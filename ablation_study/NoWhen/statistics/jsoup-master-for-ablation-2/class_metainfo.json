[{"uris": "src/test/java/org/jsoup/TextUtil.java.TextUtil", "name": "TextUtil", "file_path": "src/test/java/org/jsoup/TextUtil.java", "superclasses": "", "methods": ["[String]stripNewlines(String)", "[String]normalizeSpaces(String)", "[String]stripCRs(String)"], "method_uris": ["src/test/java/org/jsoup/TextUtil.java.TextUtil.[String]stripNewlines(String)", "src/test/java/org/jsoup/TextUtil.java.TextUtil.[String]normalizeSpaces(String)", "src/test/java/org/jsoup/TextUtil.java.TextUtil.[String]stripCRs(String)"], "overrides": null, "attributes": [], "class_docstring": "\nText utils to ease testing\n\n@author Jonathan Hedley, jonathan@hedley.net", "original_string": "public class TextUtil {\n    static Pattern stripper = Pattern.compile(\"\\\\r?\\\\n\\\\s*\");\n    static Pattern stripLines = Pattern.compile(\"\\\\r?\\\\n?\");\n    static Pattern spaceCollapse = Pattern.compile(\"\\\\s{2,}\");\n    static Pattern tagSpaceCollapse = Pattern.compile(\">\\\\s+<\");\n    static Pattern stripCRs = Pattern.compile(\"\\\\r*\");\n\n    public static String stripNewlines(String text) {\n        return stripper.matcher(text).replaceAll(\"\");\n    }\n\n    public static String normalizeSpaces(String text) {\n        text = stripLines.matcher(text).replaceAll(\"\");\n        text = stripper.matcher(text).replaceAll(\"\");\n        text = spaceCollapse.matcher(text).replaceAll(\" \");\n        text = tagSpaceCollapse.matcher(text).replaceAll(\"><\");\n        return text;\n    }\n\n    public static String stripCRs(String text) {\n        return stripCRs.matcher(text).replaceAll(\"\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static Pattern stripper = Pattern.compile(\"\\\\r?\\\\n\\\\s*\");", "docstring": "", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "Pattern", "name": "stripper = Pattern.compile(\"\\\\r?\\\\n\\\\s*\")", "syntax_pass": true}, {"attribute_expression": "static Pattern stripLines = Pattern.compile(\"\\\\r?\\\\n?\");", "docstring": "", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "Pattern", "name": "stripLines = Pattern.compile(\"\\\\r?\\\\n?\")", "syntax_pass": true}, {"attribute_expression": "static Pattern spaceCollapse = Pattern.compile(\"\\\\s{2,}\");", "docstring": "", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "Pattern", "name": "spaceCollapse = Pattern.compile(\"\\\\s{2,}\")", "syntax_pass": true}, {"attribute_expression": "static Pattern tagSpaceCollapse = Pattern.compile(\">\\\\s+<\");", "docstring": "", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "Pattern", "name": "tagSpaceCollapse = Pattern.compile(\">\\\\s+<\")", "syntax_pass": true}, {"attribute_expression": "static Pattern stripCRs = Pattern.compile(\"\\\\r*\");", "docstring": "", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "Pattern", "name": "stripCRs = Pattern.compile(\"\\\\r*\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/MultiLocaleExtension.java.MultiLocaleExtension", "name": "MultiLocaleExtension", "file_path": "src/test/java/org/jsoup/MultiLocaleExtension.java", "superclasses": "", "methods": ["[void]afterEach(ExtensionContext)", "[Stream<? extends Arguments>]provideArguments(ExtensionContext)"], "method_uris": ["src/test/java/org/jsoup/MultiLocaleExtension.java.MultiLocaleExtension.[void]afterEach(ExtensionContext)", "src/test/java/org/jsoup/MultiLocaleExtension.java.MultiLocaleExtension.[Stream<? extends Arguments>]provideArguments(ExtensionContext)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiLocaleExtension implements AfterEachCallback, ArgumentsProvider {\n    private final Locale defaultLocale = Locale.getDefault();\n\n    @Override\n    public void afterEach(ExtensionContext context) {\n        Locale.setDefault(defaultLocale);\n    }\n\n    @Override\n    public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {\n        return Stream.of(Arguments.of(Locale.ENGLISH), Arguments.arguments(new Locale(\"tr\")));\n    }\n\n\n    @Documented\n    @Target(ElementType.METHOD)\n    @Retention(RetentionPolicy.RUNTIME)\n    @ArgumentsSource(MultiLocaleExtension.class)\n    @ExtendWith(MultiLocaleExtension.class)\n    @ParameterizedTest\n    public @interface MultiLocaleTest {\n    }\n\n}", "super_interfaces": ["AfterEachCallback", "ArgumentsProvider"], "fields": [{"attribute_expression": "private final Locale defaultLocale = Locale.getDefault();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Locale", "name": "defaultLocale = Locale.getDefault()", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/helper/AuthenticationHandlerTest.java.AuthenticationHandlerTest", "name": "AuthenticationHandlerTest", "file_path": "src/test/java/org/jsoup/helper/AuthenticationHandlerTest.java", "superclasses": "", "methods": [], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class AuthenticationHandlerTest {\n    public static final int MaxAttempts = AuthenticationHandler.MaxAttempts;\n\n    // tests are in ConnectionTest, ProxyTest. This class just makes the MaxAttempts visible for test.\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int MaxAttempts = AuthenticationHandler.MaxAttempts;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MaxAttempts = AuthenticationHandler.MaxAttempts", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug", "name": "EvaluatorDebug", "file_path": "src/test/java/org/jsoup/select/EvaluatorDebug.java", "superclasses": "", "methods": ["[Document]asDocument(Evaluator)", "[Document]asDocument(String)", "[Element]asElement(Evaluator)", "[String]sexpr(String)"], "method_uris": ["src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug.[Document]asDocument(Evaluator)", "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug.[Document]asDocument(String)", "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug.[Element]asElement(Evaluator)", "src/test/java/org/jsoup/select/EvaluatorDebug.java.EvaluatorDebug.[String]sexpr(String)"], "overrides": null, "attributes": [{"original_string": "    static class SexprVisitor implements NodeVisitor {\n        StringBuilder sb = StringUtil.borrowBuilder();\n\n        @Override public void head(Node node, int depth) {\n            sb\n                .append('(')\n                .append(node.nodeName());\n\n            if (node.childNodeSize() == 0)\n                sb\n                    .append(\" '\")\n                    .append(node.attr(\"css\"))\n                    .append(\"'\");\n            else\n                sb.append(\" \");\n        }\n\n        @Override public void tail(Node node, int depth) {\n            sb.append(')');\n        }\n\n        String result() {\n            return StringUtil.releaseBuilder(sb);\n        }\n    }", "definition": "    static class SexprVisitor implements NodeVisitor", "class_docstring": "", "name": "SexprVisitor", "super_interfaces": ["NodeVisitor"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "StringBuilder sb = StringUtil.borrowBuilder();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "StringBuilder", "name": "sb = StringUtil.borrowBuilder()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override public void head(Node node, int depth) {\n            sb\n                .append('(')\n                .append(node.nodeName());\n\n            if (node.childNodeSize() == 0)\n                sb\n                    .append(\" '\")\n                    .append(node.attr(\"css\"))\n                    .append(\"'\");\n            else\n                sb.append(\" \");\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "head", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                         {\n            sb\n                .append('(')\n                .append(node.nodeName());\n\n            if (node.childNodeSize() == 0)\n                sb\n                    .append(\" '\")\n                    .append(node.attr(\"css\"))\n                    .append(\"'\");\n            else\n                sb.append(\" \");\n        }", "signature": "@Override public void head(Node node, int depth)"}, {"syntax_pass": true, "original_string": "        @Override public void tail(Node node, int depth) {\n            sb.append(')');\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tail", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                         {\n            sb.append(')');\n        }", "signature": "@Override public void tail(Node node, int depth)"}, {"syntax_pass": true, "original_string": "        String result() {\n            return StringUtil.releaseBuilder(sb);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "result", "params": [], "body": "                        {\n            return StringUtil.releaseBuilder(sb);\n        }", "signature": "String result()"}]}], "class_docstring": "", "original_string": "public class EvaluatorDebug {\n\n    /**\n     Cast an Evaluator into a pseudo Document, to help visualize the query. Quite coupled to the current impl.\n     */\n    public static Document asDocument(Evaluator eval) {\n        Document doc = new Document(null);\n        doc.outputSettings().outline(true).indentAmount(2);\n\n        Element el = asElement(eval);\n        doc.appendChild(el);\n\n        return doc;\n    }\n\n    public static Document asDocument(String query) {\n        Evaluator eval = QueryParser.parse(query);\n        return asDocument(eval);\n    }\n\n    public static Element asElement(Evaluator eval) {\n        Class<? extends Evaluator> evalClass = eval.getClass();\n        Element el = new Element(evalClass.getSimpleName());\n        el.attr(\"css\", eval.toString());\n        el.attr(\"cost\", Integer.toString(eval.cost()));\n\n        if (eval instanceof CombiningEvaluator) {\n            for (Evaluator inner : ((CombiningEvaluator) eval).sortedEvaluators) {\n                el.appendChild(asElement(inner));\n            }\n        } else if (eval instanceof StructuralEvaluator.ImmediateParentRun) {\n            for (Evaluator inner : ((StructuralEvaluator.ImmediateParentRun) eval).evaluators) {\n                el.appendChild(asElement(inner));\n            }\n        } else if (eval instanceof StructuralEvaluator) {\n            Evaluator inner = ((StructuralEvaluator) eval).evaluator;\n            el.appendChild(asElement(inner));\n        }\n\n        return el;\n    }\n\n    public static String sexpr(String query) {\n        Document doc = asDocument(query);\n\n        SexprVisitor sv = new SexprVisitor();\n        doc.childNode(0).traverse(sv); // skip outer #document\n        return sv.result();\n    }\n\n    static class SexprVisitor implements NodeVisitor {\n        StringBuilder sb = StringUtil.borrowBuilder();\n\n        @Override public void head(Node node, int depth) {\n            sb\n                .append('(')\n                .append(node.nodeName());\n\n            if (node.childNodeSize() == 0)\n                sb\n                    .append(\" '\")\n                    .append(node.attr(\"css\"))\n                    .append(\"'\");\n            else\n                sb.append(\" \");\n        }\n\n        @Override public void tail(Node node, int depth) {\n            sb.append(')');\n        }\n\n        String result() {\n            return StringUtil.releaseBuilder(sb);\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/jsoup/integration/TestServer.java.TestServer", "name": "TestServer", "file_path": "src/test/java/org/jsoup/integration/TestServer.java", "superclasses": "", "methods": ["[Server]newServer()", "[]TestServer()", "[void]start()", "[int]closeAuthedProxyConnections()", "[ServletUrls]map(Class<? extends BaseServlet>)", "[ProxySettings]proxySettings()", "[void]addHttpsConnector(File,Server)", "[void]setupDefaultTrust(File)"], "method_uris": ["src/test/java/org/jsoup/integration/TestServer.java.TestServer.[Server]newServer()", "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[]TestServer()", "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[void]start()", "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[int]closeAuthedProxyConnections()", "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[ServletUrls]map(Class<? extends BaseServlet>)", "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[ProxySettings]proxySettings()", "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[void]addHttpsConnector(File,Server)", "src/test/java/org/jsoup/integration/TestServer.java.TestServer.[void]setupDefaultTrust(File)"], "overrides": null, "attributes": [{"original_string": "    public static class ServletUrls {\n        public final String url;\n        public final String tlsUrl;\n\n        public ServletUrls(String url, String tlsUrl) {\n            this.url = url;\n            this.tlsUrl = tlsUrl;\n        }\n    }", "definition": "    public static class ServletUrls", "class_docstring": "", "name": "ServletUrls", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String url;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "url", "syntax_pass": true}, {"attribute_expression": "public final String tlsUrl;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "tlsUrl", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ServletUrls(String url, String tlsUrl) {\n            this.url = url;\n            this.tlsUrl = tlsUrl;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ServletUrls", "params": [{"name": "url", "type": "String"}, {"name": "tlsUrl", "type": "String"}], "body": "                                                      {\n            this.url = url;\n            this.tlsUrl = tlsUrl;\n        }", "signature": "public ServletUrls(String url, String tlsUrl)"}]}, {"original_string": "    public static class ProxySettings {\n        final String hostname = Localhost;\n        int port;\n        int authedPort;\n    }", "definition": "    public static class ProxySettings", "class_docstring": "public static String proxy", "name": "ProxySettings", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "final String hostname = Localhost;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "hostname = Localhost", "syntax_pass": true}, {"attribute_expression": "int port;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "port", "syntax_pass": true}, {"attribute_expression": "int authedPort;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "authedPort", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}], "class_docstring": "", "original_string": "public class TestServer {\n    static int Port;\n    static int TlsPort;\n\n    private static final String Localhost = \"localhost\";\n    private static final String KeystorePassword = \"hunter2\";\n\n    private static final Server Jetty = newServer();\n    private static final ServletHandler JettyHandler = new ServletHandler();\n    private static final Server Proxy = newServer();\n    private static final Server AuthedProxy = newServer();\n    private static final HandlerWrapper ProxyHandler = new HandlerWrapper();\n    private static final HandlerWrapper AuthedProxyHandler = new HandlerWrapper();\n    private static final ProxySettings ProxySettings = new ProxySettings();\n\n    private static Server newServer() {\n        return new Server(new InetSocketAddress(Localhost, 0));\n    }\n\n    static {\n        Jetty.setHandler(JettyHandler);\n        Proxy.setHandler(ProxyHandler);\n        AuthedProxy.setHandler(AuthedProxyHandler);\n\n        // TLS setup:\n        try {\n            File keystoreFile = ParseTest.getFile(\"/local-cert/server.pfx\");\n            if (!keystoreFile.exists()) throw new FileNotFoundException(keystoreFile.toString());\n            addHttpsConnector(keystoreFile, Jetty);\n            setupDefaultTrust(keystoreFile);\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private TestServer() {\n    }\n\n    public static void start() {\n        synchronized (Jetty) {\n            if (Jetty.isStarted()) return;\n\n            try {\n                Jetty.start();\n                JettyHandler.addFilterWithMapping(new FilterHolder(new AuthFilter(false, false)), \"/*\", FilterMapping.ALL);\n                Connector[] jcons = Jetty.getConnectors();\n                Port = ((ServerConnector) jcons[0]).getLocalPort();\n                TlsPort = ((ServerConnector) jcons[1]).getLocalPort();\n\n                ProxyHandler.setHandler(ProxyServlet.createHandler(false)); // includes proxy, CONNECT proxy, and Auth filters\n                Proxy.start();\n                ProxySettings.port = ((ServerConnector) Proxy.getConnectors()[0]).getLocalPort();\n\n                AuthedProxyHandler.setHandler(ProxyServlet.createHandler(true));\n                AuthedProxy.start();\n                ProxySettings.authedPort = ((ServerConnector) AuthedProxy.getConnectors()[0]).getLocalPort();\n            } catch (Exception e) {\n                throw new IllegalStateException(e);\n            }\n        }\n    }\n\n    /**\n     Close any current connections to the authed proxy. Tunneled connections only authenticate in their first\n     CONNECT, and may be kept alive and reused. So when we want to test unauthed - authed flows, we need to disconnect\n     them first.\n     */\n    static int closeAuthedProxyConnections() {\n        ServerConnector connector = (ServerConnector) AuthedProxy.getConnectors()[0];\n        AtomicInteger count = new AtomicInteger();\n        connector.getConnectedEndPoints().forEach(endPoint -> {\n            endPoint.close();\n            count.getAndIncrement();\n        });\n        return count.get();\n    }\n\n    public static ServletUrls map(Class<? extends BaseServlet> servletClass) {\n        synchronized (Jetty) {\n            if (!Jetty.isStarted())\n                start(); // if running out of the test cases\n\n            String path = \"/\" + servletClass.getSimpleName();\n            JettyHandler.addServletWithMapping(servletClass, path + \"/*\");\n            String url = \"http://\" + Localhost + \":\" + Port + path;\n            String tlsUrl = \"https://\" + Localhost + \":\" + TlsPort + path;\n\n            return new ServletUrls(url, tlsUrl);\n        }\n    }\n\n    public static class ServletUrls {\n        public final String url;\n        public final String tlsUrl;\n\n        public ServletUrls(String url, String tlsUrl) {\n            this.url = url;\n            this.tlsUrl = tlsUrl;\n        }\n    }\n\n    public static ProxySettings proxySettings() {\n        synchronized (Jetty) {\n            if (!Jetty.isStarted())\n                start();\n\n            return ProxySettings;\n        }\n    }\n\n    //public static String proxy\n    public static class ProxySettings {\n        final String hostname = Localhost;\n        int port;\n        int authedPort;\n    }\n\n    private static void addHttpsConnector(File keystoreFile, Server server) {\n        // Cribbed from https://github.com/jetty/jetty.project/blob/jetty-9.4.x/examples/embedded/src/main/java/org/eclipse/jetty/embedded/LikeJettyXml.java\n        SslContextFactory sslContextFactory = new SslContextFactory.Server();\n        String path = keystoreFile.getAbsolutePath();\n        sslContextFactory.setKeyStorePath(path);\n        sslContextFactory.setKeyStorePassword(KeystorePassword);\n        sslContextFactory.setKeyManagerPassword(KeystorePassword);\n        sslContextFactory.setTrustStorePath(path);\n        sslContextFactory.setTrustStorePassword(KeystorePassword);\n\n        HttpConfiguration httpConfig = new HttpConfiguration();\n        httpConfig.setSecureScheme(\"https\");\n        HttpConfiguration httpsConfig = new HttpConfiguration(httpConfig);\n        httpsConfig.addCustomizer(new SecureRequestCustomizer());\n\n        ServerConnector sslConnector = new ServerConnector(\n            server,\n            new SslConnectionFactory(sslContextFactory, HttpVersion.HTTP_1_1.asString()),\n            new HttpConnectionFactory(httpsConfig));\n        server.addConnector(sslConnector);\n    }\n\n    private static void setupDefaultTrust(File keystoreFile) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, KeyManagementException {\n        // Configure HttpsUrlConnection (jsoup) to trust (only) this cert\n        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        trustStore.load(Files.newInputStream(keystoreFile.toPath()), KeystorePassword.toCharArray());\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(trustStore);\n        TrustManager[] managers = trustManagerFactory.getTrustManagers();\n        SSLContext tls = SSLContext.getInstance(\"TLS\");\n        tls.init(null, managers, null);\n        SSLSocketFactory socketFactory = tls.getSocketFactory();\n        HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static int Port;", "docstring": "", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "int", "name": "Port", "syntax_pass": true}, {"attribute_expression": "static int TlsPort;", "docstring": "", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "int", "name": "TlsPort", "syntax_pass": true}, {"attribute_expression": "private static final String Localhost = \"localhost\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "Localhost = \"localhost\"", "syntax_pass": true}, {"attribute_expression": "private static final String KeystorePassword = \"hunter2\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "KeystorePassword = \"hunter2\"", "syntax_pass": true}, {"attribute_expression": "private static final Server Jetty = newServer();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Server", "name": "Jetty = newServer()", "syntax_pass": true}, {"attribute_expression": "private static final ServletHandler JettyHandler = new ServletHandler();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ServletHandler", "name": "JettyHandler = new ServletHandler()", "syntax_pass": true}, {"attribute_expression": "private static final Server Proxy = newServer();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Server", "name": "Proxy = newServer()", "syntax_pass": true}, {"attribute_expression": "private static final Server AuthedProxy = newServer();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Server", "name": "AuthedProxy = newServer()", "syntax_pass": true}, {"attribute_expression": "private static final HandlerWrapper ProxyHandler = new HandlerWrapper();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "HandlerWrapper", "name": "ProxyHandler = new HandlerWrapper()", "syntax_pass": true}, {"attribute_expression": "private static final HandlerWrapper AuthedProxyHandler = new HandlerWrapper();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "HandlerWrapper", "name": "AuthedProxyHandler = new HandlerWrapper()", "syntax_pass": true}, {"attribute_expression": "private static final ProxySettings ProxySettings = new ProxySettings();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ProxySettings", "name": "ProxySettings = new ProxySettings()", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/Benchmark.java.Benchmark", "name": "Benchmark", "file_path": "src/test/java/org/jsoup/integration/Benchmark.java", "superclasses": "", "methods": ["[void]run(Runnable,Runnable,int)", "[long]time(Runnable,int)", "[void]print(String)"], "method_uris": ["src/test/java/org/jsoup/integration/Benchmark.java.Benchmark.[void]run(Runnable,Runnable,int)", "src/test/java/org/jsoup/integration/Benchmark.java.Benchmark.[long]time(Runnable,int)", "src/test/java/org/jsoup/integration/Benchmark.java.Benchmark.[void]print(String)"], "overrides": null, "attributes": [], "class_docstring": "\nDoes an A/B test on two methods, and prints out how long each took.\n\n@author Jonathan Hedley, jonathan@hedley.net", "original_string": "public class Benchmark {\n    public static void run(Runnable a, Runnable b, int count) {\n        long aMillis;\n        long bMillis;\n\n        print(\"Running test A (x%d)\", count);\n        aMillis = time(a, count);\n        print(\"Running test B\");\n        bMillis = time(b, count);\n\n        print(\"\\nResults:\");\n        print(\"A: %.2fs\", aMillis / 1000f);\n        print(\"B: %.2fs\", bMillis / 1000f);\n        print(\"\\nB ran in %.2f %% time of A\\n\", (bMillis *1f / aMillis * 1f) * 100f);\n    }\n\n    private static long time(Runnable test, int count) {\n        Date start = new Date();\n        for (int i = 0; i < count; i++) {\n            test.run();\n        }\n        Date end = new Date();\n        return end.getTime() - start.getTime();\n    }\n\n    private static void print(String msgFormat, Object... msgParams) {\n        System.out.println(String.format(msgFormat, msgParams));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/jsoup/integration/servlets/DeflateServlet.java.DeflateServlet", "name": "DeflateServlet", "file_path": "src/test/java/org/jsoup/integration/servlets/DeflateServlet.java", "superclasses": "BaseServlet", "methods": ["[void]doIt(HttpServletRequest,HttpServletResponse)", "[void]main(String[])"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/DeflateServlet.java.DeflateServlet.[void]doIt(HttpServletRequest,HttpServletResponse)", "src/test/java/org/jsoup/integration/servlets/DeflateServlet.java.DeflateServlet.[void]main(String[])"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DeflateServlet extends BaseServlet {\n    public static final String Url;\n    public static final String TlsUrl;\n    static {\n        TestServer.ServletUrls urls = TestServer.map(DeflateServlet.class);\n        Url = urls.url;\n        TlsUrl = urls.tlsUrl;\n    }\n\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        res.setContentType(TextHtml);\n        res.setStatus(HttpServletResponse.SC_OK);\n        res.setHeader(\"Content-Encoding\", \"deflate\");\n\n        String doc = \"<p>Hello, World!<p>That should be enough, right?<p>Hello, World!<p>That should be enough, right?\";\n\n        DeflaterOutputStream stream = new DeflaterOutputStream(\n            res.getOutputStream(),\n            new Deflater(Deflater.BEST_COMPRESSION, true)); // true = nowrap zlib headers\n\n       stream.write(doc.getBytes(StandardCharsets.UTF_8));\n       stream.close();\n    }\n\n    // allow the servlet to run as a main program, for local test\n    public static void main(String[] args) {\n        TestServer.start();\n        System.out.println(Url);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String Url;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Url", "syntax_pass": true}, {"attribute_expression": "public static final String TlsUrl;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TlsUrl", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter", "name": "AuthFilter", "file_path": "src/test/java/org/jsoup/integration/servlets/AuthFilter.java", "superclasses": "", "methods": ["[]AuthFilter(boolean,boolean)", "[String]newPassword()", "[String]newServerPassword()", "[String]newProxyPassword()", "[void]init(FilterConfig)", "[void]doFilter(ServletRequest,ServletResponse,FilterChain)", "[void]destroy()", "[boolean]checkAuth(HttpServletRequest)"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[]AuthFilter(boolean,boolean)", "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[String]newPassword()", "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[String]newServerPassword()", "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[String]newProxyPassword()", "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[void]init(FilterConfig)", "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[void]doFilter(ServletRequest,ServletResponse,FilterChain)", "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[void]destroy()", "src/test/java/org/jsoup/integration/servlets/AuthFilter.java.AuthFilter.[boolean]checkAuth(HttpServletRequest)"], "overrides": null, "attributes": [], "class_docstring": "\nA filter to test basic authenticated requests. If the request header \"X-Wants-Authentication\" is set, or if\nalwaysWantsAuth is enabled, the filter is invoked, and requests must send the correct user authentication details.\n", "original_string": "public class AuthFilter implements Filter {\n    public static final String WantsServerAuthentication = \"X-Wants-ServerAuthentication\";\n    public static final String ServerUser = \"admin\";\n    public static final String ServerRealm = \"jsoup test server authentication realm\";\n    private static volatile String ServerPassword = newServerPassword();\n\n    public static final String WantsProxyAuthentication = \"X-Wants-ProxyAuthentication\";\n    public static final String ProxyUser = \"foxyproxy\";\n    public static final String ProxyRealm = \"jsoup test proxy authentication realm\";\n    private static volatile String ProxyPassword = newProxyPassword();\n\n    private final boolean alwaysWantsAuth; // we run a particular port that always wants auth - so the CONNECT tunnels can be authed. (The Java proxy tunnel CONNECT request strips the wants-auth headers)\n    private final boolean forProxy;\n    private final String wantsHeader;\n    private final String authorizationHeader;\n\n    /**\n     Creates an Authentication Filter with hardcoded credential expectations.\n     * @param alwaysWantsAuth true if this filter should always check for authentication, regardless of the Wants Auth header\n     * @param forProxy true if this wraps a Proxy and should use Proxy-Authenticate headers, credentials etc. False\n     * if wrapping the web server.\n     */\n    public AuthFilter(boolean alwaysWantsAuth, boolean forProxy) {\n        this.alwaysWantsAuth = alwaysWantsAuth;\n        this.forProxy = forProxy;\n\n        wantsHeader = forProxy ? WantsProxyAuthentication : WantsServerAuthentication;\n        authorizationHeader = forProxy ? \"Proxy-Authorization\" : \"Authorization\";\n    }\n\n    private static String newPassword() {\n        return \"pass-\" + Math.random();\n    }\n\n    // passwords get rotated in tests so that Java's auth cache is invalidated and a new auth callback occurs.\n    // requires tests hitting these are called serially.\n    public static String newServerPassword() {\n        return ServerPassword = newPassword() + \"-server\";\n    }\n\n    public static String newProxyPassword() {\n        return ProxyPassword = newPassword() + \"-proxy\";\n    }\n\n    @Override public void init(FilterConfig filterConfig) throws ServletException {}\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse res = (HttpServletResponse) response;\n\n        boolean accessGranted = checkAuth(req);\n        if (accessGranted) {\n            chain.doFilter(request, response);\n            return;\n        }\n\n        // Wants but failed auth - send appropriate header:\n        if (forProxy) {\n            res.setHeader(\"Proxy-Authenticate\", \"Basic realm=\\\"\" + ProxyRealm + \"\\\"\");\n            // ^^ Duped in ProxyServlet for CONNECT\n            res.sendError(HttpServletResponse.SC_PROXY_AUTHENTICATION_REQUIRED);\n        } else {\n            res.setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"\" + ServerRealm + \"\\\"\");\n            res.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n        }\n    }\n\n    @Override public void destroy() {}\n\n    public boolean checkAuth(HttpServletRequest req) {\n        if (alwaysWantsAuth || req.getHeader(wantsHeader) != null) {\n            String authHeader = req.getHeader(authorizationHeader);\n            if (authHeader != null) {\n                int space = authHeader.indexOf(' ');\n                if (space > 0) {\n                    String value = authHeader.substring(space + 1);\n                    String expected = forProxy ?\n                        (ProxyUser + \":\" + ProxyPassword) :\n                        (ServerUser + \":\" + ServerPassword);\n                    String base64 = Base64.getEncoder().encodeToString(expected.getBytes(StandardCharsets.UTF_8));\n                    return base64.equals(value); // if passed auth\n                }\n            }\n            return false; // unexpected header value\n        }\n        return true; // auth not required\n    }\n}", "super_interfaces": ["Filter"], "fields": [{"attribute_expression": "public static final String WantsServerAuthentication = \"X-Wants-ServerAuthentication\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "WantsServerAuthentication = \"X-Wants-ServerAuthentication\"", "syntax_pass": true}, {"attribute_expression": "public static final String ServerUser = \"admin\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ServerUser = \"admin\"", "syntax_pass": true}, {"attribute_expression": "public static final String ServerRealm = \"jsoup test server authentication realm\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ServerRealm = \"jsoup test server authentication realm\"", "syntax_pass": true}, {"attribute_expression": "private static volatile String ServerPassword = newServerPassword();", "docstring": "", "modifiers": "private static volatile", "marker_annotations": [], "non_marker_annotations": ["private", "static", "volatile"], "comments": [], "type": "String", "name": "ServerPassword = newServerPassword()", "syntax_pass": true}, {"attribute_expression": "public static final String WantsProxyAuthentication = \"X-Wants-ProxyAuthentication\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "WantsProxyAuthentication = \"X-Wants-ProxyAuthentication\"", "syntax_pass": true}, {"attribute_expression": "public static final String ProxyUser = \"foxyproxy\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ProxyUser = \"foxyproxy\"", "syntax_pass": true}, {"attribute_expression": "public static final String ProxyRealm = \"jsoup test proxy authentication realm\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ProxyRealm = \"jsoup test proxy authentication realm\"", "syntax_pass": true}, {"attribute_expression": "private static volatile String ProxyPassword = newProxyPassword();", "docstring": "", "modifiers": "private static volatile", "marker_annotations": [], "non_marker_annotations": ["private", "static", "volatile"], "comments": [], "type": "String", "name": "ProxyPassword = newProxyPassword()", "syntax_pass": true}, {"attribute_expression": "private final boolean alwaysWantsAuth;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "alwaysWantsAuth", "syntax_pass": true}, {"attribute_expression": "private final boolean forProxy;", "docstring": " we run a particular port that always wants auth - so the CONNECT tunnels can be authed. (The Java proxy tunnel CONNECT request strips the wants-auth headers)", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "forProxy", "syntax_pass": true}, {"attribute_expression": "private final String wantsHeader;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "wantsHeader", "syntax_pass": true}, {"attribute_expression": "private final String authorizationHeader;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "authorizationHeader", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/servlets/InterruptedServlet.java.InterruptedServlet", "name": "InterruptedServlet", "file_path": "src/test/java/org/jsoup/integration/servlets/InterruptedServlet.java", "superclasses": "BaseServlet", "methods": ["[void]doIt(HttpServletRequest,HttpServletResponse)"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/InterruptedServlet.java.InterruptedServlet.[void]doIt(HttpServletRequest,HttpServletResponse)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class InterruptedServlet extends BaseServlet {\n    public static final String Url;\n    public static final String TlsUrl;\n    static {\n        TestServer.ServletUrls urls = TestServer.map(InterruptedServlet.class);\n        Url = urls.url;\n        TlsUrl = urls.tlsUrl;\n    }\n    public static final String Magnitude = \"magnitude\";\n    public static final String Larger = \"larger\";\n\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String magnitude = req.getParameter(Magnitude);\n        magnitude  = magnitude == null ? \"\" : magnitude;\n        res.setContentType(TextHtml);\n        res.setStatus(HttpServletResponse.SC_OK);\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<title>Something</title>\");\n        while (sb.length() <= 32 * 1024) {\n            sb.append(\"<div>A suitable amount of data.</div>\\n\");\n        }\n        sb.append(\"<p>Finale.</p>\");\n        String data = sb.toString();\n\n        int contentLength = magnitude.equals(Larger) ? data.length() * 2 : data.length() / 2;\n        res.setContentLength(contentLength);\n\n        res.getWriter().write(data);\n\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String Url;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Url", "syntax_pass": true}, {"attribute_expression": "public static final String TlsUrl;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TlsUrl", "syntax_pass": true}, {"attribute_expression": "public static final String Magnitude = \"magnitude\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Magnitude = \"magnitude\"", "syntax_pass": true}, {"attribute_expression": "public static final String Larger = \"larger\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Larger = \"larger\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/servlets/RedirectServlet.java.RedirectServlet", "name": "RedirectServlet", "file_path": "src/test/java/org/jsoup/integration/servlets/RedirectServlet.java", "superclasses": "BaseServlet", "methods": ["[void]doIt(HttpServletRequest,HttpServletResponse)"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/RedirectServlet.java.RedirectServlet.[void]doIt(HttpServletRequest,HttpServletResponse)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RedirectServlet extends BaseServlet {\n    public static final String Url;\n    public static final String TlsUrl;\n    static {\n        TestServer.ServletUrls urls = TestServer.map(RedirectServlet.class);\n        Url = urls.url;\n        TlsUrl = urls.tlsUrl;\n    }\n    public static final String LocationParam = \"loc\";\n    public static final String CodeParam = \"code\";\n    public static final String SetCookiesParam = \"setCookies\";\n    private static final int DefaultCode = HttpServletResponse.SC_MOVED_TEMPORARILY;\n\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String location = req.getParameter(LocationParam);\n        if (location == null)\n            location = \"\";\n\n        int intCode = DefaultCode;\n        String code = req.getParameter(CodeParam);\n        if (code != null)\n            intCode = Integer.parseInt(code);\n\n        if (req.getParameter(SetCookiesParam) != null) {\n            res.addCookie(new Cookie(\"token\", \"asdfg123\"));\n            res.addCookie(new Cookie(\"uid\", \"foobar\"));\n            res.addCookie(new Cookie(\"uid\", \"jhy\")); // dupe, should use latter\n        }\n\n        res.setHeader(\"Location\", location);\n        res.setStatus(intCode);\n        res.flushBuffer();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String Url;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Url", "syntax_pass": true}, {"attribute_expression": "public static final String TlsUrl;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TlsUrl", "syntax_pass": true}, {"attribute_expression": "public static final String LocationParam = \"loc\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "LocationParam = \"loc\"", "syntax_pass": true}, {"attribute_expression": "public static final String CodeParam = \"code\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "CodeParam = \"code\"", "syntax_pass": true}, {"attribute_expression": "public static final String SetCookiesParam = \"setCookies\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "SetCookiesParam = \"setCookies\"", "syntax_pass": true}, {"attribute_expression": "private static final int DefaultCode = HttpServletResponse.SC_MOVED_TEMPORARILY;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DefaultCode = HttpServletResponse.SC_MOVED_TEMPORARILY", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/servlets/CookieServlet.java.CookieServlet", "name": "CookieServlet", "file_path": "src/test/java/org/jsoup/integration/servlets/CookieServlet.java", "superclasses": "BaseServlet", "methods": ["[void]doIt(HttpServletRequest,HttpServletResponse)", "[void]setCookies(HttpServletResponse)"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/CookieServlet.java.CookieServlet.[void]doIt(HttpServletRequest,HttpServletResponse)", "src/test/java/org/jsoup/integration/servlets/CookieServlet.java.CookieServlet.[void]setCookies(HttpServletResponse)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CookieServlet extends BaseServlet {\n    public static final String Url;\n    public static final String TlsUrl;\n    static {\n        TestServer.ServletUrls urls = TestServer.map(CookieServlet.class);\n        Url = urls.url;\n        TlsUrl = urls.tlsUrl;\n    }\n    public static final String SetCookiesParam = \"setCookies\";\n    public static final String LocationParam = \"loc\";\n\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        // Do we want to set cookies?\n        if (req.getParameter(SetCookiesParam) != null)\n            setCookies(res);\n\n        // Do we want to redirect elsewhere?\n        String loc = req.getParameter(LocationParam);\n        if (loc != null) {\n            res.sendRedirect(loc);\n            return;\n        }\n\n        // print out the cookies that were received\n        res.setContentType(TextHtml);\n        res.setStatus(200);\n\n        PrintWriter w = res.getWriter();\n        w.println(\"<table>\");\n        final Cookie[] cookies = req.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                EchoServlet.write(w, cookie.getName(), cookie.getValue());\n            }\n        }\n        w.println(\"</table>\");\n    }\n\n    private void setCookies(HttpServletResponse res) {\n        Cookie one = new Cookie(\"One\", \"Root\");\n        one.setPath(\"/\");\n        res.addCookie(one);\n\n        Cookie two = new Cookie(\"One\", \"CookieServlet\");\n        two.setPath(\"/CookieServlet\");\n        two.setHttpOnly(true);\n        two.setComment(\"Quite nice\");\n        res.addCookie(two);\n\n        Cookie three = new Cookie(\"One\", \"EchoServlet\");\n        three.setPath(\"/EchoServlet\");\n        res.addCookie(three);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String Url;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Url", "syntax_pass": true}, {"attribute_expression": "public static final String TlsUrl;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TlsUrl", "syntax_pass": true}, {"attribute_expression": "public static final String SetCookiesParam = \"setCookies\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "SetCookiesParam = \"setCookies\"", "syntax_pass": true}, {"attribute_expression": "public static final String LocationParam = \"loc\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "LocationParam = \"loc\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet", "name": "FileServlet", "file_path": "src/test/java/org/jsoup/integration/servlets/FileServlet.java", "superclasses": "BaseServlet", "methods": ["[void]doIt(HttpServletRequest,HttpServletResponse)", "[String]urlTo(String)", "[String]tlsUrlTo(String)"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet.[void]doIt(HttpServletRequest,HttpServletResponse)", "src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet.[String]urlTo(String)", "src/test/java/org/jsoup/integration/servlets/FileServlet.java.FileServlet.[String]tlsUrlTo(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FileServlet extends BaseServlet {\n    public static final String Url;\n    public static final String TlsUrl;\n    static {\n        TestServer.ServletUrls urls = TestServer.map(FileServlet.class);\n        Url = urls.url;\n        TlsUrl = urls.tlsUrl;\n    }\n    public static final String ContentTypeParam = \"contentType\";\n    public static final String DefaultType = \"text/html\";\n    public static final String SuppressContentLength = \"surpriseMe\";\n\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        String contentType = req.getParameter(ContentTypeParam);\n        if (contentType == null)\n            contentType = DefaultType;\n        String location = req.getPathInfo();\n\n        File file = ParseTest.getFile(location);\n        if (file.exists()) {\n            res.setContentType(contentType);\n            if (file.getName().endsWith(\"gz\"))\n                res.addHeader(\"Content-Encoding\", \"gzip\");\n            if (req.getParameter(SuppressContentLength) == null)\n                res.setContentLength((int) file.length());\n            res.setStatus(HttpServletResponse.SC_OK);\n\n            ServletOutputStream out = res.getOutputStream();\n            Files.copy(file.toPath(), out);\n            out.flush();\n        } else {\n            res.sendError(HttpServletResponse.SC_NOT_FOUND);\n        }\n    }\n\n    public static String urlTo(String path) {\n        return Url + path;\n    }\n\n    public static String tlsUrlTo(String path) {\n        return TlsUrl + path;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String Url;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Url", "syntax_pass": true}, {"attribute_expression": "public static final String TlsUrl;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TlsUrl", "syntax_pass": true}, {"attribute_expression": "public static final String ContentTypeParam = \"contentType\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ContentTypeParam = \"contentType\"", "syntax_pass": true}, {"attribute_expression": "public static final String DefaultType = \"text/html\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DefaultType = \"text/html\"", "syntax_pass": true}, {"attribute_expression": "public static final String SuppressContentLength = \"surpriseMe\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "SuppressContentLength = \"surpriseMe\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/servlets/ProxyServlet.java.ProxyServlet", "name": "ProxyServlet", "file_path": "src/test/java/org/jsoup/integration/servlets/ProxyServlet.java", "superclasses": "AsyncProxyServlet", "methods": ["[Handler]createHandler(boolean)", "[void]onServerResponseHeaders(HttpServletRequest,HttpServletResponse,Response)"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/ProxyServlet.java.ProxyServlet.[Handler]createHandler(boolean)", "src/test/java/org/jsoup/integration/servlets/ProxyServlet.java.ProxyServlet.[void]onServerResponseHeaders(HttpServletRequest,HttpServletResponse,Response)"], "overrides": null, "attributes": [{"original_string": "    static class ConnectProxy extends ConnectHandler {\n        final AuthFilter authFilter;\n\n        public ConnectProxy(AuthFilter authFilter) {\n            this.authFilter = authFilter;\n        }\n\n        @Override\n        protected boolean handleAuthentication(HttpServletRequest req, HttpServletResponse res, String address) {\n            boolean accessGranted = authFilter.checkAuth(req);\n            //System.err.println(\"CONNECT AUTH: \" + accessGranted);\n\n            // need to add the desired auth header if not granted. Returning false here will also send 407 header\n            if (!accessGranted) {\n                res.setHeader(\"Proxy-Authenticate\", \"Basic realm=\\\"\" + ProxyRealm + \"\\\"\");\n            }\n            return accessGranted;\n        }\n    }", "definition": "    static class ConnectProxy extends ConnectHandler", "class_docstring": " Supports CONNECT tunnels", "name": "ConnectProxy", "super_interfaces": [], "superclasses": "ConnectHandler", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final AuthFilter authFilter;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "AuthFilter", "name": "authFilter", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ConnectProxy(AuthFilter authFilter) {\n            this.authFilter = authFilter;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ConnectProxy", "params": [{"name": "authFilter", "type": "AuthFilter"}], "body": "                                                   {\n            this.authFilter = authFilter;\n        }", "signature": "public ConnectProxy(AuthFilter authFilter)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected boolean handleAuthentication(HttpServletRequest req, HttpServletResponse res, String address) {\n            boolean accessGranted = authFilter.checkAuth(req);\n            //System.err.println(\"CONNECT AUTH: \" + accessGranted);\n\n            // need to add the desired auth header if not granted. Returning false here will also send 407 header\n            if (!accessGranted) {\n                res.setHeader(\"Proxy-Authenticate\", \"Basic realm=\\\"\" + ProxyRealm + \"\\\"\");\n            }\n            return accessGranted;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "handleAuthentication", "params": [{"name": "req", "type": "HttpServletRequest"}, {"name": "res", "type": "HttpServletResponse"}, {"name": "address", "type": "String"}], "body": "                                                                                                                {\n            boolean accessGranted = authFilter.checkAuth(req);\n            //System.err.println(\"CONNECT AUTH: \" + accessGranted);\n\n            // need to add the desired auth header if not granted. Returning false here will also send 407 header\n            if (!accessGranted) {\n                res.setHeader(\"Proxy-Authenticate\", \"Basic realm=\\\"\" + ProxyRealm + \"\\\"\");\n            }\n            return accessGranted;\n        }", "signature": "@Override\n        protected boolean handleAuthentication(HttpServletRequest req, HttpServletResponse res, String address)"}]}], "class_docstring": "", "original_string": "public class ProxyServlet extends AsyncProxyServlet {\n    public static TestServer.ProxySettings ProxySettings = TestServer.proxySettings();\n    public static String Via = \"1.1 jsoup test proxy\";\n\n    static {\n        System.setProperty(\"jdk.http.auth.tunneling.disabledSchemes\", \"\");\n        // removes Basic, which is otherwise excluded from auth for CONNECT tunnels\n    }\n\n    public static Handler createHandler(boolean alwaysAuth) {\n        // ConnectHandler wraps this ProxyServlet and handles CONNECT, which sets up a tunnel for HTTPS requests and is\n        // opaque to the proxy. The ProxyServlet handles simple HTTP requests.\n        AuthFilter authFilter = new AuthFilter(alwaysAuth, true);\n        ConnectHandler connectHandler = new ConnectProxy(authFilter);\n        ServletHandler proxyHandler = new ServletHandler();\n        proxyHandler.addFilterWithMapping(new FilterHolder(authFilter), \"/*\", FilterMapping.ALL); // auth for HTTP proxy\n        ServletHolder proxyServletHolder = new ServletHolder(ProxyServlet.class); // Holder wraps as it requires maxThreads initialization\n        proxyServletHolder.setAsyncSupported(true);\n        proxyServletHolder.setInitParameter(\"maxThreads\", \"8\");\n        proxyHandler.addServletWithMapping(proxyServletHolder, \"/*\");\n        connectHandler.setHandler(proxyHandler);\n\n        return connectHandler;\n    }\n\n    @Override\n    protected void onServerResponseHeaders(HttpServletRequest clientRequest, HttpServletResponse proxyResponse, Response serverResponse) {\n        super.onServerResponseHeaders(clientRequest, proxyResponse, serverResponse);\n        proxyResponse.addHeader(\"Via\", Via);\n    }\n\n    /** Supports CONNECT tunnels */\n    static class ConnectProxy extends ConnectHandler {\n        final AuthFilter authFilter;\n\n        public ConnectProxy(AuthFilter authFilter) {\n            this.authFilter = authFilter;\n        }\n\n        @Override\n        protected boolean handleAuthentication(HttpServletRequest req, HttpServletResponse res, String address) {\n            boolean accessGranted = authFilter.checkAuth(req);\n            //System.err.println(\"CONNECT AUTH: \" + accessGranted);\n\n            // need to add the desired auth header if not granted. Returning false here will also send 407 header\n            if (!accessGranted) {\n                res.setHeader(\"Proxy-Authenticate\", \"Basic realm=\\\"\" + ProxyRealm + \"\\\"\");\n            }\n            return accessGranted;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static TestServer.ProxySettings ProxySettings = TestServer.proxySettings();", "docstring": "", "modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "type": "TestServer.ProxySettings", "name": "ProxySettings = TestServer.proxySettings()", "syntax_pass": true}, {"attribute_expression": "public static String Via = \"1.1 jsoup test proxy\";", "docstring": "", "modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "type": "String", "name": "Via = \"1.1 jsoup test proxy\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet", "name": "EchoServlet", "file_path": "src/test/java/org/jsoup/integration/servlets/EchoServlet.java", "superclasses": "BaseServlet", "methods": ["[void]doIt(HttpServletRequest,HttpServletResponse)", "[void]write(PrintWriter,String,String)", "[void]main(String[])", "[boolean]maybeEnableMultipart(HttpServletRequest)"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet.[void]doIt(HttpServletRequest,HttpServletResponse)", "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet.[void]write(PrintWriter,String,String)", "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet.[void]main(String[])", "src/test/java/org/jsoup/integration/servlets/EchoServlet.java.EchoServlet.[boolean]maybeEnableMultipart(HttpServletRequest)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class EchoServlet extends BaseServlet {\n    public static final String CodeParam = \"code\";\n    private static final int DefaultCode = HttpServletResponse.SC_OK;\n    public static final String Url;\n    public static final String TlsUrl;\n    static {\n        TestServer.ServletUrls urls = TestServer.map(EchoServlet.class);\n        Url = urls.url;\n        TlsUrl = urls.tlsUrl;\n    }\n\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        int intCode = DefaultCode;\n        String code = req.getHeader(CodeParam);\n        if (code != null)\n            intCode = Integer.parseInt(code);\n\n        boolean isMulti = maybeEnableMultipart(req);\n\n        res.setContentType(TextHtml);\n        res.setStatus(intCode);\n        // no-cache headers for test\n        res.addHeader(\"Cache-Control\", \"no-cache\");\n        res.addHeader(\"Cache-Control\", \"no-store\");\n\n        PrintWriter w = res.getWriter();\n\n        w.write(\"<title>Webserver Environment Variables</title>\\n\" +\n            \"    <style type=\\\"text/css\\\">\\n\" +\n            \"      body, td, th {font: 10pt Verdana, Arial, sans-serif; text-align: left}\\n\" +\n            \"      th {font-weight: bold}        \\n\" +\n            \"    </style>\\n\" +\n            \"    <body>\\n\" +\n            \"    <table border=\\\"0\\\">\");\n\n        // some get items\n        write(w, \"Method\", req.getMethod());\n        write(w, \"Request URI\", req.getRequestURI());\n        write(w, \"Path Info\", req.getPathInfo());\n        write(w, \"Query String\", req.getQueryString());\n\n        // request headers (why is it an enumeration?)\n        Enumeration<String> headerNames = req.getHeaderNames();\n        while (headerNames.hasMoreElements()) {\n            String header = headerNames.nextElement();\n            Enumeration<String> headers = req.getHeaders(header);\n            while (headers.hasMoreElements()) {\n                write(w, header, headers.nextElement());\n            }\n        }\n\n        // cookies\n        final Cookie[] cookies = req.getCookies();\n        if (cookies != null) {\n            for (Cookie cookie : cookies) {\n                EchoServlet.write(w, \"Cookie: \" + cookie.getName(), cookie.getValue());\n            }\n        }\n\n        // the request params\n        Enumeration<String> parameterNames = req.getParameterNames();\n        while (parameterNames.hasMoreElements()) {\n            String name = parameterNames.nextElement();\n            String[] values = req.getParameterValues(name);\n            write(w, name, StringUtil.join(values, \", \"));\n        }\n\n        // post body\n        ByteBuffer byteBuffer = DataUtil.readToByteBuffer(req.getInputStream(), 0);\n        String postData = new String(byteBuffer.array(), byteBuffer.arrayOffset(), byteBuffer.limit(), StandardCharsets.UTF_8);\n        if (!StringUtil.isBlank(postData)) {\n            write(w, \"Post Data\", postData);\n        }\n\n        // file uploads\n        if (isMulti) {\n            Collection<Part> parts = req.getParts();\n            write(w, \"Parts\", String.valueOf(parts.size()));\n\n            for (Part part : parts) {\n                String name = part.getName();\n                write(w, \"Part \" + name + \" ContentType\", part.getContentType());\n                write(w, \"Part \" + name + \" Name\", name);\n                write(w, \"Part \" + name + \" Filename\", part.getSubmittedFileName());\n                write(w, \"Part \" + name + \" Size\", String.valueOf(part.getSize()));\n                part.delete();\n            }\n        }\n\n        w.println(\"</table>\");\n    }\n\n    static void write(PrintWriter w, String key, String val) {\n        w.println(\"<tr><th>\" + escape(key) + \"</th><td>\" + escape(val) + \"</td></tr>\");\n    }\n\n    // allow the servlet to run as a main program, for local test\n    public static void main(String[] args) {\n        TestServer.start();\n        System.out.println(\"Listening on \" + Url + \" and \" + TlsUrl);\n    }\n\n    private static boolean maybeEnableMultipart(HttpServletRequest req) {\n        boolean isMulti = req.getContentType() != null\n            && req.getContentType().startsWith(\"multipart/form-data\");\n\n        if (isMulti) {\n            req.setAttribute(Request.MULTIPART_CONFIG_ELEMENT, new MultipartConfigElement(\n                System.getProperty(\"java.io.tmpdir\")));\n        }\n        return isMulti;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String CodeParam = \"code\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "CodeParam = \"code\"", "syntax_pass": true}, {"attribute_expression": "private static final int DefaultCode = HttpServletResponse.SC_OK;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DefaultCode = HttpServletResponse.SC_OK", "syntax_pass": true}, {"attribute_expression": "public static final String Url;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Url", "syntax_pass": true}, {"attribute_expression": "public static final String TlsUrl;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TlsUrl", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider", "name": "SlowRider", "file_path": "src/test/java/org/jsoup/integration/servlets/SlowRider.java", "superclasses": "BaseServlet", "methods": ["[void]doIt(HttpServletRequest,HttpServletResponse)", "[boolean]pause(int)", "[void]main(String[])"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider.[void]doIt(HttpServletRequest,HttpServletResponse)", "src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider.[boolean]pause(int)", "src/test/java/org/jsoup/integration/servlets/SlowRider.java.SlowRider.[void]main(String[])"], "overrides": null, "attributes": [], "class_docstring": "\nSlowly, interminably writes output. For the purposes of testing timeouts and interrupts.\n", "original_string": "public class SlowRider extends BaseServlet {\n    public static final String Url;\n    public static final String TlsUrl;\n    static {\n        TestServer.ServletUrls urls = TestServer.map(SlowRider.class);\n        Url = urls.url;\n        TlsUrl = urls.tlsUrl;\n    }\n    private static final int SleepTime = 2000;\n    public static final String MaxTimeParam = \"maxTime\";\n    public static final String IntroSizeParam = \"introSize\";\n\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        pause(1000);\n        res.setContentType(TextHtml);\n        res.setStatus(HttpServletResponse.SC_OK);\n        PrintWriter w = res.getWriter();\n\n        int maxTime = -1;\n        String maxTimeP = req.getParameter(MaxTimeParam);\n        if (maxTimeP != null) {\n            maxTime = Integer.parseInt(maxTimeP);\n        }\n\n        int introSize = 0;\n        String introSizeP = req.getParameter(IntroSizeParam);\n        if (introSizeP != null) {\n            introSize = Integer.parseInt(introSizeP);\n        }\n\n        long startTime = System.currentTimeMillis();\n        w.println(\"<title>Slow Rider</title>\");\n\n        // write out a bunch of stuff at the start before interim pauses, gets past some buffers\n        if (introSize != 0) {\n            StringBuilder s = new StringBuilder();\n            while (s.length() < introSize) {\n                s.append(\"<p>Hello and welcome to the Slow Rider!</p>\\n\");\n            }\n            w.println(s);\n            w.flush();\n        }\n\n        while (true) {\n            w.println(\"<p>Are you still there?\");\n            boolean err = w.checkError(); // flush, and check still ok\n            if (err) {\n                log(\"Remote connection lost\");\n                break;\n            }\n            if (pause(SleepTime)) break;\n\n            if (maxTime > 0 && System.currentTimeMillis() > startTime + maxTime) {\n                w.println(\"<h1>outatime</h1>\");\n                break;\n            }\n        }\n    }\n\n    private static boolean pause(int sleepTime) {\n        try {\n            Thread.sleep(sleepTime);\n        } catch (InterruptedException e) {\n            return true;\n        }\n        return false;\n    }\n\n    // allow the servlet to run as a main program, for local test\n    public static void main(String[] args) {\n        TestServer.start();\n        System.out.println(Url);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String Url;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Url", "syntax_pass": true}, {"attribute_expression": "public static final String TlsUrl;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TlsUrl", "syntax_pass": true}, {"attribute_expression": "private static final int SleepTime = 2000;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "SleepTime = 2000", "syntax_pass": true}, {"attribute_expression": "public static final String MaxTimeParam = \"maxTime\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "MaxTimeParam = \"maxTime\"", "syntax_pass": true}, {"attribute_expression": "public static final String IntroSizeParam = \"introSize\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "IntroSizeParam = \"introSize\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/integration/servlets/HelloServlet.java.HelloServlet", "name": "HelloServlet", "file_path": "src/test/java/org/jsoup/integration/servlets/HelloServlet.java", "superclasses": "BaseServlet", "methods": ["[void]doIt(HttpServletRequest,HttpServletResponse)"], "method_uris": ["src/test/java/org/jsoup/integration/servlets/HelloServlet.java.HelloServlet.[void]doIt(HttpServletRequest,HttpServletResponse)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class HelloServlet extends BaseServlet {\n    public static final String Url;\n    public static final String TlsUrl;\n    static {\n        TestServer.ServletUrls urls = TestServer.map(HelloServlet.class);\n        Url = urls.url;\n        TlsUrl = urls.tlsUrl;\n    }\n\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        res.setContentType(TextHtml);\n        res.setStatus(HttpServletResponse.SC_OK);\n\n        String doc = \"<p>Hello, World!\";\n        res.getWriter().write(doc);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String Url;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Url", "syntax_pass": true}, {"attribute_expression": "public static final String TlsUrl;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TlsUrl", "syntax_pass": true}]}, {"uris": "src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest", "name": "ParserSettingsTest", "file_path": "src/test/java/org/jsoup/parser/ParserSettingsTest.java", "superclasses": "", "methods": ["[void]caseSupport(Locale)", "[void]attributeCaseNormalization(Locale)", "[void]attributesCaseNormalization(Locale)"], "method_uris": ["src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest.[void]caseSupport(Locale)", "src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest.[void]attributeCaseNormalization(Locale)", "src/test/java/org/jsoup/parser/ParserSettingsTest.java.ParserSettingsTest.[void]attributesCaseNormalization(Locale)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ParserSettingsTest {\n    @MultiLocaleTest\n    public void caseSupport(Locale locale) {\n        Locale.setDefault(locale);\n\n        ParseSettings bothOn = new ParseSettings(true, true);\n        ParseSettings bothOff = new ParseSettings(false, false);\n        ParseSettings tagOn = new ParseSettings(true, false);\n        ParseSettings attrOn = new ParseSettings(false, true);\n\n        assertEquals(\"IMG\", bothOn.normalizeTag(\"IMG\"));\n        assertEquals(\"ID\", bothOn.normalizeAttribute(\"ID\"));\n\n        assertEquals(\"img\", bothOff.normalizeTag(\"IMG\"));\n        assertEquals(\"id\", bothOff.normalizeAttribute(\"ID\"));\n\n        assertEquals(\"IMG\", tagOn.normalizeTag(\"IMG\"));\n        assertEquals(\"id\", tagOn.normalizeAttribute(\"ID\"));\n\n        assertEquals(\"img\", attrOn.normalizeTag(\"IMG\"));\n        assertEquals(\"ID\", attrOn.normalizeAttribute(\"ID\"));\n    }\n\n    @MultiLocaleTest\n    public void attributeCaseNormalization(Locale locale) {\n        Locale.setDefault(locale);\n\n        ParseSettings parseSettings = new ParseSettings(false, false);\n        String normalizedAttribute = parseSettings.normalizeAttribute(\"HIDDEN\");\n\n        assertEquals(\"hidden\", normalizedAttribute);\n    }\n\n    @MultiLocaleTest\n    public void attributesCaseNormalization(Locale locale) {\n        Locale.setDefault(locale);\n\n        ParseSettings parseSettings = new ParseSettings(false, false);\n        Attributes attributes = new Attributes();\n        attributes.put(\"ITEM\", \"1\");\n\n        Attributes normalizedAttributes = parseSettings.normalizeAttributes(attributes);\n\n        assertEquals(\"item\", normalizedAttributes.asList().get(0).getKey());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities", "name": "BuildEntities", "file_path": "src/test/java/org/jsoup/nodes/BuildEntities.java", "superclasses": "", "methods": ["[void]main(String[])", "[void]persist(String,ArrayList<CharacterRef>)", "[String]d(int)"], "method_uris": ["src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities.[void]main(String[])", "src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities.[void]persist(String,ArrayList<CharacterRef>)", "src/test/java/org/jsoup/nodes/BuildEntities.java.BuildEntities.[String]d(int)"], "overrides": null, "attributes": [{"original_string": "    private static class CharacterRef {\n        int[] codepoints;\n        String name;\n        int codeIndex;\n\n        @Override\n        public String toString() {\n            return name\n                + \"=\"\n                + d(codepoints[0])\n                + (codepoints.length > 1 ? \",\" + d(codepoints[1]) : \"\")\n                + \";\" + d(codeIndex);\n        }\n    }", "definition": "    private static class CharacterRef", "class_docstring": "", "name": "CharacterRef", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "int[] codepoints;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "codepoints", "syntax_pass": true}, {"attribute_expression": "String name;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "int codeIndex;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "codeIndex", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return name\n                + \"=\"\n                + d(codepoints[0])\n                + (codepoints.length > 1 ? \",\" + d(codepoints[1]) : \"\")\n                + \";\" + d(codeIndex);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return name\n                + \"=\"\n                + d(codepoints[0])\n                + (codepoints.length > 1 ? \",\" + d(codepoints[1]) : \"\")\n                + \";\" + d(codeIndex);\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    private static class ByCode implements Comparator<CharacterRef> {\n        public int compare(CharacterRef o1, CharacterRef o2) {\n            int[] c1 = o1.codepoints;\n            int[] c2 = o2.codepoints;\n            int first = c1[0] - c2[0];\n            if (first != 0)\n                return first;\n            if (c1.length == 1 && c2.length == 1) { // for the same code, use the shorter name\n                int len = o2.name.length() - o1.name.length();\n                if (len != 0)\n                    return len;\n                return o1.name.compareTo(o2.name);\n            }\n            if (c1.length == 2 && c2.length == 2)\n                return c1[1] - c2[1];\n            else\n                return c2.length - c1.length; // pushes multi down the list so hits on singles first (don't support multi lookup by codepoint yet)\n        }\n    }", "definition": "    private static class ByCode implements Comparator<CharacterRef>", "class_docstring": "", "name": "ByCode", "super_interfaces": ["Comparator<CharacterRef>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public int compare(CharacterRef o1, CharacterRef o2) {\n            int[] c1 = o1.codepoints;\n            int[] c2 = o2.codepoints;\n            int first = c1[0] - c2[0];\n            if (first != 0)\n                return first;\n            if (c1.length == 1 && c2.length == 1) { // for the same code, use the shorter name\n                int len = o2.name.length() - o1.name.length();\n                if (len != 0)\n                    return len;\n                return o1.name.compareTo(o2.name);\n            }\n            if (c1.length == 2 && c2.length == 2)\n                return c1[1] - c2[1];\n            else\n                return c2.length - c1.length; // pushes multi down the list so hits on singles first (don't support multi lookup by codepoint yet)\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "o1", "type": "CharacterRef"}, {"name": "o2", "type": "CharacterRef"}], "body": "                                                             {\n            int[] c1 = o1.codepoints;\n            int[] c2 = o2.codepoints;\n            int first = c1[0] - c2[0];\n            if (first != 0)\n                return first;\n            if (c1.length == 1 && c2.length == 1) { // for the same code, use the shorter name\n                int len = o2.name.length() - o1.name.length();\n                if (len != 0)\n                    return len;\n                return o1.name.compareTo(o2.name);\n            }\n            if (c1.length == 2 && c2.length == 2)\n                return c1[1] - c2[1];\n            else\n                return c2.length - c1.length; // pushes multi down the list so hits on singles first (don't support multi lookup by codepoint yet)\n        }", "signature": "public int compare(CharacterRef o1, CharacterRef o2)"}]}], "class_docstring": "\nFetches HTML entity names from w3.org json, and outputs data files for optimized used in Entities.\nI refuse to believe that entity names like \"NotNestedLessLess\" are valuable or useful for HTML authors. Implemented\nonly to be complete.\n", "original_string": "class BuildEntities {\n    public static void main(String[] args) throws IOException {\n        String url = \"https://www.w3.org/TR/2012/WD-html5-20121025/entities.json\";\n        Connection.Response res = Jsoup.connect(url)\n            .ignoreContentType(true)\n            .userAgent(UrlConnectTest.browserUa)\n            .execute();\n\n        Gson gson = new Gson();\n        Map<String, CharacterRef> input = gson.fromJson(res.body(),\n            new TypeToken<Map<String, CharacterRef>>() {\n            }.getType());\n\n\n        // build name sorted base and full character lists:\n        ArrayList<CharacterRef> base = new ArrayList<>();\n        ArrayList<CharacterRef> full = new ArrayList<>();\n\n        for (Map.Entry<String, CharacterRef> entry : input.entrySet()) {\n            String name = entry.getKey().substring(1); // name is like &acute or &acute; , trim &\n            CharacterRef ref = entry.getValue();\n            if (name.endsWith(\";\")) {\n                name = name.substring(0, name.length() - 1);\n                full.add(ref);\n            } else {\n                base.add(ref);\n            }\n            ref.name = name;\n        }\n        base.sort(byName);\n        full.sort(byName);\n\n        // now determine code point order\n        ArrayList<CharacterRef> baseByCode = new ArrayList<>(base);\n        ArrayList<CharacterRef> fullByCode = new ArrayList<>(full);\n        baseByCode.sort(byCode);\n        fullByCode.sort(byCode);\n\n        // and update their codepoint index.\n        @SuppressWarnings(\"unchecked\") ArrayList<CharacterRef>[] codelists = new ArrayList[]{baseByCode, fullByCode};\n        for (ArrayList<CharacterRef> codelist : codelists) {\n            for (int i = 0; i < codelist.size(); i++) {\n                codelist.get(i).codeIndex = i;\n            }\n        }\n\n        // now write them\n        persist(\"entities-full\", full);\n        persist(\"entities-base\", base);\n\n        System.out.println(\"Full size: \" + full.size() + \", base size: \" + base.size());\n    }\n\n    private static void persist(String name, ArrayList<CharacterRef> refs) throws IOException {\n        File file = Files.createTempFile(name, \".txt\").toFile();\n        FileWriter writer = new FileWriter(file, false);\n        writer.append(\"static final String points = \\\"\");\n        for (CharacterRef ref : refs) {\n            writer.append(ref.toString()).append('&');\n        }\n        writer.append(\"\\\";\\n\");\n        writer.close();\n\n        System.out.println(\"Wrote \" + name + \" to \" + file.getAbsolutePath());\n    }\n\n\n    private static class CharacterRef {\n        int[] codepoints;\n        String name;\n        int codeIndex;\n\n        @Override\n        public String toString() {\n            return name\n                + \"=\"\n                + d(codepoints[0])\n                + (codepoints.length > 1 ? \",\" + d(codepoints[1]) : \"\")\n                + \";\" + d(codeIndex);\n        }\n    }\n\n    private static String d(int d) {\n        return Integer.toString(d, Entities.codepointRadix);\n    }\n\n    private static class ByCode implements Comparator<CharacterRef> {\n        public int compare(CharacterRef o1, CharacterRef o2) {\n            int[] c1 = o1.codepoints;\n            int[] c2 = o2.codepoints;\n            int first = c1[0] - c2[0];\n            if (first != 0)\n                return first;\n            if (c1.length == 1 && c2.length == 1) { // for the same code, use the shorter name\n                int len = o2.name.length() - o1.name.length();\n                if (len != 0)\n                    return len;\n                return o1.name.compareTo(o2.name);\n            }\n            if (c1.length == 2 && c2.length == 2)\n                return c1[1] - c2[1];\n            else\n                return c2.length - c1.length; // pushes multi down the list so hits on singles first (don't support multi lookup by codepoint yet)\n        }\n    }\n\n    private static final Comparator<CharacterRef> byName = Comparator.comparing(ref -> ref.name);\n    private static final ByCode byCode = new ByCode();\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Comparator<CharacterRef> byName = Comparator.comparing(ref -> ref.name);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<CharacterRef>", "name": "byName = Comparator.comparing(ref -> ref.name)", "syntax_pass": true}, {"attribute_expression": "private static final ByCode byCode = new ByCode();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ByCode", "name": "byCode = new ByCode()", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException", "name": "UncheckedIOException", "file_path": "src/main/java/org/jsoup/UncheckedIOException.java", "superclasses": "", "methods": ["[]UncheckedIOException(IOException)", "[]UncheckedIOException(String)", "[IOException]ioException()"], "method_uris": ["src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException.[]UncheckedIOException(IOException)", "src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException.[]UncheckedIOException(String)", "src/main/java/org/jsoup/UncheckedIOException.java.UncheckedIOException.[IOException]ioException()"], "overrides": null, "attributes": [], "class_docstring": "\n@deprecated Use {@link java.io.UncheckedIOException} instead. This class acted as a compatibility shim for Java\nversions prior to 1.8.\n", "original_string": "@Deprecated\npublic class UncheckedIOException extends java.io.UncheckedIOException {\n    public UncheckedIOException(IOException cause) {\n        super(cause);\n    }\n\n    public UncheckedIOException(String message) {\n        super(new IOException(message));\n    }\n\n    public IOException ioException() {\n        return getCause();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/Jsoup.java.Jsoup", "name": "Jsoup", "file_path": "src/main/java/org/jsoup/Jsoup.java", "superclasses": "", "methods": ["[]Jsoup()", "[Document]parse(String,String)", "[Document]parse(String,String,Parser)", "[Document]parse(String,Parser)", "[Document]parse(String)", "[Connection]connect(String)", "[Connection]newSession()", "[Document]parse(File,String,String)", "[Document]parse(File,String)", "[Document]parse(File)", "[Document]parse(File,String,String,Parser)", "[Document]parse(Path,String,String)", "[Document]parse(Path,String)", "[Document]parse(Path)", "[Document]parse(Path,String,String,Parser)", "[Document]parse(InputStream,String,String)", "[Document]parse(InputStream,String,String,Parser)", "[Document]parseBodyFragment(String,String)", "[Document]parseBodyFragment(String)", "[Document]parse(URL,int)", "[String]clean(String,String,Safelist)", "[String]clean(String,Safelist)", "[String]clean(String,String,Safelist,Document.OutputSettings)", "[boolean]isValid(String,Safelist)"], "method_uris": ["src/main/java/org/jsoup/Jsoup.java.Jsoup.[]Jsoup()", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(String,String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(String,String,Parser)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(String,Parser)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Connection]connect(String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Connection]newSession()", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(File,String,String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(File,String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(File)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(File,String,String,Parser)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(Path,String,String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(Path,String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(Path)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(Path,String,String,Parser)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(InputStream,String,String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(InputStream,String,String,Parser)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parseBodyFragment(String,String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parseBodyFragment(String)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[Document]parse(URL,int)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[String]clean(String,String,Safelist)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[String]clean(String,Safelist)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[String]clean(String,String,Safelist,Document.OutputSettings)", "src/main/java/org/jsoup/Jsoup.java.Jsoup.[boolean]isValid(String,Safelist)"], "overrides": null, "attributes": [], "class_docstring": "\nThe core public access point to the jsoup functionality.\n\n@author Jonathan Hedley", "original_string": "public class Jsoup {\n    private Jsoup() {}\n\n    /**\n     Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.\n\n     @param html    HTML to parse\n     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\n     before the HTML declares a {@code <base href>} tag.\n     @return sane HTML\n     */\n    public static Document parse(String html, String baseUri) {\n        return Parser.parse(html, baseUri);\n    }\n\n    /**\n     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML\n     (non-HTML) parser.\n\n     @param html    HTML to parse\n     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\n     before the HTML declares a {@code <base href>} tag.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n     */\n    public static Document parse(String html, String baseUri, Parser parser) {\n        return parser.parseInput(html, baseUri);\n    }\n\n    /**\n     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML\n     (non-HTML) parser.  As no base URI is specified, absolute URL resolution, if required, relies on the HTML including\n     a {@code <base href>} tag.\n\n     @param html    HTML to parse\n     before the HTML declares a {@code <base href>} tag.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n     */\n    public static Document parse(String html, Parser parser) {\n        return parser.parseInput(html, \"\");\n    }\n\n    /**\n     Parse HTML into a Document. As no base URI is specified, absolute URL resolution, if required, relies on the HTML\n     including a {@code <base href>} tag.\n\n     @param html HTML to parse\n     @return sane HTML\n\n     @see #parse(String, String)\n     */\n    public static Document parse(String html) {\n        return Parser.parse(html, \"\");\n    }\n\n    /**\n     * Creates a new {@link Connection} (session), with the defined request URL. Use to fetch and parse a HTML page.\n     * <p>\n     * Use examples:\n     * <ul>\n     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").userAgent(\"Mozilla\").data(\"name\", \"jsoup\").get();</code></li>\n     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").cookie(\"auth\", \"token\").post();</code></li>\n     * </ul>\n     * @param url URL to connect to. The protocol must be {@code http} or {@code https}.\n     * @return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.\n     * @see #newSession()\n     * @see Connection#newRequest()\n     */\n    public static Connection connect(String url) {\n        return HttpConnection.connect(url);\n    }\n\n    /**\n     Creates a new {@link Connection} to use as a session. Connection settings (user-agent, timeouts, URL, etc), and\n     cookies will be maintained for the session. Use examples:\n<pre><code>\nConnection session = Jsoup.newSession()\n     .timeout(20 * 1000)\n     .userAgent(\"FooBar 2000\");\n\nDocument doc1 = session.newRequest()\n     .url(\"https://jsoup.org/\").data(\"ref\", \"example\")\n     .get();\nDocument doc2 = session.newRequest()\n     .url(\"https://en.wikipedia.org/wiki/Main_Page\")\n     .get();\nConnection con3 = session.newRequest();\n</code></pre>\n\n     <p>For multi-threaded requests, it is safe to use this session between threads, but take care to call {@link\n    Connection#newRequest()} per request and not share that instance between threads when executing or parsing.</p>\n\n     @return a connection\n     @since 1.14.1\n     */\n    public static Connection newSession() {\n        return new HttpConnection();\n    }\n\n    /**\n     Parse the contents of a file as HTML.\n\n     @param file          file to load HTML from. Supports gzipped files (ending in .z or .gz).\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(File file, @Nullable String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(file, charsetName, baseUri);\n    }\n\n    /**\n     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n\n     @param file        file to load HTML from. Supports gzipped files (ending in .z or .gz).\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     @see #parse(File, String, String) parse(file, charset, baseUri)\n     */\n    public static Document parse(File file, @Nullable String charsetName) throws IOException {\n        return DataUtil.load(file, charsetName, file.getAbsolutePath());\n    }\n\n    /**\n     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n     The charset used to read the file will be determined by the byte-order-mark (BOM), or a {@code <meta charset>} tag,\n     or if neither is present, will be {@code UTF-8}.\n\n     <p>This is the equivalent of calling {@link #parse(File, String) parse(file, null)}</p>\n\n     @param file the file to load HTML from. Supports gzipped files (ending in .z or .gz).\n     @return sane HTML\n     @throws IOException if the file could not be found or read.\n     @see #parse(File, String, String) parse(file, charset, baseUri)\n     @since 1.15.1\n     */\n    public static Document parse(File file) throws IOException {\n        return DataUtil.load(file, null, file.getAbsolutePath());\n    }\n\n    /**\n     Parse the contents of a file as HTML.\n\n     @param file          file to load HTML from. Supports gzipped files (ending in .z or .gz).\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     @since 1.14.2\n     */\n    public static Document parse(File file, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(file, charsetName, baseUri, parser);\n    }\n\n    /**\n     Parse the contents of a file as HTML.\n\n     @param path          file to load HTML from. Supports gzipped files (ending in .z or .gz).\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     @since 1.18.1\n     */\n    public static Document parse(Path path, @Nullable String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(path, charsetName, baseUri);\n    }\n\n    /**\n     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n\n     @param path        file to load HTML from. Supports gzipped files (ending in .z or .gz).\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     @see #parse(File, String, String) parse(file, charset, baseUri)\n     @since 1.18.1\n     */\n    public static Document parse(Path path, @Nullable String charsetName) throws IOException {\n        return DataUtil.load(path, charsetName, path.toAbsolutePath().toString());\n    }\n\n    /**\n     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n     The charset used to read the file will be determined by the byte-order-mark (BOM), or a {@code <meta charset>} tag,\n     or if neither is present, will be {@code UTF-8}.\n\n     <p>This is the equivalent of calling {@link #parse(File, String) parse(file, null)}</p>\n\n     @param path the file to load HTML from. Supports gzipped files (ending in .z or .gz).\n     @return sane HTML\n     @throws IOException if the file could not be found or read.\n     @see #parse(Path, String, String) parse(file, charset, baseUri)\n     @since 1.18.1\n     */\n    public static Document parse(Path path) throws IOException {\n        return DataUtil.load(path, null, path.toAbsolutePath().toString());\n    }\n\n    /**\n     Parse the contents of a file as HTML.\n\n     @param path          file to load HTML from. Supports gzipped files (ending in .z or .gz).\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     @since 1.18.1\n     */\n    public static Document parse(Path path, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(path, charsetName, baseUri, parser);\n    }\n\n     /**\n     Read an input stream, and parse it to a Document.\n\n     @param in          input stream to read. The stream will be closed after reading.\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, @Nullable String charsetName, String baseUri) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri);\n    }\n\n    /**\n     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n     (non-HTML) parser.\n\n     @param in          input stream to read. Make sure to close it after parsing.\n     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n     present, or fall back to {@code UTF-8} (which is often safe to do).\n     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n     @param parser alternate {@link Parser#xmlParser() parser} to use.\n     @return sane HTML\n\n     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n     */\n    public static Document parse(InputStream in, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return DataUtil.load(in, charsetName, baseUri, parser);\n    }\n\n    /**\n     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n\n     @param bodyHtml body HTML fragment\n     @param baseUri  URL to resolve relative URLs against.\n     @return sane HTML document\n\n     @see Document#body()\n     */\n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        return Parser.parseBodyFragment(bodyHtml, baseUri);\n    }\n\n    /**\n     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n\n     @param bodyHtml body HTML fragment\n     @return sane HTML document\n\n     @see Document#body()\n     */\n    public static Document parseBodyFragment(String bodyHtml) {\n        return Parser.parseBodyFragment(bodyHtml, \"\");\n    }\n\n    /**\n     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n     <p>\n     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n\n     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n     @return The parsed HTML.\n\n     @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n     @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n     @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n     @throws java.net.SocketTimeoutException if the connection times out\n     @throws IOException if a connection or read error occurs\n\n     @see #connect(String)\n     */\n    public static Document parse(URL url, int timeoutMillis) throws IOException {\n        Connection con = HttpConnection.connect(url);\n        con.timeout(timeoutMillis);\n        return con.get();\n    }\n\n    /**\n     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through an allow-list of safe\n     tags and attributes.\n\n     @param bodyHtml  input untrusted HTML (body fragment)\n     @param baseUri   URL to resolve relative URLs against\n     @param safelist  list of permitted HTML elements\n     @return safe HTML (body fragment)\n\n     @see Cleaner#clean(Document)\n     */\n    public static String clean(String bodyHtml, String baseUri, Safelist safelist) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(safelist);\n        Document clean = cleaner.clean(dirty);\n        return clean.body().html();\n    }\n\n    /**\n     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a safe-list of permitted\n     tags and attributes.\n\n     <p>Note that as this method does not take a base href URL to resolve attributes with relative URLs against, those\n     URLs will be removed, unless the input HTML contains a {@code <base href> tag}. If you wish to preserve those, use\n     the {@link Jsoup#clean(String html, String baseHref, Safelist)} method instead, and enable\n     {@link Safelist#preserveRelativeLinks(boolean)}.</p>\n\n     <p>Note that the output of this method is still <b>HTML</b> even when using the TextNode only\n     {@link Safelist#none()}, and so any HTML entities in the output will be appropriately escaped.\n     If you want plain text, not HTML, you should use a text method such as {@link Element#text()} instead, after\n     cleaning the document.</p>\n     <p>Example:</p>\n     <pre>{@code\n     String sourceBodyHtml = \"<p>5 is &lt; 6.</p>\";\n     String html = Jsoup.clean(sourceBodyHtml, Safelist.none());\n\n     Cleaner cleaner = new Cleaner(Safelist.none());\n     String text = cleaner.clean(Jsoup.parse(sourceBodyHtml)).text();\n\n     // html is: 5 is &lt; 6.\n     // text is: 5 is < 6.\n     }</pre>\n\n     @param bodyHtml input untrusted HTML (body fragment)\n     @param safelist list of permitted HTML elements\n     @return safe HTML (body fragment)\n     @see Cleaner#clean(Document)\n     */\n    public static String clean(String bodyHtml, Safelist safelist) {\n        return clean(bodyHtml, \"\", safelist);\n    }\n\n    /**\n     * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a safe-list of\n     * permitted tags and attributes.\n     * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an\n     * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add\n     * structural tags (<code>html, head, body</code> etc) to the safelist.\n     *\n     * @param bodyHtml input untrusted HTML (body fragment)\n     * @param baseUri URL to resolve relative URLs against\n     * @param safelist list of permitted HTML elements\n     * @param outputSettings document output settings; use to control pretty-printing and entity escape modes\n     * @return safe HTML (body fragment)\n     * @see Cleaner#clean(Document)\n     */\n    public static String clean(String bodyHtml, String baseUri, Safelist safelist, Document.OutputSettings outputSettings) {\n        Document dirty = parseBodyFragment(bodyHtml, baseUri);\n        Cleaner cleaner = new Cleaner(safelist);\n        Document clean = cleaner.clean(dirty);\n        clean.outputSettings(outputSettings);\n        return clean.body().html();\n    }\n\n    /**\n     Test if the input body HTML has only tags and attributes allowed by the Safelist. Useful for form validation.\n     <p>\n     This method is intended to be used in a user interface as a validator for user input. Note that regardless of the\n     output of this method, the input document <b>must always</b> be normalized using a method such as\n     {@link #clean(String, String, Safelist)}, and the result of that method used to store or serialize the document\n     before later reuse such as presentation to end users. This ensures that enforced attributes are set correctly, and\n     that any differences between how a given browser and how jsoup parses the input HTML are normalized.\n     </p>\n     <p>Example:</p>\n     <pre>{@code\n     Safelist safelist = Safelist.relaxed();\n     boolean isValid = Jsoup.isValid(sourceBodyHtml, safelist);\n     String normalizedHtml = Jsoup.clean(sourceBodyHtml, \"https://example.com/\", safelist);\n     }</pre>\n     <p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)\n     @param bodyHtml HTML to test\n     @param safelist safelist to test against\n     @return true if no tags or attributes were removed; false otherwise\n     @see #clean(String, Safelist)\n     */\n    public static boolean isValid(String bodyHtml, Safelist safelist) {\n        return new Cleaner(safelist).isValidBodyHtml(bodyHtml);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException", "name": "HttpStatusException", "file_path": "src/main/java/org/jsoup/HttpStatusException.java", "superclasses": "IOException", "methods": ["[]HttpStatusException(String,int,String)", "[int]getStatusCode()", "[String]getUrl()"], "method_uris": ["src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException.[]HttpStatusException(String,int,String)", "src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException.[int]getStatusCode()", "src/main/java/org/jsoup/HttpStatusException.java.HttpStatusException.[String]getUrl()"], "overrides": null, "attributes": [], "class_docstring": "\nSignals that a HTTP request resulted in a not OK HTTP response.\n", "original_string": "public class HttpStatusException extends IOException {\n    private final int statusCode;\n    private final String url;\n\n    public HttpStatusException(String message, int statusCode, String url) {\n        super(message + \". Status=\" + statusCode + \", URL=[\" + url + \"]\");\n        this.statusCode = statusCode;\n        this.url = url;\n    }\n\n    public int getStatusCode() {\n        return statusCode;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final int statusCode;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "statusCode", "syntax_pass": true}, {"attribute_expression": "private final String url;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "url", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/SerializationException.java.SerializationException", "name": "SerializationException", "file_path": "src/main/java/org/jsoup/SerializationException.java", "superclasses": "RuntimeException", "methods": ["[]SerializationException()", "[]SerializationException(String)", "[]SerializationException(Throwable)", "[]SerializationException(String,Throwable)"], "method_uris": ["src/main/java/org/jsoup/SerializationException.java.SerializationException.[]SerializationException()", "src/main/java/org/jsoup/SerializationException.java.SerializationException.[]SerializationException(String)", "src/main/java/org/jsoup/SerializationException.java.SerializationException.[]SerializationException(Throwable)", "src/main/java/org/jsoup/SerializationException.java.SerializationException.[]SerializationException(String,Throwable)"], "overrides": null, "attributes": [], "class_docstring": "\nA SerializationException is raised whenever serialization of a DOM element fails. This exception usually wraps an\n{@link java.io.IOException} that may be thrown due to an inaccessible output stream.\n", "original_string": "public final class SerializationException extends RuntimeException {\n\t/**\n\t * Creates and initializes a new serialization exception with no error message and cause.\n\t */\n\tpublic SerializationException() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Creates and initializes a new serialization exception with the given error message and no cause.\n\t * \n\t * @param message\n\t *            the error message of the new serialization exception (may be <code>null</code>).\n\t */\n\tpublic SerializationException(String message) {\n\t\tsuper(message);\n\t}\n\n\t/**\n\t * Creates and initializes a new serialization exception with the specified cause and an error message of\n     * <code>(cause==null ? null : cause.toString())</code> (which typically contains the class and error message of\n     * <code>cause</code>).\n\t * \n\t * @param cause\n\t *            the cause of the new serialization exception (may be <code>null</code>).\n\t */\n\tpublic SerializationException(Throwable cause) {\n\t\tsuper(cause);\n\t}\n\n\t/**\n\t * Creates and initializes a new serialization exception with the given error message and cause.\n\t * \n\t * @param message\n\t *            the error message of the new serialization exception.\n\t * @param cause\n\t *            the cause of the new serialization exception.\n\t */\n\tpublic SerializationException(String message, Throwable cause) {\n\t\tsuper(message, cause);\n\t}\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException", "name": "UnsupportedMimeTypeException", "file_path": "src/main/java/org/jsoup/UnsupportedMimeTypeException.java", "superclasses": "IOException", "methods": ["[]UnsupportedMimeTypeException(String,String,String)", "[String]getMimeType()", "[String]getUrl()", "[String]toString()"], "method_uris": ["src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException.[]UnsupportedMimeTypeException(String,String,String)", "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException.[String]getMimeType()", "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException.[String]getUrl()", "src/main/java/org/jsoup/UnsupportedMimeTypeException.java.UnsupportedMimeTypeException.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nSignals that a HTTP response returned a mime type that is not supported.\n", "original_string": "public class UnsupportedMimeTypeException extends IOException {\n    private final String mimeType;\n    private final String url;\n\n    public UnsupportedMimeTypeException(String message, String mimeType, String url) {\n        super(message);\n        this.mimeType = mimeType;\n        this.url = url;\n    }\n\n    public String getMimeType() {\n        return mimeType;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    @Override\n    public String toString() {\n        return super.toString() + \". Mimetype=\" + mimeType + \", URL=\"+url;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final String mimeType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "mimeType", "syntax_pass": true}, {"attribute_expression": "private final String url;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "url", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/helper/Validate.java.Validate", "name": "Validate", "file_path": "src/main/java/org/jsoup/helper/Validate.java", "superclasses": "", "methods": ["[]Validate()", "[void]notNull(Object)", "[void]notNullParam(Object,String)", "[void]notNull(Object,String)", "[Object]ensureNotNull(Object)", "[Object]ensureNotNull(Object,String)", "[void]isTrue(boolean)", "[void]isTrue(boolean,String)", "[void]isFalse(boolean)", "[void]isFalse(boolean,String)", "[void]noNullElements(Object[])", "[void]noNullElements(Object[],String)", "[void]notEmpty(String)", "[void]notEmptyParam(String,String)", "[void]notEmpty(String,String)", "[void]wtf(String)", "[void]fail(String)", "[boolean]assertFail(String)", "[void]fail(String)"], "method_uris": ["src/main/java/org/jsoup/helper/Validate.java.Validate.[]Validate()", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notNull(Object)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notNullParam(Object,String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notNull(Object,String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[Object]ensureNotNull(Object)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[Object]ensureNotNull(Object,String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]isTrue(boolean)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]isTrue(boolean,String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]isFalse(boolean)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]isFalse(boolean,String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]noNullElements(Object[])", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]noNullElements(Object[],String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notEmpty(String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notEmptyParam(String,String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]notEmpty(String,String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]wtf(String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]fail(String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[boolean]assertFail(String)", "src/main/java/org/jsoup/helper/Validate.java.Validate.[void]fail(String)"], "overrides": null, "attributes": [], "class_docstring": "\nValidators to check that method arguments meet expectations. \n", "original_string": "public final class Validate {\n    \n    private Validate() {}\n\n    /**\n     * Validates that the object is not null\n     * @param obj object to test\n     * @throws ValidationException if the object is null\n     */\n    public static void notNull(@Nullable Object obj) {\n        if (obj == null)\n            throw new ValidationException(\"Object must not be null\");\n    }\n\n    /**\n     Validates that the parameter is not null\n\n     * @param obj the parameter to test\n     * @param param the name of the parameter, for presentation in the validation exception.\n     * @throws ValidationException if the object is null\n     */\n    public static void notNullParam(@Nullable final Object obj, final String param) {\n        if (obj == null)\n            throw new ValidationException(String.format(\"The parameter '%s' must not be null.\", param));\n    }\n\n    /**\n     * Validates that the object is not null\n     * @param obj object to test\n     * @param msg message to include in the Exception if validation fails\n     * @throws ValidationException if the object is null\n     */\n    public static void notNull(@Nullable Object obj, String msg) {\n        if (obj == null)\n            throw new ValidationException(msg);\n    }\n\n    /**\n     Verifies the input object is not null, and returns that object. Effectively this casts a nullable object to a non-\n     null object. (Works around lack of Objects.requestNonNull in Android version.)\n     * @param obj nullable object to case to not-null\n     * @return the object, or throws an exception if it is null\n     * @throws ValidationException if the object is null\n     */\n    public static Object ensureNotNull(@Nullable Object obj) {\n        if (obj == null)\n            throw new ValidationException(\"Object must not be null\");\n        else return obj;\n    }\n\n    /**\n     Verifies the input object is not null, and returns that object. Effectively this casts a nullable object to a non-\n     null object. (Works around lack of Objects.requestNonNull in Android version.)\n     * @param obj nullable object to case to not-null\n     * @param msg the String format message to include in the validation exception when thrown\n     * @param args the arguments to the msg\n     * @return the object, or throws an exception if it is null\n     * @throws ValidationException if the object is null\n     */\n    public static Object ensureNotNull(@Nullable Object obj, String msg, Object... args) {\n        if (obj == null)\n            throw new ValidationException(String.format(msg, args));\n        else return obj;\n    }\n\n    /**\n     * Validates that the value is true\n     * @param val object to test\n     * @throws ValidationException if the object is not true\n     */\n    public static void isTrue(boolean val) {\n        if (!val)\n            throw new ValidationException(\"Must be true\");\n    }\n\n    /**\n     * Validates that the value is true\n     * @param val object to test\n     * @param msg message to include in the Exception if validation fails\n     * @throws ValidationException if the object is not true\n     */\n    public static void isTrue(boolean val, String msg) {\n        if (!val)\n            throw new ValidationException(msg);\n    }\n\n    /**\n     * Validates that the value is false\n     * @param val object to test\n     * @throws ValidationException if the object is not false\n     */\n    public static void isFalse(boolean val) {\n        if (val)\n            throw new ValidationException(\"Must be false\");\n    }\n\n    /**\n     * Validates that the value is false\n     * @param val object to test\n     * @param msg message to include in the Exception if validation fails\n     * @throws ValidationException if the object is not false\n     */\n    public static void isFalse(boolean val, String msg) {\n        if (val)\n            throw new ValidationException(msg);\n    }\n\n    /**\n     * Validates that the array contains no null elements\n     * @param objects the array to test\n     * @throws ValidationException if the array contains a null element\n     */\n    public static void noNullElements(Object[] objects) {\n        noNullElements(objects, \"Array must not contain any null objects\");\n    }\n\n    /**\n     * Validates that the array contains no null elements\n     * @param objects the array to test\n     * @param msg message to include in the Exception if validation fails\n     * @throws ValidationException if the array contains a null element\n     */\n    public static void noNullElements(Object[] objects, String msg) {\n        for (Object obj : objects)\n            if (obj == null)\n                throw new ValidationException(msg);\n    }\n\n    /**\n     * Validates that the string is not null and is not empty\n     * @param string the string to test\n     * @throws ValidationException if the string is null or empty\n     */\n    public static void notEmpty(@Nullable String string) {\n        if (string == null || string.length() == 0)\n            throw new ValidationException(\"String must not be empty\");\n    }\n\n    /**\n     Validates that the string parameter is not null and is not empty\n     * @param string the string to test\n     * @param param the name of the parameter, for presentation in the validation exception.\n     * @throws ValidationException if the string is null or empty\n     */\n    public static void notEmptyParam(@Nullable final String string, final String param) {\n        if (string == null || string.length() == 0)\n            throw new ValidationException(String.format(\"The '%s' parameter must not be empty.\", param));\n    }\n\n    /**\n     * Validates that the string is not null and is not empty\n     * @param string the string to test\n     * @param msg message to include in the Exception if validation fails\n     * @throws ValidationException if the string is null or empty\n     */\n    public static void notEmpty(@Nullable String string, String msg) {\n        if (string == null || string.length() == 0)\n            throw new ValidationException(msg);\n    }\n\n    /**\n     * Blow up if we reach an unexpected state.\n     * @param msg message to think about\n     * @throws IllegalStateException if we reach this state\n     */\n    public static void wtf(String msg) {\n        throw new IllegalStateException(msg);\n    }\n\n    /**\n     Cause a failure.\n     @param msg message to output.\n     @throws IllegalStateException if we reach this state\n     */\n    public static void fail(String msg) {\n        throw new ValidationException(msg);\n    }\n\n    /**\n     Cause a failure, but return false so it can be used in an assert statement.\n     @param msg message to output.\n     @return false, always\n     @throws IllegalStateException if we reach this state\n     */\n    static boolean assertFail(String msg) {\n        fail(msg);\n        return false;\n    }\n\n    /**\n     Cause a failure.\n     @param msg message to output.\n     @param args the format arguments to the msg\n     @throws IllegalStateException if we reach this state\n     */\n    public static void fail(String msg, Object... args) {\n        throw new ValidationException(String.format(msg, args));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder", "name": "UrlBuilder", "file_path": "src/main/java/org/jsoup/helper/UrlBuilder.java", "superclasses": "", "methods": ["[]UrlBuilder(URL)", "[URL]build()", "[void]appendKeyVal(Connection.KeyVal)", "[String]decodePart(String)", "[void]appendToAscii(String,boolean,StringBuilder)", "[boolean]isHex(char)"], "method_uris": ["src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[]UrlBuilder(URL)", "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[URL]build()", "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[void]appendKeyVal(Connection.KeyVal)", "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[String]decodePart(String)", "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[void]appendToAscii(String,boolean,StringBuilder)", "src/main/java/org/jsoup/helper/UrlBuilder.java.UrlBuilder.[boolean]isHex(char)"], "overrides": null, "attributes": [], "class_docstring": "\nA utility class to normalize input URLs. jsoup internal; API subject to change.\n<p>Normalization includes puny-coding the host, and encoding non-ascii path components. Any non-ascii characters in\nthe query string (or the fragment/anchor) are escaped, but any existing escapes in those components are preserved.</p>\n", "original_string": "final class UrlBuilder {\n    URL u;\n    @Nullable StringBuilder q;\n\n    UrlBuilder(URL inputUrl) {\n        this.u = inputUrl;\n        if (u.getQuery() != null)\n            q = StringUtil.borrowBuilder().append(u.getQuery());\n    }\n\n    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n                null, null, null // path, query and fragment appended later so as not to encode\n            );\n\n            StringBuilder normUrl = StringUtil.borrowBuilder().append(uri.toASCIIString());\n            appendToAscii(u.getPath(), false, normUrl);\n            if (q != null) {\n                normUrl.append('?');\n                appendToAscii(StringUtil.releaseBuilder(q), true, normUrl);\n            }\n            if (u.getRef() != null) {\n                normUrl.append('#');\n                appendToAscii(u.getRef(), false, normUrl);\n            }\n            u = new URL(StringUtil.releaseBuilder(normUrl));\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }\n\n    void appendKeyVal(Connection.KeyVal kv) throws UnsupportedEncodingException {\n        if (q == null)\n            q = StringUtil.borrowBuilder();\n        else\n            q.append('&');\n        q\n            .append(URLEncoder.encode(kv.key(), UTF_8.name()))\n            .append('=')\n            .append(URLEncoder.encode(kv.value(), UTF_8.name()));\n    }\n\n    private static String decodePart(String encoded) {\n        try {\n            return URLDecoder.decode(encoded, UTF_8.name());\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e); // wtf!\n        }\n    }\n\n    private static final String unsafeCharacters = \"<>\\\"{}|\\\\^[]`\";\n\n    private static void appendToAscii(String s, boolean spaceAsPlus, StringBuilder sb) throws UnsupportedEncodingException {\n        for (int i = 0; i < s.length(); i++) {\n            int c = s.codePointAt(i);\n            if (c == ' ') {\n                sb.append(spaceAsPlus ? '+' : \"%20\");\n            } else if (c == '%') { // if already a valid escape, pass; otherwise, escape\n                if (i < s.length() - 2 && isHex(s.charAt(i + 1)) && isHex(s.charAt(i + 2))) {\n                    sb.append('%').append(s.charAt(i + 1)).append(s.charAt(i + 2));\n                    i += 2; // skip the next two characters\n                } else {\n                    sb.append(\"%25\");\n                }\n            } else if (c > 127 || unsafeCharacters.indexOf(c) != -1) { // past ascii, or otherwise unsafe\n                sb.append(URLEncoder.encode(new String(Character.toChars(c)), UTF_8.name()));\n                if (Character.charCount(c) == 2) i++; // advance past supplemental\n            } else {\n                sb.append((char) c);\n            }\n        }\n    }\n\n    private static boolean isHex(char c) {\n        return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    }\n\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "URL u;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "URL", "name": "u", "syntax_pass": true}, {"attribute_expression": "@Nullable StringBuilder q;", "docstring": "", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "StringBuilder", "name": "q", "syntax_pass": true}, {"attribute_expression": "private static final String unsafeCharacters = \"<>\\\"{}|\\\\^[]`\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "unsafeCharacters = \"<>\\\"{}|\\\\^[]`\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler", "name": "AuthenticationHandler", "file_path": "src/main/java/org/jsoup/helper/AuthenticationHandler.java", "superclasses": "Authenticator", "methods": ["[]AuthenticationHandler()", "[]AuthenticationHandler(RequestAuthenticator)", "[PasswordAuthentication]getPasswordAuthentication()"], "method_uris": ["src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler.[]AuthenticationHandler()", "src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler.[]AuthenticationHandler(RequestAuthenticator)", "src/main/java/org/jsoup/helper/AuthenticationHandler.java.AuthenticationHandler.[PasswordAuthentication]getPasswordAuthentication()"], "overrides": null, "attributes": [{"original_string": "    static class GlobalHandler implements AuthShim {\n        static ThreadLocal<AuthenticationHandler> authenticators = new ThreadLocal<>();\n        static {\n            Authenticator.setDefault(new AuthenticationHandler());\n        }\n\n        @Override public void enable(RequestAuthenticator auth, HttpURLConnection con) {\n            authenticators.set(new AuthenticationHandler(auth));\n        }\n\n        @Override public void remove() {\n            authenticators.remove();\n        }\n\n        @Override public AuthenticationHandler get(AuthenticationHandler helper) {\n            return authenticators.get();\n        }\n    }", "definition": "    static class GlobalHandler implements AuthShim", "class_docstring": "\nOn Java 8 we install a system-wide Authenticator, which pulls the delegating Auth from a ThreadLocal pool.\n", "name": "GlobalHandler", "super_interfaces": ["AuthShim"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "static ThreadLocal<AuthenticationHandler> authenticators = new ThreadLocal<>();", "docstring": "", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "ThreadLocal<AuthenticationHandler>", "name": "authenticators = new ThreadLocal<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override public void enable(RequestAuthenticator auth, HttpURLConnection con) {\n            authenticators.set(new AuthenticationHandler(auth));\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "enable", "params": [{"name": "auth", "type": "RequestAuthenticator"}, {"name": "con", "type": "HttpURLConnection"}], "body": "                                                                                       {\n            authenticators.set(new AuthenticationHandler(auth));\n        }", "signature": "@Override public void enable(RequestAuthenticator auth, HttpURLConnection con)"}, {"syntax_pass": true, "original_string": "        @Override public void remove() {\n            authenticators.remove();\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                                       {\n            authenticators.remove();\n        }", "signature": "@Override public void remove()"}, {"syntax_pass": true, "original_string": "        @Override public AuthenticationHandler get(AuthenticationHandler helper) {\n            return authenticators.get();\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AuthenticationHandler", "classes": []}, "name": "get", "params": [{"name": "helper", "type": "AuthenticationHandler"}], "body": "                                                                                 {\n            return authenticators.get();\n        }", "signature": "@Override public AuthenticationHandler get(AuthenticationHandler helper)"}]}], "class_docstring": "\nHandles per request Authenticator-based authentication. Loads the class `org.jsoup.helper.RequestAuthHandler` if\nper-request Authenticators are supported (Java 9+), or installs a system-wide Authenticator that delegates to a request\nThreadLocal.\n", "original_string": "class AuthenticationHandler extends Authenticator {\n    static final int MaxAttempts = 5; // max authentication attempts per request. allows for multiple auths (e.g. proxy and server) in one request, but saves otherwise 20 requests if credentials are incorrect.\n    static AuthShim handler;\n\n    static {\n        try {\n            //noinspection unchecked\n            Class<AuthShim> perRequestClass = (Class<AuthShim>) Class.forName(\"org.jsoup.helper.RequestAuthHandler\");\n            Constructor<AuthShim> constructor = perRequestClass.getConstructor();\n            handler = constructor.newInstance();\n        } catch (ClassNotFoundException e) {\n            handler = new GlobalHandler();\n        } catch (Exception e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Nullable RequestAuthenticator auth;\n    int attemptCount = 0;\n\n    AuthenticationHandler() {}\n\n    AuthenticationHandler(RequestAuthenticator auth) {\n        this.auth = auth;\n    }\n\n    /**\n     Authentication callback, called by HttpURLConnection - either as system-wide default (Java 8) or per HttpURLConnection (Java 9+)\n     * @return credentials, or null if not attempting to auth.\n     */\n    @Nullable @Override public final PasswordAuthentication getPasswordAuthentication() {\n        AuthenticationHandler delegate = handler.get(this);\n        if (delegate == null) return null; // this request has no auth handler\n        delegate.attemptCount++;\n        // if the password returned fails, Java will repeatedly retry the request with a new password auth hit (because\n        // it may be an interactive prompt, and the user could eventually get it right). But in Jsoup's context, the\n        // auth will either be correct or not, so just abandon\n        if (delegate.attemptCount > MaxAttempts)\n            return null;\n        if (delegate.auth == null)\n            return null; // detached - would have been the Global Authenticator (not a delegate)\n\n        RequestAuthenticator.Context ctx = new RequestAuthenticator.Context(\n            this.getRequestingURL(), this.getRequestorType(), this.getRequestingPrompt());\n        return delegate.auth.authenticate(ctx);\n    }\n\n    interface AuthShim {\n        void enable(RequestAuthenticator auth, HttpURLConnection con);\n\n        void remove();\n\n        @Nullable AuthenticationHandler get(AuthenticationHandler helper);\n    }\n\n    /**\n     On Java 8 we install a system-wide Authenticator, which pulls the delegating Auth from a ThreadLocal pool.\n     */\n    static class GlobalHandler implements AuthShim {\n        static ThreadLocal<AuthenticationHandler> authenticators = new ThreadLocal<>();\n        static {\n            Authenticator.setDefault(new AuthenticationHandler());\n        }\n\n        @Override public void enable(RequestAuthenticator auth, HttpURLConnection con) {\n            authenticators.set(new AuthenticationHandler(auth));\n        }\n\n        @Override public void remove() {\n            authenticators.remove();\n        }\n\n        @Override public AuthenticationHandler get(AuthenticationHandler helper) {\n            return authenticators.get();\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final int MaxAttempts = 5;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "MaxAttempts = 5", "syntax_pass": true}, {"attribute_expression": "static AuthShim handler;", "docstring": " max authentication attempts per request. allows for multiple auths (e.g. proxy and server) in one request, but saves otherwise 20 requests if credentials are incorrect.", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "AuthShim", "name": "handler", "syntax_pass": true}, {"attribute_expression": "@Nullable RequestAuthenticator auth;", "docstring": "", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "RequestAuthenticator", "name": "auth", "syntax_pass": true}, {"attribute_expression": "int attemptCount = 0;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "attemptCount = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil", "name": "DataUtil", "file_path": "src/main/java/org/jsoup/helper/DataUtil.java", "superclasses": "", "methods": ["[]DataUtil()", "[Document]load(File,String,String)", "[Document]load(File,String,String,Parser)", "[Document]load(Path,String,String)", "[Document]load(Path,String,String,Parser)", "[StreamParser]streamParser(Path,Charset,String,Parser)", "[ControllableInputStream]openStream(Path)", "[Document]load(InputStream,String,String)", "[Document]load(InputStream,String,String,Parser)", "[void]crossStreams(InputStream,OutputStream)", "[Document]parseInputStream(ControllableInputStream,String,String,Parser)", "[CharsetDoc]detectCharset(ControllableInputStream,String,String,Parser)", "[Document]parseInputStream(CharsetDoc,String,Parser)", "[ByteBuffer]readToByteBuffer(InputStream,int)", "[ByteBuffer]emptyByteBuffer()", "[String]getCharsetFromContentType(String)", "[String]validateCharset(String)", "[String]mimeBoundary()", "[String]detectCharsetFromBom(ControllableInputStream)"], "method_uris": ["src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[]DataUtil()", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(File,String,String)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(File,String,String,Parser)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(Path,String,String)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(Path,String,String,Parser)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[StreamParser]streamParser(Path,Charset,String,Parser)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[ControllableInputStream]openStream(Path)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(InputStream,String,String)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]load(InputStream,String,String,Parser)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[void]crossStreams(InputStream,OutputStream)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]parseInputStream(ControllableInputStream,String,String,Parser)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[CharsetDoc]detectCharset(ControllableInputStream,String,String,Parser)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[Document]parseInputStream(CharsetDoc,String,Parser)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[ByteBuffer]readToByteBuffer(InputStream,int)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[ByteBuffer]emptyByteBuffer()", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[String]getCharsetFromContentType(String)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[String]validateCharset(String)", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[String]mimeBoundary()", "src/main/java/org/jsoup/helper/DataUtil.java.DataUtil.[String]detectCharsetFromBom(ControllableInputStream)"], "overrides": null, "attributes": [{"original_string": "    static class CharsetDoc {\n        Charset charset;\n        InputStream input;\n        @Nullable Document doc;\n\n        CharsetDoc(Charset charset, @Nullable Document doc, InputStream input) {\n            this.charset = charset;\n            this.input = input;\n            this.doc = doc;\n        }\n    }", "definition": "    static class CharsetDoc", "class_docstring": " A struct to return a detected charset, and a document (if fully read).", "name": "CharsetDoc", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Charset charset;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Charset", "name": "charset", "syntax_pass": true}, {"attribute_expression": "InputStream input;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "InputStream", "name": "input", "syntax_pass": true}, {"attribute_expression": "@Nullable Document doc;", "docstring": "", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "Document", "name": "doc", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        CharsetDoc(Charset charset, @Nullable Document doc, InputStream input) {\n            this.charset = charset;\n            this.input = input;\n            this.doc = doc;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CharsetDoc", "params": [{"name": "charset", "type": "Charset"}, {"name": "doc", "type": "Document"}, {"name": "input", "type": "InputStream"}], "body": "                                                                               {\n            this.charset = charset;\n            this.input = input;\n            this.doc = doc;\n        }", "signature": "CharsetDoc(Charset charset, @Nullable Document doc, InputStream input)"}]}], "class_docstring": "\nInternal static utilities for handling data.\n\n", "original_string": "@SuppressWarnings(\"CharsetObjectCanBeUsed\")\npublic final class DataUtil {\n    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\");\n    public static final Charset UTF_8 = Charset.forName(\"UTF-8\"); // Don't use StandardCharsets, as those only appear in Android API 19, and we target 10.\n    static final String defaultCharsetName = UTF_8.name(); // used if not found in header or meta charset\n    private static final int firstReadBufferSize = 1024 * 5;\n    private static final char[] mimeBoundaryChars =\n            \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n    static final int boundaryLength = 32;\n\n    private DataUtil() {}\n\n    /**\n     * Loads and parses a file to a Document, with the HtmlParser. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})\n     * are supported in addition to uncompressed files.\n     *\n     * @param file file to load\n     * @param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in\n     *     the file will always override this setting.\n     * @param baseUri base URI of document, to resolve relative links against\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(File file, @Nullable String charsetName, String baseUri) throws IOException {\n        return load(file.toPath(), charsetName, baseUri);\n    }\n\n    /**\n     * Loads and parses a file to a Document. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})\n     * are supported in addition to uncompressed files.\n     *\n     * @param file file to load\n     * @param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in\n     *     the file will always override this setting.\n     * @param baseUri base URI of document, to resolve relative links against\n     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n\n     * @return Document\n     * @throws IOException on IO error\n     * @since 1.14.2\n     */\n    public static Document load(File file, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return load(file.toPath(), charsetName, baseUri, parser);\n    }\n\n    /**\n     * Loads and parses a file to a Document, with the HtmlParser. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})\n     * are supported in addition to uncompressed files.\n     *\n     * @param path file to load\n     * @param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in\n     *     the file will always override this setting.\n     * @param baseUri base URI of document, to resolve relative links against\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(Path path, @Nullable String charsetName, String baseUri) throws IOException {\n        return load(path, charsetName, baseUri, Parser.htmlParser());\n    }\n\n    /**\n     * Loads and parses a file to a Document. Files that are compressed with gzip (and end in {@code .gz} or {@code .z})\n     * are supported in addition to uncompressed files.\n     *\n     * @param path file to load\n     * @param charsetName (optional) character set of input; specify {@code null} to attempt to autodetect. A BOM in\n     * the file will always override this setting.\n     * @param baseUri base URI of document, to resolve relative links against\n     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n\n     * @return Document\n     * @throws IOException on IO error\n     * @since 1.17.2\n     */\n    public static Document load(Path path, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return parseInputStream(openStream(path), charsetName, baseUri, parser);\n    }\n\n    /**\n     * Returns a {@link StreamParser} that will parse the supplied file progressively.\n     * Files that are compressed with gzip (and end in {@code .gz} or {@code .z})\n     * are supported in addition to uncompressed files.\n     *\n     * @param path file to load\n     * @param charset (optional) character set of input; specify {@code null} to attempt to autodetect from metadata.\n     * A BOM in the file will always override this setting.\n     * @param baseUri base URI of document, to resolve relative links against\n     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n\n     * @return Document\n     * @throws IOException on IO error\n     * @since 1.18.2\n     * @see Connection.Response#streamParser()\n     */\n    public static StreamParser streamParser(Path path, @Nullable Charset charset, String baseUri, Parser parser) throws IOException {\n        StreamParser streamer = new StreamParser(parser);\n        String charsetName = charset != null? charset.name() : null;\n        DataUtil.CharsetDoc charsetDoc = DataUtil.detectCharset(openStream(path), charsetName, baseUri, parser);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(charsetDoc.input, charsetDoc.charset), DefaultBufferSize);\n        streamer.parse(reader, baseUri); // initializes the parse and the document, but does not step() it\n\n        return streamer;\n    }\n\n    /** Open an input stream from a file; if it's a gzip file, returns a GZIPInputStream to unzip it. */\n    private static ControllableInputStream openStream(Path path) throws IOException {\n        final SeekableByteChannel byteChannel = Files.newByteChannel(path);\n        InputStream stream = Channels.newInputStream(byteChannel);\n        String name = Normalizer.lowerCase(path.getFileName().toString());\n        if (name.endsWith(\".gz\") || name.endsWith(\".z\")) {\n            final boolean zipped = (stream.read() == 0x1f && stream.read() == 0x8b); // gzip magic bytes\n            byteChannel.position(0); // reset to start of file\n            if (zipped) {\n                stream = new GZIPInputStream(stream);\n            }\n        }\n        return ControllableInputStream.wrap(stream, 0);\n    }\n\n    /**\n     * Parses a Document from an input steam.\n     * @param in input stream to parse. The stream will be closed after reading.\n     * @param charsetName character set of input (optional)\n     * @param baseUri base URI of document, to resolve relative links against\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(InputStream in, @Nullable String charsetName, String baseUri) throws IOException {\n        return parseInputStream(ControllableInputStream.wrap(in, 0), charsetName, baseUri, Parser.htmlParser());\n    }\n\n    /**\n     * Parses a Document from an input steam, using the provided Parser.\n     * @param in input stream to parse. The stream will be closed after reading.\n     * @param charsetName character set of input (optional)\n     * @param baseUri base URI of document, to resolve relative links against\n     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n     * @return Document\n     * @throws IOException on IO error\n     */\n    public static Document load(InputStream in, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        return parseInputStream(ControllableInputStream.wrap(in, 0), charsetName, baseUri, parser);\n    }\n\n    /**\n     * Writes the input stream to the output stream. Doesn't close them.\n     * @param in input stream to read from\n     * @param out output stream to write to\n     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[DefaultBufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);\n        }\n    }\n\n    /** A struct to return a detected charset, and a document (if fully read). */\n    static class CharsetDoc {\n        Charset charset;\n        InputStream input;\n        @Nullable Document doc;\n\n        CharsetDoc(Charset charset, @Nullable Document doc, InputStream input) {\n            this.charset = charset;\n            this.input = input;\n            this.doc = doc;\n        }\n    }\n\n    static Document parseInputStream(@Nullable ControllableInputStream input, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        if (input == null) // empty body // todo reconsider?\n            return new Document(baseUri);\n\n        final Document doc;\n        CharsetDoc charsetDoc = null;\n        try {\n            charsetDoc = detectCharset(input, charsetName, baseUri, parser);\n            doc = parseInputStream(charsetDoc, baseUri, parser);\n        } finally {\n            if (charsetDoc != null)\n                charsetDoc.input.close();\n        }\n        return doc;\n    }\n\n    static CharsetDoc detectCharset(ControllableInputStream input, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {\n        Document doc = null;\n        // read the start of the stream and look for a BOM or meta charset:\n        // look for BOM - overrides any other header or input\n        String bomCharset = detectCharsetFromBom(input); // resets / consumes appropriately\n        if (bomCharset != null)\n            charsetName = bomCharset;\n\n        if (charsetName == null) { // read ahead and determine from meta. safe first parse as UTF-8\n            int origMax = input.max();\n            input.max(firstReadBufferSize);\n            input.mark(firstReadBufferSize);\n            input.allowClose(false); // ignores closes during parse, in case we need to rewind\n            try {\n                Reader reader = new InputStreamReader(input, UTF_8); // input is currently capped to firstReadBufferSize\n                doc = parser.parseInput(reader, baseUri);\n                input.reset();\n                input.max(origMax); // reset for a full read if required\n            } catch (UncheckedIOException e) {\n                throw e.getCause();\n            } finally {\n                input.allowClose(true);\n            }\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharsetName)) { // need to re-decode. (case-insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (input.baseReadFully()) { // if we have read fully, and the charset was correct, keep that current parse\n                input.close(); // the parser tried to close it\n            } else {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n\n        // finally: prepare the return struct\n        if (charsetName == null)\n            charsetName = defaultCharsetName;\n        Charset charset = charsetName.equals(defaultCharsetName) ? UTF_8 : Charset.forName(charsetName);\n        return new CharsetDoc(charset, doc, input);\n    }\n\n    static Document parseInputStream(CharsetDoc charsetDoc, String baseUri, Parser parser) throws IOException {\n        // if doc != null it was fully parsed during charset detection; so just return that\n        if (charsetDoc.doc != null)\n            return charsetDoc.doc;\n\n        final InputStream input = charsetDoc.input;\n        Validate.notNull(input);\n        final Document doc;\n        final Charset charset = charsetDoc.charset;\n        try (Reader reader = new InputStreamReader(input, charset)) {\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.getCause();\n            }\n            doc.outputSettings().charset(charset);\n            if (!charset.canEncode()) {\n                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n                doc.charset(UTF_8);\n            }\n        }\n        return doc;\n    }\n\n    /**\n     * Read the input stream into a byte buffer. To deal with slow input streams, you may interrupt the thread this\n     * method is executing on. The data read until being interrupted will be available.\n     * @param inStream the input stream to read from\n     * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n     * @return the filled byte buffer\n     * @throws IOException if an exception occurs whilst reading from the input stream.\n     */\n    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        return ControllableInputStream.readToByteBuffer(inStream, maxSize);\n    }\n\n    static ByteBuffer emptyByteBuffer() {\n        return ByteBuffer.allocate(0);\n    }\n\n    /**\n     * Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n     * will kick in.)\n     * @param contentType e.g. \"text/html; charset=EUC-JP\"\n     * @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n     */\n    static @Nullable String getCharsetFromContentType(@Nullable String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            return validateCharset(charset);\n        }\n        return null;\n    }\n\n    private @Nullable static String validateCharset(@Nullable String cs) {\n        if (cs == null || cs.length() == 0) return null;\n        cs = cs.trim().replaceAll(\"[\\\"']\", \"\");\n        try {\n            if (Charset.isSupported(cs)) return cs;\n            cs = cs.toUpperCase(Locale.ENGLISH);\n            if (Charset.isSupported(cs)) return cs;\n        } catch (IllegalCharsetNameException e) {\n            // if all this charset matching fails.... we just take the default\n        }\n        return null;\n    }\n\n    /**\n     * Creates a random string, suitable for use as a mime boundary\n     */\n    static String mimeBoundary() {\n        final StringBuilder mime = StringUtil.borrowBuilder();\n        final Random rand = new Random();\n        for (int i = 0; i < boundaryLength; i++) {\n            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n        }\n        return StringUtil.releaseBuilder(mime);\n    }\n\n    private static @Nullable String detectCharsetFromBom(ControllableInputStream input) throws IOException {\n        byte[] bom = new byte[4];\n        input.mark(bom.length);\n        //noinspection ResultOfMethodCallIgnored\n        input.read(bom, 0, 4);\n        input.reset();\n\n        // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n            return \"UTF-32\"; // and I hope it's on your system\n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            return \"UTF-16\"; // in all Javas\n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            input.read(bom, 0, 3); // consume the UTF-8 BOM\n            return \"UTF-8\"; // in all Javas\n        }\n        return null;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\")", "syntax_pass": true}, {"attribute_expression": "public static final Charset UTF_8 = Charset.forName(\"UTF-8\");", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Charset", "name": "UTF_8 = Charset.forName(\"UTF-8\")", "syntax_pass": true}, {"attribute_expression": "static final String defaultCharsetName = UTF_8.name();", "docstring": " Don't use StandardCharsets, as those only appear in Android API 19, and we target 10.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "defaultCharsetName = UTF_8.name()", "syntax_pass": true}, {"attribute_expression": "private static final int firstReadBufferSize = 1024 * 5;", "docstring": " used if not found in header or meta charset", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "firstReadBufferSize = 1024 * 5", "syntax_pass": true}, {"attribute_expression": "private static final char[] mimeBoundaryChars =\n            \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char[]", "name": "mimeBoundaryChars =\n            \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray()", "syntax_pass": true}, {"attribute_expression": "static final int boundaryLength = 32;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "boundaryLength = 32", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/helper/ValidationException.java.ValidationException", "name": "ValidationException", "file_path": "src/main/java/org/jsoup/helper/ValidationException.java", "superclasses": "IllegalArgumentException", "methods": ["[]ValidationException(String)", "[Throwable]fillInStackTrace()"], "method_uris": ["src/main/java/org/jsoup/helper/ValidationException.java.ValidationException.[]ValidationException(String)", "src/main/java/org/jsoup/helper/ValidationException.java.ValidationException.[Throwable]fillInStackTrace()"], "overrides": null, "attributes": [], "class_docstring": "\nValidation exceptions, as thrown by the methods in {@link Validate}.\n", "original_string": "public class ValidationException extends IllegalArgumentException {\n\n    public static final String Validator = Validate.class.getName();\n\n    public ValidationException(String msg) {\n        super(msg);\n    }\n\n    @Override\n    public synchronized Throwable fillInStackTrace() {\n        // Filters out the Validate class from the stacktrace, to more clearly point at the root-cause.\n\n        super.fillInStackTrace();\n\n        StackTraceElement[] stackTrace = getStackTrace();\n        List<StackTraceElement> filteredTrace = new ArrayList<>();\n        for (StackTraceElement trace : stackTrace) {\n            if (trace.getClassName().equals(Validator)) continue;\n            filteredTrace.add(trace);\n        }\n\n        setStackTrace(filteredTrace.toArray(new StackTraceElement[0]));\n\n        return this;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String Validator = Validate.class.getName();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "Validator = Validate.class.getName()", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil", "name": "CookieUtil", "file_path": "src/main/java/org/jsoup/helper/CookieUtil.java", "superclasses": "", "methods": ["[void]applyCookiesToRequest(HttpConnection.Request,HttpURLConnection)", "[LinkedHashSet<String>]requestCookieSet(Connection.Request)", "[URI]asUri(URL)", "[void]storeCookies(HttpConnection.Request,HttpConnection.Response,URL,Map<String, List<String>>)"], "method_uris": ["src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil.[void]applyCookiesToRequest(HttpConnection.Request,HttpURLConnection)", "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil.[LinkedHashSet<String>]requestCookieSet(Connection.Request)", "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil.[URI]asUri(URL)", "src/main/java/org/jsoup/helper/CookieUtil.java.CookieUtil.[void]storeCookies(HttpConnection.Request,HttpConnection.Response,URL,Map<String, List<String>>)"], "overrides": null, "attributes": [], "class_docstring": "\nHelper functions to support the Cookie Manager / Cookie Storage in HttpConnection.\n\n@since 1.14.1", "original_string": "class CookieUtil {\n    // cookie manager get() wants request headers but doesn't use them, so we just pass a dummy object here\n    private static final Map<String, List<String>> EmptyRequestHeaders = Collections.unmodifiableMap(new HashMap<>());\n    private static final String Sep = \"; \";\n    private static final String CookieName = \"Cookie\";\n    private static final String Cookie2Name = \"Cookie2\";\n\n    /**\n     Pre-request, get any applicable headers out of the Request cookies and the Cookie Store, and add them to the request\n     headers. If the Cookie Store duplicates any Request cookies (same name and value), they will be discarded.\n     */\n    static void applyCookiesToRequest(HttpConnection.Request req, HttpURLConnection con) throws IOException {\n        // Request key/val cookies. LinkedHashSet used to preserve order, as cookie store will return most specific path first\n        Set<String> cookieSet = requestCookieSet(req);\n        Set<String> cookies2 = null;\n\n        // stored:\n        Map<String, List<String>> storedCookies = req.cookieManager().get(asUri(req.url), EmptyRequestHeaders);\n        for (Map.Entry<String, List<String>> entry : storedCookies.entrySet()) {\n            // might be Cookie: name=value; name=value\\nCookie2: name=value; name=value\n            List<String> cookies = entry.getValue(); // these will be name=val\n            if (cookies == null || cookies.size() == 0) // the cookie store often returns just an empty \"Cookie\" key, no val\n                continue;\n\n            String key = entry.getKey(); // Cookie or Cookie2\n            Set<String> set;\n            if (CookieName.equals(key))\n                set = cookieSet;\n            else if (Cookie2Name.equals(key)) {\n                set = new HashSet<>();\n                cookies2 = set;\n            } else {\n                continue; // unexpected header key\n            }\n            set.addAll(cookies);\n        }\n\n        if (cookieSet.size() > 0)\n            con.addRequestProperty(CookieName, StringUtil.join(cookieSet, Sep));\n        if (cookies2 != null && cookies2.size() > 0)\n            con.addRequestProperty(Cookie2Name, StringUtil.join(cookies2, Sep));\n    }\n\n    private static LinkedHashSet<String> requestCookieSet(Connection.Request req) {\n        LinkedHashSet<String> set = new LinkedHashSet<>();\n        // req cookies are the wildcard key/val cookies (no domain, path, etc)\n        for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {\n            set.add(cookie.getKey() + \"=\" + cookie.getValue());\n        }\n        return set;\n    }\n\n    static URI asUri(URL url) throws IOException {\n        try {\n            return url.toURI();\n        } catch (URISyntaxException e) {  // this would be a WTF because we construct the URL\n            MalformedURLException ue = new MalformedURLException(e.getMessage());\n            ue.initCause(e);\n            throw ue;\n        }\n    }\n\n    /** Store the Result cookies into the cookie manager, and place relevant cookies into the Response object. */\n    static void storeCookies(HttpConnection.Request req, HttpConnection.Response res, URL url, Map<String, List<String>> resHeaders) throws IOException {\n        CookieManager manager = req.cookieManager();\n        URI uri = CookieUtil.asUri(url);\n        manager.put(uri, resHeaders); // stores cookies for session\n\n        // set up the simple cookie(name, value) map:\n        Map<String, List<String>> cookieMap = manager.get(uri, resHeaders); // get cookies for url; may have been set on this or earlier requests. the headers here are ignored other than a null check\n        for (List<String> values : cookieMap.values()) {\n            for (String headerVal : values) {\n                List<HttpCookie> cookies = HttpCookie.parse(headerVal);\n                for (HttpCookie cookie : cookies) {\n                    res.cookie(cookie.getName(), cookie.getValue());\n                }\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Map<String, List<String>> EmptyRequestHeaders = Collections.unmodifiableMap(new HashMap<>());", "docstring": " cookie manager get() wants request headers but doesn't use them, so we just pass a dummy object here", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<String, List<String>>", "name": "EmptyRequestHeaders = Collections.unmodifiableMap(new HashMap<>())", "syntax_pass": true}, {"attribute_expression": "private static final String Sep = \"; \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "Sep = \"; \"", "syntax_pass": true}, {"attribute_expression": "private static final String CookieName = \"Cookie\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CookieName = \"Cookie\"", "syntax_pass": true}, {"attribute_expression": "private static final String Cookie2Name = \"Cookie2\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "Cookie2Name = \"Cookie2\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom", "name": "W3CDom", "file_path": "src/main/java/org/jsoup/helper/W3CDom.java", "superclasses": "", "methods": ["[]W3CDom()", "[boolean]namespaceAware()", "[W3CDom]namespaceAware(boolean)", "[Document]convert(org.jsoup.nodes.Document)", "[String]asString(Document,Map<String, String>)", "[Properties]propertiesFromMap(Map<String, String>)", "[HashMap<String, String>]OutputHtml()", "[HashMap<String, String>]OutputXml()", "[HashMap<String, String>]methodMap(String)", "[Document]fromJsoup(org.jsoup.nodes.Document)", "[Document]fromJsoup(org.jsoup.nodes.Element)", "[void]convert(org.jsoup.nodes.Document,Document)", "[void]convert(org.jsoup.nodes.Element,Document)", "[NodeList]selectXpath(String,Document)", "[NodeList]selectXpath(String,Node)", "[List<T>]sourceNodes(NodeList,Class<T>)", "[Node]contextNode(Document)", "[String]asString(Document)"], "method_uris": ["src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[]W3CDom()", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[boolean]namespaceAware()", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[W3CDom]namespaceAware(boolean)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Document]convert(org.jsoup.nodes.Document)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[String]asString(Document,Map<String, String>)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Properties]propertiesFromMap(Map<String, String>)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[HashMap<String, String>]OutputHtml()", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[HashMap<String, String>]OutputXml()", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[HashMap<String, String>]methodMap(String)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Document]fromJsoup(org.jsoup.nodes.Document)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Document]fromJsoup(org.jsoup.nodes.Element)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[void]convert(org.jsoup.nodes.Document,Document)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[void]convert(org.jsoup.nodes.Element,Document)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[NodeList]selectXpath(String,Document)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[NodeList]selectXpath(String,Node)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[List<T>]sourceNodes(NodeList,Class<T>)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[Node]contextNode(Document)", "src/main/java/org/jsoup/helper/W3CDom.java.W3CDom.[String]asString(Document)"], "overrides": null, "attributes": [{"original_string": "    protected static class W3CBuilder implements NodeVisitor {\n        // TODO: move the namespace handling stuff into XmlTreeBuilder / HtmlTreeBuilder, now that Tags have namespaces\n        private static final String xmlnsKey = \"xmlns\";\n        private static final String xmlnsPrefix = \"xmlns:\";\n\n        private final Document doc;\n        private boolean namespaceAware = true;\n        private final Stack<HashMap<String, String>> namespacesStack = new Stack<>(); // stack of namespaces, prefix => urn\n        private Node dest;\n        private Syntax syntax = Syntax.xml; // the syntax (to coerce attributes to). From the input doc if available.\n        /*@Nullable*/ private final org.jsoup.nodes.Element contextElement; // todo - unsure why this can't be marked nullable?\n\n        public W3CBuilder(Document doc) {\n            this.doc = doc;\n            namespacesStack.push(new HashMap<>());\n            dest = doc;\n            contextElement = (org.jsoup.nodes.Element) doc.getUserData(ContextProperty); // Track the context jsoup Element, so we can save the corresponding w3c element\n            if (contextElement != null) {\n                final org.jsoup.nodes.Document inDoc = contextElement.ownerDocument();\n                if ( namespaceAware && inDoc != null && inDoc.parser().getTreeBuilder() instanceof HtmlTreeBuilder ) {\n                    // as per the WHATWG HTML5 spec \u00a7 2.1.3, elements are in the HTML namespace by default\n                    namespacesStack.peek().put(\"\", Parser.NamespaceHtml);\n                }\n            }\n        }\n\n        public void head(org.jsoup.nodes.Node source, int depth) {\n            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n            if (source instanceof org.jsoup.nodes.Element) {\n                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\n                String prefix = updateNamespaces(sourceEl);\n                String namespace = namespaceAware ? namespacesStack.peek().get(prefix) : null;\n                String tagName = sourceEl.tagName();\n\n                /* Tag names in XML are quite permissive, but less permissive than HTML. Rather than reimplement the validation,\n                we just try to use it as-is. If it fails, insert as a text node instead. We don't try to normalize the\n                tagname to something safe, because that isn't going to be meaningful downstream. This seems(?) to be\n                how browsers handle the situation, also. https://github.com/jhy/jsoup/issues/1093 */\n                try {\n                    // use an empty namespace if none is present but the tag name has a prefix\n                    String imputedNamespace = namespace == null && tagName.contains(\":\") ? \"\" : namespace;\n                    Element el = doc.createElementNS(imputedNamespace, tagName);\n                    copyAttributes(sourceEl, el);\n                    append(el, sourceEl);\n                    if (sourceEl == contextElement)\n                        doc.setUserData(ContextNodeProperty, el, null);\n                    dest = el; // descend\n                } catch (DOMException e) {\n                    append(doc.createTextNode(\"<\" + tagName + \">\"), sourceEl);\n                }\n            } else if (source instanceof org.jsoup.nodes.TextNode) {\n                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n                Text text = doc.createTextNode(sourceText.getWholeText());\n                append(text, sourceText);\n            } else if (source instanceof org.jsoup.nodes.Comment) {\n                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n                Comment comment = doc.createComment(sourceComment.getData());\n                append(comment, sourceComment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                append(node, sourceData);\n            } else {\n                // unhandled. note that doctype is not handled here - rather it is used in the initial doc creation\n            }\n        }\n\n        private void append(Node append, org.jsoup.nodes.Node source) {\n            append.setUserData(SourceProperty, source, null);\n            dest.appendChild(append);\n        }\n\n        public void tail(org.jsoup.nodes.Node source, int depth) {\n            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n                dest = dest.getParentNode(); // undescend\n            }\n            namespacesStack.pop();\n        }\n\n        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = Attribute.getValidKey(attribute.getKey(), syntax);\n                if (key != null) { // null if couldn't be coerced to validity\n                    el.setAttribute(key, attribute.getValue());\n                }\n            }\n        }\n\n        /**\n         * Finds any namespaces defined in this element. Returns any tag prefix.\n         */\n        private String updateNamespaces(org.jsoup.nodes.Element el) {\n            // scan the element for namespace declarations\n            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n            Attributes attributes = el.attributes();\n            for (Attribute attr : attributes) {\n                String key = attr.getKey();\n                String prefix;\n                if (key.equals(xmlnsKey)) {\n                    prefix = \"\";\n                } else if (key.startsWith(xmlnsPrefix)) {\n                    prefix = key.substring(xmlnsPrefix.length());\n                } else {\n                    continue;\n                }\n                namespacesStack.peek().put(prefix, attr.getValue());\n            }\n\n            // get the element prefix if any\n            int pos = el.tagName().indexOf(':');\n            return pos > 0 ? el.tagName().substring(0, pos) : \"\";\n        }\n\n    }", "definition": "    protected static class W3CBuilder implements NodeVisitor", "class_docstring": "\nImplements the conversion by walking the input.\n", "name": "W3CBuilder", "super_interfaces": ["NodeVisitor"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private static final String xmlnsKey = \"xmlns\";", "docstring": " TODO: move the namespace handling stuff into XmlTreeBuilder / HtmlTreeBuilder, now that Tags have namespaces", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "xmlnsKey = \"xmlns\"", "syntax_pass": true}, {"attribute_expression": "private static final String xmlnsPrefix = \"xmlns:\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "xmlnsPrefix = \"xmlns:\"", "syntax_pass": true}, {"attribute_expression": "private final Document doc;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Document", "name": "doc", "syntax_pass": true}, {"attribute_expression": "private boolean namespaceAware = true;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "namespaceAware = true", "syntax_pass": true}, {"attribute_expression": "private final Stack<HashMap<String, String>> namespacesStack = new Stack<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Stack<HashMap<String, String>>", "name": "namespacesStack = new Stack<>()", "syntax_pass": true}, {"attribute_expression": "private Node dest;", "docstring": " stack of namespaces, prefix => urn", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Node", "name": "dest", "syntax_pass": true}, {"attribute_expression": "private Syntax syntax = Syntax.xml;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Syntax", "name": "syntax = Syntax.xml", "syntax_pass": true}, {"attribute_expression": "private final org.jsoup.nodes.Element contextElement;", "docstring": "@Nullable", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "org.jsoup.nodes.Element", "name": "contextElement", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public W3CBuilder(Document doc) {\n            this.doc = doc;\n            namespacesStack.push(new HashMap<>());\n            dest = doc;\n            contextElement = (org.jsoup.nodes.Element) doc.getUserData(ContextProperty); // Track the context jsoup Element, so we can save the corresponding w3c element\n            if (contextElement != null) {\n                final org.jsoup.nodes.Document inDoc = contextElement.ownerDocument();\n                if ( namespaceAware && inDoc != null && inDoc.parser().getTreeBuilder() instanceof HtmlTreeBuilder ) {\n                    // as per the WHATWG HTML5 spec \u00a7 2.1.3, elements are in the HTML namespace by default\n                    namespacesStack.peek().put(\"\", Parser.NamespaceHtml);\n                }\n            }\n        }", "docstring": " todo - unsure why this can't be marked nullable?", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "W3CBuilder", "params": [{"name": "doc", "type": "Document"}], "body": "                                        {\n            this.doc = doc;\n            namespacesStack.push(new HashMap<>());\n            dest = doc;\n            contextElement = (org.jsoup.nodes.Element) doc.getUserData(ContextProperty); // Track the context jsoup Element, so we can save the corresponding w3c element\n            if (contextElement != null) {\n                final org.jsoup.nodes.Document inDoc = contextElement.ownerDocument();\n                if ( namespaceAware && inDoc != null && inDoc.parser().getTreeBuilder() instanceof HtmlTreeBuilder ) {\n                    // as per the WHATWG HTML5 spec \u00a7 2.1.3, elements are in the HTML namespace by default\n                    namespacesStack.peek().put(\"\", Parser.NamespaceHtml);\n                }\n            }\n        }", "signature": "public W3CBuilder(Document doc)"}, {"syntax_pass": true, "original_string": "        public void head(org.jsoup.nodes.Node source, int depth) {\n            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n            if (source instanceof org.jsoup.nodes.Element) {\n                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\n                String prefix = updateNamespaces(sourceEl);\n                String namespace = namespaceAware ? namespacesStack.peek().get(prefix) : null;\n                String tagName = sourceEl.tagName();\n\n                /* Tag names in XML are quite permissive, but less permissive than HTML. Rather than reimplement the validation,\n                we just try to use it as-is. If it fails, insert as a text node instead. We don't try to normalize the\n                tagname to something safe, because that isn't going to be meaningful downstream. This seems(?) to be\n                how browsers handle the situation, also. https://github.com/jhy/jsoup/issues/1093 */\n                try {\n                    // use an empty namespace if none is present but the tag name has a prefix\n                    String imputedNamespace = namespace == null && tagName.contains(\":\") ? \"\" : namespace;\n                    Element el = doc.createElementNS(imputedNamespace, tagName);\n                    copyAttributes(sourceEl, el);\n                    append(el, sourceEl);\n                    if (sourceEl == contextElement)\n                        doc.setUserData(ContextNodeProperty, el, null);\n                    dest = el; // descend\n                } catch (DOMException e) {\n                    append(doc.createTextNode(\"<\" + tagName + \">\"), sourceEl);\n                }\n            } else if (source instanceof org.jsoup.nodes.TextNode) {\n                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n                Text text = doc.createTextNode(sourceText.getWholeText());\n                append(text, sourceText);\n            } else if (source instanceof org.jsoup.nodes.Comment) {\n                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n                Comment comment = doc.createComment(sourceComment.getData());\n                append(comment, sourceComment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                append(node, sourceData);\n            } else {\n                // unhandled. note that doctype is not handled here - rather it is used in the initial doc creation\n            }\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "head", "params": [{"name": "source", "type": "org.jsoup.nodes.Node"}, {"name": "depth", "type": "int"}], "body": "                                                                 {\n            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n            if (source instanceof org.jsoup.nodes.Element) {\n                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\n                String prefix = updateNamespaces(sourceEl);\n                String namespace = namespaceAware ? namespacesStack.peek().get(prefix) : null;\n                String tagName = sourceEl.tagName();\n\n                /* Tag names in XML are quite permissive, but less permissive than HTML. Rather than reimplement the validation,\n                we just try to use it as-is. If it fails, insert as a text node instead. We don't try to normalize the\n                tagname to something safe, because that isn't going to be meaningful downstream. This seems(?) to be\n                how browsers handle the situation, also. https://github.com/jhy/jsoup/issues/1093 */\n                try {\n                    // use an empty namespace if none is present but the tag name has a prefix\n                    String imputedNamespace = namespace == null && tagName.contains(\":\") ? \"\" : namespace;\n                    Element el = doc.createElementNS(imputedNamespace, tagName);\n                    copyAttributes(sourceEl, el);\n                    append(el, sourceEl);\n                    if (sourceEl == contextElement)\n                        doc.setUserData(ContextNodeProperty, el, null);\n                    dest = el; // descend\n                } catch (DOMException e) {\n                    append(doc.createTextNode(\"<\" + tagName + \">\"), sourceEl);\n                }\n            } else if (source instanceof org.jsoup.nodes.TextNode) {\n                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n                Text text = doc.createTextNode(sourceText.getWholeText());\n                append(text, sourceText);\n            } else if (source instanceof org.jsoup.nodes.Comment) {\n                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n                Comment comment = doc.createComment(sourceComment.getData());\n                append(comment, sourceComment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                append(node, sourceData);\n            } else {\n                // unhandled. note that doctype is not handled here - rather it is used in the initial doc creation\n            }\n        }", "signature": "public void head(org.jsoup.nodes.Node source, int depth)"}, {"syntax_pass": true, "original_string": "        private void append(Node append, org.jsoup.nodes.Node source) {\n            append.setUserData(SourceProperty, source, null);\n            dest.appendChild(append);\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "append", "params": [{"name": "append", "type": "Node"}, {"name": "source", "type": "org.jsoup.nodes.Node"}], "body": "                                                                      {\n            append.setUserData(SourceProperty, source, null);\n            dest.appendChild(append);\n        }", "signature": "private void append(Node append, org.jsoup.nodes.Node source)"}, {"syntax_pass": true, "original_string": "        public void tail(org.jsoup.nodes.Node source, int depth) {\n            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n                dest = dest.getParentNode(); // undescend\n            }\n            namespacesStack.pop();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tail", "params": [{"name": "source", "type": "org.jsoup.nodes.Node"}, {"name": "depth", "type": "int"}], "body": "                                                                 {\n            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n                dest = dest.getParentNode(); // undescend\n            }\n            namespacesStack.pop();\n        }", "signature": "public void tail(org.jsoup.nodes.Node source, int depth)"}, {"syntax_pass": true, "original_string": "        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = Attribute.getValidKey(attribute.getKey(), syntax);\n                if (key != null) { // null if couldn't be coerced to validity\n                    el.setAttribute(key, attribute.getValue());\n                }\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "copyAttributes", "params": [{"name": "source", "type": "org.jsoup.nodes.Node"}, {"name": "el", "type": "Element"}], "body": "                                                                             {\n            for (Attribute attribute : source.attributes()) {\n                String key = Attribute.getValidKey(attribute.getKey(), syntax);\n                if (key != null) { // null if couldn't be coerced to validity\n                    el.setAttribute(key, attribute.getValue());\n                }\n            }\n        }", "signature": "private void copyAttributes(org.jsoup.nodes.Node source, Element el)"}, {"syntax_pass": true, "original_string": "        private String updateNamespaces(org.jsoup.nodes.Element el) {\n            // scan the element for namespace declarations\n            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n            Attributes attributes = el.attributes();\n            for (Attribute attr : attributes) {\n                String key = attr.getKey();\n                String prefix;\n                if (key.equals(xmlnsKey)) {\n                    prefix = \"\";\n                } else if (key.startsWith(xmlnsPrefix)) {\n                    prefix = key.substring(xmlnsPrefix.length());\n                } else {\n                    continue;\n                }\n                namespacesStack.peek().put(prefix, attr.getValue());\n            }\n\n            // get the element prefix if any\n            int pos = el.tagName().indexOf(':');\n            return pos > 0 ? el.tagName().substring(0, pos) : \"\";\n        }", "docstring": "\nFinds any namespaces defined in this element. Returns any tag prefix.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "updateNamespaces", "params": [{"name": "el", "type": "org.jsoup.nodes.Element"}], "body": "                                                                    {\n            // scan the element for namespace declarations\n            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n            Attributes attributes = el.attributes();\n            for (Attribute attr : attributes) {\n                String key = attr.getKey();\n                String prefix;\n                if (key.equals(xmlnsKey)) {\n                    prefix = \"\";\n                } else if (key.startsWith(xmlnsPrefix)) {\n                    prefix = key.substring(xmlnsPrefix.length());\n                } else {\n                    continue;\n                }\n                namespacesStack.peek().put(prefix, attr.getValue());\n            }\n\n            // get the element prefix if any\n            int pos = el.tagName().indexOf(':');\n            return pos > 0 ? el.tagName().substring(0, pos) : \"\";\n        }", "signature": "private String updateNamespaces(org.jsoup.nodes.Element el)"}]}], "class_docstring": "\nHelper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},\nfor integration with toolsets that use the W3C DOM.\n", "original_string": "public class W3CDom {\n    /** For W3C Documents created by this class, this property is set on each node to link back to the original jsoup node. */\n    public static final String SourceProperty = \"jsoupSource\";\n    private static final String ContextProperty = \"jsoupContextSource\"; // tracks the jsoup context element on w3c doc\n    private static final String ContextNodeProperty = \"jsoupContextNode\"; // the w3c node used as the creating context\n\n    /**\n     To get support for XPath versions &gt; 1, set this property to the classname of an alternate XPathFactory\n     implementation. (For e.g. {@code net.sf.saxon.xpath.XPathFactoryImpl}).\n     */\n    public static final String XPathFactoryProperty = \"javax.xml.xpath.XPathFactory:jsoup\";\n\n    protected DocumentBuilderFactory factory;\n    private boolean namespaceAware = true; // false when using selectXpath, for user's query convenience\n\n    public W3CDom() {\n        factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n    }\n\n    /**\n     Returns if this W3C DOM is namespace aware. By default, this will be {@code true}, but is disabled for simplicity\n     when using XPath selectors in {@link org.jsoup.nodes.Element#selectXpath(String)}.\n     @return the current namespace aware setting.\n     */\n    public boolean namespaceAware() {\n        return namespaceAware;\n    }\n\n    /**\n     Update the namespace aware setting. This impacts the factory that is used to create W3C nodes from jsoup nodes.\n     <p>For HTML documents, controls if the document will be in the default {@code http://www.w3.org/1999/xhtml}\n     namespace if otherwise unset.</p>.\n     @param namespaceAware the updated setting\n     @return this W3CDom, for chaining.\n     */\n    public W3CDom namespaceAware(boolean namespaceAware) {\n        this.namespaceAware = namespaceAware;\n        factory.setNamespaceAware(namespaceAware);\n        return this;\n    }\n\n    /**\n     * Converts a jsoup DOM to a W3C DOM.\n     *\n     * @param in jsoup Document\n     * @return W3C Document\n     */\n    public static Document convert(org.jsoup.nodes.Document in) {\n        return (new W3CDom().fromJsoup(in));\n    }\n\n    /**\n     * Serialize a W3C document to a String. Provide Properties to define output settings including if HTML or XML. If\n     * you don't provide the properties ({@code null}), the output will be auto-detected based on the content of the\n     * document.\n     *\n     * @param doc Document\n     * @param properties (optional/nullable) the output properties to use. See {@link\n     *     Transformer#setOutputProperties(Properties)} and {@link OutputKeys}\n     * @return Document as string\n     * @see #OutputHtml\n     * @see #OutputXml\n     * @see OutputKeys#ENCODING\n     * @see OutputKeys#OMIT_XML_DECLARATION\n     * @see OutputKeys#STANDALONE\n     * @see OutputKeys#STANDALONE\n     * @see OutputKeys#DOCTYPE_PUBLIC\n     * @see OutputKeys#CDATA_SECTION_ELEMENTS\n     * @see OutputKeys#INDENT\n     * @see OutputKeys#MEDIA_TYPE\n     */\n    public static String asString(Document doc, @Nullable Map<String, String> properties) {\n        try {\n            DOMSource domSource = new DOMSource(doc);\n            StringWriter writer = new StringWriter();\n            StreamResult result = new StreamResult(writer);\n            TransformerFactory tf = TransformerFactory.newInstance();\n            Transformer transformer = tf.newTransformer();\n            if (properties != null)\n                transformer.setOutputProperties(propertiesFromMap(properties));\n\n            if (doc.getDoctype() != null) {\n                DocumentType doctype = doc.getDoctype();\n                if (!StringUtil.isBlank(doctype.getPublicId()))\n                    transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctype.getPublicId());\n                if (!StringUtil.isBlank(doctype.getSystemId()))\n                    transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctype.getSystemId());\n                    // handle <!doctype html> for legacy dom. TODO: nicer if <!doctype html>\n                else if (doctype.getName().equalsIgnoreCase(\"html\")\n                    && StringUtil.isBlank(doctype.getPublicId())\n                    && StringUtil.isBlank(doctype.getSystemId()))\n                    transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, \"about:legacy-compat\");\n            }\n\n            transformer.transform(domSource, result);\n            return writer.toString();\n\n        } catch (TransformerException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    static Properties propertiesFromMap(Map<String, String> map) {\n        Properties props = new Properties();\n        props.putAll(map);\n        return props;\n    }\n\n    /** Canned default for HTML output. */\n    public static HashMap<String, String> OutputHtml() {\n        return methodMap(\"html\");\n    }\n\n    /** Canned default for XML output. */\n    public static HashMap<String, String> OutputXml() {\n        return methodMap(\"xml\");\n    }\n\n    private static HashMap<String, String> methodMap(String method) {\n        HashMap<String, String> map = new HashMap<>();\n        map.put(METHOD, method);\n        return map;\n    }\n\n    /**\n     * Convert a jsoup Document to a W3C Document. The created nodes will link back to the original\n     * jsoup nodes in the user property {@link #SourceProperty} (but after conversion, changes on one side will not\n     * flow to the other).\n     *\n     * @param in jsoup doc\n     * @return a W3C DOM Document representing the jsoup Document or Element contents.\n     */\n    public Document fromJsoup(org.jsoup.nodes.Document in) {\n        // just method API backcompat\n        return fromJsoup((org.jsoup.nodes.Element) in);\n    }\n\n    /**\n     * Convert a jsoup DOM to a W3C Document. The created nodes will link back to the original\n     * jsoup nodes in the user property {@link #SourceProperty} (but after conversion, changes on one side will not\n     * flow to the other). The input Element is used as a context node, but the whole surrounding jsoup Document is\n     * converted. (If you just want a subtree converted, use {@link #convert(org.jsoup.nodes.Element, Document)}.)\n     *\n     * @param in jsoup element or doc\n     * @return a W3C DOM Document representing the jsoup Document or Element contents.\n     * @see #sourceNodes(NodeList, Class)\n     * @see #contextNode(Document)\n     */\n    public Document fromJsoup(org.jsoup.nodes.Element in) {\n        Validate.notNull(in);\n        DocumentBuilder builder;\n        try {\n            builder = factory.newDocumentBuilder();\n            DOMImplementation impl = builder.getDOMImplementation();\n            Document out = builder.newDocument();\n            org.jsoup.nodes.Document inDoc = in.ownerDocument();\n            org.jsoup.nodes.DocumentType doctype = inDoc != null ? inDoc.documentType() : null;\n            if (doctype != null) {\n                try {\n                    org.w3c.dom.DocumentType documentType = impl.createDocumentType(doctype.name(), doctype.publicId(), doctype.systemId());\n                    out.appendChild(documentType);\n                } catch (DOMException ignored) {\n                    // invalid / empty doctype dropped\n                }\n            }\n            out.setXmlStandalone(true);\n            // if in is Document, use the root element, not the wrapping document, as the context:\n            org.jsoup.nodes.Element context = (in instanceof org.jsoup.nodes.Document) ? in.firstElementChild() : in;\n            out.setUserData(ContextProperty, context, null);\n            convert(inDoc != null ? inDoc : in, out);\n            return out;\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    /**\n     * Converts a jsoup document into the provided W3C Document. If required, you can set options on the output\n     * document before converting.\n     *\n     * @param in jsoup doc\n     * @param out w3c doc\n     * @see org.jsoup.helper.W3CDom#fromJsoup(org.jsoup.nodes.Element)\n     */\n    public void convert(org.jsoup.nodes.Document in, Document out) {\n        // just provides method API backcompat\n        convert((org.jsoup.nodes.Element) in, out);\n    }\n\n    /**\n     * Converts a jsoup element into the provided W3C Document. If required, you can set options on the output\n     * document before converting.\n     *\n     * @param in jsoup element\n     * @param out w3c doc\n     * @see org.jsoup.helper.W3CDom#fromJsoup(org.jsoup.nodes.Element)\n     */\n    public void convert(org.jsoup.nodes.Element in, Document out) {\n        W3CBuilder builder = new W3CBuilder(out);\n        builder.namespaceAware = namespaceAware;\n        org.jsoup.nodes.Document inDoc = in.ownerDocument();\n        if (inDoc != null) {\n            if (!StringUtil.isBlank(inDoc.location())) {\n                out.setDocumentURI(inDoc.location());\n            }\n            builder.syntax = inDoc.outputSettings().syntax();\n        }\n        org.jsoup.nodes.Element rootEl = in instanceof org.jsoup.nodes.Document ? in.firstElementChild() : in; // skip the #root node if a Document\n        NodeTraversor.traverse(builder, rootEl);\n    }\n\n    /**\n     Evaluate an XPath query against the supplied document, and return the results.\n     @param xpath an XPath query\n     @param doc the document to evaluate against\n     @return the matches nodes\n     */\n    public NodeList selectXpath(String xpath, Document doc) {\n        return selectXpath(xpath, (Node) doc);\n    }\n\n    /**\n     Evaluate an XPath query against the supplied context node, and return the results.\n     @param xpath an XPath query\n     @param contextNode the context node to evaluate against\n     @return the matches nodes\n     */\n    public NodeList selectXpath(String xpath, Node contextNode) {\n        Validate.notEmptyParam(xpath, \"xpath\");\n        Validate.notNullParam(contextNode, \"contextNode\");\n\n        NodeList nodeList;\n        try {\n            // if there is a configured XPath factory, use that instead of the Java base impl:\n            String property = System.getProperty(XPathFactoryProperty);\n            final XPathFactory xPathFactory = property != null ?\n                XPathFactory.newInstance(\"jsoup\") :\n                XPathFactory.newInstance();\n\n            XPathExpression expression = xPathFactory.newXPath().compile(xpath);\n            nodeList = (NodeList) expression.evaluate(contextNode, XPathConstants.NODESET); // love the strong typing here /s\n            Validate.notNull(nodeList);\n        } catch (XPathExpressionException | XPathFactoryConfigurationException e) {\n            throw new Selector.SelectorParseException(\n                e, \"Could not evaluate XPath query [%s]: %s\", xpath, e.getMessage());\n        }\n        return nodeList;\n    }\n\n    /**\n     Retrieves the original jsoup DOM nodes from a nodelist created by this convertor.\n     @param nodeList the W3C nodes to get the original jsoup nodes from\n     @param nodeType the jsoup node type to retrieve (e.g. Element, DataNode, etc)\n     @param <T> node type\n     @return a list of the original nodes\n     */\n    public <T extends org.jsoup.nodes.Node> List<T> sourceNodes(NodeList nodeList, Class<T> nodeType) {\n        Validate.notNull(nodeList);\n        Validate.notNull(nodeType);\n        List<T> nodes = new ArrayList<>(nodeList.getLength());\n\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            org.w3c.dom.Node node = nodeList.item(i);\n            Object source = node.getUserData(W3CDom.SourceProperty);\n            if (nodeType.isInstance(source))\n                nodes.add(nodeType.cast(source));\n        }\n\n        return nodes;\n    }\n\n    /**\n     For a Document created by {@link #fromJsoup(org.jsoup.nodes.Element)}, retrieves the W3C context node.\n     @param wDoc Document created by this class\n     @return the corresponding W3C Node to the jsoup Element that was used as the creating context.\n     */\n    public Node contextNode(Document wDoc) {\n        return (Node) wDoc.getUserData(ContextNodeProperty);\n    }\n\n    /**\n     * Serialize a W3C document to a String. The output format will be XML or HTML depending on the content of the doc.\n     *\n     * @param doc Document\n     * @return Document as string\n     * @see W3CDom#asString(Document, Map)\n     */\n    public String asString(Document doc) {\n        return asString(doc, null);\n    }\n\n    /**\n     * Implements the conversion by walking the input.\n     */\n    protected static class W3CBuilder implements NodeVisitor {\n        // TODO: move the namespace handling stuff into XmlTreeBuilder / HtmlTreeBuilder, now that Tags have namespaces\n        private static final String xmlnsKey = \"xmlns\";\n        private static final String xmlnsPrefix = \"xmlns:\";\n\n        private final Document doc;\n        private boolean namespaceAware = true;\n        private final Stack<HashMap<String, String>> namespacesStack = new Stack<>(); // stack of namespaces, prefix => urn\n        private Node dest;\n        private Syntax syntax = Syntax.xml; // the syntax (to coerce attributes to). From the input doc if available.\n        /*@Nullable*/ private final org.jsoup.nodes.Element contextElement; // todo - unsure why this can't be marked nullable?\n\n        public W3CBuilder(Document doc) {\n            this.doc = doc;\n            namespacesStack.push(new HashMap<>());\n            dest = doc;\n            contextElement = (org.jsoup.nodes.Element) doc.getUserData(ContextProperty); // Track the context jsoup Element, so we can save the corresponding w3c element\n            if (contextElement != null) {\n                final org.jsoup.nodes.Document inDoc = contextElement.ownerDocument();\n                if ( namespaceAware && inDoc != null && inDoc.parser().getTreeBuilder() instanceof HtmlTreeBuilder ) {\n                    // as per the WHATWG HTML5 spec \u00a7 2.1.3, elements are in the HTML namespace by default\n                    namespacesStack.peek().put(\"\", Parser.NamespaceHtml);\n                }\n            }\n        }\n\n        public void head(org.jsoup.nodes.Node source, int depth) {\n            namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n            if (source instanceof org.jsoup.nodes.Element) {\n                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\n                String prefix = updateNamespaces(sourceEl);\n                String namespace = namespaceAware ? namespacesStack.peek().get(prefix) : null;\n                String tagName = sourceEl.tagName();\n\n                /* Tag names in XML are quite permissive, but less permissive than HTML. Rather than reimplement the validation,\n                we just try to use it as-is. If it fails, insert as a text node instead. We don't try to normalize the\n                tagname to something safe, because that isn't going to be meaningful downstream. This seems(?) to be\n                how browsers handle the situation, also. https://github.com/jhy/jsoup/issues/1093 */\n                try {\n                    // use an empty namespace if none is present but the tag name has a prefix\n                    String imputedNamespace = namespace == null && tagName.contains(\":\") ? \"\" : namespace;\n                    Element el = doc.createElementNS(imputedNamespace, tagName);\n                    copyAttributes(sourceEl, el);\n                    append(el, sourceEl);\n                    if (sourceEl == contextElement)\n                        doc.setUserData(ContextNodeProperty, el, null);\n                    dest = el; // descend\n                } catch (DOMException e) {\n                    append(doc.createTextNode(\"<\" + tagName + \">\"), sourceEl);\n                }\n            } else if (source instanceof org.jsoup.nodes.TextNode) {\n                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n                Text text = doc.createTextNode(sourceText.getWholeText());\n                append(text, sourceText);\n            } else if (source instanceof org.jsoup.nodes.Comment) {\n                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n                Comment comment = doc.createComment(sourceComment.getData());\n                append(comment, sourceComment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                append(node, sourceData);\n            } else {\n                // unhandled. note that doctype is not handled here - rather it is used in the initial doc creation\n            }\n        }\n\n        private void append(Node append, org.jsoup.nodes.Node source) {\n            append.setUserData(SourceProperty, source, null);\n            dest.appendChild(append);\n        }\n\n        public void tail(org.jsoup.nodes.Node source, int depth) {\n            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n                dest = dest.getParentNode(); // undescend\n            }\n            namespacesStack.pop();\n        }\n\n        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                String key = Attribute.getValidKey(attribute.getKey(), syntax);\n                if (key != null) { // null if couldn't be coerced to validity\n                    el.setAttribute(key, attribute.getValue());\n                }\n            }\n        }\n\n        /**\n         * Finds any namespaces defined in this element. Returns any tag prefix.\n         */\n        private String updateNamespaces(org.jsoup.nodes.Element el) {\n            // scan the element for namespace declarations\n            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n            Attributes attributes = el.attributes();\n            for (Attribute attr : attributes) {\n                String key = attr.getKey();\n                String prefix;\n                if (key.equals(xmlnsKey)) {\n                    prefix = \"\";\n                } else if (key.startsWith(xmlnsPrefix)) {\n                    prefix = key.substring(xmlnsPrefix.length());\n                } else {\n                    continue;\n                }\n                namespacesStack.peek().put(prefix, attr.getValue());\n            }\n\n            // get the element prefix if any\n            int pos = el.tagName().indexOf(':');\n            return pos > 0 ? el.tagName().substring(0, pos) : \"\";\n        }\n\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String SourceProperty = \"jsoupSource\";", "docstring": " For W3C Documents created by this class, this property is set on each node to link back to the original jsoup node.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "SourceProperty = \"jsoupSource\"", "syntax_pass": true}, {"attribute_expression": "private static final String ContextProperty = \"jsoupContextSource\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "ContextProperty = \"jsoupContextSource\"", "syntax_pass": true}, {"attribute_expression": "private static final String ContextNodeProperty = \"jsoupContextNode\";", "docstring": " tracks the jsoup context element on w3c doc", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "ContextNodeProperty = \"jsoupContextNode\"", "syntax_pass": true}, {"attribute_expression": "public static final String XPathFactoryProperty = \"javax.xml.xpath.XPathFactory:jsoup\";", "docstring": "\nTo get support for XPath versions &gt; 1, set this property to the classname of an alternate XPathFactory\nimplementation. (For e.g. {@code net.sf.saxon.xpath.XPathFactoryImpl}).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "XPathFactoryProperty = \"javax.xml.xpath.XPathFactory:jsoup\"", "syntax_pass": true}, {"attribute_expression": "protected DocumentBuilderFactory factory;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "DocumentBuilderFactory", "name": "factory", "syntax_pass": true}, {"attribute_expression": "private boolean namespaceAware = true;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "namespaceAware = true", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection", "name": "HttpConnection", "file_path": "src/main/java/org/jsoup/helper/HttpConnection.java", "superclasses": "", "methods": ["[Connection]connect(String)", "[Connection]connect(URL)", "[]HttpConnection()", "[]HttpConnection(Request)", "[String]encodeMimeName(String)", "[Connection]newRequest()", "[]HttpConnection(Request,Response)", "[Connection]url(URL)", "[Connection]url(String)", "[Connection]proxy(Proxy)", "[Connection]proxy(String,int)", "[Connection]userAgent(String)", "[Connection]timeout(int)", "[Connection]maxBodySize(int)", "[Connection]followRedirects(boolean)", "[Connection]referrer(String)", "[Connection]method(Method)", "[Connection]ignoreHttpErrors(boolean)", "[Connection]ignoreContentType(boolean)", "[Connection]data(String,String)", "[Connection]sslSocketFactory(SSLSocketFactory)", "[Connection]data(String,String,InputStream)", "[Connection]data(String,String,InputStream,String)", "[Connection]data(Map<String, String>)", "[Connection]data()", "[Connection]data(Collection<Connection.KeyVal>)", "[Connection.KeyVal]data(String)", "[Connection]requestBody(String)", "[Connection]header(String,String)", "[Connection]headers(Map<String,String>)", "[Connection]cookie(String,String)", "[Connection]cookies(Map<String, String>)", "[Connection]cookieStore(CookieStore)", "[CookieStore]cookieStore()", "[Connection]parser(Parser)", "[Document]get()", "[Document]post()", "[Connection.Response]execute()", "[Connection.Request]request()", "[Connection]request(Connection.Request)", "[Connection.Response]response()", "[Connection]response(Connection.Response)", "[Connection]postDataCharset(String)", "[Connection]auth(RequestAuthenticator)", "[Connection]onResponseProgress(Progress<Connection.Response>)", "[boolean]needsMultipart(Connection.Request)"], "method_uris": ["src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]connect(String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]connect(URL)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[]HttpConnection()", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[]HttpConnection(Request)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[String]encodeMimeName(String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]newRequest()", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[]HttpConnection(Request,Response)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]url(URL)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]url(String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]proxy(Proxy)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]proxy(String,int)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]userAgent(String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]timeout(int)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]maxBodySize(int)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]followRedirects(boolean)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]referrer(String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]method(Method)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]ignoreHttpErrors(boolean)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]ignoreContentType(boolean)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(String,String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]sslSocketFactory(SSLSocketFactory)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(String,String,InputStream)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(String,String,InputStream,String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(Map<String, String>)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data()", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]data(Collection<Connection.KeyVal>)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection.KeyVal]data(String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]requestBody(String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]header(String,String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]headers(Map<String,String>)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]cookie(String,String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]cookies(Map<String, String>)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]cookieStore(CookieStore)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[CookieStore]cookieStore()", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]parser(Parser)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Document]get()", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Document]post()", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection.Response]execute()", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection.Request]request()", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]request(Connection.Request)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection.Response]response()", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]response(Connection.Response)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]postDataCharset(String)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]auth(RequestAuthenticator)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[Connection]onResponseProgress(Progress<Connection.Response>)", "src/main/java/org/jsoup/helper/HttpConnection.java.HttpConnection.[boolean]needsMultipart(Connection.Request)"], "overrides": null, "attributes": [{"original_string": "    @SuppressWarnings(\"unchecked\")\n    private static abstract class Base<T extends Connection.Base<T>> implements Connection.Base<T> {\n        private static final URL UnsetUrl; // only used if you created a new Request()\n        static {\n            try {\n                UnsetUrl = new URL(\"http://undefined/\");\n            } catch (MalformedURLException e) {\n                throw new IllegalStateException(e);\n            }\n        }\n\n        URL url = UnsetUrl;\n        Method method = Method.GET;\n        Map<String, List<String>> headers;\n        Map<String, String> cookies;\n\n        private Base() {\n            headers = new LinkedHashMap<>();\n            cookies = new LinkedHashMap<>();\n        }\n\n        private Base(Base<T> copy) {\n            url = copy.url; // unmodifiable object\n            method = copy.method;\n            headers = new LinkedHashMap<>();\n            for (Map.Entry<String, List<String>> entry : copy.headers.entrySet()) {\n                headers.put(entry.getKey(), new ArrayList<>(entry.getValue()));\n            }\n            cookies = new LinkedHashMap<>(); cookies.putAll(copy.cookies); // just holds strings\n        }\n\n        @Override\n        public URL url() {\n            if (url == UnsetUrl)\n                throw new IllegalArgumentException(\"URL not set. Make sure to call #url(...) before executing the request.\");\n            return url;\n        }\n\n        @Override\n        public T url(URL url) {\n            Validate.notNullParam(url, \"url\");\n            this.url = new UrlBuilder(url).build();\n            return (T) this;\n        }\n\n        @Override\n        public Method method() {\n            return method;\n        }\n\n        @Override\n        public T method(Method method) {\n            Validate.notNullParam(method, \"method\");\n            this.method = method;\n            return (T) this;\n        }\n\n        @Override\n        public String header(String name) {\n            Validate.notNullParam(name, \"name\");\n            List<String> vals = getHeadersCaseInsensitive(name);\n            if (vals.size() > 0) {\n                // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                return StringUtil.join(vals, \", \");\n            }\n\n            return null;\n        }\n\n        @Override\n        public T addHeader(String name, @Nullable String value) {\n            Validate.notEmptyParam(name, \"name\");\n            value = value == null ? \"\" : value;\n\n            List<String> values = headers(name);\n            if (values.isEmpty()) {\n                values = new ArrayList<>();\n                headers.put(name, values);\n            }\n            values.add(value);\n\n            return (T) this;\n        }\n\n        @Override\n        public List<String> headers(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return getHeadersCaseInsensitive(name);\n        }\n\n        @Override\n        public T header(String name, String value) {\n            Validate.notEmptyParam(name, \"name\");\n            removeHeader(name); // ensures we don't get an \"accept-encoding\" and a \"Accept-Encoding\"\n            addHeader(name, value);\n            return (T) this;\n        }\n\n        @Override\n        public boolean hasHeader(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return !getHeadersCaseInsensitive(name).isEmpty();\n        }\n\n        /**\n         * Test if the request has a header with this value (case insensitive).\n         */\n        @Override\n        public boolean hasHeaderWithValue(String name, String value) {\n            Validate.notEmpty(name);\n            Validate.notEmpty(value);\n            List<String> values = headers(name);\n            for (String candidate : values) {\n                if (value.equalsIgnoreCase(candidate))\n                    return true;\n            }\n            return false;\n        }\n\n        @Override\n        public T removeHeader(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            Map.Entry<String, List<String>> entry = scanHeaders(name); // remove is case-insensitive too\n            if (entry != null)\n                headers.remove(entry.getKey()); // ensures correct case\n            return (T) this;\n        }\n\n        @Override\n        public Map<String, String> headers() {\n            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                String header = entry.getKey();\n                List<String> values = entry.getValue();\n                if (values.size() > 0)\n                    map.put(header, values.get(0));\n            }\n            return map;\n        }\n\n        @Override\n        public Map<String, List<String>> multiHeaders() {\n            return headers;\n        }\n\n        private List<String> getHeadersCaseInsensitive(String name) {\n            Validate.notNull(name);\n\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (name.equalsIgnoreCase(entry.getKey()))\n                    return entry.getValue();\n            }\n\n            return Collections.emptyList();\n        }\n\n        private Map.@Nullable Entry<String, List<String>> scanHeaders(String name) {\n            String lc = lowerCase(name);\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (lowerCase(entry.getKey()).equals(lc))\n                    return entry;\n            }\n            return null;\n        }\n\n        @Override\n        public String cookie(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return cookies.get(name);\n        }\n\n        @Override\n        public T cookie(String name, String value) {\n            Validate.notEmptyParam(name, \"name\");\n            Validate.notNullParam(value, \"value\");\n            cookies.put(name, value);\n            return (T) this;\n        }\n\n        @Override\n        public boolean hasCookie(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return cookies.containsKey(name);\n        }\n\n        @Override\n        public T removeCookie(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            cookies.remove(name);\n            return (T) this;\n        }\n\n        @Override\n        public Map<String, String> cookies() {\n            return cookies;\n        }\n    }", "definition": "    @SuppressWarnings(\"unchecked\")\n    private static abstract class Base<T extends Connection.Base<T>> implements Connection.Base<T>", "class_docstring": "", "name": "Base", "super_interfaces": ["Connection.Base<T>"], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    private static abstract", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "private", "static", "abstract"], "comments": [], "fields": [{"attribute_expression": "private static final URL UnsetUrl;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "URL", "name": "UnsetUrl", "syntax_pass": true}, {"attribute_expression": "URL url = UnsetUrl;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "URL", "name": "url = UnsetUrl", "syntax_pass": true}, {"attribute_expression": "Method method = Method.GET;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Method", "name": "method = Method.GET", "syntax_pass": true}, {"attribute_expression": "Map<String, List<String>> headers;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Map<String, List<String>>", "name": "headers", "syntax_pass": true}, {"attribute_expression": "Map<String, String> cookies;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Map<String, String>", "name": "cookies", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Base() {\n            headers = new LinkedHashMap<>();\n            cookies = new LinkedHashMap<>();\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Base", "params": [], "body": "                       {\n            headers = new LinkedHashMap<>();\n            cookies = new LinkedHashMap<>();\n        }", "signature": "private Base()"}, {"syntax_pass": true, "original_string": "        private Base(Base<T> copy) {\n            url = copy.url; // unmodifiable object\n            method = copy.method;\n            headers = new LinkedHashMap<>();\n            for (Map.Entry<String, List<String>> entry : copy.headers.entrySet()) {\n                headers.put(entry.getKey(), new ArrayList<>(entry.getValue()));\n            }\n            cookies = new LinkedHashMap<>(); cookies.putAll(copy.cookies); // just holds strings\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Base", "params": [{"name": "copy", "type": "Base<T>"}], "body": "                                   {\n            url = copy.url; // unmodifiable object\n            method = copy.method;\n            headers = new LinkedHashMap<>();\n            for (Map.Entry<String, List<String>> entry : copy.headers.entrySet()) {\n                headers.put(entry.getKey(), new ArrayList<>(entry.getValue()));\n            }\n            cookies = new LinkedHashMap<>(); cookies.putAll(copy.cookies); // just holds strings\n        }", "signature": "private Base(Base<T> copy)"}, {"syntax_pass": true, "original_string": "        @Override\n        public URL url() {\n            if (url == UnsetUrl)\n                throw new IllegalArgumentException(\"URL not set. Make sure to call #url(...) before executing the request.\");\n            return url;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "URL", "classes": []}, "name": "url", "params": [], "body": "                         {\n            if (url == UnsetUrl)\n                throw new IllegalArgumentException(\"URL not set. Make sure to call #url(...) before executing the request.\");\n            return url;\n        }", "signature": "@Override\n        public URL url()"}, {"syntax_pass": true, "original_string": "        @Override\n        public T url(URL url) {\n            Validate.notNullParam(url, \"url\");\n            this.url = new UrlBuilder(url).build();\n            return (T) this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "url", "params": [{"name": "url", "type": "URL"}], "body": "                              {\n            Validate.notNullParam(url, \"url\");\n            this.url = new UrlBuilder(url).build();\n            return (T) this;\n        }", "signature": "@Override\n        public T url(URL url)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Method method() {\n            return method;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Method", "classes": []}, "name": "method", "params": [], "body": "                               {\n            return method;\n        }", "signature": "@Override\n        public Method method()"}, {"syntax_pass": true, "original_string": "        @Override\n        public T method(Method method) {\n            Validate.notNullParam(method, \"method\");\n            this.method = method;\n            return (T) this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "method", "params": [{"name": "method", "type": "Method"}], "body": "                                       {\n            Validate.notNullParam(method, \"method\");\n            this.method = method;\n            return (T) this;\n        }", "signature": "@Override\n        public T method(Method method)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String header(String name) {\n            Validate.notNullParam(name, \"name\");\n            List<String> vals = getHeadersCaseInsensitive(name);\n            if (vals.size() > 0) {\n                // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                return StringUtil.join(vals, \", \");\n            }\n\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "header", "params": [{"name": "name", "type": "String"}], "body": "                                          {\n            Validate.notNullParam(name, \"name\");\n            List<String> vals = getHeadersCaseInsensitive(name);\n            if (vals.size() > 0) {\n                // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                return StringUtil.join(vals, \", \");\n            }\n\n            return null;\n        }", "signature": "@Override\n        public String header(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T addHeader(String name, @Nullable String value) {\n            Validate.notEmptyParam(name, \"name\");\n            value = value == null ? \"\" : value;\n\n            List<String> values = headers(name);\n            if (values.isEmpty()) {\n                values = new ArrayList<>();\n                headers.put(name, values);\n            }\n            values.add(value);\n\n            return (T) this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "addHeader", "params": [{"name": "name", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                                {\n            Validate.notEmptyParam(name, \"name\");\n            value = value == null ? \"\" : value;\n\n            List<String> values = headers(name);\n            if (values.isEmpty()) {\n                values = new ArrayList<>();\n                headers.put(name, values);\n            }\n            values.add(value);\n\n            return (T) this;\n        }", "signature": "@Override\n        public T addHeader(String name, @Nullable String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<String> headers(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return getHeadersCaseInsensitive(name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "headers", "params": [{"name": "name", "type": "String"}], "body": "                                                 {\n            Validate.notEmptyParam(name, \"name\");\n            return getHeadersCaseInsensitive(name);\n        }", "signature": "@Override\n        public List<String> headers(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T header(String name, String value) {\n            Validate.notEmptyParam(name, \"name\");\n            removeHeader(name); // ensures we don't get an \"accept-encoding\" and a \"Accept-Encoding\"\n            addHeader(name, value);\n            return (T) this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "header", "params": [{"name": "name", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                   {\n            Validate.notEmptyParam(name, \"name\");\n            removeHeader(name); // ensures we don't get an \"accept-encoding\" and a \"Accept-Encoding\"\n            addHeader(name, value);\n            return (T) this;\n        }", "signature": "@Override\n        public T header(String name, String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasHeader(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return !getHeadersCaseInsensitive(name).isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasHeader", "params": [{"name": "name", "type": "String"}], "body": "                                              {\n            Validate.notEmptyParam(name, \"name\");\n            return !getHeadersCaseInsensitive(name).isEmpty();\n        }", "signature": "@Override\n        public boolean hasHeader(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasHeaderWithValue(String name, String value) {\n            Validate.notEmpty(name);\n            Validate.notEmpty(value);\n            List<String> values = headers(name);\n            for (String candidate : values) {\n                if (value.equalsIgnoreCase(candidate))\n                    return true;\n            }\n            return false;\n        }", "docstring": "\nTest if the request has a header with this value (case insensitive).\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasHeaderWithValue", "params": [{"name": "name", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                                     {\n            Validate.notEmpty(name);\n            Validate.notEmpty(value);\n            List<String> values = headers(name);\n            for (String candidate : values) {\n                if (value.equalsIgnoreCase(candidate))\n                    return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean hasHeaderWithValue(String name, String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T removeHeader(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            Map.Entry<String, List<String>> entry = scanHeaders(name); // remove is case-insensitive too\n            if (entry != null)\n                headers.remove(entry.getKey()); // ensures correct case\n            return (T) this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "removeHeader", "params": [{"name": "name", "type": "String"}], "body": "                                           {\n            Validate.notEmptyParam(name, \"name\");\n            Map.Entry<String, List<String>> entry = scanHeaders(name); // remove is case-insensitive too\n            if (entry != null)\n                headers.remove(entry.getKey()); // ensures correct case\n            return (T) this;\n        }", "signature": "@Override\n        public T removeHeader(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<String, String> headers() {\n            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                String header = entry.getKey();\n                List<String> values = entry.getValue();\n                if (values.size() > 0)\n                    map.put(header, values.get(0));\n            }\n            return map;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, String>", "classes": []}, "name": "headers", "params": [], "body": "                                             {\n            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                String header = entry.getKey();\n                List<String> values = entry.getValue();\n                if (values.size() > 0)\n                    map.put(header, values.get(0));\n            }\n            return map;\n        }", "signature": "@Override\n        public Map<String, String> headers()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<String, List<String>> multiHeaders() {\n            return headers;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, List<String>>", "classes": []}, "name": "multiHeaders", "params": [], "body": "                                                        {\n            return headers;\n        }", "signature": "@Override\n        public Map<String, List<String>> multiHeaders()"}, {"syntax_pass": true, "original_string": "        private List<String> getHeadersCaseInsensitive(String name) {\n            Validate.notNull(name);\n\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (name.equalsIgnoreCase(entry.getKey()))\n                    return entry.getValue();\n            }\n\n            return Collections.emptyList();\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getHeadersCaseInsensitive", "params": [{"name": "name", "type": "String"}], "body": "                                                                    {\n            Validate.notNull(name);\n\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (name.equalsIgnoreCase(entry.getKey()))\n                    return entry.getValue();\n            }\n\n            return Collections.emptyList();\n        }", "signature": "private List<String> getHeadersCaseInsensitive(String name)"}, {"syntax_pass": true, "original_string": "        private Map.@Nullable Entry<String, List<String>> scanHeaders(String name) {\n            String lc = lowerCase(name);\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (lowerCase(entry.getKey()).equals(lc))\n                    return entry;\n            }\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Map.@Nullable Entry<String, List<String>>", "classes": []}, "name": "scanHeaders", "params": [{"name": "name", "type": "String"}], "body": "                                                                                   {\n            String lc = lowerCase(name);\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (lowerCase(entry.getKey()).equals(lc))\n                    return entry;\n            }\n            return null;\n        }", "signature": "private Map.@Nullable Entry<String, List<String>> scanHeaders(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String cookie(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return cookies.get(name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "cookie", "params": [{"name": "name", "type": "String"}], "body": "                                          {\n            Validate.notEmptyParam(name, \"name\");\n            return cookies.get(name);\n        }", "signature": "@Override\n        public String cookie(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T cookie(String name, String value) {\n            Validate.notEmptyParam(name, \"name\");\n            Validate.notNullParam(value, \"value\");\n            cookies.put(name, value);\n            return (T) this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "cookie", "params": [{"name": "name", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                   {\n            Validate.notEmptyParam(name, \"name\");\n            Validate.notNullParam(value, \"value\");\n            cookies.put(name, value);\n            return (T) this;\n        }", "signature": "@Override\n        public T cookie(String name, String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasCookie(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return cookies.containsKey(name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasCookie", "params": [{"name": "name", "type": "String"}], "body": "                                              {\n            Validate.notEmptyParam(name, \"name\");\n            return cookies.containsKey(name);\n        }", "signature": "@Override\n        public boolean hasCookie(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T removeCookie(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            cookies.remove(name);\n            return (T) this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "removeCookie", "params": [{"name": "name", "type": "String"}], "body": "                                           {\n            Validate.notEmptyParam(name, \"name\");\n            cookies.remove(name);\n            return (T) this;\n        }", "signature": "@Override\n        public T removeCookie(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<String, String> cookies() {\n            return cookies;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, String>", "classes": []}, "name": "cookies", "params": [], "body": "                                             {\n            return cookies;\n        }", "signature": "@Override\n        public Map<String, String> cookies()"}]}, {"original_string": "    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n        static {\n            System.setProperty(\"sun.net.http.allowRestrictedHeaders\", \"true\");\n            // make sure that we can send Sec-Fetch-Site headers etc.\n        }\n\n        private @Nullable Proxy proxy;\n        private int timeoutMilliseconds;\n        private int maxBodySizeBytes;\n        private boolean followRedirects;\n        private final Collection<Connection.KeyVal> data;\n        private @Nullable String body = null;\n        private boolean ignoreHttpErrors = false;\n        private boolean ignoreContentType = false;\n        private Parser parser;\n        private boolean parserDefined = false; // called parser(...) vs initialized in ctor\n        private String postDataCharset = DataUtil.defaultCharsetName;\n        private @Nullable SSLSocketFactory sslSocketFactory;\n        private CookieManager cookieManager;\n        private @Nullable RequestAuthenticator authenticator;\n        private @Nullable Progress<Connection.Response> responseProgress;\n\n        private volatile boolean executing = false;\n\n        Request() {\n            super();\n            timeoutMilliseconds = 30000; // 30 seconds\n            maxBodySizeBytes = 1024 * 1024 * 2; // 2MB\n            followRedirects = true;\n            data = new ArrayList<>();\n            method = Method.GET;\n            addHeader(\"Accept-Encoding\", \"gzip\");\n            addHeader(USER_AGENT, DEFAULT_UA);\n            parser = Parser.htmlParser();\n            cookieManager = new CookieManager(); // creates a default InMemoryCookieStore\n        }\n\n        Request(Request copy) {\n            super(copy);\n            proxy = copy.proxy;\n            postDataCharset = copy.postDataCharset;\n            timeoutMilliseconds = copy.timeoutMilliseconds;\n            maxBodySizeBytes = copy.maxBodySizeBytes;\n            followRedirects = copy.followRedirects;\n            data = new ArrayList<>(); // data not copied\n            //body not copied\n            ignoreHttpErrors = copy.ignoreHttpErrors;\n            ignoreContentType = copy.ignoreContentType;\n            parser = copy.parser.newInstance(); // parsers and their tree-builders maintain state, so need a fresh copy\n            parserDefined = copy.parserDefined;\n            sslSocketFactory = copy.sslSocketFactory; // these are all synchronized so safe to share\n            cookieManager = copy.cookieManager;\n            authenticator = copy.authenticator;\n            responseProgress = copy.responseProgress;\n            executing = false;\n        }\n\n        @Override\n        public Proxy proxy() {\n            return proxy;\n        }\n\n        @Override\n        public Request proxy(@Nullable Proxy proxy) {\n            this.proxy = proxy;\n            return this;\n        }\n\n        @Override\n        public Request proxy(String host, int port) {\n            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n            return this;\n        }\n\n        @Override\n        public int timeout() {\n            return timeoutMilliseconds;\n        }\n\n        @Override\n        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }\n\n        @Override\n        public int maxBodySize() {\n            return maxBodySizeBytes;\n        }\n\n        @Override\n        public Connection.Request maxBodySize(int bytes) {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }\n\n        @Override\n        public boolean followRedirects() {\n            return followRedirects;\n        }\n\n        @Override\n        public Connection.Request followRedirects(boolean followRedirects) {\n            this.followRedirects = followRedirects;\n            return this;\n        }\n\n        @Override\n        public boolean ignoreHttpErrors() {\n            return ignoreHttpErrors;\n        }\n\n        @Override\n        public SSLSocketFactory sslSocketFactory() {\n            return sslSocketFactory;\n        }\n\n        @Override\n        public void sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n            this.sslSocketFactory = sslSocketFactory;\n        }\n\n        @Override\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }\n\n        @Override\n        public boolean ignoreContentType() {\n            return ignoreContentType;\n        }\n\n        @Override\n        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }\n\n        @Override\n        public Request data(Connection.KeyVal keyval) {\n            Validate.notNullParam(keyval, \"keyval\");\n            data.add(keyval);\n            return this;\n        }\n\n        @Override\n        public Collection<Connection.KeyVal> data() {\n            return data;\n        }\n\n        @Override\n        public Connection.Request requestBody(@Nullable String body) {\n            this.body = body;\n            return this;\n        }\n\n        @Override\n        public String requestBody() {\n            return body;\n        }\n\n        @Override\n        public Request parser(Parser parser) {\n            this.parser = parser;\n            parserDefined = true;\n            return this;\n        }\n\n        @Override\n        public Parser parser() {\n            return parser;\n        }\n\n        @Override\n        public Connection.Request postDataCharset(String charset) {\n            Validate.notNullParam(charset, \"charset\");\n            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n            this.postDataCharset = charset;\n            return this;\n        }\n\n        @Override\n        public String postDataCharset() {\n            return postDataCharset;\n        }\n\n        CookieManager cookieManager() {\n            return cookieManager;\n        }\n\n        @Override public Connection.Request auth(@Nullable RequestAuthenticator authenticator) {\n            this.authenticator = authenticator;\n            return this;\n        }\n\n        @Override @Nullable public RequestAuthenticator auth() {\n            return authenticator;\n        }\n    }", "definition": "    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request", "class_docstring": "", "name": "Request", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private @Nullable Proxy proxy;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Proxy", "name": "proxy", "syntax_pass": true}, {"attribute_expression": "private int timeoutMilliseconds;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "timeoutMilliseconds", "syntax_pass": true}, {"attribute_expression": "private int maxBodySizeBytes;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "maxBodySizeBytes", "syntax_pass": true}, {"attribute_expression": "private boolean followRedirects;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "followRedirects", "syntax_pass": true}, {"attribute_expression": "private final Collection<Connection.KeyVal> data;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<Connection.KeyVal>", "name": "data", "syntax_pass": true}, {"attribute_expression": "private @Nullable String body = null;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "body = null", "syntax_pass": true}, {"attribute_expression": "private boolean ignoreHttpErrors = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "ignoreHttpErrors = false", "syntax_pass": true}, {"attribute_expression": "private boolean ignoreContentType = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "ignoreContentType = false", "syntax_pass": true}, {"attribute_expression": "private Parser parser;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Parser", "name": "parser", "syntax_pass": true}, {"attribute_expression": "private boolean parserDefined = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "parserDefined = false", "syntax_pass": true}, {"attribute_expression": "private String postDataCharset = DataUtil.defaultCharsetName;", "docstring": " called parser(...) vs initialized in ctor", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "postDataCharset = DataUtil.defaultCharsetName", "syntax_pass": true}, {"attribute_expression": "private @Nullable SSLSocketFactory sslSocketFactory;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "SSLSocketFactory", "name": "sslSocketFactory", "syntax_pass": true}, {"attribute_expression": "private CookieManager cookieManager;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CookieManager", "name": "cookieManager", "syntax_pass": true}, {"attribute_expression": "private @Nullable RequestAuthenticator authenticator;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "RequestAuthenticator", "name": "authenticator", "syntax_pass": true}, {"attribute_expression": "private @Nullable Progress<Connection.Response> responseProgress;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Progress<Connection.Response>", "name": "responseProgress", "syntax_pass": true}, {"attribute_expression": "private volatile boolean executing = false;", "docstring": "", "modifiers": "private volatile", "marker_annotations": [], "non_marker_annotations": ["private", "volatile"], "comments": [], "type": "boolean", "name": "executing = false", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Request() {\n            super();\n            timeoutMilliseconds = 30000; // 30 seconds\n            maxBodySizeBytes = 1024 * 1024 * 2; // 2MB\n            followRedirects = true;\n            data = new ArrayList<>();\n            method = Method.GET;\n            addHeader(\"Accept-Encoding\", \"gzip\");\n            addHeader(USER_AGENT, DEFAULT_UA);\n            parser = Parser.htmlParser();\n            cookieManager = new CookieManager(); // creates a default InMemoryCookieStore\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Request", "params": [], "body": "                  {\n            super();\n            timeoutMilliseconds = 30000; // 30 seconds\n            maxBodySizeBytes = 1024 * 1024 * 2; // 2MB\n            followRedirects = true;\n            data = new ArrayList<>();\n            method = Method.GET;\n            addHeader(\"Accept-Encoding\", \"gzip\");\n            addHeader(USER_AGENT, DEFAULT_UA);\n            parser = Parser.htmlParser();\n            cookieManager = new CookieManager(); // creates a default InMemoryCookieStore\n        }", "signature": "Request()"}, {"syntax_pass": true, "original_string": "        Request(Request copy) {\n            super(copy);\n            proxy = copy.proxy;\n            postDataCharset = copy.postDataCharset;\n            timeoutMilliseconds = copy.timeoutMilliseconds;\n            maxBodySizeBytes = copy.maxBodySizeBytes;\n            followRedirects = copy.followRedirects;\n            data = new ArrayList<>(); // data not copied\n            //body not copied\n            ignoreHttpErrors = copy.ignoreHttpErrors;\n            ignoreContentType = copy.ignoreContentType;\n            parser = copy.parser.newInstance(); // parsers and their tree-builders maintain state, so need a fresh copy\n            parserDefined = copy.parserDefined;\n            sslSocketFactory = copy.sslSocketFactory; // these are all synchronized so safe to share\n            cookieManager = copy.cookieManager;\n            authenticator = copy.authenticator;\n            responseProgress = copy.responseProgress;\n            executing = false;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Request", "params": [{"name": "copy", "type": "Request"}], "body": "                              {\n            super(copy);\n            proxy = copy.proxy;\n            postDataCharset = copy.postDataCharset;\n            timeoutMilliseconds = copy.timeoutMilliseconds;\n            maxBodySizeBytes = copy.maxBodySizeBytes;\n            followRedirects = copy.followRedirects;\n            data = new ArrayList<>(); // data not copied\n            //body not copied\n            ignoreHttpErrors = copy.ignoreHttpErrors;\n            ignoreContentType = copy.ignoreContentType;\n            parser = copy.parser.newInstance(); // parsers and their tree-builders maintain state, so need a fresh copy\n            parserDefined = copy.parserDefined;\n            sslSocketFactory = copy.sslSocketFactory; // these are all synchronized so safe to share\n            cookieManager = copy.cookieManager;\n            authenticator = copy.authenticator;\n            responseProgress = copy.responseProgress;\n            executing = false;\n        }", "signature": "Request(Request copy)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Proxy proxy() {\n            return proxy;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Proxy", "classes": []}, "name": "proxy", "params": [], "body": "                             {\n            return proxy;\n        }", "signature": "@Override\n        public Proxy proxy()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Request proxy(@Nullable Proxy proxy) {\n            this.proxy = proxy;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Request", "classes": []}, "name": "proxy", "params": [{"name": "proxy", "type": "Proxy"}], "body": "                                                    {\n            this.proxy = proxy;\n            return this;\n        }", "signature": "@Override\n        public Request proxy(@Nullable Proxy proxy)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Request proxy(String host, int port) {\n            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Request", "classes": []}, "name": "proxy", "params": [{"name": "host", "type": "String"}, {"name": "port", "type": "int"}], "body": "                                                    {\n            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n            return this;\n        }", "signature": "@Override\n        public Request proxy(String host, int port)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int timeout() {\n            return timeoutMilliseconds;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "timeout", "params": [], "body": "                             {\n            return timeoutMilliseconds;\n        }", "signature": "@Override\n        public int timeout()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Request", "classes": []}, "name": "timeout", "params": [{"name": "millis", "type": "int"}], "body": "                                           {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }", "signature": "@Override\n        public Request timeout(int millis)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int maxBodySize() {\n            return maxBodySizeBytes;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "maxBodySize", "params": [], "body": "                                 {\n            return maxBodySizeBytes;\n        }", "signature": "@Override\n        public int maxBodySize()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection.Request maxBodySize(int bytes) {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection.Request", "classes": []}, "name": "maxBodySize", "params": [{"name": "bytes", "type": "int"}], "body": "                                                         {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }", "signature": "@Override\n        public Connection.Request maxBodySize(int bytes)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean followRedirects() {\n            return followRedirects;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "followRedirects", "params": [], "body": "                                         {\n            return followRedirects;\n        }", "signature": "@Override\n        public boolean followRedirects()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection.Request followRedirects(boolean followRedirects) {\n            this.followRedirects = followRedirects;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection.Request", "classes": []}, "name": "followRedirects", "params": [{"name": "followRedirects", "type": "boolean"}], "body": "                                                                           {\n            this.followRedirects = followRedirects;\n            return this;\n        }", "signature": "@Override\n        public Connection.Request followRedirects(boolean followRedirects)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean ignoreHttpErrors() {\n            return ignoreHttpErrors;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "ignoreHttpErrors", "params": [], "body": "                                          {\n            return ignoreHttpErrors;\n        }", "signature": "@Override\n        public boolean ignoreHttpErrors()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SSLSocketFactory sslSocketFactory() {\n            return sslSocketFactory;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SSLSocketFactory", "classes": []}, "name": "sslSocketFactory", "params": [], "body": "                                                   {\n            return sslSocketFactory;\n        }", "signature": "@Override\n        public SSLSocketFactory sslSocketFactory()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n            this.sslSocketFactory = sslSocketFactory;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "sslSocketFactory", "params": [{"name": "sslSocketFactory", "type": "SSLSocketFactory"}], "body": "                                                                        {\n            this.sslSocketFactory = sslSocketFactory;\n        }", "signature": "@Override\n        public void sslSocketFactory(SSLSocketFactory sslSocketFactory)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection.Request", "classes": []}, "name": "ignoreHttpErrors", "params": [{"name": "ignoreHttpErrors", "type": "boolean"}], "body": "                                                                             {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }", "signature": "@Override\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean ignoreContentType() {\n            return ignoreContentType;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "ignoreContentType", "params": [], "body": "                                           {\n            return ignoreContentType;\n        }", "signature": "@Override\n        public boolean ignoreContentType()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection.Request", "classes": []}, "name": "ignoreContentType", "params": [{"name": "ignoreContentType", "type": "boolean"}], "body": "                                                                               {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }", "signature": "@Override\n        public Connection.Request ignoreContentType(boolean ignoreContentType)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Request data(Connection.KeyVal keyval) {\n            Validate.notNullParam(keyval, \"keyval\");\n            data.add(keyval);\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Request", "classes": []}, "name": "data", "params": [{"name": "keyval", "type": "Connection.KeyVal"}], "body": "                                                      {\n            Validate.notNullParam(keyval, \"keyval\");\n            data.add(keyval);\n            return this;\n        }", "signature": "@Override\n        public Request data(Connection.KeyVal keyval)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<Connection.KeyVal> data() {\n            return data;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<Connection.KeyVal>", "classes": []}, "name": "data", "params": [], "body": "                                                    {\n            return data;\n        }", "signature": "@Override\n        public Collection<Connection.KeyVal> data()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection.Request requestBody(@Nullable String body) {\n            this.body = body;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection.Request", "classes": []}, "name": "requestBody", "params": [{"name": "body", "type": "String"}], "body": "                                                                     {\n            this.body = body;\n            return this;\n        }", "signature": "@Override\n        public Connection.Request requestBody(@Nullable String body)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String requestBody() {\n            return body;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "requestBody", "params": [], "body": "                                    {\n            return body;\n        }", "signature": "@Override\n        public String requestBody()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Request parser(Parser parser) {\n            this.parser = parser;\n            parserDefined = true;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Request", "classes": []}, "name": "parser", "params": [{"name": "parser", "type": "Parser"}], "body": "                                             {\n            this.parser = parser;\n            parserDefined = true;\n            return this;\n        }", "signature": "@Override\n        public Request parser(Parser parser)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Parser parser() {\n            return parser;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Parser", "classes": []}, "name": "parser", "params": [], "body": "                               {\n            return parser;\n        }", "signature": "@Override\n        public Parser parser()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection.Request postDataCharset(String charset) {\n            Validate.notNullParam(charset, \"charset\");\n            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n            this.postDataCharset = charset;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection.Request", "classes": []}, "name": "postDataCharset", "params": [{"name": "charset", "type": "String"}], "body": "                                                                  {\n            Validate.notNullParam(charset, \"charset\");\n            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n            this.postDataCharset = charset;\n            return this;\n        }", "signature": "@Override\n        public Connection.Request postDataCharset(String charset)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String postDataCharset() {\n            return postDataCharset;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "postDataCharset", "params": [], "body": "                                        {\n            return postDataCharset;\n        }", "signature": "@Override\n        public String postDataCharset()"}, {"syntax_pass": true, "original_string": "        CookieManager cookieManager() {\n            return cookieManager;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "CookieManager", "classes": []}, "name": "cookieManager", "params": [], "body": "                                      {\n            return cookieManager;\n        }", "signature": "CookieManager cookieManager()"}, {"syntax_pass": true, "original_string": "        @Override public Connection.Request auth(@Nullable RequestAuthenticator authenticator) {\n            this.authenticator = authenticator;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection.Request", "classes": []}, "name": "auth", "params": [{"name": "authenticator", "type": "RequestAuthenticator"}], "body": "                                                                                               {\n            this.authenticator = authenticator;\n            return this;\n        }", "signature": "@Override public Connection.Request auth(@Nullable RequestAuthenticator authenticator)"}, {"syntax_pass": true, "original_string": "        @Override @Nullable public RequestAuthenticator auth() {\n            return authenticator;\n        }", "docstring": "", "attributes": {"modifiers": "@Override @Nullable public", "marker_annotations": ["@Override", "@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RequestAuthenticator", "classes": []}, "name": "auth", "params": [], "body": "                                                               {\n            return authenticator;\n        }", "signature": "@Override @Nullable public RequestAuthenticator auth()"}]}, {"original_string": "    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n        private static final int MAX_REDIRECTS = 20;\n        private static final String LOCATION = \"Location\";\n        private final int statusCode;\n        private final String statusMessage;\n        private @Nullable ByteBuffer byteData;\n        private @Nullable ControllableInputStream bodyStream;\n        private @Nullable HttpURLConnection conn;\n        private @Nullable String charset;\n        private @Nullable final String contentType;\n        private boolean executed = false;\n        private boolean inputStreamRead = false;\n        private int numRedirects = 0;\n        private final HttpConnection.Request req;\n\n        /*\n         * Matches XML content types (like text/xml, image/svg+xml, application/xhtml+xml;charset=UTF8, etc)\n         */\n        private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(\\\\w+)/\\\\w*\\\\+?xml.*\");\n\n        /**\n         <b>Internal only! </b>Creates a dummy HttpConnection.Response, useful for testing. All actual responses\n         are created from the HttpURLConnection and fields defined.\n         */\n        Response() {\n            super();\n            statusCode = 400;\n            statusMessage = \"Request not made\";\n            req = new Request();\n            contentType = null;\n        }\n\n        static Response execute(HttpConnection.Request req) throws IOException {\n            return execute(req, null);\n        }\n\n        static Response execute(HttpConnection.Request req, @Nullable Response previousResponse) throws IOException {\n            synchronized (req) {\n                Validate.isFalse(req.executing, \"Multiple threads were detected trying to execute the same request concurrently. Make sure to use Connection#newRequest() and do not share an executing request between threads.\");\n                req.executing = true;\n            }\n            Validate.notNullParam(req, \"req\");\n            URL url = req.url();\n            Validate.notNull(url, \"URL must be specified to connect\");\n            String protocol = url.getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res = null;\n            try {\n                conn.connect();\n                if (conn.getDoOutput()) {\n                    OutputStream out = conn.getOutputStream();\n                    try { writePost(req, out, mimeBoundary); }\n                    catch (IOException e) { conn.disconnect(); throw e; }\n                    finally { out.close(); }\n                }\n\n                int status = conn.getResponseCode();\n                res = new Response(conn, req, previousResponse);\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    Validate.notNull(location);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(redir);\n\n                    req.executing = false;\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, */xml, or */*+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    if (!req.parserDefined) req.parser(Parser.xmlParser());\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    InputStream stream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n                        stream = new GZIPInputStream(stream);\n                    else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\"))\n                        stream = new InflaterInputStream(stream, new Inflater(true));\n                    \n                    res.bodyStream = ControllableInputStream.wrap(\n                        stream, DefaultBufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout());\n\n                    if (req.responseProgress != null) // set response progress listener\n                        res.bodyStream.onProgress(conn.getContentLength(), req.responseProgress, res);\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e) {\n                if (res != null) res.safeClose(); // will be non-null if got to conn\n                throw e;\n            } finally {\n                req.executing = false;\n\n                // detach any thread local auth delegate\n                if (req.authenticator != null)\n                    AuthenticationHandler.handler.remove();\n            }\n\n            res.executed = true;\n            return res;\n        }\n\n        @Override\n        public int statusCode() {\n            return statusCode;\n        }\n\n        @Override\n        public String statusMessage() {\n            return statusMessage;\n        }\n\n        @Override\n        public String charset() {\n            return charset;\n        }\n\n        @Override\n        public Response charset(String charset) {\n            this.charset = charset;\n            return this;\n        }\n\n        @Override\n        public String contentType() {\n            return contentType;\n        }\n\n        /** Called from parse() or streamParser(), validates and prepares the input stream, and aligns common settings. */\n        private ControllableInputStream prepareParse() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            ControllableInputStream stream = bodyStream;\n            if (byteData != null) { // bytes have been read in to the buffer, parse that\n                ByteArrayInputStream bytes = new ByteArrayInputStream(byteData.array(), 0, byteData.limit());\n                stream = ControllableInputStream.wrap(bytes, 0); // no max\n                inputStreamRead = false; // ok to reparse if in bytes\n            }\n            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n            Validate.notNull(stream);\n            inputStreamRead = true;\n            return stream;\n        }\n\n        @Override public Document parse() throws IOException {\n            ControllableInputStream stream = prepareParse();\n            Document doc = DataUtil.parseInputStream(stream, charset, url.toExternalForm(), req.parser());\n            doc.connection(new HttpConnection(req, this)); // because we're static, don't have the connection obj. // todo - maybe hold in the req?\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            safeClose();\n            return doc;\n        }\n\n        @Override public StreamParser streamParser() throws IOException {\n            ControllableInputStream stream = prepareParse();\n            String baseUri = url.toExternalForm();\n            DataUtil.CharsetDoc charsetDoc = DataUtil.detectCharset(stream, charset, baseUri, req.parser());\n            // note that there may be a document in CharsetDoc as a result of scanning meta-data -- but as requires a stream parse, it is not used here. todo - revisit.\n\n            // set up the stream parser and rig this connection up to the parsed doc:\n            StreamParser streamer = new StreamParser(req.parser());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(stream, charsetDoc.charset));\n            streamer.parse(reader, baseUri); // initializes the parse and the document, but does not step() it\n            streamer.document().connection(new HttpConnection(req, this));\n            charset = charsetDoc.charset.name();\n\n            // we don't safeClose() as in parse(); caller must close streamParser to close InputStream stream\n            return streamer;\n        }\n\n        private void prepareByteData() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            if (bodyStream != null && byteData == null) {\n                Validate.isFalse(inputStreamRead, \"Request has already been read (with .parse())\");\n                try {\n                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                } finally {\n                    inputStreamRead = true;\n                    safeClose();\n                }\n            }\n        }\n\n        @Override\n        public String body() {\n            prepareByteData();\n            Validate.notNull(byteData);\n            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n            String body = (charset == null ? UTF_8 : Charset.forName(charset))\n                .decode(byteData).toString();\n            ((Buffer)byteData).rewind(); // cast to avoid covariant return type change in jdk9\n            return body;\n        }\n\n        @Override\n        public byte[] bodyAsBytes() {\n            prepareByteData();\n            Validate.notNull(byteData);\n            Validate.isTrue(byteData.hasArray()); // we made it, so it should\n\n            byte[] array = byteData.array();\n            int offset = byteData.arrayOffset();\n            int length = byteData.limit();\n\n            if (offset == 0 && length == array.length) { // exact, just return it\n                return array;\n            } else { // trim to size\n                byte[] exactArray = new byte[length];\n                System.arraycopy(array, offset, exactArray, 0, length);\n                return exactArray;\n            }\n        }\n\n        @Override\n        public Connection.Response bufferUp() {\n            prepareByteData();\n            return this;\n        }\n\n        @Override\n        public BufferedInputStream bodyStream() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n\n            // if we have read to bytes (via buffer up), return those as a stream.\n            if (byteData != null) {\n                return new BufferedInputStream(\n                    new ByteArrayInputStream(byteData.array(), 0, byteData.limit()),\n                    DefaultBufferSize);\n            }\n\n            Validate.isFalse(inputStreamRead, \"Request has already been read\");\n            Validate.notNull(bodyStream);\n            inputStreamRead = true;\n            return bodyStream.inputStream();\n        }\n\n        // set up connection defaults, and details from request\n        private static HttpURLConnection createConnection(HttpConnection.Request req) throws IOException {\n            Proxy proxy = req.proxy();\n            final HttpURLConnection conn = (HttpURLConnection) (\n                proxy == null ?\n                req.url().openConnection() :\n                req.url().openConnection(proxy)\n            );\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout() / 2); // gets reduced after connection is made and status is read\n\n            if (req.sslSocketFactory() != null && conn instanceof HttpsURLConnection)\n                ((HttpsURLConnection) conn).setSSLSocketFactory(req.sslSocketFactory());\n            if (req.authenticator != null)\n                AuthenticationHandler.handler.enable(req.authenticator, conn); // removed in finally\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            CookieUtil.applyCookiesToRequest(req, conn); // from the Request key/val cookies and the Cookie Store\n            for (Map.Entry<String, List<String>> header : req.multiHeaders().entrySet()) {\n                for (String value : header.getValue()) {\n                    conn.addRequestProperty(header.getKey(), value);\n                }\n            }\n            return conn;\n        }\n\n        /**\n         * Call on completion of stream read, to close the body (or error) stream. The connection.disconnect allows\n         * keep-alives to work (as the underlying connection is actually held open, despite the name).\n         */\n        private void safeClose() {\n            if (bodyStream != null) {\n                try {\n                    bodyStream.close();\n                } catch (IOException e) {\n                    // no-op\n                } finally {\n                    bodyStream = null;\n                }\n            }\n            if (conn != null) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n\n        // set up url, method, header, cookies\n        private Response(HttpURLConnection conn, HttpConnection.Request request, HttpConnection.@Nullable Response previousResponse) throws IOException {\n            this.conn = conn;\n            this.req = request;\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders); // includes cookie key/val read during header scan\n            CookieUtil.storeCookies(req, this, url, resHeaders); // add set cookies to cookie store\n\n            if (previousResponse != null) { // was redirected\n                previousResponse.safeClose();\n\n                // enforce too many redirects:\n                numRedirects = previousResponse.numRedirects + 1;\n                if (numRedirects >= MAX_REDIRECTS)\n                    throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n            }\n        }\n\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            // the default sun impl of conn.getHeaderFields() returns header values out of order\n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; // skip http1.1 line\n\n                final List<String> vals = headers.computeIfAbsent(key, Functions.listFunction());\n                vals.add(val);\n            }\n            return headers;\n        }\n\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                for (String value : values) {\n                    addHeader(name, fixHeaderEncoding(value));\n                }\n            }\n        }\n\n        /**\n         Servers may encode response headers in UTF-8 instead of RFC defined 8859. This method attempts to detect that\n         and re-decode the string as UTF-8.\n         * @param val a header value string that may have been incorrectly decoded as 8859.\n         * @return a potentially re-decoded string.\n         */\n        @Nullable\n        private static String fixHeaderEncoding(@Nullable String val) {\n            if (val == null) return val;\n            byte[] bytes = val.getBytes(ISO_8859_1);\n            if (looksLikeUtf8(bytes))\n                return new String(bytes, UTF_8);\n            else\n                return val;\n        }\n\n        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3\n                && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB\n                && (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            boolean foundNonAscii = false;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n                foundNonAscii = true;\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n                if (end >= input.length)\n                    return false;\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return foundNonAscii;\n        }\n\n        private @Nullable static String setOutputContentType(final Connection.Request req) {\n            final String contentType = req.header(CONTENT_TYPE);\n            String bound = null;\n            if (contentType != null) {\n                // no-op; don't add content type as already set (e.g. for requestBody())\n                // todo - if content type already set, we could add charset\n\n                // if user has set content type to multipart/form-data, auto add boundary.\n                if(contentType.contains(MULTIPART_FORM_DATA) && !contentType.contains(\"boundary\")) {\n                    bound = DataUtil.mimeBoundary();\n                    req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n                }\n\n            }\n            else if (needsMultipart(req)) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }\n\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, @Nullable final String boundary) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, Charset.forName(req.postDataCharset())));\n\n            if (boundary != null) {\n                // boundary will be set if we're in multipart mode\n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(boundary);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n                    w.write(\"\\\"\");\n                    final InputStream input = keyVal.inputStream();\n                    if (input != null) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: \");\n                        String contentType = keyVal.contentType();\n                        w.write(contentType != null ? contentType : DefaultUploadType);\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.flush(); // flush\n                        DataUtil.crossStreams(input, outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(boundary);\n                w.write(\"--\");\n            } else {\n                String body = req.requestBody();\n                if (body != null) {\n                    // data will be in query string, we're sending a plaintext body\n                    w.write(body);\n                }\n                else {\n                    // regular form data (application/x-www-form-urlencoded)\n                    boolean first = true;\n                    for (Connection.KeyVal keyVal : data) {\n                        if (!first)\n                            w.append('&');\n                        else\n                            first = false;\n\n                        w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                        w.write('=');\n                        w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                    }\n                }\n            }\n            w.close();\n        }\n\n        // for get url reqs, serialise the data map into the url\n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            UrlBuilder in = new UrlBuilder(req.url());\n\n            for (Connection.KeyVal keyVal : req.data()) {\n                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                in.appendKeyVal(keyVal);\n            }\n            req.url(in.build());\n            req.data().clear(); // moved into url as get params\n        }\n    }", "definition": "    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response", "class_docstring": "", "name": "Response", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final int MAX_REDIRECTS = 20;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "MAX_REDIRECTS = 20", "syntax_pass": true}, {"attribute_expression": "private static final String LOCATION = \"Location\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LOCATION = \"Location\"", "syntax_pass": true}, {"attribute_expression": "private final int statusCode;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "statusCode", "syntax_pass": true}, {"attribute_expression": "private final String statusMessage;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "statusMessage", "syntax_pass": true}, {"attribute_expression": "private @Nullable ByteBuffer byteData;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "ByteBuffer", "name": "byteData", "syntax_pass": true}, {"attribute_expression": "private @Nullable ControllableInputStream bodyStream;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "ControllableInputStream", "name": "bodyStream", "syntax_pass": true}, {"attribute_expression": "private @Nullable HttpURLConnection conn;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "HttpURLConnection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "private @Nullable String charset;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "charset", "syntax_pass": true}, {"attribute_expression": "private @Nullable final String contentType;", "docstring": "", "modifiers": "private @Nullable final", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "contentType", "syntax_pass": true}, {"attribute_expression": "private boolean executed = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "executed = false", "syntax_pass": true}, {"attribute_expression": "private boolean inputStreamRead = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "inputStreamRead = false", "syntax_pass": true}, {"attribute_expression": "private int numRedirects = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "numRedirects = 0", "syntax_pass": true}, {"attribute_expression": "private final HttpConnection.Request req;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "HttpConnection.Request", "name": "req", "syntax_pass": true}, {"attribute_expression": "private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(\\\\w+)/\\\\w*\\\\+?xml.*\");", "docstring": "\nMatches XML content types (like text/xml, image/svg+xml, application/xhtml+xml;charset=UTF8, etc)\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "xmlContentTypeRxp = Pattern.compile(\"(\\\\w+)/\\\\w*\\\\+?xml.*\")", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Response() {\n            super();\n            statusCode = 400;\n            statusMessage = \"Request not made\";\n            req = new Request();\n            contentType = null;\n        }", "docstring": "\n<b>Internal only! </b>Creates a dummy HttpConnection.Response, useful for testing. All actual responses\nare created from the HttpURLConnection and fields defined.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Response", "params": [], "body": "                   {\n            super();\n            statusCode = 400;\n            statusMessage = \"Request not made\";\n            req = new Request();\n            contentType = null;\n        }", "signature": "Response()"}, {"syntax_pass": true, "original_string": "        static Response execute(HttpConnection.Request req) throws IOException {\n            return execute(req, null);\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Response", "classes": []}, "name": "execute", "params": [{"name": "req", "type": "HttpConnection.Request"}], "body": "                                                                               {\n            return execute(req, null);\n        }", "signature": "static Response execute(HttpConnection.Request req)"}, {"syntax_pass": true, "original_string": "        static Response execute(HttpConnection.Request req, @Nullable Response previousResponse) throws IOException {\n            synchronized (req) {\n                Validate.isFalse(req.executing, \"Multiple threads were detected trying to execute the same request concurrently. Make sure to use Connection#newRequest() and do not share an executing request between threads.\");\n                req.executing = true;\n            }\n            Validate.notNullParam(req, \"req\");\n            URL url = req.url();\n            Validate.notNull(url, \"URL must be specified to connect\");\n            String protocol = url.getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res = null;\n            try {\n                conn.connect();\n                if (conn.getDoOutput()) {\n                    OutputStream out = conn.getOutputStream();\n                    try { writePost(req, out, mimeBoundary); }\n                    catch (IOException e) { conn.disconnect(); throw e; }\n                    finally { out.close(); }\n                }\n\n                int status = conn.getResponseCode();\n                res = new Response(conn, req, previousResponse);\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    Validate.notNull(location);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(redir);\n\n                    req.executing = false;\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, */xml, or */*+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    if (!req.parserDefined) req.parser(Parser.xmlParser());\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    InputStream stream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n                        stream = new GZIPInputStream(stream);\n                    else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\"))\n                        stream = new InflaterInputStream(stream, new Inflater(true));\n                    \n                    res.bodyStream = ControllableInputStream.wrap(\n                        stream, DefaultBufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout());\n\n                    if (req.responseProgress != null) // set response progress listener\n                        res.bodyStream.onProgress(conn.getContentLength(), req.responseProgress, res);\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e) {\n                if (res != null) res.safeClose(); // will be non-null if got to conn\n                throw e;\n            } finally {\n                req.executing = false;\n\n                // detach any thread local auth delegate\n                if (req.authenticator != null)\n                    AuthenticationHandler.handler.remove();\n            }\n\n            res.executed = true;\n            return res;\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Response", "classes": []}, "name": "execute", "params": [{"name": "req", "type": "HttpConnection.Request"}, {"name": "previousResponse", "type": "Response"}], "body": "                                                                                                                    {\n            synchronized (req) {\n                Validate.isFalse(req.executing, \"Multiple threads were detected trying to execute the same request concurrently. Make sure to use Connection#newRequest() and do not share an executing request between threads.\");\n                req.executing = true;\n            }\n            Validate.notNullParam(req, \"req\");\n            URL url = req.url();\n            Validate.notNull(url, \"URL must be specified to connect\");\n            String protocol = url.getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res = null;\n            try {\n                conn.connect();\n                if (conn.getDoOutput()) {\n                    OutputStream out = conn.getOutputStream();\n                    try { writePost(req, out, mimeBoundary); }\n                    catch (IOException e) { conn.disconnect(); throw e; }\n                    finally { out.close(); }\n                }\n\n                int status = conn.getResponseCode();\n                res = new Response(conn, req, previousResponse);\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    Validate.notNull(location);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(redir);\n\n                    req.executing = false;\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, */xml, or */*+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    if (!req.parserDefined) req.parser(Parser.xmlParser());\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    InputStream stream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n                        stream = new GZIPInputStream(stream);\n                    else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\"))\n                        stream = new InflaterInputStream(stream, new Inflater(true));\n                    \n                    res.bodyStream = ControllableInputStream.wrap(\n                        stream, DefaultBufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout());\n\n                    if (req.responseProgress != null) // set response progress listener\n                        res.bodyStream.onProgress(conn.getContentLength(), req.responseProgress, res);\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e) {\n                if (res != null) res.safeClose(); // will be non-null if got to conn\n                throw e;\n            } finally {\n                req.executing = false;\n\n                // detach any thread local auth delegate\n                if (req.authenticator != null)\n                    AuthenticationHandler.handler.remove();\n            }\n\n            res.executed = true;\n            return res;\n        }", "signature": "static Response execute(HttpConnection.Request req, @Nullable Response previousResponse)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int statusCode() {\n            return statusCode;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "statusCode", "params": [], "body": "                                {\n            return statusCode;\n        }", "signature": "@Override\n        public int statusCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String statusMessage() {\n            return statusMessage;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "statusMessage", "params": [], "body": "                                      {\n            return statusMessage;\n        }", "signature": "@Override\n        public String statusMessage()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String charset() {\n            return charset;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "charset", "params": [], "body": "                                {\n            return charset;\n        }", "signature": "@Override\n        public String charset()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Response charset(String charset) {\n            this.charset = charset;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Response", "classes": []}, "name": "charset", "params": [{"name": "charset", "type": "String"}], "body": "                                                {\n            this.charset = charset;\n            return this;\n        }", "signature": "@Override\n        public Response charset(String charset)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String contentType() {\n            return contentType;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "contentType", "params": [], "body": "                                    {\n            return contentType;\n        }", "signature": "@Override\n        public String contentType()"}, {"syntax_pass": true, "original_string": "        private ControllableInputStream prepareParse() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            ControllableInputStream stream = bodyStream;\n            if (byteData != null) { // bytes have been read in to the buffer, parse that\n                ByteArrayInputStream bytes = new ByteArrayInputStream(byteData.array(), 0, byteData.limit());\n                stream = ControllableInputStream.wrap(bytes, 0); // no max\n                inputStreamRead = false; // ok to reparse if in bytes\n            }\n            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n            Validate.notNull(stream);\n            inputStreamRead = true;\n            return stream;\n        }", "docstring": " Called from parse() or streamParser(), validates and prepares the input stream, and aligns common settings.", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ControllableInputStream", "classes": []}, "name": "prepareParse", "params": [], "body": "                                                       {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            ControllableInputStream stream = bodyStream;\n            if (byteData != null) { // bytes have been read in to the buffer, parse that\n                ByteArrayInputStream bytes = new ByteArrayInputStream(byteData.array(), 0, byteData.limit());\n                stream = ControllableInputStream.wrap(bytes, 0); // no max\n                inputStreamRead = false; // ok to reparse if in bytes\n            }\n            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n            Validate.notNull(stream);\n            inputStreamRead = true;\n            return stream;\n        }", "signature": "private ControllableInputStream prepareParse()"}, {"syntax_pass": true, "original_string": "        @Override public Document parse() throws IOException {\n            ControllableInputStream stream = prepareParse();\n            Document doc = DataUtil.parseInputStream(stream, charset, url.toExternalForm(), req.parser());\n            doc.connection(new HttpConnection(req, this)); // because we're static, don't have the connection obj. // todo - maybe hold in the req?\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            safeClose();\n            return doc;\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Document", "classes": []}, "name": "parse", "params": [], "body": "                                                             {\n            ControllableInputStream stream = prepareParse();\n            Document doc = DataUtil.parseInputStream(stream, charset, url.toExternalForm(), req.parser());\n            doc.connection(new HttpConnection(req, this)); // because we're static, don't have the connection obj. // todo - maybe hold in the req?\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            safeClose();\n            return doc;\n        }", "signature": "@Override public Document parse()"}, {"syntax_pass": true, "original_string": "        @Override public StreamParser streamParser() throws IOException {\n            ControllableInputStream stream = prepareParse();\n            String baseUri = url.toExternalForm();\n            DataUtil.CharsetDoc charsetDoc = DataUtil.detectCharset(stream, charset, baseUri, req.parser());\n            // note that there may be a document in CharsetDoc as a result of scanning meta-data -- but as requires a stream parse, it is not used here. todo - revisit.\n\n            // set up the stream parser and rig this connection up to the parsed doc:\n            StreamParser streamer = new StreamParser(req.parser());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(stream, charsetDoc.charset));\n            streamer.parse(reader, baseUri); // initializes the parse and the document, but does not step() it\n            streamer.document().connection(new HttpConnection(req, this));\n            charset = charsetDoc.charset.name();\n\n            // we don't safeClose() as in parse(); caller must close streamParser to close InputStream stream\n            return streamer;\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "StreamParser", "classes": []}, "name": "streamParser", "params": [], "body": "                                                                        {\n            ControllableInputStream stream = prepareParse();\n            String baseUri = url.toExternalForm();\n            DataUtil.CharsetDoc charsetDoc = DataUtil.detectCharset(stream, charset, baseUri, req.parser());\n            // note that there may be a document in CharsetDoc as a result of scanning meta-data -- but as requires a stream parse, it is not used here. todo - revisit.\n\n            // set up the stream parser and rig this connection up to the parsed doc:\n            StreamParser streamer = new StreamParser(req.parser());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(stream, charsetDoc.charset));\n            streamer.parse(reader, baseUri); // initializes the parse and the document, but does not step() it\n            streamer.document().connection(new HttpConnection(req, this));\n            charset = charsetDoc.charset.name();\n\n            // we don't safeClose() as in parse(); caller must close streamParser to close InputStream stream\n            return streamer;\n        }", "signature": "@Override public StreamParser streamParser()"}, {"syntax_pass": true, "original_string": "        private void prepareByteData() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            if (bodyStream != null && byteData == null) {\n                Validate.isFalse(inputStreamRead, \"Request has already been read (with .parse())\");\n                try {\n                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                } finally {\n                    inputStreamRead = true;\n                    safeClose();\n                }\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "prepareByteData", "params": [], "body": "                                       {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            if (bodyStream != null && byteData == null) {\n                Validate.isFalse(inputStreamRead, \"Request has already been read (with .parse())\");\n                try {\n                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                } finally {\n                    inputStreamRead = true;\n                    safeClose();\n                }\n            }\n        }", "signature": "private void prepareByteData()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String body() {\n            prepareByteData();\n            Validate.notNull(byteData);\n            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n            String body = (charset == null ? UTF_8 : Charset.forName(charset))\n                .decode(byteData).toString();\n            ((Buffer)byteData).rewind(); // cast to avoid covariant return type change in jdk9\n            return body;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "body", "params": [], "body": "                             {\n            prepareByteData();\n            Validate.notNull(byteData);\n            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n            String body = (charset == null ? UTF_8 : Charset.forName(charset))\n                .decode(byteData).toString();\n            ((Buffer)byteData).rewind(); // cast to avoid covariant return type change in jdk9\n            return body;\n        }", "signature": "@Override\n        public String body()"}, {"syntax_pass": true, "original_string": "        @Override\n        public byte[] bodyAsBytes() {\n            prepareByteData();\n            Validate.notNull(byteData);\n            Validate.isTrue(byteData.hasArray()); // we made it, so it should\n\n            byte[] array = byteData.array();\n            int offset = byteData.arrayOffset();\n            int length = byteData.limit();\n\n            if (offset == 0 && length == array.length) { // exact, just return it\n                return array;\n            } else { // trim to size\n                byte[] exactArray = new byte[length];\n                System.arraycopy(array, offset, exactArray, 0, length);\n                return exactArray;\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "name": "bodyAsBytes", "params": [], "body": "                                    {\n            prepareByteData();\n            Validate.notNull(byteData);\n            Validate.isTrue(byteData.hasArray()); // we made it, so it should\n\n            byte[] array = byteData.array();\n            int offset = byteData.arrayOffset();\n            int length = byteData.limit();\n\n            if (offset == 0 && length == array.length) { // exact, just return it\n                return array;\n            } else { // trim to size\n                byte[] exactArray = new byte[length];\n                System.arraycopy(array, offset, exactArray, 0, length);\n                return exactArray;\n            }\n        }", "signature": "@Override\n        public byte[] bodyAsBytes()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection.Response bufferUp() {\n            prepareByteData();\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection.Response", "classes": []}, "name": "bufferUp", "params": [], "body": "                                              {\n            prepareByteData();\n            return this;\n        }", "signature": "@Override\n        public Connection.Response bufferUp()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BufferedInputStream bodyStream() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n\n            // if we have read to bytes (via buffer up), return those as a stream.\n            if (byteData != null) {\n                return new BufferedInputStream(\n                    new ByteArrayInputStream(byteData.array(), 0, byteData.limit()),\n                    DefaultBufferSize);\n            }\n\n            Validate.isFalse(inputStreamRead, \"Request has already been read\");\n            Validate.notNull(bodyStream);\n            inputStreamRead = true;\n            return bodyStream.inputStream();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BufferedInputStream", "classes": []}, "name": "bodyStream", "params": [], "body": "                                                {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n\n            // if we have read to bytes (via buffer up), return those as a stream.\n            if (byteData != null) {\n                return new BufferedInputStream(\n                    new ByteArrayInputStream(byteData.array(), 0, byteData.limit()),\n                    DefaultBufferSize);\n            }\n\n            Validate.isFalse(inputStreamRead, \"Request has already been read\");\n            Validate.notNull(bodyStream);\n            inputStreamRead = true;\n            return bodyStream.inputStream();\n        }", "signature": "@Override\n        public BufferedInputStream bodyStream()"}, {"syntax_pass": true, "original_string": "        private static HttpURLConnection createConnection(HttpConnection.Request req) throws IOException {\n            Proxy proxy = req.proxy();\n            final HttpURLConnection conn = (HttpURLConnection) (\n                proxy == null ?\n                req.url().openConnection() :\n                req.url().openConnection(proxy)\n            );\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout() / 2); // gets reduced after connection is made and status is read\n\n            if (req.sslSocketFactory() != null && conn instanceof HttpsURLConnection)\n                ((HttpsURLConnection) conn).setSSLSocketFactory(req.sslSocketFactory());\n            if (req.authenticator != null)\n                AuthenticationHandler.handler.enable(req.authenticator, conn); // removed in finally\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            CookieUtil.applyCookiesToRequest(req, conn); // from the Request key/val cookies and the Cookie Store\n            for (Map.Entry<String, List<String>> header : req.multiHeaders().entrySet()) {\n                for (String value : header.getValue()) {\n                    conn.addRequestProperty(header.getKey(), value);\n                }\n            }\n            return conn;\n        }", "docstring": " set up connection defaults, and details from request", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "HttpURLConnection", "classes": []}, "name": "createConnection", "params": [{"name": "req", "type": "HttpConnection.Request"}], "body": "                                                                                                         {\n            Proxy proxy = req.proxy();\n            final HttpURLConnection conn = (HttpURLConnection) (\n                proxy == null ?\n                req.url().openConnection() :\n                req.url().openConnection(proxy)\n            );\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout() / 2); // gets reduced after connection is made and status is read\n\n            if (req.sslSocketFactory() != null && conn instanceof HttpsURLConnection)\n                ((HttpsURLConnection) conn).setSSLSocketFactory(req.sslSocketFactory());\n            if (req.authenticator != null)\n                AuthenticationHandler.handler.enable(req.authenticator, conn); // removed in finally\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            CookieUtil.applyCookiesToRequest(req, conn); // from the Request key/val cookies and the Cookie Store\n            for (Map.Entry<String, List<String>> header : req.multiHeaders().entrySet()) {\n                for (String value : header.getValue()) {\n                    conn.addRequestProperty(header.getKey(), value);\n                }\n            }\n            return conn;\n        }", "signature": "private static HttpURLConnection createConnection(HttpConnection.Request req)"}, {"syntax_pass": true, "original_string": "        private void safeClose() {\n            if (bodyStream != null) {\n                try {\n                    bodyStream.close();\n                } catch (IOException e) {\n                    // no-op\n                } finally {\n                    bodyStream = null;\n                }\n            }\n            if (conn != null) {\n                conn.disconnect();\n                conn = null;\n            }\n        }", "docstring": "\nCall on completion of stream read, to close the body (or error) stream. The connection.disconnect allows\nkeep-alives to work (as the underlying connection is actually held open, despite the name).\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "safeClose", "params": [], "body": "                                 {\n            if (bodyStream != null) {\n                try {\n                    bodyStream.close();\n                } catch (IOException e) {\n                    // no-op\n                } finally {\n                    bodyStream = null;\n                }\n            }\n            if (conn != null) {\n                conn.disconnect();\n                conn = null;\n            }\n        }", "signature": "private void safeClose()"}, {"syntax_pass": true, "original_string": "        private Response(HttpURLConnection conn, HttpConnection.Request request, HttpConnection.@Nullable Response previousResponse) throws IOException {\n            this.conn = conn;\n            this.req = request;\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders); // includes cookie key/val read during header scan\n            CookieUtil.storeCookies(req, this, url, resHeaders); // add set cookies to cookie store\n\n            if (previousResponse != null) { // was redirected\n                previousResponse.safeClose();\n\n                // enforce too many redirects:\n                numRedirects = previousResponse.numRedirects + 1;\n                if (numRedirects >= MAX_REDIRECTS)\n                    throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n            }\n        }", "docstring": " set up url, method, header, cookies", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Response", "params": [{"name": "conn", "type": "HttpURLConnection"}, {"name": "request", "type": "HttpConnection.Request"}, {"name": "previousResponse", "type": "HttpConnection.@Nullable Response"}], "body": "                                                                                                                                                        {\n            this.conn = conn;\n            this.req = request;\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders); // includes cookie key/val read during header scan\n            CookieUtil.storeCookies(req, this, url, resHeaders); // add set cookies to cookie store\n\n            if (previousResponse != null) { // was redirected\n                previousResponse.safeClose();\n\n                // enforce too many redirects:\n                numRedirects = previousResponse.numRedirects + 1;\n                if (numRedirects >= MAX_REDIRECTS)\n                    throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n            }\n        }", "signature": "private Response(HttpURLConnection conn, HttpConnection.Request request, HttpConnection.@Nullable Response previousResponse)"}, {"syntax_pass": true, "original_string": "        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            // the default sun impl of conn.getHeaderFields() returns header values out of order\n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; // skip http1.1 line\n\n                final List<String> vals = headers.computeIfAbsent(key, Functions.listFunction());\n                vals.add(val);\n            }\n            return headers;\n        }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "LinkedHashMap<String, List<String>>", "classes": []}, "name": "createHeaderMap", "params": [{"name": "conn", "type": "HttpURLConnection"}], "body": "                                                                                                   {\n            // the default sun impl of conn.getHeaderFields() returns header values out of order\n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; // skip http1.1 line\n\n                final List<String> vals = headers.computeIfAbsent(key, Functions.listFunction());\n                vals.add(val);\n            }\n            return headers;\n        }", "signature": "private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn)"}, {"syntax_pass": true, "original_string": "        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                for (String value : values) {\n                    addHeader(name, fixHeaderEncoding(value));\n                }\n            }\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "processResponseHeaders", "params": [{"name": "resHeaders", "type": "Map<String, List<String>>"}], "body": "                                                                          {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                for (String value : values) {\n                    addHeader(name, fixHeaderEncoding(value));\n                }\n            }\n        }", "signature": "void processResponseHeaders(Map<String, List<String>> resHeaders)"}, {"syntax_pass": true, "original_string": "        @Nullable\n        private static String fixHeaderEncoding(@Nullable String val) {\n            if (val == null) return val;\n            byte[] bytes = val.getBytes(ISO_8859_1);\n            if (looksLikeUtf8(bytes))\n                return new String(bytes, UTF_8);\n            else\n                return val;\n        }", "docstring": "\nServers may encode response headers in UTF-8 instead of RFC defined 8859. This method attempts to detect that\nand re-decode the string as UTF-8.\n@param val a header value string that may have been incorrectly decoded as 8859.\n@return a potentially re-decoded string.\n", "attributes": {"modifiers": "@Nullable\n        private static", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "fixHeaderEncoding", "params": [{"name": "val", "type": "String"}], "body": "                                                                      {\n            if (val == null) return val;\n            byte[] bytes = val.getBytes(ISO_8859_1);\n            if (looksLikeUtf8(bytes))\n                return new String(bytes, UTF_8);\n            else\n                return val;\n        }", "signature": "@Nullable\n        private static String fixHeaderEncoding(@Nullable String val)"}, {"syntax_pass": true, "original_string": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3\n                && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB\n                && (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            boolean foundNonAscii = false;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n                foundNonAscii = true;\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n                if (end >= input.length)\n                    return false;\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return foundNonAscii;\n        }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "looksLikeUtf8", "params": [{"name": "input", "type": "byte[]"}], "body": "                                                           {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3\n                && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB\n                && (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            boolean foundNonAscii = false;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n                foundNonAscii = true;\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n                if (end >= input.length)\n                    return false;\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return foundNonAscii;\n        }", "signature": "private static boolean looksLikeUtf8(byte[] input)"}, {"syntax_pass": true, "original_string": "        private @Nullable static String setOutputContentType(final Connection.Request req) {\n            final String contentType = req.header(CONTENT_TYPE);\n            String bound = null;\n            if (contentType != null) {\n                // no-op; don't add content type as already set (e.g. for requestBody())\n                // todo - if content type already set, we could add charset\n\n                // if user has set content type to multipart/form-data, auto add boundary.\n                if(contentType.contains(MULTIPART_FORM_DATA) && !contentType.contains(\"boundary\")) {\n                    bound = DataUtil.mimeBoundary();\n                    req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n                }\n\n            }\n            else if (needsMultipart(req)) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }", "docstring": "", "attributes": {"modifiers": "private @Nullable static", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "setOutputContentType", "params": [{"name": "req", "type": "Connection.Request"}], "body": "                                                                                           {\n            final String contentType = req.header(CONTENT_TYPE);\n            String bound = null;\n            if (contentType != null) {\n                // no-op; don't add content type as already set (e.g. for requestBody())\n                // todo - if content type already set, we could add charset\n\n                // if user has set content type to multipart/form-data, auto add boundary.\n                if(contentType.contains(MULTIPART_FORM_DATA) && !contentType.contains(\"boundary\")) {\n                    bound = DataUtil.mimeBoundary();\n                    req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n                }\n\n            }\n            else if (needsMultipart(req)) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }", "signature": "private @Nullable static String setOutputContentType(final Connection.Request req)"}, {"syntax_pass": true, "original_string": "        private static void writePost(final Connection.Request req, final OutputStream outputStream, @Nullable final String boundary) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, Charset.forName(req.postDataCharset())));\n\n            if (boundary != null) {\n                // boundary will be set if we're in multipart mode\n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(boundary);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n                    w.write(\"\\\"\");\n                    final InputStream input = keyVal.inputStream();\n                    if (input != null) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: \");\n                        String contentType = keyVal.contentType();\n                        w.write(contentType != null ? contentType : DefaultUploadType);\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.flush(); // flush\n                        DataUtil.crossStreams(input, outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(boundary);\n                w.write(\"--\");\n            } else {\n                String body = req.requestBody();\n                if (body != null) {\n                    // data will be in query string, we're sending a plaintext body\n                    w.write(body);\n                }\n                else {\n                    // regular form data (application/x-www-form-urlencoded)\n                    boolean first = true;\n                    for (Connection.KeyVal keyVal : data) {\n                        if (!first)\n                            w.append('&');\n                        else\n                            first = false;\n\n                        w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                        w.write('=');\n                        w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                    }\n                }\n            }\n            w.close();\n        }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "writePost", "params": [{"name": "req", "type": "Connection.Request"}, {"name": "outputStream", "type": "OutputStream"}, {"name": "boundary", "type": "String"}], "body": "                                                                                                                                                         {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, Charset.forName(req.postDataCharset())));\n\n            if (boundary != null) {\n                // boundary will be set if we're in multipart mode\n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(boundary);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n                    w.write(\"\\\"\");\n                    final InputStream input = keyVal.inputStream();\n                    if (input != null) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: \");\n                        String contentType = keyVal.contentType();\n                        w.write(contentType != null ? contentType : DefaultUploadType);\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.flush(); // flush\n                        DataUtil.crossStreams(input, outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(boundary);\n                w.write(\"--\");\n            } else {\n                String body = req.requestBody();\n                if (body != null) {\n                    // data will be in query string, we're sending a plaintext body\n                    w.write(body);\n                }\n                else {\n                    // regular form data (application/x-www-form-urlencoded)\n                    boolean first = true;\n                    for (Connection.KeyVal keyVal : data) {\n                        if (!first)\n                            w.append('&');\n                        else\n                            first = false;\n\n                        w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                        w.write('=');\n                        w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                    }\n                }\n            }\n            w.close();\n        }", "signature": "private static void writePost(final Connection.Request req, final OutputStream outputStream, @Nullable final String boundary)"}, {"syntax_pass": true, "original_string": "        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            UrlBuilder in = new UrlBuilder(req.url());\n\n            for (Connection.KeyVal keyVal : req.data()) {\n                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                in.appendKeyVal(keyVal);\n            }\n            req.url(in.build());\n            req.data().clear(); // moved into url as get params\n        }", "docstring": " for get url reqs, serialise the data map into the url", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "serialiseRequestUrl", "params": [{"name": "req", "type": "Connection.Request"}], "body": "                                                                                           {\n            UrlBuilder in = new UrlBuilder(req.url());\n\n            for (Connection.KeyVal keyVal : req.data()) {\n                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                in.appendKeyVal(keyVal);\n            }\n            req.url(in.build());\n            req.data().clear(); // moved into url as get params\n        }", "signature": "private static void serialiseRequestUrl(Connection.Request req)"}]}, {"original_string": "    public static class KeyVal implements Connection.KeyVal {\n        private String key;\n        private String value;\n        private @Nullable InputStream stream;\n        private @Nullable String contentType;\n\n        public static KeyVal create(String key, String value) {\n            return new KeyVal(key, value);\n        }\n\n        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal(key, filename)\n                .inputStream(stream);\n        }\n\n        private KeyVal(String key, String value) {\n            Validate.notEmptyParam(key, \"key\");\n            Validate.notNullParam(value, \"value\");\n            this.key = key;\n            this.value = value;\n        }\n\n        @Override\n        public KeyVal key(String key) {\n            Validate.notEmptyParam(key, \"key\");\n            this.key = key;\n            return this;\n        }\n\n        @Override\n        public String key() {\n            return key;\n        }\n\n        @Override\n        public KeyVal value(String value) {\n            Validate.notNullParam(value, \"value\");\n            this.value = value;\n            return this;\n        }\n\n        @Override\n        public String value() {\n            return value;\n        }\n\n        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNullParam(value, \"inputStream\");\n            this.stream = inputStream;\n            return this;\n        }\n\n        @Override\n        public InputStream inputStream() {\n            return stream;\n        }\n\n        @Override\n        public boolean hasInputStream() {\n            return stream != null;\n        }\n\n        @Override\n        public Connection.KeyVal contentType(String contentType) {\n            Validate.notEmpty(contentType);\n            this.contentType = contentType;\n            return this;\n        }\n\n        @Override\n        public String contentType() {\n            return contentType;\n        }\n\n        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }", "definition": "    public static class KeyVal implements Connection.KeyVal", "class_docstring": "", "name": "KeyVal", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String key;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "key", "syntax_pass": true}, {"attribute_expression": "private String value;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "value", "syntax_pass": true}, {"attribute_expression": "private @Nullable InputStream stream;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "InputStream", "name": "stream", "syntax_pass": true}, {"attribute_expression": "private @Nullable String contentType;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "contentType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public static KeyVal create(String key, String value) {\n            return new KeyVal(key, value);\n        }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "KeyVal", "classes": []}, "name": "create", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                              {\n            return new KeyVal(key, value);\n        }", "signature": "public static KeyVal create(String key, String value)"}, {"syntax_pass": true, "original_string": "        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal(key, filename)\n                .inputStream(stream);\n        }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "KeyVal", "classes": []}, "name": "create", "params": [{"name": "key", "type": "String"}, {"name": "filename", "type": "String"}, {"name": "stream", "type": "InputStream"}], "body": "                                                                                     {\n            return new KeyVal(key, filename)\n                .inputStream(stream);\n        }", "signature": "public static KeyVal create(String key, String filename, InputStream stream)"}, {"syntax_pass": true, "original_string": "        private KeyVal(String key, String value) {\n            Validate.notEmptyParam(key, \"key\");\n            Validate.notNullParam(value, \"value\");\n            this.key = key;\n            this.value = value;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "KeyVal", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                 {\n            Validate.notEmptyParam(key, \"key\");\n            Validate.notNullParam(value, \"value\");\n            this.key = key;\n            this.value = value;\n        }", "signature": "private KeyVal(String key, String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public KeyVal key(String key) {\n            Validate.notEmptyParam(key, \"key\");\n            this.key = key;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "KeyVal", "classes": []}, "name": "key", "params": [{"name": "key", "type": "String"}], "body": "                                      {\n            Validate.notEmptyParam(key, \"key\");\n            this.key = key;\n            return this;\n        }", "signature": "@Override\n        public KeyVal key(String key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String key() {\n            return key;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "key", "params": [], "body": "                            {\n            return key;\n        }", "signature": "@Override\n        public String key()"}, {"syntax_pass": true, "original_string": "        @Override\n        public KeyVal value(String value) {\n            Validate.notNullParam(value, \"value\");\n            this.value = value;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "KeyVal", "classes": []}, "name": "value", "params": [{"name": "value", "type": "String"}], "body": "                                          {\n            Validate.notNullParam(value, \"value\");\n            this.value = value;\n            return this;\n        }", "signature": "@Override\n        public KeyVal value(String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String value() {\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "value", "params": [], "body": "                              {\n            return value;\n        }", "signature": "@Override\n        public String value()"}, {"syntax_pass": true, "original_string": "        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNullParam(value, \"inputStream\");\n            this.stream = inputStream;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "KeyVal", "classes": []}, "name": "inputStream", "params": [{"name": "inputStream", "type": "InputStream"}], "body": "                                                           {\n            Validate.notNullParam(value, \"inputStream\");\n            this.stream = inputStream;\n            return this;\n        }", "signature": "public KeyVal inputStream(InputStream inputStream)"}, {"syntax_pass": true, "original_string": "        @Override\n        public InputStream inputStream() {\n            return stream;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "inputStream", "params": [], "body": "                                         {\n            return stream;\n        }", "signature": "@Override\n        public InputStream inputStream()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasInputStream() {\n            return stream != null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasInputStream", "params": [], "body": "                                        {\n            return stream != null;\n        }", "signature": "@Override\n        public boolean hasInputStream()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection.KeyVal contentType(String contentType) {\n            Validate.notEmpty(contentType);\n            this.contentType = contentType;\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection.KeyVal", "classes": []}, "name": "contentType", "params": [{"name": "contentType", "type": "String"}], "body": "                                                                 {\n            Validate.notEmpty(contentType);\n            this.contentType = contentType;\n            return this;\n        }", "signature": "@Override\n        public Connection.KeyVal contentType(String contentType)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String contentType() {\n            return contentType;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "contentType", "params": [], "body": "                                    {\n            return contentType;\n        }", "signature": "@Override\n        public String contentType()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return key + \"=\" + value;\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nImplementation of {@link Connection}.\n@see org.jsoup.Jsoup#connect(String)\n", "original_string": "@SuppressWarnings(\"CharsetObjectCanBeUsed\")\npublic class HttpConnection implements Connection {\n    public static final String CONTENT_ENCODING = \"Content-Encoding\";\n    /**\n     * Many users would get caught by not setting a user-agent and therefore getting different responses on their desktop\n     * vs in jsoup, which would otherwise default to {@code Java}. So by default, use a desktop UA.\n     */\n    public static final String DEFAULT_UA =\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36\";\n    private static final String USER_AGENT = \"User-Agent\";\n    public static final String CONTENT_TYPE = \"Content-Type\";\n    public static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n    public static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\";\n    private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.\n    private static final String DefaultUploadType = \"application/octet-stream\";\n    private static final Charset ISO_8859_1 = Charset.forName(\"ISO-8859-1\");\n\n    /**\n     Create a new Connection, with the request URL specified.\n     @param url the URL to fetch from\n     @return a new Connection object\n     */\n    public static Connection connect(String url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n    /**\n     Create a new Connection, with the request URL specified.\n     @param url the URL to fetch from\n     @return a new Connection object\n     */\n    public static Connection connect(URL url) {\n        Connection con = new HttpConnection();\n        con.url(url);\n        return con;\n    }\n\n    /**\n     Create a new, empty HttpConnection.\n     */\n    public HttpConnection() {\n        req = new Request();\n    }\n\n    /**\n     Create a new Request by deep-copying an existing Request. Note that the data and body of the original are not\n     copied. All other settings (proxy, parser, cookies, etc) are copied.\n     @param copy the request to copy\n     */\n    HttpConnection(Request copy) {\n        req = new Request(copy);\n    }\n\n    private static String encodeMimeName(String val) {\n        return val.replace(\"\\\"\", \"%22\");\n    }\n\n    private HttpConnection.Request req;\n    private Connection.@Nullable Response res;\n\n    @Override\n    public Connection newRequest() {\n        // copy the prototype request for the different settings, cookie manager, etc\n        return new HttpConnection(req);\n    }\n\n    /** Create a new Connection that just wraps the provided Request and Response */\n    private HttpConnection(Request req, Response res) {\n        this.req = req;\n        this.res = res;\n    }\n\n    @Override\n    public Connection url(URL url) {\n        req.url(url);\n        return this;\n    }\n\n    @Override\n    public Connection url(String url) {\n        Validate.notEmptyParam(url, \"url\");\n        try {\n            req.url(new URL(url));\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(String.format(\"The supplied URL, '%s', is malformed. Make sure it is an absolute URL, and starts with 'http://' or 'https://'. See https://jsoup.org/cookbook/extracting-data/working-with-urls\", url), e);\n        }\n        return this;\n    }\n\n    @Override\n    public Connection proxy(@Nullable Proxy proxy) {\n        req.proxy(proxy);\n        return this;\n    }\n\n    @Override\n    public Connection proxy(String host, int port) {\n        req.proxy(host, port);\n        return this;\n    }\n\n    @Override\n    public Connection userAgent(String userAgent) {\n        Validate.notNullParam(userAgent, \"userAgent\");\n        req.header(USER_AGENT, userAgent);\n        return this;\n    }\n\n    @Override\n    public Connection timeout(int millis) {\n        req.timeout(millis);\n        return this;\n    }\n\n    @Override\n    public Connection maxBodySize(int bytes) {\n        req.maxBodySize(bytes);\n        return this;\n    }\n\n    @Override\n    public Connection followRedirects(boolean followRedirects) {\n        req.followRedirects(followRedirects);\n        return this;\n    }\n\n    @Override\n    public Connection referrer(String referrer) {\n        Validate.notNullParam(referrer, \"referrer\");\n        req.header(\"Referer\", referrer);\n        return this;\n    }\n\n    @Override\n    public Connection method(Method method) {\n        req.method(method);\n        return this;\n    }\n\n    @Override\n    public Connection ignoreHttpErrors(boolean ignoreHttpErrors) {\n\t\treq.ignoreHttpErrors(ignoreHttpErrors);\n\t\treturn this;\n\t}\n\n    @Override\n    public Connection ignoreContentType(boolean ignoreContentType) {\n        req.ignoreContentType(ignoreContentType);\n        return this;\n    }\n\n    @Override\n    public Connection data(String key, String value) {\n        req.data(KeyVal.create(key, value));\n        return this;\n    }\n\n    @Override\n    public Connection sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n\t    req.sslSocketFactory(sslSocketFactory);\n\t    return this;\n    }\n\n    @Override\n    public Connection data(String key, String filename, InputStream inputStream) {\n        req.data(KeyVal.create(key, filename, inputStream));\n        return this;\n    }\n\n    @Override\n    public Connection data(String key, String filename, InputStream inputStream, String contentType) {\n        req.data(KeyVal.create(key, filename, inputStream).contentType(contentType));\n        return this;\n    }\n\n    @Override\n    public Connection data(Map<String, String> data) {\n        Validate.notNullParam(data, \"data\");\n        for (Map.Entry<String, String> entry : data.entrySet()) {\n            req.data(KeyVal.create(entry.getKey(), entry.getValue()));\n        }\n        return this;\n    }\n\n    @Override\n    public Connection data(String... keyvals) {\n        Validate.notNullParam(keyvals, \"keyvals\");\n        Validate.isTrue(keyvals.length %2 == 0, \"Must supply an even number of key value pairs\");\n        for (int i = 0; i < keyvals.length; i += 2) {\n            String key = keyvals[i];\n            String value = keyvals[i+1];\n            Validate.notEmpty(key, \"Data key must not be empty\");\n            Validate.notNull(value, \"Data value must not be null\");\n            req.data(KeyVal.create(key, value));\n        }\n        return this;\n    }\n\n    @Override\n    public Connection data(Collection<Connection.KeyVal> data) {\n        Validate.notNullParam(data, \"data\");\n        for (Connection.KeyVal entry: data) {\n            req.data(entry);\n        }\n        return this;\n    }\n\n    @Override\n    public Connection.KeyVal data(String key) {\n        Validate.notEmptyParam(key, \"key\");\n        for (Connection.KeyVal keyVal : request().data()) {\n            if (keyVal.key().equals(key))\n                return keyVal;\n        }\n        return null;\n    }\n\n    @Override\n    public Connection requestBody(String body) {\n        req.requestBody(body);\n        return this;\n    }\n\n    @Override\n    public Connection header(String name, String value) {\n        req.header(name, value);\n        return this;\n    }\n\n    @Override\n    public Connection headers(Map<String,String> headers) {\n        Validate.notNullParam(headers, \"headers\");\n        for (Map.Entry<String,String> entry : headers.entrySet()) {\n            req.header(entry.getKey(),entry.getValue());\n        }\n        return this;\n    }\n\n    @Override\n    public Connection cookie(String name, String value) {\n        req.cookie(name, value);\n        return this;\n    }\n\n    @Override\n    public Connection cookies(Map<String, String> cookies) {\n        Validate.notNullParam(cookies, \"cookies\");\n        for (Map.Entry<String, String> entry : cookies.entrySet()) {\n            req.cookie(entry.getKey(), entry.getValue());\n        }\n        return this;\n    }\n\n    @Override\n    public Connection cookieStore(CookieStore cookieStore) {\n        // create a new cookie manager using the new store\n        req.cookieManager = new CookieManager(cookieStore, null);\n        return this;\n    }\n\n    @Override\n    public CookieStore cookieStore() {\n        return req.cookieManager.getCookieStore();\n    }\n\n    @Override\n    public Connection parser(Parser parser) {\n        req.parser(parser);\n        return this;\n    }\n\n    @Override\n    public Document get() throws IOException {\n        req.method(Method.GET);\n        execute();\n        Validate.notNull(res);\n        return res.parse();\n    }\n\n    @Override\n    public Document post() throws IOException {\n        req.method(Method.POST);\n        execute();\n        Validate.notNull(res);\n        return res.parse();\n    }\n\n    @Override\n    public Connection.Response execute() throws IOException {\n        res = Response.execute(req);\n        return res;\n    }\n\n    @Override\n    public Connection.Request request() {\n        return req;\n    }\n\n    @Override\n    public Connection request(Connection.Request request) {\n        req = (HttpConnection.Request) request; // will throw a class-cast exception if the user has extended some but not all of Connection; that's desired\n        return this;\n    }\n\n    @Override\n    public Connection.Response response() {\n        if (res == null) {\n            throw new IllegalArgumentException(\"You must execute the request before getting a response.\");\n        }\n        return res;\n    }\n\n    @Override\n    public Connection response(Connection.Response response) {\n        res = response;\n        return this;\n    }\n\n    @Override\n    public Connection postDataCharset(String charset) {\n        req.postDataCharset(charset);\n        return this;\n    }\n\n    @Override public Connection auth(RequestAuthenticator authenticator) {\n        req.auth(authenticator);\n        return this;\n    }\n\n    @Override public Connection onResponseProgress(Progress<Connection.Response> handler) {\n        req.responseProgress = handler;\n        return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static abstract class Base<T extends Connection.Base<T>> implements Connection.Base<T> {\n        private static final URL UnsetUrl; // only used if you created a new Request()\n        static {\n            try {\n                UnsetUrl = new URL(\"http://undefined/\");\n            } catch (MalformedURLException e) {\n                throw new IllegalStateException(e);\n            }\n        }\n\n        URL url = UnsetUrl;\n        Method method = Method.GET;\n        Map<String, List<String>> headers;\n        Map<String, String> cookies;\n\n        private Base() {\n            headers = new LinkedHashMap<>();\n            cookies = new LinkedHashMap<>();\n        }\n\n        private Base(Base<T> copy) {\n            url = copy.url; // unmodifiable object\n            method = copy.method;\n            headers = new LinkedHashMap<>();\n            for (Map.Entry<String, List<String>> entry : copy.headers.entrySet()) {\n                headers.put(entry.getKey(), new ArrayList<>(entry.getValue()));\n            }\n            cookies = new LinkedHashMap<>(); cookies.putAll(copy.cookies); // just holds strings\n        }\n\n        @Override\n        public URL url() {\n            if (url == UnsetUrl)\n                throw new IllegalArgumentException(\"URL not set. Make sure to call #url(...) before executing the request.\");\n            return url;\n        }\n\n        @Override\n        public T url(URL url) {\n            Validate.notNullParam(url, \"url\");\n            this.url = new UrlBuilder(url).build();\n            return (T) this;\n        }\n\n        @Override\n        public Method method() {\n            return method;\n        }\n\n        @Override\n        public T method(Method method) {\n            Validate.notNullParam(method, \"method\");\n            this.method = method;\n            return (T) this;\n        }\n\n        @Override\n        public String header(String name) {\n            Validate.notNullParam(name, \"name\");\n            List<String> vals = getHeadersCaseInsensitive(name);\n            if (vals.size() > 0) {\n                // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                return StringUtil.join(vals, \", \");\n            }\n\n            return null;\n        }\n\n        @Override\n        public T addHeader(String name, @Nullable String value) {\n            Validate.notEmptyParam(name, \"name\");\n            value = value == null ? \"\" : value;\n\n            List<String> values = headers(name);\n            if (values.isEmpty()) {\n                values = new ArrayList<>();\n                headers.put(name, values);\n            }\n            values.add(value);\n\n            return (T) this;\n        }\n\n        @Override\n        public List<String> headers(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return getHeadersCaseInsensitive(name);\n        }\n\n        @Override\n        public T header(String name, String value) {\n            Validate.notEmptyParam(name, \"name\");\n            removeHeader(name); // ensures we don't get an \"accept-encoding\" and a \"Accept-Encoding\"\n            addHeader(name, value);\n            return (T) this;\n        }\n\n        @Override\n        public boolean hasHeader(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return !getHeadersCaseInsensitive(name).isEmpty();\n        }\n\n        /**\n         * Test if the request has a header with this value (case insensitive).\n         */\n        @Override\n        public boolean hasHeaderWithValue(String name, String value) {\n            Validate.notEmpty(name);\n            Validate.notEmpty(value);\n            List<String> values = headers(name);\n            for (String candidate : values) {\n                if (value.equalsIgnoreCase(candidate))\n                    return true;\n            }\n            return false;\n        }\n\n        @Override\n        public T removeHeader(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            Map.Entry<String, List<String>> entry = scanHeaders(name); // remove is case-insensitive too\n            if (entry != null)\n                headers.remove(entry.getKey()); // ensures correct case\n            return (T) this;\n        }\n\n        @Override\n        public Map<String, String> headers() {\n            LinkedHashMap<String, String> map = new LinkedHashMap<>(headers.size());\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                String header = entry.getKey();\n                List<String> values = entry.getValue();\n                if (values.size() > 0)\n                    map.put(header, values.get(0));\n            }\n            return map;\n        }\n\n        @Override\n        public Map<String, List<String>> multiHeaders() {\n            return headers;\n        }\n\n        private List<String> getHeadersCaseInsensitive(String name) {\n            Validate.notNull(name);\n\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (name.equalsIgnoreCase(entry.getKey()))\n                    return entry.getValue();\n            }\n\n            return Collections.emptyList();\n        }\n\n        private Map.@Nullable Entry<String, List<String>> scanHeaders(String name) {\n            String lc = lowerCase(name);\n            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n                if (lowerCase(entry.getKey()).equals(lc))\n                    return entry;\n            }\n            return null;\n        }\n\n        @Override\n        public String cookie(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return cookies.get(name);\n        }\n\n        @Override\n        public T cookie(String name, String value) {\n            Validate.notEmptyParam(name, \"name\");\n            Validate.notNullParam(value, \"value\");\n            cookies.put(name, value);\n            return (T) this;\n        }\n\n        @Override\n        public boolean hasCookie(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            return cookies.containsKey(name);\n        }\n\n        @Override\n        public T removeCookie(String name) {\n            Validate.notEmptyParam(name, \"name\");\n            cookies.remove(name);\n            return (T) this;\n        }\n\n        @Override\n        public Map<String, String> cookies() {\n            return cookies;\n        }\n    }\n\n    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n        static {\n            System.setProperty(\"sun.net.http.allowRestrictedHeaders\", \"true\");\n            // make sure that we can send Sec-Fetch-Site headers etc.\n        }\n\n        private @Nullable Proxy proxy;\n        private int timeoutMilliseconds;\n        private int maxBodySizeBytes;\n        private boolean followRedirects;\n        private final Collection<Connection.KeyVal> data;\n        private @Nullable String body = null;\n        private boolean ignoreHttpErrors = false;\n        private boolean ignoreContentType = false;\n        private Parser parser;\n        private boolean parserDefined = false; // called parser(...) vs initialized in ctor\n        private String postDataCharset = DataUtil.defaultCharsetName;\n        private @Nullable SSLSocketFactory sslSocketFactory;\n        private CookieManager cookieManager;\n        private @Nullable RequestAuthenticator authenticator;\n        private @Nullable Progress<Connection.Response> responseProgress;\n\n        private volatile boolean executing = false;\n\n        Request() {\n            super();\n            timeoutMilliseconds = 30000; // 30 seconds\n            maxBodySizeBytes = 1024 * 1024 * 2; // 2MB\n            followRedirects = true;\n            data = new ArrayList<>();\n            method = Method.GET;\n            addHeader(\"Accept-Encoding\", \"gzip\");\n            addHeader(USER_AGENT, DEFAULT_UA);\n            parser = Parser.htmlParser();\n            cookieManager = new CookieManager(); // creates a default InMemoryCookieStore\n        }\n\n        Request(Request copy) {\n            super(copy);\n            proxy = copy.proxy;\n            postDataCharset = copy.postDataCharset;\n            timeoutMilliseconds = copy.timeoutMilliseconds;\n            maxBodySizeBytes = copy.maxBodySizeBytes;\n            followRedirects = copy.followRedirects;\n            data = new ArrayList<>(); // data not copied\n            //body not copied\n            ignoreHttpErrors = copy.ignoreHttpErrors;\n            ignoreContentType = copy.ignoreContentType;\n            parser = copy.parser.newInstance(); // parsers and their tree-builders maintain state, so need a fresh copy\n            parserDefined = copy.parserDefined;\n            sslSocketFactory = copy.sslSocketFactory; // these are all synchronized so safe to share\n            cookieManager = copy.cookieManager;\n            authenticator = copy.authenticator;\n            responseProgress = copy.responseProgress;\n            executing = false;\n        }\n\n        @Override\n        public Proxy proxy() {\n            return proxy;\n        }\n\n        @Override\n        public Request proxy(@Nullable Proxy proxy) {\n            this.proxy = proxy;\n            return this;\n        }\n\n        @Override\n        public Request proxy(String host, int port) {\n            this.proxy = new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(host, port));\n            return this;\n        }\n\n        @Override\n        public int timeout() {\n            return timeoutMilliseconds;\n        }\n\n        @Override\n        public Request timeout(int millis) {\n            Validate.isTrue(millis >= 0, \"Timeout milliseconds must be 0 (infinite) or greater\");\n            timeoutMilliseconds = millis;\n            return this;\n        }\n\n        @Override\n        public int maxBodySize() {\n            return maxBodySizeBytes;\n        }\n\n        @Override\n        public Connection.Request maxBodySize(int bytes) {\n            Validate.isTrue(bytes >= 0, \"maxSize must be 0 (unlimited) or larger\");\n            maxBodySizeBytes = bytes;\n            return this;\n        }\n\n        @Override\n        public boolean followRedirects() {\n            return followRedirects;\n        }\n\n        @Override\n        public Connection.Request followRedirects(boolean followRedirects) {\n            this.followRedirects = followRedirects;\n            return this;\n        }\n\n        @Override\n        public boolean ignoreHttpErrors() {\n            return ignoreHttpErrors;\n        }\n\n        @Override\n        public SSLSocketFactory sslSocketFactory() {\n            return sslSocketFactory;\n        }\n\n        @Override\n        public void sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n            this.sslSocketFactory = sslSocketFactory;\n        }\n\n        @Override\n        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n            this.ignoreHttpErrors = ignoreHttpErrors;\n            return this;\n        }\n\n        @Override\n        public boolean ignoreContentType() {\n            return ignoreContentType;\n        }\n\n        @Override\n        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n            this.ignoreContentType = ignoreContentType;\n            return this;\n        }\n\n        @Override\n        public Request data(Connection.KeyVal keyval) {\n            Validate.notNullParam(keyval, \"keyval\");\n            data.add(keyval);\n            return this;\n        }\n\n        @Override\n        public Collection<Connection.KeyVal> data() {\n            return data;\n        }\n\n        @Override\n        public Connection.Request requestBody(@Nullable String body) {\n            this.body = body;\n            return this;\n        }\n\n        @Override\n        public String requestBody() {\n            return body;\n        }\n\n        @Override\n        public Request parser(Parser parser) {\n            this.parser = parser;\n            parserDefined = true;\n            return this;\n        }\n\n        @Override\n        public Parser parser() {\n            return parser;\n        }\n\n        @Override\n        public Connection.Request postDataCharset(String charset) {\n            Validate.notNullParam(charset, \"charset\");\n            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n            this.postDataCharset = charset;\n            return this;\n        }\n\n        @Override\n        public String postDataCharset() {\n            return postDataCharset;\n        }\n\n        CookieManager cookieManager() {\n            return cookieManager;\n        }\n\n        @Override public Connection.Request auth(@Nullable RequestAuthenticator authenticator) {\n            this.authenticator = authenticator;\n            return this;\n        }\n\n        @Override @Nullable public RequestAuthenticator auth() {\n            return authenticator;\n        }\n    }\n\n    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n        private static final int MAX_REDIRECTS = 20;\n        private static final String LOCATION = \"Location\";\n        private final int statusCode;\n        private final String statusMessage;\n        private @Nullable ByteBuffer byteData;\n        private @Nullable ControllableInputStream bodyStream;\n        private @Nullable HttpURLConnection conn;\n        private @Nullable String charset;\n        private @Nullable final String contentType;\n        private boolean executed = false;\n        private boolean inputStreamRead = false;\n        private int numRedirects = 0;\n        private final HttpConnection.Request req;\n\n        /*\n         * Matches XML content types (like text/xml, image/svg+xml, application/xhtml+xml;charset=UTF8, etc)\n         */\n        private static final Pattern xmlContentTypeRxp = Pattern.compile(\"(\\\\w+)/\\\\w*\\\\+?xml.*\");\n\n        /**\n         <b>Internal only! </b>Creates a dummy HttpConnection.Response, useful for testing. All actual responses\n         are created from the HttpURLConnection and fields defined.\n         */\n        Response() {\n            super();\n            statusCode = 400;\n            statusMessage = \"Request not made\";\n            req = new Request();\n            contentType = null;\n        }\n\n        static Response execute(HttpConnection.Request req) throws IOException {\n            return execute(req, null);\n        }\n\n        static Response execute(HttpConnection.Request req, @Nullable Response previousResponse) throws IOException {\n            synchronized (req) {\n                Validate.isFalse(req.executing, \"Multiple threads were detected trying to execute the same request concurrently. Make sure to use Connection#newRequest() and do not share an executing request between threads.\");\n                req.executing = true;\n            }\n            Validate.notNullParam(req, \"req\");\n            URL url = req.url();\n            Validate.notNull(url, \"URL must be specified to connect\");\n            String protocol = url.getProtocol();\n            if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                throw new MalformedURLException(\"Only http & https protocols supported\");\n            final boolean methodHasBody = req.method().hasBody();\n            final boolean hasRequestBody = req.requestBody() != null;\n            if (!methodHasBody)\n                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n\n            // set up the request for execution\n            String mimeBoundary = null;\n            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n                serialiseRequestUrl(req);\n            else if (methodHasBody)\n                mimeBoundary = setOutputContentType(req);\n\n            long startTime = System.nanoTime();\n            HttpURLConnection conn = createConnection(req);\n            Response res = null;\n            try {\n                conn.connect();\n                if (conn.getDoOutput()) {\n                    OutputStream out = conn.getOutputStream();\n                    try { writePost(req, out, mimeBoundary); }\n                    catch (IOException e) { conn.disconnect(); throw e; }\n                    finally { out.close(); }\n                }\n\n                int status = conn.getResponseCode();\n                res = new Response(conn, req, previousResponse);\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);\n                        req.removeHeader(CONTENT_TYPE);\n                    }\n\n                    String location = res.header(LOCATION);\n                    Validate.notNull(location);\n                    if (location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                        location = location.substring(6);\n                    URL redir = StringUtil.resolve(req.url(), location);\n                    req.url(redir);\n\n                    req.executing = false;\n                    return execute(req, res);\n                }\n                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n\n                // check that we can handle the returned content type; if not, abort before fetching it\n                String contentType = res.contentType();\n                if (contentType != null\n                        && !req.ignoreContentType()\n                        && !contentType.startsWith(\"text/\")\n                        && !xmlContentTypeRxp.matcher(contentType).matches()\n                        )\n                    throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, */xml, or */*+xml\",\n                            contentType, req.url().toString());\n\n                // switch to the XML parser if content type is xml and not parser not explicitly set\n                if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) {\n                    if (!req.parserDefined) req.parser(Parser.xmlParser());\n                }\n\n                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                    InputStream stream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n                        stream = new GZIPInputStream(stream);\n                    else if (res.hasHeaderWithValue(CONTENT_ENCODING, \"deflate\"))\n                        stream = new InflaterInputStream(stream, new Inflater(true));\n                    \n                    res.bodyStream = ControllableInputStream.wrap(\n                        stream, DefaultBufferSize, req.maxBodySize())\n                        .timeout(startTime, req.timeout());\n\n                    if (req.responseProgress != null) // set response progress listener\n                        res.bodyStream.onProgress(conn.getContentLength(), req.responseProgress, res);\n                } else {\n                    res.byteData = DataUtil.emptyByteBuffer();\n                }\n            } catch (IOException e) {\n                if (res != null) res.safeClose(); // will be non-null if got to conn\n                throw e;\n            } finally {\n                req.executing = false;\n\n                // detach any thread local auth delegate\n                if (req.authenticator != null)\n                    AuthenticationHandler.handler.remove();\n            }\n\n            res.executed = true;\n            return res;\n        }\n\n        @Override\n        public int statusCode() {\n            return statusCode;\n        }\n\n        @Override\n        public String statusMessage() {\n            return statusMessage;\n        }\n\n        @Override\n        public String charset() {\n            return charset;\n        }\n\n        @Override\n        public Response charset(String charset) {\n            this.charset = charset;\n            return this;\n        }\n\n        @Override\n        public String contentType() {\n            return contentType;\n        }\n\n        /** Called from parse() or streamParser(), validates and prepares the input stream, and aligns common settings. */\n        private ControllableInputStream prepareParse() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n            ControllableInputStream stream = bodyStream;\n            if (byteData != null) { // bytes have been read in to the buffer, parse that\n                ByteArrayInputStream bytes = new ByteArrayInputStream(byteData.array(), 0, byteData.limit());\n                stream = ControllableInputStream.wrap(bytes, 0); // no max\n                inputStreamRead = false; // ok to reparse if in bytes\n            }\n            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n            Validate.notNull(stream);\n            inputStreamRead = true;\n            return stream;\n        }\n\n        @Override public Document parse() throws IOException {\n            ControllableInputStream stream = prepareParse();\n            Document doc = DataUtil.parseInputStream(stream, charset, url.toExternalForm(), req.parser());\n            doc.connection(new HttpConnection(req, this)); // because we're static, don't have the connection obj. // todo - maybe hold in the req?\n            charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n            safeClose();\n            return doc;\n        }\n\n        @Override public StreamParser streamParser() throws IOException {\n            ControllableInputStream stream = prepareParse();\n            String baseUri = url.toExternalForm();\n            DataUtil.CharsetDoc charsetDoc = DataUtil.detectCharset(stream, charset, baseUri, req.parser());\n            // note that there may be a document in CharsetDoc as a result of scanning meta-data -- but as requires a stream parse, it is not used here. todo - revisit.\n\n            // set up the stream parser and rig this connection up to the parsed doc:\n            StreamParser streamer = new StreamParser(req.parser());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(stream, charsetDoc.charset));\n            streamer.parse(reader, baseUri); // initializes the parse and the document, but does not step() it\n            streamer.document().connection(new HttpConnection(req, this));\n            charset = charsetDoc.charset.name();\n\n            // we don't safeClose() as in parse(); caller must close streamParser to close InputStream stream\n            return streamer;\n        }\n\n        private void prepareByteData() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n            if (bodyStream != null && byteData == null) {\n                Validate.isFalse(inputStreamRead, \"Request has already been read (with .parse())\");\n                try {\n                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                } finally {\n                    inputStreamRead = true;\n                    safeClose();\n                }\n            }\n        }\n\n        @Override\n        public String body() {\n            prepareByteData();\n            Validate.notNull(byteData);\n            // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n            String body = (charset == null ? UTF_8 : Charset.forName(charset))\n                .decode(byteData).toString();\n            ((Buffer)byteData).rewind(); // cast to avoid covariant return type change in jdk9\n            return body;\n        }\n\n        @Override\n        public byte[] bodyAsBytes() {\n            prepareByteData();\n            Validate.notNull(byteData);\n            Validate.isTrue(byteData.hasArray()); // we made it, so it should\n\n            byte[] array = byteData.array();\n            int offset = byteData.arrayOffset();\n            int length = byteData.limit();\n\n            if (offset == 0 && length == array.length) { // exact, just return it\n                return array;\n            } else { // trim to size\n                byte[] exactArray = new byte[length];\n                System.arraycopy(array, offset, exactArray, 0, length);\n                return exactArray;\n            }\n        }\n\n        @Override\n        public Connection.Response bufferUp() {\n            prepareByteData();\n            return this;\n        }\n\n        @Override\n        public BufferedInputStream bodyStream() {\n            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n\n            // if we have read to bytes (via buffer up), return those as a stream.\n            if (byteData != null) {\n                return new BufferedInputStream(\n                    new ByteArrayInputStream(byteData.array(), 0, byteData.limit()),\n                    DefaultBufferSize);\n            }\n\n            Validate.isFalse(inputStreamRead, \"Request has already been read\");\n            Validate.notNull(bodyStream);\n            inputStreamRead = true;\n            return bodyStream.inputStream();\n        }\n\n        // set up connection defaults, and details from request\n        private static HttpURLConnection createConnection(HttpConnection.Request req) throws IOException {\n            Proxy proxy = req.proxy();\n            final HttpURLConnection conn = (HttpURLConnection) (\n                proxy == null ?\n                req.url().openConnection() :\n                req.url().openConnection(proxy)\n            );\n\n            conn.setRequestMethod(req.method().name());\n            conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n            conn.setConnectTimeout(req.timeout());\n            conn.setReadTimeout(req.timeout() / 2); // gets reduced after connection is made and status is read\n\n            if (req.sslSocketFactory() != null && conn instanceof HttpsURLConnection)\n                ((HttpsURLConnection) conn).setSSLSocketFactory(req.sslSocketFactory());\n            if (req.authenticator != null)\n                AuthenticationHandler.handler.enable(req.authenticator, conn); // removed in finally\n            if (req.method().hasBody())\n                conn.setDoOutput(true);\n            CookieUtil.applyCookiesToRequest(req, conn); // from the Request key/val cookies and the Cookie Store\n            for (Map.Entry<String, List<String>> header : req.multiHeaders().entrySet()) {\n                for (String value : header.getValue()) {\n                    conn.addRequestProperty(header.getKey(), value);\n                }\n            }\n            return conn;\n        }\n\n        /**\n         * Call on completion of stream read, to close the body (or error) stream. The connection.disconnect allows\n         * keep-alives to work (as the underlying connection is actually held open, despite the name).\n         */\n        private void safeClose() {\n            if (bodyStream != null) {\n                try {\n                    bodyStream.close();\n                } catch (IOException e) {\n                    // no-op\n                } finally {\n                    bodyStream = null;\n                }\n            }\n            if (conn != null) {\n                conn.disconnect();\n                conn = null;\n            }\n        }\n\n        // set up url, method, header, cookies\n        private Response(HttpURLConnection conn, HttpConnection.Request request, HttpConnection.@Nullable Response previousResponse) throws IOException {\n            this.conn = conn;\n            this.req = request;\n            method = Method.valueOf(conn.getRequestMethod());\n            url = conn.getURL();\n            statusCode = conn.getResponseCode();\n            statusMessage = conn.getResponseMessage();\n            contentType = conn.getContentType();\n\n            Map<String, List<String>> resHeaders = createHeaderMap(conn);\n            processResponseHeaders(resHeaders); // includes cookie key/val read during header scan\n            CookieUtil.storeCookies(req, this, url, resHeaders); // add set cookies to cookie store\n\n            if (previousResponse != null) { // was redirected\n                previousResponse.safeClose();\n\n                // enforce too many redirects:\n                numRedirects = previousResponse.numRedirects + 1;\n                if (numRedirects >= MAX_REDIRECTS)\n                    throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n            }\n        }\n\n        private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {\n            // the default sun impl of conn.getHeaderFields() returns header values out of order\n            final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();\n            int i = 0;\n            while (true) {\n                final String key = conn.getHeaderFieldKey(i);\n                final String val = conn.getHeaderField(i);\n                if (key == null && val == null)\n                    break;\n                i++;\n                if (key == null || val == null)\n                    continue; // skip http1.1 line\n\n                final List<String> vals = headers.computeIfAbsent(key, Functions.listFunction());\n                vals.add(val);\n            }\n            return headers;\n        }\n\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                for (String value : values) {\n                    addHeader(name, fixHeaderEncoding(value));\n                }\n            }\n        }\n\n        /**\n         Servers may encode response headers in UTF-8 instead of RFC defined 8859. This method attempts to detect that\n         and re-decode the string as UTF-8.\n         * @param val a header value string that may have been incorrectly decoded as 8859.\n         * @return a potentially re-decoded string.\n         */\n        @Nullable\n        private static String fixHeaderEncoding(@Nullable String val) {\n            if (val == null) return val;\n            byte[] bytes = val.getBytes(ISO_8859_1);\n            if (looksLikeUtf8(bytes))\n                return new String(bytes, UTF_8);\n            else\n                return val;\n        }\n\n        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            if (input.length >= 3\n                && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB\n                && (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int end;\n            boolean foundNonAscii = false;\n            for (int j = input.length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    continue; // ASCII\n                }\n                foundNonAscii = true;\n\n                // UTF-8 leading:\n                if ((o & 0xE0) == 0xC0) {\n                    end = i + 1;\n                } else if ((o & 0xF0) == 0xE0) {\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) {\n                    end = i + 3;\n                } else {\n                    return false;\n                }\n\n                if (end >= input.length)\n                    return false;\n\n                while (i < end) {\n                    i++;\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n            }\n            return foundNonAscii;\n        }\n\n        private @Nullable static String setOutputContentType(final Connection.Request req) {\n            final String contentType = req.header(CONTENT_TYPE);\n            String bound = null;\n            if (contentType != null) {\n                // no-op; don't add content type as already set (e.g. for requestBody())\n                // todo - if content type already set, we could add charset\n\n                // if user has set content type to multipart/form-data, auto add boundary.\n                if(contentType.contains(MULTIPART_FORM_DATA) && !contentType.contains(\"boundary\")) {\n                    bound = DataUtil.mimeBoundary();\n                    req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n                }\n\n            }\n            else if (needsMultipart(req)) {\n                bound = DataUtil.mimeBoundary();\n                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n            } else {\n                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n            }\n            return bound;\n        }\n\n        private static void writePost(final Connection.Request req, final OutputStream outputStream, @Nullable final String boundary) throws IOException {\n            final Collection<Connection.KeyVal> data = req.data();\n            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, Charset.forName(req.postDataCharset())));\n\n            if (boundary != null) {\n                // boundary will be set if we're in multipart mode\n                for (Connection.KeyVal keyVal : data) {\n                    w.write(\"--\");\n                    w.write(boundary);\n                    w.write(\"\\r\\n\");\n                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n                    w.write(\"\\\"\");\n                    final InputStream input = keyVal.inputStream();\n                    if (input != null) {\n                        w.write(\"; filename=\\\"\");\n                        w.write(encodeMimeName(keyVal.value()));\n                        w.write(\"\\\"\\r\\nContent-Type: \");\n                        String contentType = keyVal.contentType();\n                        w.write(contentType != null ? contentType : DefaultUploadType);\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.flush(); // flush\n                        DataUtil.crossStreams(input, outputStream);\n                        outputStream.flush();\n                    } else {\n                        w.write(\"\\r\\n\\r\\n\");\n                        w.write(keyVal.value());\n                    }\n                    w.write(\"\\r\\n\");\n                }\n                w.write(\"--\");\n                w.write(boundary);\n                w.write(\"--\");\n            } else {\n                String body = req.requestBody();\n                if (body != null) {\n                    // data will be in query string, we're sending a plaintext body\n                    w.write(body);\n                }\n                else {\n                    // regular form data (application/x-www-form-urlencoded)\n                    boolean first = true;\n                    for (Connection.KeyVal keyVal : data) {\n                        if (!first)\n                            w.append('&');\n                        else\n                            first = false;\n\n                        w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                        w.write('=');\n                        w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                    }\n                }\n            }\n            w.close();\n        }\n\n        // for get url reqs, serialise the data map into the url\n        private static void serialiseRequestUrl(Connection.Request req) throws IOException {\n            UrlBuilder in = new UrlBuilder(req.url());\n\n            for (Connection.KeyVal keyVal : req.data()) {\n                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                in.appendKeyVal(keyVal);\n            }\n            req.url(in.build());\n            req.data().clear(); // moved into url as get params\n        }\n    }\n\n    private static boolean needsMultipart(Connection.Request req) {\n        // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n        for (Connection.KeyVal keyVal : req.data()) {\n            if (keyVal.hasInputStream())\n                return true;\n        }\n        return false;\n    }\n\n    public static class KeyVal implements Connection.KeyVal {\n        private String key;\n        private String value;\n        private @Nullable InputStream stream;\n        private @Nullable String contentType;\n\n        public static KeyVal create(String key, String value) {\n            return new KeyVal(key, value);\n        }\n\n        public static KeyVal create(String key, String filename, InputStream stream) {\n            return new KeyVal(key, filename)\n                .inputStream(stream);\n        }\n\n        private KeyVal(String key, String value) {\n            Validate.notEmptyParam(key, \"key\");\n            Validate.notNullParam(value, \"value\");\n            this.key = key;\n            this.value = value;\n        }\n\n        @Override\n        public KeyVal key(String key) {\n            Validate.notEmptyParam(key, \"key\");\n            this.key = key;\n            return this;\n        }\n\n        @Override\n        public String key() {\n            return key;\n        }\n\n        @Override\n        public KeyVal value(String value) {\n            Validate.notNullParam(value, \"value\");\n            this.value = value;\n            return this;\n        }\n\n        @Override\n        public String value() {\n            return value;\n        }\n\n        public KeyVal inputStream(InputStream inputStream) {\n            Validate.notNullParam(value, \"inputStream\");\n            this.stream = inputStream;\n            return this;\n        }\n\n        @Override\n        public InputStream inputStream() {\n            return stream;\n        }\n\n        @Override\n        public boolean hasInputStream() {\n            return stream != null;\n        }\n\n        @Override\n        public Connection.KeyVal contentType(String contentType) {\n            Validate.notEmpty(contentType);\n            this.contentType = contentType;\n            return this;\n        }\n\n        @Override\n        public String contentType() {\n            return contentType;\n        }\n\n        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n}", "super_interfaces": ["Connection"], "fields": [{"attribute_expression": "public static final String CONTENT_ENCODING = \"Content-Encoding\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "CONTENT_ENCODING = \"Content-Encoding\"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_UA =\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36\";", "docstring": "\nMany users would get caught by not setting a user-agent and therefore getting different responses on their desktop\nvs in jsoup, which would otherwise default to {@code Java}. So by default, use a desktop UA.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_UA =\n        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36\"", "syntax_pass": true}, {"attribute_expression": "private static final String USER_AGENT = \"User-Agent\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "USER_AGENT = \"User-Agent\"", "syntax_pass": true}, {"attribute_expression": "public static final String CONTENT_TYPE = \"Content-Type\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "CONTENT_TYPE = \"Content-Type\"", "syntax_pass": true}, {"attribute_expression": "public static final String MULTIPART_FORM_DATA = \"multipart/form-data\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "MULTIPART_FORM_DATA = \"multipart/form-data\"", "syntax_pass": true}, {"attribute_expression": "public static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "FORM_URL_ENCODED = \"application/x-www-form-urlencoded\"", "syntax_pass": true}, {"attribute_expression": "private static final int HTTP_TEMP_REDIR = 307;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "HTTP_TEMP_REDIR = 307", "syntax_pass": true}, {"attribute_expression": "private static final String DefaultUploadType = \"application/octet-stream\";", "docstring": " http/1.1 temporary redirect, not in Java's set.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "DefaultUploadType = \"application/octet-stream\"", "syntax_pass": true}, {"attribute_expression": "private static final Charset ISO_8859_1 = Charset.forName(\"ISO-8859-1\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Charset", "name": "ISO_8859_1 = Charset.forName(\"ISO-8859-1\")", "syntax_pass": true}, {"attribute_expression": "private HttpConnection.Request req;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HttpConnection.Request", "name": "req", "syntax_pass": true}, {"attribute_expression": "private Connection.@Nullable Response res;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Connection.@Nullable Response", "name": "res", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor", "name": "NodeTraversor", "file_path": "src/main/java/org/jsoup/select/NodeTraversor.java", "superclasses": "", "methods": ["[void]traverse(NodeVisitor,Node)", "[void]traverse(NodeVisitor,Elements)", "[FilterResult]filter(NodeFilter,Node)", "[void]filter(NodeFilter,Elements)"], "method_uris": ["src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor.[void]traverse(NodeVisitor,Node)", "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor.[void]traverse(NodeVisitor,Elements)", "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor.[FilterResult]filter(NodeFilter,Node)", "src/main/java/org/jsoup/select/NodeTraversor.java.NodeTraversor.[void]filter(NodeFilter,Elements)"], "overrides": null, "attributes": [], "class_docstring": "\nA depth-first node traversor. Use to walk through all nodes under and including the specified root node, in document\norder. The {@link NodeVisitor#head(Node, int)} and {@link NodeVisitor#tail(Node, int)} methods will be called for\neach node.\n<p> During traversal, structural changes to nodes are supported (e.g. {{@link Node#replaceWith(Node)},\n{@link Node#remove()}}\n</p>\n", "original_string": "public class NodeTraversor {\n    /**\n     Run a depth-first traverse of the root and all of its descendants.\n     @param visitor Node visitor.\n     @param root the initial node point to traverse.\n     @see NodeVisitor\n     */\n    public static void traverse(NodeVisitor visitor, Node root) {\n        Validate.notNull(visitor);\n        Validate.notNull(root);\n        Node node = root;\n        int depth = 0;\n        \n        while (node != null) {\n            Node parent = node.parentNode(); // remember parent to find nodes that get replaced in .head\n            int origSize = parent != null ? parent.childNodeSize() : 0;\n            Node next = node.nextSibling();\n\n            visitor.head(node, depth); // visit current node\n            if (parent != null && !node.hasParent()) { // removed or replaced\n                if (origSize == parent.childNodeSize()) { // replaced\n                    node = parent.childNode(node.siblingIndex()); // replace ditches parent but keeps sibling index\n                } else { // removed\n                    node = next;\n                    if (node == null) { // last one, go up\n                        node = parent;\n                        depth--;\n                    }\n                    continue; // don't tail removed\n                }\n            }\n\n            if (node.childNodeSize() > 0) { // descend\n                node = node.childNode(0);\n                depth++;\n            } else {\n                while (true) {\n                    assert node != null; // as depth > 0, will have parent\n                    if (!(node.nextSibling() == null && depth > 0)) break;\n                    visitor.tail(node, depth); // when no more siblings, ascend\n                    node = node.parentNode();\n                    depth--;\n                }\n                visitor.tail(node, depth);\n                if (node == root)\n                    break;\n                node = node.nextSibling();\n            }\n        }\n    }\n\n    /**\n     Run a depth-first traversal of each Element.\n     @param visitor Node visitor.\n     @param elements Elements to traverse.\n     */\n    public static void traverse(NodeVisitor visitor, Elements elements) {\n        Validate.notNull(visitor);\n        Validate.notNull(elements);\n        for (Element el : elements)\n            traverse(visitor, el);\n    }\n\n    /**\n     Run a depth-first filtered traversal of the root and all of its descendants.\n     @param filter NodeFilter visitor.\n     @param root the root node point to traverse.\n     @return The filter result of the root node, or {@link FilterResult#STOP}.\n\n     @see NodeFilter\n     */\n    public static FilterResult filter(NodeFilter filter, Node root) {\n        Node node = root;\n        int depth = 0;\n\n        while (node != null) {\n            FilterResult result = filter.head(node, depth);\n            if (result == FilterResult.STOP)\n                return result;\n            // Descend into child nodes:\n            if (result == FilterResult.CONTINUE && node.childNodeSize() > 0) {\n                node = node.childNode(0);\n                ++depth;\n                continue;\n            }\n            // No siblings, move upwards:\n            while (true) {\n                assert node != null; // depth > 0, so has parent\n                if (!(node.nextSibling() == null && depth > 0)) break;\n                // 'tail' current node:\n                if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {\n                    result = filter.tail(node, depth);\n                    if (result == FilterResult.STOP)\n                        return result;\n                }\n                Node prev = node; // In case we need to remove it below.\n                node = node.parentNode();\n                depth--;\n                if (result == FilterResult.REMOVE)\n                    prev.remove(); // Remove AFTER finding parent.\n                result = FilterResult.CONTINUE; // Parent was not pruned.\n            }\n            // 'tail' current node, then proceed with siblings:\n            if (result == FilterResult.CONTINUE || result == FilterResult.SKIP_CHILDREN) {\n                result = filter.tail(node, depth);\n                if (result == FilterResult.STOP)\n                    return result;\n            }\n            if (node == root)\n                return result;\n            Node prev = node; // In case we need to remove it below.\n            node = node.nextSibling();\n            if (result == FilterResult.REMOVE)\n                prev.remove(); // Remove AFTER finding sibling.\n        }\n        // root == null?\n        return FilterResult.CONTINUE;\n    }\n\n    /**\n     Run a depth-first filtered traversal of each Element.\n     @param filter NodeFilter visitor.\n     @see NodeFilter\n     */\n    public static void filter(NodeFilter filter, Elements elements) {\n        Validate.notNull(filter);\n        Validate.notNull(elements);\n        for (Element el : elements)\n            if (filter(filter, el) == FilterResult.STOP)\n                break;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/select/Elements.java.Elements", "name": "Elements", "file_path": "src/main/java/org/jsoup/select/Elements.java", "superclasses": "", "methods": ["[]Elements()", "[]Elements(int)", "[]Elements(Collection<Element>)", "[]Elements(List<Element>)", "[]Elements()", "[Elements]clone()", "[String]attr(String)", "[boolean]hasAttr(String)", "[List<String>]eachAttr(String)", "[Elements]attr(String,String)", "[Elements]removeAttr(String)", "[Elements]addClass(String)", "[Elements]removeClass(String)", "[Elements]toggleClass(String)", "[boolean]hasClass(String)", "[String]val()", "[Elements]val(String)", "[String]text()", "[boolean]hasText()", "[List<String>]eachText()", "[String]html()", "[String]outerHtml()", "[String]toString()", "[Elements]tagName(String)", "[Elements]html(String)", "[Elements]prepend(String)", "[Elements]append(String)", "[Elements]before(String)", "[Elements]after(String)", "[Elements]wrap(String)", "[Elements]unwrap()", "[Elements]empty()", "[Elements]remove()", "[Elements]select(String)", "[Elements]not(String)", "[Elements]eq(int)", "[boolean]is(String)", "[Elements]next()", "[Elements]next(String)", "[Elements]nextAll()", "[Elements]nextAll(String)", "[Elements]prev()", "[Elements]prev(String)", "[Elements]prevAll()", "[Elements]prevAll(String)", "[Elements]siblings(String,boolean,boolean)", "[Elements]parents()", "[Element]first()", "[Element]last()", "[Elements]traverse(NodeVisitor)", "[Elements]filter(NodeFilter)", "[List<FormElement>]forms()", "[List<Comment>]comments()", "[List<TextNode>]textNodes()", "[List<DataNode>]dataNodes()", "[List<T>]childNodesOfType(Class<T>)", "[Element]set(int,Element)", "[Element]remove(int)", "[boolean]remove(Object)", "[void]clear()", "[boolean]removeAll(Collection<?>)", "[boolean]retainAll(Collection<?>)", "[boolean]removeIf(Predicate<? super Element>)", "[void]replaceAll(UnaryOperator<Element>)"], "method_uris": ["src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements()", "src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements(int)", "src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements(Collection<Element>)", "src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements(List<Element>)", "src/main/java/org/jsoup/select/Elements.java.Elements.[]Elements()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]clone()", "src/main/java/org/jsoup/select/Elements.java.Elements.[String]attr(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]hasAttr(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[List<String>]eachAttr(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]attr(String,String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]removeAttr(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]addClass(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]removeClass(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]toggleClass(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]hasClass(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[String]val()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]val(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[String]text()", "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]hasText()", "src/main/java/org/jsoup/select/Elements.java.Elements.[List<String>]eachText()", "src/main/java/org/jsoup/select/Elements.java.Elements.[String]html()", "src/main/java/org/jsoup/select/Elements.java.Elements.[String]outerHtml()", "src/main/java/org/jsoup/select/Elements.java.Elements.[String]toString()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]tagName(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]html(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prepend(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]append(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]before(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]after(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]wrap(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]unwrap()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]empty()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]remove()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]select(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]not(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]eq(int)", "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]is(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]next()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]next(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]nextAll()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]nextAll(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prev()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prev(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prevAll()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]prevAll(String)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]siblings(String,boolean,boolean)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]parents()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Element]first()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Element]last()", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]traverse(NodeVisitor)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Elements]filter(NodeFilter)", "src/main/java/org/jsoup/select/Elements.java.Elements.[List<FormElement>]forms()", "src/main/java/org/jsoup/select/Elements.java.Elements.[List<Comment>]comments()", "src/main/java/org/jsoup/select/Elements.java.Elements.[List<TextNode>]textNodes()", "src/main/java/org/jsoup/select/Elements.java.Elements.[List<DataNode>]dataNodes()", "src/main/java/org/jsoup/select/Elements.java.Elements.[List<T>]childNodesOfType(Class<T>)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Element]set(int,Element)", "src/main/java/org/jsoup/select/Elements.java.Elements.[Element]remove(int)", "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]remove(Object)", "src/main/java/org/jsoup/select/Elements.java.Elements.[void]clear()", "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]removeAll(Collection<?>)", "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]retainAll(Collection<?>)", "src/main/java/org/jsoup/select/Elements.java.Elements.[boolean]removeIf(Predicate<? super Element>)", "src/main/java/org/jsoup/select/Elements.java.Elements.[void]replaceAll(UnaryOperator<Element>)"], "overrides": null, "attributes": [], "class_docstring": "\nA list of {@link Element}s, with methods that act on every element in the list.\n<p>To get an {@code Elements} object, use the {@link Element#select(String)} method.</p>\n<p>Methods that {@link #set(int, Element) set}, {@link #remove(int) remove}, or {@link #replaceAll(UnaryOperator)\nreplace} Elements in the list will also act on the underlying {@link org.jsoup.nodes.Document DOM}.</p>\n\n@author Jonathan Hedley, jonathan@hedley.net", "original_string": "public class Elements extends ArrayList<Element> {\n    public Elements() {\n    }\n\n    public Elements(int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    public Elements(Collection<Element> elements) {\n        super(elements);\n    }\n    \n    public Elements(List<Element> elements) {\n        super(elements);\n    }\n    \n    public Elements(Element... elements) {\n    \tsuper(Arrays.asList(elements));\n    }\n\n    /**\n     * Creates a deep copy of these elements.\n     * @return a deep copy\n     */\n    @Override\n\tpublic Elements clone() {\n        Elements clone = new Elements(size());\n\n        for(Element e : this)\n    \t\tclone.add(e.clone());\n    \t\n    \treturn clone;\n\t}\n\n\t// attribute methods\n    /**\n     Get an attribute value from the first matched element that has the attribute.\n     @param attributeKey The attribute key.\n     @return The attribute value from the first matched element that has the attribute. If no elements were matched (isEmpty() == true),\n     or if the no elements have the attribute, returns empty string.\n     @see #hasAttr(String)\n     */\n    public String attr(String attributeKey) {\n        for (Element element : this) {\n            if (element.hasAttr(attributeKey))\n                return element.attr(attributeKey);\n        }\n        return \"\";\n    }\n\n    /**\n     Checks if any of the matched elements have this attribute defined.\n     @param attributeKey attribute key\n     @return true if any of the elements have the attribute; false if none do.\n     */\n    public boolean hasAttr(String attributeKey) {\n        for (Element element : this) {\n            if (element.hasAttr(attributeKey))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Get the attribute value for each of the matched elements. If an element does not have this attribute, no value is\n     * included in the result set for that element.\n     * @param attributeKey the attribute name to return values for. You can add the {@code abs:} prefix to the key to\n     * get absolute URLs from relative URLs, e.g.: {@code doc.select(\"a\").eachAttr(\"abs:href\")} .\n     * @return a list of each element's attribute value for the attribute\n     */\n    public List<String> eachAttr(String attributeKey) {\n        List<String> attrs = new ArrayList<>(size());\n        for (Element element : this) {\n            if (element.hasAttr(attributeKey))\n                attrs.add(element.attr(attributeKey));\n        }\n        return attrs;\n    }\n\n    /**\n     * Set an attribute on all matched elements.\n     * @param attributeKey attribute key\n     * @param attributeValue attribute value\n     * @return this\n     */\n    public Elements attr(String attributeKey, String attributeValue) {\n        for (Element element : this) {\n            element.attr(attributeKey, attributeValue);\n        }\n        return this;\n    }\n\n    /**\n     * Remove an attribute from every matched element.\n     * @param attributeKey The attribute to remove.\n     * @return this (for chaining)\n     */\n    public Elements removeAttr(String attributeKey) {\n        for (Element element : this) {\n            element.removeAttr(attributeKey);\n        }\n        return this;\n    }\n\n    /**\n     Add the class name to every matched element's {@code class} attribute.\n     @param className class name to add\n     @return this\n     */\n    public Elements addClass(String className) {\n        for (Element element : this) {\n            element.addClass(className);\n        }\n        return this;\n    }\n\n    /**\n     Remove the class name from every matched element's {@code class} attribute, if present.\n     @param className class name to remove\n     @return this\n     */\n    public Elements removeClass(String className) {\n        for (Element element : this) {\n            element.removeClass(className);\n        }\n        return this;\n    }\n\n    /**\n     Toggle the class name on every matched element's {@code class} attribute.\n     @param className class name to add if missing, or remove if present, from every element.\n     @return this\n     */\n    public Elements toggleClass(String className) {\n        for (Element element : this) {\n            element.toggleClass(className);\n        }\n        return this;\n    }\n\n    /**\n     Determine if any of the matched elements have this class name set in their {@code class} attribute.\n     @param className class name to check for\n     @return true if any do, false if none do\n     */\n    public boolean hasClass(String className) {\n        for (Element element : this) {\n            if (element.hasClass(className))\n                return true;\n        }\n        return false;\n    }\n    \n    /**\n     * Get the form element's value of the first matched element.\n     * @return The form element's value, or empty if not set.\n     * @see Element#val()\n     */\n    public String val() {\n        if (size() > 0)\n            //noinspection ConstantConditions\n            return first().val(); // first() != null as size() > 0\n        else\n            return \"\";\n    }\n    \n    /**\n     * Set the form element's value in each of the matched elements.\n     * @param value The value to set into each matched element\n     * @return this (for chaining)\n     */\n    public Elements val(String value) {\n        for (Element element : this)\n            element.val(value);\n        return this;\n    }\n    \n    /**\n     * Get the combined text of all the matched elements.\n     * <p>\n     * Note that it is possible to get repeats if the matched elements contain both parent elements and their own\n     * children, as the Element.text() method returns the combined text of a parent and all its children.\n     * @return string of all text: unescaped and no HTML.\n     * @see Element#text()\n     * @see #eachText()\n     */\n    public String text() {\n        return stream()\n            .map(Element::text)\n            .collect(StringUtil.joining(\" \"));\n    }\n\n    /**\n     Test if any matched Element has any text content, that is not just whitespace.\n     @return true if any element has non-blank text content.\n     @see Element#hasText()\n     */\n    public boolean hasText() {\n        for (Element element: this) {\n            if (element.hasText())\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Get the text content of each of the matched elements. If an element has no text, then it is not included in the\n     * result.\n     * @return A list of each matched element's text content.\n     * @see Element#text()\n     * @see Element#hasText()\n     * @see #text()\n     */\n    public List<String> eachText() {\n        ArrayList<String> texts = new ArrayList<>(size());\n        for (Element el: this) {\n            if (el.hasText())\n                texts.add(el.text());\n        }\n        return texts;\n    }\n    \n    /**\n     * Get the combined inner HTML of all matched elements.\n     * @return string of all element's inner HTML.\n     * @see #text()\n     * @see #outerHtml()\n     */\n    public String html() {\n        return stream()\n            .map(Element::html)\n            .collect(StringUtil.joining(\"\\n\"));\n    }\n    \n    /**\n     * Get the combined outer HTML of all matched elements.\n     * @return string of all element's outer HTML.\n     * @see #text()\n     * @see #html()\n     */\n    public String outerHtml() {\n        return stream()\n            .map(Element::outerHtml)\n            .collect(StringUtil.joining(\"\\n\"));\n    }\n\n    /**\n     * Get the combined outer HTML of all matched elements. Alias of {@link #outerHtml()}.\n     * @return string of all element's outer HTML.\n     * @see #text()\n     * @see #html()\n     */\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    /**\n     * Update (rename) the tag name of each matched element. For example, to change each {@code <i>} to a {@code <em>}, do\n     * {@code doc.select(\"i\").tagName(\"em\");}\n     *\n     * @param tagName the new tag name\n     * @return this, for chaining\n     * @see Element#tagName(String)\n     */\n    public Elements tagName(String tagName) {\n        for (Element element : this) {\n            element.tagName(tagName);\n        }\n        return this;\n    }\n    \n    /**\n     * Set the inner HTML of each matched element.\n     * @param html HTML to parse and set into each matched element.\n     * @return this, for chaining\n     * @see Element#html(String)\n     */\n    public Elements html(String html) {\n        for (Element element : this) {\n            element.html(html);\n        }\n        return this;\n    }\n    \n    /**\n     * Add the supplied HTML to the start of each matched element's inner HTML.\n     * @param html HTML to add inside each element, before the existing HTML\n     * @return this, for chaining\n     * @see Element#prepend(String)\n     */\n    public Elements prepend(String html) {\n        for (Element element : this) {\n            element.prepend(html);\n        }\n        return this;\n    }\n    \n    /**\n     * Add the supplied HTML to the end of each matched element's inner HTML.\n     * @param html HTML to add inside each element, after the existing HTML\n     * @return this, for chaining\n     * @see Element#append(String)\n     */\n    public Elements append(String html) {\n        for (Element element : this) {\n            element.append(html);\n        }\n        return this;\n    }\n    \n    /**\n     * Insert the supplied HTML before each matched element's outer HTML.\n     * @param html HTML to insert before each element\n     * @return this, for chaining\n     * @see Element#before(String)\n     */\n    public Elements before(String html) {\n        for (Element element : this) {\n            element.before(html);\n        }\n        return this;\n    }\n    \n    /**\n     * Insert the supplied HTML after each matched element's outer HTML.\n     * @param html HTML to insert after each element\n     * @return this, for chaining\n     * @see Element#after(String)\n     */\n    public Elements after(String html) {\n        for (Element element : this) {\n            element.after(html);\n        }\n        return this;\n    }\n\n    /**\n     Wrap the supplied HTML around each matched elements. For example, with HTML\n     {@code <p><b>This</b> is <b>Jsoup</b></p>},\n     <code>doc.select(\"b\").wrap(\"&lt;i&gt;&lt;/i&gt;\");</code>\n     becomes {@code <p><i><b>This</b></i> is <i><b>jsoup</b></i></p>}\n     @param html HTML to wrap around each element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     @return this (for chaining)\n     @see Element#wrap\n     */\n    public Elements wrap(String html) {\n        Validate.notEmpty(html);\n        for (Element element : this) {\n            element.wrap(html);\n        }\n        return this;\n    }\n\n    /**\n     * Removes the matched elements from the DOM, and moves their children up into their parents. This has the effect of\n     * dropping the elements but keeping their children.\n     * <p>\n     * This is useful for e.g removing unwanted formatting elements but keeping their contents.\n     * </p>\n     * \n     * E.g. with HTML: <p>{@code <div><font>One</font> <font><a href=\"/\">Two</a></font></div>}</p>\n     * <p>{@code doc.select(\"font\").unwrap();}</p>\n     * <p>HTML = {@code <div>One <a href=\"/\">Two</a></div>}</p>\n     *\n     * @return this (for chaining)\n     * @see Node#unwrap\n     */\n    public Elements unwrap() {\n        for (Element element : this) {\n            element.unwrap();\n        }\n        return this;\n    }\n\n    /**\n     * Empty (remove all child nodes from) each matched element. This is similar to setting the inner HTML of each\n     * element to nothing.\n     * <p>\n     * E.g. HTML: {@code <div><p>Hello <b>there</b></p> <p>now</p></div>}<br>\n     * <code>doc.select(\"p\").empty();</code><br>\n     * HTML = {@code <div><p></p> <p></p></div>}\n     * @return this, for chaining\n     * @see Element#empty()\n     * @see #remove()\n     */\n    public Elements empty() {\n        for (Element element : this) {\n            element.empty();\n        }\n        return this;\n    }\n\n    /**\n     * Remove each matched element from the DOM. This is similar to setting the outer HTML of each element to nothing.\n     * <p>The elements will still be retained in this list, in case further processing of them is desired.</p>\n     * <p>\n     * E.g. HTML: {@code <div><p>Hello</p> <p>there</p> <img /></div>}<br>\n     * <code>doc.select(\"p\").remove();</code><br>\n     * HTML = {@code <div> <img /></div>}\n     * <p>\n     * Note that this method should not be used to clean user-submitted HTML; rather, use {@link org.jsoup.safety.Cleaner} to clean HTML.\n     * @return this, for chaining\n     * @see Element#empty()\n     * @see #empty()\n     * @see #clear()\n     */\n    public Elements remove() {\n        for (Element element : this) {\n            element.remove();\n        }\n        return this;\n    }\n    \n    // filters\n    \n    /**\n     * Find matching elements within this element list.\n     * @param query A {@link Selector} query\n     * @return the filtered list of elements, or an empty list if none match.\n     */\n    public Elements select(String query) {\n        return Selector.select(query, this);\n    }\n\n    /**\n     * Remove elements from this list that match the {@link Selector} query.\n     * <p>\n     * E.g. HTML: {@code <div class=logo>One</div> <div>Two</div>}<br>\n     * <code>Elements divs = doc.select(\"div\").not(\".logo\");</code><br>\n     * Result: {@code divs: [<div>Two</div>]}\n     * <p>\n     * @param query the selector query whose results should be removed from these elements\n     * @return a new elements list that contains only the filtered results\n     */\n    public Elements not(String query) {\n        Elements out = Selector.select(query, this);\n        return Selector.filterOut(this, out);\n    }\n    \n    /**\n     * Get the <i>nth</i> matched element as an Elements object.\n     * <p>\n     * See also {@link #get(int)} to retrieve an Element.\n     * @param index the (zero-based) index of the element in the list to retain\n     * @return Elements containing only the specified element, or, if that element did not exist, an empty list.\n     */\n    public Elements eq(int index) {\n        return size() > index ? new Elements(get(index)) : new Elements();\n    }\n    \n    /**\n     * Test if any of the matched elements match the supplied query.\n     * @param query A selector\n     * @return true if at least one element in the list matches the query.\n     */\n    public boolean is(String query) {\n        Evaluator eval = QueryParser.parse(query);\n        for (Element e : this) {\n            if (e.is(eval))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Get the immediate next element sibling of each element in this list.\n     * @return next element siblings.\n     */\n    public Elements next() {\n        return siblings(null, true, false);\n    }\n\n    /**\n     * Get the immediate next element sibling of each element in this list, filtered by the query.\n     * @param query CSS query to match siblings against\n     * @return next element siblings.\n     */\n    public Elements next(String query) {\n        return siblings(query, true, false);\n    }\n\n    /**\n     * Get each of the following element siblings of each element in this list.\n     * @return all following element siblings.\n     */\n    public Elements nextAll() {\n        return siblings(null, true, true);\n    }\n\n    /**\n     * Get each of the following element siblings of each element in this list, that match the query.\n     * @param query CSS query to match siblings against\n     * @return all following element siblings.\n     */\n    public Elements nextAll(String query) {\n        return siblings(query, true, true);\n    }\n\n    /**\n     * Get the immediate previous element sibling of each element in this list.\n     * @return previous element siblings.\n     */\n    public Elements prev() {\n        return siblings(null, false, false);\n    }\n\n    /**\n     * Get the immediate previous element sibling of each element in this list, filtered by the query.\n     * @param query CSS query to match siblings against\n     * @return previous element siblings.\n     */\n    public Elements prev(String query) {\n        return siblings(query, false, false);\n    }\n\n    /**\n     * Get each of the previous element siblings of each element in this list.\n     * @return all previous element siblings.\n     */\n    public Elements prevAll() {\n        return siblings(null, false, true);\n    }\n\n    /**\n     * Get each of the previous element siblings of each element in this list, that match the query.\n     * @param query CSS query to match siblings against\n     * @return all previous element siblings.\n     */\n    public Elements prevAll(String query) {\n        return siblings(query, false, true);\n    }\n\n    private Elements siblings(@Nullable String query, boolean next, boolean all) {\n        Elements els = new Elements();\n        Evaluator eval = query != null? QueryParser.parse(query) : null;\n        for (Element e : this) {\n            do {\n                Element sib = next ? e.nextElementSibling() : e.previousElementSibling();\n                if (sib == null) break;\n                if (eval == null)\n                    els.add(sib);\n                else if (sib.is(eval))\n                    els.add(sib);\n                e = sib;\n            } while (all);\n        }\n        return els;\n    }\n\n    /**\n     * Get all of the parents and ancestor elements of the matched elements.\n     * @return all of the parents and ancestor elements of the matched elements\n     */\n    public Elements parents() {\n        HashSet<Element> combo = new LinkedHashSet<>();\n        for (Element e: this) {\n            combo.addAll(e.parents());\n        }\n        return new Elements(combo);\n    }\n\n    // list-like methods\n    /**\n     Get the first matched element.\n     @return The first matched element, or <code>null</code> if contents is empty.\n     */\n    public @Nullable Element first() {\n        return isEmpty() ? null : get(0);\n    }\n\n    /**\n     Get the last matched element.\n     @return The last matched element, or <code>null</code> if contents is empty.\n     */\n    public @Nullable Element last() {\n        return isEmpty() ? null : get(size() - 1);\n    }\n\n    /**\n     * Perform a depth-first traversal on each of the selected elements.\n     * @param nodeVisitor the visitor callbacks to perform on each node\n     * @return this, for chaining\n     */\n    public Elements traverse(NodeVisitor nodeVisitor) {\n        NodeTraversor.traverse(nodeVisitor, this);\n        return this;\n    }\n\n    /**\n     * Perform a depth-first filtering on each of the selected elements.\n     * @param nodeFilter the filter callbacks to perform on each node\n     * @return this, for chaining\n     */\n    public Elements filter(NodeFilter nodeFilter) {\n        NodeTraversor.filter(nodeFilter, this);\n        return this;\n    }\n\n    /**\n     * Get the {@link FormElement} forms from the selected elements, if any.\n     * @return a list of {@link FormElement}s pulled from the matched elements. The list will be empty if the elements contain\n     * no forms.\n     */\n    public List<FormElement> forms() {\n        ArrayList<FormElement> forms = new ArrayList<>();\n        for (Element el: this)\n            if (el instanceof FormElement)\n                forms.add((FormElement) el);\n        return forms;\n    }\n\n    /**\n     * Get {@link Comment} nodes that are direct child nodes of the selected elements.\n     * @return Comment nodes, or an empty list if none.\n     */\n    public List<Comment> comments() {\n        return childNodesOfType(Comment.class);\n    }\n\n    /**\n     * Get {@link TextNode} nodes that are direct child nodes of the selected elements.\n     * @return TextNode nodes, or an empty list if none.\n     */\n    public List<TextNode> textNodes() {\n        return childNodesOfType(TextNode.class);\n    }\n\n    /**\n     * Get {@link DataNode} nodes that are direct child nodes of the selected elements. DataNode nodes contain the\n     * content of tags such as {@code script}, {@code style} etc and are distinct from {@link TextNode}s.\n     * @return Comment nodes, or an empty list if none.\n     */\n    public List<DataNode> dataNodes() {\n        return childNodesOfType(DataNode.class);\n    }\n\n    private <T extends Node> List<T> childNodesOfType(Class<T> tClass) {\n        ArrayList<T> nodes = new ArrayList<>();\n        for (Element el: this) {\n            for (int i = 0; i < el.childNodeSize(); i++) {\n                Node node = el.childNode(i);\n                if (tClass.isInstance(node))\n                    nodes.add(tClass.cast(node));\n            }\n        }\n        return nodes;\n    }\n\n    // list methods that update the DOM:\n\n    /**\n     Replace the Element at the specified index in this list, and in the DOM.\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the old Element at this index\n     * @since 1.17.1\n     */\n    @Override public Element set(int index, Element element) {\n        Validate.notNull(element);\n        Element old = super.set(index, element);\n        old.replaceWith(element);\n        return old;\n    }\n\n    /**\n     Remove the Element at the specified index in this ist, and from the DOM.\n     * @param index the index of the element to be removed\n     * @return the old element at this index\n     * @since 1.17.1\n     */\n    @Override public Element remove(int index) {\n        Element old = super.remove(index);\n        old.remove();\n        return old;\n    }\n\n    /**\n     Remove the specified Element from this list, and from th DOM\n     * @param o element to be removed from this list, if present\n     * @return if this list contained the Element\n     * @since 1.17.1\n     */\n    @Override public boolean remove(Object o) {\n        int index = super.indexOf(o);\n        if (index == -1) {\n            return false;\n        } else {\n            remove(index);\n            return true;\n        }\n    }\n\n    /**\n     Removes all the elements from this list, and each of them from the DOM.\n     * @since 1.17.1\n     * @see #remove()\n     */\n    @Override public void clear() {\n        remove();\n        super.clear();\n    }\n\n    /**\n     Removes from this list, and from the DOM, each of the elements that are contained in the specified collection and\n     are in this list.\n     * @param c collection containing elements to be removed from this list\n     * @return {@code true} if elements were removed from this list\n     * @since 1.17.1\n     */\n    @Override public boolean removeAll(Collection<?> c) {\n        boolean anyRemoved = false;\n        for (Object o : c) {\n            anyRemoved |= this.remove(o);\n        }\n        return anyRemoved;\n    }\n\n    /**\n     Retain in this list, and in the DOM, only the elements that are in the specified collection and are in this list.\n     In other words, remove elements from this list and the DOM any item that is in this list but not in the specified\n     collection.\n     * @param c collection containing elements to be retained in this list\n     * @return {@code true} if elements were removed from this list\n     * @since 1.17.1\n     */\n    @Override public boolean retainAll(Collection<?> c) {\n        boolean anyRemoved = false;\n        for (Iterator<Element> it = this.iterator(); it.hasNext(); ) {\n            Element el = it.next();\n            if (!c.contains(el)) {\n                it.remove();\n                anyRemoved = true;\n            }\n        }\n        return anyRemoved;\n    }\n\n    /**\n     Remove from the list, and from the DOM, all elements in this list that mach the given filter.\n     * @param filter a predicate which returns {@code true} for elements to be removed\n     * @return {@code true} if elements were removed from this list\n     * @since 1.17.1\n     */\n    @Override public boolean removeIf(Predicate<? super Element> filter) {\n        boolean anyRemoved = false;\n        for (Iterator<Element> it = this.iterator(); it.hasNext(); ) {\n            Element el = it.next();\n            if (filter.test(el)) {\n                it.remove();\n                anyRemoved = true;\n            }\n        }\n        return anyRemoved;\n    }\n\n    /**\n     Replace each element in this list with the result of the operator, and update the DOM.\n     * @param operator the operator to apply to each element\n     * @since 1.17.1\n     */\n    @Override public void replaceAll(UnaryOperator<Element> operator) {\n        for (int i = 0; i < this.size(); i++) {\n            this.set(i, operator.apply(this.get(i)));\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/select/QueryParser.java.QueryParser", "name": "QueryParser", "file_path": "src/main/java/org/jsoup/select/QueryParser.java", "superclasses": "", "methods": ["[]QueryParser(String)", "[Evaluator]parse(String)", "[Evaluator]parse()", "[void]combinator(char)", "[String]consumeSubQuery()", "[Evaluator]consumeEvaluator()", "[Evaluator]parsePseudoSelector()", "[Evaluator]byId()", "[Evaluator]byClass()", "[Evaluator]byTag()", "[Evaluator]byAttribute()", "[Evaluator]cssNthChild(boolean,boolean)", "[String]consumeParens()", "[int]consumeIndex()", "[Evaluator]has()", "[Evaluator]is()", "[Evaluator]contains(boolean)", "[Evaluator]containsWholeText(boolean)", "[Evaluator]containsData()", "[Evaluator]matches(boolean)", "[Evaluator]matchesWholeText(boolean)", "[Evaluator]not()", "[String]toString()"], "method_uris": ["src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[]QueryParser(String)", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]parse(String)", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]parse()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[void]combinator(char)", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[String]consumeSubQuery()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]consumeEvaluator()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]parsePseudoSelector()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]byId()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]byClass()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]byTag()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]byAttribute()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]cssNthChild(boolean,boolean)", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[String]consumeParens()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[int]consumeIndex()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]has()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]is()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]contains(boolean)", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]containsWholeText(boolean)", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]containsData()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]matches(boolean)", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]matchesWholeText(boolean)", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[Evaluator]not()", "src/main/java/org/jsoup/select/QueryParser.java.QueryParser.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nParses a CSS selector into an Evaluator tree.\n", "original_string": "public class QueryParser {\n    private final static char[] Combinators = {',', '>', '+', '~', ' '};\n    private final static String[] AttributeEvals = new String[]{\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"};\n\n    private final TokenQueue tq;\n    private final String query;\n    private final List<Evaluator> evals = new ArrayList<>();\n\n    /**\n     * Create a new QueryParser.\n     * @param query CSS query\n     */\n    private QueryParser(String query) {\n        Validate.notEmpty(query);\n        query = query.trim();\n        this.query = query;\n        this.tq = new TokenQueue(query);\n    }\n\n    /**\n     * Parse a CSS query into an Evaluator.\n     * @param query CSS query\n     * @return Evaluator\n     * @see Selector selector query syntax\n     */\n    public static Evaluator parse(String query) {\n        try {\n            QueryParser p = new QueryParser(query);\n            return p.parse();\n        } catch (IllegalArgumentException e) {\n            throw new Selector.SelectorParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Parse the query\n     * @return Evaluator\n     */\n    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(Combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            evals.add(consumeEvaluator());\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(Combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                evals.add(consumeEvaluator()); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }\n\n    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery = consumeSubQuery(); // support multi > childs\n\n        Evaluator rootEval; // the new topmost evaluator\n        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.\n        Evaluator newEval = parse(subQuery); // the evaluator to add into target evaluator\n        boolean replaceRightMost = false;\n\n        if (evals.size() == 1) {\n            rootEval = currentEval = evals.get(0);\n            // make sure OR (,) has precedence:\n            if (rootEval instanceof CombiningEvaluator.Or && combinator != ',') {\n                currentEval = ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();\n                assert currentEval != null; // rightMost signature can return null (if none set), but always will have one by this point\n                replaceRightMost = true;\n            }\n        }\n        else {\n            rootEval = currentEval = new CombiningEvaluator.And(evals);\n        }\n        evals.clear();\n\n        // for most combinators: change the current eval into an AND of the current eval and the new eval\n        switch (combinator) {\n            case '>':\n                ImmediateParentRun run = currentEval instanceof ImmediateParentRun ?\n                        (ImmediateParentRun) currentEval : new ImmediateParentRun(currentEval);\n                run.add(newEval);\n                currentEval = run;\n                break;\n            case ' ':\n                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.Parent(currentEval), newEval);\n                break;\n            case '+':\n                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.ImmediatePreviousSibling(currentEval), newEval);\n                break;\n            case '~':\n                currentEval = new CombiningEvaluator.And(new StructuralEvaluator.PreviousSibling(currentEval), newEval);\n                break;\n            case ',':\n                CombiningEvaluator.Or or;\n                if (currentEval instanceof CombiningEvaluator.Or) {\n                    or = (CombiningEvaluator.Or) currentEval;\n                } else {\n                    or = new CombiningEvaluator.Or();\n                    or.add(currentEval);\n                }\n                or.add(newEval);\n                currentEval = or;\n                break;\n            default:\n                throw new Selector.SelectorParseException(\"Unknown combinator '%s'\", combinator);\n        }\n\n        if (replaceRightMost)\n            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);\n        else rootEval = currentEval;\n        evals.add(rootEval);\n    }\n\n    private String consumeSubQuery() {\n        StringBuilder sq = StringUtil.borrowBuilder();\n        boolean seenClause = false; // eat until we hit a combinator after eating something else\n        while (!tq.isEmpty()) {\n            if (tq.matchesAny(Combinators)) {\n                if (seenClause)\n                    break;\n                sq.append(tq.consume());\n                continue;\n            }\n            seenClause = true;\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced('(', ')')).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced('[', ']')).append(\"]\");\n            else if (tq.matches(\"\\\\\")) { // bounce over escapes\n                sq.append(tq.consume());\n                if (!tq.isEmpty()) sq.append(tq.consume());\n            } else\n                sq.append(tq.consume());\n        }\n        return StringUtil.releaseBuilder(sq);\n    }\n\n    private Evaluator consumeEvaluator() {\n        if (tq.matchChomp(\"#\"))\n            return byId();\n        else if (tq.matchChomp(\".\"))\n            return byClass();\n        else if (tq.matchesWord() || tq.matches(\"*|\"))\n            return byTag();\n        else if (tq.matches(\"[\"))\n            return byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            return new Evaluator.AllElements();\n        else if (tq.matchChomp(\":\"))\n            return parsePseudoSelector();\n\t\telse // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n    }\n\n    private Evaluator parsePseudoSelector() {\n        final String pseudo = tq.consumeCssIdentifier();\n        switch (pseudo) {\n            case \"lt\":\n                return new Evaluator.IndexLessThan(consumeIndex());\n            case \"gt\":\n                return new Evaluator.IndexGreaterThan(consumeIndex());\n            case \"eq\":\n                return new Evaluator.IndexEquals(consumeIndex());\n            case \"has\":\n                return has();\n            case \"is\":\n                return is();\n            case \"contains\":\n                return contains(false);\n            case \"containsOwn\":\n                return contains(true);\n            case \"containsWholeText\":\n                return containsWholeText(false);\n            case \"containsWholeOwnText\":\n                return containsWholeText(true);\n            case \"containsData\":\n                return containsData();\n            case \"matches\":\n                return matches(false);\n            case \"matchesOwn\":\n                return matches(true);\n            case \"matchesWholeText\":\n                return matchesWholeText(false);\n            case \"matchesWholeOwnText\":\n                return matchesWholeText(true);\n            case \"not\":\n                return not();\n            case \"nth-child\":\n                return cssNthChild(false, false);\n            case \"nth-last-child\":\n                return cssNthChild(true, false);\n            case \"nth-of-type\":\n                return cssNthChild(false, true);\n            case \"nth-last-of-type\":\n                return cssNthChild(true, true);\n            case \"first-child\":\n                return new Evaluator.IsFirstChild();\n            case \"last-child\":\n                return new Evaluator.IsLastChild();\n            case \"first-of-type\":\n                return new Evaluator.IsFirstOfType();\n            case \"last-of-type\":\n                return new Evaluator.IsLastOfType();\n            case \"only-child\":\n                return new Evaluator.IsOnlyChild();\n            case \"only-of-type\":\n                return new Evaluator.IsOnlyOfType();\n            case \"empty\":\n                return new Evaluator.IsEmpty();\n            case \"root\":\n                return new Evaluator.IsRoot();\n            case \"matchText\":\n                return new Evaluator.MatchText();\n            default:\n                throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n        }\n    }\n\n    private Evaluator byId() {\n        String id = tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n        return new Evaluator.Id(id);\n    }\n\n    private Evaluator byClass() {\n        String className = tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n        return new Evaluator.Class(className.trim());\n    }\n\n    private Evaluator byTag() {\n        // todo - these aren't dealing perfectly with case sensitivity. For case sensitive parsers, we should also make\n        // the tag in the selector case-sensitive (and also attribute names). But for now, normalize (lower-case) for\n        // consistency - both the selector and the element tag\n        String tagName = normalize(tq.consumeElementSelector());\n        Validate.notEmpty(tagName);\n\n        // namespaces:\n        if (tagName.startsWith(\"*|\")) { // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName\n            String plainTag = tagName.substring(2); // strip *|\n            return new CombiningEvaluator.Or(\n                new Evaluator.Tag(plainTag),\n                new Evaluator.TagEndsWith(\":\" + plainTag)\n            );\n        } else if (tagName.endsWith(\"|*\")) { // ns|*\n            String ns = tagName.substring(0, tagName.length() - 2) + \":\"; // strip |*, to ns:\n            return new Evaluator.TagStartsWith(ns);\n        } else if (tagName.contains(\"|\")) { // flip \"abc|def\" to \"abc:def\"\n            tagName = tagName.replace(\"|\", \":\");\n        }\n\n        return new Evaluator.Tag(tagName);\n    }\n\n    private Evaluator byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n        final Evaluator eval;\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                eval = new Evaluator.AttributeStarting(key.substring(1));\n            else if (key.equals(\"*\")) // any attribute\n                eval = new Evaluator.AttributeStarting(\"\");\n            else\n                eval = new Evaluator.Attribute(key);\n        } else {\n            if (cq.matchChomp(\"=\"))\n                eval = new Evaluator.AttributeWithValue(key, cq.remainder());\n            else if (cq.matchChomp(\"!=\"))\n                eval = new Evaluator.AttributeWithValueNot(key, cq.remainder());\n            else if (cq.matchChomp(\"^=\"))\n                eval = new Evaluator.AttributeWithValueStarting(key, cq.remainder());\n            else if (cq.matchChomp(\"$=\"))\n                eval = new Evaluator.AttributeWithValueEnding(key, cq.remainder());\n            else if (cq.matchChomp(\"*=\"))\n                eval = new Evaluator.AttributeWithValueContaining(key, cq.remainder());\n            else if (cq.matchChomp(\"~=\"))\n                eval = new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder()));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n        return eval;\n    }\n\n    //pseudo selectors :first-child, :last-child, :nth-child, ...\n    private static final Pattern NTH_AB = Pattern.compile(\"(([+-])?(\\\\d+)?)n(\\\\s*([+-])?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n    private static final Pattern NTH_B  = Pattern.compile(\"([+-])?(\\\\d+)\");\n\n\tprivate Evaluator cssNthChild(boolean backwards, boolean ofType) {\n\t\tString arg = normalize(consumeParens());\n\t\tMatcher mAB = NTH_AB.matcher(arg);\n\t\tMatcher mB = NTH_B.matcher(arg);\n\t\tfinal int a, b;\n\t\tif (\"odd\".equals(arg)) {\n\t\t\ta = 2;\n\t\t\tb = 1;\n\t\t} else if (\"even\".equals(arg)) {\n\t\t\ta = 2;\n\t\t\tb = 0;\n\t\t} else if (mAB.matches()) {\n\t\t\ta = mAB.group(3) != null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n\t\t\tb = mAB.group(4) != null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n\t\t} else if (mB.matches()) {\n\t\t\ta = 0;\n\t\t\tb = Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n\t\t} else {\n\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index '%s': unexpected format\", arg);\n\t\t}\n\n        final Evaluator eval;\n\t\tif (ofType)\n\t\t\tif (backwards)\n\t\t\t\teval = new Evaluator.IsNthLastOfType(a, b);\n\t\t\telse\n\t\t\t\teval = new Evaluator.IsNthOfType(a, b);\n\t\telse {\n\t\t\tif (backwards)\n\t\t\t\teval = (new Evaluator.IsNthLastChild(a, b));\n\t\t\telse\n\t\t\t\teval = new Evaluator.IsNthChild(a, b);\n\t\t}\n        return eval;\n\t}\n\n    private String consumeParens() {\n        return tq.chompBalanced('(', ')');\n    }\n\n    private int consumeIndex() {\n        String index = consumeParens().trim();\n        Validate.isTrue(StringUtil.isNumeric(index), \"Index must be numeric\");\n        return Integer.parseInt(index);\n    }\n\n    // pseudo selector :has(el)\n    private Evaluator has() {\n        String subQuery = consumeParens();\n        Validate.notEmpty(subQuery, \":has(selector) sub-select must not be empty\");\n        return new StructuralEvaluator.Has(parse(subQuery));\n    }\n\n    // psuedo selector :is()\n    private Evaluator is() {\n        String subQuery = consumeParens();\n        Validate.notEmpty(subQuery, \":is(selector) sub-select must not be empty\");\n        return new StructuralEvaluator.Is(parse(subQuery));\n    }\n\n    // pseudo selector :contains(text), containsOwn(text)\n    private Evaluator contains(boolean own) {\n        String query = own ? \":containsOwn\" : \":contains\";\n        String searchText = TokenQueue.unescape(consumeParens());\n        Validate.notEmpty(searchText, query + \"(text) query must not be empty\");\n        return own\n            ? new Evaluator.ContainsOwnText(searchText)\n            : new Evaluator.ContainsText(searchText);\n    }\n\n    private Evaluator containsWholeText(boolean own) {\n        String query = own ? \":containsWholeOwnText\" : \":containsWholeText\";\n        String searchText = TokenQueue.unescape(consumeParens());\n        Validate.notEmpty(searchText, query + \"(text) query must not be empty\");\n        return own\n            ? new Evaluator.ContainsWholeOwnText(searchText)\n            : new Evaluator.ContainsWholeText(searchText);\n    }\n\n    // pseudo selector :containsData(data)\n    private Evaluator containsData() {\n        String searchText = TokenQueue.unescape(consumeParens());\n        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");\n        return new Evaluator.ContainsData(searchText);\n    }\n\n    // :matches(regex), matchesOwn(regex)\n    private Evaluator matches(boolean own) {\n        String query = own ? \":matchesOwn\" : \":matches\";\n        String regex = consumeParens(); // don't unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, query + \"(regex) query must not be empty\");\n\n        return own\n            ? new Evaluator.MatchesOwn(Pattern.compile(regex))\n            : new Evaluator.Matches(Pattern.compile(regex));\n    }\n\n    // :matches(regex), matchesOwn(regex)\n    private Evaluator matchesWholeText(boolean own) {\n        String query = own ? \":matchesWholeOwnText\" : \":matchesWholeText\";\n        String regex = consumeParens(); // don't unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, query + \"(regex) query must not be empty\");\n\n        return own\n            ? new Evaluator.MatchesWholeOwnText(Pattern.compile(regex))\n            : new Evaluator.MatchesWholeText(Pattern.compile(regex));\n    }\n\n    // :not(selector)\n    private Evaluator not() {\n        String subQuery = consumeParens();\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        return new StructuralEvaluator.Not(parse(subQuery));\n    }\n\n    @Override\n    public String toString() {\n        return query;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final static char[] Combinators = {',', '>', '+', '~', ' '};", "docstring": "", "modifiers": "private final static", "marker_annotations": [], "non_marker_annotations": ["private", "final", "static"], "comments": [], "type": "char[]", "name": "Combinators = {',', '>', '+', '~', ' '}", "syntax_pass": true}, {"attribute_expression": "private final static String[] AttributeEvals = new String[]{\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"};", "docstring": "", "modifiers": "private final static", "marker_annotations": [], "non_marker_annotations": ["private", "final", "static"], "comments": [], "type": "String[]", "name": "AttributeEvals = new String[]{\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"}", "syntax_pass": true}, {"attribute_expression": "private final TokenQueue tq;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TokenQueue", "name": "tq", "syntax_pass": true}, {"attribute_expression": "private final String query;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "query", "syntax_pass": true}, {"attribute_expression": "private final List<Evaluator> evals = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Evaluator>", "name": "evals = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private static final Pattern NTH_AB = Pattern.compile(\"(([+-])?(\\\\d+)?)n(\\\\s*([+-])?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);", "docstring": "pseudo selectors :first-child, :last-child, :nth-child, ...", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "NTH_AB = Pattern.compile(\"(([+-])?(\\\\d+)?)n(\\\\s*([+-])?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE)", "syntax_pass": true}, {"attribute_expression": "private static final Pattern NTH_B  = Pattern.compile(\"([+-])?(\\\\d+)\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "NTH_B  = Pattern.compile(\"([+-])?(\\\\d+)\")", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/select/Selector.java.Selector", "name": "Selector", "file_path": "src/main/java/org/jsoup/select/Selector.java", "superclasses": "", "methods": ["[]Selector()", "[Elements]select(String,Element)", "[Elements]select(Evaluator,Element)", "[Elements]select(String,Iterable<Element>)", "[Elements]filterOut(Collection<Element>,Collection<Element>)", "[Element]selectFirst(String,Element)"], "method_uris": ["src/main/java/org/jsoup/select/Selector.java.Selector.[]Selector()", "src/main/java/org/jsoup/select/Selector.java.Selector.[Elements]select(String,Element)", "src/main/java/org/jsoup/select/Selector.java.Selector.[Elements]select(Evaluator,Element)", "src/main/java/org/jsoup/select/Selector.java.Selector.[Elements]select(String,Iterable<Element>)", "src/main/java/org/jsoup/select/Selector.java.Selector.[Elements]filterOut(Collection<Element>,Collection<Element>)", "src/main/java/org/jsoup/select/Selector.java.Selector.[Element]selectFirst(String,Element)"], "overrides": null, "attributes": [{"original_string": "    public static class SelectorParseException extends IllegalStateException {\n        public SelectorParseException(String msg) {\n            super(msg);\n        }\n\n        public SelectorParseException(String msg, Object... msgArgs) {\n            super(String.format(msg, msgArgs));\n        }\n\n        public SelectorParseException(Throwable cause, String msg, Object... msgArgs) {\n            super(String.format(msg, msgArgs), cause);\n        }\n    }", "definition": "    public static class SelectorParseException extends IllegalStateException", "class_docstring": "", "name": "SelectorParseException", "super_interfaces": [], "superclasses": "IllegalStateException", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public SelectorParseException(String msg) {\n            super(msg);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SelectorParseException", "params": [{"name": "msg", "type": "String"}], "body": "                                                  {\n            super(msg);\n        }", "signature": "public SelectorParseException(String msg)"}, {"syntax_pass": true, "original_string": "        public SelectorParseException(String msg, Object... msgArgs) {\n            super(String.format(msg, msgArgs));\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SelectorParseException", "params": [{"name": "msg", "type": "String"}], "body": "                                                                     {\n            super(String.format(msg, msgArgs));\n        }", "signature": "public SelectorParseException(String msg, Object... msgArgs)"}, {"syntax_pass": true, "original_string": "        public SelectorParseException(Throwable cause, String msg, Object... msgArgs) {\n            super(String.format(msg, msgArgs), cause);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SelectorParseException", "params": [{"name": "cause", "type": "Throwable"}, {"name": "msg", "type": "String"}], "body": "                                                                                      {\n            super(String.format(msg, msgArgs), cause);\n        }", "signature": "public SelectorParseException(Throwable cause, String msg, Object... msgArgs)"}]}], "class_docstring": "\nCSS-like element selector, that finds elements matching a query.\n\n<h2>Selector syntax</h2>\n<p>\nA selector is a chain of simple selectors, separated by combinators. Selectors are <b>case insensitive</b> (including against\nelements, attributes, and attribute values).\n</p>\n<p>\nThe universal selector {@code *} is implicit when no element selector is supplied (i.e. {@code .header} and {@code *.header}\nare equivalent).\n</p>\n<style>table.syntax tr td {vertical-align: top; padding-right: 2em; padding-top:0.5em; padding-bottom:0.5em; } table.syntax tr:hover{background-color: #eee;} table.syntax {border-spacing: 0px 0px;}</style>\n<table summary=\"\" class=\"syntax\"><colgroup><col span=\"1\" style=\"width: 20%;\"><col span=\"1\" style=\"width: 40%;\"><col span=\"1\" style=\"width: 40%;\"></colgroup>\n<tr><th align=\"left\">Pattern</th><th align=\"left\">Matches</th><th align=\"left\">Example</th></tr>\n<tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n<tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n<tr><td><code>*|E</code></td><td>elements of type E in any namespace (including non-namespaced)</td><td><code>*|name</code> finds <code>&lt;dc:name&gt;</code> and <code>&lt;name&gt;</code> elements</td></tr>\n<tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>dc|name</code> finds <code>&lt;dc:name&gt;</code> elements</td></tr>\n<tr><td><code>ns|*</code></td><td>all elements in the namespace <i>ns</i></td><td><code>dc|*</code> finds <code>&lt;dc:p&gt;</code> and <code>&lt;dc:img&gt;</code>elements</td></tr>\n<tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n<tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n<tr><td><code>[attr]</code></td><td>elements with an attribute named \"attr\" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>\n<tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with \"attrPrefix\". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>\n<tr><td><code>[attr=val]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>\n<tr><td><code>[attr=&quot;val&quot;]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>span[hello=\"Cleveland\"][goodbye=\"Columbus\"]</code>, <code>a[rel=&quot;nofollow&quot;]</code></td></tr>\n<tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></td></tr>\n<tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named \"attr\", and value ending with \"valSuffix\"</td><td><code>img[src$=.png]</code></td></tr>\n<tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named \"attr\", and value containing \"valContaining\"</td><td><code>a[href*=/search/]</code></td></tr>\n<tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named \"attr\", and value matching the regular expression</td><td><code>img[src~=(?i)\\\\.(png|jpe?g)]</code></td></tr>\n<tr><td><code>[*]</code></td><td>elements with any attribute</td><td><code>p[*]</code> finds <code>p</code> elements that have at least one attribute; <code>p:not([*])</code> finds those with no attributes</td></tr>\n<tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n<tr><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n<tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n<tr><td><code>E {@literal >} F</code></td><td>an F direct child of E</td><td><code>ol {@literal >} li</code></td></tr>\n<tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n<tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n<tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n<tr><td colspan=\"3\"><h3>Pseudo selectors</h3></td></tr>\n<tr><td><code>:lt(<em>n</em>)</code></td><td>elements whose sibling index is less than <em>n</em></td><td><code>td:lt(3)</code> finds the first 3 cells of each row</td></tr>\n<tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n<tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n<tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds <code>div</code>s that contain <code>p</code> elements.<br><code>div:has(&gt; a)</code> selects <code>div</code> elements that have at least one direct child <code>a</code> element.<br><code>section:has(h1, h2)</code> finds <code>section</code> elements that contain a <code>h1</code> or a <code>h2</code> element</td></tr>\n<tr><td><code>:is(<em>selector list</em>)</code></td><td>elements that match any of the selectors in the selector list</td><td><code>:is(h1, h2, h3, h4, h5, h6)</code> finds any heading element.<br><code>:is(section, article) > :is(h1, h2)</code> finds a <code>h1</code> or <code>h2</code> that is a direct child of a <code>section</code> or an <code>article</code></td></tr>\n<tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<p><code>div:not(:has(div))</code> finds divs that do not contain divs.</p></td></tr>\n<tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants. The text is whitespace normalized. <p>To find content that includes parentheses, escape those with a {@code \\}.</p></td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".<p>{@code p:contains(hello \\(there\\) finds p elements containing the text \"Hello (There)\"}</p></td></tr>\n<tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n<tr><td><code>:containsData(<em>data</em>)</code></td><td>elements that contains the specified <em>data</em>. The contents of {@code script} and {@code style} elements, and {@code comment} nodes (etc) are considered data nodes, not text nodes. The search is case insensitive. The data may appear in the found element, or any of its descendants.</td><td><code>script:contains(jsoup)</code> finds script elements containing the data \"jsoup\".</td></tr>\n<tr><td><code>:containsWholeText(<em>text</em>)</code></td><td>elements that contains the specified <b>non-normalized</b> text. The search is case sensitive, and will match exactly against spaces and newlines found in the original input. The text may appear in the found element, or any of its descendants. <p>To find content that includes parentheses, escape those with a {@code \\}.</p></td><td><code>p:containsWholeText(jsoup\\nThe Java HTML Parser)</code> finds p elements containing the text <code>\"jsoup\\nThe Java HTML Parser\"</code> (and not other variations of whitespace or casing, as <code>:contains()</code> would. Note that {@code br} elements are presented as a newline.</p></td></tr>\n<tr><td><code>:containsWholeOwnText(<em>text</em>)</code></td><td>elements that <b>directly</b> contain the specified <b>non-normalized</b> text. The search is case sensitive, and will match exactly against spaces and newlines found in the original input. The text may appear in the found element, but not in its descendants. <p>To find content that includes parentheses, escape those with a {@code \\}.</p></td><td><code>p:containsWholeOwnText(jsoup\\nThe Java HTML Parser)</code> finds p elements directly containing the text <code>\"jsoup\\nThe Java HTML Parser\"</code> (and not other variations of whitespace or casing, as <code>:contains()</code> would. Note that {@code br} elements are presented as a newline.</p></td></tr>\n<tr><td><code>:matches(<em>regex</em>)</code></td><td>elements containing <b>whitespace normalized</b> text that matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n<tr><td><code>:matchesWholeText(<em>regex</em>)</code></td><td>elements containing <b>non-normalized</b> whole text that matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matchesWholeText(\\\\s{2,})</code> finds table cells a run of at least two space characters.</td></tr>\n<tr><td><code>:matchesWholeOwnText(<em>regex</em>)</code></td><td>elements whose own <b>non-normalized</b> whole text matches the specified regular expression. The text must appear in the found element, not any of its descendants.</td><td><code>td:matchesWholeOwnText(\\n\\\\d+)</code> finds table cells directly containing digits following a neewline.</td></tr>\n<tr><td></td><td>The above may be combined in any order and with other selectors</td><td><code>.light:contains(name):eq(0)</code></td></tr>\n<tr><td><code>:matchText</code></td><td>treats text nodes as elements, and so allows you to match against and select text nodes.<p><b>Note</b> that using this selector will modify the DOM, so you may want to {@code clone} your document before using.</td><td>{@code p:matchText:firstChild} with input {@code <p>One<br />Two</p>} will return one {@link org.jsoup.nodes.PseudoTextElement} with text \"{@code One}\".</td></tr>\n<tr><td colspan=\"3\"><h3>Structural pseudo selectors</h3></td></tr>\n<tr><td><code>:root</code></td><td>The element that is the root of the document. In HTML, this is the <code>html</code> element</td><td><code>:root</code></td></tr>\n<tr><td><code>:nth-child(<em>a</em>n+<em>b</em>)</code></td><td><p>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>before</b> it in the document tree, for any positive integer or zero value of <code>n</code>, and has a parent element. For values of <code>a</code> and <code>b</code> greater than zero, this effectively divides the element's children into groups of a elements (the last group taking the remainder), and selecting the <em>b</em>th element of each group. For example, this allows the selectors to address every other row in a table, and could be used to alternate the color of paragraph text in a cycle of four. The <code>a</code> and <code>b</code> values must be integers (positive, negative, or zero). The index of the first child of an element is 1.</p>\nAdditionally, <code>:nth-child()</code> supports <code>odd</code> and <code>even</code> as arguments. <code>odd</code> is the same as <code>2n+1</code>, and <code>even</code> is the same as <code>2n</code>.</td><td><code>tr:nth-child(2n+1)</code> finds every odd row of a table. <code>:nth-child(10n-1)</code> the 9th, 19th, 29th, etc, element. <code>li:nth-child(5)</code> the 5h li</td></tr>\n<tr><td><code>:nth-last-child(<em>a</em>n+<em>b</em>)</code></td><td>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>after</b> it in the document tree. Otherwise like <code>:nth-child()</code></td><td><code>tr:nth-last-child(-n+2)</code> the last two rows of a table</td></tr>\n<tr><td><code>:nth-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>before</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-of-type(2n+1)</code></td></tr>\n<tr><td><code>:nth-last-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>after</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-last-of-type(2n+1)</code></td></tr>\n<tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div {@literal >} p:first-child</code></td></tr>\n<tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol {@literal >} li:last-child</code></td></tr>\n<tr><td><code>:first-of-type</code></td><td>elements that are the first sibling of its type in the list of children of its parent element</td><td><code>dl dt:first-of-type</code></td></tr>\n<tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr {@literal >} td:last-of-type</code></td></tr>\n<tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element have no other element children</td><td></td></tr>\n<tr><td><code>:only-of-type</code></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>\n<tr><td><code>:empty</code></td><td>elements that contain no child elements or nodes, with the exception of blank text nodes, comments, XML declarations, and doctype declarations. In other words, it matches elements that are effectively empty of meaningful content.</td><td><code>li:not(:empty)</code></td></tr>\n</table>\n\n<p>A word on using regular expressions in these selectors: depending on the content of the regex, you will need to quote the pattern using <b><code>Pattern.quote(\"regex\")</code></b> for it to parse correctly through both the selector parser and the regex parser. E.g. <code>String query = \"div:matches(\" + Pattern.quote(regex) + \");\"</code>.</p>\n<p><b>Escaping special characters:</b> to match a tag, ID, or other selector that does not follow the regular CSS syntax, the query must be escaped with the <code>\\</code> character. For example, to match by ID {@code <p id=\"i.d\">}, use {@code document.select(\"#i\\\\.d\")}.</p>\n\n@see Element#select(String css)\n@see Elements#select(String css)\n@see Element#selectXpath(String xpath)\n", "original_string": "public class Selector {\n    // not instantiable\n    private Selector() {}\n\n    /**\n     * Find elements matching selector.\n     *\n     * @param query CSS selector\n     * @param root  root element to descend into\n     * @return matching elements, empty if none\n     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.\n     */\n    public static Elements select(String query, Element root) {\n        Validate.notEmpty(query);\n        return select(QueryParser.parse(query), root);\n    }\n\n    /**\n     * Find elements matching selector.\n     *\n     * @param evaluator CSS selector\n     * @param root root element to descend into\n     * @return matching elements, empty if none\n     */\n    public static Elements select(Evaluator evaluator, Element root) {\n        Validate.notNull(evaluator);\n        Validate.notNull(root);\n        return Collector.collect(evaluator, root);\n    }\n\n    /**\n     * Find elements matching selector.\n     *\n     * @param query CSS selector\n     * @param roots root elements to descend into\n     * @return matching elements, empty if none\n     */\n    public static Elements select(String query, Iterable<Element> roots) {\n        Validate.notEmpty(query);\n        Validate.notNull(roots);\n        Evaluator evaluator = QueryParser.parse(query);\n        Elements elements = new Elements();\n        IdentityHashMap<Element, Boolean> seenElements = new IdentityHashMap<>();\n        // dedupe elements by identity, not equality\n\n        for (Element root : roots) {\n            final Elements found = select(evaluator, root);\n            for (Element el : found) {\n                if (seenElements.put(el, Boolean.TRUE) == null) {\n                    elements.add(el);\n                }\n            }\n        }\n        return elements;\n    }\n\n    // exclude set. package open so that Elements can implement .not() selector.\n    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {\n        Elements output = new Elements();\n        for (Element el : elements) {\n            boolean found = false;\n            for (Element out : outs) {\n                if (el.equals(out)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found)\n                output.add(el);\n        }\n        return output;\n    }\n\n    /**\n     * Find the first element that matches the query.\n     * @param cssQuery CSS selector\n     * @param root root element to descend into\n     * @return the matching element, or <b>null</b> if none.\n     */\n    public static @Nullable Element selectFirst(String cssQuery, Element root) {\n        Validate.notEmpty(cssQuery);\n        return Collector.findFirst(QueryParser.parse(cssQuery), root);\n    }\n\n    public static class SelectorParseException extends IllegalStateException {\n        public SelectorParseException(String msg) {\n            super(msg);\n        }\n\n        public SelectorParseException(String msg, Object... msgArgs) {\n            super(String.format(msg, msgArgs));\n        }\n\n        public SelectorParseException(Throwable cause, String msg, Object... msgArgs) {\n            super(String.format(msg, msgArgs), cause);\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/select/Collector.java.Collector", "name": "Collector", "file_path": "src/main/java/org/jsoup/select/Collector.java", "superclasses": "", "methods": ["[]Collector()", "[Elements]collect(Evaluator,Element)", "[Element]findFirst(Evaluator,Element)"], "method_uris": ["src/main/java/org/jsoup/select/Collector.java.Collector.[]Collector()", "src/main/java/org/jsoup/select/Collector.java.Collector.[Elements]collect(Evaluator,Element)", "src/main/java/org/jsoup/select/Collector.java.Collector.[Element]findFirst(Evaluator,Element)"], "overrides": null, "attributes": [], "class_docstring": "\nCollects a list of elements that match the supplied criteria.\n\n@author Jonathan Hedley\n", "original_string": "public class Collector {\n\n    private Collector() {}\n\n    /**\n     Build a list of elements, by visiting root and every descendant of root, and testing it against the evaluator.\n     @param eval Evaluator to test elements against\n     @param root root of tree to descend\n     @return list of matches; empty if none\n     */\n    public static Elements collect (Evaluator eval, Element root) {\n        eval.reset();\n\n        return root.stream()\n            .filter(eval.asPredicate(root))\n            .collect(Collectors.toCollection(Elements::new));\n    }\n\n    /**\n     Finds the first Element that matches the Evaluator that descends from the root, and stops the query once that first\n     match is found.\n     @param eval Evaluator to test elements against\n     @param root root of tree to descend\n     @return the first match; {@code null} if none\n     */\n    public static @Nullable Element findFirst(Evaluator eval, Element root) {\n        eval.reset();\n\n        Optional<Element> first = root.stream().filter(eval.asPredicate(root)).findFirst();\n        return first.orElse(null);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/parser/ParseError.java.ParseError", "name": "ParseError", "file_path": "src/main/java/org/jsoup/parser/ParseError.java", "superclasses": "", "methods": ["[]ParseError(CharacterReader,String)", "[]ParseError(CharacterReader,String)", "[]ParseError(int,String)", "[]ParseError(int,String)", "[String]getErrorMessage()", "[int]getPosition()", "[String]getCursorPos()", "[String]toString()"], "method_uris": ["src/main/java/org/jsoup/parser/ParseError.java.ParseError.[]ParseError(CharacterReader,String)", "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[]ParseError(CharacterReader,String)", "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[]ParseError(int,String)", "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[]ParseError(int,String)", "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[String]getErrorMessage()", "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[int]getPosition()", "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[String]getCursorPos()", "src/main/java/org/jsoup/parser/ParseError.java.ParseError.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nA Parse Error records an error in the input HTML that occurs in either the tokenisation or the tree building phase.\n", "original_string": "public class ParseError {\n    private final int pos;\n    private final String cursorPos;\n    private final String errorMsg;\n\n    ParseError(CharacterReader reader, String errorMsg) {\n        pos = reader.pos();\n        cursorPos = reader.posLineCol();\n        this.errorMsg = errorMsg;\n    }\n\n    ParseError(CharacterReader reader, String errorFormat, Object... args) {\n        pos = reader.pos();\n        cursorPos = reader.posLineCol();\n        this.errorMsg = String.format(errorFormat, args);\n    }\n\n    ParseError(int pos, String errorMsg) {\n        this.pos = pos;\n        cursorPos = String.valueOf(pos);\n        this.errorMsg = errorMsg;\n    }\n\n    ParseError(int pos, String errorFormat, Object... args) {\n        this.pos = pos;\n        cursorPos = String.valueOf(pos);\n        this.errorMsg = String.format(errorFormat, args);\n    }\n\n    /**\n     * Retrieve the error message.\n     * @return the error message.\n     */\n    public String getErrorMessage() {\n        return errorMsg;\n    }\n\n    /**\n     * Retrieves the offset of the error.\n     * @return error offset within input\n     */\n    public int getPosition() {\n        return pos;\n    }\n\n    /**\n     Get the formatted line:column cursor position where the error occurred.\n     @return line:number cursor position\n     */\n    public String getCursorPos() {\n        return cursorPos;\n    }\n\n    @Override\n    public String toString() {\n        return \"<\" + cursorPos + \">: \" + errorMsg;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final int pos;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "pos", "syntax_pass": true}, {"attribute_expression": "private final String cursorPos;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "cursorPos", "syntax_pass": true}, {"attribute_expression": "private final String errorMsg;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "errorMsg", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList", "name": "ParseErrorList", "file_path": "src/main/java/org/jsoup/parser/ParseErrorList.java", "superclasses": "", "methods": ["[]ParseErrorList(int,int)", "[]ParseErrorList(ParseErrorList)", "[boolean]canAddError()", "[int]getMaxSize()", "[ParseErrorList]noTracking()", "[ParseErrorList]tracking(int)", "[Object]clone()"], "method_uris": ["src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[]ParseErrorList(int,int)", "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[]ParseErrorList(ParseErrorList)", "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[boolean]canAddError()", "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[int]getMaxSize()", "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[ParseErrorList]noTracking()", "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[ParseErrorList]tracking(int)", "src/main/java/org/jsoup/parser/ParseErrorList.java.ParseErrorList.[Object]clone()"], "overrides": null, "attributes": [], "class_docstring": "\nA container for ParseErrors.\n\n@author Jonathan Hedley\n", "original_string": "public class ParseErrorList extends ArrayList<ParseError>{\n    private static final int INITIAL_CAPACITY = 16;\n    private final int initialCapacity;\n    private final int maxSize;\n    \n    ParseErrorList(int initialCapacity, int maxSize) {\n        super(initialCapacity);\n        this.initialCapacity = initialCapacity;\n        this.maxSize = maxSize;\n    }\n\n    /**\n     Create a new ParseErrorList with the same settings, but no errors in the list\n     @param copy initial and max size details to copy\n     */\n    ParseErrorList(ParseErrorList copy) {\n        this(copy.initialCapacity, copy.maxSize);\n    }\n    \n    boolean canAddError() {\n        return size() < maxSize;\n    }\n\n    int getMaxSize() {\n        return maxSize;\n    }\n\n    public static ParseErrorList noTracking() {\n        return new ParseErrorList(0, 0);\n    }\n    \n    public static ParseErrorList tracking(int maxSize) {\n        return new ParseErrorList(INITIAL_CAPACITY, maxSize);\n    }\n\n    @Override\n    public Object clone() {\n        // all class fields are primitive, so native clone is enough.\n        return super.clone();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int INITIAL_CAPACITY = 16;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "INITIAL_CAPACITY = 16", "syntax_pass": true}, {"attribute_expression": "private final int initialCapacity;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "initialCapacity", "syntax_pass": true}, {"attribute_expression": "private final int maxSize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxSize", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings", "name": "ParseSettings", "file_path": "src/main/java/org/jsoup/parser/ParseSettings.java", "superclasses": "", "methods": ["[boolean]preserveTagCase()", "[boolean]preserveAttributeCase()", "[]ParseSettings(boolean,boolean)", "[]ParseSettings(ParseSettings)", "[String]normalizeTag(String)", "[String]normalizeAttribute(String)", "[Attributes]normalizeAttributes(Attributes)", "[String]normalName(String)"], "method_uris": ["src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[boolean]preserveTagCase()", "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[boolean]preserveAttributeCase()", "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[]ParseSettings(boolean,boolean)", "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[]ParseSettings(ParseSettings)", "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[String]normalizeTag(String)", "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[String]normalizeAttribute(String)", "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[Attributes]normalizeAttributes(Attributes)", "src/main/java/org/jsoup/parser/ParseSettings.java.ParseSettings.[String]normalName(String)"], "overrides": null, "attributes": [], "class_docstring": "\nControls parser case settings, to optionally preserve tag and/or attribute name case.\n", "original_string": "public class ParseSettings {\n    /**\n     * HTML default settings: both tag and attribute names are lower-cased during parsing.\n     */\n    public static final ParseSettings htmlDefault;\n    /**\n     * Preserve both tag and attribute case.\n     */\n    public static final ParseSettings preserveCase;\n\n    static {\n        htmlDefault = new ParseSettings(false, false);\n        preserveCase = new ParseSettings(true, true);\n    }\n\n    private final boolean preserveTagCase;\n    private final boolean preserveAttributeCase;\n\n    /**\n     * Returns true if preserving tag name case.\n     */\n    public boolean preserveTagCase() {\n        return preserveTagCase;\n    }\n\n    /**\n     * Returns true if preserving attribute case.\n     */\n    public boolean preserveAttributeCase() {\n        return preserveAttributeCase;\n    }\n\n    /**\n     * Define parse settings.\n     * @param tag preserve tag case?\n     * @param attribute preserve attribute name case?\n     */\n    public ParseSettings(boolean tag, boolean attribute) {\n        preserveTagCase = tag;\n        preserveAttributeCase = attribute;\n    }\n\n    ParseSettings(ParseSettings copy) {\n        this(copy.preserveTagCase, copy.preserveAttributeCase);\n    }\n\n    /**\n     * Normalizes a tag name according to the case preservation setting.\n     */\n    public String normalizeTag(String name) {\n        name = name.trim();\n        if (!preserveTagCase)\n            name = lowerCase(name);\n        return name;\n    }\n\n    /**\n     * Normalizes an attribute according to the case preservation setting.\n     */\n    public String normalizeAttribute(String name) {\n        name = name.trim();\n        if (!preserveAttributeCase)\n            name = lowerCase(name);\n        return name;\n    }\n\n    @Nullable Attributes normalizeAttributes(@Nullable Attributes attributes) {\n        if (attributes != null && !preserveAttributeCase) {\n            attributes.normalize();\n        }\n        return attributes;\n    }\n\n    /** Returns the normal name that a Tag will have (trimmed and lower-cased) */\n    static String normalName(String name) {\n        return lowerCase(name.trim());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final ParseSettings htmlDefault;", "docstring": "\nHTML default settings: both tag and attribute names are lower-cased during parsing.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "ParseSettings", "name": "htmlDefault", "syntax_pass": true}, {"attribute_expression": "public static final ParseSettings preserveCase;", "docstring": "\nPreserve both tag and attribute case.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "ParseSettings", "name": "preserveCase", "syntax_pass": true}, {"attribute_expression": "private final boolean preserveTagCase;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "preserveTagCase", "syntax_pass": true}, {"attribute_expression": "private final boolean preserveAttributeCase;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "preserveAttributeCase", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader", "name": "CharacterReader", "file_path": "src/main/java/org/jsoup/parser/CharacterReader.java", "superclasses": "", "methods": ["[]CharacterReader(Reader,int)", "[]CharacterReader(Reader)", "[]CharacterReader(String)", "[void]close()", "[void]bufferUp()", "[void]doBufferUp()", "[void]mark()", "[void]unmark()", "[void]rewindToMark()", "[int]pos()", "[boolean]readFully()", "[void]trackNewlines(boolean)", "[boolean]isTrackNewlines()", "[int]lineNumber()", "[int]lineNumber(int)", "[int]columnNumber()", "[int]columnNumber(int)", "[String]posLineCol()", "[int]lineNumIndex(int)", "[void]scanBufferForNewlines()", "[boolean]isEmpty()", "[boolean]isEmptyNoBufferUp()", "[char]current()", "[char]consume()", "[void]unconsume()", "[void]advance()", "[int]nextIndexOf(char)", "[int]nextIndexOf(CharSequence)", "[String]consumeTo(char)", "[String]consumeTo(String)", "[String]consumeToAny()", "[String]consumeToAnySorted()", "[String]consumeData()", "[String]consumeAttributeQuoted(boolean)", "[String]consumeRawData()", "[String]consumeTagName()", "[String]consumeToEnd()", "[String]consumeLetterSequence()", "[String]consumeLetterThenDigitSequence()", "[String]consumeHexSequence()", "[String]consumeDigitSequence()", "[boolean]matches(char)", "[boolean]matches(String)", "[boolean]matchesIgnoreCase(String)", "[boolean]matchesAny()", "[boolean]matchesAnySorted(char[])", "[boolean]matchesLetter()", "[boolean]matchesAsciiAlpha()", "[boolean]matchesDigit()", "[boolean]matchConsume(String)", "[boolean]matchConsumeIgnoreCase(String)", "[boolean]containsIgnoreCase(String)", "[String]toString()", "[String]cacheString(char[],String[],int,int)", "[boolean]rangeEquals(char[],int,int,String)", "[boolean]rangeEquals(int,int,String)"], "method_uris": ["src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[]CharacterReader(Reader,int)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[]CharacterReader(Reader)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[]CharacterReader(String)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]close()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]bufferUp()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]doBufferUp()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]mark()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]unmark()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]rewindToMark()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]pos()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]readFully()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]trackNewlines(boolean)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]isTrackNewlines()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]lineNumber()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]lineNumber(int)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]columnNumber()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]columnNumber(int)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]posLineCol()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]lineNumIndex(int)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]scanBufferForNewlines()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]isEmpty()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]isEmptyNoBufferUp()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[char]current()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[char]consume()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]unconsume()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[void]advance()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]nextIndexOf(char)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[int]nextIndexOf(CharSequence)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeTo(char)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeTo(String)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeToAny()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeToAnySorted()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeData()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeAttributeQuoted(boolean)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeRawData()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeTagName()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeToEnd()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeLetterSequence()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeLetterThenDigitSequence()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeHexSequence()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]consumeDigitSequence()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matches(char)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matches(String)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesIgnoreCase(String)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesAny()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesAnySorted(char[])", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesLetter()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesAsciiAlpha()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchesDigit()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchConsume(String)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]matchConsumeIgnoreCase(String)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]containsIgnoreCase(String)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]toString()", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[String]cacheString(char[],String[],int,int)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]rangeEquals(char[],int,int,String)", "src/main/java/org/jsoup/parser/CharacterReader.java.CharacterReader.[boolean]rangeEquals(int,int,String)"], "overrides": null, "attributes": [], "class_docstring": "\nCharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n", "original_string": "public final class CharacterReader {\n    static final char EOF = (char) -1;\n    private static final int MaxStringCacheLen = 12;\n    private static final int StringCacheSize = 512;\n    private String[] stringCache; // holds reused strings in this doc, to lessen garbage\n    private static final SoftPool<String[]> StringPool = new SoftPool<>(() -> new String[StringCacheSize]); // reuse cache between iterations\n\n    static final int BufferSize = 1024 * 2;         // visible for testing\n    static final int RefillPoint = BufferSize / 2;  // when bufPos characters read, refill; visible for testing\n    private static final int RewindLimit = 1024;    // the maximum we can rewind. No HTML entities can be larger than this.\n\n    private Reader reader;      // underlying Reader, will be backed by a buffered+controlled input stream, or StringReader\n    private char[] charBuf;     // character buffer we consume from; filled from Reader\n    private int bufPos;         // position in charBuf that's been consumed to\n    private int bufLength;      // the num of characters actually buffered in charBuf, <= charBuf.length\n    private int fillPoint = 0;  // how far into the charBuf we read before re-filling. 0.5 of charBuf.length after bufferUp\n    private int consumed;       // how many characters total have been consumed from this CharacterReader (less the current bufPos)\n    private int bufMark = -1;   // if not -1, the marked rewind position\n    private boolean readFully;  // if the underlying stream has been completely read, no value in further buffering\n\n    private static final SoftPool<char[]> BufferPool = new SoftPool<>(() -> new char[BufferSize]); // recycled char buffer\n\n    @Nullable private ArrayList<Integer> newlinePositions = null; // optionally track the pos() position of newlines - scans during bufferUp()\n    private int lineNumberOffset = 1; // line numbers start at 1; += newlinePosition[indexof(pos)]\n\n    public CharacterReader(Reader input, int sz) {\n        this(input); // sz is no longer used\n    }\n\n    public CharacterReader(Reader input) {\n        Validate.notNull(input);\n        reader = input;\n        charBuf = BufferPool.borrow();\n        stringCache = StringPool.borrow();\n        bufferUp();\n    }\n\n    public CharacterReader(String input) {\n        this(new StringReader(input));\n    }\n\n    public void close() {\n        if (reader == null)\n            return;\n        try {\n            reader.close();\n        } catch (IOException ignored) {\n        } finally {\n            reader = null;\n            Arrays.fill(charBuf, (char) 0); // before release, clear the buffer. Not required, but acts as a safety net, and makes debug view clearer\n            BufferPool.release(charBuf);\n            charBuf = null;\n            StringPool.release(stringCache); // conversely, we don't clear the string cache, so we can reuse the contents\n            stringCache = null;\n        }\n    }\n\n    private void bufferUp() {\n        if (readFully || bufPos < fillPoint || bufMark != -1)\n            return;\n        doBufferUp(); // structured so bufferUp may become an intrinsic candidate\n    }\n\n    private void doBufferUp() {\n        /*\n        The flow:\n        - if read fully, or if bufPos < fillPoint, or if marked - do not fill.\n        - update readerPos (total amount consumed from this CharacterReader) += bufPos\n        - shift charBuf contents such that bufPos = 0; set next read offset (bufLength) -= shift amount\n        - loop read the Reader until we fill charBuf. bufLength += read.\n        - readFully = true when read = -1\n         */\n        consumed += bufPos;\n        bufLength -= bufPos;\n        if (bufLength > 0)\n            System.arraycopy(charBuf, bufPos, charBuf, 0, bufLength);\n        bufPos = 0;\n        while (bufLength < BufferSize) {\n            try {\n                int read = reader.read(charBuf, bufLength, charBuf.length - bufLength);\n                if (read == -1) {\n                    readFully = true;\n                    break;\n                }\n                bufLength += read;\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n        fillPoint = Math.min(bufLength, RefillPoint);\n\n        scanBufferForNewlines(); // if enabled, we index newline positions for line number tracking\n        lastIcSeq = null; // cache for last containsIgnoreCase(seq)\n    }\n\n    void mark() {\n        // make sure there is enough look ahead capacity\n        if (bufLength - bufPos < RewindLimit)\n            fillPoint = 0;\n\n        bufferUp();\n        bufMark = bufPos;\n    }\n\n    void unmark() {\n        bufMark = -1;\n    }\n\n    void rewindToMark() {\n        if (bufMark == -1)\n            throw new UncheckedIOException(new IOException(\"Mark invalid\"));\n\n        bufPos = bufMark;\n        unmark();\n    }\n\n    /**\n     * Gets the position currently read to in the content. Starts at 0.\n     * @return current position\n     */\n    public int pos() {\n        return consumed + bufPos;\n    }\n\n    /** Tests if the buffer has been fully read. */\n    boolean readFully() {\n        return readFully;\n    }\n\n    /**\n     Enables or disables line number tracking. By default, will be <b>off</b>.Tracking line numbers improves the\n     legibility of parser error messages, for example. Tracking should be enabled before any content is read to be of\n     use.\n\n     @param track set tracking on|off\n     @since 1.14.3\n     */\n    public void trackNewlines(boolean track) {\n        if (track && newlinePositions == null) {\n            newlinePositions = new ArrayList<>(BufferSize / 80); // rough guess of likely count\n            scanBufferForNewlines(); // first pass when enabled; subsequently called during bufferUp\n        }\n        else if (!track)\n            newlinePositions = null;\n    }\n\n    /**\n     Check if the tracking of newlines is enabled.\n     @return the current newline tracking state\n     @since 1.14.3\n     */\n    public boolean isTrackNewlines() {\n        return newlinePositions != null;\n    }\n\n    /**\n     Get the current line number (that the reader has consumed to). Starts at line #1.\n     @return the current line number, or 1 if line tracking is not enabled.\n     @since 1.14.3\n     @see #trackNewlines(boolean)\n     */\n    public int lineNumber() {\n        return lineNumber(pos());\n    }\n\n    int lineNumber(int pos) {\n        // note that this impl needs to be called before the next buffer up or line numberoffset will be wrong. if that\n        // causes issues, can remove the reset of newlinepositions during buffer, at the cost of a larger tracking array\n        if (!isTrackNewlines())\n            return 1;\n\n        int i = lineNumIndex(pos);\n        if (i == -1)\n            return lineNumberOffset; // first line\n        return i + lineNumberOffset + 1;\n    }\n\n    /**\n     Get the current column number (that the reader has consumed to). Starts at column #1.\n     @return the current column number\n     @since 1.14.3\n     @see #trackNewlines(boolean)\n     */\n    public int columnNumber() {\n        return columnNumber(pos());\n    }\n\n    int columnNumber(int pos) {\n        if (!isTrackNewlines())\n            return pos + 1;\n\n        int i = lineNumIndex(pos);\n        if (i == -1)\n          return pos + 1;\n        return pos - newlinePositions.get(i) + 1;\n    }\n\n    /**\n     Get a formatted string representing the current line and column positions. E.g. <code>5:10</code> indicating line\n     number 5 and column number 10.\n     @return line:col position\n     @since 1.14.3\n     @see #trackNewlines(boolean)\n     */\n    String posLineCol() {\n        return lineNumber() + \":\" + columnNumber();\n    }\n\n    private int lineNumIndex(int pos) {\n        if (!isTrackNewlines()) return 0;\n        int i = Collections.binarySearch(newlinePositions, pos);\n        if (i < -1) i = Math.abs(i) - 2;\n        return i;\n    }\n\n    /**\n     Scans the buffer for newline position, and tracks their location in newlinePositions.\n     */\n    private void scanBufferForNewlines() {\n        if (!isTrackNewlines())\n            return;\n\n        if (newlinePositions.size() > 0) {\n            // work out the line number that we have read up to (as we have likely scanned past this point)\n            int index = lineNumIndex(consumed);\n            if (index == -1) index = 0; // first line\n            int linePos = newlinePositions.get(index);\n            lineNumberOffset += index; // the num lines we've read up to\n            newlinePositions.clear();\n            newlinePositions.add(linePos); // roll the last read pos to first, for cursor num after buffer\n        }\n\n        for (int i = bufPos; i < bufLength; i++) {\n            if (charBuf[i] == '\\n')\n                newlinePositions.add(1 + consumed + i);\n        }\n    }\n\n    /**\n     * Tests if all the content has been read.\n     * @return true if nothing left to read.\n     */\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    /**\n     * Get the char at the current position.\n     * @return char\n     */\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    /**\n     Unconsume one character (bufPos--). MUST only be called directly after a consume(), and no chance of a bufferUp.\n     */\n    void unconsume() {\n        if (bufPos < 1)\n            throw new UncheckedIOException(new IOException(\"WTF: No buffer left to unconsume.\")); // a bug if this fires, need to trace it.\n\n        bufPos--;\n    }\n\n    /**\n     * Moves the current position by one.\n     */\n    public void advance() {\n        bufPos++;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input char\n     * @param c scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i])\n                return i - bufPos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        bufferUp();\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != charBuf[offset])\n                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < bufLength && last <= bufLength) {\n                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                if (i == last) // found full sequence\n                    return offset - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Reads characters up to the specific char.\n     * @param c the delimiter\n     * @return the chars read\n     */\n    public String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else if (bufLength - bufPos < seq.length()) {\n            // nextIndexOf() did a bufferUp(), so if the buffer is shorter than the search string, we must be at EOF\n            return consumeToEnd();\n        } else {\n            // the string we're looking for may be straddling a buffer boundary, so keep (length - 1) characters\n            // unread in case they contain the beginning of the search string\n            int endPos = bufLength - seq.length() + 1;\n            String consumed = cacheString(charBuf, stringCache, bufPos, endPos - bufPos);\n            bufPos = endPos;\n            return consumed;\n        }\n    }\n\n    /**\n     * Read characters until the first of any delimiters is found.\n     * @param chars delimiters to scan for\n     * @return characters read up to the matched delimiter.\n     */\n    public String consumeToAny(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        final int charLen = chars.length;\n        int i;\n\n        OUTER: while (pos < remaining) {\n            for (i = 0; i < charLen; i++) {\n                if (val[pos] == chars[i])\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (pos < remaining) {\n            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n                break;\n            pos++;\n        }\n        bufPos = pos;\n        return bufPos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeData() {\n        // &, <, null\n        //bufferUp(); // no need to bufferUp, just called consume()\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '&':\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                default:\n                    pos++;\n            }\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeAttributeQuoted(final boolean single) {\n        // null, \" or ', &\n        //bufferUp(); // no need to bufferUp, just called consume()\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '&':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                case '\\'':\n                    if (single) break OUTER;\n                    break;\n                case '\"':\n                    if (!single) break OUTER;\n                    break;\n            }\n            pos++;\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n\n    String consumeRawData() {\n        // <, null\n        //bufferUp(); // no need to bufferUp, just called consume()\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '<':\n                case TokeniserState.nullChar:\n                    break OUTER;\n                default:\n                    pos++;\n            }\n        }\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>'\n        // NOTE: out of spec, added '<' to fix common author bugs; does not stop and append on nullChar but eats\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        OUTER: while (pos < remaining) {\n            switch (val[pos]) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                case '/':\n                case '>':\n                case '<':\n                    break OUTER;\n            }\n            pos++;\n        }\n\n        bufPos = pos;\n        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : \"\";\n    }\n\n    String consumeToEnd() {\n        bufferUp();\n        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n                bufPos++;\n            else\n                break;\n        }\n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if (c >= '0' && c <= '9')\n                bufPos++;\n            else\n                break;\n        }\n        return cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return !isEmpty() && charBuf[bufPos] == c;\n\n    }\n\n    boolean matches(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++)\n            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                return false;\n        return true;\n    }\n\n    boolean matchesIgnoreCase(String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > bufLength - bufPos)\n            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    /**\n     Checks if the current pos matches an ascii alpha (A-Z a-z) per https://infra.spec.whatwg.org/#ascii-alpha\n     @return if it matches or not\n     */\n    boolean matchesAsciiAlpha() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = charBuf[bufPos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // we maintain a cache of the previously scanned sequence, and return that if applicable on repeated scans.\n    // that improves the situation where there is a sequence of <p<p<p<p<p<p<p...</title> and we're bashing on the <p\n    // looking for the </title>. Resets in bufferUp()\n    @Nullable private String lastIcSeq; // scan cache\n    private int lastIcIndex; // nearest found indexOf\n\n    /** Used to check presence of </title>, </style> when we're in RCData and see a <xxx. Only finds consistent case. */\n    boolean containsIgnoreCase(String seq) {\n        if (seq.equals(lastIcSeq)) {\n            if (lastIcIndex == -1) return false;\n            if (lastIcIndex >= bufPos) return true;\n        }\n        lastIcSeq = seq;\n\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        int lo = nextIndexOf(loScan);\n        if (lo > -1) {\n            lastIcIndex = bufPos + lo; return true;\n        }\n\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n        int hi = nextIndexOf(hiScan);\n        boolean found = hi > -1;\n        lastIcIndex = found ? bufPos + hi : -1; // we don't care about finding the nearest, just that buf contains\n        return found;\n    }\n\n    @Override\n    public String toString() {\n        if (bufLength - bufPos < 0)\n            return \"\";\n        return new String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    /**\n     * Caches short strings, as a flyweight pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        if (count > MaxStringCacheLen) // don't cache strings that are too big\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";\n\n        // calculate hash:\n        int hash = 0;\n        int end = count + start;\n        for (int i = start; i < end; i++) {\n            hash = 31 * hash + charBuf[i];\n        }\n\n        // get from cache\n        final int index = hash & StringCacheSize - 1;\n        String cached = stringCache[index];\n\n        if (cached != null && rangeEquals(charBuf, start, count, cached)) // positive hit\n            return cached;\n        else {\n            cached = new String(charBuf, start, count);\n            stringCache[index] = cached; // add or replace, assuming most recently used are most likely to recur next\n        }\n\n        return cached;\n    }\n\n    /**\n     * Check if the value of the provided range equals the string.\n     */\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while (count-- != 0) {\n                if (charBuf[i++] != cached.charAt(j++))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    // just used for testing\n    boolean rangeEquals(final int start, final int count, final String cached) {\n        return rangeEquals(charBuf, start, count, cached);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final char EOF = (char) -1;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "EOF = (char) -1", "syntax_pass": true}, {"attribute_expression": "private static final int MaxStringCacheLen = 12;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "MaxStringCacheLen = 12", "syntax_pass": true}, {"attribute_expression": "private static final int StringCacheSize = 512;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "StringCacheSize = 512", "syntax_pass": true}, {"attribute_expression": "private String[] stringCache;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String[]", "name": "stringCache", "syntax_pass": true}, {"attribute_expression": "private static final SoftPool<String[]> StringPool = new SoftPool<>(() -> new String[StringCacheSize]);", "docstring": " holds reused strings in this doc, to lessen garbage", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "SoftPool<String[]>", "name": "StringPool = new SoftPool<>(() -> new String[StringCacheSize])", "syntax_pass": true}, {"attribute_expression": "static final int BufferSize = 1024 * 2;", "docstring": " reuse cache between iterations", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "BufferSize = 1024 * 2", "syntax_pass": true}, {"attribute_expression": "static final int RefillPoint = BufferSize / 2;", "docstring": " visible for testing", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "RefillPoint = BufferSize / 2", "syntax_pass": true}, {"attribute_expression": "private static final int RewindLimit = 1024;", "docstring": " when bufPos characters read, refill; visible for testing", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "RewindLimit = 1024", "syntax_pass": true}, {"attribute_expression": "private Reader reader;", "docstring": " the maximum we can rewind. No HTML entities can be larger than this.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Reader", "name": "reader", "syntax_pass": true}, {"attribute_expression": "private char[] charBuf;", "docstring": " underlying Reader, will be backed by a buffered+controlled input stream, or StringReader", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "char[]", "name": "charBuf", "syntax_pass": true}, {"attribute_expression": "private int bufPos;", "docstring": " character buffer we consume from; filled from Reader", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bufPos", "syntax_pass": true}, {"attribute_expression": "private int bufLength;", "docstring": " position in charBuf that's been consumed to", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bufLength", "syntax_pass": true}, {"attribute_expression": "private int fillPoint = 0;", "docstring": " the num of characters actually buffered in charBuf, <= charBuf.length", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "fillPoint = 0", "syntax_pass": true}, {"attribute_expression": "private int consumed;", "docstring": " how far into the charBuf we read before re-filling. 0.5 of charBuf.length after bufferUp", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "consumed", "syntax_pass": true}, {"attribute_expression": "private int bufMark = -1;", "docstring": " how many characters total have been consumed from this CharacterReader (less the current bufPos)", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bufMark = -1", "syntax_pass": true}, {"attribute_expression": "private boolean readFully;", "docstring": " if not -1, the marked rewind position", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "readFully", "syntax_pass": true}, {"attribute_expression": "private static final SoftPool<char[]> BufferPool = new SoftPool<>(() -> new char[BufferSize]);", "docstring": " if the underlying stream has been completely read, no value in further buffering", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "SoftPool<char[]>", "name": "BufferPool = new SoftPool<>(() -> new char[BufferSize])", "syntax_pass": true}, {"attribute_expression": "@Nullable private ArrayList<Integer> newlinePositions = null;", "docstring": " recycled char buffer", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "newlinePositions = null", "syntax_pass": true}, {"attribute_expression": "private int lineNumberOffset = 1;", "docstring": " optionally track the pos() position of newlines - scans during bufferUp()", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lineNumberOffset = 1", "syntax_pass": true}, {"attribute_expression": "@Nullable private String lastIcSeq;", "docstring": " looking for the </title>. Resets in bufferUp()", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "lastIcSeq", "syntax_pass": true}, {"attribute_expression": "private int lastIcIndex;", "docstring": " scan cache", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lastIcIndex", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser", "name": "Tokeniser", "file_path": "src/main/java/org/jsoup/parser/Tokeniser.java", "superclasses": "", "methods": ["[]Tokeniser(TreeBuilder)", "[Token]read()", "[void]emit(Token)", "[void]emit(String)", "[void]emit(StringBuilder)", "[void]emit(char)", "[void]emit(char[])", "[void]emit(int[])", "[TokeniserState]getState()", "[void]transition(TokeniserState)", "[void]advanceTransition(TokeniserState)", "[int[]]consumeCharacterReference(Character,boolean)", "[Token.Tag]createTagPending(boolean)", "[void]emitTagPending()", "[void]createCommentPending()", "[void]emitCommentPending()", "[void]createBogusCommentPending()", "[void]createDoctypePending()", "[void]emitDoctypePending()", "[void]createTempBuffer()", "[boolean]isAppropriateEndTagToken()", "[String]appropriateEndTagName()", "[String]appropriateEndTagSeq()", "[void]error(TokeniserState)", "[void]eofError(TokeniserState)", "[void]characterReferenceError(String)", "[void]error(String)", "[void]error(String)", "[boolean]currentNodeInHtmlNS()", "[String]unescapeEntities(boolean)"], "method_uris": ["src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[]Tokeniser(TreeBuilder)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[Token]read()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(Token)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(String)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(StringBuilder)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(char)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(char[])", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emit(int[])", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[TokeniserState]getState()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]transition(TokeniserState)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]advanceTransition(TokeniserState)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[int[]]consumeCharacterReference(Character,boolean)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[Token.Tag]createTagPending(boolean)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emitTagPending()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]createCommentPending()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emitCommentPending()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]createBogusCommentPending()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]createDoctypePending()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]emitDoctypePending()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]createTempBuffer()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[boolean]isAppropriateEndTagToken()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[String]appropriateEndTagName()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[String]appropriateEndTagSeq()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]error(TokeniserState)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]eofError(TokeniserState)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]characterReferenceError(String)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]error(String)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[void]error(String)", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[boolean]currentNodeInHtmlNS()", "src/main/java/org/jsoup/parser/Tokeniser.java.Tokeniser.[String]unescapeEntities(boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nReaders the input stream into tokens.\n", "original_string": "final class Tokeniser {\n    static final char replacementChar = '\\uFFFD'; // replaces null character\n    private static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'};\n\n    // Some illegal character escapes are parsed by browsers as windows-1252 instead. See issue #1034\n    // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\n    static final int win1252ExtensionsStart = 0x80;\n    static final int[] win1252Extensions = new int[] {\n            // we could build this manually, but Windows-1252 is not a standard java charset so that could break on\n            // some platforms - this table is verified with a test\n            0x20AC, 0x0081, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,\n            0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008D, 0x017D, 0x008F,\n            0x0090, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,\n            0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x009D, 0x017E, 0x0178,\n    };\n\n    static {\n        Arrays.sort(notCharRefCharsSorted);\n    }\n\n    private final CharacterReader reader; // html input\n    private final ParseErrorList errors; // errors found while tokenising\n\n    private TokeniserState state = TokeniserState.Data; // current tokenisation state\n    @Nullable private Token emitPending = null; // the token we are about to emit on next read\n    private boolean isEmitPending = false;\n    @Nullable private String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one\n    private final StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read\n    final StringBuilder dataBuffer = new StringBuilder(1024); // buffers data looking for </script>\n\n    final Token.StartTag startPending;\n    final Token.EndTag endPending;\n    Token.Tag tagPending; // tag we are building up: start or end pending\n    final Token.Character charPending = new Token.Character();\n    final Token.Doctype doctypePending = new Token.Doctype(); // doctype building up\n    final Token.Comment commentPending = new Token.Comment(); // comment building up\n    @Nullable private String lastStartTag; // the last start tag emitted, to test appropriate end tag\n    @Nullable private String lastStartCloseSeq; // \"</\" + lastStartTag, so we can quickly check for that in RCData\n\n    private int markupStartPos, charStartPos = 0; // reader pos at the start of markup / characters. markup updated on state transition, char on token emit.\n\n    Tokeniser(TreeBuilder treeBuilder) {\n        tagPending = startPending  = new Token.StartTag(treeBuilder);\n        endPending = new Token.EndTag(treeBuilder);\n        this.reader = treeBuilder.reader;\n        this.errors = treeBuilder.parser.getErrors();\n    }\n\n    Token read() {\n        while (!isEmitPending) {\n            state.read(this, reader);\n        }\n\n        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n        final StringBuilder cb = this.charsBuilder;\n        if (cb.length() != 0) {\n            String str = cb.toString();\n            cb.delete(0, cb.length());\n            Token token = charPending.data(str);\n            charsString = null;\n            return token;\n        } else if (charsString != null) {\n            Token token = charPending.data(charsString);\n            charsString = null;\n            return token;\n        } else {\n            isEmitPending = false;\n            assert emitPending != null;\n            return emitPending;\n        }\n    }\n\n    void emit(Token token) {\n        Validate.isFalse(isEmitPending);\n\n        emitPending = token;\n        isEmitPending = true;\n        token.startPos(markupStartPos);\n        token.endPos(reader.pos());\n        charStartPos = reader.pos(); // update char start when we complete a token emit\n\n        if (token.type == Token.TokenType.StartTag) {\n            Token.StartTag startTag = (Token.StartTag) token;\n            lastStartTag = startTag.tagName;\n            lastStartCloseSeq = null; // only lazy inits\n        } else if (token.type == Token.TokenType.EndTag) {\n            Token.EndTag endTag = (Token.EndTag) token;\n            if (endTag.hasAttributes())\n                error(\"Attributes incorrectly present on end tag [/%s]\", endTag.normalName());\n        }\n    }\n\n    void emit(final String str) {\n        // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n        // does not set isEmitPending; read checks that\n        if (charsString == null) {\n            charsString = str;\n        } else {\n            if (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\n                charsBuilder.append(charsString);\n            }\n            charsBuilder.append(str);\n        }\n        charPending.startPos(charStartPos);\n        charPending.endPos(reader.pos());\n    }\n\n    // variations to limit need to create temp strings\n    void emit(final StringBuilder str) {\n        if (charsString == null) {\n            charsString = str.toString();\n        } else {\n            if (charsBuilder.length() == 0) {\n                charsBuilder.append(charsString);\n            }\n            charsBuilder.append(str);\n        }\n        charPending.startPos(charStartPos);\n        charPending.endPos(reader.pos());\n    }\n\n    void emit(char c) {\n        if (charsString == null) {\n            charsString = String.valueOf(c);\n        } else {\n            if (charsBuilder.length() == 0) {\n                charsBuilder.append(charsString);\n            }\n            charsBuilder.append(c);\n        }\n        charPending.startPos(charStartPos);\n        charPending.endPos(reader.pos());\n    }\n\n    void emit(char[] chars) {\n        emit(String.valueOf(chars));\n    }\n\n    void emit(int[] codepoints) {\n        emit(new String(codepoints, 0, codepoints.length));\n    }\n\n    TokeniserState getState() {\n        return state;\n    }\n\n    void transition(TokeniserState newState) {\n        // track markup position on state transitions\n        if (newState == TokeniserState.TagOpen)\n            markupStartPos = reader.pos();\n\n        this.state = newState;\n    }\n\n    void advanceTransition(TokeniserState newState) {\n        transition(newState);\n        reader.advance();\n    }\n\n    final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays\n    final private int[] multipointHolder = new int[2];\n    @Nullable int[] consumeCharacterReference(@Nullable Character additionalAllowedCharacter, boolean inAttribute) {\n        if (reader.isEmpty())\n            return null;\n        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n            return null;\n        if (reader.matchesAnySorted(notCharRefCharsSorted))\n            return null;\n\n        final int[] codeRef = codepointHolder;\n        reader.mark();\n        if (reader.matchConsume(\"#\")) { // numbered\n            boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n            if (numRef.length() == 0) { // didn't match anything\n                characterReferenceError(\"numeric reference with no numerals\");\n                reader.rewindToMark();\n                return null;\n            }\n\n            reader.unmark();\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon on [&#%s]\", numRef); // missing semi\n            int charval = -1;\n            try {\n                int base = isHexMode ? 16 : 10;\n                charval = Integer.valueOf(numRef, base);\n            } catch (NumberFormatException ignored) {\n                // skip\n            }\n            // todo: check for extra illegal unicode points as parse errors - described https://html.spec.whatwg.org/multipage/syntax.html#character-references and in Infra\n            // The numeric character reference forms described above are allowed to reference any code point excluding U+000D CR, noncharacters, and controls other than ASCII whitespace.\n            if (charval == -1 || charval > 0x10FFFF) {\n                characterReferenceError(\"character [%s] outside of valid range\", charval);\n                codeRef[0] = replacementChar;\n            } else {\n                // fix illegal unicode characters to match browser behavior\n                if (charval >= win1252ExtensionsStart && charval < win1252ExtensionsStart + win1252Extensions.length) {\n                    characterReferenceError(\"character [%s] is not a valid unicode code point\", charval);\n                    charval = win1252Extensions[charval - win1252ExtensionsStart];\n                }\n\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                codeRef[0] = charval;\n            }\n            return codeRef;\n        } else { // named\n            // get as many letters as possible, and look for matching entities.\n            String nameRef = reader.consumeLetterThenDigitSequence();\n            boolean looksLegit = reader.matches(';');\n            // found if a base named entity without a ;, or an extended entity with the ;.\n            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n\n            if (!found) {\n                reader.rewindToMark();\n                if (looksLegit) // named with semicolon\n                    characterReferenceError(\"invalid named reference [%s]\", nameRef);\n                return null;\n            }\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n\n            reader.unmark();\n            if (!reader.matchConsume(\";\"))\n                characterReferenceError(\"missing semicolon on [&%s]\", nameRef); // missing semi\n            int numChars = Entities.codepointsForName(nameRef, multipointHolder);\n            if (numChars == 1) {\n                codeRef[0] = multipointHolder[0];\n                return codeRef;\n            } else if (numChars ==2) {\n                return multipointHolder;\n            } else {\n                Validate.fail(\"Unexpected characters returned for \" + nameRef);\n                return multipointHolder;\n            }\n        }\n    }\n\n    Token.Tag createTagPending(boolean start) {\n        tagPending = start ? startPending.reset() : endPending.reset();\n        return tagPending;\n    }\n\n    void emitTagPending() {\n        tagPending.finaliseTag();\n        emit(tagPending);\n    }\n\n    void createCommentPending() {\n        commentPending.reset();\n    }\n\n    void emitCommentPending() {\n        emit(commentPending);\n    }\n\n    void createBogusCommentPending() {\n        commentPending.reset();\n        commentPending.bogus = true;\n    }\n\n    void createDoctypePending() {\n        doctypePending.reset();\n    }\n\n    void emitDoctypePending() {\n        emit(doctypePending);\n    }\n\n    void createTempBuffer() {\n        Token.reset(dataBuffer);\n    }\n\n    boolean isAppropriateEndTagToken() {\n        return lastStartTag != null && tagPending.name().equalsIgnoreCase(lastStartTag);\n    }\n\n    @Nullable String appropriateEndTagName() {\n        return lastStartTag; // could be null\n    }\n\n    /** Returns the closer sequence {@code </lastStart} */\n    String appropriateEndTagSeq() {\n        if (lastStartCloseSeq == null) // reset on start tag emit\n            lastStartCloseSeq = \"</\" + lastStartTag;\n        return lastStartCloseSeq;\n    }\n\n    void error(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n    }\n\n    void eofError(TokeniserState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n    }\n\n    private void characterReferenceError(String message, Object... args) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, String.format(\"Invalid character reference: \" + message, args)));\n    }\n\n    void error(String errorMsg) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, errorMsg));\n    }\n\n    void error(String errorMsg, Object... args) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader, errorMsg, args));\n    }\n\n    static boolean currentNodeInHtmlNS() {\n        // todo: implement namespaces correctly\n        return true;\n        // Element currentNode = currentNode();\n        // return currentNode != null && currentNode.namespace().equals(\"HTML\");\n    }\n\n    /**\n     * Utility method to consume reader and unescape entities found within.\n     * @param inAttribute if the text to be unescaped is in an attribute\n     * @return unescaped string from reader\n     */\n    String unescapeEntities(boolean inAttribute) {\n        StringBuilder builder = StringUtil.borrowBuilder();\n        while (!reader.isEmpty()) {\n            builder.append(reader.consumeTo('&'));\n            if (reader.matches('&')) {\n                reader.consume();\n                int[] c = consumeCharacterReference(null, inAttribute);\n                if (c == null || c.length==0)\n                    builder.append('&');\n                else {\n                    builder.appendCodePoint(c[0]);\n                    if (c.length == 2)\n                        builder.appendCodePoint(c[1]);\n                }\n\n            }\n        }\n        return StringUtil.releaseBuilder(builder);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final char replacementChar = '\\uFFFD';", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "replacementChar = '\\uFFFD'", "syntax_pass": true}, {"attribute_expression": "private static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'};", "docstring": " replaces null character", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char[]", "name": "notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'}", "syntax_pass": true}, {"attribute_expression": "static final int win1252ExtensionsStart = 0x80;", "docstring": " https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "win1252ExtensionsStart = 0x80", "syntax_pass": true}, {"attribute_expression": "static final int[] win1252Extensions = new int[] {\n            // we could build this manually, but Windows-1252 is not a standard java charset so that could break on\n            // some platforms - this table is verified with a test\n            0x20AC, 0x0081, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,\n            0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008D, 0x017D, 0x008F,\n            0x0090, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,\n            0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x009D, 0x017E, 0x0178,\n    };", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int[]", "name": "win1252Extensions = new int[] {\n            // we could build this manually, but Windows-1252 is not a standard java charset so that could break on\n            // some platforms - this table is verified with a test\n            0x20AC, 0x0081, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,\n            0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008D, 0x017D, 0x008F,\n            0x0090, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,\n            0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x009D, 0x017E, 0x0178,\n    }", "syntax_pass": true}, {"attribute_expression": "private final CharacterReader reader;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CharacterReader", "name": "reader", "syntax_pass": true}, {"attribute_expression": "private final ParseErrorList errors;", "docstring": " html input", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParseErrorList", "name": "errors", "syntax_pass": true}, {"attribute_expression": "private TokeniserState state = TokeniserState.Data;", "docstring": " errors found while tokenising", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TokeniserState", "name": "state = TokeniserState.Data", "syntax_pass": true}, {"attribute_expression": "@Nullable private Token emitPending = null;", "docstring": " current tokenisation state", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Token", "name": "emitPending = null", "syntax_pass": true}, {"attribute_expression": "private boolean isEmitPending = false;", "docstring": " the token we are about to emit on next read", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isEmitPending = false", "syntax_pass": true}, {"attribute_expression": "@Nullable private String charsString = null;", "docstring": "", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "charsString = null", "syntax_pass": true}, {"attribute_expression": "private final StringBuilder charsBuilder = new StringBuilder(1024);", "docstring": " characters pending an emit. Will fall to charsBuilder if more than one", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StringBuilder", "name": "charsBuilder = new StringBuilder(1024)", "syntax_pass": true}, {"attribute_expression": "final StringBuilder dataBuffer = new StringBuilder(1024);", "docstring": " buffers characters to output as one token, if more than one emit per read", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "StringBuilder", "name": "dataBuffer = new StringBuilder(1024)", "syntax_pass": true}, {"attribute_expression": "final Token.StartTag startPending;", "docstring": " buffers data looking for </script>", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Token.StartTag", "name": "startPending", "syntax_pass": true}, {"attribute_expression": "final Token.EndTag endPending;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Token.EndTag", "name": "endPending", "syntax_pass": true}, {"attribute_expression": "Token.Tag tagPending;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Token.Tag", "name": "tagPending", "syntax_pass": true}, {"attribute_expression": "final Token.Character charPending = new Token.Character();", "docstring": " tag we are building up: start or end pending", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Token.Character", "name": "charPending = new Token.Character()", "syntax_pass": true}, {"attribute_expression": "final Token.Doctype doctypePending = new Token.Doctype();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Token.Doctype", "name": "doctypePending = new Token.Doctype()", "syntax_pass": true}, {"attribute_expression": "final Token.Comment commentPending = new Token.Comment();", "docstring": " doctype building up", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Token.Comment", "name": "commentPending = new Token.Comment()", "syntax_pass": true}, {"attribute_expression": "@Nullable private String lastStartTag;", "docstring": " comment building up", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "lastStartTag", "syntax_pass": true}, {"attribute_expression": "@Nullable private String lastStartCloseSeq;", "docstring": " the last start tag emitted, to test appropriate end tag", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "lastStartCloseSeq", "syntax_pass": true}, {"attribute_expression": "private int markupStartPos, charStartPos = 0;", "docstring": " \"</\" + lastStartTag, so we can quickly check for that in RCData", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "markupStartPos", "syntax_pass": true}, {"attribute_expression": "final private int[] codepointHolder = new int[1];", "docstring": "", "modifiers": "final private", "marker_annotations": [], "non_marker_annotations": ["final", "private"], "comments": [], "type": "int[]", "name": "codepointHolder = new int[1]", "syntax_pass": true}, {"attribute_expression": "final private int[] multipointHolder = new int[2];", "docstring": " holder to not have to keep creating arrays", "modifiers": "final private", "marker_annotations": [], "non_marker_annotations": ["final", "private"], "comments": [], "type": "int[]", "name": "multipointHolder = new int[2]", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/Parser.java.Parser", "name": "Parser", "file_path": "src/main/java/org/jsoup/parser/Parser.java", "superclasses": "", "methods": ["[]Parser(TreeBuilder)", "[Parser]newInstance()", "[]Parser(Parser)", "[Document]parseInput(String,String)", "[Document]parseInput(Reader,String)", "[List<Node>]parseFragmentInput(String,Element,String)", "[TreeBuilder]getTreeBuilder()", "[Parser]setTreeBuilder(TreeBuilder)", "[boolean]isTrackErrors()", "[Parser]setTrackErrors(int)", "[ParseErrorList]getErrors()", "[boolean]isTrackPosition()", "[Parser]setTrackPosition(boolean)", "[Parser]settings(ParseSettings)", "[ParseSettings]settings()", "[boolean]isContentForTagData(String)", "[String]defaultNamespace()", "[Document]parse(String,String)", "[List<Node>]parseFragment(String,Element,String)", "[List<Node>]parseFragment(String,Element,String,ParseErrorList)", "[List<Node>]parseXmlFragment(String,String)", "[Document]parseBodyFragment(String,String)", "[String]unescapeEntities(String,boolean)", "[Parser]htmlParser()", "[Parser]xmlParser()"], "method_uris": ["src/main/java/org/jsoup/parser/Parser.java.Parser.[]Parser(TreeBuilder)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]newInstance()", "src/main/java/org/jsoup/parser/Parser.java.Parser.[]Parser(Parser)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Document]parseInput(String,String)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Document]parseInput(Reader,String)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[List<Node>]parseFragmentInput(String,Element,String)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[TreeBuilder]getTreeBuilder()", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]setTreeBuilder(TreeBuilder)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[boolean]isTrackErrors()", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]setTrackErrors(int)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[ParseErrorList]getErrors()", "src/main/java/org/jsoup/parser/Parser.java.Parser.[boolean]isTrackPosition()", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]setTrackPosition(boolean)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]settings(ParseSettings)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[ParseSettings]settings()", "src/main/java/org/jsoup/parser/Parser.java.Parser.[boolean]isContentForTagData(String)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[String]defaultNamespace()", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Document]parse(String,String)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[List<Node>]parseFragment(String,Element,String)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[List<Node>]parseFragment(String,Element,String,ParseErrorList)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[List<Node>]parseXmlFragment(String,String)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Document]parseBodyFragment(String,String)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[String]unescapeEntities(String,boolean)", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]htmlParser()", "src/main/java/org/jsoup/parser/Parser.java.Parser.[Parser]xmlParser()"], "overrides": null, "attributes": [], "class_docstring": "\nParses HTML or XML into a {@link org.jsoup.nodes.Document}. Generally, it is simpler to use one of the parse methods in\n{@link org.jsoup.Jsoup}.\n<p>Note that a Parser instance object is not threadsafe. To reuse a Parser configuration in a multi-threaded\nenvironment, use {@link #newInstance()} to make copies.", "original_string": "public class Parser {\n    public static final String NamespaceHtml = \"http://www.w3.org/1999/xhtml\";\n    public static final String NamespaceXml = \"http://www.w3.org/XML/1998/namespace\";\n    public static final String NamespaceMathml = \"http://www.w3.org/1998/Math/MathML\";\n    public static final String NamespaceSvg = \"http://www.w3.org/2000/svg\";\n\n    private TreeBuilder treeBuilder;\n    private ParseErrorList errors;\n    private ParseSettings settings;\n    private boolean trackPosition = false;\n\n    /**\n     * Create a new Parser, using the specified TreeBuilder\n     * @param treeBuilder TreeBuilder to use to parse input into Documents.\n     */\n    public Parser(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        settings = treeBuilder.defaultSettings();\n        errors = ParseErrorList.noTracking();\n    }\n\n    /**\n     Creates a new Parser as a deep copy of this; including initializing a new TreeBuilder. Allows independent (multi-threaded) use.\n     @return a copied parser\n     */\n    public Parser newInstance() {\n        return new Parser(this);\n    }\n\n    private Parser(Parser copy) {\n        treeBuilder = copy.treeBuilder.newInstance(); // because extended\n        errors = new ParseErrorList(copy.errors); // only copies size, not contents\n        settings = new ParseSettings(copy.settings);\n        trackPosition = copy.trackPosition;\n    }\n    \n    public Document parseInput(String html, String baseUri) {\n        return treeBuilder.parse(new StringReader(html), baseUri, this);\n    }\n\n    public Document parseInput(Reader inputHtml, String baseUri) {\n        return treeBuilder.parse(inputHtml, baseUri, this);\n    }\n\n    public List<Node> parseFragmentInput(String fragment, @Nullable Element context, String baseUri) {\n        return treeBuilder.parseFragment(fragment, context, baseUri, this);\n    }\n    // gets & sets\n    /**\n     * Get the TreeBuilder currently in use.\n     * @return current TreeBuilder.\n     */\n    public TreeBuilder getTreeBuilder() {\n        return treeBuilder;\n    }\n\n    /**\n     * Update the TreeBuilder used when parsing content.\n     * @param treeBuilder new TreeBuilder\n     * @return this, for chaining\n     */\n    public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n        this.treeBuilder = treeBuilder;\n        treeBuilder.parser = this;\n        return this;\n    }\n\n    /**\n     * Check if parse error tracking is enabled.\n     * @return current track error state.\n     */\n    public boolean isTrackErrors() {\n        return errors.getMaxSize() > 0;\n    }\n\n    /**\n     * Enable or disable parse error tracking for the next parse.\n     * @param maxErrors the maximum number of errors to track. Set to 0 to disable.\n     * @return this, for chaining\n     */\n    public Parser setTrackErrors(int maxErrors) {\n        errors = maxErrors > 0 ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n        return this;\n    }\n\n    /**\n     * Retrieve the parse errors, if any, from the last parse.\n     * @return list of parse errors, up to the size of the maximum errors tracked.\n     * @see #setTrackErrors(int)\n     */\n    public ParseErrorList getErrors() {\n        return errors;\n    }\n\n    /**\n     Test if position tracking is enabled. If it is, Nodes will have a Position to track where in the original input\n     source they were created from. By default, tracking is not enabled.\n     * @return current track position setting\n     */\n    public boolean isTrackPosition() {\n        return trackPosition;\n    }\n\n    /**\n     Enable or disable source position tracking. If enabled, Nodes will have a Position to track where in the original\n     input source they were created from.\n     @param trackPosition position tracking setting; {@code true} to enable\n     @return this Parser, for chaining\n     */\n    public Parser setTrackPosition(boolean trackPosition) {\n        this.trackPosition = trackPosition;\n        return this;\n    }\n\n    /**\n     Update the ParseSettings of this Parser, to control the case sensitivity of tags and attributes.\n     * @param settings the new settings\n     * @return this Parser\n     */\n    public Parser settings(ParseSettings settings) {\n        this.settings = settings;\n        return this;\n    }\n\n    /**\n     Gets the current ParseSettings for this Parser\n     * @return current ParseSettings\n     */\n    public ParseSettings settings() {\n        return settings;\n    }\n\n    /**\n     (An internal method, visible for Element. For HTML parse, signals that script and style text should be treated as\n     Data Nodes).\n     */\n    public boolean isContentForTagData(String normalName) {\n        return getTreeBuilder().isContentForTagData(normalName);\n    }\n\n    public String defaultNamespace() {\n        return getTreeBuilder().defaultNamespace();\n    }\n\n    // static parse functions below\n    /**\n     * Parse HTML into a Document.\n     *\n     * @param html HTML to parse\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return parsed Document\n     */\n    public static Document parse(String html, String baseUri) {\n        TreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parse(new StringReader(html), baseUri, new Parser(treeBuilder));\n    }\n\n    /**\n     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n     *\n     * @param fragmentHtml the fragment of HTML to parse\n     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n     * provides stack context (for implicit element creation).\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n     */\n    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, new Parser(treeBuilder));\n    }\n\n    /**\n     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n     *\n     * @param fragmentHtml the fragment of HTML to parse\n     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n     * provides stack context (for implicit element creation).\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     * @param errorList list to add errors to\n     *\n     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n     */\n    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n        Parser parser = new Parser(treeBuilder);\n        parser.errors = errorList;\n        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, parser);\n    }\n\n    /**\n     * Parse a fragment of XML into a list of nodes.\n     *\n     * @param fragmentXml the fragment of XML to parse\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     * @return list of nodes parsed from the input XML.\n     */\n    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n        return treeBuilder.parseFragment(fragmentXml, null, baseUri, new Parser(treeBuilder));\n    }\n\n    /**\n     * Parse a fragment of HTML into the {@code body} of a Document.\n     *\n     * @param bodyHtml fragment of HTML\n     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     *\n     * @return Document, with empty head, and HTML parsed into body\n     */\n    public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n        Document doc = Document.createShell(baseUri);\n        Element body = doc.body();\n        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n        Node[] nodes = nodeList.toArray(new Node[0]); // the node list gets modified when re-parented\n        for (int i = nodes.length - 1; i > 0; i--) {\n            nodes[i].remove();\n        }\n        for (Node node : nodes) {\n            body.appendChild(node);\n        }\n        return doc;\n    }\n\n    /**\n     * Utility method to unescape HTML entities from a string\n     * @param string HTML escaped string\n     * @param inAttribute if the string is to be escaped in strict mode (as attributes are)\n     * @return an unescaped string\n     */\n    public static String unescapeEntities(String string, boolean inAttribute) {\n        Parser parser = Parser.htmlParser();\n        parser.treeBuilder.initialiseParse(new StringReader(string), \"\", parser);\n        Tokeniser tokeniser = new Tokeniser(parser.treeBuilder);\n        return tokeniser.unescapeEntities(inAttribute);\n    }\n\n    // builders\n\n    /**\n     * Create a new HTML parser. This parser treats input as HTML5, and enforces the creation of a normalised document,\n     * based on a knowledge of the semantics of the incoming tags.\n     * @return a new HTML parser.\n     */\n    public static Parser htmlParser() {\n        return new Parser(new HtmlTreeBuilder());\n    }\n\n    /**\n     * Create a new XML parser. This parser assumes no knowledge of the incoming tags and does not treat it as HTML,\n     * rather creates a simple tree directly from the input.\n     * @return a new simple XML parser.\n     */\n    public static Parser xmlParser() {\n        return new Parser(new XmlTreeBuilder());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NamespaceHtml = \"http://www.w3.org/1999/xhtml\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NamespaceHtml = \"http://www.w3.org/1999/xhtml\"", "syntax_pass": true}, {"attribute_expression": "public static final String NamespaceXml = \"http://www.w3.org/XML/1998/namespace\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NamespaceXml = \"http://www.w3.org/XML/1998/namespace\"", "syntax_pass": true}, {"attribute_expression": "public static final String NamespaceMathml = \"http://www.w3.org/1998/Math/MathML\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NamespaceMathml = \"http://www.w3.org/1998/Math/MathML\"", "syntax_pass": true}, {"attribute_expression": "public static final String NamespaceSvg = \"http://www.w3.org/2000/svg\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NamespaceSvg = \"http://www.w3.org/2000/svg\"", "syntax_pass": true}, {"attribute_expression": "private TreeBuilder treeBuilder;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TreeBuilder", "name": "treeBuilder", "syntax_pass": true}, {"attribute_expression": "private ParseErrorList errors;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParseErrorList", "name": "errors", "syntax_pass": true}, {"attribute_expression": "private ParseSettings settings;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParseSettings", "name": "settings", "syntax_pass": true}, {"attribute_expression": "private boolean trackPosition = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "trackPosition = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue", "name": "TokenQueue", "file_path": "src/main/java/org/jsoup/parser/TokenQueue.java", "superclasses": "", "methods": ["[]TokenQueue(String)", "[boolean]isEmpty()", "[int]remainingLength()", "[void]addFirst(String)", "[boolean]matches(String)", "[boolean]matchesAny()", "[boolean]matchesAny()", "[boolean]matchChomp(String)", "[boolean]matchesWhitespace()", "[boolean]matchesWord()", "[void]advance()", "[char]consume()", "[void]consume(String)", "[String]consumeTo(String)", "[String]consumeToIgnoreCase(String)", "[String]consumeToAny()", "[String]chompTo(String)", "[String]chompToIgnoreCase(String)", "[String]chompBalanced(char,char)", "[String]unescape(String)", "[String]escapeCssIdentifier(String)", "[boolean]consumeWhitespace()", "[String]consumeWord()", "[String]consumeElementSelector()", "[String]consumeCssIdentifier()", "[String]consumeEscapedCssIdentifier()", "[boolean]matchesCssIdentifier()", "[String]remainder()", "[String]toString()"], "method_uris": ["src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[]TokenQueue(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]isEmpty()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[int]remainingLength()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[void]addFirst(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matches(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesAny()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesAny()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchChomp(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesWhitespace()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesWord()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[void]advance()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[char]consume()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[void]consume(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeTo(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeToIgnoreCase(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeToAny()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]chompTo(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]chompToIgnoreCase(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]chompBalanced(char,char)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]unescape(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]escapeCssIdentifier(String)", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]consumeWhitespace()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeWord()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeElementSelector()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeCssIdentifier()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]consumeEscapedCssIdentifier()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[boolean]matchesCssIdentifier()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]remainder()", "src/main/java/org/jsoup/parser/TokenQueue.java.TokenQueue.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nA character queue with parsing helpers.\n\n@author Jonathan Hedley\n", "original_string": "public class TokenQueue {\n    private String queue;\n    private int pos = 0;\n    \n    private static final char ESC = '\\\\'; // escape char for chomp balanced.\n\n    /**\n     Create a new TokenQueue.\n     @param data string of data to back queue.\n     */\n    public TokenQueue(String data) {\n        Validate.notNull(data);\n        queue = data;\n    }\n\n    /**\n     * Is the queue empty?\n     * @return true if no data left in queue.\n     */\n    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }\n    \n    private int remainingLength() {\n        return queue.length() - pos;\n    }\n\n    /**\n     Add a string to the start of the queue.\n     @param seq string to add.\n     */\n    public void addFirst(String seq) {\n        // not very performant, but an edge case\n        queue = seq + queue.substring(pos);\n        pos = 0;\n    }\n\n    /**\n     * Tests if the next characters on the queue match the sequence. Case insensitive.\n     * @param seq String to check queue for.\n     * @return true if the next characters match.\n     */\n    public boolean matches(String seq) {\n        return queue.regionMatches(true, pos, seq, 0, seq.length());\n    }\n\n    /**\n     Tests if the next characters match any of the sequences. Case insensitive.\n     @param seq list of strings to case insensitively check for\n     @return true of any matched, false if none did\n     */\n    public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }\n\n    public boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        for (char c: seq) {\n            if (queue.charAt(pos) == c)\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n     * queue.\n     * @param seq String to search for, and if found, remove from queue.\n     * @return true if found and removed, false if not found.\n     */\n    public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     Tests if queue starts with a whitespace character.\n     @return if starts with whitespace\n     */\n    public boolean matchesWhitespace() {\n        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n    }\n\n    /**\n     Test if the queue matches a word character (letter or digit).\n     @return if matches a word character\n     */\n    public boolean matchesWord() {\n        return !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n    }\n\n    /**\n     * Drops the next character off the queue.\n     */\n    public void advance() {\n        if (!isEmpty()) pos++;\n    }\n\n    /**\n     * Consume one character off queue.\n     * @return first character on queue.\n     */\n    public char consume() {\n        return queue.charAt(pos++);\n    }\n\n    /**\n     * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will\n     * throw an illegal state exception -- but you should be running match() against that condition.\n     <p>\n     Case insensitive.\n     * @param seq sequence to remove from head of queue.\n     */\n    public void consume(String seq) {\n        if (!matches(seq))\n            throw new IllegalStateException(\"Queue did not match expected sequence\");\n        int len = seq.length();\n        if (len > remainingLength())\n            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n        \n        pos += len;\n    }\n\n    /**\n     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n     * @param seq String to end on (and not include in return, but leave on queue). <b>Case sensitive.</b>\n     * @return The matched data consumed from queue.\n     */\n    public String consumeTo(String seq) {\n        int offset = queue.indexOf(seq, pos);\n        if (offset != -1) {\n            String consumed = queue.substring(pos, offset);\n            pos += consumed.length();\n            return consumed;\n        } else {\n            return remainder();\n        }\n    }\n    \n    public String consumeToIgnoreCase(String seq) {\n        int start = pos;\n        String first = seq.substring(0, 1);\n        boolean canScan = first.toLowerCase().equals(first.toUpperCase()); // if first is not cased, use index of\n        while (!isEmpty()) {\n            if (matches(seq))\n                break;\n            \n            if (canScan) {\n                int skip = queue.indexOf(first, pos) - pos;\n                if (skip == 0) // this char is the skip char, but not match, so force advance of pos\n                    pos++;\n                else if (skip < 0) // no chance of finding, grab to end\n                    pos = queue.length();\n                else\n                    pos += skip;\n            }\n            else\n                pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     Consumes to the first sequence provided, or to the end of the queue. Leaves the terminator on the queue.\n     @param seq any number of terminators to consume to. <b>Case insensitive.</b>\n     @return consumed string   \n     */\n    // todo: method name. not good that consumeTo cares for case, and consume to any doesn't. And the only use for this\n    // is a case sensitive time...\n    public String consumeToAny(String... seq) {\n        int start = pos;\n        while (!isEmpty() && !matchesAny(seq)) {\n            pos++;\n        }\n\n        return queue.substring(start, pos);\n    }\n\n    /**\n     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n     * <p>\n     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n     * isEmpty() == true).\n     * @param seq String to match up to, and not include in return, and to pull off queue. <b>Case sensitive.</b>\n     * @return Data matched from queue.\n     */\n    public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }\n    \n    public String chompToIgnoreCase(String seq) {\n        String data = consumeToIgnoreCase(seq); // case insensitive scan\n        matchChomp(seq);\n        return data;\n    }\n\n    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can be quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        boolean inRegexQE = false; // regex \\Q .. \\E escapes from Pattern.quote()\n\n        do {\n            if (isEmpty()) break;\n            char c = consume();\n            if (last != ESC) {\n                if (c == '\\'' && c != open && !inDoubleQuote)\n                    inSingleQuote = !inSingleQuote;\n                else if (c == '\"' && c != open && !inSingleQuote)\n                    inDoubleQuote = !inDoubleQuote;\n                if (inSingleQuote || inDoubleQuote || inRegexQE){\n                    last = c;\n                    continue;\n                }\n\n                if (c == open) {\n                    depth++;\n                    if (start == -1)\n                        start = pos;\n                }\n                else if (c == close)\n                    depth--;\n            } else if (c == 'Q') {\n                inRegexQE = true;\n            } else if (c == 'E') {\n                inRegexQE = false;\n            }\n\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        } while (depth > 0);\n        final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n        if (depth > 0) {// ran out of queue before seeing enough )\n            Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n        }\n        return out;\n    }\n    \n    /**\n     * Unescape a \\ escaped string.\n     * @param in backslash escaped string\n     * @return unescaped string\n     */\n    public static String unescape(String in) {\n        StringBuilder out = StringUtil.borrowBuilder();\n        char last = 0;\n        for (char c : in.toCharArray()) {\n            if (c == ESC) {\n                if (last == ESC) {\n                    out.append(c);\n                    c = 0;\n                }\n            }\n            else \n                out.append(c);\n            last = c;\n        }\n        return StringUtil.releaseBuilder(out);\n    }\n\n    /*\n    Given a CSS identifier (such as a tag, ID, or class), escape any CSS special characters that would otherwise not be\n    valid in a selector.\n     */\n    public static String escapeCssIdentifier(String in) {\n        StringBuilder out = StringUtil.borrowBuilder();\n        TokenQueue q = new TokenQueue(in);\n        while (!q.isEmpty()) {\n            if (q.matchesCssIdentifier(CssIdentifierChars)) {\n                out.append(q.consume());\n            } else {\n                out.append(ESC).append(q.consume());\n            }\n        }\n        return StringUtil.releaseBuilder(out);\n    }\n\n    /**\n     * Pulls the next run of whitespace characters of the queue.\n     * @return Whether consuming whitespace or not\n     */\n    public boolean consumeWhitespace() {\n        boolean seen = false;\n        while (matchesWhitespace()) {\n            pos++;\n            seen = true;\n        }\n        return seen;\n    }\n\n    /**\n     * Retrieves the next run of word type (letter or digit) off the queue.\n     * @return String of word characters from queue, or empty string if none.\n     */\n    public String consumeWord() {\n        int start = pos;\n        while (matchesWord())\n            pos++;\n        return queue.substring(start, pos);\n    }\n\n    \n    /**\n     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).\n     * \n     * @return tag name\n     */\n    public String consumeElementSelector() {\n        return consumeEscapedCssIdentifier(ElementSelectorChars);\n    }\n    private static final String[] ElementSelectorChars = {\"*\", \"|\", \"_\", \"-\"};\n\n    /**\n     Consume a CSS identifier (ID or class) off the queue (letter, digit, -, _)\n     http://www.w3.org/TR/CSS2/syndata.html#value-def-identifier\n     @return identifier\n     */\n    public String consumeCssIdentifier() {\n        return consumeEscapedCssIdentifier(CssIdentifierChars);\n    }\n    private static final String[] CssIdentifierChars = {\"-\", \"_\"};\n\n\n    private String consumeEscapedCssIdentifier(String... matches) {\n        int start = pos;\n        boolean escaped = false;\n        while (!isEmpty()) {\n            if (queue.charAt(pos) == ESC && remainingLength() >1 ) {\n                escaped = true;\n                pos+=2; // skip the escape and the escaped\n            } else if (matchesCssIdentifier(matches)) {\n                pos++;\n            } else {\n                break;\n            }\n        }\n\n        String consumed = queue.substring(start, pos);\n        return escaped ? unescape(consumed) : consumed;\n    }\n\n    private boolean matchesCssIdentifier(String... matches) {\n        return matchesWord() || matchesAny(matches);\n    }\n\n    /**\n     Consume and return whatever is left on the queue.\n     @return remained of queue.\n     */\n    public String remainder() {\n        final String remainder = queue.substring(pos);\n        pos = queue.length();\n        return remainder;\n    }\n    \n    @Override\n    public String toString() {\n        return queue.substring(pos);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private String queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "queue", "syntax_pass": true}, {"attribute_expression": "private int pos = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "pos = 0", "syntax_pass": true}, {"attribute_expression": "private static final char ESC = '\\\\';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "ESC = '\\\\'", "syntax_pass": true}, {"attribute_expression": "private static final String[] ElementSelectorChars = {\"*\", \"|\", \"_\", \"-\"};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "ElementSelectorChars = {\"*\", \"|\", \"_\", \"-\"}", "syntax_pass": true}, {"attribute_expression": "private static final String[] CssIdentifierChars = {\"-\", \"_\"};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "CssIdentifierChars = {\"-\", \"_\"}", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder", "name": "XmlTreeBuilder", "file_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java", "superclasses": "TreeBuilder", "methods": ["[ParseSettings]defaultSettings()", "[void]initialiseParse(Reader,String,Parser)", "[Document]parse(Reader,String)", "[Document]parse(String,String)", "[List<Node>]completeParseFragment()", "[XmlTreeBuilder]newInstance()", "[String]defaultNamespace()", "[boolean]process(Token)", "[void]insertElementFor(Token.StartTag)", "[void]insertLeafNode(LeafNode)", "[void]insertCommentFor(Token.Comment)", "[void]insertCharacterFor(Token.Character)", "[void]insertDoctypeFor(Token.Doctype)", "[void]popStackToClose(Token.EndTag)"], "method_uris": ["src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[ParseSettings]defaultSettings()", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]initialiseParse(Reader,String,Parser)", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[Document]parse(Reader,String)", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[Document]parse(String,String)", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[List<Node>]completeParseFragment()", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[XmlTreeBuilder]newInstance()", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[String]defaultNamespace()", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[boolean]process(Token)", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertElementFor(Token.StartTag)", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertLeafNode(LeafNode)", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertCommentFor(Token.Comment)", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertCharacterFor(Token.Character)", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]insertDoctypeFor(Token.Doctype)", "src/main/java/org/jsoup/parser/XmlTreeBuilder.java.XmlTreeBuilder.[void]popStackToClose(Token.EndTag)"], "overrides": null, "attributes": [], "class_docstring": "\nUse the {@code XmlTreeBuilder} when you want to parse XML without any of the HTML DOM rules being applied to the\ndocument.\n<p>Usage example: {@code Document xmlDoc = Jsoup.parse(html, baseUrl, Parser.xmlParser());}</p>\n\n@author Jonathan Hedley\n", "original_string": "public class XmlTreeBuilder extends TreeBuilder {\n    @Override ParseSettings defaultSettings() {\n        return ParseSettings.preserveCase;\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n        doc.outputSettings()\n            .syntax(Document.OutputSettings.Syntax.xml)\n            .escapeMode(Entities.EscapeMode.xhtml)\n            .prettyPrint(false); // as XML, we don't understand what whitespace is significant or not\n    }\n\n    Document parse(Reader input, String baseUri) {\n        return parse(input, baseUri, new Parser(this));\n    }\n\n    Document parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri, new Parser(this));\n    }\n\n    @Override List<Node> completeParseFragment() {\n        return doc.childNodes();\n    }\n\n    @Override\n    XmlTreeBuilder newInstance() {\n        return new XmlTreeBuilder();\n    }\n\n    @Override public String defaultNamespace() {\n        return NamespaceXml;\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        currentToken = token;\n\n        // start tag, end tag, doctype, comment, character, eof\n        switch (token.type) {\n            case StartTag:\n                insertElementFor(token.asStartTag());\n                break;\n            case EndTag:\n                popStackToClose(token.asEndTag());\n                break;\n            case Comment:\n                insertCommentFor(token.asComment());\n                break;\n            case Character:\n                insertCharacterFor(token.asCharacter());\n                break;\n            case Doctype:\n                insertDoctypeFor(token.asDoctype());\n                break;\n            case EOF: // could put some normalisation here if desired\n                break;\n            default:\n                Validate.fail(\"Unexpected token type: \" + token.type);\n        }\n        return true;\n    }\n\n    void insertElementFor(Token.StartTag startTag) {\n        Tag tag = tagFor(startTag.name(), settings);\n        if (startTag.attributes != null)\n            startTag.attributes.deduplicate(settings);\n\n        Element el = new Element(tag, null, settings.normalizeAttributes(startTag.attributes));\n        currentElement().appendChild(el);\n        push(el);\n\n        if (startTag.isSelfClosing()) {\n            tag.setSelfClosing();\n            pop(); // push & pop ensures onNodeInserted & onNodeClosed\n        }\n    }\n\n    void insertLeafNode(LeafNode node) {\n        currentElement().appendChild(node);\n        onNodeInserted(node);\n    }\n\n    void insertCommentFor(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        LeafNode insert = comment;\n        if (commentToken.bogus && comment.isXmlDeclaration()) {\n            // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            // todo - refactor this to parse more appropriately\n            XmlDeclaration decl = comment.asXmlDeclaration(); // else, we couldn't parse it as a decl, so leave as a comment\n            if (decl != null)\n                insert = decl;\n        }\n        insertLeafNode(insert);\n    }\n\n    void insertCharacterFor(Token.Character token) {\n        final String data = token.getData();\n        insertLeafNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insertDoctypeFor(Token.Doctype token) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(token.getName()), token.getPublicIdentifier(), token.getSystemIdentifier());\n        doctypeNode.setPubSysKey(token.getPubSysKey());\n        insertLeafNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    protected void popStackToClose(Token.EndTag endTag) {\n        // like in HtmlTreeBuilder - don't scan up forever for very (artificially) deeply nested stacks\n        String elName = settings.normalizeTag(endTag.tagName);\n        Element firstFound = null;\n\n        final int bottom = stack.size() - 1;\n        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;\n\n        for (int pos = stack.size() -1; pos >= upper; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = pop();\n            if (next == firstFound) {\n                break;\n            }\n        }\n    }\n    private static final int maxQueueDepth = 256; // an arbitrary tension point between real XML and crafted pain\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int maxQueueDepth = 256;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "maxQueueDepth = 256", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/Tag.java.Tag", "name": "Tag", "file_path": "src/main/java/org/jsoup/parser/Tag.java", "superclasses": "", "methods": ["[]Tag(String,String)", "[String]getName()", "[String]normalName()", "[String]namespace()", "[Tag]valueOf(String,String,ParseSettings)", "[Tag]valueOf(String)", "[Tag]valueOf(String,ParseSettings)", "[boolean]isBlock()", "[boolean]formatAsBlock()", "[boolean]isInline()", "[boolean]isEmpty()", "[boolean]isSelfClosing()", "[boolean]isKnownTag()", "[boolean]isKnownTag(String)", "[boolean]preserveWhitespace()", "[boolean]isFormListed()", "[boolean]isFormSubmittable()", "[Tag]setSelfClosing()", "[boolean]equals(Object)", "[int]hashCode()", "[String]toString()", "[Tag]clone()", "[void]setupTags(String[],Consumer<Tag>)"], "method_uris": ["src/main/java/org/jsoup/parser/Tag.java.Tag.[]Tag(String,String)", "src/main/java/org/jsoup/parser/Tag.java.Tag.[String]getName()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[String]normalName()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[String]namespace()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]valueOf(String,String,ParseSettings)", "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]valueOf(String)", "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]valueOf(String,ParseSettings)", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isBlock()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]formatAsBlock()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isInline()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isEmpty()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isSelfClosing()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isKnownTag()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isKnownTag(String)", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]preserveWhitespace()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isFormListed()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]isFormSubmittable()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]setSelfClosing()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[boolean]equals(Object)", "src/main/java/org/jsoup/parser/Tag.java.Tag.[int]hashCode()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[String]toString()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[Tag]clone()", "src/main/java/org/jsoup/parser/Tag.java.Tag.[void]setupTags(String[],Consumer<Tag>)"], "overrides": null, "attributes": [], "class_docstring": "\nTag capabilities.\n\n@author Jonathan Hedley, jonathan@hedley.net\n", "original_string": "public class Tag implements Cloneable {\n    private static final Map<String, Tag> Tags = new HashMap<>(); // map of known tags\n\n    private String tagName;\n    private final String normalName; // always the lower case version of this tag, regardless of case preservation mode\n    private String namespace;\n    private boolean isBlock = true; // block\n    private boolean formatAsBlock = true; // should be formatted as a block\n    private boolean empty = false; // can hold nothing; e.g. img\n    private boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.\n    private boolean preserveWhitespace = false; // for pre, textarea, script etc\n    private boolean formList = false; // a control that appears in forms: input, textarea, output etc\n    private boolean formSubmit = false; // a control that can be submitted in a form: input etc\n\n    private Tag(String tagName, String namespace) {\n        this.tagName = tagName;\n        normalName = Normalizer.lowerCase(tagName);\n        this.namespace = namespace;\n    }\n\n    /**\n     * Get this tag's name.\n     *\n     * @return the tag's name\n     */\n    public String getName() {\n        return tagName;\n    }\n\n    /**\n     * Get this tag's normalized (lowercased) name.\n     * @return the tag's normal name.\n     */\n    public String normalName() {\n        return normalName;\n    }\n\n    public String namespace() {\n        return namespace;\n    }\n\n    /**\n     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n     * <p>\n     * Pre-defined tags (p, div etc) will be ==, but unknown tags are not registered and will only .equals().\n     * </p>\n     * \n     * @param tagName Name of tag, e.g. \"p\". Case-insensitive.\n     * @param namespace the namespace for the tag.\n     * @param settings used to control tag name sensitivity\n     * @return The tag, either defined or new generic.\n     */\n    public static Tag valueOf(String tagName, String namespace, ParseSettings settings) {\n        Validate.notEmpty(tagName);\n        Validate.notNull(namespace);\n        Tag tag = Tags.get(tagName);\n        if (tag != null && tag.namespace.equals(namespace))\n            return tag;\n\n        tagName = settings.normalizeTag(tagName); // the name we'll use\n        Validate.notEmpty(tagName);\n        String normalName = Normalizer.lowerCase(tagName); // the lower-case name to get tag settings off\n        tag = Tags.get(normalName);\n        if (tag != null && tag.namespace.equals(namespace)) {\n            if (settings.preserveTagCase() && !tagName.equals(normalName)) {\n                tag = tag.clone(); // get a new version vs the static one, so name update doesn't reset all\n                tag.tagName = tagName;\n            }\n            return tag;\n        }\n\n        // not defined: create default; go anywhere, do anything! (incl be inside a <p>)\n        tag = new Tag(tagName, namespace);\n        tag.isBlock = false;\n\n        return tag;\n    }\n\n    /**\n     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n     * <p>\n     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n     * </p>\n     *\n     * @param tagName Name of tag, e.g. \"p\". <b>Case sensitive</b>.\n     * @return The tag, either defined or new generic.\n     * @see #valueOf(String tagName, String namespace, ParseSettings settings)\n     */\n    public static Tag valueOf(String tagName) {\n        return valueOf(tagName, Parser.NamespaceHtml, ParseSettings.preserveCase);\n    }\n\n    /**\n     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n     * <p>\n     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n     * </p>\n     *\n     * @param tagName Name of tag, e.g. \"p\". <b>Case sensitive</b>.\n     * @param settings used to control tag name sensitivity\n     * @return The tag, either defined or new generic.\n     * @see #valueOf(String tagName, String namespace, ParseSettings settings)\n     */\n    public static Tag valueOf(String tagName, ParseSettings settings) {\n        return valueOf(tagName, Parser.NamespaceHtml, settings);\n    }\n\n    /**\n     * Gets if this is a block tag.\n     *\n     * @return if block tag\n     */\n    public boolean isBlock() {\n        return isBlock;\n    }\n\n    /**\n     * Gets if this tag should be formatted as a block (or as inline)\n     *\n     * @return if should be formatted as block or inline\n     */\n    public boolean formatAsBlock() {\n        return formatAsBlock;\n    }\n\n    /**\n     * Gets if this tag is an inline tag.\n     *\n     * @return if this tag is an inline tag.\n     */\n    public boolean isInline() {\n        return !isBlock;\n    }\n\n    /**\n     * Get if this is an empty tag\n     *\n     * @return if this is an empty tag\n     */\n    public boolean isEmpty() {\n        return empty;\n    }\n\n    /**\n     * Get if this tag is self-closing.\n     *\n     * @return if this tag should be output as self-closing.\n     */\n    public boolean isSelfClosing() {\n        return empty || selfClosing;\n    }\n\n    /**\n     * Get if this is a pre-defined tag, or was auto created on parsing.\n     *\n     * @return if a known tag\n     */\n    public boolean isKnownTag() {\n        return Tags.containsKey(tagName);\n    }\n\n    /**\n     * Check if this tagname is a known tag.\n     *\n     * @param tagName name of tag\n     * @return if known HTML tag\n     */\n    public static boolean isKnownTag(String tagName) {\n        return Tags.containsKey(tagName);\n    }\n\n    /**\n     * Get if this tag should preserve whitespace within child text nodes.\n     *\n     * @return if preserve whitespace\n     */\n    public boolean preserveWhitespace() {\n        return preserveWhitespace;\n    }\n\n    /**\n     * Get if this tag represents a control associated with a form. E.g. input, textarea, output\n     * @return if associated with a form\n     */\n    public boolean isFormListed() {\n        return formList;\n    }\n\n    /**\n     * Get if this tag represents an element that should be submitted with a form. E.g. input, option\n     * @return if submittable with a form\n     */\n    public boolean isFormSubmittable() {\n        return formSubmit;\n    }\n\n    Tag setSelfClosing() {\n        selfClosing = true;\n        return this;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Tag)) return false;\n\n        Tag tag = (Tag) o;\n\n        if (!tagName.equals(tag.tagName)) return false;\n        if (empty != tag.empty) return false;\n        if (formatAsBlock != tag.formatAsBlock) return false;\n        if (isBlock != tag.isBlock) return false;\n        if (preserveWhitespace != tag.preserveWhitespace) return false;\n        if (selfClosing != tag.selfClosing) return false;\n        if (formList != tag.formList) return false;\n        return formSubmit == tag.formSubmit;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(tagName, isBlock, formatAsBlock, empty, selfClosing, preserveWhitespace,\n            formList, formSubmit);\n    }\n\n    @Override\n    public String toString() {\n        return tagName;\n    }\n\n    @Override\n    protected Tag clone() {\n        try {\n            return (Tag) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // internal static initialisers:\n    // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html and other sources\n    private static final String[] blockTags = {\n            \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n            \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n            \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n            \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n            \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\", \"template\", \"article\", \"main\",\n            \"svg\", \"math\", \"center\", \"template\",\n            \"dir\", \"applet\", \"marquee\", \"listing\" // deprecated but still known / special handling\n    };\n    private static final String[] inlineTags = {\n            \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\",\n            \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"rtc\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\",\n            \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"optgroup\",\n            \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n            \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\",\n            \"data\", \"bdi\", \"s\", \"strike\", \"nobr\",\n            \"rb\", // deprecated but still known / special handling\n            \"text\", // in SVG NS\n            \"mi\", \"mo\", \"msup\", \"mn\", \"mtext\" // in MathML NS, to ensure inline\n    };\n    private static final String[] emptyTags = {\n            \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n            \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\"\n    };\n    // todo - rework this to format contents as inline; and update html emitter in Element. Same output, just neater.\n    private static final String[] formatAsInlineTags = {\n            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\",\n            \"ins\", \"del\", \"s\", \"button\"\n    };\n    private static final String[] preserveWhitespaceTags = {\n            \"pre\", \"plaintext\", \"title\", \"textarea\"\n            // script is not here as it is a data node, which always preserve whitespace\n    };\n    // todo: I think we just need submit tags, and can scrub listed\n    private static final String[] formListedTags = {\n            \"button\", \"fieldset\", \"input\", \"keygen\", \"object\", \"output\", \"select\", \"textarea\"\n    };\n    private static final String[] formSubmitTags = SharedConstants.FormSubmitTags;\n\n    private static final Map<String, String[]> namespaces = new HashMap<>();\n    static {\n        namespaces.put(Parser.NamespaceMathml, new String[]{\"math\", \"mi\", \"mo\", \"msup\", \"mn\", \"mtext\"});\n        namespaces.put(Parser.NamespaceSvg, new String[]{\"svg\", \"text\"});\n        // We don't need absolute coverage here as other cases will be inferred by the HtmlTreeBuilder\n    }\n\n    private static void setupTags(String[] tagNames, Consumer<Tag> tagModifier) {\n        for (String tagName : tagNames) {\n            Tag tag = Tags.get(tagName);\n            if (tag == null) {\n                tag = new Tag(tagName, Parser.NamespaceHtml);\n                Tags.put(tag.tagName, tag);\n            }\n            tagModifier.accept(tag);\n        }\n    }\n\n    static {\n        setupTags(blockTags, tag -> {\n            tag.isBlock = true;\n            tag.formatAsBlock = true;\n        });\n\n        setupTags(inlineTags, tag -> {\n            tag.isBlock = false;\n            tag.formatAsBlock = false;\n        });\n\n        setupTags(emptyTags, tag -> tag.empty = true);\n        setupTags(formatAsInlineTags, tag -> tag.formatAsBlock = false);\n        setupTags(preserveWhitespaceTags, tag -> tag.preserveWhitespace = true);\n        setupTags(formListedTags, tag -> tag.formList = true);\n        setupTags(formSubmitTags, tag -> tag.formSubmit = true);\n        for (Map.Entry<String, String[]> ns : namespaces.entrySet()) {\n            setupTags(ns.getValue(), tag -> tag.namespace = ns.getKey());\n        }\n    }\n}", "super_interfaces": ["Cloneable"], "fields": [{"attribute_expression": "private static final Map<String, Tag> Tags = new HashMap<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<String, Tag>", "name": "Tags = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private String tagName;", "docstring": " map of known tags", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "tagName", "syntax_pass": true}, {"attribute_expression": "private final String normalName;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "normalName", "syntax_pass": true}, {"attribute_expression": "private String namespace;", "docstring": " always the lower case version of this tag, regardless of case preservation mode", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "namespace", "syntax_pass": true}, {"attribute_expression": "private boolean isBlock = true;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isBlock = true", "syntax_pass": true}, {"attribute_expression": "private boolean formatAsBlock = true;", "docstring": " block", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "formatAsBlock = true", "syntax_pass": true}, {"attribute_expression": "private boolean empty = false;", "docstring": " should be formatted as a block", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "empty = false", "syntax_pass": true}, {"attribute_expression": "private boolean selfClosing = false;", "docstring": " can hold nothing; e.g. img", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "selfClosing = false", "syntax_pass": true}, {"attribute_expression": "private boolean preserveWhitespace = false;", "docstring": " can self close (<foo />). used for unknown tags that self close, without forcing them as empty.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "preserveWhitespace = false", "syntax_pass": true}, {"attribute_expression": "private boolean formList = false;", "docstring": " for pre, textarea, script etc", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "formList = false", "syntax_pass": true}, {"attribute_expression": "private boolean formSubmit = false;", "docstring": " a control that appears in forms: input, textarea, output etc", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "formSubmit = false", "syntax_pass": true}, {"attribute_expression": "private static final String[] blockTags = {\n            \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n            \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n            \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n            \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n            \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\", \"template\", \"article\", \"main\",\n            \"svg\", \"math\", \"center\", \"template\",\n            \"dir\", \"applet\", \"marquee\", \"listing\" // deprecated but still known / special handling\n    };", "docstring": " prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html and other sources", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "blockTags = {\n            \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n            \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n            \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n            \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n            \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\", \"template\", \"article\", \"main\",\n            \"svg\", \"math\", \"center\", \"template\",\n            \"dir\", \"applet\", \"marquee\", \"listing\" // deprecated but still known / special handling\n    }", "syntax_pass": true}, {"attribute_expression": "private static final String[] inlineTags = {\n            \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\",\n            \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"rtc\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\",\n            \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"optgroup\",\n            \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n            \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\",\n            \"data\", \"bdi\", \"s\", \"strike\", \"nobr\",\n            \"rb\", // deprecated but still known / special handling\n            \"text\", // in SVG NS\n            \"mi\", \"mo\", \"msup\", \"mn\", \"mtext\" // in MathML NS, to ensure inline\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "inlineTags = {\n            \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\",\n            \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"rtc\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\",\n            \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"optgroup\",\n            \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n            \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\",\n            \"data\", \"bdi\", \"s\", \"strike\", \"nobr\",\n            \"rb\", // deprecated but still known / special handling\n            \"text\", // in SVG NS\n            \"mi\", \"mo\", \"msup\", \"mn\", \"mtext\" // in MathML NS, to ensure inline\n    }", "syntax_pass": true}, {"attribute_expression": "private static final String[] emptyTags = {\n            \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n            \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\"\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "emptyTags = {\n            \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n            \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\"\n    }", "syntax_pass": true}, {"attribute_expression": "private static final String[] formatAsInlineTags = {\n            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\",\n            \"ins\", \"del\", \"s\", \"button\"\n    };", "docstring": " todo - rework this to format contents as inline; and update html emitter in Element. Same output, just neater.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "formatAsInlineTags = {\n            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\",\n            \"ins\", \"del\", \"s\", \"button\"\n    }", "syntax_pass": true}, {"attribute_expression": "private static final String[] preserveWhitespaceTags = {\n            \"pre\", \"plaintext\", \"title\", \"textarea\"\n            // script is not here as it is a data node, which always preserve whitespace\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "preserveWhitespaceTags = {\n            \"pre\", \"plaintext\", \"title\", \"textarea\"\n            // script is not here as it is a data node, which always preserve whitespace\n    }", "syntax_pass": true}, {"attribute_expression": "private static final String[] formListedTags = {\n            \"button\", \"fieldset\", \"input\", \"keygen\", \"object\", \"output\", \"select\", \"textarea\"\n    };", "docstring": " todo: I think we just need submit tags, and can scrub listed", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "formListedTags = {\n            \"button\", \"fieldset\", \"input\", \"keygen\", \"object\", \"output\", \"select\", \"textarea\"\n    }", "syntax_pass": true}, {"attribute_expression": "private static final String[] formSubmitTags = SharedConstants.FormSubmitTags;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "formSubmitTags = SharedConstants.FormSubmitTags", "syntax_pass": true}, {"attribute_expression": "private static final Map<String, String[]> namespaces = new HashMap<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<String, String[]>", "name": "namespaces = new HashMap<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser", "name": "StreamParser", "file_path": "src/main/java/org/jsoup/parser/StreamParser.java", "superclasses": "", "methods": ["[]StreamParser(Parser)", "[StreamParser]parse(Reader,String)", "[StreamParser]parse(String,String)", "[StreamParser]parseFragment(Reader,Element,String)", "[StreamParser]parseFragment(String,Element,String)", "[Stream<Element>]stream()", "[Iterator<Element>]iterator()", "[StreamParser]stop()", "[void]close()", "[Document]document()", "[Document]complete()", "[List<Node>]completeFragment()", "[Element]selectFirst(String)", "[Element]expectFirst(String)", "[Element]selectFirst(Evaluator)", "[Element]selectNext(String)", "[Element]expectNext(String)", "[Element]selectNext(Evaluator)"], "method_uris": ["src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[]StreamParser(Parser)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]parse(Reader,String)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]parse(String,String)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]parseFragment(Reader,Element,String)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]parseFragment(String,Element,String)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Stream<Element>]stream()", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Iterator<Element>]iterator()", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[StreamParser]stop()", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[void]close()", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Document]document()", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Document]complete()", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[List<Node>]completeFragment()", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]selectFirst(String)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]expectFirst(String)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]selectFirst(Evaluator)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]selectNext(String)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]expectNext(String)", "src/main/java/org/jsoup/parser/StreamParser.java.StreamParser.[Element]selectNext(Evaluator)"], "overrides": null, "attributes": [{"original_string": "    final class ElementIterator implements Iterator<Element>, NodeVisitor {\n        // listeners add to a next emit queue, as a single token read step may yield multiple elements\n        final private Queue<Element> emitQueue = new LinkedList<>();\n        private @Nullable Element current;  // most recently emitted\n        private @Nullable Element next;     // element waiting to be picked up\n        private @Nullable Element tail;     // The last tailed element (</html>), on hold for final pop\n\n        void reset() {\n            emitQueue.clear();\n            current = next = tail = null;\n            stopped = false;\n        }\n\n        // Iterator Interface:\n        /**\n         {@inheritDoc}\n         @throws UncheckedIOException if the underlying Reader errors during a read\n         */\n        @Override public boolean hasNext() {\n            maybeFindNext();\n            return next != null;\n        }\n\n        /**\n         {@inheritDoc}\n         @throws UncheckedIOException if the underlying Reader errors during a read\n         */\n        @Override public Element next() {\n            maybeFindNext();\n            if (next == null) throw new NoSuchElementException();\n            current = next;\n            next = null;\n            return current;\n        }\n\n        private void maybeFindNext() {\n            if (stopped || next != null) return;\n\n            // drain the current queue before stepping to get more\n            if (!emitQueue.isEmpty()) {\n                next = emitQueue.remove();\n                return;\n            }\n\n            // step the parser, which will hit the node listeners to add to the queue:\n            while (treeBuilder.stepParser()) {\n                if (!emitQueue.isEmpty()) {\n                    next = emitQueue.remove();\n                    return;\n                }\n            }\n            stop();\n            close();\n\n            // send the final element out:\n            if (tail != null) {\n                next = tail;\n                tail = null;\n            }\n        }\n\n        @Override public void remove() {\n            if (current == null) throw new NoSuchElementException();\n            current.remove();\n        }\n\n        // NodeVisitor Interface:\n        @Override public void head(Node node, int depth) {\n            if (node instanceof Element) {\n                Element prev = ((Element) node).previousElementSibling();\n                // We prefer to wait until an element has a next sibling before emitting it; otherwise, get it in tail\n                if (prev != null) emitQueue.add(prev);\n            }\n        }\n\n        @Override public void tail(Node node, int depth) {\n            if (node instanceof Element) {\n                tail = (Element) node; // kept for final hit\n                Element lastChild = tail.lastElementChild(); // won't get a nextsib, so emit that:\n                if (lastChild != null) emitQueue.add(lastChild);\n            }\n        }\n    }", "definition": "    final class ElementIterator implements Iterator<Element>, NodeVisitor", "class_docstring": "", "name": "ElementIterator", "super_interfaces": ["Iterator<Element>", "NodeVisitor"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "final private Queue<Element> emitQueue = new LinkedList<>();", "docstring": " listeners add to a next emit queue, as a single token read step may yield multiple elements", "modifiers": "final private", "marker_annotations": [], "non_marker_annotations": ["final", "private"], "comments": [], "type": "Queue<Element>", "name": "emitQueue = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private @Nullable Element current;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Element", "name": "current", "syntax_pass": true}, {"attribute_expression": "private @Nullable Element next;", "docstring": " most recently emitted", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Element", "name": "next", "syntax_pass": true}, {"attribute_expression": "private @Nullable Element tail;", "docstring": " element waiting to be picked up", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Element", "name": "tail", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        void reset() {\n            emitQueue.clear();\n            current = next = tail = null;\n            stopped = false;\n        }", "docstring": " The last tailed element (</html>), on hold for final pop", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                     {\n            emitQueue.clear();\n            current = next = tail = null;\n            stopped = false;\n        }", "signature": "void reset()"}, {"syntax_pass": true, "original_string": "        @Override public boolean hasNext() {\n            maybeFindNext();\n            return next != null;\n        }", "docstring": "\n{@inheritDoc}\n@throws UncheckedIOException if the underlying Reader errors during a read\n", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                           {\n            maybeFindNext();\n            return next != null;\n        }", "signature": "@Override public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override public Element next() {\n            maybeFindNext();\n            if (next == null) throw new NoSuchElementException();\n            current = next;\n            next = null;\n            return current;\n        }", "docstring": "\n{@inheritDoc}\n@throws UncheckedIOException if the underlying Reader errors during a read\n", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Element", "classes": []}, "name": "next", "params": [], "body": "                                        {\n            maybeFindNext();\n            if (next == null) throw new NoSuchElementException();\n            current = next;\n            next = null;\n            return current;\n        }", "signature": "@Override public Element next()"}, {"syntax_pass": true, "original_string": "        private void maybeFindNext() {\n            if (stopped || next != null) return;\n\n            // drain the current queue before stepping to get more\n            if (!emitQueue.isEmpty()) {\n                next = emitQueue.remove();\n                return;\n            }\n\n            // step the parser, which will hit the node listeners to add to the queue:\n            while (treeBuilder.stepParser()) {\n                if (!emitQueue.isEmpty()) {\n                    next = emitQueue.remove();\n                    return;\n                }\n            }\n            stop();\n            close();\n\n            // send the final element out:\n            if (tail != null) {\n                next = tail;\n                tail = null;\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "maybeFindNext", "params": [], "body": "                                     {\n            if (stopped || next != null) return;\n\n            // drain the current queue before stepping to get more\n            if (!emitQueue.isEmpty()) {\n                next = emitQueue.remove();\n                return;\n            }\n\n            // step the parser, which will hit the node listeners to add to the queue:\n            while (treeBuilder.stepParser()) {\n                if (!emitQueue.isEmpty()) {\n                    next = emitQueue.remove();\n                    return;\n                }\n            }\n            stop();\n            close();\n\n            // send the final element out:\n            if (tail != null) {\n                next = tail;\n                tail = null;\n            }\n        }", "signature": "private void maybeFindNext()"}, {"syntax_pass": true, "original_string": "        @Override public void remove() {\n            if (current == null) throw new NoSuchElementException();\n            current.remove();\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                                       {\n            if (current == null) throw new NoSuchElementException();\n            current.remove();\n        }", "signature": "@Override public void remove()"}, {"syntax_pass": true, "original_string": "        @Override public void head(Node node, int depth) {\n            if (node instanceof Element) {\n                Element prev = ((Element) node).previousElementSibling();\n                // We prefer to wait until an element has a next sibling before emitting it; otherwise, get it in tail\n                if (prev != null) emitQueue.add(prev);\n            }\n        }", "docstring": " NodeVisitor Interface:", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "head", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                         {\n            if (node instanceof Element) {\n                Element prev = ((Element) node).previousElementSibling();\n                // We prefer to wait until an element has a next sibling before emitting it; otherwise, get it in tail\n                if (prev != null) emitQueue.add(prev);\n            }\n        }", "signature": "@Override public void head(Node node, int depth)"}, {"syntax_pass": true, "original_string": "        @Override public void tail(Node node, int depth) {\n            if (node instanceof Element) {\n                tail = (Element) node; // kept for final hit\n                Element lastChild = tail.lastElementChild(); // won't get a nextsib, so emit that:\n                if (lastChild != null) emitQueue.add(lastChild);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tail", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                         {\n            if (node instanceof Element) {\n                tail = (Element) node; // kept for final hit\n                Element lastChild = tail.lastElementChild(); // won't get a nextsib, so emit that:\n                if (lastChild != null) emitQueue.add(lastChild);\n            }\n        }", "signature": "@Override public void tail(Node node, int depth)"}]}], "class_docstring": "\nA StreamParser provides a progressive parse of its input. As each Element is completed, it is emitted via a Stream or\nIterator interface. Elements returned will be complete with all their children, and an (empty) next sibling, if\napplicable.\n<p>Elements (or their children) may be removed from the DOM during the parse, for e.g. to conserve memory, providing a\nmechanism to parse an input document that would otherwise be too large to fit into memory, yet still providing a DOM\ninterface to the document and its elements.</p>\n<p>\nAdditionally, the parser provides a {@link #selectFirst(String query)} / {@link #selectNext(String query)}, which will\nrun the parser until a hit is found, at which point the parse is suspended. It can be resumed via another\n{@code select()} call, or via the {@link #stream()} or {@link #iterator()} methods.\n</p>\n<p>Once the input has been fully read, the input Reader will be closed. Or, if the whole document does not need to be\nread, call {@link #stop()} and {@link #close()}.</p>\n<p>The {@link #document()} method will return the Document being parsed into, which will be only partially complete\nuntil the input is fully consumed.</p>\n<p>A StreamParser can be reused via a new {@link #parse(Reader, String)}, but is not thread-safe for concurrent inputs.\nNew parsers should be used in each thread.</p>\n<p>If created via {@link Connection.Response#streamParser()}, or another Reader that is I/O backed, the iterator and\nstream consumers will throw an {@link java.io.UncheckedIOException} if the underlying Reader errors during read.</p>\n<p>The StreamParser interface is currently in <b>beta</b> and may change in subsequent releases. Feedback on the\nfeature and how you're using it is very welcome via the <a href=\"https://jsoup.org/discussion\">jsoup\ndiscussions</a>.</p>\n@since 1.18.1\n", "original_string": "public class StreamParser implements Closeable {\n    final private Parser parser;\n    final private TreeBuilder treeBuilder;\n    final private ElementIterator it = new ElementIterator();\n    @Nullable private Document document;\n    private boolean stopped = false;\n\n    /**\n     Construct a new StreamParser, using the supplied base Parser.\n     @param parser the configured base parser\n     */\n    public StreamParser(Parser parser) {\n        this.parser = parser;\n        treeBuilder = parser.getTreeBuilder();\n        treeBuilder.nodeListener(it);\n    }\n\n    /**\n     Provide the input for a Document parse. The input is not read until a consuming operation is called.\n     @param input the input to be read.\n     @param baseUri the URL of this input, for absolute link resolution\n     @return this parser, for chaining\n     */\n    public StreamParser parse(Reader input, String baseUri) {\n        close(); // probably a no-op, but ensures any previous reader is closed\n        it.reset();\n        treeBuilder.initialiseParse(input, baseUri, parser); // reader is not read, so no chance of IO error\n        document = treeBuilder.doc;\n        return this;\n    }\n\n    /**\n     Provide the input for a Document parse. The input is not read until a consuming operation is called.\n     @param input the input to be read\n     @param baseUri the URL of this input, for absolute link resolution\n     @return this parser\n     */\n    public StreamParser parse(String input, String baseUri) {\n        return parse(new StringReader(input), baseUri);\n    }\n\n    /**\n     Provide the input for a fragment parse. The input is not read until a consuming operation is called.\n     @param input the input to be read\n     @param context the optional fragment context element\n     @param baseUri the URL of this input, for absolute link resolution\n     @return this parser\n     @see #completeFragment()\n     */\n    public StreamParser parseFragment(Reader input, @Nullable Element context, String baseUri) {\n        parse(input, baseUri);\n        treeBuilder.initialiseParseFragment(context);\n        return this;\n    }\n\n    /**\n     Provide the input for a fragment parse. The input is not read until a consuming operation is called.\n     @param input the input to be read\n     @param context the optional fragment context element\n     @param baseUri the URL of this input, for absolute link resolution\n     @return this parser\n     @see #completeFragment()\n     */\n    public StreamParser parseFragment(String input, @Nullable Element context, String baseUri) {\n        return parseFragment(new StringReader(input), context, baseUri);\n    }\n\n    /**\n     Creates a {@link Stream} of {@link Element}s, with the input being parsed as each element is consumed. Each\n     Element returned will be complete (that is, all of its children will be included, and if it has a next sibling, that\n     (empty) sibling will exist at {@link Element#nextElementSibling()}). The stream will be emitted in document order as\n     each element is closed. That means that child elements will be returned prior to their parents.\n     <p>The stream will start from the current position of the backing iterator and the parse.</p>\n     <p>When consuming the stream, if the Reader that the Parser is reading throws an I/O exception (for example a\n     SocketTimeoutException), that will be emitted as an {@link UncheckedIOException}</p>\n     @return a stream of Element objects\n     @throws UncheckedIOException if the underlying Reader excepts during a read (in stream consuming methods)\n     */\n    public Stream<Element> stream() {\n        return StreamSupport.stream(\n            Spliterators.spliteratorUnknownSize(\n                it, Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.ORDERED),\n            false);\n    }\n\n    /**\n     Returns an {@link Iterator} of {@link Element}s, with the input being parsed as each element is consumed. Each\n     Element returned will be complete (that is, all of its children will be included, and if it has a next sibling, that\n     (empty) sibling will exist at {@link Element#nextElementSibling()}). The elements will be emitted in document order as\n     each element is closed. That means that child elements will be returned prior to their parents.\n     <p>The iterator will start from the current position of the parse.</p>\n     <p>The iterator is backed by this StreamParser, and the resources it holds.</p>\n     @return a stream of Element objects\n     */\n    public Iterator<Element> iterator() {\n        //noinspection ReturnOfInnerClass\n        return it;\n    }\n\n    /**\n     Flags that the parse should be stopped; the backing iterator will not return any more Elements.\n     @return this parser\n     */\n    public StreamParser stop() {\n        stopped = true;\n        return this;\n    }\n\n    /**\n     Closes the input and releases resources including the underlying parser and reader.\n     <p>The parser will also be closed when the input is fully read.</p>\n     <p>The parser can be reused with another call to {@link #parse(Reader, String)}.</p>\n     */\n    @Override public void close() {\n        treeBuilder.completeParse(); // closes the reader, frees resources\n    }\n\n    /**\n     Get the current {@link Document} as it is being parsed. It will be only partially complete until the input is fully\n     read. Structural changes (e.g. insert, remove) may be made to the Document contents.\n     @return the (partial) Document\n     */\n    public Document document() {\n        document = treeBuilder.doc;\n        Validate.notNull(document, \"Must run parse() before calling.\");\n        return document;\n    }\n\n    /**\n     Runs the parser until the input is fully read, and returns the completed Document.\n     @return the completed Document\n     @throws IOException if an I/O error occurs\n     */\n    public Document complete() throws IOException {\n        Document doc = document();\n        treeBuilder.runParser();\n        return doc;\n    }\n\n    /**\n     When initialized as a fragment parse, runs the parser until the input is fully read, and returns the completed\n     fragment child nodes.\n     @return the completed child nodes\n     @throws IOException if an I/O error occurs\n     @see #parseFragment(Reader, Element, String)\n     */\n    public List<Node> completeFragment() throws IOException {\n        treeBuilder.runParser();\n        return treeBuilder.completeParseFragment();\n    }\n\n    /**\n     Finds the first Element that matches the provided query. If the parsed Document does not already have a match, the\n     input will be parsed until the first match is found, or the input is completely read.\n     @param query the {@link org.jsoup.select.Selector} query.\n     @return the first matching {@link Element}, or {@code null} if there's no match\n     @throws IOException if an I/O error occurs\n     */\n    public @Nullable Element selectFirst(String query) throws IOException {\n        return selectFirst(QueryParser.parse(query));\n    }\n\n    /**\n     Just like {@link #selectFirst(String)}, but if there is no match, throws an {@link IllegalArgumentException}. This\n     is useful if you want to simply abort processing on a failed match.\n     @param query the {@link org.jsoup.select.Selector} query.\n     @return the first matching element\n     @throws IllegalArgumentException if no match is found\n     @throws IOException if an I/O error occurs\n     */\n    public Element expectFirst(String query) throws IOException {\n        return (Element) Validate.ensureNotNull(\n            selectFirst(query),\n            \"No elements matched the query '%s' in the document.\"\n            , query\n        );\n    }\n\n    /**\n     Finds the first Element that matches the provided query. If the parsed Document does not already have a match, the\n     input will be parsed until the first match is found, or the input is completely read.\n     @param eval the {@link org.jsoup.select.Selector} evaluator.\n     @return the first matching {@link Element}, or {@code null} if there's no match\n     @throws IOException if an I/O error occurs\n     */\n    public @Nullable Element selectFirst(Evaluator eval) throws IOException {\n        final Document doc = document();\n\n        // run the query on the existing (partial) doc first, as there may be a hit already parsed\n        Element first = doc.selectFirst(eval);\n        if (first != null) return first;\n\n        return selectNext(eval);\n    }\n\n    /**\n     Finds the next Element that matches the provided query. The input will be parsed until the next match is found, or\n     the input is completely read.\n     @param query the {@link org.jsoup.select.Selector} query.\n     @return the next matching {@link Element}, or {@code null} if there's no match\n     @throws IOException if an I/O error occurs\n     */\n    public @Nullable Element selectNext(String query) throws IOException {\n        return selectNext(QueryParser.parse(query));\n    }\n\n    /**\n     Just like {@link #selectFirst(String)}, but if there is no match, throws an {@link IllegalArgumentException}. This\n     is useful if you want to simply abort processing on a failed match.\n     @param query the {@link org.jsoup.select.Selector} query.\n     @return the first matching element\n     @throws IllegalArgumentException if no match is found\n     @throws IOException if an I/O error occurs\n     */\n    public Element expectNext(String query) throws IOException {\n        return (Element) Validate.ensureNotNull(\n            selectNext(query),\n            \"No elements matched the query '%s' in the document.\"\n            , query\n        );\n    }\n\n    /**\n     Finds the next Element that matches the provided query. The input will be parsed until the next match is found, or\n     the input is completely read.\n     @param eval the {@link org.jsoup.select.Selector} evaluator.\n     @return the next matching {@link Element}, or {@code null} if there's no match\n     @throws IOException if an I/O error occurs\n     */\n    public @Nullable Element selectNext(Evaluator eval) throws IOException {\n        try {\n            final Document doc = document(); // validates the parse was initialized, keeps stack trace out of stream\n            return stream()\n                .filter(eval.asPredicate(doc))\n                .findFirst()\n                .orElse(null);\n        } catch (UncheckedIOException e) {\n            // Reader threw an IO exception emitted via Iterator's next()\n            throw e.getCause();\n        }\n    }\n\n    final class ElementIterator implements Iterator<Element>, NodeVisitor {\n        // listeners add to a next emit queue, as a single token read step may yield multiple elements\n        final private Queue<Element> emitQueue = new LinkedList<>();\n        private @Nullable Element current;  // most recently emitted\n        private @Nullable Element next;     // element waiting to be picked up\n        private @Nullable Element tail;     // The last tailed element (</html>), on hold for final pop\n\n        void reset() {\n            emitQueue.clear();\n            current = next = tail = null;\n            stopped = false;\n        }\n\n        // Iterator Interface:\n        /**\n         {@inheritDoc}\n         @throws UncheckedIOException if the underlying Reader errors during a read\n         */\n        @Override public boolean hasNext() {\n            maybeFindNext();\n            return next != null;\n        }\n\n        /**\n         {@inheritDoc}\n         @throws UncheckedIOException if the underlying Reader errors during a read\n         */\n        @Override public Element next() {\n            maybeFindNext();\n            if (next == null) throw new NoSuchElementException();\n            current = next;\n            next = null;\n            return current;\n        }\n\n        private void maybeFindNext() {\n            if (stopped || next != null) return;\n\n            // drain the current queue before stepping to get more\n            if (!emitQueue.isEmpty()) {\n                next = emitQueue.remove();\n                return;\n            }\n\n            // step the parser, which will hit the node listeners to add to the queue:\n            while (treeBuilder.stepParser()) {\n                if (!emitQueue.isEmpty()) {\n                    next = emitQueue.remove();\n                    return;\n                }\n            }\n            stop();\n            close();\n\n            // send the final element out:\n            if (tail != null) {\n                next = tail;\n                tail = null;\n            }\n        }\n\n        @Override public void remove() {\n            if (current == null) throw new NoSuchElementException();\n            current.remove();\n        }\n\n        // NodeVisitor Interface:\n        @Override public void head(Node node, int depth) {\n            if (node instanceof Element) {\n                Element prev = ((Element) node).previousElementSibling();\n                // We prefer to wait until an element has a next sibling before emitting it; otherwise, get it in tail\n                if (prev != null) emitQueue.add(prev);\n            }\n        }\n\n        @Override public void tail(Node node, int depth) {\n            if (node instanceof Element) {\n                tail = (Element) node; // kept for final hit\n                Element lastChild = tail.lastElementChild(); // won't get a nextsib, so emit that:\n                if (lastChild != null) emitQueue.add(lastChild);\n            }\n        }\n    }\n}", "super_interfaces": ["Closeable"], "fields": [{"attribute_expression": "final private Parser parser;", "docstring": "", "modifiers": "final private", "marker_annotations": [], "non_marker_annotations": ["final", "private"], "comments": [], "type": "Parser", "name": "parser", "syntax_pass": true}, {"attribute_expression": "final private TreeBuilder treeBuilder;", "docstring": "", "modifiers": "final private", "marker_annotations": [], "non_marker_annotations": ["final", "private"], "comments": [], "type": "TreeBuilder", "name": "treeBuilder", "syntax_pass": true}, {"attribute_expression": "final private ElementIterator it = new ElementIterator();", "docstring": "", "modifiers": "final private", "marker_annotations": [], "non_marker_annotations": ["final", "private"], "comments": [], "type": "ElementIterator", "name": "it = new ElementIterator()", "syntax_pass": true}, {"attribute_expression": "@Nullable private Document document;", "docstring": "", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Document", "name": "document", "syntax_pass": true}, {"attribute_expression": "private boolean stopped = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "stopped = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder", "name": "HtmlTreeBuilder", "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java", "superclasses": "TreeBuilder", "methods": ["[ParseSettings]defaultSettings()", "[HtmlTreeBuilder]newInstance()", "[void]initialiseParse(Reader,String,Parser)", "[void]initialiseParseFragment(Element)", "[List<Node>]completeParseFragment()", "[boolean]process(Token)", "[boolean]useCurrentOrForeignInsert(Token)", "[boolean]isMathmlTextIntegration(Element)", "[boolean]isHtmlIntegration(Element)", "[boolean]process(Token,HtmlTreeBuilderState)", "[void]transition(HtmlTreeBuilderState)", "[HtmlTreeBuilderState]state()", "[void]markInsertionMode()", "[HtmlTreeBuilderState]originalState()", "[void]framesetOk(boolean)", "[boolean]framesetOk()", "[Document]getDocument()", "[String]getBaseUri()", "[void]maybeSetBaseUri(Element)", "[boolean]isFragmentParsing()", "[void]error(HtmlTreeBuilderState)", "[Element]createElementFor(Token.StartTag,String,boolean)", "[Element]insertElementFor(Token.StartTag)", "[Element]insertForeignElementFor(Token.StartTag,String)", "[Element]insertEmptyElementFor(Token.StartTag)", "[FormElement]insertFormElement(Token.StartTag,boolean,boolean)", "[void]doInsertElement(Element,Token)", "[void]insertCommentNode(Token.Comment)", "[void]insertCharacterNode(Token.Character)", "[void]insertCharacterToElement(Token.Character,Element)", "[ArrayList<Element>]getStack()", "[boolean]onStack(Element)", "[boolean]onStack(String)", "[boolean]onStack(ArrayList<Element>,Element)", "[Element]getFromStack(String)", "[boolean]removeFromStack(Element)", "[Element]popStackToClose(String)", "[Element]popStackToCloseAnyNamespace(String)", "[void]popStackToClose()", "[void]clearStackToTableContext()", "[void]clearStackToTableBodyContext()", "[void]clearStackToTableRowContext()", "[void]clearStackToContext()", "[Element]aboveOnStack(Element)", "[void]insertOnStackAfter(Element,Element)", "[void]replaceOnStack(Element,Element)", "[void]replaceInQueue(ArrayList<Element>,Element,Element)", "[boolean]resetInsertionMode()", "[void]resetBody()", "[boolean]inSpecificScope(String,String[],String[])", "[boolean]inSpecificScope(String[],String[],String[])", "[boolean]inScope(String[])", "[boolean]inScope(String)", "[boolean]inScope(String,String[])", "[boolean]inListItemScope(String)", "[boolean]inButtonScope(String)", "[boolean]inTableScope(String)", "[boolean]inSelectScope(String)", "[boolean]onStackNot(String[])", "[void]setHeadElement(Element)", "[Element]getHeadElement()", "[boolean]isFosterInserts()", "[void]setFosterInserts(boolean)", "[FormElement]getFormElement()", "[void]setFormElement(FormElement)", "[void]resetPendingTableCharacters()", "[List<Token.Character>]getPendingTableCharacters()", "[void]addPendingTableCharacters(Token.Character)", "[void]generateImpliedEndTags(String)", "[void]generateImpliedEndTags()", "[void]generateImpliedEndTags(boolean)", "[void]closeElement(String)", "[boolean]isSpecial(Element)", "[Element]lastFormattingElement()", "[int]positionOfElement(Element)", "[Element]removeLastFormattingElement()", "[void]pushActiveFormattingElements(Element)", "[void]pushWithBookmark(Element,int)", "[void]checkActiveFormattingElements(Element)", "[boolean]isSameFormattingElement(Element,Element)", "[void]reconstructFormattingElements()", "[void]clearFormattingElementsToLastMarker()", "[void]removeFromActiveFormattingElements(Element)", "[boolean]isInActiveFormattingElements(Element)", "[Element]getActiveFormattingElement(String)", "[void]replaceActiveFormattingElement(Element,Element)", "[void]insertMarkerToFormattingElements()", "[void]insertInFosterParent(Node)", "[void]pushTemplateMode(HtmlTreeBuilderState)", "[HtmlTreeBuilderState]popTemplateMode()", "[int]templateModeSize()", "[HtmlTreeBuilderState]currentTemplateMode()", "[String]toString()", "[boolean]isContentForTagData(String)"], "method_uris": ["src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[ParseSettings]defaultSettings()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilder]newInstance()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]initialiseParse(Reader,String,Parser)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]initialiseParseFragment(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[List<Node>]completeParseFragment()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]process(Token)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]useCurrentOrForeignInsert(Token)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isMathmlTextIntegration(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isHtmlIntegration(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]process(Token,HtmlTreeBuilderState)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]transition(HtmlTreeBuilderState)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilderState]state()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]markInsertionMode()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilderState]originalState()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]framesetOk(boolean)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]framesetOk()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Document]getDocument()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[String]getBaseUri()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]maybeSetBaseUri(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isFragmentParsing()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]error(HtmlTreeBuilderState)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]createElementFor(Token.StartTag,String,boolean)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]insertElementFor(Token.StartTag)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]insertForeignElementFor(Token.StartTag,String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]insertEmptyElementFor(Token.StartTag)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[FormElement]insertFormElement(Token.StartTag,boolean,boolean)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]doInsertElement(Element,Token)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertCommentNode(Token.Comment)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertCharacterNode(Token.Character)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertCharacterToElement(Token.Character,Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[ArrayList<Element>]getStack()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]onStack(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]onStack(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]onStack(ArrayList<Element>,Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]getFromStack(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]removeFromStack(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]popStackToClose(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]popStackToCloseAnyNamespace(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]popStackToClose()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearStackToTableContext()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearStackToTableBodyContext()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearStackToTableRowContext()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearStackToContext()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]aboveOnStack(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertOnStackAfter(Element,Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]replaceOnStack(Element,Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]replaceInQueue(ArrayList<Element>,Element,Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]resetInsertionMode()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]resetBody()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inSpecificScope(String,String[],String[])", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inSpecificScope(String[],String[],String[])", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inScope(String[])", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inScope(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inScope(String,String[])", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inListItemScope(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inButtonScope(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inTableScope(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]inSelectScope(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]onStackNot(String[])", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]setHeadElement(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]getHeadElement()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isFosterInserts()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]setFosterInserts(boolean)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[FormElement]getFormElement()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]setFormElement(FormElement)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]resetPendingTableCharacters()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[List<Token.Character>]getPendingTableCharacters()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]addPendingTableCharacters(Token.Character)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]generateImpliedEndTags(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]generateImpliedEndTags()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]generateImpliedEndTags(boolean)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]closeElement(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isSpecial(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]lastFormattingElement()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[int]positionOfElement(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]removeLastFormattingElement()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]pushActiveFormattingElements(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]pushWithBookmark(Element,int)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]checkActiveFormattingElements(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isSameFormattingElement(Element,Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]reconstructFormattingElements()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]clearFormattingElementsToLastMarker()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]removeFromActiveFormattingElements(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isInActiveFormattingElements(Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[Element]getActiveFormattingElement(String)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]replaceActiveFormattingElement(Element,Element)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertMarkerToFormattingElements()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]insertInFosterParent(Node)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[void]pushTemplateMode(HtmlTreeBuilderState)", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilderState]popTemplateMode()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[int]templateModeSize()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[HtmlTreeBuilderState]currentTemplateMode()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[String]toString()", "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java.HtmlTreeBuilder.[boolean]isContentForTagData(String)"], "overrides": null, "attributes": [], "class_docstring": "\nHTML Tree Builder; creates a DOM from Tokens.\n", "original_string": "public class HtmlTreeBuilder extends TreeBuilder {\n    // tag searches. must be sorted, used in inSorted. HtmlTreeBuilderTest validates they're sorted.\n    static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"marquee\", \"object\", \"table\", \"td\", \"th\"};\n    static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};\n    static final String[] TagSearchButton = new String[]{\"button\"};\n    static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};\n    static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};\n    static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rb\", \"rp\", \"rt\", \"rtc\"};\n    static final String[] TagThoroughSearchEndTags = new String[]{\"caption\", \"colgroup\", \"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rb\", \"rp\", \"rt\", \"rtc\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};\n    static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n        \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n        \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n        \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n        \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n        \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n        \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n        \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};\n    static final String[] TagMathMlTextIntegration = new String[]{\"mi\", \"mn\", \"mo\", \"ms\", \"mtext\"};\n    static final String[] TagSvgHtmlIntegration = new String[]{\"desc\", \"foreignObject\", \"title\"};\n\n    public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages\n\n    private HtmlTreeBuilderState state; // the current state\n    private HtmlTreeBuilderState originalState; // original / marked state\n\n    private boolean baseUriSetFromDoc;\n    private @Nullable Element headElement; // the current head element\n    private @Nullable FormElement formElement; // the current form element\n    private @Nullable Element contextElement; // fragment parse root; name only copy of context. could be null even if fragment parsing\n    private ArrayList<Element> formattingElements; // active (open) formatting elements\n    private ArrayList<HtmlTreeBuilderState> tmplInsertMode; // stack of Template Insertion modes\n    private List<Token.Character> pendingTableCharacters; // chars in table to be shifted out\n    private Token.EndTag emptyEnd; // reused empty end tag\n\n    private boolean framesetOk; // if ok to go into frameset\n    private boolean fosterInserts; // if next inserts should be fostered\n    private boolean fragmentParsing; // if parsing a fragment of html\n\n    @Override ParseSettings defaultSettings() {\n        return ParseSettings.htmlDefault;\n    }\n\n    @Override\n    HtmlTreeBuilder newInstance() {\n        return new HtmlTreeBuilder();\n    }\n\n    @Override\n    protected void initialiseParse(Reader input, String baseUri, Parser parser) {\n        super.initialiseParse(input, baseUri, parser);\n\n        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n        state = HtmlTreeBuilderState.Initial;\n        originalState = null;\n        baseUriSetFromDoc = false;\n        headElement = null;\n        formElement = null;\n        contextElement = null;\n        formattingElements = new ArrayList<>();\n        tmplInsertMode = new ArrayList<>();\n        pendingTableCharacters = new ArrayList<>();\n        emptyEnd = new Token.EndTag(this);\n        framesetOk = true;\n        fosterInserts = false;\n        fragmentParsing = false;\n    }\n\n    @Override void initialiseParseFragment(@Nullable Element context) {\n        // context may be null\n        state = HtmlTreeBuilderState.Initial;\n        fragmentParsing = true;\n\n        if (context != null) {\n            final String contextName = context.normalName();\n            contextElement = new Element(tagFor(contextName, settings), baseUri);\n            if (context.ownerDocument() != null) // quirks setup:\n                doc.quirksMode(context.ownerDocument().quirksMode());\n\n            // initialise the tokeniser state:\n            switch (contextName) {\n                case \"title\":\n                case \"textarea\":\n                    tokeniser.transition(TokeniserState.Rcdata);\n                    break;\n                case \"iframe\":\n                case \"noembed\":\n                case \"noframes\":\n                case \"style\":\n                case \"xmp\":\n                    tokeniser.transition(TokeniserState.Rawtext);\n                    break;\n                case \"script\":\n                    tokeniser.transition(TokeniserState.ScriptData);\n                    break;\n                case \"plaintext\":\n                    tokeniser.transition(TokeniserState.PLAINTEXT);\n                    break;\n                case \"template\":\n                    tokeniser.transition(TokeniserState.Data);\n                    pushTemplateMode(HtmlTreeBuilderState.InTemplate);\n                    break;\n                default:\n                    tokeniser.transition(TokeniserState.Data);\n            }\n            doc.appendChild(contextElement);\n            push(contextElement);\n            resetInsertionMode();\n\n            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n            // with form correctly\n            Element formSearch = context;\n            while (formSearch != null) {\n                if (formSearch instanceof FormElement) {\n                    formElement = (FormElement) formSearch;\n                    break;\n                }\n                formSearch = formSearch.parent();\n            }\n        }\n    }\n\n    @Override List<Node> completeParseFragment() {\n        if (contextElement != null) {\n            // depending on context and the input html, content may have been added outside of the root el\n            // e.g. context=p, input=div, the div will have been pushed out.\n            List<Node> nodes = contextElement.siblingNodes();\n            if (!nodes.isEmpty())\n                contextElement.insertChildren(-1, nodes);\n            return contextElement.childNodes();\n        }\n        else\n            return doc.childNodes();\n    }\n\n    @Override\n    protected boolean process(Token token) {\n        HtmlTreeBuilderState dispatch = useCurrentOrForeignInsert(token) ? this.state : ForeignContent;\n        return dispatch.process(token, this);\n    }\n\n    boolean useCurrentOrForeignInsert(Token token) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction\n        // If the stack of open elements is empty\n        if (stack.isEmpty())\n            return true;\n        final Element el = currentElement();\n        final String ns = el.tag().namespace();\n\n        // If the adjusted current node is an element in the HTML namespace\n        if (NamespaceHtml.equals(ns))\n            return true;\n\n        // If the adjusted current node is a MathML text integration point and the token is a start tag whose tag name is neither \"mglyph\" nor \"malignmark\"\n        // If the adjusted current node is a MathML text integration point and the token is a character token\n        if (isMathmlTextIntegration(el)) {\n            if (token.isStartTag()\n                    && !\"mglyph\".equals(token.asStartTag().normalName)\n                    && !\"malignmark\".equals(token.asStartTag().normalName))\n                    return true;\n            if (token.isCharacter())\n                    return true;\n        }\n        // If the adjusted current node is a MathML annotation-xml element and the token is a start tag whose tag name is \"svg\"\n        if (Parser.NamespaceMathml.equals(ns)\n            && el.nameIs(\"annotation-xml\")\n            && token.isStartTag()\n            && \"svg\".equals(token.asStartTag().normalName))\n            return true;\n\n        // If the adjusted current node is an HTML integration point and the token is a start tag\n        // If the adjusted current node is an HTML integration point and the token is a character token\n        if (isHtmlIntegration(el)\n            && (token.isStartTag() || token.isCharacter()))\n            return true;\n\n        // If the token is an end-of-file token\n        return token.isEOF();\n    }\n\n    static boolean isMathmlTextIntegration(Element el) {\n        /*\n        A node is a MathML text integration point if it is one of the following elements:\n        A MathML mi element\n        A MathML mo element\n        A MathML mn element\n        A MathML ms element\n        A MathML mtext element\n         */\n        return (Parser.NamespaceMathml.equals(el.tag().namespace())\n            && StringUtil.inSorted(el.normalName(), TagMathMlTextIntegration));\n    }\n\n    static boolean isHtmlIntegration(Element el) {\n        /*\n        A node is an HTML integration point if it is one of the following elements:\n        A MathML annotation-xml element whose start tag token had an attribute with the name \"encoding\" whose value was an ASCII case-insensitive match for the string \"text/html\"\n        A MathML annotation-xml element whose start tag token had an attribute with the name \"encoding\" whose value was an ASCII case-insensitive match for the string \"application/xhtml+xml\"\n        An SVG foreignObject element\n        An SVG desc element\n        An SVG title element\n         */\n        if (Parser.NamespaceMathml.equals(el.tag().namespace())\n            && el.nameIs(\"annotation-xml\")) {\n            String encoding = Normalizer.normalize(el.attr(\"encoding\"));\n            if (encoding.equals(\"text/html\") || encoding.equals(\"application/xhtml+xml\"))\n                return true;\n        }\n        if (Parser.NamespaceSvg.equals(el.tag().namespace())\n            && StringUtil.in(el.tagName(), TagSvgHtmlIntegration)) // note using .tagName for case-sensitive hit here of foreignObject\n            return true;\n\n        return false;\n    }\n\n    boolean process(Token token, HtmlTreeBuilderState state) {\n        return state.process(token, this);\n    }\n\n    void transition(HtmlTreeBuilderState state) {\n        this.state = state;\n    }\n\n    HtmlTreeBuilderState state() {\n        return state;\n    }\n\n    void markInsertionMode() {\n        originalState = state;\n    }\n\n    HtmlTreeBuilderState originalState() {\n        return originalState;\n    }\n\n    void framesetOk(boolean framesetOk) {\n        this.framesetOk = framesetOk;\n    }\n\n    boolean framesetOk() {\n        return framesetOk;\n    }\n\n    Document getDocument() {\n        return doc;\n    }\n\n    String getBaseUri() {\n        return baseUri;\n    }\n\n    void maybeSetBaseUri(Element base) {\n        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n            return;\n\n        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (parser.getErrors().canAddError())\n            parser.getErrors().add(new ParseError(reader, \"Unexpected %s token [%s] when in state [%s]\",\n                currentToken.tokenType(), currentToken, state));\n    }\n\n    Element createElementFor(Token.StartTag startTag, String namespace, boolean forcePreserveCase) {\n        // dedupe and normalize the attributes:\n        Attributes attributes = startTag.attributes;\n        if (!forcePreserveCase)\n            attributes = settings.normalizeAttributes(attributes);\n        if (attributes != null && !attributes.isEmpty()) {\n            int dupes = attributes.deduplicate(settings);\n            if (dupes > 0) {\n                error(\"Dropped duplicate attribute(s) in tag [%s]\", startTag.normalName);\n            }\n        }\n\n        Tag tag = tagFor(startTag.tagName, namespace,\n            forcePreserveCase ? ParseSettings.preserveCase : settings);\n\n        return (tag.normalName().equals(\"form\")) ?\n            new FormElement(tag, null, attributes) :\n            new Element(tag, null, attributes);\n    }\n\n    /** Inserts an HTML element for the given tag) */\n    Element insertElementFor(final Token.StartTag startTag) {\n        Element el = createElementFor(startTag, NamespaceHtml, false);\n        doInsertElement(el, startTag);\n\n        // handle self-closing tags. when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Tag tag = el.tag();\n            if (tag.isKnownTag()) {\n                if (!tag.isEmpty())\n                    tokeniser.error(\"Tag [%s] cannot be self closing; not a void tag\", tag.normalName());\n                // else: ok\n            }\n            else { // unknown tag: remember this is self-closing, for output\n                tag.setSelfClosing();\n            }\n\n            // effectively a pop, but fiddles with the state. handles empty style, title etc which would otherwise leave us in data state\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n        }\n\n        return el;\n    }\n\n    /**\n     Inserts a foreign element. Preserves the case of the tag name and of the attributes.\n     */\n    Element insertForeignElementFor(final Token.StartTag startTag, String namespace) {\n        Element el = createElementFor(startTag, namespace, true);\n        doInsertElement(el, startTag);\n\n        if (startTag.isSelfClosing()) {\n            el.tag().setSelfClosing(); // remember this is self-closing for output\n            pop();\n        }\n\n        return el;\n    }\n\n    Element insertEmptyElementFor(Token.StartTag startTag) {\n        Element el = createElementFor(startTag, NamespaceHtml, false);\n        doInsertElement(el, startTag);\n        pop();\n        return el;\n    }\n\n    FormElement insertFormElement(Token.StartTag startTag, boolean onStack, boolean checkTemplateStack) {\n        FormElement el = (FormElement) createElementFor(startTag, NamespaceHtml, false);\n\n        if (checkTemplateStack) {\n            if(!onStack(\"template\"))\n                setFormElement(el);\n        } else\n            setFormElement(el);\n\n        doInsertElement(el, startTag);\n        if (!onStack) pop();\n        return el;\n    }\n\n    /** Inserts the Element onto the stack. All element inserts must run through this method. Performs any general\n     tests on the Element before insertion.\n     * @param el the Element to insert and make the current element\n     * @param token the token this element was parsed from. If null, uses a zero-width current token as intrinsic insert\n     */\n    private void doInsertElement(Element el, @Nullable Token token) {\n        if (el.tag().isFormListed() && formElement != null)\n            formElement.addElement(el); // connect form controls to their form element\n\n        // in HTML, the xmlns attribute if set must match what the parser set the tag's namespace to\n        if (parser.getErrors().canAddError() && el.hasAttr(\"xmlns\") && !el.attr(\"xmlns\").equals(el.tag().namespace()))\n            error(\"Invalid xmlns attribute [%s] on tag [%s]\", el.attr(\"xmlns\"), el.tagName());\n\n        if (isFosterInserts() && StringUtil.inSorted(currentElement().normalName(), InTableFoster))\n            insertInFosterParent(el);\n        else\n            currentElement().appendChild(el);\n\n        push(el);\n    }\n\n    void insertCommentNode(Token.Comment token) {\n        Comment node = new Comment(token.getData());\n        currentElement().appendChild(node);\n        onNodeInserted(node);\n    }\n\n    /** Inserts the provided character token into the current element. */\n    void insertCharacterNode(Token.Character characterToken) {\n        Element el = currentElement(); // will be doc if no current element; allows for whitespace to be inserted into the doc root object (not on the stack)\n        insertCharacterToElement(characterToken, el);\n    }\n\n    /** Inserts the provided character token into the provided element. */\n    void insertCharacterToElement(Token.Character characterToken, Element el) {\n        final Node node;\n        final String tagName = el.normalName();\n        final String data = characterToken.getData();\n\n        if (characterToken.isCData())\n            node = new CDataNode(data);\n        else if (isContentForTagData(tagName))\n            node = new DataNode(data);\n        else\n            node = new TextNode(data);\n        el.appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n        onNodeInserted(node);\n    }\n\n    ArrayList<Element> getStack() {\n        return stack;\n    }\n\n    boolean onStack(Element el) {\n        return onStack(stack, el);\n    }\n\n    /** Checks if there is an HTML element with the given name on the stack. */\n    boolean onStack(String elName) {\n        return getFromStack(elName) != null;\n    }\n\n    private static final int maxQueueDepth = 256; // an arbitrary tension point between real HTML and crafted pain\n    private static boolean onStack(ArrayList<Element> queue, Element element) {\n        final int bottom = queue.size() - 1;\n        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;\n        for (int pos = bottom; pos >= upper; pos--) {\n            Element next = queue.get(pos);\n            if (next == element) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** Gets the nearest (lowest) HTML element with the given name from the stack. */\n    @Nullable\n    Element getFromStack(String elName) {\n        final int bottom = stack.size() - 1;\n        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;\n        for (int pos = bottom; pos >= upper; pos--) {\n            Element next = stack.get(pos);\n            if (next.elementIs(elName, NamespaceHtml)) {\n                return next;\n            }\n        }\n        return null;\n    }\n\n    boolean removeFromStack(Element el) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                stack.remove(pos);\n                onNodeClosed(el);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** Pops the stack until the given HTML element is removed. */\n    @Nullable\n    Element popStackToClose(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = pop();\n            if (el.elementIs(elName, NamespaceHtml)) {\n                return el;\n            }\n        }\n        return null;\n    }\n\n    /** Pops the stack until an element with the supplied name is removed, irrespective of namespace. */\n    @Nullable\n    Element popStackToCloseAnyNamespace(String elName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = pop();\n            if (el.nameIs(elName)) {\n                return el;\n            }\n        }\n        return null;\n    }\n\n    /** Pops the stack until one of the given HTML elements is removed. */\n    void popStackToClose(String... elNames) { // elnames is sorted, comes from Constants\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = pop();\n            if (inSorted(el.normalName(), elNames) && NamespaceHtml.equals(el.tag().namespace())) {\n                break;\n            }\n        }\n    }\n\n    void clearStackToTableContext() {\n        clearStackToContext(\"table\", \"template\");\n    }\n\n    void clearStackToTableBodyContext() {\n        clearStackToContext(\"tbody\", \"tfoot\", \"thead\", \"template\");\n    }\n\n    void clearStackToTableRowContext() {\n        clearStackToContext(\"tr\", \"template\");\n    }\n\n    /** Removes elements from the stack until one of the supplied HTML elements is removed. */\n    private void clearStackToContext(String... nodeNames) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (NamespaceHtml.equals(next.tag().namespace()) &&\n                (StringUtil.in(next.normalName(), nodeNames) || next.nameIs(\"html\")))\n                break;\n            else\n                pop();\n        }\n    }\n\n    @Nullable Element aboveOnStack(Element el) {\n        assert onStack(el);\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next == el) {\n                return stack.get(pos-1);\n            }\n        }\n        return null;\n    }\n\n    void insertOnStackAfter(Element after, Element in) {\n        int i = stack.lastIndexOf(after);\n        Validate.isTrue(i != -1);\n        stack.add(i+1, in);\n    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private static void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    /**\n     * Reset the insertion mode, by searching up the stack for an appropriate insertion mode. The stack search depth\n     * is limited to {@link #maxQueueDepth}.\n     * @return true if the insertion mode was actually changed.\n     */\n    boolean resetInsertionMode() {\n        // https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode\n        boolean last = false;\n        final int bottom = stack.size() - 1;\n        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;\n        final HtmlTreeBuilderState origState = this.state;\n\n        if (stack.size() == 0) { // nothing left of stack, just get to body\n            transition(HtmlTreeBuilderState.InBody);\n        }\n\n        LOOP: for (int pos = bottom; pos >= upper; pos--) {\n            Element node = stack.get(pos);\n            if (pos == upper) {\n                last = true;\n                if (fragmentParsing)\n                    node = contextElement;\n            }\n            String name = node != null ? node.normalName() : \"\";\n            if (!NamespaceHtml.equals(node.tag().namespace()))\n                continue; // only looking for HTML elements here\n\n            switch (name) {\n                case \"select\":\n                    transition(HtmlTreeBuilderState.InSelect);\n                    // todo - should loop up (with some limit) and check for table or template hits\n                    break LOOP;\n                case \"td\":\n                case \"th\":\n                    if (!last) {\n                        transition(HtmlTreeBuilderState.InCell);\n                        break LOOP;\n                    }\n                    break;\n                case \"tr\":\n                    transition(HtmlTreeBuilderState.InRow);\n                    break LOOP;\n                case \"tbody\":\n                case \"thead\":\n                case \"tfoot\":\n                    transition(HtmlTreeBuilderState.InTableBody);\n                    break LOOP;\n                case \"caption\":\n                    transition(HtmlTreeBuilderState.InCaption);\n                    break LOOP;\n                case \"colgroup\":\n                    transition(HtmlTreeBuilderState.InColumnGroup);\n                    break LOOP;\n                case \"table\":\n                    transition(HtmlTreeBuilderState.InTable);\n                    break LOOP;\n                case \"template\":\n                    HtmlTreeBuilderState tmplState = currentTemplateMode();\n                    Validate.notNull(tmplState, \"Bug: no template insertion mode on stack!\");\n                    transition(tmplState);\n                    break LOOP;\n                case \"head\":\n                    if (!last) {\n                        transition(HtmlTreeBuilderState.InHead);\n                        break LOOP;\n                    }\n                    break;\n                case \"body\":\n                    transition(HtmlTreeBuilderState.InBody);\n                    break LOOP;\n                case \"frameset\":\n                    transition(HtmlTreeBuilderState.InFrameset);\n                    break LOOP;\n                case \"html\":\n                    transition(headElement == null ? HtmlTreeBuilderState.BeforeHead : HtmlTreeBuilderState.AfterHead);\n                    break LOOP;\n            }\n            if (last) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            }\n        }\n        return state != origState;\n    }\n\n    /** Places the body back onto the stack and moves to InBody, for cases in AfterBody / AfterAfterBody when more content comes */\n    void resetBody() {\n        if (!onStack(\"body\")) {\n            stack.add(doc.body()); // not onNodeInserted, as already seen\n        }\n        transition(HtmlTreeBuilderState.InBody);\n    }\n\n    // todo: tidy up in specific scope methods\n    private final String[] specificScopeTarget = {null};\n\n    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n        specificScopeTarget[0] = targetName;\n        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n    }\n\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, @Nullable String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {\n            Element el = stack.get(pos);\n            if (!el.tag().namespace().equals(NamespaceHtml)) continue;\n\n            final String elName = el.normalName();\n            if (inSorted(elName, targetNames))\n                return true;\n            if (inSorted(elName, baseTypes))\n                return false;\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false;\n        }\n        //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n        return false;\n    }\n\n    boolean inScope(String[] targetNames) {\n        return inSpecificScope(targetNames, TagsSearchInScope, null);\n    }\n\n    boolean inScope(String targetName) {\n        return inScope(targetName, null);\n    }\n\n    boolean inScope(String targetName, String[] extras) {\n        return inSpecificScope(targetName, TagsSearchInScope, extras);\n        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n        // todo: in svg namespace: forignOjbect, desc, title\n    }\n\n    boolean inListItemScope(String targetName) {\n        return inScope(targetName, TagSearchList);\n    }\n\n    boolean inButtonScope(String targetName) {\n        return inScope(targetName, TagSearchButton);\n    }\n\n    boolean inTableScope(String targetName) {\n        return inSpecificScope(targetName, TagSearchTableScope, null);\n    }\n\n    boolean inSelectScope(String targetName) {\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element el = stack.get(pos);\n            String elName = el.normalName();\n            if (elName.equals(targetName))\n                return true;\n            if (!inSorted(elName, TagSearchSelectScope)) // all elements except\n                return false;\n        }\n        Validate.fail(\"Should not be reachable\");\n        return false;\n    }\n\n    /** Tests if there is some element on the stack that is not in the provided set. */\n    boolean onStackNot(String[] allowedTags) {\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).normalName();\n            if (!inSorted(elName, allowedTags))\n                return true;\n        }\n        return false;\n    }\n\n    void setHeadElement(Element headElement) {\n        this.headElement = headElement;\n    }\n\n    Element getHeadElement() {\n        return headElement;\n    }\n\n    boolean isFosterInserts() {\n        return fosterInserts;\n    }\n\n    void setFosterInserts(boolean fosterInserts) {\n        this.fosterInserts = fosterInserts;\n    }\n\n    @Nullable FormElement getFormElement() {\n        return formElement;\n    }\n\n    void setFormElement(FormElement formElement) {\n        this.formElement = formElement;\n    }\n\n    void resetPendingTableCharacters() {\n        pendingTableCharacters.clear();\n    }\n\n    List<Token.Character> getPendingTableCharacters() {\n        return pendingTableCharacters;\n    }\n\n    void addPendingTableCharacters(Token.Character c) {\n        // make a clone of the token to maintain its state (as Tokens are otherwise reset)\n        Token.Character clone = c.clone();\n        pendingTableCharacters.add(clone);\n    }\n\n    /**\n     13.2.6.3 Closing elements that have implied end tags\n     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, or an rtc element, the UA must pop the current node off the stack of open elements.\n\n     If a step requires the UA to generate implied end tags but lists an element to exclude from the process, then the UA must perform the above steps as if that element was not in the above list.\n\n     When the steps below require the UA to generate all implied end tags thoroughly, then, while the current node is a caption element, a colgroup element, a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, or a tr element, the UA must pop the current node off the stack of open elements.\n\n     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n     process, then the UA must perform the above steps as if that element was not in the above list.\n     */\n    void generateImpliedEndTags(String excludeTag) {\n        while (inSorted(currentElement().normalName(), TagSearchEndTags)) {\n            if (excludeTag != null && currentElementIs(excludeTag))\n                break;\n            pop();\n        }\n    }\n\n    void generateImpliedEndTags() {\n        generateImpliedEndTags(false);\n    }\n\n    /**\n     Pops HTML elements off the stack according to the implied end tag rules\n     @param thorough if we are thorough (includes table elements etc) or not\n     */\n    void generateImpliedEndTags(boolean thorough) {\n        final String[] search = thorough ? TagThoroughSearchEndTags : TagSearchEndTags;\n        while (NamespaceHtml.equals(currentElement().tag().namespace())\n            && inSorted(currentElement().normalName(), search)) {\n            pop();\n        }\n    }\n\n    void closeElement(String name) {\n        generateImpliedEndTags(name);\n        if (!name.equals(currentElement().normalName())) error(state());\n        popStackToClose(name);\n    }\n\n    static boolean isSpecial(Element el) {\n        // todo: mathml's mi, mo, mn\n        // todo: svg's foreigObject, desc, title\n        String name = el.normalName();\n        return inSorted(name, TagSearchSpecial);\n    }\n\n    Element lastFormattingElement() {\n        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n    }\n\n    int positionOfElement(Element el){\n        for (int i = 0; i < formattingElements.size(); i++){\n            if (el == formattingElements.get(i))\n                return i;\n        }\n        return -1;\n    }\n\n    Element removeLastFormattingElement() {\n        int size = formattingElements.size();\n        if (size > 0)\n            return formattingElements.remove(size-1);\n        else\n            return null;\n    }\n\n    // active formatting elements\n    void pushActiveFormattingElements(Element in) {\n        checkActiveFormattingElements(in);\n        formattingElements.add(in);\n    }\n\n    void pushWithBookmark(Element in, int bookmark){\n        checkActiveFormattingElements(in);\n        // catch any range errors and assume bookmark is incorrect - saves a redundant range check.\n        try {\n            formattingElements.add(bookmark, in);\n        } catch (IndexOutOfBoundsException e) {\n            formattingElements.add(in);\n        }\n    }\n\n    void checkActiveFormattingElements(Element in){\n        int numSeen = 0;\n        final int size = formattingElements.size() -1;\n        int ceil = size - maxUsedFormattingElements; if (ceil <0) ceil = 0;\n\n        for (int pos = size; pos >= ceil; pos--) {\n            Element el = formattingElements.get(pos);\n            if (el == null) // marker\n                break;\n\n            if (isSameFormattingElement(in, el))\n                numSeen++;\n\n            if (numSeen == 3) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    private static boolean isSameFormattingElement(Element a, Element b) {\n        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n        return a.normalName().equals(b.normalName()) &&\n                // a.namespace().equals(b.namespace()) &&\n                a.attributes().equals(b.attributes());\n        // todo: namespaces\n    }\n\n    void reconstructFormattingElements() {\n        if (stack.size() > maxQueueDepth)\n            return;\n        Element last = lastFormattingElement();\n        if (last == null || onStack(last))\n            return;\n\n        Element entry = last;\n        int size = formattingElements.size();\n        int ceil = size - maxUsedFormattingElements; if (ceil <0) ceil = 0;\n        int pos = size - 1;\n        boolean skip = false;\n        while (true) {\n            if (pos == ceil) { // step 4. if none before, skip to 8\n                skip = true;\n                break;\n            }\n            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n                break; // jump to 8, else continue back to 4\n        }\n        while(true) {\n            if (!skip) // step 7: on later than entry\n                entry = formattingElements.get(++pos);\n            Validate.notNull(entry); // should not occur, as we break at last element\n\n            // 8. create new element from element, 9 insert into current node, onto stack\n            skip = false; // can only skip increment from 4.\n            Element newEl = new Element(tagFor(entry.normalName(), settings), null, entry.attributes().clone());\n            doInsertElement(newEl, null);\n\n            // 10. replace entry with new entry\n            formattingElements.set(pos, newEl);\n\n            // 11\n            if (pos == size-1) // if not last entry in list, jump to 7\n                break;\n        }\n    }\n    private static final int maxUsedFormattingElements = 12; // limit how many elements get recreated\n\n    void clearFormattingElementsToLastMarker() {\n        while (!formattingElements.isEmpty()) {\n            Element el = removeLastFormattingElement();\n            if (el == null)\n                break;\n        }\n    }\n\n    void removeFromActiveFormattingElements(Element el) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == el) {\n                formattingElements.remove(pos);\n                break;\n            }\n        }\n    }\n\n    boolean isInActiveFormattingElements(Element el) {\n        return onStack(formattingElements, el);\n    }\n\n    @Nullable\n    Element getActiveFormattingElement(String nodeName) {\n        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n            Element next = formattingElements.get(pos);\n            if (next == null) // scope marker\n                break;\n            else if (next.nameIs(nodeName))\n                return next;\n        }\n        return null;\n    }\n\n    void replaceActiveFormattingElement(Element out, Element in) {\n        replaceInQueue(formattingElements, out, in);\n    }\n\n    void insertMarkerToFormattingElements() {\n        formattingElements.add(null);\n    }\n\n    void insertInFosterParent(Node in) {\n        Element fosterParent;\n        Element lastTable = getFromStack(\"table\");\n        boolean isLastTableParent = false;\n        if (lastTable != null) {\n            if (lastTable.parent() != null) {\n                fosterParent = lastTable.parent();\n                isLastTableParent = true;\n            } else\n                fosterParent = aboveOnStack(lastTable);\n        } else { // no table == frag\n            fosterParent = stack.get(0);\n        }\n\n        if (isLastTableParent) {\n            Validate.notNull(lastTable); // last table cannot be null by this point.\n            lastTable.before(in);\n        }\n        else\n            fosterParent.appendChild(in);\n    }\n\n    // Template Insertion Mode stack\n    void pushTemplateMode(HtmlTreeBuilderState state) {\n        tmplInsertMode.add(state);\n    }\n\n    @Nullable HtmlTreeBuilderState popTemplateMode() {\n        if (tmplInsertMode.size() > 0) {\n            return tmplInsertMode.remove(tmplInsertMode.size() -1);\n        } else {\n            return null;\n        }\n    }\n\n    int templateModeSize() {\n        return tmplInsertMode.size();\n    }\n\n    @Nullable HtmlTreeBuilderState currentTemplateMode() {\n        return (tmplInsertMode.size() > 0) ? tmplInsertMode.get(tmplInsertMode.size() -1)  : null;\n    }\n\n    @Override\n    public String toString() {\n        return \"TreeBuilder{\" +\n                \"currentToken=\" + currentToken +\n                \", state=\" + state +\n                \", currentElement=\" + currentElement() +\n                '}';\n    }\n\n    @Override protected boolean isContentForTagData(final String normalName) {\n        return (normalName.equals(\"script\") || normalName.equals(\"style\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final String[] TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"marquee\", \"object\", \"table\", \"td\", \"th\"};", "docstring": " tag searches. must be sorted, used in inSorted. HtmlTreeBuilderTest validates they're sorted.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagsSearchInScope = new String[]{\"applet\", \"caption\", \"html\", \"marquee\", \"object\", \"table\", \"td\", \"th\"}", "syntax_pass": true}, {"attribute_expression": "static final String[] TagSearchList = new String[]{\"ol\", \"ul\"};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagSearchList = new String[]{\"ol\", \"ul\"}", "syntax_pass": true}, {"attribute_expression": "static final String[] TagSearchButton = new String[]{\"button\"};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagSearchButton = new String[]{\"button\"}", "syntax_pass": true}, {"attribute_expression": "static final String[] TagSearchTableScope = new String[]{\"html\", \"table\"};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagSearchTableScope = new String[]{\"html\", \"table\"}", "syntax_pass": true}, {"attribute_expression": "static final String[] TagSearchSelectScope = new String[]{\"optgroup\", \"option\"};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagSearchSelectScope = new String[]{\"optgroup\", \"option\"}", "syntax_pass": true}, {"attribute_expression": "static final String[] TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rb\", \"rp\", \"rt\", \"rtc\"};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagSearchEndTags = new String[]{\"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rb\", \"rp\", \"rt\", \"rtc\"}", "syntax_pass": true}, {"attribute_expression": "static final String[] TagThoroughSearchEndTags = new String[]{\"caption\", \"colgroup\", \"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rb\", \"rp\", \"rt\", \"rtc\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagThoroughSearchEndTags = new String[]{\"caption\", \"colgroup\", \"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rb\", \"rp\", \"rt\", \"rtc\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"}", "syntax_pass": true}, {"attribute_expression": "static final String[] TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n        \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n        \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n        \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n        \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n        \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n        \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n        \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagSearchSpecial = new String[]{\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n        \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n        \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n        \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n        \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n        \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n        \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n        \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\"}", "syntax_pass": true}, {"attribute_expression": "static final String[] TagMathMlTextIntegration = new String[]{\"mi\", \"mn\", \"mo\", \"ms\", \"mtext\"};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagMathMlTextIntegration = new String[]{\"mi\", \"mn\", \"mo\", \"ms\", \"mtext\"}", "syntax_pass": true}, {"attribute_expression": "static final String[] TagSvgHtmlIntegration = new String[]{\"desc\", \"foreignObject\", \"title\"};", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "TagSvgHtmlIntegration = new String[]{\"desc\", \"foreignObject\", \"title\"}", "syntax_pass": true}, {"attribute_expression": "public static final int MaxScopeSearchDepth = 100;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MaxScopeSearchDepth = 100", "syntax_pass": true}, {"attribute_expression": "private HtmlTreeBuilderState state;", "docstring": " prevents the parser bogging down in exceptionally broken pages", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HtmlTreeBuilderState", "name": "state", "syntax_pass": true}, {"attribute_expression": "private HtmlTreeBuilderState originalState;", "docstring": " the current state", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HtmlTreeBuilderState", "name": "originalState", "syntax_pass": true}, {"attribute_expression": "private boolean baseUriSetFromDoc;", "docstring": " original / marked state", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "baseUriSetFromDoc", "syntax_pass": true}, {"attribute_expression": "private @Nullable Element headElement;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Element", "name": "headElement", "syntax_pass": true}, {"attribute_expression": "private @Nullable FormElement formElement;", "docstring": " the current head element", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "FormElement", "name": "formElement", "syntax_pass": true}, {"attribute_expression": "private @Nullable Element contextElement;", "docstring": " the current form element", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Element", "name": "contextElement", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Element> formattingElements;", "docstring": " fragment parse root; name only copy of context. could be null even if fragment parsing", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Element>", "name": "formattingElements", "syntax_pass": true}, {"attribute_expression": "private ArrayList<HtmlTreeBuilderState> tmplInsertMode;", "docstring": " active (open) formatting elements", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<HtmlTreeBuilderState>", "name": "tmplInsertMode", "syntax_pass": true}, {"attribute_expression": "private List<Token.Character> pendingTableCharacters;", "docstring": " stack of Template Insertion modes", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Token.Character>", "name": "pendingTableCharacters", "syntax_pass": true}, {"attribute_expression": "private Token.EndTag emptyEnd;", "docstring": " chars in table to be shifted out", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Token.EndTag", "name": "emptyEnd", "syntax_pass": true}, {"attribute_expression": "private boolean framesetOk;", "docstring": " reused empty end tag", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "framesetOk", "syntax_pass": true}, {"attribute_expression": "private boolean fosterInserts;", "docstring": " if ok to go into frameset", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "fosterInserts", "syntax_pass": true}, {"attribute_expression": "private boolean fragmentParsing;", "docstring": " if next inserts should be fostered", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "fragmentParsing", "syntax_pass": true}, {"attribute_expression": "private static final int maxQueueDepth = 256;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "maxQueueDepth = 256", "syntax_pass": true}, {"attribute_expression": "private final String[] specificScopeTarget = {null};", "docstring": " todo: tidy up in specific scope methods", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "specificScopeTarget = {null}", "syntax_pass": true}, {"attribute_expression": "private static final int maxUsedFormattingElements = 12;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "maxUsedFormattingElements = 12", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/safety/Safelist.java.Safelist", "name": "Safelist", "file_path": "src/main/java/org/jsoup/safety/Safelist.java", "superclasses": "", "methods": ["[Safelist]none()", "[Safelist]simpleText()", "[Safelist]basic()", "[Safelist]basicWithImages()", "[Safelist]relaxed()", "[]Safelist()", "[]Safelist(Safelist)", "[Safelist]addTags()", "[Safelist]removeTags()", "[Safelist]addAttributes(String)", "[Safelist]removeAttributes(String)", "[Safelist]addEnforcedAttribute(String,String,String)", "[Safelist]removeEnforcedAttribute(String,String)", "[Safelist]preserveRelativeLinks(boolean)", "[Safelist]addProtocols(String,String)", "[Safelist]removeProtocols(String,String)", "[boolean]isSafeTag(String)", "[boolean]isSafeAttribute(String,Element,Attribute)", "[boolean]testValidProtocol(Element,Attribute,Set<Protocol>)", "[boolean]isValidAnchor(String)", "[Attributes]getEnforcedAttributes(String)"], "method_uris": ["src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]none()", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]simpleText()", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]basic()", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]basicWithImages()", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]relaxed()", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[]Safelist()", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[]Safelist(Safelist)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]addTags()", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]removeTags()", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]addAttributes(String)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]removeAttributes(String)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]addEnforcedAttribute(String,String,String)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]removeEnforcedAttribute(String,String)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]preserveRelativeLinks(boolean)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]addProtocols(String,String)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Safelist]removeProtocols(String,String)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[boolean]isSafeTag(String)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[boolean]isSafeAttribute(String,Element,Attribute)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[boolean]testValidProtocol(Element,Attribute,Set<Protocol>)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[boolean]isValidAnchor(String)", "src/main/java/org/jsoup/safety/Safelist.java.Safelist.[Attributes]getEnforcedAttributes(String)"], "overrides": null, "attributes": [{"original_string": "    static class TagName extends TypedValue {\n        TagName(String value) {\n            super(value);\n        }\n\n        static TagName valueOf(String value) {\n            return new TagName(Normalizer.lowerCase(value));\n        }\n    }", "definition": "    static class TagName extends TypedValue", "class_docstring": " named types for config. All just hold strings, but here for my sanity.", "name": "TagName", "super_interfaces": [], "superclasses": "TypedValue", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TagName(String value) {\n            super(value);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TagName", "params": [{"name": "value", "type": "String"}], "body": "                              {\n            super(value);\n        }", "signature": "TagName(String value)"}, {"syntax_pass": true, "original_string": "        static TagName valueOf(String value) {\n            return new TagName(Normalizer.lowerCase(value));\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "TagName", "classes": []}, "name": "valueOf", "params": [{"name": "value", "type": "String"}], "body": "                                             {\n            return new TagName(Normalizer.lowerCase(value));\n        }", "signature": "static TagName valueOf(String value)"}]}, {"original_string": "    static class AttributeKey extends TypedValue {\n        AttributeKey(String value) {\n            super(value);\n        }\n\n        static AttributeKey valueOf(String value) {\n            return new AttributeKey(Normalizer.lowerCase(value));\n        }\n    }", "definition": "    static class AttributeKey extends TypedValue", "class_docstring": "", "name": "AttributeKey", "super_interfaces": [], "superclasses": "TypedValue", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        AttributeKey(String value) {\n            super(value);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AttributeKey", "params": [{"name": "value", "type": "String"}], "body": "                                   {\n            super(value);\n        }", "signature": "AttributeKey(String value)"}, {"syntax_pass": true, "original_string": "        static AttributeKey valueOf(String value) {\n            return new AttributeKey(Normalizer.lowerCase(value));\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "AttributeKey", "classes": []}, "name": "valueOf", "params": [{"name": "value", "type": "String"}], "body": "                                                  {\n            return new AttributeKey(Normalizer.lowerCase(value));\n        }", "signature": "static AttributeKey valueOf(String value)"}]}, {"original_string": "    static class AttributeValue extends TypedValue {\n        AttributeValue(String value) {\n            super(value);\n        }\n\n        static AttributeValue valueOf(String value) {\n            return new AttributeValue(value);\n        }\n    }", "definition": "    static class AttributeValue extends TypedValue", "class_docstring": "", "name": "AttributeValue", "super_interfaces": [], "superclasses": "TypedValue", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        AttributeValue(String value) {\n            super(value);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AttributeValue", "params": [{"name": "value", "type": "String"}], "body": "                                     {\n            super(value);\n        }", "signature": "AttributeValue(String value)"}, {"syntax_pass": true, "original_string": "        static AttributeValue valueOf(String value) {\n            return new AttributeValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "AttributeValue", "classes": []}, "name": "valueOf", "params": [{"name": "value", "type": "String"}], "body": "                                                    {\n            return new AttributeValue(value);\n        }", "signature": "static AttributeValue valueOf(String value)"}]}, {"original_string": "    static class Protocol extends TypedValue {\n        Protocol(String value) {\n            super(value);\n        }\n\n        static Protocol valueOf(String value) {\n            return new Protocol(value);\n        }\n    }", "definition": "    static class Protocol extends TypedValue", "class_docstring": "", "name": "Protocol", "super_interfaces": [], "superclasses": "TypedValue", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Protocol(String value) {\n            super(value);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Protocol", "params": [{"name": "value", "type": "String"}], "body": "                               {\n            super(value);\n        }", "signature": "Protocol(String value)"}, {"syntax_pass": true, "original_string": "        static Protocol valueOf(String value) {\n            return new Protocol(value);\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Protocol", "classes": []}, "name": "valueOf", "params": [{"name": "value", "type": "String"}], "body": "                                              {\n            return new Protocol(value);\n        }", "signature": "static Protocol valueOf(String value)"}]}, {"original_string": "    abstract static class TypedValue {\n        private final String value;\n\n        TypedValue(String value) {\n            Validate.notNull(value);\n            this.value = value;\n        }\n\n        @Override\n        public int hashCode() {\n            return value.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            TypedValue other = (TypedValue) obj;\n            return Objects.equals(value, other.value);\n        }\n\n        @Override\n        public String toString() {\n            return value;\n        }\n    }", "definition": "    abstract static class TypedValue", "class_docstring": "", "name": "TypedValue", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [{"attribute_expression": "private final String value;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TypedValue(String value) {\n            Validate.notNull(value);\n            this.value = value;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TypedValue", "params": [{"name": "value", "type": "String"}], "body": "                                 {\n            Validate.notNull(value);\n            this.value = value;\n        }", "signature": "TypedValue(String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return value.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return value.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            TypedValue other = (TypedValue) obj;\n            return Objects.equals(value, other.value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                          {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            TypedValue other = (TypedValue) obj;\n            return Objects.equals(value, other.value);\n        }", "signature": "@Override\n        public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return value;\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nSafe-lists define what HTML (elements and attributes) to allow through the cleaner. Everything else is removed.\n<p>\nStart with one of the defaults:\n</p>\n<ul>\n<li>{@link #none}\n<li>{@link #simpleText}\n<li>{@link #basic}\n<li>{@link #basicWithImages}\n<li>{@link #relaxed}\n</ul>\n<p>\nIf you need to allow more through (please be careful!), tweak a base safelist with:\n</p>\n<ul>\n<li>{@link #addTags(String... tagNames)}\n<li>{@link #addAttributes(String tagName, String... attributes)}\n<li>{@link #addEnforcedAttribute(String tagName, String attribute, String value)}\n<li>{@link #addProtocols(String tagName, String attribute, String... protocols)}\n</ul>\n<p>\nYou can remove any setting from an existing safelist with:\n</p>\n<ul>\n<li>{@link #removeTags(String... tagNames)}\n<li>{@link #removeAttributes(String tagName, String... attributes)}\n<li>{@link #removeEnforcedAttribute(String tagName, String attribute)}\n<li>{@link #removeProtocols(String tagName, String attribute, String... removeProtocols)}\n</ul>\n\n<p>\nThe cleaner and these safelists assume that you want to clean a <code>body</code> fragment of HTML (to add user\nsupplied HTML into a templated page), and not to clean a full HTML document. If the latter is the case, you could wrap\nthe templated document HTML around the cleaned body HTML.\n</p>\n<p>\nIf you are going to extend a safelist, please be very careful. Make sure you understand what attributes may lead to\nXSS attack vectors. URL attributes are particularly vulnerable and require careful validation. See \nthe <a href=\"https://owasp.org/www-community/xss-filter-evasion-cheatsheet\">XSS Filter Evasion Cheat Sheet</a> for some\nXSS attack examples (that jsoup will safegaurd against the default Cleaner and Safelist configuration).\n</p>\n", "original_string": "public class Safelist {\n    private static final String All = \":all\";\n    private final Set<TagName> tagNames; // tags allowed, lower case. e.g. [p, br, span]\n    private final Map<TagName, Set<AttributeKey>> attributes; // tag -> attribute[]. allowed attributes [href] for a tag.\n    private final Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes; // always set these attribute values\n    private final Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols; // allowed URL protocols for attributes\n    private boolean preserveRelativeLinks; // option to preserve relative links\n\n    /**\n     This safelist allows only text nodes: any HTML Element or any Node other than a TextNode will be removed.\n     <p>\n     Note that the output of {@link org.jsoup.Jsoup#clean(String, Safelist)} is still <b>HTML</b> even when using\n     this Safelist, and so any HTML entities in the output will be appropriately escaped. If you want plain text, not\n     HTML, you should use a text method such as {@link Element#text()} instead, after cleaning the document.\n     </p>\n     <p>Example:</p>\n     <pre>{@code\n     String sourceBodyHtml = \"<p>5 is &lt; 6.</p>\";\n     String html = Jsoup.clean(sourceBodyHtml, Safelist.none());\n\n     Cleaner cleaner = new Cleaner(Safelist.none());\n     String text = cleaner.clean(Jsoup.parse(sourceBodyHtml)).text();\n\n     // html is: 5 is &lt; 6.\n     // text is: 5 is < 6.\n     }</pre>\n\n     @return safelist\n     */\n    public static Safelist none() {\n        return new Safelist();\n    }\n\n    /**\n     This safelist allows only simple text formatting: <code>b, em, i, strong, u</code>. All other HTML (tags and\n     attributes) will be removed.\n\n     @return safelist\n     */\n    public static Safelist simpleText() {\n        return new Safelist()\n                .addTags(\"b\", \"em\", \"i\", \"strong\", \"u\")\n                ;\n    }\n\n    /**\n     <p>\n     This safelist allows a fuller range of text nodes: <code>a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li,\n     ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>, and appropriate attributes.\n     </p>\n     <p>\n     Links (<code>a</code> elements) can point to <code>http, https, ftp, mailto</code>, and have an enforced\n     <code>rel=nofollow</code> attribute.\n     </p>\n     <p>\n     Does not allow images.\n     </p>\n\n     @return safelist\n     */\n    public static Safelist basic() {\n        return new Safelist()\n                .addTags(\n                        \"a\", \"b\", \"blockquote\", \"br\", \"cite\", \"code\", \"dd\", \"dl\", \"dt\", \"em\",\n                        \"i\", \"li\", \"ol\", \"p\", \"pre\", \"q\", \"small\", \"span\", \"strike\", \"strong\", \"sub\",\n                        \"sup\", \"u\", \"ul\")\n\n                .addAttributes(\"a\", \"href\")\n                .addAttributes(\"blockquote\", \"cite\")\n                .addAttributes(\"q\", \"cite\")\n\n                .addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\", \"mailto\")\n                .addProtocols(\"blockquote\", \"cite\", \"http\", \"https\")\n                .addProtocols(\"cite\", \"cite\", \"http\", \"https\")\n\n                .addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")\n                ;\n\n    }\n\n    /**\n     This safelist allows the same text tags as {@link #basic}, and also allows <code>img</code> tags, with appropriate\n     attributes, with <code>src</code> pointing to <code>http</code> or <code>https</code>.\n\n     @return safelist\n     */\n    public static Safelist basicWithImages() {\n        return basic()\n                .addTags(\"img\")\n                .addAttributes(\"img\", \"align\", \"alt\", \"height\", \"src\", \"title\", \"width\")\n                .addProtocols(\"img\", \"src\", \"http\", \"https\")\n                ;\n    }\n\n    /**\n     This safelist allows a full range of text and structural body HTML: <code>a, b, blockquote, br, caption, cite,\n     code, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub,\n     sup, table, tbody, td, tfoot, th, thead, tr, u, ul</code>\n     <p>\n     Links do not have an enforced <code>rel=nofollow</code> attribute, but you can add that if desired.\n     </p>\n\n     @return safelist\n     */\n    public static Safelist relaxed() {\n        return new Safelist()\n                .addTags(\n                        \"a\", \"b\", \"blockquote\", \"br\", \"caption\", \"cite\", \"code\", \"col\",\n                        \"colgroup\", \"dd\", \"div\", \"dl\", \"dt\", \"em\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n                        \"i\", \"img\", \"li\", \"ol\", \"p\", \"pre\", \"q\", \"small\", \"span\", \"strike\", \"strong\",\n                        \"sub\", \"sup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"u\",\n                        \"ul\")\n\n                .addAttributes(\"a\", \"href\", \"title\")\n                .addAttributes(\"blockquote\", \"cite\")\n                .addAttributes(\"col\", \"span\", \"width\")\n                .addAttributes(\"colgroup\", \"span\", \"width\")\n                .addAttributes(\"img\", \"align\", \"alt\", \"height\", \"src\", \"title\", \"width\")\n                .addAttributes(\"ol\", \"start\", \"type\")\n                .addAttributes(\"q\", \"cite\")\n                .addAttributes(\"table\", \"summary\", \"width\")\n                .addAttributes(\"td\", \"abbr\", \"axis\", \"colspan\", \"rowspan\", \"width\")\n                .addAttributes(\n                        \"th\", \"abbr\", \"axis\", \"colspan\", \"rowspan\", \"scope\",\n                        \"width\")\n                .addAttributes(\"ul\", \"type\")\n\n                .addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\", \"mailto\")\n                .addProtocols(\"blockquote\", \"cite\", \"http\", \"https\")\n                .addProtocols(\"cite\", \"cite\", \"http\", \"https\")\n                .addProtocols(\"img\", \"src\", \"http\", \"https\")\n                .addProtocols(\"q\", \"cite\", \"http\", \"https\")\n                ;\n    }\n\n    /**\n     Create a new, empty safelist. Generally it will be better to start with a default prepared safelist instead.\n\n     @see #basic()\n     @see #basicWithImages()\n     @see #simpleText()\n     @see #relaxed()\n     */\n    public Safelist() {\n        tagNames = new HashSet<>();\n        attributes = new HashMap<>();\n        enforcedAttributes = new HashMap<>();\n        protocols = new HashMap<>();\n        preserveRelativeLinks = false;\n    }\n\n    /**\n     Deep copy an existing Safelist to a new Safelist.\n     @param copy the Safelist to copy\n     */\n    public Safelist(Safelist copy) {\n        this();\n        tagNames.addAll(copy.tagNames);\n        for (Map.Entry<TagName, Set<AttributeKey>> copyTagAttributes : copy.attributes.entrySet()) {\n            attributes.put(copyTagAttributes.getKey(), new HashSet<>(copyTagAttributes.getValue()));\n        }\n        for (Map.Entry<TagName, Map<AttributeKey, AttributeValue>> enforcedEntry : copy.enforcedAttributes.entrySet()) {\n            enforcedAttributes.put(enforcedEntry.getKey(), new HashMap<>(enforcedEntry.getValue()));\n        }\n        for (Map.Entry<TagName, Map<AttributeKey, Set<Protocol>>> protocolsEntry : copy.protocols.entrySet()) {\n            Map<AttributeKey, Set<Protocol>> attributeProtocolsCopy = new HashMap<>();\n            for (Map.Entry<AttributeKey, Set<Protocol>> attributeProtocols : protocolsEntry.getValue().entrySet()) {\n                attributeProtocolsCopy.put(attributeProtocols.getKey(), new HashSet<>(attributeProtocols.getValue()));\n            }\n            protocols.put(protocolsEntry.getKey(), attributeProtocolsCopy);\n        }\n        preserveRelativeLinks = copy.preserveRelativeLinks;\n    }\n\n    /**\n     Add a list of allowed elements to a safelist. (If a tag is not allowed, it will be removed from the HTML.)\n\n     @param tags tag names to allow\n     @return this (for chaining)\n     */\n    public Safelist addTags(String... tags) {\n        Validate.notNull(tags);\n\n        for (String tagName : tags) {\n            Validate.notEmpty(tagName);\n            Validate.isFalse(tagName.equalsIgnoreCase(\"noscript\"),\n                \"noscript is unsupported in Safelists, due to incompatibilities between parsers with and without script-mode enabled\");\n            tagNames.add(TagName.valueOf(tagName));\n        }\n        return this;\n    }\n\n    /**\n     Remove a list of allowed elements from a safelist. (If a tag is not allowed, it will be removed from the HTML.)\n\n     @param tags tag names to disallow\n     @return this (for chaining)\n     */\n    public Safelist removeTags(String... tags) {\n        Validate.notNull(tags);\n\n        for(String tag: tags) {\n            Validate.notEmpty(tag);\n            TagName tagName = TagName.valueOf(tag);\n\n            if(tagNames.remove(tagName)) { // Only look in sub-maps if tag was allowed\n                attributes.remove(tagName);\n                enforcedAttributes.remove(tagName);\n                protocols.remove(tagName);\n            }\n        }\n        return this;\n    }\n\n    /**\n     Add a list of allowed attributes to a tag. (If an attribute is not allowed on an element, it will be removed.)\n     <p>\n     E.g.: <code>addAttributes(\"a\", \"href\", \"class\")</code> allows <code>href</code> and <code>class</code> attributes\n     on <code>a</code> tags.\n     </p>\n     <p>\n     To make an attribute valid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n     <code>addAttributes(\":all\", \"class\")</code>.\n     </p>\n\n     @param tag  The tag the attributes are for. The tag will be added to the allowed tag list if necessary.\n     @param attributes List of valid attributes for the tag\n     @return this (for chaining)\n     */\n    public Safelist addAttributes(String tag, String... attributes) {\n        Validate.notEmpty(tag);\n        Validate.notNull(attributes);\n        Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n\n        addTags(tag);\n        TagName tagName = TagName.valueOf(tag);\n        Set<AttributeKey> attributeSet = new HashSet<>();\n        for (String key : attributes) {\n            Validate.notEmpty(key);\n            attributeSet.add(AttributeKey.valueOf(key));\n        }\n        Set<AttributeKey> currentSet = this.attributes.computeIfAbsent(tagName, Functions.setFunction());\n        currentSet.addAll(attributeSet);\n        return this;\n    }\n\n    /**\n     Remove a list of allowed attributes from a tag. (If an attribute is not allowed on an element, it will be removed.)\n     <p>\n     E.g.: <code>removeAttributes(\"a\", \"href\", \"class\")</code> disallows <code>href</code> and <code>class</code>\n     attributes on <code>a</code> tags.\n     </p>\n     <p>\n     To make an attribute invalid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n     <code>removeAttributes(\":all\", \"class\")</code>.\n     </p>\n\n     @param tag  The tag the attributes are for.\n     @param attributes List of invalid attributes for the tag\n     @return this (for chaining)\n     */\n    public Safelist removeAttributes(String tag, String... attributes) {\n        Validate.notEmpty(tag);\n        Validate.notNull(attributes);\n        Validate.isTrue(attributes.length > 0, \"No attribute names supplied.\");\n\n        TagName tagName = TagName.valueOf(tag);\n        Set<AttributeKey> attributeSet = new HashSet<>();\n        for (String key : attributes) {\n            Validate.notEmpty(key);\n            attributeSet.add(AttributeKey.valueOf(key));\n        }\n        if(tagNames.contains(tagName) && this.attributes.containsKey(tagName)) { // Only look in sub-maps if tag was allowed\n            Set<AttributeKey> currentSet = this.attributes.get(tagName);\n            currentSet.removeAll(attributeSet);\n\n            if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n                this.attributes.remove(tagName);\n        }\n        if(tag.equals(All)) { // Attribute needs to be removed from all individually set tags\n            Iterator<Map.Entry<TagName, Set<AttributeKey>>> it = this.attributes.entrySet().iterator();\n            while (it.hasNext()) {\n                Map.Entry<TagName, Set<AttributeKey>> entry = it.next();\n                Set<AttributeKey> currentSet = entry.getValue();\n                currentSet.removeAll(attributeSet);\n                if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n                    it.remove();\n            }\n        }\n        return this;\n    }\n\n    /**\n     Add an enforced attribute to a tag. An enforced attribute will always be added to the element. If the element\n     already has the attribute set, it will be overridden with this value.\n     <p>\n     E.g.: <code>addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")</code> will make all <code>a</code> tags output as\n     <code>&lt;a href=\"...\" rel=\"nofollow\"&gt;</code>\n     </p>\n\n     @param tag   The tag the enforced attribute is for. The tag will be added to the allowed tag list if necessary.\n     @param attribute   The attribute name\n     @param value The enforced attribute value\n     @return this (for chaining)\n     */\n    public Safelist addEnforcedAttribute(String tag, String attribute, String value) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n        Validate.notEmpty(value);\n\n        TagName tagName = TagName.valueOf(tag);\n        tagNames.add(tagName);\n        AttributeKey attrKey = AttributeKey.valueOf(attribute);\n        AttributeValue attrVal = AttributeValue.valueOf(value);\n\n        Map<AttributeKey, AttributeValue> attrMap = enforcedAttributes.computeIfAbsent(tagName, Functions.mapFunction());\n        attrMap.put(attrKey, attrVal);\n        return this;\n    }\n\n    /**\n     Remove a previously configured enforced attribute from a tag.\n\n     @param tag   The tag the enforced attribute is for.\n     @param attribute   The attribute name\n     @return this (for chaining)\n     */\n    public Safelist removeEnforcedAttribute(String tag, String attribute) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n\n        TagName tagName = TagName.valueOf(tag);\n        if(tagNames.contains(tagName) && enforcedAttributes.containsKey(tagName)) {\n            AttributeKey attrKey = AttributeKey.valueOf(attribute);\n            Map<AttributeKey, AttributeValue> attrMap = enforcedAttributes.get(tagName);\n            attrMap.remove(attrKey);\n\n            if(attrMap.isEmpty()) // Remove tag from enforced attribute map if no enforced attributes are present\n                enforcedAttributes.remove(tagName);\n        }\n        return this;\n    }\n\n    /**\n     * Configure this Safelist to preserve relative links in an element's URL attribute, or convert them to absolute\n     * links. By default, this is <b>false</b>: URLs will be  made absolute (e.g. start with an allowed protocol, like\n     * e.g. {@code http://}.\n     * <p>\n     * Note that when handling relative links, the input document must have an appropriate {@code base URI} set when\n     * parsing, so that the link's protocol can be confirmed. Regardless of the setting of the {@code preserve relative\n     * links} option, the link must be resolvable against the base URI to an allowed protocol; otherwise the attribute\n     * will be removed.\n     * </p>\n     *\n     * @param preserve {@code true} to allow relative links, {@code false} (default) to deny\n     * @return this Safelist, for chaining.\n     * @see #addProtocols\n     */\n    public Safelist preserveRelativeLinks(boolean preserve) {\n        preserveRelativeLinks = preserve;\n        return this;\n    }\n\n    /**\n     Add allowed URL protocols for an element's URL attribute. This restricts the possible values of the attribute to\n     URLs with the defined protocol.\n     <p>\n     E.g.: <code>addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\")</code>\n     </p>\n     <p>\n     To allow a link to an in-page URL anchor (i.e. <code>&lt;a href=\"#anchor\"&gt;</code>, add a <code>#</code>:<br>\n     E.g.: <code>addProtocols(\"a\", \"href\", \"#\")</code>\n     </p>\n\n     @param tag       Tag the URL protocol is for\n     @param attribute       Attribute name\n     @param protocols List of valid protocols\n     @return this, for chaining\n     */\n    public Safelist addProtocols(String tag, String attribute, String... protocols) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n        Validate.notNull(protocols);\n\n        TagName tagName = TagName.valueOf(tag);\n        AttributeKey attrKey = AttributeKey.valueOf(attribute);\n        Map<AttributeKey, Set<Protocol>> attrMap = this.protocols.computeIfAbsent(tagName, Functions.mapFunction());\n        Set<Protocol> protSet = attrMap.computeIfAbsent(attrKey, Functions.setFunction());\n\n        for (String protocol : protocols) {\n            Validate.notEmpty(protocol);\n            Protocol prot = Protocol.valueOf(protocol);\n            protSet.add(prot);\n        }\n        return this;\n    }\n\n    /**\n     Remove allowed URL protocols for an element's URL attribute. If you remove all protocols for an attribute, that\n     attribute will allow any protocol.\n     <p>\n     E.g.: <code>removeProtocols(\"a\", \"href\", \"ftp\")</code>\n     </p>\n\n     @param tag Tag the URL protocol is for\n     @param attribute Attribute name\n     @param removeProtocols List of invalid protocols\n     @return this, for chaining\n     */\n    public Safelist removeProtocols(String tag, String attribute, String... removeProtocols) {\n        Validate.notEmpty(tag);\n        Validate.notEmpty(attribute);\n        Validate.notNull(removeProtocols);\n\n        TagName tagName = TagName.valueOf(tag);\n        AttributeKey attr = AttributeKey.valueOf(attribute);\n\n        // make sure that what we're removing actually exists; otherwise can open the tag to any data and that can\n        // be surprising\n        Validate.isTrue(protocols.containsKey(tagName), \"Cannot remove a protocol that is not set.\");\n        Map<AttributeKey, Set<Protocol>> tagProtocols = protocols.get(tagName);\n        Validate.isTrue(tagProtocols.containsKey(attr), \"Cannot remove a protocol that is not set.\");\n\n        Set<Protocol> attrProtocols = tagProtocols.get(attr);\n        for (String protocol : removeProtocols) {\n            Validate.notEmpty(protocol);\n            attrProtocols.remove(Protocol.valueOf(protocol));\n        }\n\n        if (attrProtocols.isEmpty()) { // Remove protocol set if empty\n            tagProtocols.remove(attr);\n            if (tagProtocols.isEmpty()) // Remove entry for tag if empty\n                protocols.remove(tagName);\n        }\n        return this;\n    }\n\n    /**\n     * Test if the supplied tag is allowed by this safelist.\n     * @param tag test tag\n     * @return true if allowed\n     */\n    public boolean isSafeTag(String tag) {\n        return tagNames.contains(TagName.valueOf(tag));\n    }\n\n    /**\n     * Test if the supplied attribute is allowed by this safelist for this tag.\n     * @param tagName tag to consider allowing the attribute in\n     * @param el element under test, to confirm protocol\n     * @param attr attribute under test\n     * @return true if allowed\n     */\n    public boolean isSafeAttribute(String tagName, Element el, Attribute attr) {\n        TagName tag = TagName.valueOf(tagName);\n        AttributeKey key = AttributeKey.valueOf(attr.getKey());\n\n        Set<AttributeKey> okSet = attributes.get(tag);\n        if (okSet != null && okSet.contains(key)) {\n            if (protocols.containsKey(tag)) {\n                Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);\n                // ok if not defined protocol; otherwise test\n                return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));\n            } else { // attribute found, no protocols defined, so OK\n                return true;\n            }\n        }\n        // might be an enforced attribute?\n        Map<AttributeKey, AttributeValue> enforcedSet = enforcedAttributes.get(tag);\n        if (enforcedSet != null) {\n            Attributes expect = getEnforcedAttributes(tagName);\n            String attrKey = attr.getKey();\n            if (expect.hasKeyIgnoreCase(attrKey)) {\n                return expect.getIgnoreCase(attrKey).equals(attr.getValue());\n            }\n        }\n        // no attributes defined for tag, try :all tag\n        return !tagName.equals(All) && isSafeAttribute(All, el, attr);\n    }\n\n    private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n        // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n        // rels without a baseuri get removed\n        String value = el.absUrl(attr.getKey());\n        if (value.length() == 0)\n            value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols\n        if (!preserveRelativeLinks)\n            attr.setValue(value);\n        \n        for (Protocol protocol : protocols) {\n            String prot = protocol.toString();\n\n            if (prot.equals(\"#\")) { // allows anchor links\n                if (isValidAnchor(value)) {\n                    return true;\n                } else {\n                    continue;\n                }\n            }\n\n            prot += \":\";\n\n            if (lowerCase(value).startsWith(prot)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean isValidAnchor(String value) {\n        return value.startsWith(\"#\") && !value.matches(\".*\\\\s.*\");\n    }\n\n    /**\n     Gets the Attributes that should be enforced for a given tag\n     * @param tagName the tag\n     * @return the attributes that will be enforced; empty if none are set for the given tag\n     */\n    public Attributes getEnforcedAttributes(String tagName) {\n        Attributes attrs = new Attributes();\n        TagName tag = TagName.valueOf(tagName);\n        if (enforcedAttributes.containsKey(tag)) {\n            Map<AttributeKey, AttributeValue> keyVals = enforcedAttributes.get(tag);\n            for (Map.Entry<AttributeKey, AttributeValue> entry : keyVals.entrySet()) {\n                attrs.put(entry.getKey().toString(), entry.getValue().toString());\n            }\n        }\n        return attrs;\n    }\n    \n    // named types for config. All just hold strings, but here for my sanity.\n\n    static class TagName extends TypedValue {\n        TagName(String value) {\n            super(value);\n        }\n\n        static TagName valueOf(String value) {\n            return new TagName(Normalizer.lowerCase(value));\n        }\n    }\n\n    static class AttributeKey extends TypedValue {\n        AttributeKey(String value) {\n            super(value);\n        }\n\n        static AttributeKey valueOf(String value) {\n            return new AttributeKey(Normalizer.lowerCase(value));\n        }\n    }\n\n    static class AttributeValue extends TypedValue {\n        AttributeValue(String value) {\n            super(value);\n        }\n\n        static AttributeValue valueOf(String value) {\n            return new AttributeValue(value);\n        }\n    }\n\n    static class Protocol extends TypedValue {\n        Protocol(String value) {\n            super(value);\n        }\n\n        static Protocol valueOf(String value) {\n            return new Protocol(value);\n        }\n    }\n\n    abstract static class TypedValue {\n        private final String value;\n\n        TypedValue(String value) {\n            Validate.notNull(value);\n            this.value = value;\n        }\n\n        @Override\n        public int hashCode() {\n            return value.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            TypedValue other = (TypedValue) obj;\n            return Objects.equals(value, other.value);\n        }\n\n        @Override\n        public String toString() {\n            return value;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String All = \":all\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "All = \":all\"", "syntax_pass": true}, {"attribute_expression": "private final Set<TagName> tagNames;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<TagName>", "name": "tagNames", "syntax_pass": true}, {"attribute_expression": "private final Map<TagName, Set<AttributeKey>> attributes;", "docstring": " tags allowed, lower case. e.g. [p, br, span]", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<TagName, Set<AttributeKey>>", "name": "attributes", "syntax_pass": true}, {"attribute_expression": "private final Map<TagName, Map<AttributeKey, AttributeValue>> enforcedAttributes;", "docstring": " tag -> attribute[]. allowed attributes [href] for a tag.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<TagName, Map<AttributeKey, AttributeValue>>", "name": "enforcedAttributes", "syntax_pass": true}, {"attribute_expression": "private final Map<TagName, Map<AttributeKey, Set<Protocol>>> protocols;", "docstring": " always set these attribute values", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<TagName, Map<AttributeKey, Set<Protocol>>>", "name": "protocols", "syntax_pass": true}, {"attribute_expression": "private boolean preserveRelativeLinks;", "docstring": " allowed URL protocols for attributes", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "preserveRelativeLinks", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner", "name": "Cleaner", "file_path": "src/main/java/org/jsoup/safety/Cleaner.java", "superclasses": "", "methods": ["[]Cleaner(Safelist)", "[Document]clean(Document)", "[boolean]isValid(Document)", "[boolean]isValidBodyHtml(String)", "[int]copySafeNodes(Element,Element)", "[ElementMeta]createSafeElement(Element)"], "method_uris": ["src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[]Cleaner(Safelist)", "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[Document]clean(Document)", "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[boolean]isValid(Document)", "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[boolean]isValidBodyHtml(String)", "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[int]copySafeNodes(Element,Element)", "src/main/java/org/jsoup/safety/Cleaner.java.Cleaner.[ElementMeta]createSafeElement(Element)"], "overrides": null, "attributes": [{"original_string": "    private final class CleaningVisitor implements NodeVisitor {\n        private int numDiscarded = 0;\n        private final Element root;\n        private Element destination; // current element to append nodes to\n\n        private CleaningVisitor(Element root, Element destination) {\n            this.root = root;\n            this.destination = destination;\n        }\n\n        @Override public void head(Node source, int depth) {\n            if (source instanceof Element) {\n                Element sourceEl = (Element) source;\n\n                if (safelist.isSafeTag(sourceEl.normalName())) { // safe, clone and copy safe attrs\n                    ElementMeta meta = createSafeElement(sourceEl);\n                    Element destChild = meta.el;\n                    destination.appendChild(destChild);\n\n                    numDiscarded += meta.numAttribsDiscarded;\n                    destination = destChild;\n                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.\n                    numDiscarded++;\n                }\n            } else if (source instanceof TextNode) {\n                TextNode sourceText = (TextNode) source;\n                TextNode destText = new TextNode(sourceText.getWholeText());\n                destination.appendChild(destText);\n            } else if (source instanceof DataNode && safelist.isSafeTag(source.parent().normalName())) {\n              DataNode sourceData = (DataNode) source;\n              DataNode destData = new DataNode(sourceData.getWholeData());\n              destination.appendChild(destData);\n            } else { // else, we don't care about comments, xml proc instructions, etc\n                numDiscarded++;\n            }\n        }\n\n        @Override public void tail(Node source, int depth) {\n            if (source instanceof Element && safelist.isSafeTag(source.normalName())) {\n                destination = destination.parent(); // would have descended, so pop destination stack\n            }\n        }\n    }", "definition": "    private final class CleaningVisitor implements NodeVisitor", "class_docstring": "\nIterates the input and copies trusted nodes (tags, attributes, text) into the destination.\n", "name": "CleaningVisitor", "super_interfaces": ["NodeVisitor"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private int numDiscarded = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "numDiscarded = 0", "syntax_pass": true}, {"attribute_expression": "private final Element root;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Element", "name": "root", "syntax_pass": true}, {"attribute_expression": "private Element destination;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Element", "name": "destination", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private CleaningVisitor(Element root, Element destination) {\n            this.root = root;\n            this.destination = destination;\n        }", "docstring": " current element to append nodes to", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "CleaningVisitor", "params": [{"name": "root", "type": "Element"}, {"name": "destination", "type": "Element"}], "body": "                                                                   {\n            this.root = root;\n            this.destination = destination;\n        }", "signature": "private CleaningVisitor(Element root, Element destination)"}, {"syntax_pass": true, "original_string": "        @Override public void head(Node source, int depth) {\n            if (source instanceof Element) {\n                Element sourceEl = (Element) source;\n\n                if (safelist.isSafeTag(sourceEl.normalName())) { // safe, clone and copy safe attrs\n                    ElementMeta meta = createSafeElement(sourceEl);\n                    Element destChild = meta.el;\n                    destination.appendChild(destChild);\n\n                    numDiscarded += meta.numAttribsDiscarded;\n                    destination = destChild;\n                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.\n                    numDiscarded++;\n                }\n            } else if (source instanceof TextNode) {\n                TextNode sourceText = (TextNode) source;\n                TextNode destText = new TextNode(sourceText.getWholeText());\n                destination.appendChild(destText);\n            } else if (source instanceof DataNode && safelist.isSafeTag(source.parent().normalName())) {\n              DataNode sourceData = (DataNode) source;\n              DataNode destData = new DataNode(sourceData.getWholeData());\n              destination.appendChild(destData);\n            } else { // else, we don't care about comments, xml proc instructions, etc\n                numDiscarded++;\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "head", "params": [{"name": "source", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                           {\n            if (source instanceof Element) {\n                Element sourceEl = (Element) source;\n\n                if (safelist.isSafeTag(sourceEl.normalName())) { // safe, clone and copy safe attrs\n                    ElementMeta meta = createSafeElement(sourceEl);\n                    Element destChild = meta.el;\n                    destination.appendChild(destChild);\n\n                    numDiscarded += meta.numAttribsDiscarded;\n                    destination = destChild;\n                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.\n                    numDiscarded++;\n                }\n            } else if (source instanceof TextNode) {\n                TextNode sourceText = (TextNode) source;\n                TextNode destText = new TextNode(sourceText.getWholeText());\n                destination.appendChild(destText);\n            } else if (source instanceof DataNode && safelist.isSafeTag(source.parent().normalName())) {\n              DataNode sourceData = (DataNode) source;\n              DataNode destData = new DataNode(sourceData.getWholeData());\n              destination.appendChild(destData);\n            } else { // else, we don't care about comments, xml proc instructions, etc\n                numDiscarded++;\n            }\n        }", "signature": "@Override public void head(Node source, int depth)"}, {"syntax_pass": true, "original_string": "        @Override public void tail(Node source, int depth) {\n            if (source instanceof Element && safelist.isSafeTag(source.normalName())) {\n                destination = destination.parent(); // would have descended, so pop destination stack\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tail", "params": [{"name": "source", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                           {\n            if (source instanceof Element && safelist.isSafeTag(source.normalName())) {\n                destination = destination.parent(); // would have descended, so pop destination stack\n            }\n        }", "signature": "@Override public void tail(Node source, int depth)"}]}, {"original_string": "    private static class ElementMeta {\n        Element el;\n        int numAttribsDiscarded;\n\n        ElementMeta(Element el, int numAttribsDiscarded) {\n            this.el = el;\n            this.numAttribsDiscarded = numAttribsDiscarded;\n        }\n    }", "definition": "    private static class ElementMeta", "class_docstring": "", "name": "ElementMeta", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "Element el;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Element", "name": "el", "syntax_pass": true}, {"attribute_expression": "int numAttribsDiscarded;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "numAttribsDiscarded", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ElementMeta(Element el, int numAttribsDiscarded) {\n            this.el = el;\n            this.numAttribsDiscarded = numAttribsDiscarded;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ElementMeta", "params": [{"name": "el", "type": "Element"}, {"name": "numAttribsDiscarded", "type": "int"}], "body": "                                                         {\n            this.el = el;\n            this.numAttribsDiscarded = numAttribsDiscarded;\n        }", "signature": "ElementMeta(Element el, int numAttribsDiscarded)"}]}], "class_docstring": "\nThe safelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes\nthat you are expecting; no junk, and no cross-site scripting attacks!\n<p>\nThe HTML cleaner parses the input as HTML and then runs it through a safe-list, so the output HTML can only contain\nHTML that is allowed by the safelist.\n</p>\n<p>\nIt is assumed that the input HTML is a body fragment; the clean methods only pull from the source's body, and the\ncanned safe-lists only allow body contained tags.\n</p>\n<p>\nRather than interacting directly with a Cleaner object, generally see the {@code clean} methods in {@link org.jsoup.Jsoup}.\n</p>\n", "original_string": "public class Cleaner {\n    private final Safelist safelist;\n\n    /**\n     Create a new cleaner, that sanitizes documents using the supplied safelist.\n     @param safelist safe-list to clean with\n     */\n    public Cleaner(Safelist safelist) {\n        Validate.notNull(safelist);\n        this.safelist = safelist;\n    }\n\n    /**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the safelist.\n     The original document is not modified. Only elements from the dirty document's <code>body</code> are used. The\n     OutputSettings of the original document are cloned into the clean document.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */\n    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        copySafeNodes(dirtyDocument.body(), clean.body());\n        clean.outputSettings(dirtyDocument.outputSettings().clone());\n\n        return clean;\n    }\n\n    /**\n     Determines if the input document's <b>body</b> is valid, against the safelist. It is considered valid if all the\n     tags and attributes in the input HTML are allowed by the safelist, and that there is no content in the\n     <code>head</code>.\n     <p>\n     This method is intended to be used in a user interface as a validator for user input. Note that regardless of the\n     output of this method, the input document <b>must always</b> be normalized using a method such as\n     {@link #clean(Document)}, and the result of that method used to store or serialize the document before later reuse\n     such as presentation to end users. This ensures that enforced attributes are set correctly, and that any\n     differences between how a given browser and how jsoup parses the input HTML are normalized.\n     </p>\n     <p>Example:\n     <pre>{@code\n     Document inputDoc = Jsoup.parse(inputHtml);\n     Cleaner cleaner = new Cleaner(Safelist.relaxed());\n     boolean isValid = cleaner.isValid(inputDoc);\n     Document normalizedDoc = cleaner.clean(inputDoc);\n     }</pre>\n     </p>\n     @param dirtyDocument document to test\n     @return true if no tags or attributes need to be removed; false if they do\n     */\n    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0\n            && dirtyDocument.head().childNodes().isEmpty(); // because we only look at the body, but we start from a shell, make sure there's nothing in the head\n    }\n\n    /**\n     Determines if the input document's <b>body HTML</b> is valid, against the safelist. It is considered valid if all\n     the tags and attributes in the input HTML are allowed by the safelist.\n     <p>\n     This method is intended to be used in a user interface as a validator for user input. Note that regardless of the\n     output of this method, the input document <b>must always</b> be normalized using a method such as\n     {@link #clean(Document)}, and the result of that method used to store or serialize the document before later reuse\n     such as presentation to end users. This ensures that enforced attributes are set correctly, and that any\n     differences between how a given browser and how jsoup parses the input HTML are normalized.\n     </p>\n     <p>Example:\n     <pre>{@code\n     Document inputDoc = Jsoup.parse(inputHtml);\n     Cleaner cleaner = new Cleaner(Safelist.relaxed());\n     boolean isValid = cleaner.isValidBodyHtml(inputHtml);\n     Document normalizedDoc = cleaner.clean(inputDoc);\n     }</pre>\n     </p>\n     @param bodyHtml HTML fragment to test\n     @return true if no tags or attributes need to be removed; false if they do\n     */\n    public boolean isValidBodyHtml(String bodyHtml) {\n        Document clean = Document.createShell(\"\");\n        Document dirty = Document.createShell(\"\");\n        ParseErrorList errorList = ParseErrorList.tracking(1);\n        List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), \"\", errorList);\n        dirty.body().insertChildren(0, nodes);\n        int numDiscarded = copySafeNodes(dirty.body(), clean.body());\n        return numDiscarded == 0 && errorList.isEmpty();\n    }\n\n    /**\n     Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.\n     */\n    private final class CleaningVisitor implements NodeVisitor {\n        private int numDiscarded = 0;\n        private final Element root;\n        private Element destination; // current element to append nodes to\n\n        private CleaningVisitor(Element root, Element destination) {\n            this.root = root;\n            this.destination = destination;\n        }\n\n        @Override public void head(Node source, int depth) {\n            if (source instanceof Element) {\n                Element sourceEl = (Element) source;\n\n                if (safelist.isSafeTag(sourceEl.normalName())) { // safe, clone and copy safe attrs\n                    ElementMeta meta = createSafeElement(sourceEl);\n                    Element destChild = meta.el;\n                    destination.appendChild(destChild);\n\n                    numDiscarded += meta.numAttribsDiscarded;\n                    destination = destChild;\n                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.\n                    numDiscarded++;\n                }\n            } else if (source instanceof TextNode) {\n                TextNode sourceText = (TextNode) source;\n                TextNode destText = new TextNode(sourceText.getWholeText());\n                destination.appendChild(destText);\n            } else if (source instanceof DataNode && safelist.isSafeTag(source.parent().normalName())) {\n              DataNode sourceData = (DataNode) source;\n              DataNode destData = new DataNode(sourceData.getWholeData());\n              destination.appendChild(destData);\n            } else { // else, we don't care about comments, xml proc instructions, etc\n                numDiscarded++;\n            }\n        }\n\n        @Override public void tail(Node source, int depth) {\n            if (source instanceof Element && safelist.isSafeTag(source.normalName())) {\n                destination = destination.parent(); // would have descended, so pop destination stack\n            }\n        }\n    }\n\n    private int copySafeNodes(Element source, Element dest) {\n        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);\n        NodeTraversor.traverse(cleaningVisitor, source);\n        return cleaningVisitor.numDiscarded;\n    }\n\n    private ElementMeta createSafeElement(Element sourceEl) {\n        Element dest = sourceEl.shallowClone(); // reuses tag, clones attributes and preserves any user data\n        String sourceTag = sourceEl.tagName();\n        Attributes destAttrs = dest.attributes();\n        dest.clearAttributes(); // clear all non-internal attributes, ready for safe copy\n\n        int numDiscarded = 0;\n        Attributes sourceAttrs = sourceEl.attributes();\n        for (Attribute sourceAttr : sourceAttrs) {\n            if (safelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr))\n                destAttrs.put(sourceAttr);\n            else\n                numDiscarded++;\n        }\n        Attributes enforcedAttrs = safelist.getEnforcedAttributes(sourceTag);\n        destAttrs.addAll(enforcedAttrs);\n        dest.attributes().addAll(destAttrs); // re-attach, if removed in clear\n        return new ElementMeta(dest, numDiscarded);\n    }\n\n    private static class ElementMeta {\n        Element el;\n        int numAttribsDiscarded;\n\n        ElementMeta(Element el, int numAttribsDiscarded) {\n            this.el = el;\n            this.numAttribsDiscarded = numAttribsDiscarded;\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Safelist safelist;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Safelist", "name": "safelist", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/internal/Functions.java.Functions", "name": "Functions", "file_path": "src/main/java/org/jsoup/internal/Functions.java", "superclasses": "", "methods": ["[]Functions()", "[Function<T, List<U>>]listFunction()", "[Function<T, Set<U>>]setFunction()", "[Function<T, Map<K, V>>]mapFunction()", "[Function<T, IdentityHashMap<K, V>>]identityMapFunction()"], "method_uris": ["src/main/java/org/jsoup/internal/Functions.java.Functions.[]Functions()", "src/main/java/org/jsoup/internal/Functions.java.Functions.[Function<T, List<U>>]listFunction()", "src/main/java/org/jsoup/internal/Functions.java.Functions.[Function<T, Set<U>>]setFunction()", "src/main/java/org/jsoup/internal/Functions.java.Functions.[Function<T, Map<K, V>>]mapFunction()", "src/main/java/org/jsoup/internal/Functions.java.Functions.[Function<T, IdentityHashMap<K, V>>]identityMapFunction()"], "overrides": null, "attributes": [], "class_docstring": "\nAn internal class containing functions for use with {@link Map#computeIfAbsent(Object, Function)}.\n", "original_string": "@SuppressWarnings({\"rawtypes\", \"unchecked\"})\npublic final class Functions {\n    private static final Function ListFunction = key -> new ArrayList<>();\n    private static final Function SetFunction = key -> new HashSet<>();\n    private static final Function MapFunction = key -> new HashMap<>();\n    private static final Function IdentityMapFunction = key -> new IdentityHashMap<>();\n\n    private Functions() {\n    }\n\n    public static <T, U> Function<T, List<U>> listFunction() {\n        return (Function<T, List<U>>) ListFunction;\n    }\n\n    public static <T, U> Function<T, Set<U>> setFunction() {\n        return (Function<T, Set<U>>) SetFunction;\n    }\n\n    public static <T, K, V> Function<T, Map<K, V>> mapFunction() {\n        return (Function<T, Map<K, V>>) MapFunction;\n    }\n\n    public static <T, K, V> Function<T, IdentityHashMap<K, V>> identityMapFunction() {\n        return (Function<T, IdentityHashMap<K, V>>) IdentityMapFunction;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Function ListFunction = key -> new ArrayList<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Function", "name": "ListFunction = key -> new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private static final Function SetFunction = key -> new HashSet<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Function", "name": "SetFunction = key -> new HashSet<>()", "syntax_pass": true}, {"attribute_expression": "private static final Function MapFunction = key -> new HashMap<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Function", "name": "MapFunction = key -> new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private static final Function IdentityMapFunction = key -> new IdentityHashMap<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Function", "name": "IdentityMapFunction = key -> new IdentityHashMap<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool", "name": "SoftPool", "file_path": "src/main/java/org/jsoup/internal/SoftPool.java", "superclasses": "", "methods": ["[]SoftPool(Supplier<T>)", "[T]borrow()", "[void]release(T)", "[Stack<T>]getStack()"], "method_uris": ["src/main/java/org/jsoup/internal/SoftPool.java.SoftPool.[]SoftPool(Supplier<T>)", "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool.[T]borrow()", "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool.[void]release(T)", "src/main/java/org/jsoup/internal/SoftPool.java.SoftPool.[Stack<T>]getStack()"], "overrides": null, "attributes": [], "class_docstring": "\nA SoftPool is a ThreadLocal that holds a SoftReference to a pool of initializable objects. This allows us to reuse\nexpensive objects (buffers, etc.) between invocations (the ThreadLocal), but also for those objects to be reaped if\nthey are no longer in use.\n<p>Like a ThreadLocal, should be stored in a static field.</p>\n@param <T> the type of object to pool.\n@since 1.18.2\n", "original_string": "public class SoftPool<T> {\n    final ThreadLocal<SoftReference<Stack<T>>> threadLocalStack;\n    private final Supplier<T> initializer;\n    /**\n     How many total uses of the creating object might be instantiated on the same thread at once. More than this and\n     those objects aren't recycled. Doesn't need to be too conservative, as they can still be GCed as SoftRefs.\n     */\n    static final int MaxIdle = 12;\n\n    /**\n     Create a new SoftPool.\n     @param initializer a supplier that creates a new object when one is needed.\n     */\n    public SoftPool(Supplier<T> initializer) {\n        this.initializer = initializer;\n        this.threadLocalStack = ThreadLocal.withInitial(() -> new SoftReference<>(new Stack<>()));\n    }\n\n    /**\n     Borrow an object from the pool, creating a new one if the pool is empty. Make sure to release it back to the pool\n     when done, so that it can be reused.\n     @return an object from the pool, as defined by the initializer.\n     */\n    public T borrow() {\n        Stack<T> stack = getStack();\n        if (!stack.isEmpty()) {\n            return stack.pop();\n        }\n        return initializer.get();\n    }\n\n    /**\n     Release an object back to the pool. If the pool is full, the object is not retained. If you don't want to reuse a\n     borrowed object (for e.g. a StringBuilder that grew too large), just don't release it.\n     @param value the object to release back to the pool.\n     */\n    public void release(T value) {\n        Stack<T> stack = getStack();\n        if (stack.size() < MaxIdle) {\n            stack.push(value);\n        }\n    }\n\n    Stack<T> getStack() {\n        Stack<T> stack = threadLocalStack.get().get();\n        if (stack == null) {\n            stack = new Stack<>();\n            threadLocalStack.set(new SoftReference<>(stack));\n        }\n        return stack;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final ThreadLocal<SoftReference<Stack<T>>> threadLocalStack;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ThreadLocal<SoftReference<Stack<T>>>", "name": "threadLocalStack", "syntax_pass": true}, {"attribute_expression": "private final Supplier<T> initializer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Supplier<T>", "name": "initializer", "syntax_pass": true}, {"attribute_expression": "static final int MaxIdle = 12;", "docstring": "\nHow many total uses of the creating object might be instantiated on the same thread at once. More than this and\nthose objects aren't recycled. Doesn't need to be too conservative, as they can still be GCed as SoftRefs.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "MaxIdle = 12", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/internal/SharedConstants.java.SharedConstants", "name": "SharedConstants", "file_path": "src/main/java/org/jsoup/internal/SharedConstants.java", "superclasses": "", "methods": ["[]SharedConstants()"], "method_uris": ["src/main/java/org/jsoup/internal/SharedConstants.java.SharedConstants.[]SharedConstants()"], "overrides": null, "attributes": [], "class_docstring": "\njsoup constants used between packages. Do not use as they may change without warning. Users will not be able to see\nthis package when modules are enabled.\n", "original_string": "public final class SharedConstants {\n    public static final String UserDataKey = \"/jsoup.userdata\";\n    public final static String AttrRangeKey = \"jsoup.attrs\";\n    public static final String RangeKey = \"jsoup.start\";\n    public static final String EndRangeKey = \"jsoup.end\";\n\n    public static final int DefaultBufferSize = 8 * 1024;\n\n    public static final String[] FormSubmitTags = {\n        \"input\", \"keygen\", \"object\", \"select\", \"textarea\"\n    };\n\n    private SharedConstants() {}\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String UserDataKey = \"/jsoup.userdata\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "UserDataKey = \"/jsoup.userdata\"", "syntax_pass": true}, {"attribute_expression": "public final static String AttrRangeKey = \"jsoup.attrs\";", "docstring": "", "modifiers": "public final static", "marker_annotations": [], "non_marker_annotations": ["public", "final", "static"], "comments": [], "type": "String", "name": "AttrRangeKey = \"jsoup.attrs\"", "syntax_pass": true}, {"attribute_expression": "public static final String RangeKey = \"jsoup.start\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "RangeKey = \"jsoup.start\"", "syntax_pass": true}, {"attribute_expression": "public static final String EndRangeKey = \"jsoup.end\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "EndRangeKey = \"jsoup.end\"", "syntax_pass": true}, {"attribute_expression": "public static final int DefaultBufferSize = 8 * 1024;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DefaultBufferSize = 8 * 1024", "syntax_pass": true}, {"attribute_expression": "public static final String[] FormSubmitTags = {\n        \"input\", \"keygen\", \"object\", \"select\", \"textarea\"\n    };", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String[]", "name": "FormSubmitTags = {\n        \"input\", \"keygen\", \"object\", \"select\", \"textarea\"\n    }", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/internal/Normalizer.java.Normalizer", "name": "Normalizer", "file_path": "src/main/java/org/jsoup/internal/Normalizer.java", "superclasses": "", "methods": ["[String]lowerCase(String)", "[String]normalize(String)", "[String]normalize(String,boolean)"], "method_uris": ["src/main/java/org/jsoup/internal/Normalizer.java.Normalizer.[String]lowerCase(String)", "src/main/java/org/jsoup/internal/Normalizer.java.Normalizer.[String]normalize(String)", "src/main/java/org/jsoup/internal/Normalizer.java.Normalizer.[String]normalize(String,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nUtil methods for normalizing strings. Jsoup internal use only, please don't depend on this API.\n", "original_string": "public final class Normalizer {\n\n    /** Drops the input string to lower case. */\n    public static String lowerCase(final String input) {\n        return input != null ? input.toLowerCase(Locale.ENGLISH) : \"\";\n    }\n\n    /** Lower-cases and trims the input string. */\n    public static String normalize(final String input) {\n        return lowerCase(input).trim();\n    }\n\n    /** If a string literal, just lower case the string; otherwise lower-case and trim. */\n    public static String normalize(final String input, boolean isStringLiteral) {\n        return isStringLiteral ? lowerCase(input) : normalize(input);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil", "name": "StringUtil", "file_path": "src/main/java/org/jsoup/internal/StringUtil.java", "superclasses": "", "methods": ["[String]join(Collection<?>,String)", "[String]join(Iterator<?>,String)", "[String]join(String[],String)", "[String]padding(int)", "[String]padding(int,int)", "[boolean]isBlank(String)", "[boolean]startsWithNewline(String)", "[boolean]isNumeric(String)", "[boolean]isWhitespace(int)", "[boolean]isActuallyWhitespace(int)", "[boolean]isInvisibleChar(int)", "[String]normaliseWhitespace(String)", "[void]appendNormalisedWhitespace(StringBuilder,String,boolean)", "[boolean]in(String)", "[boolean]inSorted(String,String[])", "[boolean]isAscii(String)", "[URL]resolve(URL,String)", "[String]resolve(String,String)", "[String]stripControlChars(String)", "[StringBuilder]borrowBuilder()", "[String]releaseBuilder(StringBuilder)", "[Collector<CharSequence, ?, String>]joining(String)"], "method_uris": ["src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]join(Collection<?>,String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]join(Iterator<?>,String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]join(String[],String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]padding(int)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]padding(int,int)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isBlank(String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]startsWithNewline(String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isNumeric(String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isWhitespace(int)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isActuallyWhitespace(int)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isInvisibleChar(int)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]normaliseWhitespace(String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[void]appendNormalisedWhitespace(StringBuilder,String,boolean)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]in(String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]inSorted(String,String[])", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[boolean]isAscii(String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[URL]resolve(URL,String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]resolve(String,String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]stripControlChars(String)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[StringBuilder]borrowBuilder()", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[String]releaseBuilder(StringBuilder)", "src/main/java/org/jsoup/internal/StringUtil.java.StringUtil.[Collector<CharSequence, ?, String>]joining(String)"], "overrides": null, "attributes": [{"original_string": "    public static class StringJoiner {\n        @Nullable StringBuilder sb = borrowBuilder(); // sets null on builder release so can't accidentally be reused\n        final String separator;\n        boolean first = true;\n\n        /**\n         Create a new joiner, that uses the specified separator. MUST call {@link #complete()} or will leak a thread\n         local string builder.\n\n         @param separator the token to insert between strings\n         */\n        public StringJoiner(String separator) {\n            this.separator = separator;\n        }\n\n        /**\n         Add another item to the joiner, will be separated\n         */\n        public StringJoiner add(Object stringy) {\n            Validate.notNull(sb); // don't reuse\n            if (!first)\n                sb.append(separator);\n            sb.append(stringy);\n            first = false;\n            return this;\n        }\n\n        /**\n         Append content to the current item; not separated\n         */\n        public StringJoiner append(Object stringy) {\n            Validate.notNull(sb); // don't reuse\n            sb.append(stringy);\n            return this;\n        }\n\n        /**\n         Return the joined string, and release the builder back to the pool. This joiner cannot be reused.\n         */\n        public String complete() {\n            String string = releaseBuilder(sb);\n            sb = null;\n            return string;\n        }\n    }", "definition": "    public static class StringJoiner", "class_docstring": "\nA StringJoiner allows incremental / filtered joining of a set of stringable objects.\n@since 1.14.1\n", "name": "StringJoiner", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "@Nullable StringBuilder sb = borrowBuilder();", "docstring": "", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "StringBuilder", "name": "sb = borrowBuilder()", "syntax_pass": true}, {"attribute_expression": "final String separator;", "docstring": " sets null on builder release so can't accidentally be reused", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "separator", "syntax_pass": true}, {"attribute_expression": "boolean first = true;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "first = true", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public StringJoiner(String separator) {\n            this.separator = separator;\n        }", "docstring": "\nCreate a new joiner, that uses the specified separator. MUST call {@link #complete()} or will leak a thread\nlocal string builder.\n\n@param separator the token to insert between strings\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "StringJoiner", "params": [{"name": "separator", "type": "String"}], "body": "                                              {\n            this.separator = separator;\n        }", "signature": "public StringJoiner(String separator)"}, {"syntax_pass": true, "original_string": "        public StringJoiner add(Object stringy) {\n            Validate.notNull(sb); // don't reuse\n            if (!first)\n                sb.append(separator);\n            sb.append(stringy);\n            first = false;\n            return this;\n        }", "docstring": "\nAdd another item to the joiner, will be separated\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringJoiner", "classes": []}, "name": "add", "params": [{"name": "stringy", "type": "Object"}], "body": "                                                {\n            Validate.notNull(sb); // don't reuse\n            if (!first)\n                sb.append(separator);\n            sb.append(stringy);\n            first = false;\n            return this;\n        }", "signature": "public StringJoiner add(Object stringy)"}, {"syntax_pass": true, "original_string": "        public StringJoiner append(Object stringy) {\n            Validate.notNull(sb); // don't reuse\n            sb.append(stringy);\n            return this;\n        }", "docstring": "\nAppend content to the current item; not separated\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringJoiner", "classes": []}, "name": "append", "params": [{"name": "stringy", "type": "Object"}], "body": "                                                   {\n            Validate.notNull(sb); // don't reuse\n            sb.append(stringy);\n            return this;\n        }", "signature": "public StringJoiner append(Object stringy)"}, {"syntax_pass": true, "original_string": "        public String complete() {\n            String string = releaseBuilder(sb);\n            sb = null;\n            return string;\n        }", "docstring": "\nReturn the joined string, and release the builder back to the pool. This joiner cannot be reused.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "complete", "params": [], "body": "                                 {\n            String string = releaseBuilder(sb);\n            sb = null;\n            return string;\n        }", "signature": "public String complete()"}]}], "class_docstring": "\nA minimal String utility class. Designed for <b>internal</b> jsoup use only - the API and outcome may change without\nnotice.\n", "original_string": "public final class StringUtil {\n    // memoised padding up to 21 (blocks 0 to 20 spaces)\n    static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n        \"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n        \"                \", \"                 \", \"                  \", \"                   \", \"                    \"};\n\n    /**\n     * Join a collection of strings by a separator\n     * @param strings collection of string objects\n     * @param sep string to place between strings\n     * @return joined string\n     */\n    public static String join(Collection<?> strings, String sep) {\n        return join(strings.iterator(), sep);\n    }\n\n    /**\n     * Join a collection of strings by a separator\n     * @param strings iterator of string objects\n     * @param sep string to place between strings\n     * @return joined string\n     */\n    public static String join(Iterator<?> strings, String sep) {\n        if (!strings.hasNext())\n            return \"\";\n\n        String start = strings.next().toString();\n        if (!strings.hasNext()) // only one, avoid builder\n            return start;\n\n        StringJoiner j = new StringJoiner(sep);\n        j.add(start);\n        while (strings.hasNext()) {\n            j.add(strings.next());\n        }\n        return j.complete();\n    }\n\n    /**\n     * Join an array of strings by a separator\n     * @param strings collection of string objects\n     * @param sep string to place between strings\n     * @return joined string\n     */\n    public static String join(String[] strings, String sep) {\n        return join(Arrays.asList(strings), sep);\n    }\n\n    /**\n     A StringJoiner allows incremental / filtered joining of a set of stringable objects.\n     @since 1.14.1\n     */\n    public static class StringJoiner {\n        @Nullable StringBuilder sb = borrowBuilder(); // sets null on builder release so can't accidentally be reused\n        final String separator;\n        boolean first = true;\n\n        /**\n         Create a new joiner, that uses the specified separator. MUST call {@link #complete()} or will leak a thread\n         local string builder.\n\n         @param separator the token to insert between strings\n         */\n        public StringJoiner(String separator) {\n            this.separator = separator;\n        }\n\n        /**\n         Add another item to the joiner, will be separated\n         */\n        public StringJoiner add(Object stringy) {\n            Validate.notNull(sb); // don't reuse\n            if (!first)\n                sb.append(separator);\n            sb.append(stringy);\n            first = false;\n            return this;\n        }\n\n        /**\n         Append content to the current item; not separated\n         */\n        public StringJoiner append(Object stringy) {\n            Validate.notNull(sb); // don't reuse\n            sb.append(stringy);\n            return this;\n        }\n\n        /**\n         Return the joined string, and release the builder back to the pool. This joiner cannot be reused.\n         */\n        public String complete() {\n            String string = releaseBuilder(sb);\n            sb = null;\n            return string;\n        }\n    }\n\n    /**\n     * Returns space padding (up to the default max of 30). Use {@link #padding(int, int)} to specify a different limit.\n     * @param width amount of padding desired\n     * @return string of spaces * width\n     * @see #padding(int, int) \n      */\n    public static String padding(int width) {\n        return padding(width, 30);\n    }\n\n    /**\n     * Returns space padding, up to a max of maxPaddingWidth.\n     * @param width amount of padding desired\n     * @param maxPaddingWidth maximum padding to apply. Set to {@code -1} for unlimited.\n     * @return string of spaces * width\n     */\n    public static String padding(int width, int maxPaddingWidth) {\n        Validate.isTrue(width >= 0, \"width must be >= 0\");\n        Validate.isTrue(maxPaddingWidth >= -1);\n        if (maxPaddingWidth != -1)\n            width = Math.min(width, maxPaddingWidth);\n        if (width < padding.length)\n            return padding[width];        \n        char[] out = new char[width];\n        for (int i = 0; i < width; i++)\n            out[i] = ' ';\n        return String.valueOf(out);\n    }\n\n    /**\n     * Tests if a string is blank: null, empty, or only whitespace (\" \", \\r\\n, \\t, etc)\n     * @param string string to test\n     * @return if string is blank\n     */\n    public static boolean isBlank(final String string) {\n        if (string == null || string.length() == 0)\n            return true;\n\n        int l = string.length();\n        for (int i = 0; i < l; i++) {\n            if (!StringUtil.isWhitespace(string.codePointAt(i)))\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     Tests if a string starts with a newline character\n     @param string string to test\n     @return if its first character is a newline\n     */\n    public static boolean startsWithNewline(final String string) {\n        if (string == null || string.length() == 0)\n            return false;\n        return string.charAt(0) == '\\n';\n    }\n\n    /**\n     * Tests if a string is numeric, i.e. contains only digit characters\n     * @param string string to test\n     * @return true if only digit chars, false if empty or null or contains non-digit chars\n     */\n    public static boolean isNumeric(String string) {\n        if (string == null || string.length() == 0)\n            return false;\n\n        int l = string.length();\n        for (int i = 0; i < l; i++) {\n            if (!Character.isDigit(string.codePointAt(i)))\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests if a code point is \"whitespace\" as defined in the HTML spec. Used for output HTML.\n     * @param c code point to test\n     * @return true if code point is whitespace, false otherwise\n     * @see #isActuallyWhitespace(int)\n     */\n    public static boolean isWhitespace(int c){\n        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n    }\n\n    /**\n     * Tests if a code point is \"whitespace\" as defined by what it looks like. Used for Element.text etc.\n     * @param c code point to test\n     * @return true if code point is whitespace, false otherwise\n     */\n    public static boolean isActuallyWhitespace(int c){\n        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r' || c == 160;\n        // 160 is &nbsp; (non-breaking space). Not in the spec but expected.\n    }\n\n    public static boolean isInvisibleChar(int c) {\n        return c == 8203 || c == 173; // zero width sp, soft hyphen\n        // previously also included zw non join, zw join - but removing those breaks semantic meaning of text\n    }\n\n    /**\n     * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters\n     * (e.g. newline, tab) convert to a simple space.\n     * @param string content to normalise\n     * @return normalised string\n     */\n    public static String normaliseWhitespace(String string) {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        appendNormalisedWhitespace(sb, string, false);\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    /**\n     * After normalizing the whitespace within a string, appends it to a string builder.\n     * @param accum builder to append to\n     * @param string string to normalize whitespace within\n     * @param stripLeading set to true if you wish to remove any leading whitespace\n     */\n    public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n\n        int len = string.length();\n        int c;\n        for (int i = 0; i < len; i+= Character.charCount(c)) {\n            c = string.codePointAt(i);\n            if (isActuallyWhitespace(c)) {\n                if ((stripLeading && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n            }\n            else if (!isInvisibleChar(c)) {\n                accum.appendCodePoint(c);\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n    }\n\n    public static boolean in(final String needle, final String... haystack) {\n        final int len = haystack.length;\n        for (int i = 0; i < len; i++) {\n            if (haystack[i].equals(needle))\n               return true;\n        }\n        return false;\n    }\n\n    public static boolean inSorted(String needle, String[] haystack) {\n        return Arrays.binarySearch(haystack, needle) >= 0;\n    }\n\n    /**\n     Tests that a String contains only ASCII characters.\n     @param string scanned string\n     @return true if all characters are in range 0 - 127\n     */\n    public static boolean isAscii(String string) {\n        Validate.notNull(string);\n        for (int i = 0; i < string.length(); i++) {\n            int c = string.charAt(i);\n            if (c > 127) { // ascii range\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static final Pattern extraDotSegmentsPattern = Pattern.compile(\"^/(?>(?>\\\\.\\\\.?/)+)\");\n    /**\n     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n     * @param base the existing absolute base URL\n     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n     * @return the resolved absolute URL\n     * @throws MalformedURLException if an error occurred generating the URL\n     */\n    public static URL resolve(URL base, String relUrl) throws MalformedURLException {\n        relUrl = stripControlChars(relUrl);\n        // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n        if (relUrl.startsWith(\"?\"))\n            relUrl = base.getPath() + relUrl;\n        // workaround: //example.com + ./foo = //example.com/./foo, not //example.com/foo\n        URL url = new URL(base, relUrl);\n        String fixedFile = extraDotSegmentsPattern.matcher(url.getFile()).replaceFirst(\"/\");\n        if (url.getRef() != null) {\n            fixedFile = fixedFile + \"#\" + url.getRef();\n        }\n        return new URL(url.getProtocol(), url.getHost(), url.getPort(), fixedFile);\n    }\n\n    /**\n     * Create a new absolute URL, from a provided existing absolute URL and a relative URL component.\n     * @param baseUrl the existing absolute base URL\n     * @param relUrl the relative URL to resolve. (If it's already absolute, it will be returned)\n     * @return an absolute URL if one was able to be generated, or the empty string if not\n     */\n    public static String resolve(String baseUrl, String relUrl) {\n        // workaround: java will allow control chars in a path URL and may treat as relative, but Chrome / Firefox will strip and may see as a scheme. Normalize to browser's view.\n        baseUrl = stripControlChars(baseUrl); relUrl = stripControlChars(relUrl);\n        try {\n            URL base;\n            try {\n                base = new URL(baseUrl);\n            } catch (MalformedURLException e) {\n                // the base is unsuitable, but the attribute/rel may be abs on its own, so try that\n                URL abs = new URL(relUrl);\n                return abs.toExternalForm();\n            }\n            return resolve(base, relUrl).toExternalForm();\n        } catch (MalformedURLException e) {\n            // it may still be valid, just that Java doesn't have a registered stream handler for it, e.g. tel\n            // we test here vs at start to normalize supported URLs (e.g. HTTP -> http)\n            return validUriScheme.matcher(relUrl).find() ? relUrl : \"\";\n        }\n    }\n    private static final Pattern validUriScheme = Pattern.compile(\"^[a-zA-Z][a-zA-Z0-9+-.]*:\");\n\n    private static final Pattern controlChars = Pattern.compile(\"[\\\\x00-\\\\x1f]*\"); // matches ascii 0 - 31, to strip from url\n    private static String stripControlChars(final String input) {\n        return controlChars.matcher(input).replaceAll(\"\");\n    }\n\n    private static final int InitBuilderSize = 1024;\n    private static final int MaxBuilderSize = 8 * 1024;\n    private static final SoftPool<StringBuilder> BuilderPool = new SoftPool<>(\n        () -> new StringBuilder(InitBuilderSize));\n\n    /**\n     * Maintains cached StringBuilders in a flyweight pattern, to minimize new StringBuilder GCs. The StringBuilder is\n     * prevented from growing too large.\n     * <p>\n     * Care must be taken to release the builder once its work has been completed, with {@link #releaseBuilder}\n     * @return an empty StringBuilder\n     */\n    public static StringBuilder borrowBuilder() {\n        return BuilderPool.borrow();\n    }\n\n    /**\n     * Release a borrowed builder. Care must be taken not to use the builder after it has been returned, as its\n     * contents may be changed by this method, or by a concurrent thread.\n     * @param sb the StringBuilder to release.\n     * @return the string value of the released String Builder (as an incentive to release it!).\n     */\n    public static String releaseBuilder(StringBuilder sb) {\n        Validate.notNull(sb);\n        String string = sb.toString();\n\n        // if it hasn't grown too big, reset it and return it to the pool:\n        if (sb.length() <= MaxBuilderSize) {\n            sb.delete(0, sb.length()); // make sure it's emptied on release\n            BuilderPool.release(sb);\n        }\n\n        return string;\n    }\n\n    /**\n     * Return a {@link Collector} similar to the one returned by {@link Collectors#joining(CharSequence)},\n     * but backed by jsoup's {@link StringJoiner}, which allows for more efficient garbage collection.\n     *\n     * @param delimiter The delimiter for separating the strings.\n     * @return A {@code Collector} which concatenates CharSequence elements, separated by the specified delimiter\n     */\n    public static Collector<CharSequence, ?, String> joining(String delimiter) {\n        return Collector.of(() -> new StringJoiner(delimiter),\n            StringJoiner::add,\n            (j1, j2) -> {\n                j1.append(j2.complete());\n                return j1;\n            },\n            StringJoiner::complete);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n        \"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n        \"                \", \"                 \", \"                  \", \"                   \", \"                    \"};", "docstring": " memoised padding up to 21 (blocks 0 to 20 spaces)", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n        \"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n        \"                \", \"                 \", \"                  \", \"                   \", \"                    \"}", "syntax_pass": true}, {"attribute_expression": "private static final Pattern extraDotSegmentsPattern = Pattern.compile(\"^/(?>(?>\\\\.\\\\.?/)+)\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "extraDotSegmentsPattern = Pattern.compile(\"^/(?>(?>\\\\.\\\\.?/)+)\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern validUriScheme = Pattern.compile(\"^[a-zA-Z][a-zA-Z0-9+-.]*:\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "validUriScheme = Pattern.compile(\"^[a-zA-Z][a-zA-Z0-9+-.]*:\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern controlChars = Pattern.compile(\"[\\\\x00-\\\\x1f]*\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "controlChars = Pattern.compile(\"[\\\\x00-\\\\x1f]*\")", "syntax_pass": true}, {"attribute_expression": "private static final int InitBuilderSize = 1024;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "InitBuilderSize = 1024", "syntax_pass": true}, {"attribute_expression": "private static final int MaxBuilderSize = 8 * 1024;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "MaxBuilderSize = 8 * 1024", "syntax_pass": true}, {"attribute_expression": "private static final SoftPool<StringBuilder> BuilderPool = new SoftPool<>(\n        () -> new StringBuilder(InitBuilderSize));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "SoftPool<StringBuilder>", "name": "BuilderPool = new SoftPool<>(\n        () -> new StringBuilder(InitBuilderSize))", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput", "name": "SimpleBufferedInput", "file_path": "src/main/java/org/jsoup/internal/SimpleBufferedInput.java", "superclasses": "FilterInputStream", "methods": ["[]SimpleBufferedInput(InputStream)", "[int]read()", "[int]read(byte[],int,int)", "[void]fill()", "[void]closeIfDone(int)", "[byte[]]getBuf()", "[boolean]baseReadFully()", "[int]available()", "[void]mark(int)", "[void]reset()", "[void]close()"], "method_uris": ["src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[]SimpleBufferedInput(InputStream)", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[int]read()", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[int]read(byte[],int,int)", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]fill()", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]closeIfDone(int)", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[byte[]]getBuf()", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[boolean]baseReadFully()", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[int]available()", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]mark(int)", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]reset()", "src/main/java/org/jsoup/internal/SimpleBufferedInput.java.SimpleBufferedInput.[void]close()"], "overrides": null, "attributes": [], "class_docstring": "\nA simple implemented of a buffered input stream, in which we can control the byte[] buffer to recycle it. Not safe for\nuse between threads; no sync or locks. The buffer is borrowed on initial demand in fill.\n@since 1.18.2\n", "original_string": "class SimpleBufferedInput extends FilterInputStream {\n    static final int BufferSize = DefaultBufferSize;\n    static final SoftPool<byte[]> BufferPool = new SoftPool<>(() -> new byte[BufferSize]);\n\n    private byte @Nullable [] byteBuf; // the byte buffer; recycled via SoftPool. Created in fill if required\n    private int bufPos;\n    private int bufLength;\n    private int bufMark = -1;\n    private boolean inReadFully = false; // true when the underlying inputstream has been read fully\n\n    SimpleBufferedInput(InputStream in) {\n        super(in);\n    }\n\n    @Override\n    public int read() throws IOException {\n        if (bufPos >= bufLength) {\n            fill();\n            if (bufPos >= bufLength)\n                return -1;\n        }\n        return getBuf()[bufPos++] & 0xff;\n    }\n\n    @Override\n    public int read(byte[] dest, int offset, int desiredLen) throws IOException {\n        Validate.notNull(dest);\n        if (offset < 0 || desiredLen < 0 || desiredLen > dest.length - offset) {\n            throw new IndexOutOfBoundsException();\n        } else if (desiredLen == 0) {\n            return 0;\n        }\n\n        int bufAvail = bufLength - bufPos;\n        if (bufAvail <= 0) { // can't serve from the buffer\n            if (!inReadFully && bufMark < 0) {\n                // skip creating / copying into a local buffer; just pass through\n                int read = in.read(dest, offset, desiredLen);\n                closeIfDone(read);\n                return read;\n            }\n            fill();\n            bufAvail = bufLength - bufPos;\n        }\n\n        int read = Math.min(bufAvail, desiredLen);\n        if (read <= 0) {\n            return -1;\n        }\n\n        System.arraycopy(getBuf(), bufPos, dest, offset, read);\n        bufPos += read;\n        return read;\n    }\n\n    private void fill() throws IOException {\n        if (inReadFully) return;\n        if (byteBuf == null) { // get one on first demand\n            byteBuf = BufferPool.borrow();\n        }\n\n        if (bufMark < 0) { // no mark, can lose buffer (assumes we've read to bufLen)\n            bufPos = 0;\n        } else if (bufPos >= BufferSize) { // no room left in buffer\n            if (bufMark > 0) { // can throw away early part of the buffer\n                int size = bufPos - bufMark;\n                System.arraycopy(byteBuf, bufMark, byteBuf, 0, size);\n                bufPos = size;\n                bufMark = 0;\n            } else { // invalidate mark\n                bufMark = -1;\n                bufPos = 0;\n            }\n        }\n        bufLength = bufPos;\n        int read = in.read(byteBuf, bufPos, byteBuf.length - bufPos);\n        if (read > 0) {\n            bufLength = read + bufPos;\n            while (byteBuf.length - bufLength > 0) { // read in more if we have space, without blocking\n                if (in.available() < 1) break;\n                read = in.read(byteBuf, bufLength, byteBuf.length - bufLength);\n                if (read <= 0) break;\n                bufLength += read;\n            }\n        }\n        closeIfDone(read);\n    }\n\n    private void closeIfDone(int read) throws IOException {\n        if (read == -1) {\n            inReadFully = true;\n            super.close(); // close underlying stream immediately; frees resources a little earlier\n        }\n    }\n\n    byte[] getBuf() {\n        Validate.notNull(byteBuf);\n        return byteBuf;\n    }\n\n    /**\n     Check if the underlying InputStream has been read fully. There may still content in this buffer to be consumed.\n     @return true if the underlying inputstream has been read fully.\n     */\n    boolean baseReadFully() {\n        return inReadFully;\n    }\n\n    @Override\n    public int available() throws IOException {\n        if (byteBuf != null && bufLength - bufPos > 0)\n            return bufLength - bufPos; // doesn't include those in.available(), but mostly used as a block test\n        return inReadFully ? 0 : in.available();\n    }\n\n    @SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // explicitly not synced\n    @Override\n    public void mark(int readlimit) {\n        if (readlimit > BufferSize) {\n            throw new IllegalArgumentException(\"Read-ahead limit is greater than buffer size\");\n        }\n        bufMark = bufPos;\n    }\n\n    @SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // explicitly not synced\n    @Override\n    public void reset() throws IOException {\n        if (bufMark < 0)\n            throw new IOException(\"Resetting to invalid mark\");\n        bufPos = bufMark;\n    }\n\n    @Override\n    public void close() throws IOException {\n        super.close();\n        if (byteBuf == null) return; // already closed, or never allocated\n        BufferPool.release(byteBuf); // return the buffer to the pool\n        byteBuf = null; // NPE further attempts to read\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final int BufferSize = DefaultBufferSize;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "BufferSize = DefaultBufferSize", "syntax_pass": true}, {"attribute_expression": "static final SoftPool<byte[]> BufferPool = new SoftPool<>(() -> new byte[BufferSize]);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "SoftPool<byte[]>", "name": "BufferPool = new SoftPool<>(() -> new byte[BufferSize])", "syntax_pass": true}, {"attribute_expression": "private byte @Nullable [] byteBuf;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte @Nullable []", "name": "byteBuf", "syntax_pass": true}, {"attribute_expression": "private int bufPos;", "docstring": " the byte buffer; recycled via SoftPool. Created in fill if required", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bufPos", "syntax_pass": true}, {"attribute_expression": "private int bufLength;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bufLength", "syntax_pass": true}, {"attribute_expression": "private int bufMark = -1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bufMark = -1", "syntax_pass": true}, {"attribute_expression": "private boolean inReadFully = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "inReadFully = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream", "name": "ControllableInputStream", "file_path": "src/main/java/org/jsoup/internal/ControllableInputStream.java", "superclasses": "FilterInputStream", "methods": ["[]ControllableInputStream(SimpleBufferedInput,int)", "[ControllableInputStream]wrap(InputStream,int)", "[ControllableInputStream]wrap(InputStream,int,int)", "[int]read(byte[],int,int)", "[ByteBuffer]readToByteBuffer(InputStream,int)", "[void]reset()", "[void]mark(int)", "[boolean]baseReadFully()", "[int]max()", "[void]max(int)", "[void]allowClose(boolean)", "[void]close()", "[ControllableInputStream]timeout(long,long)", "[void]emitProgress()", "[ControllableInputStream]onProgress(int,Progress<ProgressContext>,ProgressContext)", "[boolean]expired()", "[BufferedInputStream]inputStream()"], "method_uris": ["src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[]ControllableInputStream(SimpleBufferedInput,int)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ControllableInputStream]wrap(InputStream,int)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ControllableInputStream]wrap(InputStream,int,int)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[int]read(byte[],int,int)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ByteBuffer]readToByteBuffer(InputStream,int)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]reset()", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]mark(int)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[boolean]baseReadFully()", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[int]max()", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]max(int)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]allowClose(boolean)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]close()", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ControllableInputStream]timeout(long,long)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[void]emitProgress()", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[ControllableInputStream]onProgress(int,Progress<ProgressContext>,ProgressContext)", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[boolean]expired()", "src/main/java/org/jsoup/internal/ControllableInputStream.java.ControllableInputStream.[BufferedInputStream]inputStream()"], "overrides": null, "attributes": [], "class_docstring": " reimplemented from ConstrainableInputStream for JDK21 - extending BufferedInputStream will pin threads during read", "original_string": "public class ControllableInputStream extends FilterInputStream {\n    private final SimpleBufferedInput buff; // super.in, but typed as SimpleBufferedInput\n    private int maxSize;\n    private long startTime;\n    private long timeout = 0; // optional max time of request\n    private int remaining;\n    private int markPos;\n    private boolean interrupted;\n    private boolean allowClose = true; // for cases where we want to re-read the input, can ignore .close() from the parser\n\n    // if we are tracking progress, will have the expected content length, progress callback, connection\n    private @Nullable Progress<?> progress;\n    private @Nullable Object progressContext;\n    private int contentLength = -1;\n    private int readPos = 0; // amount read; can be reset()\n\n    private ControllableInputStream(SimpleBufferedInput in, int maxSize) {\n        super(in);\n        Validate.isTrue(maxSize >= 0);\n        buff = in;\n        this.maxSize = maxSize;\n        remaining = maxSize;\n        markPos = -1;\n        startTime = System.nanoTime();\n    }\n\n    /**\n     * If this InputStream is not already a ControllableInputStream, let it be one.\n     * @param in the input stream to (maybe) wrap\n     * @param maxSize the maximum size to allow to be read. 0 == infinite.\n     * @return a controllable input stream\n     */\n    public static ControllableInputStream wrap(InputStream in, int maxSize) {\n        // bufferSize currently unused; consider implementing as a min size in the SoftPool recycler\n        if (in instanceof ControllableInputStream)\n            return (ControllableInputStream) in;\n        else\n            return new ControllableInputStream(new SimpleBufferedInput(in), maxSize);\n    }\n\n    /**\n     * If this InputStream is not already a ControllableInputStream, let it be one.\n     * @param in the input stream to (maybe) wrap\n     * @param bufferSize the buffer size to use when reading\n     * @param maxSize the maximum size to allow to be read. 0 == infinite.\n     * @return a controllable input stream\n     */\n    public static ControllableInputStream wrap(InputStream in, int bufferSize, int maxSize) {\n        // todo - bufferSize currently unused; consider implementing as a min size in the SoftPool recycler; or just deprecate if always DefaultBufferSize\n        return wrap(in, maxSize);\n    }\n\n    @Override\n    public int read(byte[] b, int off, int len) throws IOException {\n        if (readPos == 0) emitProgress(); // emits a progress\n\n        boolean capped = maxSize != 0;\n        if (interrupted || capped && remaining <= 0)\n            return -1;\n        if (Thread.currentThread().isInterrupted()) {\n            // interrupted latches, because parse() may call twice\n            interrupted = true;\n            return -1;\n        }\n\n        if (capped && len > remaining)\n            len = remaining; // don't read more than desired, even if available\n\n        while (true) { // loop trying to read until we get some data or hit the overall timeout, if we have one\n            if (expired())\n                throw new SocketTimeoutException(\"Read timeout\");\n\n            try {\n                final int read = super.read(b, off, len);\n                if (read == -1) { // completed\n                    contentLength = readPos;\n                } else {\n                    remaining -= read;\n                    readPos += read;\n                }\n                emitProgress();\n                return read;\n            } catch (SocketTimeoutException e) {\n                if (expired() || timeout == 0)\n                    throw e;\n            }\n        }\n    }\n\n    /**\n     * Reads this inputstream to a ByteBuffer. The supplied max may be less than the inputstream's max, to support\n     * reading just the first bytes.\n     */\n    public static ByteBuffer readToByteBuffer(InputStream in, int max) throws IOException {\n        Validate.isTrue(max >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        Validate.notNull(in);\n        final boolean capped = max > 0;\n        final byte[] readBuf = SimpleBufferedInput.BufferPool.borrow(); // Share the same byte[] pool as SBI\n        final int outSize = capped ? Math.min(max, DefaultBufferSize) : DefaultBufferSize;\n        ByteBuffer outBuf = ByteBuffer.allocate(outSize);\n\n        try {\n            int remaining = max;\n            int read;\n            while ((read = in.read(readBuf, 0, capped ? Math.min(remaining, DefaultBufferSize) : DefaultBufferSize)) != -1) {\n                if (outBuf.remaining() < read) { // needs to grow\n                    int newCapacity = (int) Math.max(outBuf.capacity() * 1.5, outBuf.capacity() + read);\n                    ByteBuffer newBuffer = ByteBuffer.allocate(newCapacity);\n                    outBuf.flip();\n                    newBuffer.put(outBuf);\n                    outBuf = newBuffer;\n                }\n                outBuf.put(readBuf, 0, read);\n                if (capped) {\n                    remaining -= read;\n                    if (remaining <= 0) break;\n                }\n            }\n            outBuf.flip(); // Prepare the buffer for reading\n            return outBuf;\n        } finally {\n            SimpleBufferedInput.BufferPool.release(readBuf);\n        }\n    }\n\n    @SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // not synchronized in later JDKs\n    @Override public void reset() throws IOException {\n        super.reset();\n        remaining = maxSize - markPos;\n        readPos = markPos; // readPos is used for progress emits\n    }\n\n    @SuppressWarnings(\"NonSynchronizedMethodOverridesSynchronizedMethod\") // not synchronized in later JDKs\n    @Override public void mark(int readlimit) {\n        super.mark(readlimit);\n        markPos = maxSize - remaining;\n    }\n\n    /**\n     Check if the underlying InputStream has been read fully. There may still content in buffers to be consumed, and\n     read methods may return -1 if hit the read limit.\n     @return true if the underlying inputstream has been read fully.\n     */\n    public boolean baseReadFully() {\n        return buff.baseReadFully();\n    }\n\n    /**\n     Get the max size of this stream (how far at most will be read from the underlying stream)\n     * @return the max size\n     */\n    public int max() {\n        return maxSize;\n    }\n\n    public void max(int newMax) {\n        remaining += newMax - maxSize; // update remaining to reflect the difference in the new maxsize\n        maxSize = newMax;\n    }\n\n    public void allowClose(boolean allowClose) {\n        this.allowClose = allowClose;\n    }\n\n    @Override public void close() throws IOException {\n        if (allowClose) super.close();\n    }\n\n    public ControllableInputStream timeout(long startTimeNanos, long timeoutMillis) {\n        this.startTime = startTimeNanos;\n        this.timeout = timeoutMillis * 1000000;\n        return this;\n    }\n\n    private void emitProgress() {\n        if (progress == null) return;\n        // calculate percent complete if contentLength > 0 (and cap to 100.0 if totalRead > contentLength):\n        float percent = contentLength > 0 ? Math.min(100f, readPos * 100f / contentLength) : 0;\n        //noinspection unchecked\n        ((Progress<Object>) progress).onProgress(readPos, contentLength, percent, progressContext); // (not actually unchecked - verified when set)\n        if (percent == 100.0f) progress = null; // detach once we reach 100%, so that any subsequent buffer hits don't report 100 again\n    }\n\n    public <ProgressContext> ControllableInputStream onProgress(int contentLength, Progress<ProgressContext> callback, ProgressContext context) {\n        Validate.notNull(callback);\n        Validate.notNull(context);\n        this.contentLength = contentLength;\n        this.progress = callback;\n        this.progressContext = context;\n        return this;\n    }\n\n    private boolean expired() {\n        if (timeout == 0)\n            return false;\n\n        final long now = System.nanoTime();\n        final long dur = now - startTime;\n        return (dur > timeout);\n    }\n\n    public BufferedInputStream inputStream() {\n        // called via HttpConnection.Response.bodyStream(), needs an OG BufferedInputStream\n        return new BufferedInputStream(buff);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final SimpleBufferedInput buff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SimpleBufferedInput", "name": "buff", "syntax_pass": true}, {"attribute_expression": "private int maxSize;", "docstring": " super.in, but typed as SimpleBufferedInput", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "maxSize", "syntax_pass": true}, {"attribute_expression": "private long startTime;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "startTime", "syntax_pass": true}, {"attribute_expression": "private long timeout = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "timeout = 0", "syntax_pass": true}, {"attribute_expression": "private int remaining;", "docstring": " optional max time of request", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "remaining", "syntax_pass": true}, {"attribute_expression": "private int markPos;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "markPos", "syntax_pass": true}, {"attribute_expression": "private boolean interrupted;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "interrupted", "syntax_pass": true}, {"attribute_expression": "private boolean allowClose = true;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "allowClose = true", "syntax_pass": true}, {"attribute_expression": "private @Nullable Progress<?> progress;", "docstring": " if we are tracking progress, will have the expected content length, progress callback, connection", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Progress<?>", "name": "progress", "syntax_pass": true}, {"attribute_expression": "private @Nullable Object progressContext;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Object", "name": "progressContext", "syntax_pass": true}, {"attribute_expression": "private int contentLength = -1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "contentLength = -1", "syntax_pass": true}, {"attribute_expression": "private int readPos = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "readPos = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/Comment.java.Comment", "name": "Comment", "file_path": "src/main/java/org/jsoup/nodes/Comment.java", "superclasses": "LeafNode", "methods": ["[]Comment(String)", "[String]nodeName()", "[String]getData()", "[Comment]setData(String)", "[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "[Comment]clone()", "[boolean]isXmlDeclaration()", "[boolean]isXmlDeclarationData(String)", "[XmlDeclaration]asXmlDeclaration()"], "method_uris": ["src/main/java/org/jsoup/nodes/Comment.java.Comment.[]Comment(String)", "src/main/java/org/jsoup/nodes/Comment.java.Comment.[String]nodeName()", "src/main/java/org/jsoup/nodes/Comment.java.Comment.[String]getData()", "src/main/java/org/jsoup/nodes/Comment.java.Comment.[Comment]setData(String)", "src/main/java/org/jsoup/nodes/Comment.java.Comment.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Comment.java.Comment.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Comment.java.Comment.[Comment]clone()", "src/main/java/org/jsoup/nodes/Comment.java.Comment.[boolean]isXmlDeclaration()", "src/main/java/org/jsoup/nodes/Comment.java.Comment.[boolean]isXmlDeclarationData(String)", "src/main/java/org/jsoup/nodes/Comment.java.Comment.[XmlDeclaration]asXmlDeclaration()"], "overrides": null, "attributes": [], "class_docstring": "\nA comment node.\n\n@author Jonathan Hedley, jonathan@hedley.net", "original_string": "public class Comment extends LeafNode {\n    /**\n     Create a new comment node.\n     @param data The contents of the comment\n     */\n    public Comment(String data) {\n        super(data);\n    }\n\n    @Override public String nodeName() {\n        return \"#comment\";\n    }\n\n    /**\n     Get the contents of the comment.\n     @return comment content\n     */\n    public String getData() {\n        return coreValue();\n    }\n\n    public Comment setData(String data) {\n        coreValue(data);\n        return this;\n    }\n\n    @Override\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint() && ((isEffectivelyFirst() && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock()) || (out.outline() )))\n            indent(accum, depth, out);\n        accum\n                .append(\"<!--\")\n                .append(getData())\n                .append(\"-->\");\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n\n    @Override\n    public Comment clone() {\n        return (Comment) super.clone();\n    }\n\n    /**\n     * Check if this comment looks like an XML Declaration.\n     * @return true if it looks like, maybe, it's an XML Declaration.\n     */\n    public boolean isXmlDeclaration() {\n        String data = getData();\n        return isXmlDeclarationData(data);\n    }\n\n    private static boolean isXmlDeclarationData(String data) {\n        return (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\")));\n    }\n\n    /**\n     * Attempt to cast this comment to an XML Declaration node.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public @Nullable XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n\n        XmlDeclaration decl = null;\n        String declContent = data.substring(1, data.length() - 1);\n        // make sure this bogus comment is not immediately followed by another, treat as comment if so\n        if (isXmlDeclarationData(declContent))\n            return null;\n\n        String fragment = \"<\" + declContent + \">\";\n        // use the HTML parser not XML, so we don't get into a recursive XML Declaration on contrived data\n        Document doc = Parser.htmlParser().settings(ParseSettings.preserveCase).parseInput(fragment, baseUri());\n        if (doc.body().childrenSize() > 0) {\n            Element el = doc.body().child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType", "name": "DocumentType", "file_path": "src/main/java/org/jsoup/nodes/DocumentType.java", "superclasses": "LeafNode", "methods": ["[]DocumentType(String,String,String)", "[void]setPubSysKey(String)", "[void]updatePubSyskey()", "[String]name()", "[String]publicId()", "[String]systemId()", "[String]nodeName()", "[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "[boolean]has(String)"], "method_uris": ["src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[]DocumentType(String,String,String)", "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[void]setPubSysKey(String)", "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[void]updatePubSyskey()", "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[String]name()", "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[String]publicId()", "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[String]systemId()", "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[String]nodeName()", "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/DocumentType.java.DocumentType.[boolean]has(String)"], "overrides": null, "attributes": [], "class_docstring": "\nA {@code <!DOCTYPE>} node.\n", "original_string": "public class DocumentType extends LeafNode {\n    // todo needs a bit of a chunky cleanup. this level of detail isn't needed\n    public static final String PUBLIC_KEY = \"PUBLIC\";\n    public static final String SYSTEM_KEY = \"SYSTEM\";\n    private static final String Name = \"#doctype\";\n    private static final String PubSysKey = \"pubSysKey\"; // PUBLIC or SYSTEM\n    private static final String PublicId = \"publicId\";\n    private static final String SystemId = \"systemId\";\n    // todo: quirk mode from publicId and systemId\n\n    /**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     */\n    public DocumentType(String name, String publicId, String systemId) {\n        super(name);\n        Validate.notNull(publicId);\n        Validate.notNull(systemId);\n        attr(Name, name);\n        attr(PublicId, publicId);\n        attr(SystemId, systemId);\n        updatePubSyskey();\n    }\n\n    public void setPubSysKey(@Nullable String value) {\n        if (value != null)\n            attr(PubSysKey, value);\n    }\n\n    private void updatePubSyskey() {\n        if (has(PublicId)) {\n            attr(PubSysKey, PUBLIC_KEY);\n        } else if (has(SystemId))\n            attr(PubSysKey, SYSTEM_KEY);\n    }\n\n    /**\n     * Get this doctype's name (when set, or empty string)\n     * @return doctype name\n     */\n    public String name() {\n        return attr(Name);\n    }\n\n    /**\n     * Get this doctype's Public ID (when set, or empty string)\n     * @return doctype Public ID\n     */\n    public String publicId() {\n        return attr(PublicId);\n    }\n\n    /**\n     * Get this doctype's System ID (when set, or empty string)\n     * @return doctype System ID\n     */\n    public String systemId() {\n        return attr(SystemId);\n    }\n\n    @Override\n    public String nodeName() {\n        return Name;\n    }\n\n    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        // add a newline if the doctype has a preceding node (which must be a comment)\n        if (siblingIndex > 0 && out.prettyPrint())\n            accum.append('\\n');\n\n        if (out.syntax() == Syntax.html && !has(PublicId) && !has(SystemId)) {\n            // looks like a html5 doctype, go lowercase for aesthetics\n            accum.append(\"<!doctype\");\n        } else {\n            accum.append(\"<!DOCTYPE\");\n        }\n        if (has(Name))\n            accum.append(\" \").append(attr(Name));\n        if (has(PubSysKey))\n            accum.append(\" \").append(attr(PubSysKey));\n        if (has(PublicId))\n            accum.append(\" \\\"\").append(attr(PublicId)).append('\"');\n        if (has(SystemId))\n            accum.append(\" \\\"\").append(attr(SystemId)).append('\"');\n        accum.append('>');\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }\n\n    private boolean has(final String attribute) {\n        return !StringUtil.isBlank(attr(attribute));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String PUBLIC_KEY = \"PUBLIC\";", "docstring": " todo needs a bit of a chunky cleanup. this level of detail isn't needed", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PUBLIC_KEY = \"PUBLIC\"", "syntax_pass": true}, {"attribute_expression": "public static final String SYSTEM_KEY = \"SYSTEM\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "SYSTEM_KEY = \"SYSTEM\"", "syntax_pass": true}, {"attribute_expression": "private static final String Name = \"#doctype\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "Name = \"#doctype\"", "syntax_pass": true}, {"attribute_expression": "private static final String PubSysKey = \"pubSysKey\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PubSysKey = \"pubSysKey\"", "syntax_pass": true}, {"attribute_expression": "private static final String PublicId = \"publicId\";", "docstring": " PUBLIC or SYSTEM", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PublicId = \"publicId\"", "syntax_pass": true}, {"attribute_expression": "private static final String SystemId = \"systemId\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "SystemId = \"systemId\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode", "name": "CDataNode", "file_path": "src/main/java/org/jsoup/nodes/CDataNode.java", "superclasses": "TextNode", "methods": ["[]CDataNode(String)", "[String]nodeName()", "[String]text()", "[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "[CDataNode]clone()"], "method_uris": ["src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[]CDataNode(String)", "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[String]nodeName()", "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[String]text()", "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/CDataNode.java.CDataNode.[CDataNode]clone()"], "overrides": null, "attributes": [], "class_docstring": "\nA Character Data node, to support CDATA sections.\n", "original_string": "public class CDataNode extends TextNode {\n    public CDataNode(String text) {\n        super(text);\n    }\n\n    @Override\n    public String nodeName() {\n        return \"#cdata\";\n    }\n\n    /**\n     * Get the un-encoded, <b>non-normalized</b> text content of this CDataNode.\n     * @return un-encoded, non-normalized text\n     */\n    @Override\n    public String text() {\n        return getWholeText();\n    }\n\n    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum\n            .append(\"<![CDATA[\")\n            .append(getWholeText());\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum.append(\"]]>\");\n    }\n\n    @Override\n    public CDataNode clone() {\n        return (CDataNode) super.clone();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement", "name": "PseudoTextElement", "file_path": "src/main/java/org/jsoup/nodes/PseudoTextElement.java", "superclasses": "Element", "methods": ["[]PseudoTextElement(Tag,String,Attributes)", "[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "[void]outerHtmlTail(Appendable,int,Document.OutputSettings)"], "method_uris": ["src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement.[]PseudoTextElement(Tag,String,Attributes)", "src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/PseudoTextElement.java.PseudoTextElement.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a {@link TextNode} as an {@link Element}, to enable text nodes to be selected with\nthe {@link org.jsoup.select.Selector} {@code :matchText} syntax.\n", "original_string": "public class PseudoTextElement extends Element {\n\n    public PseudoTextElement(Tag tag, String baseUri, Attributes attributes) {\n        super(tag, baseUri, attributes);\n    }\n\n    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) {\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/nodes/TextNode.java.TextNode", "name": "TextNode", "file_path": "src/main/java/org/jsoup/nodes/TextNode.java", "superclasses": "LeafNode", "methods": ["[]TextNode(String)", "[String]nodeName()", "[String]text()", "[TextNode]text(String)", "[String]getWholeText()", "[boolean]isBlank()", "[TextNode]splitText(int)", "[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "[String]toString()", "[TextNode]clone()", "[TextNode]createFromEncoded(String)", "[String]normaliseWhitespace(String)", "[String]stripLeadingWhitespace(String)", "[boolean]lastCharIsWhitespace(StringBuilder)"], "method_uris": ["src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[]TextNode(String)", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]nodeName()", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]text()", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[TextNode]text(String)", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]getWholeText()", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[boolean]isBlank()", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[TextNode]splitText(int)", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]toString()", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[TextNode]clone()", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[TextNode]createFromEncoded(String)", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]normaliseWhitespace(String)", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[String]stripLeadingWhitespace(String)", "src/main/java/org/jsoup/nodes/TextNode.java.TextNode.[boolean]lastCharIsWhitespace(StringBuilder)"], "overrides": null, "attributes": [], "class_docstring": "\nA text node.\n\n@author Jonathan Hedley, jonathan@hedley.net", "original_string": "public class TextNode extends LeafNode {\n    /**\n     Create a new TextNode representing the supplied (unencoded) text).\n\n     @param text raw text\n     @see #createFromEncoded(String)\n     */\n    public TextNode(String text) {\n        super(text);\n    }\n\n\t@Override public String nodeName() {\n        return \"#text\";\n    }\n    \n    /**\n     * Get the text content of this text node.\n     * @return Unencoded, normalised text.\n     * @see TextNode#getWholeText()\n     */\n    public String text() {\n        return StringUtil.normaliseWhitespace(getWholeText());\n    }\n    \n    /**\n     * Set the text content of this text node.\n     * @param text unencoded text\n     * @return this, for chaining\n     */\n    public TextNode text(String text) {\n        coreValue(text);\n        return this;\n    }\n\n    /**\n     Get the (unencoded) text of this text node, including any newlines and spaces present in the original.\n     @return text\n     */\n    public String getWholeText() {\n        return coreValue();\n    }\n\n    /**\n     Test if this text node is blank -- that is, empty or only whitespace (including newlines).\n     @return true if this document is empty or only whitespace, false if it contains any text content.\n     */\n    public boolean isBlank() {\n        return StringUtil.isBlank(coreValue());\n    }\n\n    /**\n     * Split this text node into two nodes at the specified string offset. After splitting, this node will contain the\n     * original text up to the offset, and will have a new text node sibling containing the text after the offset.\n     * @param offset string offset point to split node at.\n     * @return the newly created text node containing the text after the offset.\n     */\n    public TextNode splitText(int offset) {\n        final String text = coreValue();\n        Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n        Validate.isTrue(offset < text.length(), \"Split offset must not be greater than current text length\");\n\n        String head = text.substring(0, offset);\n        String tail = text.substring(offset);\n        text(head);\n        TextNode tailNode = new TextNode(tail);\n        if (parentNode != null)\n            parentNode.addChildren(siblingIndex()+1, tailNode);\n\n        return tailNode;\n    }\n\n    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n        int escape = Entities.ForText;\n\n        if (normaliseWhite) {\n            escape |= Entities.Normalise;\n            final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n            final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n            if ((trimLikeBlock && siblingIndex == 0) || parentNode instanceof Document)\n                escape |= Entities.TrimLeading;\n            if (trimLikeBlock && nextSibling() == null)\n                escape |= Entities.TrimTrailing;\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n            Node next = nextSibling();\n            Node prev = previousSibling();\n            boolean isBlank = isBlank();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())) // next is blank text, from re-parenting\n                || (prev instanceof Element && (((Element) prev).isBlock() || prev.nameIs(\"br\"))) // br is a bit special - make sure we don't get a dangling blank line, but not a block otherwise wraps in head\n                ;\n            if (couldSkip && isBlank) return;\n\n            if (\n                (prev == null && parent != null && parent.tag().formatAsBlock() && !isBlank) ||\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                (prev != null && prev.nameIs(\"br\")) // special case wrap on inline <br> - doesn't make sense as a block tag\n            )\n                indent(accum, depth, out);\n        }\n\n        Entities.escape(accum, coreValue(), out, escape);\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {}\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public TextNode clone() {\n        return (TextNode) super.clone();\n    }\n\n    /**\n     * Create a new TextNode from HTML encoded (aka escaped) data.\n     * @param encodedText Text containing encoded HTML (e.g. {@code &lt;})\n     * @return TextNode containing unencoded data (e.g. {@code <})\n     */\n    public static TextNode createFromEncoded(String encodedText) {\n        String text = Entities.unescape(encodedText);\n        return new TextNode(text);\n    }\n\n    static String normaliseWhitespace(String text) {\n        text = StringUtil.normaliseWhitespace(text);\n        return text;\n    }\n\n    static String stripLeadingWhitespace(String text) {\n        return text.replaceFirst(\"^\\\\s+\", \"\");\n    }\n\n    static boolean lastCharIsWhitespace(StringBuilder sb) {\n        return sb.length() != 0 && sb.charAt(sb.length() - 1) == ' ';\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/nodes/Element.java.Element", "name": "Element", "file_path": "src/main/java/org/jsoup/nodes/Element.java", "superclasses": "Node", "methods": ["[]Element(String,String)", "[]Element(String)", "[]Element(Tag,String,Attributes)", "[]Element(Tag,String)", "[boolean]hasChildNodes()", "[List<Node>]ensureChildNodes()", "[boolean]hasAttributes()", "[Attributes]attributes()", "[String]baseUri()", "[String]searchUpForAttribute(Element,String)", "[void]doSetBaseUri(String)", "[int]childNodeSize()", "[String]nodeName()", "[String]tagName()", "[String]normalName()", "[boolean]elementIs(String,String)", "[Element]tagName(String)", "[Element]tagName(String,String)", "[Tag]tag()", "[boolean]isBlock()", "[String]id()", "[Element]id(String)", "[Element]attr(String,String)", "[Element]attr(String,boolean)", "[Attribute]attribute(String)", "[Map<String, String>]dataset()", "[Element]parent()", "[Elements]parents()", "[Element]child(int)", "[int]childrenSize()", "[Elements]children()", "[List<Element>]childElementsList()", "[void]nodelistChanged()", "[Stream<Element>]stream()", "[List<T>]filterNodes(Class<T>)", "[List<TextNode>]textNodes()", "[List<DataNode>]dataNodes()", "[Elements]select(String)", "[Elements]select(Evaluator)", "[Element]selectFirst(String)", "[Element]selectFirst(Evaluator)", "[Element]expectFirst(String)", "[boolean]is(String)", "[boolean]is(Evaluator)", "[Element]closest(String)", "[Element]closest(Evaluator)", "[Elements]selectXpath(String)", "[List<T>]selectXpath(String,Class<T>)", "[Element]appendChild(Node)", "[Element]appendChildren(Collection<? extends Node>)", "[Element]appendTo(Element)", "[Element]prependChild(Node)", "[Element]prependChildren(Collection<? extends Node>)", "[Element]insertChildren(int,Collection<? extends Node>)", "[Element]insertChildren(int)", "[Element]appendElement(String)", "[Element]appendElement(String,String)", "[Element]prependElement(String)", "[Element]prependElement(String,String)", "[Element]appendText(String)", "[Element]prependText(String)", "[Element]append(String)", "[Element]prepend(String)", "[Element]before(String)", "[Element]before(Node)", "[Element]after(String)", "[Element]after(Node)", "[Element]empty()", "[Element]wrap(String)", "[String]cssSelector()", "[String]cssSelectorComponent()", "[Elements]siblingElements()", "[Element]nextElementSibling()", "[Elements]nextElementSiblings()", "[Element]previousElementSibling()", "[Elements]previousElementSiblings()", "[Elements]nextElementSiblings(boolean)", "[Element]firstElementSibling()", "[int]elementSiblingIndex()", "[Element]lastElementSibling()", "[int]indexInList(Element,List<E>)", "[Element]firstElementChild()", "[Element]lastElementChild()", "[Elements]getElementsByTag(String)", "[Element]getElementById(String)", "[Elements]getElementsByClass(String)", "[Elements]getElementsByAttribute(String)", "[Elements]getElementsByAttributeStarting(String)", "[Elements]getElementsByAttributeValue(String,String)", "[Elements]getElementsByAttributeValueNot(String,String)", "[Elements]getElementsByAttributeValueStarting(String,String)", "[Elements]getElementsByAttributeValueEnding(String,String)", "[Elements]getElementsByAttributeValueContaining(String,String)", "[Elements]getElementsByAttributeValueMatching(String,Pattern)", "[Elements]getElementsByAttributeValueMatching(String,String)", "[Elements]getElementsByIndexLessThan(int)", "[Elements]getElementsByIndexGreaterThan(int)", "[Elements]getElementsByIndexEquals(int)", "[Elements]getElementsContainingText(String)", "[Elements]getElementsContainingOwnText(String)", "[Elements]getElementsMatchingText(Pattern)", "[Elements]getElementsMatchingText(String)", "[Elements]getElementsMatchingOwnText(Pattern)", "[Elements]getElementsMatchingOwnText(String)", "[Elements]getAllElements()", "[String]text()", "[String]wholeText()", "[String]wholeTextOf(Stream<Node>)", "[String]wholeOwnText()", "[String]ownText()", "[void]ownText(StringBuilder)", "[void]appendNormalisedText(StringBuilder,TextNode)", "[boolean]preserveWhitespace(Node)", "[Element]text(String)", "[boolean]hasText()", "[String]data()", "[String]className()", "[Set<String>]classNames()", "[Element]classNames(Set<String>)", "[boolean]hasClass(String)", "[Element]addClass(String)", "[Element]removeClass(String)", "[Element]toggleClass(String)", "[String]val()", "[Element]val(String)", "[Range]endSourceRange()", "[boolean]shouldIndent(Document.OutputSettings)", "[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "[String]html()", "[T]html(T)", "[Element]html(String)", "[Element]clone()", "[Element]shallowClone()", "[Element]doClone(Node)", "[Element]clearAttributes()", "[Element]removeAttr(String)", "[Element]root()", "[Element]traverse(NodeVisitor)", "[Element]forEachNode(Consumer<? super Node>)", "[Element]forEach(Consumer<? super Element>)", "[Element]filter(NodeFilter)", "[boolean]isFormatAsBlock(Document.OutputSettings)", "[boolean]isInlineable(Document.OutputSettings)"], "method_uris": ["src/main/java/org/jsoup/nodes/Element.java.Element.[]Element(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[]Element(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[]Element(Tag,String,Attributes)", "src/main/java/org/jsoup/nodes/Element.java.Element.[]Element(Tag,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]hasChildNodes()", "src/main/java/org/jsoup/nodes/Element.java.Element.[List<Node>]ensureChildNodes()", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]hasAttributes()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Attributes]attributes()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]baseUri()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]searchUpForAttribute(Element,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[void]doSetBaseUri(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[int]childNodeSize()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]nodeName()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]tagName()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]normalName()", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]elementIs(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]tagName(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]tagName(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Tag]tag()", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]isBlock()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]id()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]id(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]attr(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]attr(String,boolean)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Attribute]attribute(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Map<String, String>]dataset()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]parent()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]parents()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]child(int)", "src/main/java/org/jsoup/nodes/Element.java.Element.[int]childrenSize()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]children()", "src/main/java/org/jsoup/nodes/Element.java.Element.[List<Element>]childElementsList()", "src/main/java/org/jsoup/nodes/Element.java.Element.[void]nodelistChanged()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Stream<Element>]stream()", "src/main/java/org/jsoup/nodes/Element.java.Element.[List<T>]filterNodes(Class<T>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[List<TextNode>]textNodes()", "src/main/java/org/jsoup/nodes/Element.java.Element.[List<DataNode>]dataNodes()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]select(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]select(Evaluator)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]selectFirst(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]selectFirst(Evaluator)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]expectFirst(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]is(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]is(Evaluator)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]closest(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]closest(Evaluator)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]selectXpath(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[List<T>]selectXpath(String,Class<T>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendChild(Node)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendChildren(Collection<? extends Node>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendTo(Element)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependChild(Node)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependChildren(Collection<? extends Node>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]insertChildren(int,Collection<? extends Node>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]insertChildren(int)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendElement(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendElement(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependElement(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependElement(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]appendText(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prependText(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]append(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]prepend(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]before(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]before(Node)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]after(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]after(Node)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]empty()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]wrap(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]cssSelector()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]cssSelectorComponent()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]siblingElements()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]nextElementSibling()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]nextElementSiblings()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]previousElementSibling()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]previousElementSiblings()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]nextElementSiblings(boolean)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]firstElementSibling()", "src/main/java/org/jsoup/nodes/Element.java.Element.[int]elementSiblingIndex()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]lastElementSibling()", "src/main/java/org/jsoup/nodes/Element.java.Element.[int]indexInList(Element,List<E>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]firstElementChild()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]lastElementChild()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByTag(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]getElementById(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByClass(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttribute(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeStarting(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValue(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueNot(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueStarting(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueEnding(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueContaining(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueMatching(String,Pattern)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByAttributeValueMatching(String,String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByIndexLessThan(int)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByIndexGreaterThan(int)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsByIndexEquals(int)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsContainingText(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsContainingOwnText(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsMatchingText(Pattern)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsMatchingText(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsMatchingOwnText(Pattern)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getElementsMatchingOwnText(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Elements]getAllElements()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]text()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]wholeText()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]wholeTextOf(Stream<Node>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]wholeOwnText()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]ownText()", "src/main/java/org/jsoup/nodes/Element.java.Element.[void]ownText(StringBuilder)", "src/main/java/org/jsoup/nodes/Element.java.Element.[void]appendNormalisedText(StringBuilder,TextNode)", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]preserveWhitespace(Node)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]text(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]hasText()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]data()", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]className()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Set<String>]classNames()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]classNames(Set<String>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]hasClass(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]addClass(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]removeClass(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]toggleClass(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]val()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]val(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Range]endSourceRange()", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]shouldIndent(Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Element.java.Element.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Element.java.Element.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Element.java.Element.[String]html()", "src/main/java/org/jsoup/nodes/Element.java.Element.[T]html(T)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]html(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]clone()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]shallowClone()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]doClone(Node)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]clearAttributes()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]removeAttr(String)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]root()", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]traverse(NodeVisitor)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]forEachNode(Consumer<? super Node>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]forEach(Consumer<? super Element>)", "src/main/java/org/jsoup/nodes/Element.java.Element.[Element]filter(NodeFilter)", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]isFormatAsBlock(Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Element.java.Element.[boolean]isInlineable(Document.OutputSettings)"], "overrides": null, "attributes": [{"original_string": "    private static class TextAccumulator implements NodeVisitor {\n        private final StringBuilder accum;\n\n        public TextAccumulator(StringBuilder accum) {\n            this.accum = accum;\n        }\n\n        @Override public void head(Node node, int depth) {\n            if (node instanceof TextNode) {\n                TextNode textNode = (TextNode) node;\n                appendNormalisedText(accum, textNode);\n            } else if (node instanceof Element) {\n                Element element = (Element) node;\n                if (accum.length() > 0 &&\n                    (element.isBlock() || element.nameIs(\"br\")) &&\n                    !lastCharIsWhitespace(accum))\n                    accum.append(' ');\n            }\n        }\n\n        @Override public void tail(Node node, int depth) {\n            // make sure there is a space between block tags and immediately following text nodes or inline elements <div>One</div>Two should be \"One Two\".\n            if (node instanceof Element) {\n                Element element = (Element) node;\n                Node next = node.nextSibling();\n                if (element.isBlock() && (next instanceof TextNode || next instanceof Element && !((Element) next).tag.formatAsBlock()) && !lastCharIsWhitespace(accum))\n                    accum.append(' ');\n            }\n\n        }\n    }", "definition": "    private static class TextAccumulator implements NodeVisitor", "class_docstring": "", "name": "TextAccumulator", "super_interfaces": ["NodeVisitor"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final StringBuilder accum;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StringBuilder", "name": "accum", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TextAccumulator(StringBuilder accum) {\n            this.accum = accum;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TextAccumulator", "params": [{"name": "accum", "type": "StringBuilder"}], "body": "                                                    {\n            this.accum = accum;\n        }", "signature": "public TextAccumulator(StringBuilder accum)"}, {"syntax_pass": true, "original_string": "        @Override public void head(Node node, int depth) {\n            if (node instanceof TextNode) {\n                TextNode textNode = (TextNode) node;\n                appendNormalisedText(accum, textNode);\n            } else if (node instanceof Element) {\n                Element element = (Element) node;\n                if (accum.length() > 0 &&\n                    (element.isBlock() || element.nameIs(\"br\")) &&\n                    !lastCharIsWhitespace(accum))\n                    accum.append(' ');\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "head", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                         {\n            if (node instanceof TextNode) {\n                TextNode textNode = (TextNode) node;\n                appendNormalisedText(accum, textNode);\n            } else if (node instanceof Element) {\n                Element element = (Element) node;\n                if (accum.length() > 0 &&\n                    (element.isBlock() || element.nameIs(\"br\")) &&\n                    !lastCharIsWhitespace(accum))\n                    accum.append(' ');\n            }\n        }", "signature": "@Override public void head(Node node, int depth)"}, {"syntax_pass": true, "original_string": "        @Override public void tail(Node node, int depth) {\n            // make sure there is a space between block tags and immediately following text nodes or inline elements <div>One</div>Two should be \"One Two\".\n            if (node instanceof Element) {\n                Element element = (Element) node;\n                Node next = node.nextSibling();\n                if (element.isBlock() && (next instanceof TextNode || next instanceof Element && !((Element) next).tag.formatAsBlock()) && !lastCharIsWhitespace(accum))\n                    accum.append(' ');\n            }\n\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tail", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                                         {\n            // make sure there is a space between block tags and immediately following text nodes or inline elements <div>One</div>Two should be \"One Two\".\n            if (node instanceof Element) {\n                Element element = (Element) node;\n                Node next = node.nextSibling();\n                if (element.isBlock() && (next instanceof TextNode || next instanceof Element && !((Element) next).tag.formatAsBlock()) && !lastCharIsWhitespace(accum))\n                    accum.append(' ');\n            }\n\n        }", "signature": "@Override public void tail(Node node, int depth)"}]}, {"original_string": "    private static final class NodeList extends ChangeNotifyingArrayList<Node> {\n        private final Element owner;\n\n        NodeList(Element owner, int initialCapacity) {\n            super(initialCapacity);\n            this.owner = owner;\n        }\n\n        @Override public void onContentsChanged() {\n            owner.nodelistChanged();\n        }\n    }", "definition": "    private static final class NodeList extends ChangeNotifyingArrayList<Node>", "class_docstring": "", "name": "NodeList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Element owner;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Element", "name": "owner", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        NodeList(Element owner, int initialCapacity) {\n            super(initialCapacity);\n            this.owner = owner;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NodeList", "params": [{"name": "owner", "type": "Element"}, {"name": "initialCapacity", "type": "int"}], "body": "                                                     {\n            super(initialCapacity);\n            this.owner = owner;\n        }", "signature": "NodeList(Element owner, int initialCapacity)"}, {"syntax_pass": true, "original_string": "        @Override public void onContentsChanged() {\n            owner.nodelistChanged();\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onContentsChanged", "params": [], "body": "                                                  {\n            owner.nodelistChanged();\n        }", "signature": "@Override public void onContentsChanged()"}]}], "class_docstring": "\nAn HTML Element consists of a tag name, attributes, and child nodes (including text nodes and other elements).\n<p>\nFrom an Element, you can extract data, traverse the node graph, and manipulate the HTML.\n", "original_string": "public class Element extends Node {\n    private static final List<Element> EmptyChildren = Collections.emptyList();\n    private static final Pattern ClassSplit = Pattern.compile(\"\\\\s+\");\n    private static final String BaseUriKey = Attributes.internalKey(\"baseUri\");\n    private Tag tag;\n    private @Nullable WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children\n    List<Node> childNodes;\n    @Nullable Attributes attributes; // field is nullable but all methods for attributes are non-null\n\n    /**\n     * Create a new, standalone element, in the specified namespace.\n     * @param tag tag name\n     * @param namespace namespace for this element\n     */\n    public Element(String tag, String namespace) {\n        this(Tag.valueOf(tag, namespace, ParseSettings.preserveCase), null);\n    }\n\n    /**\n     * Create a new, standalone element, in the HTML namespace.\n     * @param tag tag name\n     * @see #Element(String tag, String namespace)\n     */\n    public Element(String tag) {\n        this(Tag.valueOf(tag, Parser.NamespaceHtml, ParseSettings.preserveCase), \"\", null);\n    }\n\n    /**\n     * Create a new, standalone Element. (Standalone in that it has no parent.)\n     *\n     * @param tag tag of this element\n     * @param baseUri the base URI (optional, may be null to inherit from parent, or \"\" to clear parent's)\n     * @param attributes initial attributes (optional, may be null)\n     * @see #appendChild(Node)\n     * @see #appendElement(String)\n     */\n    public Element(Tag tag, @Nullable String baseUri, @Nullable Attributes attributes) {\n        Validate.notNull(tag);\n        childNodes = EmptyNodes;\n        this.attributes = attributes;\n        this.tag = tag;\n        if (baseUri != null)\n            this.setBaseUri(baseUri);\n    }\n\n    /**\n     * Create a new Element from a Tag and a base URI.\n     *\n     * @param tag element tag\n     * @param baseUri the base URI of this element. Optional, and will inherit from its parent, if any.\n     * @see Tag#valueOf(String, ParseSettings)\n     */\n    public Element(Tag tag, @Nullable String baseUri) {\n        this(tag, baseUri, null);\n    }\n\n    /**\n     Internal test to check if a nodelist object has been created.\n     */\n    protected boolean hasChildNodes() {\n        return childNodes != EmptyNodes;\n    }\n\n    @Override protected List<Node> ensureChildNodes() {\n        if (childNodes == EmptyNodes) {\n            childNodes = new NodeList(this, 4);\n        }\n        return childNodes;\n    }\n\n    @Override\n    protected boolean hasAttributes() {\n        return attributes != null;\n    }\n\n    @Override\n    public Attributes attributes() {\n        if (attributes == null) // not using hasAttributes, as doesn't clear warning\n            attributes = new Attributes();\n        return attributes;\n    }\n\n    @Override\n    public String baseUri() {\n        return searchUpForAttribute(this, BaseUriKey);\n    }\n\n    private static String searchUpForAttribute(final Element start, final String key) {\n        Element el = start;\n        while (el != null) {\n            if (el.attributes != null && el.attributes.hasKey(key))\n                return el.attributes.get(key);\n            el = el.parent();\n        }\n        return \"\";\n    }\n\n    @Override\n    protected void doSetBaseUri(String baseUri) {\n        attributes().put(BaseUriKey, baseUri);\n    }\n\n    @Override\n    public int childNodeSize() {\n        return childNodes.size();\n    }\n\n    @Override\n    public String nodeName() {\n        return tag.getName();\n    }\n\n    /**\n     * Get the name of the tag for this element. E.g. {@code div}. If you are using {@link ParseSettings#preserveCase\n     * case preserving parsing}, this will return the source's original case.\n     *\n     * @return the tag name\n     */\n    public String tagName() {\n        return tag.getName();\n    }\n\n    /**\n     * Get the normalized name of this Element's tag. This will always be the lower-cased version of the tag, regardless\n     * of the tag case preserving setting of the parser. For e.g., {@code <DIV>} and {@code <div>} both have a\n     * normal name of {@code div}.\n     * @return normal name\n     */\n    @Override\n    public String normalName() {\n        return tag.normalName();\n    }\n\n    /**\n     Test if this Element has the specified normalized name, and is in the specified namespace.\n     * @param normalName a normalized element name (e.g. {@code div}).\n     * @param namespace the namespace\n     * @return true if the element's normal name matches exactly, and is in the specified namespace\n     * @since 1.17.2\n     */\n    public boolean elementIs(String normalName, String namespace) {\n        return tag.normalName().equals(normalName) && tag.namespace().equals(namespace);\n    }\n\n    /**\n     * Change (rename) the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n     * {@code el.tagName(\"div\");}.\n     *\n     * @param tagName new tag name for this element\n     * @return this element, for chaining\n     * @see Elements#tagName(String)\n     */\n    public Element tagName(String tagName) {\n        return tagName(tagName, tag.namespace());\n    }\n\n    /**\n     * Change (rename) the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with\n     * {@code el.tagName(\"div\");}.\n     *\n     * @param tagName new tag name for this element\n     * @param namespace the new namespace for this element\n     * @return this element, for chaining\n     * @see Elements#tagName(String)\n     */\n    public Element tagName(String tagName, String namespace) {\n        Validate.notEmptyParam(tagName, \"tagName\");\n        Validate.notEmptyParam(namespace, \"namespace\");\n        tag = Tag.valueOf(tagName, namespace, NodeUtils.parser(this).settings()); // maintains the case option of the original parse\n        return this;\n    }\n\n    /**\n     * Get the Tag for this element.\n     *\n     * @return the tag object\n     */\n    public Tag tag() {\n        return tag;\n    }\n\n    /**\n     * Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element\n     * {@code <span> == false}).\n     *\n     * @return true if block, false if not (and thus inline)\n     */\n    public boolean isBlock() {\n        return tag.isBlock();\n    }\n\n    /**\n     * Get the {@code id} attribute of this element.\n     *\n     * @return The id attribute, if present, or an empty string if not.\n     */\n    public String id() {\n        return attributes != null ? attributes.getIgnoreCase(\"id\") :\"\";\n    }\n\n    /**\n     Set the {@code id} attribute of this element.\n     @param id the ID value to use\n     @return this Element, for chaining\n     */\n    public Element id(String id) {\n        Validate.notNull(id);\n        attr(\"id\", id);\n        return this;\n    }\n\n    /**\n     * Set an attribute value on this element. If this element already has an attribute with the\n     * key, its value is updated; otherwise, a new attribute is added.\n     *\n     * @return this element\n     */\n    @Override public Element attr(String attributeKey, String attributeValue) {\n        super.attr(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to \"\" and\n     * marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute\n     * with the same key if it exists.\n     *\n     * @param attributeKey the attribute key\n     * @param attributeValue the attribute value\n     *\n     * @return this element\n     */\n    public Element attr(String attributeKey, boolean attributeValue) {\n        attributes().put(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     Get an Attribute by key. Changes made via {@link Attribute#setKey(String)}, {@link Attribute#setValue(String)} etc\n     will cascade back to this Element.\n     @param key the (case-sensitive) attribute key\n     @return the Attribute for this key, or null if not present.\n     @since 1.17.2\n     */\n    @Nullable public Attribute attribute(String key) {\n        return hasAttributes() ? attributes().attribute(key) : null;\n    }\n\n    /**\n     * Get this element's HTML5 custom data attributes. Each attribute in the element that has a key\n     * starting with \"data-\" is included the dataset.\n     * <p>\n     * E.g., the element {@code <div data-package=\"jsoup\" data-language=\"Java\" class=\"group\">...} has the dataset\n     * {@code package=jsoup, language=java}.\n     * <p>\n     * This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected\n     * in the other map.\n     * <p>\n     * You can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.\n     * @return a map of {@code key=value} custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return attributes().dataset();\n    }\n\n    @Override @Nullable\n    public final Element parent() {\n        return (Element) parentNode;\n    }\n\n    /**\n     * Get this element's parent and ancestors, up to the document root.\n     * @return this element's stack of parents, starting with the closest first.\n     */\n    public Elements parents() {\n        Elements parents = new Elements();\n        Element parent = this.parent();\n        while (parent != null && !parent.nameIs(\"#root\")) {\n            parents.add(parent);\n            parent = parent.parent();\n        }\n        return parents;\n    }\n\n    /**\n     * Get a child element of this element, by its 0-based index number.\n     * <p>\n     * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n     * a filtered list of children that are elements, and the index is based on that filtered list.\n     * </p>\n     *\n     * @param index the index number of the element to retrieve\n     * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n     * @see #childNode(int)\n     */\n    public Element child(int index) {\n        return childElementsList().get(index);\n    }\n\n    /**\n     * Get the number of child nodes of this element that are elements.\n     * <p>\n     * This method works on the same filtered list like {@link #child(int)}. Use {@link #childNodes()} and {@link\n     * #childNodeSize()} to get the unfiltered Nodes (e.g. includes TextNodes etc.)\n     * </p>\n     *\n     * @return the number of child nodes that are elements\n     * @see #children()\n     * @see #child(int)\n     */\n    public int childrenSize() {\n        return childElementsList().size();\n    }\n\n    /**\n     * Get this element's child elements.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n     * </p>\n     * @return child elements. If this element has no children, returns an empty list.\n     * @see #childNodes()\n     */\n    public Elements children() {\n        return new Elements(childElementsList());\n    }\n\n    /**\n     * Maintains a shadow copy of this element's child elements. If the nodelist is changed, this cache is invalidated.\n     * TODO - think about pulling this out as a helper as there are other shadow lists (like in Attributes) kept around.\n     * @return a list of child elements\n     */\n    List<Element> childElementsList() {\n        if (childNodeSize() == 0)\n            return EmptyChildren; // short circuit creating empty\n\n        List<Element> children;\n        if (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\n            final int size = childNodes.size();\n            children = new ArrayList<>(size);\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i = 0; i < size; i++) {\n                final Node node = childNodes.get(i);\n                if (node instanceof Element)\n                    children.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n        return children;\n    }\n\n    /**\n     * Clears the cached shadow child elements.\n     */\n    @Override\n    void nodelistChanged() {\n        super.nodelistChanged();\n        shadowChildrenRef = null;\n    }\n\n    /**\n     Returns a Stream of this Element and all of its descendant Elements. The stream has document order.\n     @return a stream of this element and its descendants.\n     @see #nodeStream()\n     @since 1.17.1\n     */\n    public Stream<Element> stream() {\n        return NodeUtils.stream(this, Element.class);\n    }\n\n    private <T> List<T> filterNodes(Class<T> clazz) {\n        return childNodes.stream()\n                .filter(clazz::isInstance)\n                .map(clazz::cast)\n                .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));\n    }\n\n    /**\n     * Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Text nodes.\n     * @return child text nodes. If this element has no text nodes, returns an\n     * empty list.\n     * </p>\n     * For example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:\n     * <ul>\n     *     <li>{@code p.text()} = {@code \"One Two Three Four\"}</li>\n     *     <li>{@code p.ownText()} = {@code \"One Three Four\"}</li>\n     *     <li>{@code p.children()} = {@code Elements[<span>, <br>]}</li>\n     *     <li>{@code p.childNodes()} = {@code List<Node>[\"One \", <span>, \" Three \", <br>, \" Four\"]}</li>\n     *     <li>{@code p.textNodes()} = {@code List<TextNode>[\"One \", \" Three \", \" Four\"]}</li>\n     * </ul>\n     */\n    public List<TextNode> textNodes() {\n        return filterNodes(TextNode.class);\n    }\n\n    /**\n     * Get this element's child data nodes. The list is unmodifiable but the data nodes may be manipulated.\n     * <p>\n     * This is effectively a filter on {@link #childNodes()} to get Data nodes.\n     * </p>\n     * @return child data nodes. If this element has no data nodes, returns an\n     * empty list.\n     * @see #data()\n     */\n    public List<DataNode> dataNodes() {\n        return filterNodes(DataNode.class);\n    }\n\n    /**\n     * Find elements that match the {@link Selector} CSS query, with this element as the starting context. Matched elements\n     * may include this element, or any of its children.\n     * <p>This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because\n     * multiple filters can be combined, e.g.:</p>\n     * <ul>\n     * <li>{@code el.select(\"a[href]\")} - finds links ({@code a} tags with {@code href} attributes)\n     * <li>{@code el.select(\"a[href*=example.com]\")} - finds links pointing to example.com (loosely)\n     * </ul>\n     * <p>See the query syntax documentation in {@link org.jsoup.select.Selector}.</p>\n     * <p>Also known as {@code querySelectorAll()} in the Web DOM.</p>\n     *\n     * @param cssQuery a {@link Selector} CSS-like query\n     * @return an {@link Elements} list containing elements that match the query (empty if none match)\n     * @see Selector selector query syntax\n     * @see QueryParser#parse(String)\n     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.\n     */\n    public Elements select(String cssQuery) {\n        return Selector.select(cssQuery, this);\n    }\n\n    /**\n     * Find elements that match the supplied Evaluator. This has the same functionality as {@link #select(String)}, but\n     * may be useful if you are running the same query many times (on many documents) and want to save the overhead of\n     * repeatedly parsing the CSS query.\n     * @param evaluator an element evaluator\n     * @return an {@link Elements} list containing elements that match the query (empty if none match)\n     */\n    public Elements select(Evaluator evaluator) {\n        return Selector.select(evaluator, this);\n    }\n\n    /**\n     * Find the first Element that matches the {@link Selector} CSS query, with this element as the starting context.\n     * <p>This is effectively the same as calling {@code element.select(query).first()}, but is more efficient as query\n     * execution stops on the first hit.</p>\n     * <p>Also known as {@code querySelector()} in the Web DOM.</p>\n     * @param cssQuery cssQuery a {@link Selector} CSS-like query\n     * @return the first matching element, or <b>{@code null}</b> if there is no match.\n     * @see #expectFirst(String)\n     */\n    public @Nullable Element selectFirst(String cssQuery) {\n        return Selector.selectFirst(cssQuery, this);\n    }\n\n    /**\n     * Finds the first Element that matches the supplied Evaluator, with this element as the starting context, or\n     * {@code null} if none match.\n     *\n     * @param evaluator an element evaluator\n     * @return the first matching element (walking down the tree, starting from this element), or {@code null} if none\n     * match.\n     */\n    public @Nullable Element selectFirst(Evaluator evaluator) {\n        return Collector.findFirst(evaluator, this);\n    }\n\n    /**\n     Just like {@link #selectFirst(String)}, but if there is no match, throws an {@link IllegalArgumentException}. This\n     is useful if you want to simply abort processing on a failed match.\n     @param cssQuery a {@link Selector} CSS-like query\n     @return the first matching element\n     @throws IllegalArgumentException if no match is found\n     @since 1.15.2\n     */\n    public Element expectFirst(String cssQuery) {\n        return (Element) Validate.ensureNotNull(\n            Selector.selectFirst(cssQuery, this),\n            parent() != null ?\n                \"No elements matched the query '%s' on element '%s'.\":\n                \"No elements matched the query '%s' in the document.\"\n            , cssQuery, this.tagName()\n        );\n    }\n\n    /**\n     * Checks if this element matches the given {@link Selector} CSS query. Also knows as {@code matches()} in the Web\n     * DOM.\n     *\n     * @param cssQuery a {@link Selector} CSS query\n     * @return if this element matches the query\n     */\n    public boolean is(String cssQuery) {\n        return is(QueryParser.parse(cssQuery));\n    }\n\n    /**\n     * Check if this element matches the given evaluator.\n     * @param evaluator an element evaluator\n     * @return if this element matches\n     */\n    public boolean is(Evaluator evaluator) {\n        return evaluator.matches(this.root(), this);\n    }\n\n    /**\n     * Find the closest element up the tree of parents that matches the specified CSS query. Will return itself, an\n     * ancestor, or {@code null} if there is no such matching element.\n     * @param cssQuery a {@link Selector} CSS query\n     * @return the closest ancestor element (possibly itself) that matches the provided evaluator. {@code null} if not\n     * found.\n     */\n    public @Nullable Element closest(String cssQuery) {\n        return closest(QueryParser.parse(cssQuery));\n    }\n\n    /**\n     * Find the closest element up the tree of parents that matches the specified evaluator. Will return itself, an\n     * ancestor, or {@code null} if there is no such matching element.\n     * @param evaluator a query evaluator\n     * @return the closest ancestor element (possibly itself) that matches the provided evaluator. {@code null} if not\n     * found.\n     */\n    public @Nullable Element closest(Evaluator evaluator) {\n        Validate.notNull(evaluator);\n        Element el = this;\n        final Element root = root();\n        do {\n            if (evaluator.matches(root, el))\n                return el;\n            el = el.parent();\n        } while (el != null);\n        return null;\n    }\n\n    /**\n     Find Elements that match the supplied {@index XPath} expression.\n     <p>Note that for convenience of writing the Xpath expression, namespaces are disabled, and queries can be\n     expressed using the element's local name only.</p>\n     <p>By default, XPath 1.0 expressions are supported. If you would to use XPath 2.0 or higher, you can provide an\n     alternate XPathFactory implementation:</p>\n     <ol>\n     <li>Add the implementation to your classpath. E.g. to use <a href=\"https://www.saxonica.com/products/products.xml\">Saxon-HE</a>, add <a href=\"https://mvnrepository.com/artifact/net.sf.saxon/Saxon-HE\">net.sf.saxon:Saxon-HE</a> to your build.</li>\n     <li>Set the system property <code>javax.xml.xpath.XPathFactory:jsoup</code> to the implementing classname. E.g.:<br>\n     <code>System.setProperty(W3CDom.XPathFactoryProperty, \"net.sf.saxon.xpath.XPathFactoryImpl\");</code>\n     </li>\n     </ol>\n\n     @param xpath XPath expression\n     @return matching elements, or an empty list if none match.\n     @see #selectXpath(String, Class)\n     @since 1.14.3\n     */\n    public Elements selectXpath(String xpath) {\n        return new Elements(NodeUtils.selectXpath(xpath, this, Element.class));\n    }\n\n    /**\n     Find Nodes that match the supplied XPath expression.\n     <p>For example, to select TextNodes under {@code p} elements: </p>\n     <pre>List&lt;TextNode&gt; textNodes = doc.selectXpath(\"//body//p//text()\", TextNode.class);</pre>\n     <p>Note that in the jsoup DOM, Attribute objects are not Nodes. To directly select attribute values, do something\n     like:</p>\n     <pre>List&lt;String&gt; hrefs = doc.selectXpath(\"//a\").eachAttr(\"href\");</pre>\n     @param xpath XPath expression\n     @param nodeType the jsoup node type to return\n     @see #selectXpath(String)\n     @return a list of matching nodes\n     @since 1.14.3\n     */\n    public <T extends Node> List<T> selectXpath(String xpath, Class<T> nodeType) {\n        return NodeUtils.selectXpath(xpath, this, nodeType);\n    }\n\n    /**\n     * Insert a node to the end of this Element's children. The incoming node will be re-parented.\n     *\n     * @param child node to add.\n     * @return this Element, for chaining\n     * @see #prependChild(Node)\n     * @see #insertChildren(int, Collection)\n     */\n    public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        // was - Node#addChildren(child). short-circuits an array create and a loop.\n        reparentChild(child);\n        ensureChildNodes();\n        childNodes.add(child);\n        child.setSiblingIndex(childNodes.size() - 1);\n        return this;\n    }\n\n    /**\n     Insert the given nodes to the end of this Element's children.\n\n     @param children nodes to add\n     @return this Element, for chaining\n     @see #insertChildren(int, Collection)\n     */\n    public Element appendChildren(Collection<? extends Node> children) {\n        insertChildren(-1, children);\n        return this;\n    }\n\n    /**\n     * Add this element to the supplied parent element, as its next child.\n     *\n     * @param parent element to which this element will be appended\n     * @return this element, so that you can continue modifying the element\n     */\n    public Element appendTo(Element parent) {\n        Validate.notNull(parent);\n        parent.appendChild(this);\n        return this;\n    }\n\n    /**\n     * Add a node to the start of this element's children.\n     *\n     * @param child node to add.\n     * @return this element, so that you can add more child nodes or elements.\n     */\n    public Element prependChild(Node child) {\n        Validate.notNull(child);\n\n        addChildren(0, child);\n        return this;\n    }\n\n    /**\n     Insert the given nodes to the start of this Element's children.\n\n     @param children nodes to add\n     @return this Element, for chaining\n     @see #insertChildren(int, Collection)\n     */\n    public Element prependChildren(Collection<? extends Node> children) {\n        insertChildren(0, children);\n        return this;\n    }\n\n\n    /**\n     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n     *\n     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n     * end\n     * @param children child nodes to insert\n     * @return this element, for chaining.\n     */\n    public Element insertChildren(int index, Collection<? extends Node> children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        ArrayList<Node> nodes = new ArrayList<>(children);\n        Node[] nodeArray = nodes.toArray(new Node[0]);\n        addChildren(index, nodeArray);\n        return this;\n    }\n\n    /**\n     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n     *\n     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n     * end\n     * @param children child nodes to insert\n     * @return this element, for chaining.\n     */\n    public Element insertChildren(int index, Node... children) {\n        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n        int currentSize = childNodeSize();\n        if (index < 0) index += currentSize +1; // roll around\n        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n\n        addChildren(index, children);\n        return this;\n    }\n\n    /**\n     * Create a new element by tag name, and add it as this Element's last child.\n     *\n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     */\n    public Element appendElement(String tagName) {\n        return appendElement(tagName, tag.namespace());\n    }\n\n    /**\n     * Create a new element by tag name and namespace, add it as this Element's last child.\n     *\n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @param namespace the namespace of the tag (e.g. {@link Parser#NamespaceHtml})\n     * @return the new element, in the specified namespace\n     */\n    public Element appendElement(String tagName, String namespace) {\n        Element child = new Element(Tag.valueOf(tagName, namespace, NodeUtils.parser(this).settings()), baseUri());\n        appendChild(child);\n        return child;\n    }\n\n    /**\n     * Create a new element by tag name, and add it as this Element's first child.\n     *\n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @return the new element, to allow you to add content to it, e.g.:\n     *  {@code parent.prependElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n     */\n    public Element prependElement(String tagName) {\n        return prependElement(tagName, tag.namespace());\n    }\n\n    /**\n     * Create a new element by tag name and namespace, and add it as this Element's first child.\n     *\n     * @param tagName the name of the tag (e.g. {@code div}).\n     * @param namespace the namespace of the tag (e.g. {@link Parser#NamespaceHtml})\n     * @return the new element, in the specified namespace\n     */\n    public Element prependElement(String tagName, String namespace) {\n        Element child = new Element(Tag.valueOf(tagName, namespace, NodeUtils.parser(this).settings()), baseUri());\n        prependChild(child);\n        return child;\n    }\n\n    /**\n     * Create and append a new TextNode to this element.\n     *\n     * @param text the (un-encoded) text to add\n     * @return this element\n     */\n    public Element appendText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        appendChild(node);\n        return this;\n    }\n\n    /**\n     * Create and prepend a new TextNode to this element.\n     *\n     * @param text the decoded text to add\n     * @return this element\n     */\n    public Element prependText(String text) {\n        Validate.notNull(text);\n        TextNode node = new TextNode(text);\n        prependChild(node);\n        return this;\n    }\n\n    /**\n     * Add inner HTML to this element. The supplied HTML will be parsed, and each node appended to the end of the children.\n     * @param html HTML to add inside this element, after the existing HTML\n     * @return this element\n     * @see #html(String)\n     */\n    public Element append(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(nodes.toArray(new Node[0]));\n        return this;\n    }\n\n    /**\n     * Add inner HTML into this element. The supplied HTML will be parsed, and each node prepended to the start of the element's children.\n     * @param html HTML to add inside this element, before the existing HTML\n     * @return this element\n     * @see #html(String)\n     */\n    public Element prepend(String html) {\n        Validate.notNull(html);\n        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());\n        addChildren(0, nodes.toArray(new Node[0]));\n        return this;\n    }\n\n    /**\n     * Insert the specified HTML into the DOM before this element (as a preceding sibling).\n     *\n     * @param html HTML to add before this element\n     * @return this element, for chaining\n     * @see #after(String)\n     */\n    @Override\n    public Element before(String html) {\n        return (Element) super.before(html);\n    }\n\n    /**\n     * Insert the specified node into the DOM before this node (as a preceding sibling).\n     * @param node to add before this element\n     * @return this Element, for chaining\n     * @see #after(Node)\n     */\n    @Override\n    public Element before(Node node) {\n        return (Element) super.before(node);\n    }\n\n    /**\n     * Insert the specified HTML into the DOM after this element (as a following sibling).\n     *\n     * @param html HTML to add after this element\n     * @return this element, for chaining\n     * @see #before(String)\n     */\n    @Override\n    public Element after(String html) {\n        return (Element) super.after(html);\n    }\n\n    /**\n     * Insert the specified node into the DOM after this node (as a following sibling).\n     * @param node to add after this element\n     * @return this element, for chaining\n     * @see #before(Node)\n     */\n    @Override\n    public Element after(Node node) {\n        return (Element) super.after(node);\n    }\n\n    /**\n     * Remove all the element's child nodes. Any attributes are left as-is. Each child node has its parent set to\n     * {@code null}.\n     * @return this element\n     */\n    @Override\n    public Element empty() {\n        // Detach each of the children -> parent links:\n        for (Node child : childNodes) {\n            child.parentNode = null;\n        }\n        childNodes.clear();\n        return this;\n    }\n\n    /**\n     * Wrap the supplied HTML around this element.\n     *\n     * @param html HTML to wrap around this element, e.g. {@code <div class=\"head\"></div>}. Can be arbitrarily deep.\n     * @return this element, for chaining.\n     */\n    @Override\n    public Element wrap(String html) {\n        return (Element) super.wrap(html);\n    }\n\n    /**\n     * Get a CSS selector that will uniquely select this element.\n     * <p>\n     * If the element has an ID, returns #id;\n     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n     * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n     * </p>\n     *\n     * @return the CSS Path that can be used to retrieve the element in a selector.\n     */\n    public String cssSelector() {\n        if (id().length() > 0) {\n            // prefer to return the ID - but check that it's actually unique first!\n            String idSel = \"#\" + escapeCssIdentifier(id());\n            Document doc = ownerDocument();\n            if (doc != null) {\n                Elements els = doc.select(idSel);\n                if (els.size() == 1 && els.get(0) == this) // otherwise, continue to the nth-child impl\n                    return idSel;\n            } else {\n                return idSel; // no ownerdoc, return the ID selector\n            }\n        }\n\n        StringBuilder selector = StringUtil.borrowBuilder();\n        Element el = this;\n        while (el != null && !(el instanceof Document)) {\n            selector.insert(0, el.cssSelectorComponent());\n            el = el.parent();\n        }\n        return StringUtil.releaseBuilder(selector);\n    }\n\n    private String cssSelectorComponent() {\n        // Escape tagname, and translate HTML namespace ns:tag to CSS namespace syntax ns|tag\n        String tagName = escapeCssIdentifier(tagName()).replace(\"\\\\:\", \"|\");\n        StringBuilder selector = StringUtil.borrowBuilder().append(tagName);\n        String classes = classNames().stream().map(TokenQueue::escapeCssIdentifier)\n                .collect(StringUtil.joining(\".\"));\n        if (!classes.isEmpty())\n            selector.append('.').append(classes);\n\n        if (parent() == null || parent() instanceof Document) // don't add Document to selector, as will always have a html node\n            return StringUtil.releaseBuilder(selector);\n\n        selector.insert(0, \" > \");\n        if (parent().select(selector.toString()).size() > 1)\n            selector.append(String.format(\n                \":nth-child(%d)\", elementSiblingIndex() + 1));\n\n        return StringUtil.releaseBuilder(selector);\n    }\n\n    /**\n     * Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling\n     * of itself, so will not be included in the returned list.\n     * @return sibling elements\n     */\n    public Elements siblingElements() {\n        if (parentNode == null)\n            return new Elements(0);\n\n        List<Element> elements = parent().childElementsList();\n        Elements siblings = new Elements(elements.size() - 1);\n        for (Element el: elements)\n            if (el != this)\n                siblings.add(el);\n        return siblings;\n    }\n\n    /**\n     * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s,\n     * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n     * <p>\n     * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n     * </p>\n     * @return the next element, or null if there is no next element\n     * @see #previousElementSibling()\n     */\n    public @Nullable Element nextElementSibling() {\n        Node next = this;\n        while ((next = next.nextSibling()) != null) {\n            if (next instanceof Element) return (Element) next;\n        }\n        return null;\n    }\n\n    /**\n     * Get each of the sibling elements that come after this element.\n     *\n     * @return each of the element siblings after this element, or an empty list if there are no next sibling elements\n     */\n    public Elements nextElementSiblings() {\n        return nextElementSiblings(true);\n    }\n\n    /**\n     * Gets the previous element sibling of this element.\n     * @return the previous element, or null if there is no previous element\n     * @see #nextElementSibling()\n     */\n    public @Nullable Element previousElementSibling() {\n        Node prev = this;\n        while ((prev = prev.previousSibling()) != null) {\n            if (prev instanceof Element) return (Element) prev;\n        }\n        return null;\n    }\n\n    /**\n     * Get each of the element siblings before this element.\n     *\n     * @return the previous element siblings, or an empty list if there are none.\n     */\n    public Elements previousElementSiblings() {\n        return nextElementSiblings(false);\n    }\n\n    private Elements nextElementSiblings(boolean next) {\n        Elements els = new Elements();\n        if (parentNode == null)\n            return  els;\n        els.add(this);\n        return next ?  els.nextAll() : els.prevAll();\n    }\n\n    /**\n     * Gets the first Element sibling of this element. That may be this element.\n     * @return the first sibling that is an element (aka the parent's first element child)\n     */\n    public Element firstElementSibling() {\n        if (parent() != null) {\n            //noinspection DataFlowIssue (not nullable, would be this is no other sibs)\n            return parent().firstElementChild();\n        } else\n            return this; // orphan is its own first sibling\n    }\n\n    /**\n     * Get the list index of this element in its element sibling list. I.e. if this is the first element\n     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public int elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().childElementsList());\n    }\n\n    /**\n     * Gets the last element sibling of this element. That may be this element.\n     * @return the last sibling that is an element (aka the parent's last element child)\n     */\n    public Element lastElementSibling() {\n        if (parent() != null) {\n            //noinspection DataFlowIssue (not nullable, would be this if no other sibs)\n            return parent().lastElementChild();\n        } else\n            return this;\n    }\n\n    private static <E extends Element> int indexInList(Element search, List<E> elements) {\n        final int size = elements.size();\n        for (int i = 0; i < size; i++) {\n            if (elements.get(i) == search)\n                return i;\n        }\n        return 0;\n    }\n\n    /**\n     Gets the first child of this Element that is an Element, or {@code null} if there is none.\n     @return the first Element child node, or null.\n     @see #firstChild()\n     @see #lastElementChild()\n     @since 1.15.2\n     */\n    public @Nullable Element firstElementChild() {\n        Node child = firstChild();\n        while (child != null) {\n            if (child instanceof Element) return (Element) child;\n            child = child.nextSibling();\n        }\n        return null;\n    }\n\n    /**\n     Gets the last child of this Element that is an Element, or @{code null} if there is none.\n     @return the last Element child node, or null.\n     @see #lastChild()\n     @see #firstElementChild()\n     @since 1.15.2\n     */\n    public @Nullable Element lastElementChild() {\n        Node child = lastChild();\n        while (child != null) {\n            if (child instanceof Element) return (Element) child;\n            child = child.previousSibling();\n        }\n        return null;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = normalize(tagName);\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n     * starting point, it is possible to find a different element by ID. For unique element by ID within a Document,\n     * use {@link Document#getElementById(String)}\n     * @param id The ID to search for.\n     * @return The first matching element by ID, starting with this element, or null if none found.\n     */\n    public @Nullable Element getElementById(String id) {\n        Validate.notEmpty(id);\n\n        Elements elements = Collector.collect(new Evaluator.Id(id), this);\n        if (elements.size() > 0)\n            return elements.get(0);\n        else\n            return null;\n    }\n\n    /**\n     * Find elements that have this class, including or under this element. Case-insensitive.\n     * <p>\n     * Elements can have multiple classes (e.g. {@code <div class=\"header round first\">}). This method\n     * checks each class, so you can find the above with {@code el.getElementsByClass(\"header\");}.\n     *\n     * @param className the name of the class to search for.\n     * @return elements with the supplied class name, empty if none\n     * @see #hasClass(String)\n     * @see #classNames()\n     */\n    public Elements getElementsByClass(String className) {\n        Validate.notEmpty(className);\n\n        return Collector.collect(new Evaluator.Class(className), this);\n    }\n\n    /**\n     * Find elements that have a named attribute set. Case-insensitive.\n     *\n     * @param key name of the attribute, e.g. {@code href}\n     * @return elements that have this attribute, empty if none\n     */\n    public Elements getElementsByAttribute(String key) {\n        Validate.notEmpty(key);\n        key = key.trim();\n\n        return Collector.collect(new Evaluator.Attribute(key), this);\n    }\n\n    /**\n     * Find elements that have an attribute name starting with the supplied prefix. Use {@code data-} to find elements\n     * that have HTML5 datasets.\n     * @param keyPrefix name prefix of the attribute e.g. {@code data-}\n     * @return elements that have attribute names that start with the prefix, empty if none.\n     */\n    public Elements getElementsByAttributeStarting(String keyPrefix) {\n        Validate.notEmpty(keyPrefix);\n        keyPrefix = keyPrefix.trim();\n\n        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n    }\n\n    /**\n     * Find elements that have an attribute with the specific value. Case-insensitive.\n     *\n     * @param key name of the attribute\n     * @param value value of the attribute\n     * @return elements that have this attribute with this value, empty if none\n     */\n    public Elements getElementsByAttributeValue(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);\n    }\n\n    /**\n     * Find elements that either do not have this attribute, or have it with a different value. Case-insensitive.\n     *\n     * @param key name of the attribute\n     * @param value value of the attribute\n     * @return elements that do not have a matching attribute\n     */\n    public Elements getElementsByAttributeValueNot(String key, String value) {\n        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);\n    }\n\n    /**\n     * Find elements that have attributes that start with the value prefix. Case-insensitive.\n     *\n     * @param key name of the attribute\n     * @param valuePrefix start of attribute value\n     * @return elements that have attributes that start with the value prefix\n     */\n    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);\n    }\n\n    /**\n     * Find elements that have attributes that end with the value suffix. Case-insensitive.\n     *\n     * @param key name of the attribute\n     * @param valueSuffix end of the attribute value\n     * @return elements that have attributes that end with the value suffix\n     */\n    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);\n    }\n\n    /**\n     * Find elements that have attributes whose value contains the match string. Case-insensitive.\n     *\n     * @param key name of the attribute\n     * @param match substring of value to search for\n     * @return elements that have attributes containing this text\n     */\n    public Elements getElementsByAttributeValueContaining(String key, String match) {\n        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);\n    }\n\n    /**\n     * Find elements that have an attribute whose value matches the supplied regular expression.\n     * @param key name of the attribute\n     * @param pattern compiled regular expression to match against attribute values\n     * @return elements that have attributes matching this regular expression\n     */\n    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {\n        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);\n\n    }\n\n    /**\n     * Find elements that have attributes whose values match the supplied regular expression.\n     * @param key name of the attribute\n     * @param regex regular expression to match against attribute values. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as {@code (?i)} and {@code (?m)}) to control regex options.\n     * @return elements that have attributes matching this regular expression\n     */\n    public Elements getElementsByAttributeValueMatching(String key, String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsByAttributeValueMatching(key, pattern);\n    }\n\n    /**\n     * Find elements whose sibling index is less than the supplied index.\n     * @param index 0-based index\n     * @return elements less than index\n     */\n    public Elements getElementsByIndexLessThan(int index) {\n        return Collector.collect(new Evaluator.IndexLessThan(index), this);\n    }\n\n    /**\n     * Find elements whose sibling index is greater than the supplied index.\n     * @param index 0-based index\n     * @return elements greater than index\n     */\n    public Elements getElementsByIndexGreaterThan(int index) {\n        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);\n    }\n\n    /**\n     * Find elements whose sibling index is equal to the supplied index.\n     * @param index 0-based index\n     * @return elements equal to index\n     */\n    public Elements getElementsByIndexEquals(int index) {\n        return Collector.collect(new Evaluator.IndexEquals(index), this);\n    }\n\n    /**\n     * Find elements that contain the specified string. The search is case-insensitive. The text may appear directly\n     * in the element, or in any of its descendants.\n     * @param searchText to look for in the element's text\n     * @return elements that contain the string, case-insensitive.\n     * @see Element#text()\n     */\n    public Elements getElementsContainingText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsText(searchText), this);\n    }\n\n    /**\n     * Find elements that directly contain the specified string. The search is case-insensitive. The text must appear directly\n     * in the element, not in any of its descendants.\n     * @param searchText to look for in the element's own text\n     * @return elements that contain the string, case-insensitive.\n     * @see Element#ownText()\n     */\n    public Elements getElementsContainingOwnText(String searchText) {\n        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);\n    }\n\n    /**\n     * Find elements whose text matches the supplied regular expression.\n     * @param pattern regular expression to match text against\n     * @return elements matching the supplied regular expression.\n     * @see Element#text()\n     */\n    public Elements getElementsMatchingText(Pattern pattern) {\n        return Collector.collect(new Evaluator.Matches(pattern), this);\n    }\n\n    /**\n     * Find elements whose text matches the supplied regular expression.\n     * @param regex regular expression to match text against. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as {@code (?i)} and {@code (?m)}) to control regex options.\n     * @return elements matching the supplied regular expression.\n     * @see Element#text()\n     */\n    public Elements getElementsMatchingText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingText(pattern);\n    }\n\n    /**\n     * Find elements whose own text matches the supplied regular expression.\n     * @param pattern regular expression to match text against\n     * @return elements matching the supplied regular expression.\n     * @see Element#ownText()\n     */\n    public Elements getElementsMatchingOwnText(Pattern pattern) {\n        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);\n    }\n\n    /**\n     * Find elements whose own text matches the supplied regular expression.\n     * @param regex regular expression to match text against. You can use <a href=\"http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html#embedded\">embedded flags</a> (such as {@code (?i)} and {@code (?m)}) to control regex options.\n     * @return elements matching the supplied regular expression.\n     * @see Element#ownText()\n     */\n    public Elements getElementsMatchingOwnText(String regex) {\n        Pattern pattern;\n        try {\n            pattern = Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new IllegalArgumentException(\"Pattern syntax error: \" + regex, e);\n        }\n        return getElementsMatchingOwnText(pattern);\n    }\n\n    /**\n     * Find all elements under this element (including self, and children of children).\n     *\n     * @return all elements\n     */\n    public Elements getAllElements() {\n        return Collector.collect(new Evaluator.AllElements(), this);\n    }\n\n    /**\n     Gets the <b>normalized, combined text</b> of this element and all its children. Whitespace is normalized and\n     trimmed.\n     <p>For example, given HTML {@code <p>Hello  <b>there</b> now! </p>}, {@code p.text()} returns {@code \"Hello there\n    now!\"}\n     <p>If you do not want normalized text, use {@link #wholeText()}. If you want just the text of this node (and not\n     children), use {@link #ownText()}\n     <p>Note that this method returns the textual content that would be presented to a reader. The contents of data\n     nodes (such as {@code <script>} tags) are not considered text. Use {@link #data()} or {@link #html()} to retrieve\n     that content.\n\n     @return decoded, normalized text, or empty string if none.\n     @see #wholeText()\n     @see #ownText()\n     @see #textNodes()\n     */\n    public String text() {\n        final StringBuilder accum = StringUtil.borrowBuilder();\n        NodeTraversor.traverse(new TextAccumulator(accum), this);\n        return StringUtil.releaseBuilder(accum).trim();\n    }\n\n    private static class TextAccumulator implements NodeVisitor {\n        private final StringBuilder accum;\n\n        public TextAccumulator(StringBuilder accum) {\n            this.accum = accum;\n        }\n\n        @Override public void head(Node node, int depth) {\n            if (node instanceof TextNode) {\n                TextNode textNode = (TextNode) node;\n                appendNormalisedText(accum, textNode);\n            } else if (node instanceof Element) {\n                Element element = (Element) node;\n                if (accum.length() > 0 &&\n                    (element.isBlock() || element.nameIs(\"br\")) &&\n                    !lastCharIsWhitespace(accum))\n                    accum.append(' ');\n            }\n        }\n\n        @Override public void tail(Node node, int depth) {\n            // make sure there is a space between block tags and immediately following text nodes or inline elements <div>One</div>Two should be \"One Two\".\n            if (node instanceof Element) {\n                Element element = (Element) node;\n                Node next = node.nextSibling();\n                if (element.isBlock() && (next instanceof TextNode || next instanceof Element && !((Element) next).tag.formatAsBlock()) && !lastCharIsWhitespace(accum))\n                    accum.append(' ');\n            }\n\n        }\n    }\n\n    /**\n     Get the non-normalized, decoded text of this element and its children, including only any newlines and spaces\n     present in the original source.\n     @return decoded, non-normalized text\n     @see #text()\n     @see #wholeOwnText()\n     */\n    public String wholeText() {\n        return wholeTextOf(nodeStream());\n    }\n\n    private static String wholeTextOf(Stream<Node> stream) {\n        return stream.map(node -> {\n            if (node instanceof TextNode) return ((TextNode) node).getWholeText();\n            if (node.nameIs(\"br\")) return \"\\n\";\n            return \"\";\n        }).collect(StringUtil.joining(\"\"));\n    }\n\n    /**\n     Get the non-normalized, decoded text of this element, <b>not including</b> any child elements, including any\n     newlines and spaces present in the original source.\n     @return decoded, non-normalized text that is a direct child of this Element\n     @see #text()\n     @see #wholeText()\n     @see #ownText()\n     @since 1.15.1\n     */\n    public String wholeOwnText() {\n        return wholeTextOf(childNodes.stream());\n    }\n\n    /**\n     * Gets the (normalized) text owned by this element only; does not get the combined text of all children.\n     * <p>\n     * For example, given HTML {@code <p>Hello <b>there</b> now!</p>}, {@code p.ownText()} returns {@code \"Hello now!\"},\n     * whereas {@code p.text()} returns {@code \"Hello there now!\"}.\n     * Note that the text within the {@code b} element is not returned, as it is not a direct child of the {@code p} element.\n     *\n     * @return decoded text, or empty string if none.\n     * @see #text()\n     * @see #textNodes()\n     */\n    public String ownText() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        ownText(sb);\n        return StringUtil.releaseBuilder(sb).trim();\n    }\n\n    private void ownText(StringBuilder accum) {\n        for (int i = 0; i < childNodeSize(); i++) {\n            Node child = childNodes.get(i);\n            if (child instanceof TextNode) {\n                TextNode textNode = (TextNode) child;\n                appendNormalisedText(accum, textNode);\n            } else if (child.nameIs(\"br\") && !lastCharIsWhitespace(accum)) {\n                accum.append(\" \");\n            }\n        }\n    }\n\n    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {\n        String text = textNode.getWholeText();\n        if (preserveWhitespace(textNode.parentNode) || textNode instanceof CDataNode)\n            accum.append(text);\n        else\n            StringUtil.appendNormalisedWhitespace(accum, text, lastCharIsWhitespace(accum));\n    }\n\n    static boolean preserveWhitespace(@Nullable Node node) {\n        // looks only at this element and five levels up, to prevent recursion & needless stack searches\n        if (node instanceof Element) {\n            Element el = (Element) node;\n            int i = 0;\n            do {\n                if (el.tag.preserveWhitespace())\n                    return true;\n                el = el.parent();\n                i++;\n            } while (i < 6 && el != null);\n        }\n        return false;\n    }\n\n    /**\n     * Set the text of this element. Any existing contents (text or elements) will be cleared.\n     * <p>As a special case, for {@code <script>} and {@code <style>} tags, the input text will be treated as data,\n     * not visible text.</p>\n     * @param text decoded text\n     * @return this element\n     */\n    public Element text(String text) {\n        Validate.notNull(text);\n        empty();\n        // special case for script/style in HTML: should be data node\n        Document owner = ownerDocument();\n        // an alternate impl would be to run through the parser\n        if (owner != null && owner.parser().isContentForTagData(normalName()))\n            appendChild(new DataNode(text));\n        else\n            appendChild(new TextNode(text));\n\n        return this;\n    }\n\n    /**\n     Checks if the current element or any of its child elements contain non-whitespace text.\n     @return {@code true} if the element has non-blank text content, {@code false} otherwise.\n     */\n    public boolean hasText() {\n        AtomicBoolean hasText = new AtomicBoolean(false);\n        filter((node, depth) -> {\n            if (node instanceof TextNode) {\n                TextNode textNode = (TextNode) node;\n                if (!textNode.isBlank()) {\n                    hasText.set(true);\n                    return NodeFilter.FilterResult.STOP;\n                }\n            }\n            return NodeFilter.FilterResult.CONTINUE;\n        });\n        return hasText.get();\n    }\n\n    /**\n     * Get the combined data of this element. Data is e.g. the inside of a {@code <script>} tag. Note that data is NOT the\n     * text of the element. Use {@link #text()} to get the text that would be visible to a user, and {@code data()}\n     * for the contents of scripts, comments, CSS styles, etc.\n     *\n     * @return the data, or empty string if none\n     *\n     * @see #dataNodes()\n     */\n    public String data() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        traverse((childNode, depth) -> {\n            if (childNode instanceof DataNode) {\n                DataNode data = (DataNode) childNode;\n                sb.append(data.getWholeData());\n            } else if (childNode instanceof Comment) {\n                Comment comment = (Comment) childNode;\n                sb.append(comment.getData());\n            } else if (childNode instanceof CDataNode) {\n                // this shouldn't really happen because the html parser won't see the cdata as anything special when parsing script.\n                // but in case another type gets through.\n                CDataNode cDataNode = (CDataNode) childNode;\n                sb.append(cDataNode.getWholeText());\n            }\n        });\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    /**\n     * Gets the literal value of this element's \"class\" attribute, which may include multiple class names, space\n     * separated. (E.g. on <code>&lt;div class=\"header gray\"&gt;</code> returns, \"<code>header gray</code>\")\n     * @return The literal class attribute, or <b>empty string</b> if no class attribute set.\n     */\n    public String className() {\n        return attr(\"class\").trim();\n    }\n\n    /**\n     * Get each of the element's class names. E.g. on element {@code <div class=\"header gray\">},\n     * returns a set of two elements {@code \"header\", \"gray\"}. Note that modifications to this set are not pushed to\n     * the backing {@code class} attribute; use the {@link #classNames(java.util.Set)} method to persist them.\n     * @return set of classnames, empty if no class attribute\n     */\n    public Set<String> classNames() {\n    \tString[] names = ClassSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }\n\n    /**\n     Set the element's {@code class} attribute to the supplied class names.\n     @param classNames set of classes\n     @return this element, for chaining\n     */\n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        if (classNames.isEmpty()) {\n            attributes().remove(\"class\");\n        } else {\n            attributes().put(\"class\", StringUtil.join(classNames, \" \"));\n        }\n        return this;\n    }\n\n    /**\n     * Tests if this element has a class. Case-insensitive.\n     * @param className name of class to check for\n     * @return true if it does, false if not\n     */\n    // performance sensitive\n    public boolean hasClass(String className) {\n        if (attributes == null)\n            return false;\n\n        final String classAttr = attributes.getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n                if (!inClass) {\n                    // we're in a class name : keep the start of the substring\n                    inClass = true;\n                    start = i;\n                }\n            }\n        }\n\n        // check the last entry\n        if (inClass && len - start == wantLen) {\n            return classAttr.regionMatches(true, start, className, 0, wantLen);\n        }\n\n        return false;\n    }\n\n    /**\n     Add a class name to this element's {@code class} attribute.\n     @param className class name to add\n     @return this element\n     */\n    public Element addClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    /**\n     Remove a class name from this element's {@code class} attribute.\n     @param className class name to remove\n     @return this element\n     */\n    public Element removeClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        classes.remove(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    /**\n     Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it.\n     @param className class name to toggle\n     @return this element\n     */\n    public Element toggleClass(String className) {\n        Validate.notNull(className);\n\n        Set<String> classes = classNames();\n        if (classes.contains(className))\n            classes.remove(className);\n        else\n            classes.add(className);\n        classNames(classes);\n\n        return this;\n    }\n\n    /**\n     * Get the value of a form element (input, textarea, etc).\n     * @return the value of the form element, or empty string if not set.\n     */\n    public String val() {\n        if (elementIs(\"textarea\", NamespaceHtml))\n            return text();\n        else\n            return attr(\"value\");\n    }\n\n    /**\n     * Set the value of a form element (input, textarea, etc).\n     * @param value value to set\n     * @return this element (for chaining)\n     */\n    public Element val(String value) {\n        if (elementIs(\"textarea\", NamespaceHtml))\n            text(value);\n        else\n            attr(\"value\", value);\n        return this;\n    }\n\n    /**\n     Get the source range (start and end positions) of the end (closing) tag for this Element. Position tracking must be\n     enabled prior to parsing the content.\n     @return the range of the closing tag for this element, or {@code untracked} if its range was not tracked.\n     @see org.jsoup.parser.Parser#setTrackPosition(boolean)\n     @see Node#sourceRange()\n     @see Range#isImplicit()\n     @since 1.15.2\n     */\n    public Range endSourceRange() {\n        return Range.of(this, false);\n    }\n\n    boolean shouldIndent(final Document.OutputSettings out) {\n        return out.prettyPrint() && isFormatAsBlock(out) && !isInlineable(out) && !preserveWhitespace(parentNode);\n    }\n\n    @Override\n    void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\n        if (shouldIndent(out)) {\n            if (accum instanceof StringBuilder) {\n                if (((StringBuilder) accum).length() > 0)\n                    indent(accum, depth, out);\n            } else {\n                indent(accum, depth, out);\n            }\n        }\n        accum.append('<').append(tagName());\n        if (attributes != null) attributes.html(accum, out);\n\n        // selfclosing includes unknown tags, isEmpty defines tags that are always empty\n        if (childNodes.isEmpty() && tag.isSelfClosing()) {\n            if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\n                accum.append('>');\n            else\n                accum.append(\" />\"); // <img> in html, <img /> in xml\n        }\n        else\n            accum.append('>');\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                (tag.formatAsBlock() && !preserveWhitespace(parentNode)) ||\n                    (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && (childNodes.get(0) instanceof Element))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append('>');\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     *\n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = StringUtil.borrowBuilder();\n        html(accum);\n        String html = StringUtil.releaseBuilder(accum);\n        return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;\n    }\n\n    @Override\n    public <T extends Appendable> T html(T appendable) {\n        final int size = childNodes.size();\n        for (int i = 0; i < size; i++)\n            childNodes.get(i).outerHtml(appendable);\n\n        return appendable;\n    }\n\n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n\n    @Override\n    public Element shallowClone() {\n        // simpler than implementing a clone version with no child copy\n        String baseUri = baseUri();\n        if (baseUri.isEmpty()) baseUri = null; // saves setting a blank internal attribute\n        return new Element(tag, baseUri, attributes == null ? null : attributes.clone());\n    }\n\n    @Override\n    protected Element doClone(@Nullable Node parent) {\n        Element clone = (Element) super.doClone(parent);\n        clone.attributes = attributes != null ? attributes.clone() : null;\n        clone.childNodes = new NodeList(clone, childNodes.size());\n        clone.childNodes.addAll(childNodes); // the children then get iterated and cloned in Node.clone\n\n        return clone;\n    }\n\n    // overrides of Node for call chaining\n    @Override\n    public Element clearAttributes() {\n        if (attributes != null) {\n            super.clearAttributes(); // keeps internal attributes via iterator\n            if (attributes.size() == 0)\n                attributes = null; // only remove entirely if no internal attributes\n        }\n\n        return this;\n    }\n\n    @Override\n    public Element removeAttr(String attributeKey) {\n        return (Element) super.removeAttr(attributeKey);\n    }\n\n    @Override\n    public Element root() {\n        return (Element) super.root(); // probably a document, but always at least an element\n    }\n\n    @Override\n    public Element traverse(NodeVisitor nodeVisitor) {\n        return (Element) super.traverse(nodeVisitor);\n    }\n\n    @Override\n    public Element forEachNode(Consumer<? super Node> action) {\n        return (Element) super.forEachNode(action);\n    }\n\n    /**\n     Perform the supplied action on this Element and each of its descendant Elements, during a depth-first traversal.\n     Elements may be inspected, changed, added, replaced, or removed.\n     @param action the function to perform on the element\n     @return this Element, for chaining\n     @see Node#forEachNode(Consumer)\n     @deprecated use {@link #stream()}.{@link Stream#forEach(Consumer) forEach(Consumer)} instead. (Removing this method\n     so Element can implement Iterable, which this signature conflicts with due to the non-void return.)\n     */\n    @Deprecated\n    public Element forEach(Consumer<? super Element> action) {\n        stream().forEach(action);\n        return this;\n    }\n\n    @Override\n    public Element filter(NodeFilter nodeFilter) {\n        return  (Element) super.filter(nodeFilter);\n    }\n\n    private static final class NodeList extends ChangeNotifyingArrayList<Node> {\n        private final Element owner;\n\n        NodeList(Element owner, int initialCapacity) {\n            super(initialCapacity);\n            this.owner = owner;\n        }\n\n        @Override public void onContentsChanged() {\n            owner.nodelistChanged();\n        }\n    }\n\n    private boolean isFormatAsBlock(Document.OutputSettings out) {\n        return tag.isBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();\n    }\n\n    private boolean isInlineable(Document.OutputSettings out) {\n        if (!tag.isInline())\n            return false;\n        return (parent() == null || parent().isBlock())\n            && !isEffectivelyFirst()\n            && !out.outline()\n            && !nameIs(\"br\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final List<Element> EmptyChildren = Collections.emptyList();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<Element>", "name": "EmptyChildren = Collections.emptyList()", "syntax_pass": true}, {"attribute_expression": "private static final Pattern ClassSplit = Pattern.compile(\"\\\\s+\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "ClassSplit = Pattern.compile(\"\\\\s+\")", "syntax_pass": true}, {"attribute_expression": "private static final String BaseUriKey = Attributes.internalKey(\"baseUri\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "BaseUriKey = Attributes.internalKey(\"baseUri\")", "syntax_pass": true}, {"attribute_expression": "private Tag tag;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Tag", "name": "tag", "syntax_pass": true}, {"attribute_expression": "private @Nullable WeakReference<List<Element>> shadowChildrenRef;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "WeakReference<List<Element>>", "name": "shadowChildrenRef", "syntax_pass": true}, {"attribute_expression": "List<Node> childNodes;", "docstring": " points to child elements shadowed from node children", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "List<Node>", "name": "childNodes", "syntax_pass": true}, {"attribute_expression": "@Nullable Attributes attributes;", "docstring": "", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "Attributes", "name": "attributes", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/EntitiesData.java.EntitiesData", "name": "EntitiesData", "file_path": "src/main/java/org/jsoup/nodes/EntitiesData.java", "superclasses": "", "methods": [], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nHolds packed data that represents Entity name=value pairs. Parsed by Entities, created by BuildEntities.\n", "original_string": "class EntitiesData {\n    static final String xmlPoints;\n    static final String basePoints;\n    static final String fullPoints;\n\n    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6447475\n    // allocated in static here so not inlined in users; saves 16K from .jar (!)\n    static {\n        xmlPoints = \"amp=12;1&gt=1q;3&lt=1o;2&quot=y;0&\";\n        basePoints = \"AElig=5i;1c&AMP=12;2&Aacute=5d;17&Acirc=5e;18&Agrave=5c;16&Aring=5h;1b&Atilde=5f;19&Auml=5g;1a&COPY=4p;h&Ccedil=5j;1d&ETH=5s;1m&Eacute=5l;1f&Ecirc=5m;1g&Egrave=5k;1e&Euml=5n;1h&GT=1q;6&Iacute=5p;1j&Icirc=5q;1k&Igrave=5o;1i&Iuml=5r;1l&LT=1o;4&Ntilde=5t;1n&Oacute=5v;1p&Ocirc=5w;1q&Ograve=5u;1o&Oslash=60;1u&Otilde=5x;1r&Ouml=5y;1s&QUOT=y;0&REG=4u;n&THORN=66;20&Uacute=62;1w&Ucirc=63;1x&Ugrave=61;1v&Uuml=64;1y&Yacute=65;1z&aacute=69;23&acirc=6a;24&acute=50;u&aelig=6e;28&agrave=68;22&amp=12;3&aring=6d;27&atilde=6b;25&auml=6c;26&brvbar=4m;e&ccedil=6f;29&cedil=54;y&cent=4i;a&copy=4p;i&curren=4k;c&deg=4w;q&divide=6v;2p&eacute=6h;2b&ecirc=6i;2c&egrave=6g;2a&eth=6o;2i&euml=6j;2d&frac12=59;13&frac14=58;12&frac34=5a;14&gt=1q;7&iacute=6l;2f&icirc=6m;2g&iexcl=4h;9&igrave=6k;2e&iquest=5b;15&iuml=6n;2h&laquo=4r;k&lt=1o;5&macr=4v;p&micro=51;v&middot=53;x&nbsp=4g;8&not=4s;l&ntilde=6p;2j&oacute=6r;2l&ocirc=6s;2m&ograve=6q;2k&ordf=4q;j&ordm=56;10&oslash=6w;2q&otilde=6t;2n&ouml=6u;2o&para=52;w&plusmn=4x;r&pound=4j;b&quot=y;1&raquo=57;11&reg=4u;o&sect=4n;f&shy=4t;m&sup1=55;z&sup2=4y;s&sup3=4z;t&szlig=67;21&thorn=72;2w&times=5z;1t&uacute=6y;2s&ucirc=6z;2t&ugrave=6x;2r&uml=4o;g&uuml=70;2u&yacute=71;2v&yen=4l;d&yuml=73;2x&\";\n        fullPoints = \"AElig=5i;2v&AMP=12;8&Aacute=5d;2p&Abreve=76;4k&Acirc=5e;2q&Acy=sw;av&Afr=2kn8;1kh&Agrave=5c;2o&Alpha=pd;8d&Amacr=74;4i&And=8cz;1e1&Aogon=78;4m&Aopf=2koo;1ls&ApplyFunction=6e9;ew&Aring=5h;2t&Ascr=2kkc;1jc&Assign=6s4;s6&Atilde=5f;2r&Auml=5g;2s&Backslash=6qe;o1&Barv=8h3;1it&Barwed=6x2;120&Bcy=sx;aw&Because=6r9;pw&Bernoullis=6jw;gn&Beta=pe;8e&Bfr=2kn9;1ki&Bopf=2kop;1lt&Breve=k8;82&Bscr=6jw;gp&Bumpeq=6ry;ro&CHcy=tj;bi&COPY=4p;1q&Cacute=7a;4o&Cap=6vm;zz&CapitalDifferentialD=6kl;h8&Cayleys=6jx;gq&Ccaron=7g;4u&Ccedil=5j;2w&Ccirc=7c;4q&Cconint=6r4;pn&Cdot=7e;4s&Cedilla=54;2e&CenterDot=53;2b&Cfr=6jx;gr&Chi=pz;8y&CircleDot=6u1;x8&CircleMinus=6ty;x3&CirclePlus=6tx;x1&CircleTimes=6tz;x5&ClockwiseContourIntegral=6r6;pp&CloseCurlyDoubleQuote=6cd;e0&CloseCurlyQuote=6c9;dt&Colon=6rb;q1&Colone=8dw;1en&Congruent=6sh;sn&Conint=6r3;pm&ContourIntegral=6r2;pi&Copf=6iq;f7&Coproduct=6q8;nq&CounterClockwiseContourIntegral=6r7;pr&Cross=8bz;1d8&Cscr=2kke;1jd&Cup=6vn;100&CupCap=6rx;rk&DD=6kl;h9&DDotrahd=841;184&DJcy=si;ai&DScy=sl;al&DZcy=sv;au&Dagger=6ch;e7&Darr=6n5;j5&Dashv=8h0;1ir&Dcaron=7i;4w&Dcy=t0;az&Del=6pz;n9&Delta=pg;8g&Dfr=2knb;1kj&DiacriticalAcute=50;27&DiacriticalDot=k9;84&DiacriticalDoubleAcute=kd;8a&DiacriticalGrave=2o;13&DiacriticalTilde=kc;88&Diamond=6v8;za&DifferentialD=6km;ha&Dopf=2kor;1lu&Dot=4o;1n&DotDot=6ho;f5&DotEqual=6s0;rw&DoubleContourIntegral=6r3;pl&DoubleDot=4o;1m&DoubleDownArrow=6oj;m0&DoubleLeftArrow=6og;lq&DoubleLeftRightArrow=6ok;m3&DoubleLeftTee=8h0;1iq&DoubleLongLeftArrow=7w8;17g&DoubleLongLeftRightArrow=7wa;17m&DoubleLongRightArrow=7w9;17j&DoubleRightArrow=6oi;lw&DoubleRightTee=6ug;xz&DoubleUpArrow=6oh;lt&DoubleUpDownArrow=6ol;m7&DoubleVerticalBar=6qt;ov&DownArrow=6mr;i8&DownArrowBar=843;186&DownArrowUpArrow=6ph;mn&DownBreve=lt;8c&DownLeftRightVector=85s;198&DownLeftTeeVector=866;19m&DownLeftVector=6nx;ke&DownLeftVectorBar=85y;19e&DownRightTeeVector=867;19n&DownRightVector=6o1;kq&DownRightVectorBar=85z;19f&DownTee=6uc;xs&DownTeeArrow=6nb;jh&Downarrow=6oj;m1&Dscr=2kkf;1je&Dstrok=7k;4y&ENG=96;6g&ETH=5s;35&Eacute=5l;2y&Ecaron=7u;56&Ecirc=5m;2z&Ecy=tp;bo&Edot=7q;52&Efr=2knc;1kk&Egrave=5k;2x&Element=6q0;na&Emacr=7m;50&EmptySmallSquare=7i3;15x&EmptyVerySmallSquare=7fv;150&Eogon=7s;54&Eopf=2kos;1lv&Epsilon=ph;8h&Equal=8dx;1eo&EqualTilde=6rm;qp&Equilibrium=6oc;li&Escr=6k0;gu&Esim=8dv;1em&Eta=pj;8j&Euml=5n;30&Exists=6pv;mz&ExponentialE=6kn;hc&Fcy=tg;bf&Ffr=2knd;1kl&FilledSmallSquare=7i4;15y&FilledVerySmallSquare=7fu;14w&Fopf=2kot;1lw&ForAll=6ps;ms&Fouriertrf=6k1;gv&Fscr=6k1;gw&GJcy=sj;aj&GT=1q;r&Gamma=pf;8f&Gammad=rg;a5&Gbreve=7y;5a&Gcedil=82;5e&Gcirc=7w;58&Gcy=sz;ay&Gdot=80;5c&Gfr=2kne;1km&Gg=6vt;10c&Gopf=2kou;1lx&GreaterEqual=6sl;sv&GreaterEqualLess=6vv;10i&GreaterFullEqual=6sn;t6&GreaterGreater=8f6;1gh&GreaterLess=6t3;ul&GreaterSlantEqual=8e6;1f5&GreaterTilde=6sz;ub&Gscr=2kki;1jf&Gt=6sr;tr&HARDcy=tm;bl&Hacek=jr;80&Hat=2m;10&Hcirc=84;5f&Hfr=6j0;fe&HilbertSpace=6iz;fa&Hopf=6j1;fg&HorizontalLine=7b4;13i&Hscr=6iz;fc&Hstrok=86;5h&HumpDownHump=6ry;rn&HumpEqual=6rz;rs&IEcy=t1;b0&IJlig=8i;5s&IOcy=sh;ah&Iacute=5p;32&Icirc=5q;33&Icy=t4;b3&Idot=8g;5p&Ifr=6j5;fq&Igrave=5o;31&Im=6j5;fr&Imacr=8a;5l&ImaginaryI=6ko;hf&Implies=6oi;ly&Int=6r0;pf&Integral=6qz;pd&Intersection=6v6;z4&InvisibleComma=6eb;f0&InvisibleTimes=6ea;ey&Iogon=8e;5n&Iopf=2kow;1ly&Iota=pl;8l&Iscr=6j4;fn&Itilde=88;5j&Iukcy=sm;am&Iuml=5r;34&Jcirc=8k;5u&Jcy=t5;b4&Jfr=2knh;1kn&Jopf=2kox;1lz&Jscr=2kkl;1jg&Jsercy=so;ao&Jukcy=sk;ak&KHcy=th;bg&KJcy=ss;as&Kappa=pm;8m&Kcedil=8m;5w&Kcy=t6;b5&Kfr=2kni;1ko&Kopf=2koy;1m0&Kscr=2kkm;1jh&LJcy=sp;ap&LT=1o;m&Lacute=8p;5z&Lambda=pn;8n&Lang=7vu;173&Laplacetrf=6j6;fs&Larr=6n2;j1&Lcaron=8t;63&Lcedil=8r;61&Lcy=t7;b6&LeftAngleBracket=7vs;16x&LeftArrow=6mo;hu&LeftArrowBar=6p0;mj&LeftArrowRightArrow=6o6;l3&LeftCeiling=6x4;121&LeftDoubleBracket=7vq;16t&LeftDownTeeVector=869;19p&LeftDownVector=6o3;kw&LeftDownVectorBar=861;19h&LeftFloor=6x6;125&LeftRightArrow=6ms;ib&LeftRightVector=85q;196&LeftTee=6ub;xq&LeftTeeArrow=6n8;ja&LeftTeeVector=862;19i&LeftTriangle=6uq;ya&LeftTriangleBar=89b;1c0&LeftTriangleEqual=6us;yg&LeftUpDownVector=85t;199&LeftUpTeeVector=868;19o&LeftUpVector=6nz;kk&LeftUpVectorBar=860;19g&LeftVector=6nw;kb&LeftVectorBar=85u;19a&Leftarrow=6og;lr&Leftrightarrow=6ok;m4&LessEqualGreater=6vu;10e&LessFullEqual=6sm;t0&LessGreater=6t2;ui&LessLess=8f5;1gf&LessSlantEqual=8e5;1ez&LessTilde=6sy;u8&Lfr=2knj;1kp&Ll=6vs;109&Lleftarrow=6oq;me&Lmidot=8v;65&LongLeftArrow=7w5;177&LongLeftRightArrow=7w7;17d&LongRightArrow=7w6;17a&Longleftarrow=7w8;17h&Longleftrightarrow=7wa;17n&Longrightarrow=7w9;17k&Lopf=2koz;1m1&LowerLeftArrow=6mx;iq&LowerRightArrow=6mw;in&Lscr=6j6;fu&Lsh=6nk;jv&Lstrok=8x;67&Lt=6sq;tl&Map=83p;17v&Mcy=t8;b7&MediumSpace=6e7;eu&Mellintrf=6k3;gx&Mfr=2knk;1kq&MinusPlus=6qb;nv&Mopf=2kp0;1m2&Mscr=6k3;gz&Mu=po;8o&NJcy=sq;aq&Nacute=8z;69&Ncaron=93;6d&Ncedil=91;6b&Ncy=t9;b8&NegativeMediumSpace=6bv;dc&NegativeThickSpace=6bv;dd&NegativeThinSpace=6bv;de&NegativeVeryThinSpace=6bv;db&NestedGreaterGreater=6sr;tq&NestedLessLess=6sq;tk&NewLine=a;1&Nfr=2knl;1kr&NoBreak=6e8;ev&NonBreakingSpace=4g;1d&Nopf=6j9;fx&Not=8h8;1ix&NotCongruent=6si;sp&NotCupCap=6st;tv&NotDoubleVerticalBar=6qu;p0&NotElement=6q1;ne&NotEqual=6sg;sk&NotEqualTilde=6rm,mw;qn&NotExists=6pw;n1&NotGreater=6sv;tz&NotGreaterEqual=6sx;u5&NotGreaterFullEqual=6sn,mw;t3&NotGreaterGreater=6sr,mw;tn&NotGreaterLess=6t5;uq&NotGreaterSlantEqual=8e6,mw;1f2&NotGreaterTilde=6t1;ug&NotHumpDownHump=6ry,mw;rl&NotHumpEqual=6rz,mw;rq&NotLeftTriangle=6wa;113&NotLeftTriangleBar=89b,mw;1bz&NotLeftTriangleEqual=6wc;119&NotLess=6su;tw&NotLessEqual=6sw;u2&NotLessGreater=6t4;uo&NotLessLess=6sq,mw;th&NotLessSlantEqual=8e5,mw;1ew&NotLessTilde=6t0;ue&NotNestedGreaterGreater=8f6,mw;1gg&NotNestedLessLess=8f5,mw;1ge&NotPrecedes=6tc;vb&NotPrecedesEqual=8fj,mw;1gv&NotPrecedesSlantEqual=6w0;10p&NotReverseElement=6q4;nl&NotRightTriangle=6wb;116&NotRightTriangleBar=89c,mw;1c1&NotRightTriangleEqual=6wd;11c&NotSquareSubset=6tr,mw;wh&NotSquareSubsetEqual=6w2;10t&NotSquareSuperset=6ts,mw;wl&NotSquareSupersetEqual=6w3;10v&NotSubset=6te,6he;vh&NotSubsetEqual=6tk;w0&NotSucceeds=6td;ve&NotSucceedsEqual=8fk,mw;1h1&NotSucceedsSlantEqual=6w1;10r&NotSucceedsTilde=6tb,mw;v7&NotSuperset=6tf,6he;vm&NotSupersetEqual=6tl;w3&NotTilde=6rl;ql&NotTildeEqual=6ro;qv&NotTildeFullEqual=6rr;r1&NotTildeTilde=6rt;r9&NotVerticalBar=6qs;or&Nscr=2kkp;1ji&Ntilde=5t;36&Nu=pp;8p&OElig=9e;6m&Oacute=5v;38&Ocirc=5w;39&Ocy=ta;b9&Odblac=9c;6k&Ofr=2knm;1ks&Ograve=5u;37&Omacr=98;6i&Omega=q1;90&Omicron=pr;8r&Oopf=2kp2;1m3&OpenCurlyDoubleQuote=6cc;dy&OpenCurlyQuote=6c8;dr&Or=8d0;1e2&Oscr=2kkq;1jj&Oslash=60;3d&Otilde=5x;3a&Otimes=8c7;1df&Ouml=5y;3b&OverBar=6da;em&OverBrace=732;13b&OverBracket=71w;134&OverParenthesis=730;139&PartialD=6pu;mx&Pcy=tb;ba&Pfr=2knn;1kt&Phi=py;8x&Pi=ps;8s&PlusMinus=4x;22&Poincareplane=6j0;fd&Popf=6jd;g3&Pr=8fv;1hl&Precedes=6t6;us&PrecedesEqual=8fj;1gy&PrecedesSlantEqual=6t8;uy&PrecedesTilde=6ta;v4&Prime=6cz;eg&Product=6q7;no&Proportion=6rb;q0&Proportional=6ql;oa&Pscr=2kkr;1jk&Psi=q0;8z&QUOT=y;3&Qfr=2kno;1ku&Qopf=6je;g5&Qscr=2kks;1jl&RBarr=840;183&REG=4u;1x&Racute=9g;6o&Rang=7vv;174&Rarr=6n4;j4&Rarrtl=846;187&Rcaron=9k;6s&Rcedil=9i;6q&Rcy=tc;bb&Re=6jg;gb&ReverseElement=6q3;nh&ReverseEquilibrium=6ob;le&ReverseUpEquilibrium=86n;1a4&Rfr=6jg;ga&Rho=pt;8t&RightAngleBracket=7vt;170&RightArrow=6mq;i3&RightArrowBar=6p1;ml&RightArrowLeftArrow=6o4;ky&RightCeiling=6x5;123&RightDoubleBracket=7vr;16v&RightDownTeeVector=865;19l&RightDownVector=6o2;kt&RightDownVectorBar=85x;19d&RightFloor=6x7;127&RightTee=6ua;xo&RightTeeArrow=6na;je&RightTeeVector=863;19j&RightTriangle=6ur;yd&RightTriangleBar=89c;1c2&RightTriangleEqual=6ut;yk&RightUpDownVector=85r;197&RightUpTeeVector=864;19k&RightUpVector=6ny;kh&RightUpVectorBar=85w;19c&RightVector=6o0;kn&RightVectorBar=85v;19b&Rightarrow=6oi;lx&Ropf=6jh;gd&RoundImplies=86o;1a6&Rrightarrow=6or;mg&Rscr=6jf;g7&Rsh=6nl;jx&RuleDelayed=8ac;1cb&SHCHcy=tl;bk&SHcy=tk;bj&SOFTcy=to;bn&Sacute=9m;6u&Sc=8fw;1hm&Scaron=9s;70&Scedil=9q;6y&Scirc=9o;6w&Scy=td;bc&Sfr=2knq;1kv&ShortDownArrow=6mr;i7&ShortLeftArrow=6mo;ht&ShortRightArrow=6mq;i2&ShortUpArrow=6mp;hy&Sigma=pv;8u&SmallCircle=6qg;o6&Sopf=2kp6;1m4&Sqrt=6qi;o9&Square=7fl;14t&SquareIntersection=6tv;ww&SquareSubset=6tr;wi&SquareSubsetEqual=6tt;wp&SquareSuperset=6ts;wm&SquareSupersetEqual=6tu;ws&SquareUnion=6tw;wz&Sscr=2kku;1jm&Star=6va;zf&Sub=6vk;zw&Subset=6vk;zv&SubsetEqual=6ti;vu&Succeeds=6t7;uv&SucceedsEqual=8fk;1h4&SucceedsSlantEqual=6t9;v1&SucceedsTilde=6tb;v8&SuchThat=6q3;ni&Sum=6q9;ns&Sup=6vl;zy&Superset=6tf;vp&SupersetEqual=6tj;vx&Supset=6vl;zx&THORN=66;3j&TRADE=6jm;gf&TSHcy=sr;ar&TScy=ti;bh&Tab=9;0&Tau=pw;8v&Tcaron=9w;74&Tcedil=9u;72&Tcy=te;bd&Tfr=2knr;1kw&Therefore=6r8;pt&Theta=pk;8k&ThickSpace=6e7,6bu;et&ThinSpace=6bt;d7&Tilde=6rg;q9&TildeEqual=6rn;qs&TildeFullEqual=6rp;qy&TildeTilde=6rs;r4&Topf=2kp7;1m5&TripleDot=6hn;f3&Tscr=2kkv;1jn&Tstrok=9y;76&Uacute=62;3f&Uarr=6n3;j2&Uarrocir=85l;193&Ubrcy=su;at&Ubreve=a4;7c&Ucirc=63;3g&Ucy=tf;be&Udblac=a8;7g&Ufr=2kns;1kx&Ugrave=61;3e&Umacr=a2;7a&UnderBar=2n;11&UnderBrace=733;13c&UnderBracket=71x;136&UnderParenthesis=731;13a&Union=6v7;z8&UnionPlus=6tq;wf&Uogon=aa;7i&Uopf=2kp8;1m6&UpArrow=6mp;hz&UpArrowBar=842;185&UpArrowDownArrow=6o5;l1&UpDownArrow=6mt;ie&UpEquilibrium=86m;1a2&UpTee=6ud;xv&UpTeeArrow=6n9;jc&Uparrow=6oh;lu&Updownarrow=6ol;m8&UpperLeftArrow=6mu;ih&UpperRightArrow=6mv;ik&Upsi=r6;9z&Upsilon=px;8w&Uring=a6;7e&Uscr=2kkw;1jo&Utilde=a0;78&Uuml=64;3h&VDash=6uj;y3&Vbar=8h7;1iw&Vcy=sy;ax&Vdash=6uh;y1&Vdashl=8h2;1is&Vee=6v5;z3&Verbar=6c6;dp&Vert=6c6;dq&VerticalBar=6qr;on&VerticalLine=3g;18&VerticalSeparator=7rs;16o&VerticalTilde=6rk;qi&VeryThinSpace=6bu;d9&Vfr=2knt;1ky&Vopf=2kp9;1m7&Vscr=2kkx;1jp&Vvdash=6ui;y2&Wcirc=ac;7k&Wedge=6v4;z0&Wfr=2knu;1kz&Wopf=2kpa;1m8&Wscr=2kky;1jq&Xfr=2knv;1l0&Xi=pq;8q&Xopf=2kpb;1m9&Xscr=2kkz;1jr&YAcy=tr;bq&YIcy=sn;an&YUcy=tq;bp&Yacute=65;3i&Ycirc=ae;7m&Ycy=tn;bm&Yfr=2knw;1l1&Yopf=2kpc;1ma&Yscr=2kl0;1js&Yuml=ag;7o&ZHcy=t2;b1&Zacute=ah;7p&Zcaron=al;7t&Zcy=t3;b2&Zdot=aj;7r&ZeroWidthSpace=6bv;df&Zeta=pi;8i&Zfr=6js;gl&Zopf=6jo;gi&Zscr=2kl1;1jt&aacute=69;3m&abreve=77;4l&ac=6ri;qg&acE=6ri,mr;qe&acd=6rj;qh&acirc=6a;3n&acute=50;28&acy=ts;br&aelig=6e;3r&af=6e9;ex&afr=2kny;1l2&agrave=68;3l&alefsym=6k5;h3&aleph=6k5;h4&alpha=q9;92&amacr=75;4j&amalg=8cf;1dm&amp=12;9&and=6qv;p6&andand=8d1;1e3&andd=8d8;1e9&andslope=8d4;1e6&andv=8d6;1e7&ang=6qo;oj&ange=884;1b1&angle=6qo;oi&angmsd=6qp;ol&angmsdaa=888;1b5&angmsdab=889;1b6&angmsdac=88a;1b7&angmsdad=88b;1b8&angmsdae=88c;1b9&angmsdaf=88d;1ba&angmsdag=88e;1bb&angmsdah=88f;1bc&angrt=6qn;og&angrtvb=6v2;yw&angrtvbd=87x;1b0&angsph=6qq;om&angst=5h;2u&angzarr=70c;12z&aogon=79;4n&aopf=2kpe;1mb&ap=6rs;r8&apE=8ds;1ej&apacir=8dr;1eh&ape=6ru;rd&apid=6rv;rf&apos=13;a&approx=6rs;r5&approxeq=6ru;rc&aring=6d;3q&ascr=2kl2;1ju&ast=16;e&asymp=6rs;r6&asympeq=6rx;rj&atilde=6b;3o&auml=6c;3p&awconint=6r7;ps&awint=8b5;1cr&bNot=8h9;1iy&backcong=6rw;rg&backepsilon=s6;af&backprime=6d1;ei&backsim=6rh;qc&backsimeq=6vh;zp&barvee=6v1;yv&barwed=6x1;11y&barwedge=6x1;11x&bbrk=71x;137&bbrktbrk=71y;138&bcong=6rw;rh&bcy=tt;bs&bdquo=6ce;e4&becaus=6r9;py&because=6r9;px&bemptyv=88g;1bd&bepsi=s6;ag&bernou=6jw;go&beta=qa;93&beth=6k6;h5&between=6ss;tt&bfr=2knz;1l3&bigcap=6v6;z5&bigcirc=7hr;15s&bigcup=6v7;z7&bigodot=8ao;1cd&bigoplus=8ap;1cf&bigotimes=8aq;1ch&bigsqcup=8au;1cl&bigstar=7id;15z&bigtriangledown=7gd;15e&bigtriangleup=7g3;154&biguplus=8as;1cj&bigvee=6v5;z1&bigwedge=6v4;yy&bkarow=83x;17x&blacklozenge=8a3;1c9&blacksquare=7fu;14x&blacktriangle=7g4;156&blacktriangledown=7ge;15g&blacktriangleleft=7gi;15k&blacktriangleright=7g8;15a&blank=74z;13f&blk12=7f6;14r&blk14=7f5;14q&blk34=7f7;14s&block=7ew;14p&bne=1p,6hx;o&bnequiv=6sh,6hx;sm&bnot=6xc;12d&bopf=2kpf;1mc&bot=6ud;xx&bottom=6ud;xu&bowtie=6vc;zi&boxDL=7dj;141&boxDR=7dg;13y&boxDl=7di;140&boxDr=7df;13x&boxH=7dc;13u&boxHD=7dy;14g&boxHU=7e1;14j&boxHd=7dw;14e&boxHu=7dz;14h&boxUL=7dp;147&boxUR=7dm;144&boxUl=7do;146&boxUr=7dl;143&boxV=7dd;13v&boxVH=7e4;14m&boxVL=7dv;14d&boxVR=7ds;14a&boxVh=7e3;14l&boxVl=7du;14c&boxVr=7dr;149&boxbox=895;1bw&boxdL=7dh;13z&boxdR=7de;13w&boxdl=7bk;13m&boxdr=7bg;13l&boxh=7b4;13j&boxhD=7dx;14f&boxhU=7e0;14i&boxhd=7cc;13r&boxhu=7ck;13s&boxminus=6u7;xi&boxplus=6u6;xg&boxtimes=6u8;xk&boxuL=7dn;145&boxuR=7dk;142&boxul=7bs;13o&boxur=7bo;13n&boxv=7b6;13k&boxvH=7e2;14k&boxvL=7dt;14b&boxvR=7dq;148&boxvh=7cs;13t&boxvl=7c4;13q&boxvr=7bw;13p&bprime=6d1;ej&breve=k8;83&brvbar=4m;1k&bscr=2kl3;1jv&bsemi=6dr;er&bsim=6rh;qd&bsime=6vh;zq&bsol=2k;x&bsolb=891;1bv&bsolhsub=7uw;16r&bull=6ci;e9&bullet=6ci;e8&bump=6ry;rp&bumpE=8fi;1gu&bumpe=6rz;ru&bumpeq=6rz;rt&cacute=7b;4p&cap=6qx;pa&capand=8ck;1dq&capbrcup=8cp;1dv&capcap=8cr;1dx&capcup=8cn;1dt&capdot=8cg;1dn&caps=6qx,1e68;p9&caret=6dd;eo&caron=jr;81&ccaps=8ct;1dz&ccaron=7h;4v&ccedil=6f;3s&ccirc=7d;4r&ccups=8cs;1dy&ccupssm=8cw;1e0&cdot=7f;4t&cedil=54;2f&cemptyv=88i;1bf&cent=4i;1g&centerdot=53;2c&cfr=2ko0;1l4&chcy=uf;ce&check=7pv;16j&checkmark=7pv;16i&chi=qv;9s&cir=7gr;15q&cirE=88z;1bt&circ=jq;7z&circeq=6s7;sc&circlearrowleft=6nu;k6&circlearrowright=6nv;k8&circledR=4u;1w&circledS=79k;13g&circledast=6u3;xc&circledcirc=6u2;xa&circleddash=6u5;xe&cire=6s7;sd&cirfnint=8b4;1cq&cirmid=8hb;1j0&cirscir=88y;1bs&clubs=7kz;168&clubsuit=7kz;167&colon=1m;j&colone=6s4;s7&coloneq=6s4;s5&comma=18;g&commat=1s;u&comp=6pt;mv&compfn=6qg;o7&complement=6pt;mu&complexes=6iq;f6&cong=6rp;qz&congdot=8dp;1ef&conint=6r2;pj&copf=2kpg;1md&coprod=6q8;nr&copy=4p;1r&copysr=6jb;fz&crarr=6np;k1&cross=7pz;16k&cscr=2kl4;1jw&csub=8gf;1id&csube=8gh;1if&csup=8gg;1ie&csupe=8gi;1ig&ctdot=6wf;11g&cudarrl=854;18x&cudarrr=851;18u&cuepr=6vy;10m&cuesc=6vz;10o&cularr=6nq;k3&cularrp=859;190&cup=6qy;pc&cupbrcap=8co;1du&cupcap=8cm;1ds&cupcup=8cq;1dw&cupdot=6tp;we&cupor=8cl;1dr&cups=6qy,1e68;pb&curarr=6nr;k5&curarrm=858;18z&curlyeqprec=6vy;10l&curlyeqsucc=6vz;10n&curlyvee=6vi;zr&curlywedge=6vj;zt&curren=4k;1i&curvearrowleft=6nq;k2&curvearrowright=6nr;k4&cuvee=6vi;zs&cuwed=6vj;zu&cwconint=6r6;pq&cwint=6r5;po&cylcty=6y5;12u&dArr=6oj;m2&dHar=86d;19t&dagger=6cg;e5&daleth=6k8;h7&darr=6mr;ia&dash=6c0;dl&dashv=6ub;xr&dbkarow=83z;180&dblac=kd;8b&dcaron=7j;4x&dcy=tw;bv&dd=6km;hb&ddagger=6ch;e6&ddarr=6oa;ld&ddotseq=8dz;1ep&deg=4w;21&delta=qc;95&demptyv=88h;1be&dfisht=873;1aj&dfr=2ko1;1l5&dharl=6o3;kx&dharr=6o2;ku&diam=6v8;zc&diamond=6v8;zb&diamondsuit=7l2;16b&diams=7l2;16c&die=4o;1o&digamma=rh;a6&disin=6wi;11j&div=6v;49&divide=6v;48&divideontimes=6vb;zg&divonx=6vb;zh&djcy=uq;co&dlcorn=6xq;12n&dlcrop=6x9;12a&dollar=10;6&dopf=2kph;1me&dot=k9;85&doteq=6s0;rx&doteqdot=6s1;rz&dotminus=6rc;q2&dotplus=6qc;ny&dotsquare=6u9;xm&doublebarwedge=6x2;11z&downarrow=6mr;i9&downdownarrows=6oa;lc&downharpoonleft=6o3;kv&downharpoonright=6o2;ks&drbkarow=840;182&drcorn=6xr;12p&drcrop=6x8;129&dscr=2kl5;1jx&dscy=ut;cr&dsol=8ae;1cc&dstrok=7l;4z&dtdot=6wh;11i&dtri=7gf;15j&dtrif=7ge;15h&duarr=6ph;mo&duhar=86n;1a5&dwangle=886;1b3&dzcy=v3;d0&dzigrarr=7wf;17r&eDDot=8dz;1eq&eDot=6s1;s0&eacute=6h;3u&easter=8dq;1eg&ecaron=7v;57&ecir=6s6;sb&ecirc=6i;3v&ecolon=6s5;s9&ecy=ul;ck&edot=7r;53&ee=6kn;he&efDot=6s2;s2&efr=2ko2;1l6&eg=8ey;1g9&egrave=6g;3t&egs=8eu;1g5&egsdot=8ew;1g7&el=8ex;1g8&elinters=73b;13e&ell=6j7;fv&els=8et;1g3&elsdot=8ev;1g6&emacr=7n;51&empty=6px;n7&emptyset=6px;n5&emptyv=6px;n6&emsp=6bn;d2&emsp13=6bo;d3&emsp14=6bp;d4&eng=97;6h&ensp=6bm;d1&eogon=7t;55&eopf=2kpi;1mf&epar=6vp;103&eparsl=89v;1c6&eplus=8dt;1ek&epsi=qd;97&epsilon=qd;96&epsiv=s5;ae&eqcirc=6s6;sa&eqcolon=6s5;s8&eqsim=6rm;qq&eqslantgtr=8eu;1g4&eqslantless=8et;1g2&equals=1p;p&equest=6sf;sj&equiv=6sh;so&equivDD=8e0;1er&eqvparsl=89x;1c8&erDot=6s3;s4&erarr=86p;1a7&escr=6jz;gs&esdot=6s0;ry&esim=6rm;qr&eta=qf;99&eth=6o;41&euml=6j;3w&euro=6gc;f2&excl=x;2&exist=6pv;n0&expectation=6k0;gt&exponentiale=6kn;hd&fallingdotseq=6s2;s1&fcy=uc;cb&female=7k0;163&ffilig=1dkz;1ja&fflig=1dkw;1j7&ffllig=1dl0;1jb&ffr=2ko3;1l7&filig=1dkx;1j8&fjlig=2u,2y;15&flat=7l9;16e&fllig=1dky;1j9&fltns=7g1;153&fnof=b6;7v&fopf=2kpj;1mg&forall=6ps;mt&fork=6vo;102&forkv=8gp;1in&fpartint=8b1;1cp&frac12=59;2k&frac13=6kz;hh&frac14=58;2j&frac15=6l1;hj&frac16=6l5;hn&frac18=6l7;hp&frac23=6l0;hi&frac25=6l2;hk&frac34=5a;2m&frac35=6l3;hl&frac38=6l8;hq&frac45=6l4;hm&frac56=6l6;ho&frac58=6l9;hr&frac78=6la;hs&frasl=6dg;eq&frown=6xu;12r&fscr=2kl7;1jy&gE=6sn;t8&gEl=8ek;1ft&gacute=dx;7x&gamma=qb;94&gammad=rh;a7&gap=8ee;1fh&gbreve=7z;5b&gcirc=7x;59&gcy=tv;bu&gdot=81;5d&ge=6sl;sx&gel=6vv;10k&geq=6sl;sw&geqq=6sn;t7&geqslant=8e6;1f6&ges=8e6;1f7&gescc=8fd;1gn&gesdot=8e8;1f9&gesdoto=8ea;1fb&gesdotol=8ec;1fd&gesl=6vv,1e68;10h&gesles=8es;1g1&gfr=2ko4;1l8&gg=6sr;ts&ggg=6vt;10b&gimel=6k7;h6&gjcy=ur;cp&gl=6t3;un&glE=8eq;1fz&gla=8f9;1gj&glj=8f8;1gi&gnE=6sp;tg&gnap=8ei;1fp&gnapprox=8ei;1fo&gne=8eg;1fl&gneq=8eg;1fk&gneqq=6sp;tf&gnsim=6w7;10y&gopf=2kpk;1mh&grave=2o;14&gscr=6iy;f9&gsim=6sz;ud&gsime=8em;1fv&gsiml=8eo;1fx&gt=1q;s&gtcc=8fb;1gl&gtcir=8e2;1et&gtdot=6vr;107&gtlPar=87p;1aw&gtquest=8e4;1ev&gtrapprox=8ee;1fg&gtrarr=86w;1ad&gtrdot=6vr;106&gtreqless=6vv;10j&gtreqqless=8ek;1fs&gtrless=6t3;um&gtrsim=6sz;uc&gvertneqq=6sp,1e68;td&gvnE=6sp,1e68;te&hArr=6ok;m5&hairsp=6bu;da&half=59;2l&hamilt=6iz;fb&hardcy=ui;ch&harr=6ms;id&harrcir=85k;192&harrw=6nh;js&hbar=6j3;fl&hcirc=85;5g&hearts=7l1;16a&heartsuit=7l1;169&hellip=6cm;eb&hercon=6ux;yr&hfr=2ko5;1l9&hksearow=84l;18i&hkswarow=84m;18k&hoarr=6pr;mr&homtht=6rf;q5&hookleftarrow=6nd;jj&hookrightarrow=6ne;jl&hopf=2kpl;1mi&horbar=6c5;do&hscr=2kl9;1jz&hslash=6j3;fi&hstrok=87;5i&hybull=6df;ep&hyphen=6c0;dk&iacute=6l;3y&ic=6eb;f1&icirc=6m;3z&icy=u0;bz&iecy=tx;bw&iexcl=4h;1f&iff=6ok;m6&ifr=2ko6;1la&igrave=6k;3x&ii=6ko;hg&iiiint=8b0;1cn&iiint=6r1;pg&iinfin=89o;1c3&iiota=6jt;gm&ijlig=8j;5t&imacr=8b;5m&image=6j5;fp&imagline=6j4;fm&imagpart=6j5;fo&imath=8h;5r&imof=6uv;yo&imped=c5;7w&in=6q0;nd&incare=6it;f8&infin=6qm;of&infintie=89p;1c4&inodot=8h;5q&int=6qz;pe&intcal=6uy;yt&integers=6jo;gh&intercal=6uy;ys&intlarhk=8bb;1cx&intprod=8cc;1dk&iocy=up;cn&iogon=8f;5o&iopf=2kpm;1mj&iota=qh;9b&iprod=8cc;1dl&iquest=5b;2n&iscr=2kla;1k0&isin=6q0;nc&isinE=6wp;11r&isindot=6wl;11n&isins=6wk;11l&isinsv=6wj;11k&isinv=6q0;nb&it=6ea;ez&itilde=89;5k&iukcy=uu;cs&iuml=6n;40&jcirc=8l;5v&jcy=u1;c0&jfr=2ko7;1lb&jmath=fr;7y&jopf=2kpn;1mk&jscr=2klb;1k1&jsercy=uw;cu&jukcy=us;cq&kappa=qi;9c&kappav=s0;a9&kcedil=8n;5x&kcy=u2;c1&kfr=2ko8;1lc&kgreen=8o;5y&khcy=ud;cc&kjcy=v0;cy&kopf=2kpo;1ml&kscr=2klc;1k2&lAarr=6oq;mf&lArr=6og;ls&lAtail=84b;18a&lBarr=83y;17z&lE=6sm;t2&lEg=8ej;1fr&lHar=86a;19q&lacute=8q;60&laemptyv=88k;1bh&lagran=6j6;ft&lambda=qj;9d&lang=7vs;16z&langd=87l;1as&langle=7vs;16y&lap=8ed;1ff&laquo=4r;1t&larr=6mo;hx&larrb=6p0;mk&larrbfs=84f;18e&larrfs=84d;18c&larrhk=6nd;jk&larrlp=6nf;jo&larrpl=855;18y&larrsim=86r;1a9&larrtl=6n6;j7&lat=8ff;1gp&latail=849;188&late=8fh;1gt&lates=8fh,1e68;1gs&lbarr=83w;17w&lbbrk=7si;16p&lbrace=3f;16&lbrack=2j;v&lbrke=87f;1am&lbrksld=87j;1aq&lbrkslu=87h;1ao&lcaron=8u;64&lcedil=8s;62&lceil=6x4;122&lcub=3f;17&lcy=u3;c2&ldca=852;18v&ldquo=6cc;dz&ldquor=6ce;e3&ldrdhar=86f;19v&ldrushar=85n;195&ldsh=6nm;jz&le=6sk;st&leftarrow=6mo;hv&leftarrowtail=6n6;j6&leftharpoondown=6nx;kd&leftharpoonup=6nw;ka&leftleftarrows=6o7;l6&leftrightarrow=6ms;ic&leftrightarrows=6o6;l4&leftrightharpoons=6ob;lf&leftrightsquigarrow=6nh;jr&leftthreetimes=6vf;zl&leg=6vu;10g&leq=6sk;ss&leqq=6sm;t1&leqslant=8e5;1f0&les=8e5;1f1&lescc=8fc;1gm&lesdot=8e7;1f8&lesdoto=8e9;1fa&lesdotor=8eb;1fc&lesg=6vu,1e68;10d&lesges=8er;1g0&lessapprox=8ed;1fe&lessdot=6vq;104&lesseqgtr=6vu;10f&lesseqqgtr=8ej;1fq&lessgtr=6t2;uj&lesssim=6sy;u9&lfisht=870;1ag&lfloor=6x6;126&lfr=2ko9;1ld&lg=6t2;uk&lgE=8ep;1fy&lhard=6nx;kf&lharu=6nw;kc&lharul=86i;19y&lhblk=7es;14o&ljcy=ux;cv&ll=6sq;tm&llarr=6o7;l7&llcorner=6xq;12m&llhard=86j;19z&lltri=7i2;15w&lmidot=8w;66&lmoust=71s;131&lmoustache=71s;130&lnE=6so;tc&lnap=8eh;1fn&lnapprox=8eh;1fm&lne=8ef;1fj&lneq=8ef;1fi&lneqq=6so;tb&lnsim=6w6;10x&loang=7vw;175&loarr=6pp;mp&lobrk=7vq;16u&longleftarrow=7w5;178&longleftrightarrow=7w7;17e&longmapsto=7wc;17p&longrightarrow=7w6;17b&looparrowleft=6nf;jn&looparrowright=6ng;jp&lopar=879;1ak&lopf=2kpp;1mm&loplus=8bx;1d6&lotimes=8c4;1dc&lowast=6qf;o5&lowbar=2n;12&loz=7gq;15p&lozenge=7gq;15o&lozf=8a3;1ca&lpar=14;b&lparlt=87n;1au&lrarr=6o6;l5&lrcorner=6xr;12o&lrhar=6ob;lg&lrhard=86l;1a1&lrm=6by;di&lrtri=6v3;yx&lsaquo=6d5;ek&lscr=2kld;1k3&lsh=6nk;jw&lsim=6sy;ua&lsime=8el;1fu&lsimg=8en;1fw&lsqb=2j;w&lsquo=6c8;ds&lsquor=6ca;dw&lstrok=8y;68&lt=1o;n&ltcc=8fa;1gk&ltcir=8e1;1es&ltdot=6vq;105&lthree=6vf;zm&ltimes=6vd;zj&ltlarr=86u;1ac&ltquest=8e3;1eu&ltrPar=87q;1ax&ltri=7gj;15n&ltrie=6us;yi&ltrif=7gi;15l&lurdshar=85m;194&luruhar=86e;19u&lvertneqq=6so,1e68;t9&lvnE=6so,1e68;ta&mDDot=6re;q4&macr=4v;20&male=7k2;164&malt=7q8;16m&maltese=7q8;16l&map=6na;jg&mapsto=6na;jf&mapstodown=6nb;ji&mapstoleft=6n8;jb&mapstoup=6n9;jd&marker=7fy;152&mcomma=8bt;1d4&mcy=u4;c3&mdash=6c4;dn&measuredangle=6qp;ok&mfr=2koa;1le&mho=6jr;gj&micro=51;29&mid=6qr;oq&midast=16;d&midcir=8hc;1j1&middot=53;2d&minus=6qa;nu&minusb=6u7;xj&minusd=6rc;q3&minusdu=8bu;1d5&mlcp=8gr;1ip&mldr=6cm;ec&mnplus=6qb;nw&models=6uf;xy&mopf=2kpq;1mn&mp=6qb;nx&mscr=2kle;1k4&mstpos=6ri;qf&mu=qk;9e&multimap=6uw;yp&mumap=6uw;yq&nGg=6vt,mw;10a&nGt=6sr,6he;tp&nGtv=6sr,mw;to&nLeftarrow=6od;lk&nLeftrightarrow=6oe;lm&nLl=6vs,mw;108&nLt=6sq,6he;tj&nLtv=6sq,mw;ti&nRightarrow=6of;lo&nVDash=6un;y7&nVdash=6um;y6&nabla=6pz;n8&nacute=90;6a&nang=6qo,6he;oh&nap=6rt;rb&napE=8ds,mw;1ei&napid=6rv,mw;re&napos=95;6f&napprox=6rt;ra&natur=7la;16g&natural=7la;16f&naturals=6j9;fw&nbsp=4g;1e&nbump=6ry,mw;rm&nbumpe=6rz,mw;rr&ncap=8cj;1dp&ncaron=94;6e&ncedil=92;6c&ncong=6rr;r2&ncongdot=8dp,mw;1ee&ncup=8ci;1do&ncy=u5;c4&ndash=6c3;dm&ne=6sg;sl&neArr=6on;mb&nearhk=84k;18h&nearr=6mv;im&nearrow=6mv;il&nedot=6s0,mw;rv&nequiv=6si;sq&nesear=84o;18n&nesim=6rm,mw;qo&nexist=6pw;n3&nexists=6pw;n2&nfr=2kob;1lf&ngE=6sn,mw;t4&nge=6sx;u7&ngeq=6sx;u6&ngeqq=6sn,mw;t5&ngeqslant=8e6,mw;1f3&nges=8e6,mw;1f4&ngsim=6t1;uh&ngt=6sv;u1&ngtr=6sv;u0&nhArr=6oe;ln&nharr=6ni;ju&nhpar=8he;1j3&ni=6q3;nk&nis=6ws;11u&nisd=6wq;11s&niv=6q3;nj&njcy=uy;cw&nlArr=6od;ll&nlE=6sm,mw;sy&nlarr=6my;iu&nldr=6cl;ea&nle=6sw;u4&nleftarrow=6my;it&nleftrightarrow=6ni;jt&nleq=6sw;u3&nleqq=6sm,mw;sz&nleqslant=8e5,mw;1ex&nles=8e5,mw;1ey&nless=6su;tx&nlsim=6t0;uf&nlt=6su;ty&nltri=6wa;115&nltrie=6wc;11b&nmid=6qs;ou&nopf=2kpr;1mo&not=4s;1u&notin=6q1;ng&notinE=6wp,mw;11q&notindot=6wl,mw;11m&notinva=6q1;nf&notinvb=6wn;11p&notinvc=6wm;11o&notni=6q4;nn&notniva=6q4;nm&notnivb=6wu;11w&notnivc=6wt;11v&npar=6qu;p4&nparallel=6qu;p2&nparsl=8hp,6hx;1j5&npart=6pu,mw;mw&npolint=8b8;1cu&npr=6tc;vd&nprcue=6w0;10q&npre=8fj,mw;1gw&nprec=6tc;vc&npreceq=8fj,mw;1gx&nrArr=6of;lp&nrarr=6mz;iw&nrarrc=84z,mw;18s&nrarrw=6n1,mw;ix&nrightarrow=6mz;iv&nrtri=6wb;118&nrtrie=6wd;11e&nsc=6td;vg&nsccue=6w1;10s&nsce=8fk,mw;1h2&nscr=2klf;1k5&nshortmid=6qs;os&nshortparallel=6qu;p1&nsim=6rl;qm&nsime=6ro;qx&nsimeq=6ro;qw&nsmid=6qs;ot&nspar=6qu;p3&nsqsube=6w2;10u&nsqsupe=6w3;10w&nsub=6tg;vs&nsubE=8g5,mw;1hv&nsube=6tk;w2&nsubset=6te,6he;vi&nsubseteq=6tk;w1&nsubseteqq=8g5,mw;1hw&nsucc=6td;vf&nsucceq=8fk,mw;1h3&nsup=6th;vt&nsupE=8g6,mw;1hz&nsupe=6tl;w5&nsupset=6tf,6he;vn&nsupseteq=6tl;w4&nsupseteqq=8g6,mw;1i0&ntgl=6t5;ur&ntilde=6p;42&ntlg=6t4;up&ntriangleleft=6wa;114&ntrianglelefteq=6wc;11a&ntriangleright=6wb;117&ntrianglerighteq=6wd;11d&nu=ql;9f&num=z;5&numero=6ja;fy&numsp=6br;d5&nvDash=6ul;y5&nvHarr=83o;17u&nvap=6rx,6he;ri&nvdash=6uk;y4&nvge=6sl,6he;su&nvgt=1q,6he;q&nvinfin=89q;1c5&nvlArr=83m;17s&nvle=6sk,6he;sr&nvlt=1o,6he;l&nvltrie=6us,6he;yf&nvrArr=83n;17t&nvrtrie=6ut,6he;yj&nvsim=6rg,6he;q6&nwArr=6om;ma&nwarhk=84j;18g&nwarr=6mu;ij&nwarrow=6mu;ii&nwnear=84n;18m&oS=79k;13h&oacute=6r;44&oast=6u3;xd&ocir=6u2;xb&ocirc=6s;45&ocy=u6;c5&odash=6u5;xf&odblac=9d;6l&odiv=8c8;1dg&odot=6u1;x9&odsold=88s;1bn&oelig=9f;6n&ofcir=88v;1bp&ofr=2koc;1lg&ogon=kb;87&ograve=6q;43&ogt=88x;1br&ohbar=88l;1bi&ohm=q1;91&oint=6r2;pk&olarr=6nu;k7&olcir=88u;1bo&olcross=88r;1bm&oline=6da;en&olt=88w;1bq&omacr=99;6j&omega=qx;9u&omicron=qn;9h&omid=88m;1bj&ominus=6ty;x4&oopf=2kps;1mp&opar=88n;1bk&operp=88p;1bl&oplus=6tx;x2&or=6qw;p8&orarr=6nv;k9&ord=8d9;1ea&order=6k4;h1&orderof=6k4;h0&ordf=4q;1s&ordm=56;2h&origof=6uu;yn&oror=8d2;1e4&orslope=8d3;1e5&orv=8d7;1e8&oscr=6k4;h2&oslash=6w;4a&osol=6u0;x7&otilde=6t;46&otimes=6tz;x6&otimesas=8c6;1de&ouml=6u;47&ovbar=6yl;12x&par=6qt;oz&para=52;2a&parallel=6qt;ox&parsim=8hf;1j4&parsl=8hp;1j6&part=6pu;my&pcy=u7;c6&percnt=11;7&period=1a;h&permil=6cw;ed&perp=6ud;xw&pertenk=6cx;ee&pfr=2kod;1lh&phi=qu;9r&phiv=r9;a2&phmmat=6k3;gy&phone=7im;162&pi=qo;9i&pitchfork=6vo;101&piv=ra;a4&planck=6j3;fj&planckh=6j2;fh&plankv=6j3;fk&plus=17;f&plusacir=8bn;1cz&plusb=6u6;xh&pluscir=8bm;1cy&plusdo=6qc;nz&plusdu=8bp;1d1&pluse=8du;1el&plusmn=4x;23&plussim=8bq;1d2&plustwo=8br;1d3&pm=4x;24&pointint=8b9;1cv&popf=2kpt;1mq&pound=4j;1h&pr=6t6;uu&prE=8fn;1h7&prap=8fr;1he&prcue=6t8;v0&pre=8fj;1h0&prec=6t6;ut&precapprox=8fr;1hd&preccurlyeq=6t8;uz&preceq=8fj;1gz&precnapprox=8ft;1hh&precneqq=8fp;1h9&precnsim=6w8;10z&precsim=6ta;v5&prime=6cy;ef&primes=6jd;g2&prnE=8fp;1ha&prnap=8ft;1hi&prnsim=6w8;110&prod=6q7;np&profalar=6y6;12v&profline=6xe;12e&profsurf=6xf;12f&prop=6ql;oe&propto=6ql;oc&prsim=6ta;v6&prurel=6uo;y8&pscr=2klh;1k6&psi=qw;9t&puncsp=6bs;d6&qfr=2koe;1li&qint=8b0;1co&qopf=2kpu;1mr&qprime=6dz;es&qscr=2kli;1k7&quaternions=6j1;ff&quatint=8ba;1cw&quest=1r;t&questeq=6sf;si&quot=y;4&rAarr=6or;mh&rArr=6oi;lz&rAtail=84c;18b&rBarr=83z;181&rHar=86c;19s&race=6rh,mp;qb&racute=9h;6p&radic=6qi;o8&raemptyv=88j;1bg&rang=7vt;172&rangd=87m;1at&range=885;1b2&rangle=7vt;171&raquo=57;2i&rarr=6mq;i6&rarrap=86t;1ab&rarrb=6p1;mm&rarrbfs=84g;18f&rarrc=84z;18t&rarrfs=84e;18d&rarrhk=6ne;jm&rarrlp=6ng;jq&rarrpl=85h;191&rarrsim=86s;1aa&rarrtl=6n7;j9&rarrw=6n1;iz&ratail=84a;189&ratio=6ra;pz&rationals=6je;g4&rbarr=83x;17y&rbbrk=7sj;16q&rbrace=3h;1b&rbrack=2l;y&rbrke=87g;1an&rbrksld=87i;1ap&rbrkslu=87k;1ar&rcaron=9l;6t&rcedil=9j;6r&rceil=6x5;124&rcub=3h;1c&rcy=u8;c7&rdca=853;18w&rdldhar=86h;19x&rdquo=6cd;e2&rdquor=6cd;e1&rdsh=6nn;k0&real=6jg;g9&realine=6jf;g6&realpart=6jg;g8&reals=6jh;gc&rect=7fx;151&reg=4u;1y&rfisht=871;1ah&rfloor=6x7;128&rfr=2kof;1lj&rhard=6o1;kr&rharu=6o0;ko&rharul=86k;1a0&rho=qp;9j&rhov=s1;ab&rightarrow=6mq;i4&rightarrowtail=6n7;j8&rightharpoondown=6o1;kp&rightharpoonup=6o0;km&rightleftarrows=6o4;kz&rightleftharpoons=6oc;lh&rightrightarrows=6o9;la&rightsquigarrow=6n1;iy&rightthreetimes=6vg;zn&ring=ka;86&risingdotseq=6s3;s3&rlarr=6o4;l0&rlhar=6oc;lj&rlm=6bz;dj&rmoust=71t;133&rmoustache=71t;132&rnmid=8ha;1iz&roang=7vx;176&roarr=6pq;mq&robrk=7vr;16w&ropar=87a;1al&ropf=2kpv;1ms&roplus=8by;1d7&rotimes=8c5;1dd&rpar=15;c&rpargt=87o;1av&rppolint=8b6;1cs&rrarr=6o9;lb&rsaquo=6d6;el&rscr=2klj;1k8&rsh=6nl;jy&rsqb=2l;z&rsquo=6c9;dv&rsquor=6c9;du&rthree=6vg;zo&rtimes=6ve;zk&rtri=7g9;15d&rtrie=6ut;ym&rtrif=7g8;15b&rtriltri=89a;1by&ruluhar=86g;19w&rx=6ji;ge&sacute=9n;6v&sbquo=6ca;dx&sc=6t7;ux&scE=8fo;1h8&scap=8fs;1hg&scaron=9t;71&sccue=6t9;v3&sce=8fk;1h6&scedil=9r;6z&scirc=9p;6x&scnE=8fq;1hc&scnap=8fu;1hk&scnsim=6w9;112&scpolint=8b7;1ct&scsim=6tb;va&scy=u9;c8&sdot=6v9;zd&sdotb=6u9;xn&sdote=8di;1ec&seArr=6oo;mc&searhk=84l;18j&searr=6mw;ip&searrow=6mw;io&sect=4n;1l&semi=1n;k&seswar=84p;18p&setminus=6qe;o2&setmn=6qe;o4&sext=7qu;16n&sfr=2kog;1lk&sfrown=6xu;12q&sharp=7lb;16h&shchcy=uh;cg&shcy=ug;cf&shortmid=6qr;oo&shortparallel=6qt;ow&shy=4t;1v&sigma=qr;9n&sigmaf=qq;9l&sigmav=qq;9m&sim=6rg;qa&simdot=8dm;1ed&sime=6rn;qu&simeq=6rn;qt&simg=8f2;1gb&simgE=8f4;1gd&siml=8f1;1ga&simlE=8f3;1gc&simne=6rq;r0&simplus=8bo;1d0&simrarr=86q;1a8&slarr=6mo;hw&smallsetminus=6qe;o0&smashp=8c3;1db&smeparsl=89w;1c7&smid=6qr;op&smile=6xv;12t&smt=8fe;1go&smte=8fg;1gr&smtes=8fg,1e68;1gq&softcy=uk;cj&sol=1b;i&solb=890;1bu&solbar=6yn;12y&sopf=2kpw;1mt&spades=7kw;166&spadesuit=7kw;165&spar=6qt;oy&sqcap=6tv;wx&sqcaps=6tv,1e68;wv&sqcup=6tw;x0&sqcups=6tw,1e68;wy&sqsub=6tr;wk&sqsube=6tt;wr&sqsubset=6tr;wj&sqsubseteq=6tt;wq&sqsup=6ts;wo&sqsupe=6tu;wu&sqsupset=6ts;wn&sqsupseteq=6tu;wt&squ=7fl;14v&square=7fl;14u&squarf=7fu;14y&squf=7fu;14z&srarr=6mq;i5&sscr=2klk;1k9&ssetmn=6qe;o3&ssmile=6xv;12s&sstarf=6va;ze&star=7ie;161&starf=7id;160&straightepsilon=s5;ac&straightphi=r9;a0&strns=4v;1z&sub=6te;vl&subE=8g5;1hy&subdot=8fx;1hn&sube=6ti;vw&subedot=8g3;1ht&submult=8g1;1hr&subnE=8gb;1i8&subne=6tm;w9&subplus=8fz;1hp&subrarr=86x;1ae&subset=6te;vk&subseteq=6ti;vv&subseteqq=8g5;1hx&subsetneq=6tm;w8&subsetneqq=8gb;1i7&subsim=8g7;1i3&subsub=8gl;1ij&subsup=8gj;1ih&succ=6t7;uw&succapprox=8fs;1hf&succcurlyeq=6t9;v2&succeq=8fk;1h5&succnapprox=8fu;1hj&succneqq=8fq;1hb&succnsim=6w9;111&succsim=6tb;v9&sum=6q9;nt&sung=7l6;16d&sup=6tf;vr&sup1=55;2g&sup2=4y;25&sup3=4z;26&supE=8g6;1i2&supdot=8fy;1ho&supdsub=8go;1im&supe=6tj;vz&supedot=8g4;1hu&suphsol=7ux;16s&suphsub=8gn;1il&suplarr=86z;1af&supmult=8g2;1hs&supnE=8gc;1ic&supne=6tn;wd&supplus=8g0;1hq&supset=6tf;vq&supseteq=6tj;vy&supseteqq=8g6;1i1&supsetneq=6tn;wc&supsetneqq=8gc;1ib&supsim=8g8;1i4&supsub=8gk;1ii&supsup=8gm;1ik&swArr=6op;md&swarhk=84m;18l&swarr=6mx;is&swarrow=6mx;ir&swnwar=84q;18r&szlig=67;3k&target=6xi;12h&tau=qs;9o&tbrk=71w;135&tcaron=9x;75&tcedil=9v;73&tcy=ua;c9&tdot=6hn;f4&telrec=6xh;12g&tfr=2koh;1ll&there4=6r8;pv&therefore=6r8;pu&theta=qg;9a&thetasym=r5;9v&thetav=r5;9x&thickapprox=6rs;r3&thicksim=6rg;q7&thinsp=6bt;d8&thkap=6rs;r7&thksim=6rg;q8&thorn=72;4g&tilde=kc;89&times=5z;3c&timesb=6u8;xl&timesbar=8c1;1da&timesd=8c0;1d9&tint=6r1;ph&toea=84o;18o&top=6uc;xt&topbot=6ye;12w&topcir=8hd;1j2&topf=2kpx;1mu&topfork=8gq;1io&tosa=84p;18q&tprime=6d0;eh&trade=6jm;gg&triangle=7g5;158&triangledown=7gf;15i&triangleleft=7gj;15m&trianglelefteq=6us;yh&triangleq=6sc;sg&triangleright=7g9;15c&trianglerighteq=6ut;yl&tridot=7ho;15r&trie=6sc;sh&triminus=8ca;1di&triplus=8c9;1dh&trisb=899;1bx&tritime=8cb;1dj&trpezium=736;13d&tscr=2kll;1ka&tscy=ue;cd&tshcy=uz;cx&tstrok=9z;77&twixt=6ss;tu&twoheadleftarrow=6n2;j0&twoheadrightarrow=6n4;j3&uArr=6oh;lv&uHar=86b;19r&uacute=6y;4c&uarr=6mp;i1&ubrcy=v2;cz&ubreve=a5;7d&ucirc=6z;4d&ucy=ub;ca&udarr=6o5;l2&udblac=a9;7h&udhar=86m;1a3&ufisht=872;1ai&ufr=2koi;1lm&ugrave=6x;4b&uharl=6nz;kl&uharr=6ny;ki&uhblk=7eo;14n&ulcorn=6xo;12j&ulcorner=6xo;12i&ulcrop=6xb;12c&ultri=7i0;15u&umacr=a3;7b&uml=4o;1p&uogon=ab;7j&uopf=2kpy;1mv&uparrow=6mp;i0&updownarrow=6mt;if&upharpoonleft=6nz;kj&upharpoonright=6ny;kg&uplus=6tq;wg&upsi=qt;9q&upsih=r6;9y&upsilon=qt;9p&upuparrows=6o8;l8&urcorn=6xp;12l&urcorner=6xp;12k&urcrop=6xa;12b&uring=a7;7f&urtri=7i1;15v&uscr=2klm;1kb&utdot=6wg;11h&utilde=a1;79&utri=7g5;159&utrif=7g4;157&uuarr=6o8;l9&uuml=70;4e&uwangle=887;1b4&vArr=6ol;m9&vBar=8h4;1iu&vBarv=8h5;1iv&vDash=6ug;y0&vangrt=87w;1az&varepsilon=s5;ad&varkappa=s0;a8&varnothing=6px;n4&varphi=r9;a1&varpi=ra;a3&varpropto=6ql;ob&varr=6mt;ig&varrho=s1;aa&varsigma=qq;9k&varsubsetneq=6tm,1e68;w6&varsubsetneqq=8gb,1e68;1i5&varsupsetneq=6tn,1e68;wa&varsupsetneqq=8gc,1e68;1i9&vartheta=r5;9w&vartriangleleft=6uq;y9&vartriangleright=6ur;yc&vcy=tu;bt&vdash=6ua;xp&vee=6qw;p7&veebar=6uz;yu&veeeq=6sa;sf&vellip=6we;11f&verbar=3g;19&vert=3g;1a&vfr=2koj;1ln&vltri=6uq;yb&vnsub=6te,6he;vj&vnsup=6tf,6he;vo&vopf=2kpz;1mw&vprop=6ql;od&vrtri=6ur;ye&vscr=2kln;1kc&vsubnE=8gb,1e68;1i6&vsubne=6tm,1e68;w7&vsupnE=8gc,1e68;1ia&vsupne=6tn,1e68;wb&vzigzag=87u;1ay&wcirc=ad;7l&wedbar=8db;1eb&wedge=6qv;p5&wedgeq=6s9;se&weierp=6jc;g0&wfr=2kok;1lo&wopf=2kq0;1mx&wp=6jc;g1&wr=6rk;qk&wreath=6rk;qj&wscr=2klo;1kd&xcap=6v6;z6&xcirc=7hr;15t&xcup=6v7;z9&xdtri=7gd;15f&xfr=2kol;1lp&xhArr=7wa;17o&xharr=7w7;17f&xi=qm;9g&xlArr=7w8;17i&xlarr=7w5;179&xmap=7wc;17q&xnis=6wr;11t&xodot=8ao;1ce&xopf=2kq1;1my&xoplus=8ap;1cg&xotime=8aq;1ci&xrArr=7w9;17l&xrarr=7w6;17c&xscr=2klp;1ke&xsqcup=8au;1cm&xuplus=8as;1ck&xutri=7g3;155&xvee=6v5;z2&xwedge=6v4;yz&yacute=71;4f&yacy=un;cm&ycirc=af;7n&ycy=uj;ci&yen=4l;1j&yfr=2kom;1lq&yicy=uv;ct&yopf=2kq2;1mz&yscr=2klq;1kf&yucy=um;cl&yuml=73;4h&zacute=ai;7q&zcaron=am;7u&zcy=tz;by&zdot=ak;7s&zeetrf=6js;gk&zeta=qe;98&zfr=2kon;1lr&zhcy=ty;bx&zigrarr=6ot;mi&zopf=2kq3;1n0&zscr=2klr;1kg&zwj=6bx;dh&zwnj=6bw;dg&\";\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final String xmlPoints;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "xmlPoints", "syntax_pass": true}, {"attribute_expression": "static final String basePoints;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "basePoints", "syntax_pass": true}, {"attribute_expression": "static final String fullPoints;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String", "name": "fullPoints", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/Range.java.Range", "name": "Range", "file_path": "src/main/java/org/jsoup/nodes/Range.java", "superclasses": "", "methods": ["[]Range(Position,Position)", "[Position]start()", "[int]startPos()", "[Position]end()", "[int]endPos()", "[boolean]isTracked()", "[boolean]isImplicit()", "[Range]of(Node,boolean)", "[boolean]equals(Object)", "[int]hashCode()", "[String]toString()"], "method_uris": ["src/main/java/org/jsoup/nodes/Range.java.Range.[]Range(Position,Position)", "src/main/java/org/jsoup/nodes/Range.java.Range.[Position]start()", "src/main/java/org/jsoup/nodes/Range.java.Range.[int]startPos()", "src/main/java/org/jsoup/nodes/Range.java.Range.[Position]end()", "src/main/java/org/jsoup/nodes/Range.java.Range.[int]endPos()", "src/main/java/org/jsoup/nodes/Range.java.Range.[boolean]isTracked()", "src/main/java/org/jsoup/nodes/Range.java.Range.[boolean]isImplicit()", "src/main/java/org/jsoup/nodes/Range.java.Range.[Range]of(Node,boolean)", "src/main/java/org/jsoup/nodes/Range.java.Range.[boolean]equals(Object)", "src/main/java/org/jsoup/nodes/Range.java.Range.[int]hashCode()", "src/main/java/org/jsoup/nodes/Range.java.Range.[String]toString()"], "overrides": null, "attributes": [{"original_string": "    public static class Position {\n        private final int pos, lineNumber, columnNumber;\n\n        /**\n         Create a new Position object. Called by the TreeBuilder if source position tracking is on.\n         * @param pos position index\n         * @param lineNumber line number\n         * @param columnNumber column number\n         */\n        public Position(int pos, int lineNumber, int columnNumber) {\n            this.pos = pos;\n            this.lineNumber = lineNumber;\n            this.columnNumber = columnNumber;\n        }\n\n        /**\n         Gets the position index (0-based) of the original input source that this Position was read at. This tracks the\n         total number of characters read into the source at this position, regardless of the number of preceding lines.\n         * @return the position, or {@code -1} if untracked.\n         */\n        public int pos() {\n            return pos;\n        }\n\n        /**\n         Gets the line number (1-based) of the original input source that this Position was read at.\n         * @return the line number, or {@code -1} if untracked.\n         */\n        public int lineNumber() {\n            return lineNumber;\n        }\n\n        /**\n         Gets the cursor number (1-based) of the original input source that this Position was read at. The cursor number\n         resets to 1 on every new line.\n         * @return the cursor number, or {@code -1} if untracked.\n         */\n        public int columnNumber() {\n            return columnNumber;\n        }\n\n        /**\n         Test if this position was tracked during parsing.\n         * @return true if this was tracked during parsing, false otherwise (and all fields will be {@code -1}).\n         */\n        public boolean isTracked() {\n            return this != UntrackedPos;\n        }\n\n        /**\n         Gets a String presentation of this Position, in the format {@code line,column:pos}.\n         * @return a String\n         */\n        @Override\n        public String toString() {\n            return lineNumber + \",\" + columnNumber + \":\" + pos;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Position position = (Position) o;\n            if (pos != position.pos) return false;\n            if (lineNumber != position.lineNumber) return false;\n            return columnNumber == position.columnNumber;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(pos, lineNumber, columnNumber);\n        }\n    }", "definition": "    public static class Position", "class_docstring": "\nA Position object tracks the character position in the original input source where a Node starts or ends. If you want to\ntrack these positions, tracking must be enabled in the Parser with\n{@link org.jsoup.parser.Parser#setTrackPosition(boolean)}.\n@see Node#sourceRange()\n", "name": "Position", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final int pos, lineNumber, columnNumber;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "pos", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Position(int pos, int lineNumber, int columnNumber) {\n            this.pos = pos;\n            this.lineNumber = lineNumber;\n            this.columnNumber = columnNumber;\n        }", "docstring": "\nCreate a new Position object. Called by the TreeBuilder if source position tracking is on.\n@param pos position index\n@param lineNumber line number\n@param columnNumber column number\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Position", "params": [{"name": "pos", "type": "int"}, {"name": "lineNumber", "type": "int"}, {"name": "columnNumber", "type": "int"}], "body": "                                                                   {\n            this.pos = pos;\n            this.lineNumber = lineNumber;\n            this.columnNumber = columnNumber;\n        }", "signature": "public Position(int pos, int lineNumber, int columnNumber)"}, {"syntax_pass": true, "original_string": "        public int pos() {\n            return pos;\n        }", "docstring": "\nGets the position index (0-based) of the original input source that this Position was read at. This tracks the\ntotal number of characters read into the source at this position, regardless of the number of preceding lines.\n@return the position, or {@code -1} if untracked.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "pos", "params": [], "body": "                         {\n            return pos;\n        }", "signature": "public int pos()"}, {"syntax_pass": true, "original_string": "        public int lineNumber() {\n            return lineNumber;\n        }", "docstring": "\nGets the line number (1-based) of the original input source that this Position was read at.\n@return the line number, or {@code -1} if untracked.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "lineNumber", "params": [], "body": "                                {\n            return lineNumber;\n        }", "signature": "public int lineNumber()"}, {"syntax_pass": true, "original_string": "        public int columnNumber() {\n            return columnNumber;\n        }", "docstring": "\nGets the cursor number (1-based) of the original input source that this Position was read at. The cursor number\nresets to 1 on every new line.\n@return the cursor number, or {@code -1} if untracked.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "columnNumber", "params": [], "body": "                                  {\n            return columnNumber;\n        }", "signature": "public int columnNumber()"}, {"syntax_pass": true, "original_string": "        public boolean isTracked() {\n            return this != UntrackedPos;\n        }", "docstring": "\nTest if this position was tracked during parsing.\n@return true if this was tracked during parsing, false otherwise (and all fields will be {@code -1}).\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTracked", "params": [], "body": "                                   {\n            return this != UntrackedPos;\n        }", "signature": "public boolean isTracked()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return lineNumber + \",\" + columnNumber + \":\" + pos;\n        }", "docstring": "\nGets a String presentation of this Position, in the format {@code line,column:pos}.\n@return a String\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return lineNumber + \",\" + columnNumber + \":\" + pos;\n        }", "signature": "@Override\n        public String toString()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Position position = (Position) o;\n            if (pos != position.pos) return false;\n            if (lineNumber != position.lineNumber) return false;\n            return columnNumber == position.columnNumber;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                        {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Position position = (Position) o;\n            if (pos != position.pos) return false;\n            if (lineNumber != position.lineNumber) return false;\n            return columnNumber == position.columnNumber;\n        }", "signature": "@Override\n        public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return Objects.hash(pos, lineNumber, columnNumber);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return Objects.hash(pos, lineNumber, columnNumber);\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    public static class AttributeRange {\n        static final AttributeRange UntrackedAttr = new AttributeRange(Range.Untracked, Range.Untracked);\n\n        private final Range nameRange;\n        private final Range valueRange;\n\n        /** Creates a new AttributeRange. Called during parsing by Token.StartTag. */\n        public AttributeRange(Range nameRange, Range valueRange) {\n            this.nameRange = nameRange;\n            this.valueRange = valueRange;\n        }\n\n        /** Get the source range for the attribute's name. */\n        public Range nameRange() {\n            return nameRange;\n        }\n\n        /** Get the source range for the attribute's value. */\n        public Range valueRange() {\n            return valueRange;\n        }\n\n        /** Get a String presentation of this Attribute range, in the form\n         {@code line,column:pos-line,column:pos=line,column:pos-line,column:pos} (name start - name end = val start - val end).\n         . */\n        @Override public String toString() {\n            StringBuilder sb = StringUtil.borrowBuilder()\n                .append(nameRange)\n                .append('=')\n                .append(valueRange);\n            return StringUtil.releaseBuilder(sb);\n        }\n\n        @Override public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            AttributeRange that = (AttributeRange) o;\n\n            if (!nameRange.equals(that.nameRange)) return false;\n            return valueRange.equals(that.valueRange);\n        }\n\n        @Override public int hashCode() {\n            return Objects.hash(nameRange, valueRange);\n        }\n    }", "definition": "    public static class AttributeRange", "class_docstring": "", "name": "AttributeRange", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "static final AttributeRange UntrackedAttr = new AttributeRange(Range.Untracked, Range.Untracked);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "AttributeRange", "name": "UntrackedAttr = new AttributeRange(Range.Untracked, Range.Untracked)", "syntax_pass": true}, {"attribute_expression": "private final Range nameRange;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Range", "name": "nameRange", "syntax_pass": true}, {"attribute_expression": "private final Range valueRange;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Range", "name": "valueRange", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AttributeRange(Range nameRange, Range valueRange) {\n            this.nameRange = nameRange;\n            this.valueRange = valueRange;\n        }", "docstring": " Creates a new AttributeRange. Called during parsing by Token.StartTag.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AttributeRange", "params": [{"name": "nameRange", "type": "Range"}, {"name": "valueRange", "type": "Range"}], "body": "                                                                 {\n            this.nameRange = nameRange;\n            this.valueRange = valueRange;\n        }", "signature": "public AttributeRange(Range nameRange, Range valueRange)"}, {"syntax_pass": true, "original_string": "        public Range nameRange() {\n            return nameRange;\n        }", "docstring": " Get the source range for the attribute's name.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Range", "classes": []}, "name": "nameRange", "params": [], "body": "                                 {\n            return nameRange;\n        }", "signature": "public Range nameRange()"}, {"syntax_pass": true, "original_string": "        public Range valueRange() {\n            return valueRange;\n        }", "docstring": " Get the source range for the attribute's value.", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Range", "classes": []}, "name": "valueRange", "params": [], "body": "                                  {\n            return valueRange;\n        }", "signature": "public Range valueRange()"}, {"syntax_pass": true, "original_string": "        @Override public String toString() {\n            StringBuilder sb = StringUtil.borrowBuilder()\n                .append(nameRange)\n                .append('=')\n                .append(valueRange);\n            return StringUtil.releaseBuilder(sb);\n        }", "docstring": " Get a String presentation of this Attribute range, in the form\n{@code line,column:pos-line,column:pos=line,column:pos-line,column:pos} (name start - name end = val start - val end).\n.", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                           {\n            StringBuilder sb = StringUtil.borrowBuilder()\n                .append(nameRange)\n                .append('=')\n                .append(valueRange);\n            return StringUtil.releaseBuilder(sb);\n        }", "signature": "@Override public String toString()"}, {"syntax_pass": true, "original_string": "        @Override public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            AttributeRange that = (AttributeRange) o;\n\n            if (!nameRange.equals(that.nameRange)) return false;\n            return valueRange.equals(that.valueRange);\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                                  {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            AttributeRange that = (AttributeRange) o;\n\n            if (!nameRange.equals(that.nameRange)) return false;\n            return valueRange.equals(that.valueRange);\n        }", "signature": "@Override public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "        @Override public int hashCode() {\n            return Objects.hash(nameRange, valueRange);\n        }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                        {\n            return Objects.hash(nameRange, valueRange);\n        }", "signature": "@Override public int hashCode()"}]}], "class_docstring": "\nA Range object tracks the character positions in the original input source where a Node starts or ends. If you want to\ntrack these positions, tracking must be enabled in the Parser with\n{@link org.jsoup.parser.Parser#setTrackPosition(boolean)}.\n@see Node#sourceRange()\n@since 1.15.2\n", "original_string": "public class Range {\n    private static final Position UntrackedPos = new Position(-1, -1, -1);\n    private final Position start, end;\n\n    /** An untracked source range. */\n    static final Range Untracked = new Range(UntrackedPos, UntrackedPos);\n\n    /**\n     Creates a new Range with start and end Positions. Called by TreeBuilder when position tracking is on.\n     * @param start the start position\n     * @param end the end position\n     */\n    public Range(Position start, Position end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    /**\n     Get the start position of this node.\n     * @return the start position\n     */\n    public Position start() {\n        return start;\n    }\n\n    /**\n     Get the starting cursor position of this range.\n     @return the 0-based start cursor position.\n     @since 1.17.1\n     */\n    public int startPos() {\n        return start.pos;\n    }\n\n    /**\n     Get the end position of this node.\n     * @return the end position\n     */\n    public Position end() {\n        return end;\n    }\n\n    /**\n     Get the ending cursor position of this range.\n     @return the 0-based ending cursor position.\n     @since 1.17.1\n     */\n    public int endPos() {\n        return end.pos;\n    }\n\n    /**\n     Test if this source range was tracked during parsing.\n     * @return true if this was tracked during parsing, false otherwise (and all fields will be {@code -1}).\n     */\n    public boolean isTracked() {\n        return this != Untracked;\n    }\n\n    /**\n     Checks if the range represents a node that was implicitly created / closed.\n     <p>For example, with HTML of {@code <p>One<p>Two}, both {@code p} elements will have an explicit\n     {@link Element#sourceRange()} but an implicit {@link Element#endSourceRange()} marking the end position, as neither\n     have closing {@code </p>} tags. The TextNodes will have explicit sourceRanges.\n     <p>A range is considered implicit if its start and end positions are the same.\n     @return true if the range is tracked and its start and end positions are the same, false otherwise.\n     @since 1.17.1\n     */\n    public boolean isImplicit() {\n        if (!isTracked()) return false;\n        return start.equals(end);\n    }\n\n    /**\n     Retrieves the source range for a given Node.\n     * @param node the node to retrieve the position for\n     * @param start if this is the starting range. {@code false} for Element end tags.\n     * @return the Range, or the Untracked (-1) position if tracking is disabled.\n     */\n    static Range of(Node node, boolean start) {\n        final String key = start ? RangeKey : EndRangeKey;\n        if (!node.hasAttributes()) return Untracked;\n        Object range = node.attributes().userData(key);\n        return range != null ? (Range) range : Untracked;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Range range = (Range) o;\n\n        if (!start.equals(range.start)) return false;\n        return end.equals(range.end);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(start, end);\n    }\n\n    /**\n     Gets a String presentation of this Range, in the format {@code line,column:pos-line,column:pos}.\n     * @return a String\n     */\n    @Override\n    public String toString() {\n        return start + \"-\" + end;\n    }\n\n    /**\n     A Position object tracks the character position in the original input source where a Node starts or ends. If you want to\n     track these positions, tracking must be enabled in the Parser with\n     {@link org.jsoup.parser.Parser#setTrackPosition(boolean)}.\n     @see Node#sourceRange()\n     */\n    public static class Position {\n        private final int pos, lineNumber, columnNumber;\n\n        /**\n         Create a new Position object. Called by the TreeBuilder if source position tracking is on.\n         * @param pos position index\n         * @param lineNumber line number\n         * @param columnNumber column number\n         */\n        public Position(int pos, int lineNumber, int columnNumber) {\n            this.pos = pos;\n            this.lineNumber = lineNumber;\n            this.columnNumber = columnNumber;\n        }\n\n        /**\n         Gets the position index (0-based) of the original input source that this Position was read at. This tracks the\n         total number of characters read into the source at this position, regardless of the number of preceding lines.\n         * @return the position, or {@code -1} if untracked.\n         */\n        public int pos() {\n            return pos;\n        }\n\n        /**\n         Gets the line number (1-based) of the original input source that this Position was read at.\n         * @return the line number, or {@code -1} if untracked.\n         */\n        public int lineNumber() {\n            return lineNumber;\n        }\n\n        /**\n         Gets the cursor number (1-based) of the original input source that this Position was read at. The cursor number\n         resets to 1 on every new line.\n         * @return the cursor number, or {@code -1} if untracked.\n         */\n        public int columnNumber() {\n            return columnNumber;\n        }\n\n        /**\n         Test if this position was tracked during parsing.\n         * @return true if this was tracked during parsing, false otherwise (and all fields will be {@code -1}).\n         */\n        public boolean isTracked() {\n            return this != UntrackedPos;\n        }\n\n        /**\n         Gets a String presentation of this Position, in the format {@code line,column:pos}.\n         * @return a String\n         */\n        @Override\n        public String toString() {\n            return lineNumber + \",\" + columnNumber + \":\" + pos;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Position position = (Position) o;\n            if (pos != position.pos) return false;\n            if (lineNumber != position.lineNumber) return false;\n            return columnNumber == position.columnNumber;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(pos, lineNumber, columnNumber);\n        }\n    }\n\n    public static class AttributeRange {\n        static final AttributeRange UntrackedAttr = new AttributeRange(Range.Untracked, Range.Untracked);\n\n        private final Range nameRange;\n        private final Range valueRange;\n\n        /** Creates a new AttributeRange. Called during parsing by Token.StartTag. */\n        public AttributeRange(Range nameRange, Range valueRange) {\n            this.nameRange = nameRange;\n            this.valueRange = valueRange;\n        }\n\n        /** Get the source range for the attribute's name. */\n        public Range nameRange() {\n            return nameRange;\n        }\n\n        /** Get the source range for the attribute's value. */\n        public Range valueRange() {\n            return valueRange;\n        }\n\n        /** Get a String presentation of this Attribute range, in the form\n         {@code line,column:pos-line,column:pos=line,column:pos-line,column:pos} (name start - name end = val start - val end).\n         . */\n        @Override public String toString() {\n            StringBuilder sb = StringUtil.borrowBuilder()\n                .append(nameRange)\n                .append('=')\n                .append(valueRange);\n            return StringUtil.releaseBuilder(sb);\n        }\n\n        @Override public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            AttributeRange that = (AttributeRange) o;\n\n            if (!nameRange.equals(that.nameRange)) return false;\n            return valueRange.equals(that.valueRange);\n        }\n\n        @Override public int hashCode() {\n            return Objects.hash(nameRange, valueRange);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Position UntrackedPos = new Position(-1, -1, -1);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Position", "name": "UntrackedPos = new Position(-1, -1, -1)", "syntax_pass": true}, {"attribute_expression": "private final Position start, end;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Position", "name": "start", "syntax_pass": true}, {"attribute_expression": "static final Range Untracked = new Range(UntrackedPos, UntrackedPos);", "docstring": " An untracked source range.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Range", "name": "Untracked = new Range(UntrackedPos, UntrackedPos)", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/FormElement.java.FormElement", "name": "FormElement", "file_path": "src/main/java/org/jsoup/nodes/FormElement.java", "superclasses": "Element", "methods": ["[]FormElement(Tag,String,Attributes)", "[Elements]elements()", "[FormElement]addElement(Element)", "[void]removeChild(Node)", "[Connection]submit()", "[List<Connection.KeyVal>]formData()", "[FormElement]clone()"], "method_uris": ["src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[]FormElement(Tag,String,Attributes)", "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[Elements]elements()", "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[FormElement]addElement(Element)", "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[void]removeChild(Node)", "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[Connection]submit()", "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[List<Connection.KeyVal>]formData()", "src/main/java/org/jsoup/nodes/FormElement.java.FormElement.[FormElement]clone()"], "overrides": null, "attributes": [], "class_docstring": "\nAn HTML Form Element provides ready access to the form fields/controls that are associated with it. It also allows a\nform to easily be submitted.\n", "original_string": "public class FormElement extends Element {\n    private final Elements linkedEls = new Elements();\n    // contains form submittable elements that were linked during the parse (and due to parse rules, may no longer be a child of this form)\n    private final Evaluator submittable = QueryParser.parse(StringUtil.join(SharedConstants.FormSubmitTags, \", \"));\n\n    /**\n     * Create a new, standalone form element.\n     *\n     * @param tag        tag of this element\n     * @param baseUri    the base URI\n     * @param attributes initial attributes\n     */\n    public FormElement(Tag tag, @Nullable String baseUri, @Nullable Attributes attributes) {\n        super(tag, baseUri, attributes);\n    }\n\n    /**\n     * Get the list of form control elements associated with this form.\n     * @return form controls associated with this element.\n     */\n    public Elements elements() {\n        // As elements may have been added or removed from the DOM after parse, prepare a new list that unions them:\n        Elements els = select(submittable); // current form children\n        for (Element linkedEl : linkedEls) {\n            if (linkedEl.ownerDocument() != null && !els.contains(linkedEl)) {\n                els.add(linkedEl); // adds previously linked elements, that weren't previously removed from the DOM\n            }\n        }\n\n        return els;\n    }\n\n    /**\n     * Add a form control element to this form.\n     * @param element form control to add\n     * @return this form element, for chaining\n     */\n    public FormElement addElement(Element element) {\n        linkedEls.add(element);\n        return this;\n    }\n\n    @Override\n    protected void removeChild(Node out) {\n        super.removeChild(out);\n        linkedEls.remove(out);\n    }\n\n    /**\n     Prepare to submit this form. A Connection object is created with the request set up from the form values. This\n     Connection will inherit the settings and the cookies (etc) of the connection/session used to request this Document\n     (if any), as available in {@link Document#connection()}\n     <p>You can then set up other options (like user-agent, timeout, cookies), then execute it.</p>\n\n     @return a connection prepared from the values of this form, in the same session as the one used to request it\n     @throws IllegalArgumentException if the form's absolute action URL cannot be determined. Make sure you pass the\n     document's base URI when parsing.\n     */\n    public Connection submit() {\n        String action = hasAttr(\"action\") ? absUrl(\"action\") : baseUri();\n        Validate.notEmpty(action, \"Could not determine a form action URL for submit. Ensure you set a base URI when parsing.\");\n        Connection.Method method = attr(\"method\").equalsIgnoreCase(\"POST\") ?\n                Connection.Method.POST : Connection.Method.GET;\n\n        Document owner = ownerDocument();\n        Connection connection = owner != null? owner.connection().newRequest() : Jsoup.newSession();\n        return connection.url(action)\n                .data(formData())\n                .method(method);\n    }\n\n    /**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n        // iterate the form control elements and accumulate their values\n        Elements formEls = elements();\n        for (Element el: formEls) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (type.equalsIgnoreCase(\"button\") || type.equalsIgnoreCase(\"image\")) continue; // browsers don't submit these\n\n            if (el.nameIs(\"select\")) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.selectFirst(\"option\");\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }\n\n    @Override\n    public FormElement clone() {\n        return (FormElement) super.clone();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Elements linkedEls = new Elements();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Elements", "name": "linkedEls = new Elements()", "syntax_pass": true}, {"attribute_expression": "private final Evaluator submittable = QueryParser.parse(StringUtil.join(SharedConstants.FormSubmitTags, \", \"));", "docstring": " contains form submittable elements that were linked during the parse (and due to parse rules, may no longer be a child of this form)", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Evaluator", "name": "submittable = QueryParser.parse(StringUtil.join(SharedConstants.FormSubmitTags, \", \"))", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/Document.java.Document", "name": "Document", "file_path": "src/main/java/org/jsoup/nodes/Document.java", "superclasses": "Element", "methods": ["[]Document(String,String)", "[]Document(String)", "[Document]createShell(String)", "[String]location()", "[Connection]connection()", "[DocumentType]documentType()", "[Element]htmlEl()", "[Element]head()", "[Element]body()", "[List<FormElement>]forms()", "[FormElement]expectForm(String)", "[String]title()", "[void]title(String)", "[Element]createElement(String)", "[String]outerHtml()", "[Element]text(String)", "[String]nodeName()", "[void]charset(Charset)", "[Charset]charset()", "[void]updateMetaCharsetElement(boolean)", "[boolean]updateMetaCharsetElement()", "[Document]clone()", "[Document]shallowClone()", "[void]ensureMetaCharsetElement()", "[OutputSettings]outputSettings()", "[Document]outputSettings(OutputSettings)", "[QuirksMode]quirksMode()", "[Document]quirksMode(QuirksMode)", "[Parser]parser()", "[Document]parser(Parser)", "[Document]connection(Connection)"], "method_uris": ["src/main/java/org/jsoup/nodes/Document.java.Document.[]Document(String,String)", "src/main/java/org/jsoup/nodes/Document.java.Document.[]Document(String)", "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]createShell(String)", "src/main/java/org/jsoup/nodes/Document.java.Document.[String]location()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Connection]connection()", "src/main/java/org/jsoup/nodes/Document.java.Document.[DocumentType]documentType()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]htmlEl()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]head()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]body()", "src/main/java/org/jsoup/nodes/Document.java.Document.[List<FormElement>]forms()", "src/main/java/org/jsoup/nodes/Document.java.Document.[FormElement]expectForm(String)", "src/main/java/org/jsoup/nodes/Document.java.Document.[String]title()", "src/main/java/org/jsoup/nodes/Document.java.Document.[void]title(String)", "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]createElement(String)", "src/main/java/org/jsoup/nodes/Document.java.Document.[String]outerHtml()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Element]text(String)", "src/main/java/org/jsoup/nodes/Document.java.Document.[String]nodeName()", "src/main/java/org/jsoup/nodes/Document.java.Document.[void]charset(Charset)", "src/main/java/org/jsoup/nodes/Document.java.Document.[Charset]charset()", "src/main/java/org/jsoup/nodes/Document.java.Document.[void]updateMetaCharsetElement(boolean)", "src/main/java/org/jsoup/nodes/Document.java.Document.[boolean]updateMetaCharsetElement()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]clone()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]shallowClone()", "src/main/java/org/jsoup/nodes/Document.java.Document.[void]ensureMetaCharsetElement()", "src/main/java/org/jsoup/nodes/Document.java.Document.[OutputSettings]outputSettings()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]outputSettings(OutputSettings)", "src/main/java/org/jsoup/nodes/Document.java.Document.[QuirksMode]quirksMode()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]quirksMode(QuirksMode)", "src/main/java/org/jsoup/nodes/Document.java.Document.[Parser]parser()", "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]parser(Parser)", "src/main/java/org/jsoup/nodes/Document.java.Document.[Document]connection(Connection)"], "overrides": null, "attributes": [{"original_string": "    public static class OutputSettings implements Cloneable {\n        /**\n         * The output serialization syntax.\n         */\n        public enum Syntax {html, xml}\n        private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\n        private Charset charset = DataUtil.UTF_8;\n        private boolean prettyPrint = true;\n        private boolean outline = false;\n        private int indentAmount = 1;\n        private int maxPaddingWidth = 30;\n        private Syntax syntax = Syntax.html;\n\n        /**\n         Create a new OutputSettings object, with the default settings (UTF-8, HTML, EscapeMode.base, pretty-printing,\n         indent amount of 1).\n         */\n        public OutputSettings() {\n        }\n\n        /**\n         Get the document's current entity escape mode:\n         <ul>\n         <li><code>xhtml</code>, the minimal named entities in XHTML / XML</li>\n         <li><code>base</code>, which provides a limited set of named HTML\n         entities and escapes other characters as numbered entities for maximum compatibility</li>\n         <li><code>extended</code>,\n         which uses the complete set of HTML named entities.</li>\n         </ul>\n         <p>The default escape mode is <code>base</code>.\n         @return the document's current escape mode\n         */\n        public Entities.EscapeMode escapeMode() {\n            return escapeMode;\n        }\n\n        /**\n         * Set the document's escape mode, which determines how characters are escaped when the output character set\n         * does not support a given character:- using either a named or a numbered escape.\n         * @param escapeMode the new escape mode to use\n         * @return the document's output settings, for chaining\n         */\n        public OutputSettings escapeMode(Entities.EscapeMode escapeMode) {\n            this.escapeMode = escapeMode;\n            return this;\n        }\n\n        /**\n         * Get the document's current output charset, which is used to control which characters are escaped when\n         * generating HTML (via the <code>html()</code> methods), and which are kept intact.\n         * <p>\n         * Where possible (when parsing from a URL or File), the document's output charset is automatically set to the\n         * input charset. Otherwise, it defaults to UTF-8.\n         * @return the document's current charset.\n         */\n        public Charset charset() {\n            return charset;\n        }\n\n        /**\n         * Update the document's output charset.\n         * @param charset the new charset to use.\n         * @return the document's output settings, for chaining\n         */\n        public OutputSettings charset(Charset charset) {\n            this.charset = charset;\n            return this;\n        }\n\n        /**\n         * Update the document's output charset.\n         * @param charset the new charset (by name) to use.\n         * @return the document's output settings, for chaining\n         */\n        public OutputSettings charset(String charset) {\n            charset(Charset.forName(charset));\n            return this;\n        }\n\n        /**\n         * Get the document's current output syntax.\n         * @return current syntax\n         */\n        public Syntax syntax() {\n            return syntax;\n        }\n\n        /**\n         * Set the document's output syntax. Either {@code html}, with empty tags and boolean attributes (etc), or\n         * {@code xml}, with self-closing tags.\n         * <p>When set to {@link Document.OutputSettings.Syntax#xml xml}, the {@link #escapeMode() escapeMode} is\n         * automatically set to {@link Entities.EscapeMode#xhtml}, but may be subsequently changed if desired.</p>\n         * @param syntax serialization syntax\n         * @return the document's output settings, for chaining\n         */\n        public OutputSettings syntax(Syntax syntax) {\n            this.syntax = syntax;\n            if (syntax == Syntax.xml)\n                this.escapeMode(Entities.EscapeMode.xhtml);\n            return this;\n        }\n\n        /**\n         * Get if pretty printing is enabled. Default is true. If disabled, the HTML output methods will not re-format\n         * the output, and the output will generally look like the input.\n         * @return if pretty printing is enabled.\n         */\n        public boolean prettyPrint() {\n            return prettyPrint;\n        }\n\n        /**\n         * Enable or disable pretty printing.\n         * @param pretty new pretty print setting\n         * @return this, for chaining\n         */\n        public OutputSettings prettyPrint(boolean pretty) {\n            prettyPrint = pretty;\n            return this;\n        }\n        \n        /**\n         * Get if outline mode is enabled. Default is false. If enabled, the HTML output methods will consider\n         * all tags as block.\n         * @return if outline mode is enabled.\n         */\n        public boolean outline() {\n            return outline;\n        }\n        \n        /**\n         * Enable or disable HTML outline mode.\n         * @param outlineMode new outline setting\n         * @return this, for chaining\n         */\n        public OutputSettings outline(boolean outlineMode) {\n            outline = outlineMode;\n            return this;\n        }\n\n        /**\n         * Get the current tag indent amount, used when pretty printing.\n         * @return the current indent amount\n         */\n        public int indentAmount() {\n            return indentAmount;\n        }\n\n        /**\n         * Set the indent amount for pretty printing\n         * @param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.\n         * @return this, for chaining\n         */\n        public OutputSettings indentAmount(int indentAmount) {\n            Validate.isTrue(indentAmount >= 0);\n            this.indentAmount = indentAmount;\n            return this;\n        }\n\n        /**\n         * Get the current max padding amount, used when pretty printing\n         * so very deeply nested nodes don't get insane padding amounts.\n         * @return the current indent amount\n         */\n        public int maxPaddingWidth() {\n            return maxPaddingWidth;\n        }\n\n        /**\n         * Set the max padding amount for pretty printing so very deeply nested nodes don't get insane padding amounts.\n         * @param maxPaddingWidth number of spaces to use for indenting each level of nested nodes. Must be {@literal >=} -1.\n         *        Default is 30 and -1 means unlimited.\n         * @return this, for chaining\n         */\n        public OutputSettings maxPaddingWidth(int maxPaddingWidth) {\n            Validate.isTrue(maxPaddingWidth >= -1);\n            this.maxPaddingWidth = maxPaddingWidth;\n            return this;\n        }\n\n        @Override\n        public OutputSettings clone() {\n            OutputSettings clone;\n            try {\n                clone = (OutputSettings) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n            clone.charset(charset.name()); // new charset, coreCharset, and charset encoder\n            clone.escapeMode = Entities.EscapeMode.valueOf(escapeMode.name());\n            // indentAmount, maxPaddingWidth, and prettyPrint are primitives so object.clone() will handle\n            return clone;\n        }\n    }", "definition": "    public static class OutputSettings implements Cloneable", "class_docstring": "\nA Document's output settings control the form of the text() and html() methods.\n", "name": "OutputSettings", "super_interfaces": ["Cloneable"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Entities.EscapeMode", "name": "escapeMode = Entities.EscapeMode.base", "syntax_pass": true}, {"attribute_expression": "private Charset charset = DataUtil.UTF_8;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Charset", "name": "charset = DataUtil.UTF_8", "syntax_pass": true}, {"attribute_expression": "private boolean prettyPrint = true;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "prettyPrint = true", "syntax_pass": true}, {"attribute_expression": "private boolean outline = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "outline = false", "syntax_pass": true}, {"attribute_expression": "private int indentAmount = 1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "indentAmount = 1", "syntax_pass": true}, {"attribute_expression": "private int maxPaddingWidth = 30;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "maxPaddingWidth = 30", "syntax_pass": true}, {"attribute_expression": "private Syntax syntax = Syntax.html;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Syntax", "name": "syntax = Syntax.html", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public OutputSettings() {\n        }", "docstring": "\nCreate a new OutputSettings object, with the default settings (UTF-8, HTML, EscapeMode.base, pretty-printing,\nindent amount of 1).\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "OutputSettings", "params": [], "body": "                                {\n        }", "signature": "public OutputSettings()"}, {"syntax_pass": true, "original_string": "        public Entities.EscapeMode escapeMode() {\n            return escapeMode;\n        }", "docstring": "\nGet the document's current entity escape mode:\n<ul>\n<li><code>xhtml</code>, the minimal named entities in XHTML / XML</li>\n<li><code>base</code>, which provides a limited set of named HTML\nentities and escapes other characters as numbered entities for maximum compatibility</li>\n<li><code>extended</code>,\nwhich uses the complete set of HTML named entities.</li>\n</ul>\n<p>The default escape mode is <code>base</code>.\n@return the document's current escape mode\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entities.EscapeMode", "classes": []}, "name": "escapeMode", "params": [], "body": "                                                {\n            return escapeMode;\n        }", "signature": "public Entities.EscapeMode escapeMode()"}, {"syntax_pass": true, "original_string": "        public OutputSettings escapeMode(Entities.EscapeMode escapeMode) {\n            this.escapeMode = escapeMode;\n            return this;\n        }", "docstring": "\nSet the document's escape mode, which determines how characters are escaped when the output character set\ndoes not support a given character:- using either a named or a numbered escape.\n@param escapeMode the new escape mode to use\n@return the document's output settings, for chaining\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputSettings", "classes": []}, "name": "escapeMode", "params": [{"name": "escapeMode", "type": "Entities.EscapeMode"}], "body": "                                                                         {\n            this.escapeMode = escapeMode;\n            return this;\n        }", "signature": "public OutputSettings escapeMode(Entities.EscapeMode escapeMode)"}, {"syntax_pass": true, "original_string": "        public Charset charset() {\n            return charset;\n        }", "docstring": "\nGet the document's current output charset, which is used to control which characters are escaped when\ngenerating HTML (via the <code>html()</code> methods), and which are kept intact.\n<p>\nWhere possible (when parsing from a URL or File), the document's output charset is automatically set to the\ninput charset. Otherwise, it defaults to UTF-8.\n@return the document's current charset.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Charset", "classes": []}, "name": "charset", "params": [], "body": "                                 {\n            return charset;\n        }", "signature": "public Charset charset()"}, {"syntax_pass": true, "original_string": "        public OutputSettings charset(Charset charset) {\n            this.charset = charset;\n            return this;\n        }", "docstring": "\nUpdate the document's output charset.\n@param charset the new charset to use.\n@return the document's output settings, for chaining\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputSettings", "classes": []}, "name": "charset", "params": [{"name": "charset", "type": "Charset"}], "body": "                                                       {\n            this.charset = charset;\n            return this;\n        }", "signature": "public OutputSettings charset(Charset charset)"}, {"syntax_pass": true, "original_string": "        public OutputSettings charset(String charset) {\n            charset(Charset.forName(charset));\n            return this;\n        }", "docstring": "\nUpdate the document's output charset.\n@param charset the new charset (by name) to use.\n@return the document's output settings, for chaining\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputSettings", "classes": []}, "name": "charset", "params": [{"name": "charset", "type": "String"}], "body": "                                                      {\n            charset(Charset.forName(charset));\n            return this;\n        }", "signature": "public OutputSettings charset(String charset)"}, {"syntax_pass": true, "original_string": "        public Syntax syntax() {\n            return syntax;\n        }", "docstring": "\nGet the document's current output syntax.\n@return current syntax\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Syntax", "classes": []}, "name": "syntax", "params": [], "body": "                               {\n            return syntax;\n        }", "signature": "public Syntax syntax()"}, {"syntax_pass": true, "original_string": "        public OutputSettings syntax(Syntax syntax) {\n            this.syntax = syntax;\n            if (syntax == Syntax.xml)\n                this.escapeMode(Entities.EscapeMode.xhtml);\n            return this;\n        }", "docstring": "\nSet the document's output syntax. Either {@code html}, with empty tags and boolean attributes (etc), or\n{@code xml}, with self-closing tags.\n<p>When set to {@link Document.OutputSettings.Syntax#xml xml}, the {@link #escapeMode() escapeMode} is\nautomatically set to {@link Entities.EscapeMode#xhtml}, but may be subsequently changed if desired.</p>\n@param syntax serialization syntax\n@return the document's output settings, for chaining\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputSettings", "classes": []}, "name": "syntax", "params": [{"name": "syntax", "type": "Syntax"}], "body": "                                                    {\n            this.syntax = syntax;\n            if (syntax == Syntax.xml)\n                this.escapeMode(Entities.EscapeMode.xhtml);\n            return this;\n        }", "signature": "public OutputSettings syntax(Syntax syntax)"}, {"syntax_pass": true, "original_string": "        public boolean prettyPrint() {\n            return prettyPrint;\n        }", "docstring": "\nGet if pretty printing is enabled. Default is true. If disabled, the HTML output methods will not re-format\nthe output, and the output will generally look like the input.\n@return if pretty printing is enabled.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "prettyPrint", "params": [], "body": "                                     {\n            return prettyPrint;\n        }", "signature": "public boolean prettyPrint()"}, {"syntax_pass": true, "original_string": "        public OutputSettings prettyPrint(boolean pretty) {\n            prettyPrint = pretty;\n            return this;\n        }", "docstring": "\nEnable or disable pretty printing.\n@param pretty new pretty print setting\n@return this, for chaining\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputSettings", "classes": []}, "name": "prettyPrint", "params": [{"name": "pretty", "type": "boolean"}], "body": "                                                          {\n            prettyPrint = pretty;\n            return this;\n        }", "signature": "public OutputSettings prettyPrint(boolean pretty)"}, {"syntax_pass": true, "original_string": "        public boolean outline() {\n            return outline;\n        }", "docstring": "\nGet if outline mode is enabled. Default is false. If enabled, the HTML output methods will consider\nall tags as block.\n@return if outline mode is enabled.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "outline", "params": [], "body": "                                 {\n            return outline;\n        }", "signature": "public boolean outline()"}, {"syntax_pass": true, "original_string": "        public OutputSettings outline(boolean outlineMode) {\n            outline = outlineMode;\n            return this;\n        }", "docstring": "\nEnable or disable HTML outline mode.\n@param outlineMode new outline setting\n@return this, for chaining\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputSettings", "classes": []}, "name": "outline", "params": [{"name": "outlineMode", "type": "boolean"}], "body": "                                                           {\n            outline = outlineMode;\n            return this;\n        }", "signature": "public OutputSettings outline(boolean outlineMode)"}, {"syntax_pass": true, "original_string": "        public int indentAmount() {\n            return indentAmount;\n        }", "docstring": "\nGet the current tag indent amount, used when pretty printing.\n@return the current indent amount\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "indentAmount", "params": [], "body": "                                  {\n            return indentAmount;\n        }", "signature": "public int indentAmount()"}, {"syntax_pass": true, "original_string": "        public OutputSettings indentAmount(int indentAmount) {\n            Validate.isTrue(indentAmount >= 0);\n            this.indentAmount = indentAmount;\n            return this;\n        }", "docstring": "\nSet the indent amount for pretty printing\n@param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.\n@return this, for chaining\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputSettings", "classes": []}, "name": "indentAmount", "params": [{"name": "indentAmount", "type": "int"}], "body": "                                                             {\n            Validate.isTrue(indentAmount >= 0);\n            this.indentAmount = indentAmount;\n            return this;\n        }", "signature": "public OutputSettings indentAmount(int indentAmount)"}, {"syntax_pass": true, "original_string": "        public int maxPaddingWidth() {\n            return maxPaddingWidth;\n        }", "docstring": "\nGet the current max padding amount, used when pretty printing\nso very deeply nested nodes don't get insane padding amounts.\n@return the current indent amount\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "maxPaddingWidth", "params": [], "body": "                                     {\n            return maxPaddingWidth;\n        }", "signature": "public int maxPaddingWidth()"}, {"syntax_pass": true, "original_string": "        public OutputSettings maxPaddingWidth(int maxPaddingWidth) {\n            Validate.isTrue(maxPaddingWidth >= -1);\n            this.maxPaddingWidth = maxPaddingWidth;\n            return this;\n        }", "docstring": "\nSet the max padding amount for pretty printing so very deeply nested nodes don't get insane padding amounts.\n@param maxPaddingWidth number of spaces to use for indenting each level of nested nodes. Must be {@literal >=} -1.\n       Default is 30 and -1 means unlimited.\n@return this, for chaining\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputSettings", "classes": []}, "name": "maxPaddingWidth", "params": [{"name": "maxPaddingWidth", "type": "int"}], "body": "                                                                   {\n            Validate.isTrue(maxPaddingWidth >= -1);\n            this.maxPaddingWidth = maxPaddingWidth;\n            return this;\n        }", "signature": "public OutputSettings maxPaddingWidth(int maxPaddingWidth)"}, {"syntax_pass": true, "original_string": "        @Override\n        public OutputSettings clone() {\n            OutputSettings clone;\n            try {\n                clone = (OutputSettings) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n            clone.charset(charset.name()); // new charset, coreCharset, and charset encoder\n            clone.escapeMode = Entities.EscapeMode.valueOf(escapeMode.name());\n            // indentAmount, maxPaddingWidth, and prettyPrint are primitives so object.clone() will handle\n            return clone;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputSettings", "classes": []}, "name": "clone", "params": [], "body": "                                      {\n            OutputSettings clone;\n            try {\n                clone = (OutputSettings) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n            clone.charset(charset.name()); // new charset, coreCharset, and charset encoder\n            clone.escapeMode = Entities.EscapeMode.valueOf(escapeMode.name());\n            // indentAmount, maxPaddingWidth, and prettyPrint are primitives so object.clone() will handle\n            return clone;\n        }", "signature": "@Override\n        public OutputSettings clone()"}]}], "class_docstring": "\nA HTML Document.\n\n@author Jonathan Hedley, jonathan@hedley.net", "original_string": "public class Document extends Element {\n    private @Nullable Connection connection; // the connection this doc was fetched from, if any\n    private OutputSettings outputSettings = new OutputSettings();\n    private Parser parser; // the parser used to parse this document\n    private QuirksMode quirksMode = QuirksMode.noQuirks;\n    private final String location;\n    private boolean updateMetaCharset = false;\n\n    /**\n     Create a new, empty Document, in the specified namespace.\n     @param namespace the namespace of this Document's root node.\n     @param baseUri base URI of document\n     @see org.jsoup.Jsoup#parse\n     @see #createShell\n     */\n    public Document(String namespace, String baseUri) {\n        super(Tag.valueOf(\"#root\", namespace, ParseSettings.htmlDefault), baseUri);\n        this.location = baseUri;\n        this.parser = Parser.htmlParser(); // default, but overridable\n    }\n\n    /**\n     Create a new, empty Document, in the HTML namespace.\n     @param baseUri base URI of document\n     @see org.jsoup.Jsoup#parse\n     @see #Document(String namespace, String baseUri)\n     */\n    public Document(String baseUri) {\n        this(NamespaceHtml, baseUri);\n    }\n\n    /**\n     Create a valid, empty shell of a document, suitable for adding more elements to.\n     @param baseUri baseUri of document\n     @return document with html, head, and body elements.\n     */\n    public static Document createShell(String baseUri) {\n        Validate.notNull(baseUri);\n\n        Document doc = new Document(baseUri);\n        Element html = doc.appendElement(\"html\");\n        html.appendElement(\"head\");\n        html.appendElement(\"body\");\n\n        return doc;\n    }\n\n    /**\n     * Get the URL this Document was parsed from. If the starting URL is a redirect,\n     * this will return the final URL from which the document was served from.\n     * <p>Will return an empty string if the location is unknown (e.g. if parsed from a String).\n     * @return location\n     */\n    public String location() {\n        return location;\n    }\n\n    /**\n     Returns the Connection (Request/Response) object that was used to fetch this document, if any; otherwise, a new\n     default Connection object. This can be used to continue a session, preserving settings and cookies, etc.\n     @return the Connection (session) associated with this Document, or an empty one otherwise.\n     @see Connection#newRequest()\n     */\n    public Connection connection() {\n        if (connection == null)\n            return Jsoup.newSession();\n        else\n            return connection;\n    }\n\n    /**\n     * Returns this Document's doctype.\n     * @return document type, or null if not set\n     */\n    public @Nullable DocumentType documentType() {\n        for (Node node : childNodes) {\n            if (node instanceof DocumentType)\n                return (DocumentType) node;\n            else if (!(node instanceof LeafNode)) // scans forward across comments, text, processing instructions etc\n                break;\n        }\n        return null;\n        // todo - add a set document type?\n    }\n\n    /**\n     Find the root HTML element, or create it if it doesn't exist.\n     @return the root HTML element.\n     */\n    private Element htmlEl() {\n        Element el = firstElementChild();\n        while (el != null) {\n            if (el.nameIs(\"html\"))\n                return el;\n            el = el.nextElementSibling();\n        }\n        return appendElement(\"html\");\n    }\n\n    /**\n     Get this document's {@code head} element.\n     <p>\n     As a side effect, if this Document does not already have an HTML structure, it will be created. If you do not want\n     that, use {@code #selectFirst(\"head\")} instead.\n\n     @return {@code head} element.\n     */\n    public Element head() {\n        final Element html = htmlEl();\n        Element el = html.firstElementChild();\n        while (el != null) {\n            if (el.nameIs(\"head\"))\n                return el;\n            el = el.nextElementSibling();\n        }\n        return html.prependElement(\"head\");\n    }\n\n    /**\n     Get this document's {@code <body>} or {@code <frameset>} element.\n     <p>\n     As a <b>side-effect</b>, if this Document does not already have an HTML structure, it will be created with a {@code\n    <body>} element. If you do not want that, use {@code #selectFirst(\"body\")} instead.\n\n     @return {@code body} element for documents with a {@code <body>}, a new {@code <body>} element if the document\n     had no contents, or the outermost {@code <frameset> element} for frameset documents.\n     */\n    public Element body() {\n        final Element html = htmlEl();\n        Element el = html.firstElementChild();\n        while (el != null) {\n            if (el.nameIs(\"body\") || el.nameIs(\"frameset\"))\n                return el;\n            el = el.nextElementSibling();\n        }\n        return html.appendElement(\"body\");\n    }\n\n    /**\n     Get each of the {@code <form>} elements contained in this document.\n     @return a List of FormElement objects, which will be empty if there are none.\n     @see Elements#forms()\n     @see FormElement#elements()\n     @since 1.15.4\n     */\n    public List<FormElement> forms() {\n        return select(\"form\").forms();\n    }\n\n    /**\n     Selects the first {@link FormElement} in this document that matches the query. If none match, throws an\n     {@link IllegalArgumentException}.\n     @param cssQuery a {@link Selector} CSS query\n     @return the first matching {@code <form>} element\n     @throws IllegalArgumentException if no match is found\n     @since 1.15.4\n     */\n    public FormElement expectForm(String cssQuery) {\n        Elements els = select(cssQuery);\n        for (Element el : els) {\n            if (el instanceof FormElement) return (FormElement) el;\n        }\n        Validate.fail(\"No form elements matched the query '%s' in the document.\", cssQuery);\n        return null; // (not really)\n    }\n\n    /**\n     Get the string contents of the document's {@code title} element.\n     @return Trimmed title, or empty string if none set.\n     */\n    public String title() {\n        // title is a preserve whitespace tag (for document output), but normalised here\n        Element titleEl = head().selectFirst(titleEval);\n        return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : \"\";\n    }\n    private static final Evaluator titleEval = new Evaluator.Tag(\"title\");\n\n    /**\n     Set the document's {@code title} element. Updates the existing element, or adds {@code title} to {@code head} if\n     not present\n     @param title string to set as title\n     */\n    public void title(String title) {\n        Validate.notNull(title);\n        Element titleEl = head().selectFirst(titleEval);\n        if (titleEl == null) // add to head\n            titleEl = head().appendElement(\"title\");\n        titleEl.text(title);\n    }\n\n    /**\n     Create a new Element, with this document's base uri. Does not make the new element a child of this document.\n     @param tagName element tag name (e.g. {@code a})\n     @return new element\n     */\n    public Element createElement(String tagName) {\n        return new Element(Tag.valueOf(tagName, parser.defaultNamespace(), ParseSettings.preserveCase), this.baseUri());\n    }\n\n    @Override\n    public String outerHtml() {\n        return super.html(); // no outer wrapper tag\n    }\n\n    /**\n     Set the text of the {@code body} of this document. Any existing nodes within the body will be cleared.\n     @param text un-encoded text\n     @return this document\n     */\n    @Override\n    public Element text(String text) {\n        body().text(text); // overridden to not nuke doc structure\n        return this;\n    }\n\n    @Override\n    public String nodeName() {\n        return \"#document\";\n    }\n    \n    /**\n     * Sets the charset used in this document. This method is equivalent\n     * to {@link OutputSettings#charset(java.nio.charset.Charset)\n     * OutputSettings.charset(Charset)} but in addition it updates the\n     * charset / encoding element within the document.\n     * \n     * <p>This enables\n     * {@link #updateMetaCharsetElement(boolean) meta charset update}.</p>\n     * \n     * <p>If there's no element with charset / encoding information yet it will\n     * be created. Obsolete charset / encoding definitions are removed!</p>\n     * \n     * <p><b>Elements used:</b></p>\n     * \n     * <ul>\n     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n     * </ul>\n     * \n     * @param charset Charset\n     * \n     * @see #updateMetaCharsetElement(boolean) \n     * @see OutputSettings#charset(java.nio.charset.Charset) \n     */\n    public void charset(Charset charset) {\n        updateMetaCharsetElement(true);\n        outputSettings.charset(charset);\n        ensureMetaCharsetElement();\n    }\n    \n    /**\n     * Returns the charset used in this document. This method is equivalent\n     * to {@link OutputSettings#charset()}.\n     * \n     * @return Current Charset\n     * \n     * @see OutputSettings#charset() \n     */\n    public Charset charset() {\n        return outputSettings.charset();\n    }\n    \n    /**\n     * Sets whether the element with charset information in this document is\n     * updated on changes through {@link #charset(java.nio.charset.Charset)\n     * Document.charset(Charset)} or not.\n     * \n     * <p>If set to <tt>false</tt> <i>(default)</i> there are no elements\n     * modified.</p>\n     * \n     * @param update If <tt>true</tt> the element updated on charset\n     * changes, <tt>false</tt> if not\n     * \n     * @see #charset(java.nio.charset.Charset) \n     */\n    public void updateMetaCharsetElement(boolean update) {\n        this.updateMetaCharset = update;\n    }\n    \n    /**\n     * Returns whether the element with charset information in this document is\n     * updated on changes through {@link #charset(java.nio.charset.Charset)\n     * Document.charset(Charset)} or not.\n     * \n     * @return Returns <tt>true</tt> if the element is updated on charset\n     * changes, <tt>false</tt> if not\n     */\n    public boolean updateMetaCharsetElement() {\n        return updateMetaCharset;\n    }\n\n    @Override\n    public Document clone() {\n        Document clone = (Document) super.clone();\n        clone.outputSettings = this.outputSettings.clone();\n        return clone;\n    }\n\n    @Override\n    public Document shallowClone() {\n        Document clone = new Document(this.tag().namespace(), baseUri());\n        if (attributes != null)\n            clone.attributes = attributes.clone();\n        clone.outputSettings = this.outputSettings.clone();\n        return clone;\n    }\n    \n    /**\n     * Ensures a meta charset (html) or xml declaration (xml) with the current\n     * encoding used. This only applies with\n     * {@link #updateMetaCharsetElement(boolean) updateMetaCharset} set to\n     * <tt>true</tt>, otherwise this method does nothing.\n     * \n     * <ul>\n     * <li>An existing element gets updated with the current charset</li>\n     * <li>If there's no element yet it will be inserted</li>\n     * <li>Obsolete elements are removed</li>\n     * </ul>\n     * \n     * <p><b>Elements used:</b></p>\n     * \n     * <ul>\n     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n     * </ul>\n     */\n    private void ensureMetaCharsetElement() {\n        if (updateMetaCharset) {\n            OutputSettings.Syntax syntax = outputSettings().syntax();\n\n            if (syntax == OutputSettings.Syntax.html) {\n                Element metaCharset = selectFirst(\"meta[charset]\");\n                if (metaCharset != null) {\n                    metaCharset.attr(\"charset\", charset().displayName());\n                } else {\n                    head().appendElement(\"meta\").attr(\"charset\", charset().displayName());\n                }\n                select(\"meta[name=charset]\").remove(); // Remove obsolete elements\n            } else if (syntax == OutputSettings.Syntax.xml) {\n                Node node = ensureChildNodes().get(0);\n                if (node instanceof XmlDeclaration) {\n                    XmlDeclaration decl = (XmlDeclaration) node;\n                    if (decl.name().equals(\"xml\")) {\n                        decl.attr(\"encoding\", charset().displayName());\n                        if (decl.hasAttr(\"version\"))\n                            decl.attr(\"version\", \"1.0\");\n                    } else {\n                        decl = new XmlDeclaration(\"xml\", false);\n                        decl.attr(\"version\", \"1.0\");\n                        decl.attr(\"encoding\", charset().displayName());\n                        prependChild(decl);\n                    }\n                } else {\n                    XmlDeclaration decl = new XmlDeclaration(\"xml\", false);\n                    decl.attr(\"version\", \"1.0\");\n                    decl.attr(\"encoding\", charset().displayName());\n                    prependChild(decl);\n                }\n            }\n        }\n    }\n    \n\n    /**\n     * A Document's output settings control the form of the text() and html() methods.\n     */\n    public static class OutputSettings implements Cloneable {\n        /**\n         * The output serialization syntax.\n         */\n        public enum Syntax {html, xml}\n        private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\n        private Charset charset = DataUtil.UTF_8;\n        private boolean prettyPrint = true;\n        private boolean outline = false;\n        private int indentAmount = 1;\n        private int maxPaddingWidth = 30;\n        private Syntax syntax = Syntax.html;\n\n        /**\n         Create a new OutputSettings object, with the default settings (UTF-8, HTML, EscapeMode.base, pretty-printing,\n         indent amount of 1).\n         */\n        public OutputSettings() {\n        }\n\n        /**\n         Get the document's current entity escape mode:\n         <ul>\n         <li><code>xhtml</code>, the minimal named entities in XHTML / XML</li>\n         <li><code>base</code>, which provides a limited set of named HTML\n         entities and escapes other characters as numbered entities for maximum compatibility</li>\n         <li><code>extended</code>,\n         which uses the complete set of HTML named entities.</li>\n         </ul>\n         <p>The default escape mode is <code>base</code>.\n         @return the document's current escape mode\n         */\n        public Entities.EscapeMode escapeMode() {\n            return escapeMode;\n        }\n\n        /**\n         * Set the document's escape mode, which determines how characters are escaped when the output character set\n         * does not support a given character:- using either a named or a numbered escape.\n         * @param escapeMode the new escape mode to use\n         * @return the document's output settings, for chaining\n         */\n        public OutputSettings escapeMode(Entities.EscapeMode escapeMode) {\n            this.escapeMode = escapeMode;\n            return this;\n        }\n\n        /**\n         * Get the document's current output charset, which is used to control which characters are escaped when\n         * generating HTML (via the <code>html()</code> methods), and which are kept intact.\n         * <p>\n         * Where possible (when parsing from a URL or File), the document's output charset is automatically set to the\n         * input charset. Otherwise, it defaults to UTF-8.\n         * @return the document's current charset.\n         */\n        public Charset charset() {\n            return charset;\n        }\n\n        /**\n         * Update the document's output charset.\n         * @param charset the new charset to use.\n         * @return the document's output settings, for chaining\n         */\n        public OutputSettings charset(Charset charset) {\n            this.charset = charset;\n            return this;\n        }\n\n        /**\n         * Update the document's output charset.\n         * @param charset the new charset (by name) to use.\n         * @return the document's output settings, for chaining\n         */\n        public OutputSettings charset(String charset) {\n            charset(Charset.forName(charset));\n            return this;\n        }\n\n        /**\n         * Get the document's current output syntax.\n         * @return current syntax\n         */\n        public Syntax syntax() {\n            return syntax;\n        }\n\n        /**\n         * Set the document's output syntax. Either {@code html}, with empty tags and boolean attributes (etc), or\n         * {@code xml}, with self-closing tags.\n         * <p>When set to {@link Document.OutputSettings.Syntax#xml xml}, the {@link #escapeMode() escapeMode} is\n         * automatically set to {@link Entities.EscapeMode#xhtml}, but may be subsequently changed if desired.</p>\n         * @param syntax serialization syntax\n         * @return the document's output settings, for chaining\n         */\n        public OutputSettings syntax(Syntax syntax) {\n            this.syntax = syntax;\n            if (syntax == Syntax.xml)\n                this.escapeMode(Entities.EscapeMode.xhtml);\n            return this;\n        }\n\n        /**\n         * Get if pretty printing is enabled. Default is true. If disabled, the HTML output methods will not re-format\n         * the output, and the output will generally look like the input.\n         * @return if pretty printing is enabled.\n         */\n        public boolean prettyPrint() {\n            return prettyPrint;\n        }\n\n        /**\n         * Enable or disable pretty printing.\n         * @param pretty new pretty print setting\n         * @return this, for chaining\n         */\n        public OutputSettings prettyPrint(boolean pretty) {\n            prettyPrint = pretty;\n            return this;\n        }\n        \n        /**\n         * Get if outline mode is enabled. Default is false. If enabled, the HTML output methods will consider\n         * all tags as block.\n         * @return if outline mode is enabled.\n         */\n        public boolean outline() {\n            return outline;\n        }\n        \n        /**\n         * Enable or disable HTML outline mode.\n         * @param outlineMode new outline setting\n         * @return this, for chaining\n         */\n        public OutputSettings outline(boolean outlineMode) {\n            outline = outlineMode;\n            return this;\n        }\n\n        /**\n         * Get the current tag indent amount, used when pretty printing.\n         * @return the current indent amount\n         */\n        public int indentAmount() {\n            return indentAmount;\n        }\n\n        /**\n         * Set the indent amount for pretty printing\n         * @param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.\n         * @return this, for chaining\n         */\n        public OutputSettings indentAmount(int indentAmount) {\n            Validate.isTrue(indentAmount >= 0);\n            this.indentAmount = indentAmount;\n            return this;\n        }\n\n        /**\n         * Get the current max padding amount, used when pretty printing\n         * so very deeply nested nodes don't get insane padding amounts.\n         * @return the current indent amount\n         */\n        public int maxPaddingWidth() {\n            return maxPaddingWidth;\n        }\n\n        /**\n         * Set the max padding amount for pretty printing so very deeply nested nodes don't get insane padding amounts.\n         * @param maxPaddingWidth number of spaces to use for indenting each level of nested nodes. Must be {@literal >=} -1.\n         *        Default is 30 and -1 means unlimited.\n         * @return this, for chaining\n         */\n        public OutputSettings maxPaddingWidth(int maxPaddingWidth) {\n            Validate.isTrue(maxPaddingWidth >= -1);\n            this.maxPaddingWidth = maxPaddingWidth;\n            return this;\n        }\n\n        @Override\n        public OutputSettings clone() {\n            OutputSettings clone;\n            try {\n                clone = (OutputSettings) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n            clone.charset(charset.name()); // new charset, coreCharset, and charset encoder\n            clone.escapeMode = Entities.EscapeMode.valueOf(escapeMode.name());\n            // indentAmount, maxPaddingWidth, and prettyPrint are primitives so object.clone() will handle\n            return clone;\n        }\n    }\n\n    /**\n     * Get the document's current output settings.\n     * @return the document's current output settings.\n     */\n    public OutputSettings outputSettings() {\n        return outputSettings;\n    }\n\n    /**\n     * Set the document's output settings.\n     * @param outputSettings new output settings.\n     * @return this document, for chaining.\n     */\n    public Document outputSettings(OutputSettings outputSettings) {\n        Validate.notNull(outputSettings);\n        this.outputSettings = outputSettings;\n        return this;\n    }\n\n    public enum QuirksMode {\n        noQuirks, quirks, limitedQuirks\n    }\n\n    public QuirksMode quirksMode() {\n        return quirksMode;\n    }\n\n    public Document quirksMode(QuirksMode quirksMode) {\n        this.quirksMode = quirksMode;\n        return this;\n    }\n\n    /**\n     * Get the parser that was used to parse this document.\n     * @return the parser\n     */\n    public Parser parser() {\n        return parser;\n    }\n\n    /**\n     * Set the parser used to create this document. This parser is then used when further parsing within this document\n     * is required.\n     * @param parser the configured parser to use when further parsing is required for this document.\n     * @return this document, for chaining.\n     */\n    public Document parser(Parser parser) {\n        this.parser = parser;\n        return this;\n    }\n\n    /**\n     Set the Connection used to fetch this document. This Connection is used as a session object when further requests are\n     made (e.g. when a form is submitted).\n\n     @param connection to set\n     @return this document, for chaining\n     @see Connection#newRequest()\n     @since 1.14.1\n     */\n    public Document connection(Connection connection) {\n        Validate.notNull(connection);\n        this.connection = connection;\n        return this;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private @Nullable Connection connection;", "docstring": "", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Connection", "name": "connection", "syntax_pass": true}, {"attribute_expression": "private OutputSettings outputSettings = new OutputSettings();", "docstring": " the connection this doc was fetched from, if any", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OutputSettings", "name": "outputSettings = new OutputSettings()", "syntax_pass": true}, {"attribute_expression": "private Parser parser;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Parser", "name": "parser", "syntax_pass": true}, {"attribute_expression": "private QuirksMode quirksMode = QuirksMode.noQuirks;", "docstring": " the parser used to parse this document", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "QuirksMode", "name": "quirksMode = QuirksMode.noQuirks", "syntax_pass": true}, {"attribute_expression": "private final String location;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "location", "syntax_pass": true}, {"attribute_expression": "private boolean updateMetaCharset = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "updateMetaCharset = false", "syntax_pass": true}, {"attribute_expression": "private static final Evaluator titleEval = new Evaluator.Tag(\"title\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Evaluator", "name": "titleEval = new Evaluator.Tag(\"title\")", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration", "name": "XmlDeclaration", "file_path": "src/main/java/org/jsoup/nodes/XmlDeclaration.java", "superclasses": "LeafNode", "methods": ["[]XmlDeclaration(String,boolean)", "[String]nodeName()", "[String]name()", "[String]getWholeDeclaration()", "[void]getWholeDeclaration(Appendable,Document.OutputSettings)", "[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "[String]toString()", "[XmlDeclaration]clone()"], "method_uris": ["src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[]XmlDeclaration(String,boolean)", "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[String]nodeName()", "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[String]name()", "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[String]getWholeDeclaration()", "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[void]getWholeDeclaration(Appendable,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[String]toString()", "src/main/java/org/jsoup/nodes/XmlDeclaration.java.XmlDeclaration.[XmlDeclaration]clone()"], "overrides": null, "attributes": [], "class_docstring": "\nAn XML Declaration.\n", "original_string": "public class XmlDeclaration extends LeafNode {\n    // todo this impl isn't really right, the data shouldn't be attributes, just a run of text after the name\n    private final boolean isProcessingInstruction; // <! if true, <? if false, declaration (and last data char should be ?)\n\n    /**\n     * Create a new XML declaration\n     * @param name of declaration\n     * @param isProcessingInstruction is processing instruction\n     */\n    public XmlDeclaration(String name, boolean isProcessingInstruction) {\n        super(name);\n        this.isProcessingInstruction = isProcessingInstruction;\n    }\n\n    @Override public String nodeName() {\n        return \"#declaration\";\n    }\n\n    /**\n     * Get the name of this declaration.\n     * @return name of this declaration.\n     */\n    public String name() {\n        return coreValue();\n    }\n\n    /**\n     * Get the unencoded XML declaration.\n     * @return XML declaration\n     */\n    public String getWholeDeclaration() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            getWholeDeclaration(sb, new Document.OutputSettings());\n        } catch (IOException e) {\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb).trim();\n    }\n\n    private void getWholeDeclaration(Appendable accum, Document.OutputSettings out) throws IOException {\n        for (Attribute attribute : attributes()) {\n            String key = attribute.getKey();\n            String val = attribute.getValue();\n            if (!key.equals(nodeName())) { // skips coreValue (name)\n                accum.append(' ');\n                // basically like Attribute, but skip empty vals in XML\n                accum.append(key);\n                if (!val.isEmpty()) {\n                    accum.append(\"=\\\"\");\n                    Entities.escape(accum, val, out, Entities.ForAttribute);\n                    accum.append('\"');\n                }\n            }\n        }\n    }\n\n    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum\n            .append(\"<\")\n            .append(isProcessingInstruction ? \"!\" : \"?\")\n            .append(coreValue());\n        getWholeDeclaration(accum, out);\n        accum\n            .append(isProcessingInstruction ? \"!\" : \"?\")\n            .append(\">\");\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n    }\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public XmlDeclaration clone() {\n        return (XmlDeclaration) super.clone();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final boolean isProcessingInstruction;", "docstring": " todo this impl isn't really right, the data shouldn't be attributes, just a run of text after the name", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "isProcessingInstruction", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/Attribute.java.Attribute", "name": "Attribute", "file_path": "src/main/java/org/jsoup/nodes/Attribute.java", "superclasses": "", "methods": ["[]Attribute(String,String)", "[]Attribute(String,String,Attributes)", "[String]getKey()", "[void]setKey(String)", "[String]getValue()", "[boolean]hasDeclaredValue()", "[String]setValue(String)", "[String]html()", "[Range.AttributeRange]sourceRange()", "[void]html(Appendable,Document.OutputSettings)", "[void]html(String,String,Appendable,Document.OutputSettings)", "[void]htmlNoValidate(String,String,Appendable,Document.OutputSettings)", "[String]getValidKey(String,Syntax)", "[boolean]isValidXmlKey(String)", "[boolean]isValidHtmlKey(String)", "[String]toString()", "[Attribute]createFromEncoded(String,String)", "[boolean]isDataAttribute()", "[boolean]isDataAttribute(String)", "[boolean]shouldCollapseAttribute(Document.OutputSettings)", "[boolean]shouldCollapseAttribute(String,String,Document.OutputSettings)", "[boolean]isBooleanAttribute(String)", "[boolean]equals(Object)", "[int]hashCode()", "[Attribute]clone()"], "method_uris": ["src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[]Attribute(String,String)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[]Attribute(String,String,Attributes)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]getKey()", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[void]setKey(String)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]getValue()", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]hasDeclaredValue()", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]setValue(String)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]html()", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[Range.AttributeRange]sourceRange()", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[void]html(Appendable,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[void]html(String,String,Appendable,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[void]htmlNoValidate(String,String,Appendable,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]getValidKey(String,Syntax)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isValidXmlKey(String)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isValidHtmlKey(String)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[String]toString()", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[Attribute]createFromEncoded(String,String)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isDataAttribute()", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isDataAttribute(String)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]shouldCollapseAttribute(Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]shouldCollapseAttribute(String,String,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]isBooleanAttribute(String)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[boolean]equals(Object)", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[int]hashCode()", "src/main/java/org/jsoup/nodes/Attribute.java.Attribute.[Attribute]clone()"], "overrides": null, "attributes": [], "class_docstring": "\nA single key + value attribute. (Only used for presentation.)\n", "original_string": "public class Attribute implements Map.Entry<String, String>, Cloneable  {\n    private static final String[] booleanAttributes = {\n            \"allowfullscreen\", \"async\", \"autofocus\", \"checked\", \"compact\", \"declare\", \"default\", \"defer\", \"disabled\",\n            \"formnovalidate\", \"hidden\", \"inert\", \"ismap\", \"itemscope\", \"multiple\", \"muted\", \"nohref\", \"noresize\",\n            \"noshade\", \"novalidate\", \"nowrap\", \"open\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\",\n            \"sortable\", \"truespeed\", \"typemustmatch\"\n    };\n\n    private String key;\n    @Nullable private String val;\n    @Nullable Attributes parent; // used to update the holding Attributes when the key / value is changed via this interface\n\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param value attribute value (may be null)\n     * @see #createFromEncoded\n     */\n    public Attribute(String key, @Nullable String value) {\n        this(key, value, null);\n    }\n\n    /**\n     * Create a new attribute from unencoded (raw) key and value.\n     * @param key attribute key; case is preserved.\n     * @param val attribute value (may be null)\n     * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n     * @see #createFromEncoded*/\n    public Attribute(String key, @Nullable String val, @Nullable Attributes parent) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        this.key = key;\n        this.val = val;\n        this.parent = parent;\n    }\n\n    /**\n     Get the attribute key.\n     @return the attribute key\n     */\n    @Override\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                String oldKey = parent.keys[i];\n                parent.keys[i] = key;\n\n                // if tracking source positions, update the key in the range map\n                Map<String, Range.AttributeRange> ranges = parent.getRanges();\n                if (ranges != null) {\n                    Range.AttributeRange range = ranges.remove(oldKey);\n                    ranges.put(key, range);\n                }\n            }\n        }\n        this.key = key;\n    }\n\n    /**\n     Get the attribute value. Will return an empty string if the value is not set.\n     @return the attribute value\n     */\n    @Override\n    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }\n\n    /**\n     * Check if this Attribute has a value. Set boolean attributes have no value.\n     * @return if this is a boolean attribute / attribute without a value\n     */\n    public boolean hasDeclaredValue() {\n        return val != null;\n    }\n\n    /**\n     Set the attribute value.\n     @param val the new attribute value; may be null (to set an enabled boolean attribute)\n     @return the previous value (if was null; an empty string)\n     */\n    @Override public String setValue(@Nullable String val) {\n        String oldVal = this.val;\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound) {\n                oldVal = parent.get(this.key); // trust the container more\n                parent.vals[i] = val;\n            }\n        }\n        this.val = val;\n        return Attributes.checkNotNull(oldVal);\n    }\n\n    /**\n     Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n     @return HTML\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        \n        try {\n        \thtml(sb, (new Document(\"\")).outputSettings());\n        } catch(IOException exception) {\n        \tthrow new SerializationException(exception);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    /**\n     Get the source ranges (start to end positions) in the original input source from which this attribute's <b>name</b>\n     and <b>value</b> were parsed.\n     <p>Position tracking must be enabled prior to parsing the content.</p>\n     @return the ranges for the attribute's name and value, or {@code untracked} if the attribute does not exist or its range\n     was not tracked.\n     @see org.jsoup.parser.Parser#setTrackPosition(boolean)\n     @see Attributes#sourceRange(String)\n     @see Node#sourceRange()\n     @see Element#endSourceRange()\n     @since 1.17.1\n     */\n    public Range.AttributeRange sourceRange() {\n        if (parent == null) return Range.AttributeRange.UntrackedAttr;\n        return parent.sourceRange(key);\n    }\n\n    protected void html(Appendable accum, Document.OutputSettings out) throws IOException {\n        html(key, val, accum, out);\n    }\n\n    protected static void html(String key, @Nullable String val, Appendable accum, Document.OutputSettings out) throws IOException {\n        key = getValidKey(key, out.syntax());\n        if (key == null) return; // can't write it :(\n        htmlNoValidate(key, val, accum, out);\n    }\n\n    static void htmlNoValidate(String key, @Nullable String val, Appendable accum, Document.OutputSettings out) throws IOException {\n        // structured like this so that Attributes can check we can write first, so it can add whitespace correctly\n        accum.append(key);\n        if (!shouldCollapseAttribute(key, val, out)) {\n            accum.append(\"=\\\"\");\n            Entities.escape(accum, Attributes.checkNotNull(val), out, Entities.ForAttribute); // preserves whitespace\n            accum.append('\"');\n        }\n    }\n\n    private static final Pattern xmlKeyReplace = Pattern.compile(\"[^-a-zA-Z0-9_:.]+\");\n    private static final Pattern htmlKeyReplace = Pattern.compile(\"[\\\\x00-\\\\x1f\\\\x7f-\\\\x9f \\\"'/=]+\");\n    /**\n     * Get a valid attribute key for the given syntax. If the key is not valid, it will be coerced into a valid key.\n     * @param key the original attribute key\n     * @param syntax HTML or XML\n     * @return the original key if it's valid; a key with invalid characters replaced with \"_\" otherwise; or null if a valid key could not be created.\n     */\n    @Nullable public static String getValidKey(String key, Syntax syntax) {\n        if (syntax == Syntax.xml && !isValidXmlKey(key)) {\n            key = xmlKeyReplace.matcher(key).replaceAll(\"_\");\n            return isValidXmlKey(key) ? key : null; // null if could not be coerced\n        }\n        else if (syntax == Syntax.html && !isValidHtmlKey(key)) {\n            key = htmlKeyReplace.matcher(key).replaceAll(\"_\");\n            return isValidHtmlKey(key) ? key : null; // null if could not be coerced\n        }\n        return key;\n    }\n\n    // perf critical in html() so using manual scan vs regex:\n    // note that we aren't using anything in supplemental space, so OK to iter charAt\n    private static boolean isValidXmlKey(String key) {\n        // =~ [a-zA-Z_:][-a-zA-Z0-9_:.]*\n        final int length = key.length();\n        if (length ==0) return false;\n        char c = key.charAt(0);\n        if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == ':'))\n            return false;\n        for (int i = 1; i < length; i++) {\n            c = key.charAt(i);\n            if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == ':'))\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean isValidHtmlKey(String key) {\n        // =~ [\\x00-\\x1f\\x7f-\\x9f \"'/=]+\n        final int length = key.length();\n        if (length ==0) return false;\n        for (int i = 0; i < length; i++) {\n            char c = key.charAt(i);\n            if (c <= 0x1f || c >= 0x7f && c <= 0x9f || c == ' ' || c == '\"' || c == '\\'' || c == '/' || c == '=')\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     Get the string representation of this attribute, implemented as {@link #html()}.\n     @return string\n     */\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Create a new Attribute from an unencoded key and a HTML attribute encoded value.\n     * @param unencodedKey assumes the key is not encoded, as can be only run of simple \\w chars.\n     * @param encodedValue HTML attribute encoded value\n     * @return attribute\n     */\n    public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {\n        String value = Entities.unescape(encodedValue, true);\n        return new Attribute(unencodedKey, value, null); // parent will get set when Put\n    }\n\n    protected boolean isDataAttribute() {\n        return isDataAttribute(key);\n    }\n\n    protected static boolean isDataAttribute(String key) {\n        return key.startsWith(Attributes.dataPrefix) && key.length() > Attributes.dataPrefix.length();\n    }\n\n    /**\n     * Collapsible if it's a boolean attribute and value is empty or same as name\n     * \n     * @param out output settings\n     * @return  Returns whether collapsible or not\n     */\n    protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n        return shouldCollapseAttribute(key, val, out);\n    }\n\n    // collapse unknown foo=null, known checked=null, checked=\"\", checked=checked; write out others\n    protected static boolean shouldCollapseAttribute(final String key, @Nullable final String val, final Document.OutputSettings out) {\n        return (\n            out.syntax() == Syntax.html &&\n                (val == null || (val.isEmpty() || val.equalsIgnoreCase(key)) && Attribute.isBooleanAttribute(key)));\n    }\n\n    /**\n     * Checks if this attribute name is defined as a boolean attribute in HTML5\n     */\n    public static boolean isBooleanAttribute(final String key) {\n        return Arrays.binarySearch(booleanAttributes, Normalizer.lowerCase(key)) >= 0;\n    }\n\n    @Override\n    public boolean equals(@Nullable Object o) { // note parent not considered\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Attribute attribute = (Attribute) o;\n        return Objects.equals(key, attribute.key) && Objects.equals(val, attribute.val);\n    }\n\n    @Override\n    public int hashCode() { // note parent not considered\n        return Objects.hash(key, val);\n    }\n\n    @Override\n    public Attribute clone() {\n        try {\n            return (Attribute) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}", "super_interfaces": ["Map.Entry<String, String>", "Cloneable"], "fields": [{"attribute_expression": "private static final String[] booleanAttributes = {\n            \"allowfullscreen\", \"async\", \"autofocus\", \"checked\", \"compact\", \"declare\", \"default\", \"defer\", \"disabled\",\n            \"formnovalidate\", \"hidden\", \"inert\", \"ismap\", \"itemscope\", \"multiple\", \"muted\", \"nohref\", \"noresize\",\n            \"noshade\", \"novalidate\", \"nowrap\", \"open\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\",\n            \"sortable\", \"truespeed\", \"typemustmatch\"\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "booleanAttributes = {\n            \"allowfullscreen\", \"async\", \"autofocus\", \"checked\", \"compact\", \"declare\", \"default\", \"defer\", \"disabled\",\n            \"formnovalidate\", \"hidden\", \"inert\", \"ismap\", \"itemscope\", \"multiple\", \"muted\", \"nohref\", \"noresize\",\n            \"noshade\", \"novalidate\", \"nowrap\", \"open\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\",\n            \"sortable\", \"truespeed\", \"typemustmatch\"\n    }", "syntax_pass": true}, {"attribute_expression": "private String key;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "key", "syntax_pass": true}, {"attribute_expression": "@Nullable private String val;", "docstring": "", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "val", "syntax_pass": true}, {"attribute_expression": "@Nullable Attributes parent;", "docstring": "", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "Attributes", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private static final Pattern xmlKeyReplace = Pattern.compile(\"[^-a-zA-Z0-9_:.]+\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "xmlKeyReplace = Pattern.compile(\"[^-a-zA-Z0-9_:.]+\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern htmlKeyReplace = Pattern.compile(\"[\\\\x00-\\\\x1f\\\\x7f-\\\\x9f \\\"'/=]+\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "htmlKeyReplace = Pattern.compile(\"[\\\\x00-\\\\x1f\\\\x7f-\\\\x9f \\\"'/=]+\")", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/Attributes.java.Attributes", "name": "Attributes", "file_path": "src/main/java/org/jsoup/nodes/Attributes.java", "superclasses": "", "methods": ["[void]checkCapacity(int)", "[int]indexOfKey(String)", "[int]indexOfKeyIgnoreCase(String)", "[String]checkNotNull(Object)", "[String]get(String)", "[Attribute]attribute(String)", "[String]getIgnoreCase(String)", "[Attributes]add(String,String)", "[void]addObject(String,Object)", "[Attributes]put(String,String)", "[Map<String, Object>]userData()", "[Object]userData(String)", "[Attributes]userData(String,Object)", "[void]putIgnoreCase(String,String)", "[Attributes]put(String,boolean)", "[Attributes]put(Attribute)", "[void]remove(int)", "[void]remove(String)", "[void]removeIgnoreCase(String)", "[boolean]hasKey(String)", "[boolean]hasKeyIgnoreCase(String)", "[boolean]hasDeclaredValueForKey(String)", "[boolean]hasDeclaredValueForKeyIgnoreCase(String)", "[int]size()", "[boolean]isEmpty()", "[void]addAll(Attributes)", "[Range.AttributeRange]sourceRange(String)", "[Map<String, Range.AttributeRange>]getRanges()", "[Iterator<Attribute>]iterator()", "[List<Attribute>]asList()", "[Map<String, String>]dataset()", "[String]html()", "[void]html(Appendable,Document.OutputSettings)", "[String]toString()", "[boolean]equals(Object)", "[int]hashCode()", "[Attributes]clone()", "[void]normalize()", "[int]deduplicate(ParseSettings)", "[String]dataKey(String)", "[String]internalKey(String)", "[boolean]isInternalKey(String)"], "method_uris": ["src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]checkCapacity(int)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]indexOfKey(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]indexOfKeyIgnoreCase(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]checkNotNull(Object)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]get(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attribute]attribute(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]getIgnoreCase(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]add(String,String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]addObject(String,Object)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]put(String,String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Map<String, Object>]userData()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Object]userData(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]userData(String,Object)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]putIgnoreCase(String,String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]put(String,boolean)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]put(Attribute)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]remove(int)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]remove(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]removeIgnoreCase(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]hasKey(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]hasKeyIgnoreCase(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]hasDeclaredValueForKey(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]hasDeclaredValueForKeyIgnoreCase(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]size()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]isEmpty()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]addAll(Attributes)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Range.AttributeRange]sourceRange(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Map<String, Range.AttributeRange>]getRanges()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Iterator<Attribute>]iterator()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[List<Attribute>]asList()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Map<String, String>]dataset()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]html()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]html(Appendable,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]toString()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]equals(Object)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]hashCode()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[Attributes]clone()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[void]normalize()", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[int]deduplicate(ParseSettings)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]dataKey(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[String]internalKey(String)", "src/main/java/org/jsoup/nodes/Attributes.java.Attributes.[boolean]isInternalKey(String)"], "overrides": null, "attributes": [{"original_string": "    private static class Dataset extends AbstractMap<String, String> {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator<Entry<String, String>> iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private final Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            @Override public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            @Override public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            @Override public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }", "definition": "    private static class Dataset extends AbstractMap<String, String>", "class_docstring": "", "name": "Dataset", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Attributes attributes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Attributes", "name": "attributes", "syntax_pass": true}], "classes": [{"original_string": "        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator<Entry<String, String>> iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }", "definition": "        private class EntrySet extends AbstractSet<Map.Entry<String, String>>", "class_docstring": "", "name": "EntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<String, String>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                                  {\n                return new DatasetIterator();\n            }", "signature": "@Override\n            public Iterator<Map.Entry<String, String>> iterator()"}, {"syntax_pass": true, "original_string": "            @Override\n            public int size() {\n                int count = 0;\n                Iterator<Entry<String, String>> iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                              {\n                int count = 0;\n                Iterator<Entry<String, String>> iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }", "signature": "@Override\n            public int size()"}]}, {"original_string": "        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private final Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            @Override public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            @Override public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            @Override public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }", "definition": "        private class DatasetIterator implements Iterator<Map.Entry<String, String>>", "class_docstring": "", "name": "DatasetIterator", "super_interfaces": ["Iterator<Map.Entry<String, String>>"], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private final Iterator<Attribute> attrIter = attributes.iterator();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<Attribute>", "name": "attrIter = attributes.iterator()", "syntax_pass": true}, {"attribute_expression": "private Attribute attr;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Attribute", "name": "attr", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            @Override public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                               {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }", "signature": "@Override public boolean hasNext()"}, {"syntax_pass": true, "original_string": "            @Override public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry<String, String>", "classes": []}, "name": "next", "params": [], "body": "                                                          {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }", "signature": "@Override public Entry<String, String> next()"}, {"syntax_pass": true, "original_string": "            @Override public void remove() {\n                attributes.remove(attr.getKey());\n            }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                                           {\n                attributes.remove(attr.getKey());\n            }", "signature": "@Override public void remove()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Dataset", "params": [{"name": "attributes", "type": "Attributes"}], "body": "                                               {\n            this.attributes = attributes;\n        }", "signature": "private Dataset(Attributes attributes)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Entry<String, String>>", "classes": []}, "name": "entrySet", "params": [], "body": "                                                     {\n            return new EntrySet();\n        }", "signature": "@Override\n        public Set<Entry<String, String>> entrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "put", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                    {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }", "signature": "@Override\n        public String put(String key, String value)"}]}], "class_docstring": "\nThe attributes of an Element.\n<p>\nDuring parsing, attributes in with the same name in an element are deduplicated, according to the configured parser's\nattribute case-sensitive setting. It is possible to have duplicate attributes subsequently if\n{@link #add(String, String)} vs {@link #put(String, String)} is used.\n</p>\n<p>\nAttribute name and value comparisons are generally <b>case sensitive</b>. By default for HTML, attribute names are\nnormalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\nname.\n</p>\n\n@author Jonathan Hedley, jonathan@hedley.net\n", "original_string": "public class Attributes implements Iterable<Attribute>, Cloneable {\n    // Indicates an internal key. Can't be set via HTML. (It could be set via accessor, but not too worried about\n    // that. Suppressed from list, iter.)\n    static final char InternalPrefix = '/';\n\n    // The Attributes object is only created on the first use of an attribute; the Element will just have a null\n    // Attribute slot otherwise\n    protected static final String dataPrefix = \"data-\";\n    private static final int InitialCapacity = 3; // sampling found mean count when attrs present = 1.49; 1.08 overall. 2.6:1 don't have any attrs.\n\n    // manages the key/val arrays\n    private static final int GrowthFactor = 2;\n    static final int NotFound = -1;\n    private static final String EmptyString = \"\";\n\n    // the number of instance fields is kept as low as possible giving an object size of 24 bytes\n    private int size = 0; // number of slots used (not total capacity, which is keys.length)\n    @Nullable String[] keys = new String[InitialCapacity]; // keys is not null, but contents may be. Same for vals\n    @Nullable Object[] vals = new Object[InitialCapacity]; // Genericish: all non-internal attribute values must be Strings and are cast on access.\n    // todo - make keys iterable without creating Attribute objects\n\n    // check there's room for more\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize >= size);\n        int curCap = keys.length;\n        if (curCap >= minNewSize)\n            return;\n        int newCap = curCap >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize > newCap)\n            newCap = minNewSize;\n\n        keys = Arrays.copyOf(keys, newCap);\n        vals = Arrays.copyOf(vals, newCap);\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i = 0; i < size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    // we track boolean attributes as null in values - they're just keys. so returns empty for consumers\n    // casts to String, so only for non-internal attributes\n    static String checkNotNull(@Nullable Object val) {\n        return val == null ? EmptyString : (String) val;\n    }\n\n    /**\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     */\n    public String get(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     Get an Attribute by key. The Attribute will remain connected to these Attributes, so changes made via\n     {@link Attribute#setKey(String)}, {@link Attribute#setValue(String)} etc will cascade back to these Attributes and\n     their owning Element.\n     @param key the (case-sensitive) attribute key\n     @return the Attribute for this key, or null if not present.\n     @since 1.17.2\n     */\n    @Nullable public Attribute attribute(String key) {\n        int i = indexOfKey(key);\n        return i == NotFound ? null : new Attribute(key, checkNotNull(vals[i]), this);\n    }\n\n    /**\n     * Get an attribute's value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     */\n    public String getIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i == NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */\n    public Attributes add(String key, @Nullable String value) {\n        addObject(key, value);\n        return this;\n    }\n\n    private void addObject(String key, @Nullable Object value) {\n        checkCapacity(size + 1);\n        keys[size] = key;\n        vals[size] = value;\n        size++;\n    }\n\n    /**\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key (not null)\n     * @param value attribute value (which can be null, to set a true boolean attribute)\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, @Nullable String value) {\n        Validate.notNull(key);\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            vals[i] = value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    /**\n     Get the map holding any user-data associated with these Attributes. Will be created empty on first use. Held as\n     an internal attribute, not a field member, to reduce the memory footprint of Attributes when not used. Can hold\n     arbitrary objects; use for source ranges, connecting W3C nodes to Elements, etc.\n     * @return the map holding user-data\n     */\n    Map<String, Object> userData() {\n        final Map<String, Object> userData;\n        int i = indexOfKey(SharedConstants.UserDataKey);\n        if (i == NotFound) {\n            userData = new HashMap<>();\n            addObject(SharedConstants.UserDataKey, userData);\n        } else {\n            //noinspection unchecked\n            userData = (Map<String, Object>) vals[i];\n        }\n        assert userData != null;\n        return userData;\n    }\n\n    /**\n     Get an arbitrary user-data object by key.\n     * @param key case-sensitive key to the object.\n     * @return the object associated to this key, or {@code null} if not found.\n     * @see #userData(String key, Object val)\n     * @since 1.17.1\n     */\n    @Nullable\n    public Object userData(String key) {\n        Validate.notNull(key);\n        if (!hasKey(SharedConstants.UserDataKey)) return null; // no user data exists\n        Map<String, Object> userData = userData();\n        return userData.get(key);\n    }\n\n    /**\n     Set an arbitrary user-data object by key. Will be treated as an internal attribute, so will not be emitted in HTML.\n     * @param key case-sensitive key\n     * @param value object value\n     * @return these attributes\n     * @see #userData(String key)\n     * @since 1.17.1\n     */\n    public Attributes userData(String key, Object value) {\n        Validate.notNull(key);\n        userData().put(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, @Nullable String value) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound) {\n            vals[i] = value;\n            String old = keys[i];\n            assert old != null;\n            if (!old.equals(key)) // case changed, update\n                keys[i] = key;\n        }\n        else\n            add(key, value);\n    }\n\n    /**\n     * Set a new boolean attribute. Removes the attribute if the value is false.\n     * @param key case <b>insensitive</b> attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    /**\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case-sensitive key\n     @return these attributes, for chaining\n     */\n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent = this;\n        return this;\n    }\n\n    // removes and shifts up\n    @SuppressWarnings(\"AssignmentToNull\")\n    private void remove(int index) {\n        Validate.isFalse(index >= size);\n        int shifted = size - index - 1;\n        if (shifted > 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] = null; // release hold\n        vals[size] = null;\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        int i = indexOfKey(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        if (i != NotFound)\n            remove(i);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return indexOfKey(key) != NotFound;\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) != NotFound;\n    }\n\n    /**\n     * Check if these attributes contain an attribute with a value for this key.\n     * @param key key to check for\n     * @return true if key exists, and it has a value\n     */\n    public boolean hasDeclaredValueForKey(String key) {\n        int i = indexOfKey(key);\n        return i != NotFound && vals[i] != null;\n    }\n\n    /**\n     * Check if these attributes contain an attribute with a value for this key.\n     * @param key case-insensitive key to check for\n     * @return true if key exists, and it has a value\n     */\n    public boolean hasDeclaredValueForKeyIgnoreCase(String key) {\n        int i = indexOfKeyIgnoreCase(key);\n        return i != NotFound && vals[i] != null;\n    }\n\n    /**\n     Get the number of attributes in this set, including any jsoup internal-only attributes. Internal attributes are\n     excluded from the {@link #html()}, {@link #asList()}, and {@link #iterator()} methods.\n     @return size\n     */\n    public int size() {\n        return size;\n        // todo - exclude internal attributes from this count - maintain size, count of internals\n    }\n\n    /**\n     * Test if this Attributes list is empty (size==0).\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     */\n    public void addAll(Attributes incoming) {\n        if (incoming.size() == 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        boolean needsPut = size != 0; // if this set is empty, no need to check existing set, so can add() vs put()\n        // (and save bashing on the indexOfKey()\n        for (Attribute attr : incoming) {\n            if (needsPut)\n                put(attr);\n            else\n                add(attr.getKey(), attr.getValue());\n        }\n    }\n\n    /**\n     Get the source ranges (start to end position) in the original input source from which this attribute's <b>name</b>\n     and <b>value</b> were parsed.\n     <p>Position tracking must be enabled prior to parsing the content.</p>\n     @param key the attribute name\n     @return the ranges for the attribute's name and value, or {@code untracked} if the attribute does not exist or its range\n     was not tracked.\n     @see org.jsoup.parser.Parser#setTrackPosition(boolean)\n     @see Attribute#sourceRange()\n     @see Node#sourceRange()\n     @see Element#endSourceRange()\n     @since 1.17.1\n     */\n    public Range.AttributeRange sourceRange(String key) {\n        if (!hasKey(key)) return UntrackedAttr;\n        Map<String, Range.AttributeRange> ranges = getRanges();\n        if (ranges == null) return Range.AttributeRange.UntrackedAttr;\n        Range.AttributeRange range = ranges.get(key);\n        return range != null ? range : Range.AttributeRange.UntrackedAttr;\n    }\n\n    /** Get the Ranges, if tracking is enabled; null otherwise. */\n    @Nullable Map<String, Range.AttributeRange> getRanges() {\n        //noinspection unchecked\n        return (Map<String, Range.AttributeRange>) userData(AttrRangeKey);\n    }\n\n\n    @Override\n    public Iterator<Attribute> iterator() {\n        //noinspection ReturnOfInnerClass\n        return new Iterator<Attribute>() {\n            int expectedSize = size;\n            int i = 0;\n\n            @Override\n            public boolean hasNext() {\n                checkModified();\n                while (i < size) {\n                    String key = keys[i];\n                    assert key != null;\n                    if (isInternalKey(key)) // skip over internal keys\n                        i++;\n                    else\n                        break;\n                }\n\n                return i < size;\n            }\n\n            @Override\n            public Attribute next() {\n                checkModified();\n                if (i >= size) throw new NoSuchElementException();\n                String key = keys[i];\n                assert key != null;\n                final Attribute attr = new Attribute(key, (String) vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            private void checkModified() {\n                if (size != expectedSize) throw new ConcurrentModificationException(\"Use Iterator#remove() instead to remove attributes while iterating.\");\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n                expectedSize--;\n            }\n        };\n    }\n\n    /**\n     Get the attributes as a List, for iteration.\n     @return a view of the attributes as an unmodifiable List.\n     */\n    public List<Attribute> asList() {\n        ArrayList<Attribute> list = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            String key = keys[i];\n            assert key != null;\n            if (isInternalKey(key))\n                continue; // skip internal keys\n            Attribute attr = new Attribute(key, (String) vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     */\n    public Map<String, String> dataset() {\n        return new Dataset(this);\n    }\n\n    /**\n     Get the HTML representation of these attributes.\n     @return HTML\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz = size;\n        for (int i = 0; i < sz; i++) {\n            String key = keys[i];\n            assert key != null;\n            if (isInternalKey(key))\n                continue;\n            final String validated = Attribute.getValidKey(key, out.syntax());\n            if (validated != null)\n                Attribute.htmlNoValidate(validated, (String) vals[i], accum.append(' '), out);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets. Note that the order\n     * of the attributes does not impact this equality (as per the Map interface equals()).\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     */\n    @Override\n    public boolean equals(@Nullable Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Attributes that = (Attributes) o;\n        if (size != that.size) return false;\n        for (int i = 0; i < size; i++) {\n            String key = keys[i];\n            assert key != null;\n            int thatI = that.indexOfKey(key);\n            if (thatI == NotFound || !Objects.equals(vals[i], that.vals[thatI]))\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result = size;\n        result = 31 * result + Arrays.hashCode(keys);\n        result = 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone = (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size = size;\n        clone.keys = Arrays.copyOf(keys, size);\n        clone.vals = Arrays.copyOf(vals, size);\n        return clone;\n    }\n\n    /**\n     * Internal method. Lowercases all (non-internal) keys.\n     */\n    public void normalize() {\n        for (int i = 0; i < size; i++) {\n            assert keys[i] != null;\n            String key = keys[i];\n            assert key != null;\n            if (!isInternalKey(key))\n                keys[i] = lowerCase(key);\n        }\n    }\n\n    /**\n     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n     * @param settings case sensitivity\n     * @return number of removed dupes\n     */\n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve = settings.preserveAttributeCase();\n        int dupes = 0;\n        for (int i = 0; i < size; i++) {\n            String keyI = keys[i];\n            assert keyI != null;\n            for (int j = i + 1; j < size; j++) {\n                if ((preserve && keyI.equals(keys[j])) || (!preserve && keyI.equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap<String, String> {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes = attributes;\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey = dataKey(key);\n            String oldValue = attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n\n            @Override\n            public Iterator<Map.Entry<String, String>> iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count = 0;\n                Iterator<Entry<String, String>> iter = new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator<Map.Entry<String, String>> {\n            private final Iterator<Attribute> attrIter = attributes.iterator();\n            private Attribute attr;\n            @Override public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr = attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            @Override public Entry<String, String> next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            @Override public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n\n    static String internalKey(String key) {\n        return InternalPrefix + key;\n    }\n\n    static boolean isInternalKey(String key) {\n        return key.length() > 1 && key.charAt(0) == InternalPrefix;\n    }\n}", "super_interfaces": ["Iterable<Attribute>", "Cloneable"], "fields": [{"attribute_expression": "static final char InternalPrefix = '/';", "docstring": " that. Suppressed from list, iter.)", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "InternalPrefix = '/'", "syntax_pass": true}, {"attribute_expression": "protected static final String dataPrefix = \"data-\";", "docstring": " Attribute slot otherwise", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "dataPrefix = \"data-\"", "syntax_pass": true}, {"attribute_expression": "private static final int InitialCapacity = 3;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "InitialCapacity = 3", "syntax_pass": true}, {"attribute_expression": "private static final int GrowthFactor = 2;", "docstring": " manages the key/val arrays", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "GrowthFactor = 2", "syntax_pass": true}, {"attribute_expression": "static final int NotFound = -1;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "NotFound = -1", "syntax_pass": true}, {"attribute_expression": "private static final String EmptyString = \"\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "EmptyString = \"\"", "syntax_pass": true}, {"attribute_expression": "private int size = 0;", "docstring": " the number of instance fields is kept as low as possible giving an object size of 24 bytes", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "size = 0", "syntax_pass": true}, {"attribute_expression": "@Nullable String[] keys = new String[InitialCapacity];", "docstring": " number of slots used (not total capacity, which is keys.length)", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "String[]", "name": "keys = new String[InitialCapacity]", "syntax_pass": true}, {"attribute_expression": "@Nullable Object[] vals = new Object[InitialCapacity];", "docstring": " keys is not null, but contents may be. Same for vals", "modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "type": "Object[]", "name": "vals = new Object[InitialCapacity]", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/Entities.java.Entities", "name": "Entities", "file_path": "src/main/java/org/jsoup/nodes/Entities.java", "superclasses": "", "methods": ["[]Entities()", "[boolean]isNamedEntity(String)", "[boolean]isBaseNamedEntity(String)", "[String]getByName(String)", "[int]codepointsForName(String,int[])", "[String]escape(String,OutputSettings)", "[String]escape(String)", "[String]escapeString(String,EscapeMode,Syntax,Charset)", "[void]escape(Appendable,String,OutputSettings,int)", "[void]doEscape(String,Appendable,EscapeMode,Syntax,Charset,int)", "[void]appendEscaped(int,Appendable,int,EscapeMode,Syntax,CoreCharset,CharsetEncoder)", "[void]appendNbsp(Appendable,EscapeMode)", "[void]appendLt(Appendable,int,EscapeMode,Syntax)", "[void]appendApos(Appendable,int,EscapeMode)", "[void]appendEncoded(Appendable,EscapeMode,int)", "[String]unescape(String)", "[String]unescape(String,boolean)", "[boolean]canEncode(CoreCharset,char,CharsetEncoder)", "[CharsetEncoder]encoderFor(Charset)", "[void]load(EscapeMode,String,int)"], "method_uris": ["src/main/java/org/jsoup/nodes/Entities.java.Entities.[]Entities()", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[boolean]isNamedEntity(String)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[boolean]isBaseNamedEntity(String)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]getByName(String)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[int]codepointsForName(String,int[])", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]escape(String,OutputSettings)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]escape(String)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]escapeString(String,EscapeMode,Syntax,Charset)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]escape(Appendable,String,OutputSettings,int)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]doEscape(String,Appendable,EscapeMode,Syntax,Charset,int)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendEscaped(int,Appendable,int,EscapeMode,Syntax,CoreCharset,CharsetEncoder)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendNbsp(Appendable,EscapeMode)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendLt(Appendable,int,EscapeMode,Syntax)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendApos(Appendable,int,EscapeMode)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]appendEncoded(Appendable,EscapeMode,int)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]unescape(String)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[String]unescape(String,boolean)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[boolean]canEncode(CoreCharset,char,CharsetEncoder)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[CharsetEncoder]encoderFor(Charset)", "src/main/java/org/jsoup/nodes/Entities.java.Entities.[void]load(EscapeMode,String,int)"], "overrides": null, "attributes": [], "class_docstring": "\nHTML entities, and escape routines. Source: <a href=\"http://www.w3.org/TR/html5/named-character-references.html#named-character-references\">W3C\nHTML named character references</a>.\n", "original_string": "public class Entities {\n    // constants for escape options:\n    static final int ForText = 0x1;\n    static final int ForAttribute = 0x2;\n    static final int Normalise = 0x4;\n    static final int TrimLeading = 0x8;\n    static final int TrimTrailing = 0x10;\n\n    private static final int empty = -1;\n    private static final String emptyName = \"\";\n    static final int codepointRadix = 36;\n    private static final char[] codeDelims = {',', ';'};\n    private static final HashMap<String, String> multipoints = new HashMap<>(); // name -> multiple character references\n\n    public enum EscapeMode {\n        /**\n         * Restricted entities suitable for XHTML output: lt, gt, amp, and quot only.\n         */\n        xhtml(EntitiesData.xmlPoints, 4),\n        /**\n         * Default HTML output entities.\n         */\n        base(EntitiesData.basePoints, 106),\n        /**\n         * Complete HTML entities.\n         */\n        extended(EntitiesData.fullPoints, 2125);\n\n        // table of named references to their codepoints. sorted so we can binary search. built by BuildEntities.\n        private String[] nameKeys;\n        private int[] codeVals; // limitation is the few references with multiple characters; those go into multipoints.\n\n        // table of codepoints to named entities.\n        private int[] codeKeys; // we don't support multicodepoints to single named value currently\n        private String[] nameVals;\n\n        EscapeMode(String file, int size) {\n            load(this, file, size);\n        }\n\n        int codepointForName(final String name) {\n            int index = Arrays.binarySearch(nameKeys, name);\n            return index >= 0 ? codeVals[index] : empty;\n        }\n\n        String nameForCodepoint(final int codepoint) {\n            final int index = Arrays.binarySearch(codeKeys, codepoint);\n            if (index >= 0) {\n                // the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower\n                // (and binary search for same item with multi results is undefined\n                return (index < nameVals.length - 1 && codeKeys[index + 1] == codepoint) ?\n                    nameVals[index + 1] : nameVals[index];\n            }\n            return emptyName;\n        }\n    }\n\n    private Entities() {\n    }\n\n    /**\n     * Check if the input is a known named entity\n     *\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity\n     */\n    public static boolean isNamedEntity(final String name) {\n        return extended.codepointForName(name) != empty;\n    }\n\n    /**\n     * Check if the input is a known named entity in the base entity set.\n     *\n     * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n     * @return true if a known named entity in the base set\n     * @see #isNamedEntity(String)\n     */\n    public static boolean isBaseNamedEntity(final String name) {\n        return base.codepointForName(name) != empty;\n    }\n\n    /**\n     * Get the character(s) represented by the named entity\n     *\n     * @param name entity (e.g. \"lt\" or \"amp\")\n     * @return the string value of the character(s) represented by this entity, or \"\" if not defined\n     */\n    public static String getByName(String name) {\n        String val = multipoints.get(name);\n        if (val != null)\n            return val;\n        int codepoint = extended.codepointForName(name);\n        if (codepoint != empty)\n            return new String(new int[]{codepoint}, 0, 1);\n        return emptyName;\n    }\n\n    public static int codepointsForName(final String name, final int[] codepoints) {\n        String val = multipoints.get(name);\n        if (val != null) {\n            codepoints[0] = val.codePointAt(0);\n            codepoints[1] = val.codePointAt(1);\n            return 2;\n        }\n        int codepoint = extended.codepointForName(name);\n        if (codepoint != empty) {\n            codepoints[0] = codepoint;\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     HTML escape an input string. That is, {@code <} is returned as {@code &lt;}. The escaped string is suitable for use\n     both in attributes and in text data.\n     @param data the un-escaped string to escape\n     @param out the output settings to use. This configures the character set escaped against (that is, if a\n     character is supported in the output character set, it doesn't have to be escaped), and also HTML or XML\n     settings.\n     @return the escaped string\n     */\n    public static String escape(String data, OutputSettings out) {\n        return escapeString(data, out.escapeMode(), out.syntax(), out.charset());\n    }\n\n    /**\n     HTML escape an input string, using the default settings (UTF-8, base entities, HTML syntax). That is, {@code <} is\n     returned as {@code &lt;}. The escaped string is suitable for use both in attributes and in text data.\n     @param data the un-escaped string to escape\n     @return the escaped string\n     @see #escape(String, OutputSettings)\n     */\n    public static String escape(String data) {\n        return escapeString(data, base, Syntax.html, DataUtil.UTF_8);\n    }\n\n    private static String escapeString(String data, EscapeMode escapeMode, Syntax syntax, Charset charset) {\n        if (data == null)\n            return \"\";\n        StringBuilder accum = StringUtil.borrowBuilder();\n        try {\n            doEscape(data, accum, escapeMode, syntax, charset, ForText | ForAttribute);\n        } catch (IOException e) {\n            throw new SerializationException(e); // doesn't happen\n        }\n        return StringUtil.releaseBuilder(accum);\n    }\n\n\n    static void escape(Appendable accum, String data, OutputSettings out, int options) throws IOException {\n        doEscape(data, accum, out.escapeMode(), out.syntax(), out.charset(), options);\n    }\n\n    private static void doEscape(String data, Appendable accum, EscapeMode mode, Syntax syntax, Charset charset, int options) throws IOException {\n        final CoreCharset coreCharset = CoreCharset.byName(charset.name());\n        final CharsetEncoder fallback = encoderFor(charset);\n        final int length = data.length();\n\n        int codePoint;\n        boolean lastWasWhite = false;\n        boolean reachedNonWhite = false;\n        boolean skipped = false;\n        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = data.codePointAt(offset);\n\n            if ((options & Normalise) != 0) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((options & TrimLeading) != 0 && !reachedNonWhite) continue;\n                    if (lastWasWhite) continue;\n                    if ((options & TrimTrailing) != 0) {\n                        skipped = true;\n                        continue;\n                    }\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                    if (skipped) {\n                        accum.append(' '); // wasn't the end, so need to place a normalized space\n                        skipped = false;\n                    }\n                }\n            }\n            appendEscaped(codePoint, accum, options, mode, syntax, coreCharset, fallback);\n        }\n    }\n\n    private static void appendEscaped(int codePoint, Appendable accum, int options, EscapeMode escapeMode,\n        Syntax syntax, CoreCharset coreCharset, CharsetEncoder fallback) throws IOException {\n\n        // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n        final char c = (char) codePoint;\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            // html specific and required escapes:\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    appendNbsp(accum, escapeMode);\n                    break;\n                case '<':\n                    // escape when in character data or when in a xml attribute val or XML syntax; not needed in html attr val\n                    appendLt(accum, options, escapeMode, syntax);\n                    break;\n                case '>':\n                    if ((options & ForText) != 0) accum.append(\"&gt;\");\n                    else accum.append(c);\n                    break;\n                case '\"':\n                    if ((options & ForAttribute) != 0) accum.append(\"&quot;\");\n                    else accum.append(c);\n                    break;\n                case '\\'':\n                    // special case for the Entities.escape(string) method when we are maximally escaping. Otherwise, because we output attributes in \"\", there's no need to escape.\n                    appendApos(accum, options, escapeMode);\n                    break;\n                // we escape ascii control <x20 (other than tab, line-feed, carriage return) for XML compliance (required) and HTML ease of reading (not required) - https://www.w3.org/TR/xml/#charsets\n                case 0x9:\n                case 0xA:\n                case 0xD:\n                    accum.append(c);\n                    break;\n                default:\n                    if (c < 0x20 || !canEncode(coreCharset, c, fallback)) appendEncoded(accum, escapeMode, codePoint);\n                    else accum.append(c);\n            }\n        } else {\n            if (canEncode(coreCharset, c, fallback)) {\n                // reads into charBuf - we go through these steps to avoid GC objects as much as possible (would be a new String and a new char[2] for each character)\n                char[] chars = charBuf.get();\n                int len = Character.toChars(codePoint, chars, 0);\n                if (accum instanceof StringBuilder) // true unless the user supplied their own\n                    ((StringBuilder) accum).append(chars, 0, len);\n                else\n                    accum.append(new String(chars, 0, len));\n            } else {\n                appendEncoded(accum, escapeMode, codePoint);\n            }\n        }\n    }\n\n    private static final ThreadLocal<char[]> charBuf = ThreadLocal.withInitial(() -> new char[2]);\n\n    private static void appendNbsp(Appendable accum, EscapeMode escapeMode) throws IOException {\n        if (escapeMode != EscapeMode.xhtml) accum.append(\"&nbsp;\");\n        else accum.append(\"&#xa0;\");\n    }\n\n    private static void appendLt(Appendable accum, int options, EscapeMode escapeMode, Syntax syntax) throws IOException {\n        if ((options & ForText) != 0 || escapeMode == EscapeMode.xhtml || syntax == Syntax.xml) accum.append(\"&lt;\");\n        else accum.append('<'); // no need to escape < when in an HTML attribute\n    }\n\n    private static void appendApos(Appendable accum, int options, EscapeMode escapeMode) throws IOException {\n        if ((options & ForAttribute) != 0 && (options & ForText) != 0) {\n            if (escapeMode == EscapeMode.xhtml) accum.append(\"&#x27;\");\n            else accum.append(\"&apos;\");\n        } else {\n            accum.append('\\'');\n        }\n    }\n\n    private static void appendEncoded(Appendable accum, EscapeMode escapeMode, int codePoint) throws IOException {\n        final String name = escapeMode.nameForCodepoint(codePoint);\n        if (!emptyName.equals(name)) // ok for identity check\n            accum.append('&').append(name).append(';');\n        else\n            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n    }\n\n    /**\n     * Un-escape an HTML escaped string. That is, {@code &lt;} is returned as {@code <}.\n     *\n     * @param string the HTML string to un-escape\n     * @return the unescaped string\n     */\n    public static String unescape(String string) {\n        return unescape(string, false);\n    }\n\n    /**\n     * Unescape the input string.\n     *\n     * @param string to un-HTML-escape\n     * @param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n     * @return unescaped string\n     */\n    static String unescape(String string, boolean strict) {\n        return Parser.unescapeEntities(string, strict);\n    }\n\n    /*\n     * Provides a fast-path for Encoder.canEncode, which drastically improves performance on Android post JellyBean.\n     * After KitKat, the implementation of canEncode degrades to the point of being useless. For non ASCII or UTF,\n     * performance may be bad. We can add more encoders for common character sets that are impacted by performance\n     * issues on Android if required.\n     *\n     * Benchmarks:     *\n     * OLD toHtml() impl v New (fastpath) in millis\n     * Wiki: 1895, 16\n     * CNN: 6378, 55\n     * Alterslash: 3013, 28\n     * Jsoup: 167, 2\n     */\n    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n        // todo add more charset tests if impacted by Android's bad perf in canEncode\n        switch (charset) {\n            case ascii:\n                return c < 0x80;\n            case utf:\n                return !(c >= Character.MIN_SURROGATE && c < (Character.MAX_SURROGATE + 1)); // !Character.isSurrogate(c); but not in Android 10 desugar\n            default:\n                return fallback.canEncode(c);\n        }\n    }\n\n    enum CoreCharset {\n        ascii, utf, fallback;\n\n        static CoreCharset byName(final String name) {\n            if (name.equals(\"US-ASCII\"))\n                return ascii;\n            if (name.startsWith(\"UTF-\")) // covers UTF-8, UTF-16, et al\n                return utf;\n            return fallback;\n        }\n    }\n\n    // cache the last used fallback encoder to save recreating on every use\n    private static final ThreadLocal<CharsetEncoder> LocalEncoder = new ThreadLocal<>();\n    private static CharsetEncoder encoderFor(Charset charset) {\n        CharsetEncoder encoder = LocalEncoder.get();\n        if (encoder == null || !encoder.charset().equals(charset)) {\n            encoder = charset.newEncoder();\n            LocalEncoder.set(encoder);\n        }\n        return encoder;\n    }\n\n    private static void load(EscapeMode e, String pointsData, int size) {\n        e.nameKeys = new String[size];\n        e.codeVals = new int[size];\n        e.codeKeys = new int[size];\n        e.nameVals = new String[size];\n\n        int i = 0;\n        CharacterReader reader = new CharacterReader(pointsData);\n        try {\n            while (!reader.isEmpty()) {\n                // NotNestedLessLess=10913,824;1887&\n\n                final String name = reader.consumeTo('=');\n                reader.advance();\n                final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\n                final char codeDelim = reader.current();\n                reader.advance();\n                final int cp2;\n                if (codeDelim == ',') {\n                    cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\n                    reader.advance();\n                } else {\n                    cp2 = empty;\n                }\n                final String indexS = reader.consumeTo('&');\n                final int index = Integer.parseInt(indexS, codepointRadix);\n                reader.advance();\n\n                e.nameKeys[i] = name;\n                e.codeVals[i] = cp1;\n                e.codeKeys[index] = cp1;\n                e.nameVals[index] = name;\n\n                if (cp2 != empty) {\n                    multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n                }\n                i++;\n            }\n\n            Validate.isTrue(i == size, \"Unexpected count of entities loaded\");\n        } finally {\n            reader.close();\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final int ForText = 0x1;", "docstring": " constants for escape options:", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "ForText = 0x1", "syntax_pass": true}, {"attribute_expression": "static final int ForAttribute = 0x2;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "ForAttribute = 0x2", "syntax_pass": true}, {"attribute_expression": "static final int Normalise = 0x4;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "Normalise = 0x4", "syntax_pass": true}, {"attribute_expression": "static final int TrimLeading = 0x8;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "TrimLeading = 0x8", "syntax_pass": true}, {"attribute_expression": "static final int TrimTrailing = 0x10;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "TrimTrailing = 0x10", "syntax_pass": true}, {"attribute_expression": "private static final int empty = -1;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "empty = -1", "syntax_pass": true}, {"attribute_expression": "private static final String emptyName = \"\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "emptyName = \"\"", "syntax_pass": true}, {"attribute_expression": "static final int codepointRadix = 36;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "codepointRadix = 36", "syntax_pass": true}, {"attribute_expression": "private static final char[] codeDelims = {',', ';'};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char[]", "name": "codeDelims = {',', ';'}", "syntax_pass": true}, {"attribute_expression": "private static final HashMap<String, String> multipoints = new HashMap<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "HashMap<String, String>", "name": "multipoints = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private static final ThreadLocal<char[]> charBuf = ThreadLocal.withInitial(() -> new char[2]);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ThreadLocal<char[]>", "name": "charBuf = ThreadLocal.withInitial(() -> new char[2])", "syntax_pass": true}, {"attribute_expression": "private static final ThreadLocal<CharsetEncoder> LocalEncoder = new ThreadLocal<>();", "docstring": " cache the last used fallback encoder to save recreating on every use", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ThreadLocal<CharsetEncoder>", "name": "LocalEncoder = new ThreadLocal<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils", "name": "NodeUtils", "file_path": "src/main/java/org/jsoup/nodes/NodeUtils.java", "superclasses": "", "methods": ["[Document.OutputSettings]outputSettings(Node)", "[Parser]parser(Node)", "[List<T>]selectXpath(String,Element,Class<T>)", "[Stream<T>]stream(Node,Class<T>)", "[Spliterator<T>]spliterator(Iterator<T>)"], "method_uris": ["src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[Document.OutputSettings]outputSettings(Node)", "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[Parser]parser(Node)", "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[List<T>]selectXpath(String,Element,Class<T>)", "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[Stream<T>]stream(Node,Class<T>)", "src/main/java/org/jsoup/nodes/NodeUtils.java.NodeUtils.[Spliterator<T>]spliterator(Iterator<T>)"], "overrides": null, "attributes": [], "class_docstring": "\nInternal helpers for Nodes, to keep the actual node APIs relatively clean. A jsoup internal class, so don't use it as\nthere is no contract API.\n", "original_string": "final class NodeUtils {\n    /**\n     * Get the output setting for this node,  or if this node has no document (or parent), retrieve the default output\n     * settings\n     */\n    static Document.OutputSettings outputSettings(Node node) {\n        Document owner = node.ownerDocument();\n        return owner != null ? owner.outputSettings() : (new Document(\"\")).outputSettings();\n    }\n\n    /**\n     * Get the parser that was used to make this node, or the default HTML parser if it has no parent.\n     */\n    static Parser parser(Node node) {\n        Document doc = node.ownerDocument();\n        return doc != null ? doc.parser() : new Parser(new HtmlTreeBuilder());\n    }\n\n    /**\n     This impl works by compiling the input xpath expression, and then evaluating it against a W3C Document converted\n     from the original jsoup element. The original jsoup elements are then fetched from the w3c doc user data (where we\n     stashed them during conversion). This process could potentially be optimized by transpiling the compiled xpath\n     expression to a jsoup Evaluator when there's 1:1 support, thus saving the W3C document conversion stage.\n     */\n    static <T extends Node> List<T> selectXpath(String xpath, Element el, Class<T> nodeType) {\n        Validate.notEmpty(xpath);\n        Validate.notNull(el);\n        Validate.notNull(nodeType);\n\n        W3CDom w3c = new W3CDom().namespaceAware(false);\n        org.w3c.dom.Document wDoc = w3c.fromJsoup(el);\n        org.w3c.dom.Node contextNode = w3c.contextNode(wDoc);\n        NodeList nodeList = w3c.selectXpath(xpath, contextNode);\n        return w3c.sourceNodes(nodeList, nodeType);\n    }\n\n    /** Creates a Stream, starting with the supplied node. */\n    static <T extends Node> Stream<T> stream(Node start, Class<T> type) {\n        NodeIterator<T> iterator = new NodeIterator<>(start, type);\n        Spliterator<T> spliterator = spliterator(iterator);\n\n        return StreamSupport.stream(spliterator, false);\n    }\n\n    static <T extends Node> Spliterator<T> spliterator(Iterator<T> iterator) {\n        return Spliterators.spliteratorUnknownSize(\n                iterator,\n                Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.ORDERED);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/nodes/DataNode.java.DataNode", "name": "DataNode", "file_path": "src/main/java/org/jsoup/nodes/DataNode.java", "superclasses": "LeafNode", "methods": ["[]DataNode(String)", "[String]nodeName()", "[String]getWholeData()", "[DataNode]setWholeData(String)", "[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "[DataNode]clone()"], "method_uris": ["src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[]DataNode(String)", "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[String]nodeName()", "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[String]getWholeData()", "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[DataNode]setWholeData(String)", "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[void]outerHtmlHead(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[void]outerHtmlTail(Appendable,int,Document.OutputSettings)", "src/main/java/org/jsoup/nodes/DataNode.java.DataNode.[DataNode]clone()"], "overrides": null, "attributes": [], "class_docstring": "\nA data node, for contents of style, script tags etc, where contents should not show in text().\n\n@author Jonathan Hedley, jonathan@hedley.net", "original_string": "public class DataNode extends LeafNode {\n\n    /**\n     Create a new DataNode.\n     @param data data contents\n     */\n    public DataNode(String data) {\n        super(data);\n    }\n\n    @Override public String nodeName() {\n        return \"#data\";\n    }\n\n    /**\n     Get the data contents of this node. Will be unescaped and with original new lines, space etc.\n     @return data\n     */\n    public String getWholeData() {\n        return coreValue();\n    }\n\n    /**\n     * Set the data contents of this node.\n     * @param data un-encoded data\n     * @return this node, for chaining\n     */\n    public DataNode setWholeData(String data) {\n        coreValue(data);\n        return this;\n    }\n\n    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        /* For XML output, escape the DataNode in a CData section. The data may contain pseudo-CData content if it was\n        parsed as HTML, so don't double up Cdata. Output in polyglot HTML / XHTML / XML format. */\n        final String data = getWholeData();\n        if (out.syntax() == Document.OutputSettings.Syntax.xml && !data.contains(\"<![CDATA[\")) {\n            if (parentNameIs(\"script\"))\n                accum.append(\"//<![CDATA[\\n\").append(data).append(\"\\n//]]>\");\n            else if (parentNameIs(\"style\"))\n                accum.append(\"/*<![CDATA[*/\\n\").append(data).append(\"\\n/*]]>*/\");\n            else\n                accum.append(\"<![CDATA[\").append(data).append(\"]]>\");\n        } else {\n            // In HTML, data is not escaped in the output of data nodes, so < and & in script, style is OK\n            accum.append(getWholeData());\n        }\n    }\n\n    @Override\n    void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n\n    @Override\n    public DataNode clone() {\n        return (DataNode) super.clone();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator", "name": "NodeIterator", "file_path": "src/main/java/org/jsoup/nodes/NodeIterator.java", "superclasses": "", "methods": ["[]NodeIterator(Node,Class<T>)", "[NodeIterator<Node>]from(Node)", "[void]restart(Node)", "[boolean]hasNext()", "[T]next()", "[void]maybeFindNext()", "[T]findNextNode()", "[void]remove()"], "method_uris": ["src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[]NodeIterator(Node,Class<T>)", "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[NodeIterator<Node>]from(Node)", "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[void]restart(Node)", "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[boolean]hasNext()", "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[T]next()", "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[void]maybeFindNext()", "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[T]findNextNode()", "src/main/java/org/jsoup/nodes/NodeIterator.java.NodeIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nIterate through a Node and its tree of descendants, in document order, and returns nodes of the specified type. This\niterator supports structural changes to the tree during the traversal, such as {@link Node#remove()},\n{@link Node#replaceWith(Node)}, {@link Node#wrap(String)}, etc.\n<p>See also the {@link org.jsoup.select.NodeTraversor NodeTraversor} if {@code head} and {@code tail} callbacks are\ndesired for each node.</p>\n@since 1.17.1\n", "original_string": "public class NodeIterator<T extends Node> implements Iterator<T> {\n    private Node root;                      // root / starting node\n    private @Nullable T next;               // the next node to return\n    private Node current;                   // the current (last emitted) node\n    private Node previous;                  // the previously emitted node; used to recover from structural changes\n    private @Nullable Node currentParent;   // the current node's parent; used to detect structural changes\n    private final Class<T> type;            // the desired node class type\n\n    /**\n     Create a NoteIterator that will iterate the supplied node, and all of its descendants. The returned {@link #next}\n     type will be filtered to the input type.\n     * @param start initial node\n     * @param type node type to filter for\n     */\n    public NodeIterator(Node start, Class<T> type) {\n        Validate.notNull(start);\n        Validate.notNull(type);\n        this.type = type;\n\n        restart(start);\n    }\n\n    /**\n     Create a NoteIterator that will iterate the supplied node, and all of its descendants. All node types will be\n     returned.\n     * @param start initial node\n     */\n    public static NodeIterator<Node> from(Node start) {\n        return new NodeIterator<>(start, Node.class);\n    }\n\n    /**\n     Restart this Iterator from the specified start node. Will act as if it were newly constructed. Useful for e.g. to\n     save some GC if the iterator is used in a tight loop.\n     * @param start the new start node.\n     */\n    public void restart(Node start) {\n        if (type.isInstance(start))\n            //noinspection unchecked\n            next = (T) start; // first next() will be the start node\n\n        root = previous = current = start;\n        currentParent = current.parent();\n    }\n\n    @Override public boolean hasNext() {\n        maybeFindNext();\n        return next != null;\n    }\n\n    @Override public T next() {\n        maybeFindNext();\n        if (next == null) throw new NoSuchElementException();\n\n        T result = next;\n        previous = current;\n        current = next;\n        currentParent = current.parent();\n        next = null;\n        return result;\n    }\n\n    /**\n     If next is not null, looks for and sets next. If next is null after this, we have reached the end.\n     */\n    private void maybeFindNext() {\n        if (next != null) return;\n\n        //  change detected (removed or replaced), redo from previous\n        if (currentParent != null && !current.hasParent())\n            current = previous;\n\n        next = findNextNode();\n    }\n\n    private @Nullable T findNextNode() {\n        Node node = current;\n        while (true) {\n            if (node.childNodeSize() > 0)\n                node = node.childNode(0);                   // descend children\n            else if (root.equals(node))\n                node = null;                                // complete when all children of root are fully visited\n            else if (node.nextSibling() != null)\n                node = node.nextSibling();                  // in a descendant with no more children; traverse\n            else {\n                while (true) {\n                    node = node.parent();                   // pop out of descendants\n                    if (node == null || root.equals(node))\n                        return null;                        // got back to root; complete\n                    if (node.nextSibling() != null) {\n                        node = node.nextSibling();          // traverse\n                        break;\n                    }\n                }\n            }\n            if (node == null)\n                return null;                                // reached the end\n\n            if (type.isInstance(node))\n                //noinspection unchecked\n                return (T) node;\n        }\n    }\n\n    @Override public void remove() {\n        current.remove();\n    }\n}", "super_interfaces": ["Iterator<T>"], "fields": [{"attribute_expression": "private Node root;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Node", "name": "root", "syntax_pass": true}, {"attribute_expression": "private @Nullable T next;", "docstring": " root / starting node", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "T", "name": "next", "syntax_pass": true}, {"attribute_expression": "private Node current;", "docstring": " the next node to return", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Node", "name": "current", "syntax_pass": true}, {"attribute_expression": "private Node previous;", "docstring": " the current (last emitted) node", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Node", "name": "previous", "syntax_pass": true}, {"attribute_expression": "private @Nullable Node currentParent;", "docstring": " the previously emitted node; used to recover from structural changes", "modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "Node", "name": "currentParent", "syntax_pass": true}, {"attribute_expression": "private final Class<T> type;", "docstring": " the current node's parent; used to detect structural changes", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<T>", "name": "type", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/examples/ListLinks.java.ListLinks", "name": "ListLinks", "file_path": "src/main/java/org/jsoup/examples/ListLinks.java", "superclasses": "", "methods": ["[void]main(String[])", "[void]print(String)", "[String]trim(String,int)"], "method_uris": ["src/main/java/org/jsoup/examples/ListLinks.java.ListLinks.[void]main(String[])", "src/main/java/org/jsoup/examples/ListLinks.java.ListLinks.[void]print(String)", "src/main/java/org/jsoup/examples/ListLinks.java.ListLinks.[String]trim(String,int)"], "overrides": null, "attributes": [], "class_docstring": "\nExample program to list links from a URL.\n", "original_string": "public class ListLinks {\n    public static void main(String[] args) throws IOException {\n        Validate.isTrue(args.length == 1, \"usage: supply url to fetch\");\n        String url = args[0];\n        print(\"Fetching %s...\", url);\n\n        Document doc = Jsoup.connect(url).get();\n        Elements links = doc.select(\"a[href]\");\n        Elements media = doc.select(\"[src]\");\n        Elements imports = doc.select(\"link[href]\");\n\n        print(\"\\nMedia: (%d)\", media.size());\n        for (Element src : media) {\n            if (src.nameIs(\"img\"))\n                print(\" * %s: <%s> %sx%s (%s)\",\n                        src.tagName(), src.attr(\"abs:src\"), src.attr(\"width\"), src.attr(\"height\"),\n                        trim(src.attr(\"alt\"), 20));\n            else\n                print(\" * %s: <%s>\", src.tagName(), src.attr(\"abs:src\"));\n        }\n\n        print(\"\\nImports: (%d)\", imports.size());\n        for (Element link : imports) {\n            print(\" * %s <%s> (%s)\", link.tagName(),link.attr(\"abs:href\"), link.attr(\"rel\"));\n        }\n\n        print(\"\\nLinks: (%d)\", links.size());\n        for (Element link : links) {\n            print(\" * a: <%s>  (%s)\", link.attr(\"abs:href\"), trim(link.text(), 35));\n        }\n    }\n\n    private static void print(String msg, Object... args) {\n        System.out.println(String.format(msg, args));\n    }\n\n    private static String trim(String s, int width) {\n        if (s.length() > width)\n            return s.substring(0, width-1) + \".\";\n        else\n            return s;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/jsoup/examples/HtmlToPlainText.java.HtmlToPlainText", "name": "HtmlToPlainText", "file_path": "src/main/java/org/jsoup/examples/HtmlToPlainText.java", "superclasses": "", "methods": ["[void]main()", "[String]getPlainText(Element)"], "method_uris": ["src/main/java/org/jsoup/examples/HtmlToPlainText.java.HtmlToPlainText.[void]main()", "src/main/java/org/jsoup/examples/HtmlToPlainText.java.HtmlToPlainText.[String]getPlainText(Element)"], "overrides": null, "attributes": [{"original_string": "    private static class FormattingVisitor implements NodeVisitor {\n        private static final int maxWidth = 80;\n        private int width = 0;\n        private StringBuilder accum = new StringBuilder(); // holds the accumulated text\n\n        // hit when the node is first seen\n        public void head(Node node, int depth) {\n            String name = node.nodeName();\n            if (node instanceof TextNode)\n                append(((TextNode) node).text()); // TextNodes carry all user-readable text in the DOM.\n            else if (name.equals(\"li\"))\n                append(\"\\n * \");\n            else if (name.equals(\"dt\"))\n                append(\"  \");\n            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"tr\"))\n                append(\"\\n\");\n        }\n\n        // hit when all of the node's children (if any) have been visited\n        public void tail(Node node, int depth) {\n            String name = node.nodeName();\n            if (StringUtil.in(name, \"br\", \"dd\", \"dt\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n                append(\"\\n\");\n            else if (name.equals(\"a\"))\n                append(String.format(\" <%s>\", node.absUrl(\"href\")));\n        }\n\n        // appends text to the string builder with a simple word wrap method\n        private void append(String text) {\n            if (text.startsWith(\"\\n\"))\n                width = 0; // reset counter if starts with a newline. only from formats above, not in natural text\n            if (text.equals(\" \") &&\n                    (accum.length() == 0 || StringUtil.in(accum.substring(accum.length() - 1), \" \", \"\\n\")))\n                return; // don't accumulate long runs of empty spaces\n\n            if (text.length() + width > maxWidth) { // won't fit, needs to wrap\n                String[] words = text.split(\"\\\\s+\");\n                for (int i = 0; i < words.length; i++) {\n                    String word = words[i];\n                    boolean last = i == words.length - 1;\n                    if (!last) // insert a space if not the last word\n                        word = word + \" \";\n                    if (word.length() + width > maxWidth) { // wrap and reset counter\n                        accum.append(\"\\n\").append(word);\n                        width = word.length();\n                    } else {\n                        accum.append(word);\n                        width += word.length();\n                    }\n                }\n            } else { // fits as is, without need to wrap text\n                accum.append(text);\n                width += text.length();\n            }\n        }\n\n        @Override\n        public String toString() {\n            return accum.toString();\n        }\n    }", "definition": "    private static class FormattingVisitor implements NodeVisitor", "class_docstring": " the formatting rules, implemented in a breadth-first DOM traverse", "name": "FormattingVisitor", "super_interfaces": ["NodeVisitor"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private static final int maxWidth = 80;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "maxWidth = 80", "syntax_pass": true}, {"attribute_expression": "private int width = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "width = 0", "syntax_pass": true}, {"attribute_expression": "private StringBuilder accum = new StringBuilder();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringBuilder", "name": "accum = new StringBuilder()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void head(Node node, int depth) {\n            String name = node.nodeName();\n            if (node instanceof TextNode)\n                append(((TextNode) node).text()); // TextNodes carry all user-readable text in the DOM.\n            else if (name.equals(\"li\"))\n                append(\"\\n * \");\n            else if (name.equals(\"dt\"))\n                append(\"  \");\n            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"tr\"))\n                append(\"\\n\");\n        }", "docstring": " hit when the node is first seen", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "head", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                               {\n            String name = node.nodeName();\n            if (node instanceof TextNode)\n                append(((TextNode) node).text()); // TextNodes carry all user-readable text in the DOM.\n            else if (name.equals(\"li\"))\n                append(\"\\n * \");\n            else if (name.equals(\"dt\"))\n                append(\"  \");\n            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"tr\"))\n                append(\"\\n\");\n        }", "signature": "public void head(Node node, int depth)"}, {"syntax_pass": true, "original_string": "        public void tail(Node node, int depth) {\n            String name = node.nodeName();\n            if (StringUtil.in(name, \"br\", \"dd\", \"dt\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n                append(\"\\n\");\n            else if (name.equals(\"a\"))\n                append(String.format(\" <%s>\", node.absUrl(\"href\")));\n        }", "docstring": " hit when all of the node's children (if any) have been visited", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tail", "params": [{"name": "node", "type": "Node"}, {"name": "depth", "type": "int"}], "body": "                                               {\n            String name = node.nodeName();\n            if (StringUtil.in(name, \"br\", \"dd\", \"dt\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n                append(\"\\n\");\n            else if (name.equals(\"a\"))\n                append(String.format(\" <%s>\", node.absUrl(\"href\")));\n        }", "signature": "public void tail(Node node, int depth)"}, {"syntax_pass": true, "original_string": "        private void append(String text) {\n            if (text.startsWith(\"\\n\"))\n                width = 0; // reset counter if starts with a newline. only from formats above, not in natural text\n            if (text.equals(\" \") &&\n                    (accum.length() == 0 || StringUtil.in(accum.substring(accum.length() - 1), \" \", \"\\n\")))\n                return; // don't accumulate long runs of empty spaces\n\n            if (text.length() + width > maxWidth) { // won't fit, needs to wrap\n                String[] words = text.split(\"\\\\s+\");\n                for (int i = 0; i < words.length; i++) {\n                    String word = words[i];\n                    boolean last = i == words.length - 1;\n                    if (!last) // insert a space if not the last word\n                        word = word + \" \";\n                    if (word.length() + width > maxWidth) { // wrap and reset counter\n                        accum.append(\"\\n\").append(word);\n                        width = word.length();\n                    } else {\n                        accum.append(word);\n                        width += word.length();\n                    }\n                }\n            } else { // fits as is, without need to wrap text\n                accum.append(text);\n                width += text.length();\n            }\n        }", "docstring": " appends text to the string builder with a simple word wrap method", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "append", "params": [{"name": "text", "type": "String"}], "body": "                                         {\n            if (text.startsWith(\"\\n\"))\n                width = 0; // reset counter if starts with a newline. only from formats above, not in natural text\n            if (text.equals(\" \") &&\n                    (accum.length() == 0 || StringUtil.in(accum.substring(accum.length() - 1), \" \", \"\\n\")))\n                return; // don't accumulate long runs of empty spaces\n\n            if (text.length() + width > maxWidth) { // won't fit, needs to wrap\n                String[] words = text.split(\"\\\\s+\");\n                for (int i = 0; i < words.length; i++) {\n                    String word = words[i];\n                    boolean last = i == words.length - 1;\n                    if (!last) // insert a space if not the last word\n                        word = word + \" \";\n                    if (word.length() + width > maxWidth) { // wrap and reset counter\n                        accum.append(\"\\n\").append(word);\n                        width = word.length();\n                    } else {\n                        accum.append(word);\n                        width += word.length();\n                    }\n                }\n            } else { // fits as is, without need to wrap text\n                accum.append(text);\n                width += text.length();\n            }\n        }", "signature": "private void append(String text)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return accum.toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return accum.toString();\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nHTML to plain-text. This example program demonstrates the use of jsoup to convert HTML input to lightly-formatted\nplain-text. That is divergent from the general goal of jsoup's .text() methods, which is to get clean data from a\nscrape.\n<p>\nNote that this is a fairly simplistic formatter -- for real world use you'll want to embrace and extend.\n</p>\n<p>\nTo invoke from the command line, assuming you've downloaded the jsoup jar to your current directory:</p>\n<p><code>java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]</code></p>\nwhere <i>url</i> is the URL to fetch, and <i>selector</i> is an optional CSS selector.\n\n@author Jonathan Hedley, jonathan@hedley.net\n", "original_string": "public class HtmlToPlainText {\n    private static final String userAgent = \"Mozilla/5.0 (jsoup)\";\n    private static final int timeout = 5 * 1000;\n\n    public static void main(String... args) throws IOException {\n        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n        final String url = args[0];\n        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n\n        if (selector != null) {\n            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n            for (Element element : elements) {\n                String plainText = formatter.getPlainText(element); // format that element to plain text\n                System.out.println(plainText);\n            }\n        } else { // format the whole doc\n            String plainText = formatter.getPlainText(doc);\n            System.out.println(plainText);\n        }\n    }\n\n    /**\n     * Format an Element to plain-text\n     * @param element the root element to format\n     * @return formatted text\n     */\n    public String getPlainText(Element element) {\n        FormattingVisitor formatter = new FormattingVisitor();\n        NodeTraversor.traverse(formatter, element); // walk the DOM, and call .head() and .tail() for each node\n\n        return formatter.toString();\n    }\n\n    // the formatting rules, implemented in a breadth-first DOM traverse\n    private static class FormattingVisitor implements NodeVisitor {\n        private static final int maxWidth = 80;\n        private int width = 0;\n        private StringBuilder accum = new StringBuilder(); // holds the accumulated text\n\n        // hit when the node is first seen\n        public void head(Node node, int depth) {\n            String name = node.nodeName();\n            if (node instanceof TextNode)\n                append(((TextNode) node).text()); // TextNodes carry all user-readable text in the DOM.\n            else if (name.equals(\"li\"))\n                append(\"\\n * \");\n            else if (name.equals(\"dt\"))\n                append(\"  \");\n            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"tr\"))\n                append(\"\\n\");\n        }\n\n        // hit when all of the node's children (if any) have been visited\n        public void tail(Node node, int depth) {\n            String name = node.nodeName();\n            if (StringUtil.in(name, \"br\", \"dd\", \"dt\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n                append(\"\\n\");\n            else if (name.equals(\"a\"))\n                append(String.format(\" <%s>\", node.absUrl(\"href\")));\n        }\n\n        // appends text to the string builder with a simple word wrap method\n        private void append(String text) {\n            if (text.startsWith(\"\\n\"))\n                width = 0; // reset counter if starts with a newline. only from formats above, not in natural text\n            if (text.equals(\" \") &&\n                    (accum.length() == 0 || StringUtil.in(accum.substring(accum.length() - 1), \" \", \"\\n\")))\n                return; // don't accumulate long runs of empty spaces\n\n            if (text.length() + width > maxWidth) { // won't fit, needs to wrap\n                String[] words = text.split(\"\\\\s+\");\n                for (int i = 0; i < words.length; i++) {\n                    String word = words[i];\n                    boolean last = i == words.length - 1;\n                    if (!last) // insert a space if not the last word\n                        word = word + \" \";\n                    if (word.length() + width > maxWidth) { // wrap and reset counter\n                        accum.append(\"\\n\").append(word);\n                        width = word.length();\n                    } else {\n                        accum.append(word);\n                        width += word.length();\n                    }\n                }\n            } else { // fits as is, without need to wrap text\n                accum.append(text);\n                width += text.length();\n            }\n        }\n\n        @Override\n        public String toString() {\n            return accum.toString();\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String userAgent = \"Mozilla/5.0 (jsoup)\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "userAgent = \"Mozilla/5.0 (jsoup)\"", "syntax_pass": true}, {"attribute_expression": "private static final int timeout = 5 * 1000;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "timeout = 5 * 1000", "syntax_pass": true}]}, {"uris": "src/main/java/org/jsoup/examples/Wikipedia.java.Wikipedia", "name": "Wikipedia", "file_path": "src/main/java/org/jsoup/examples/Wikipedia.java", "superclasses": "", "methods": ["[void]main(String[])", "[void]log(String)"], "method_uris": ["src/main/java/org/jsoup/examples/Wikipedia.java.Wikipedia.[void]main(String[])", "src/main/java/org/jsoup/examples/Wikipedia.java.Wikipedia.[void]log(String)"], "overrides": null, "attributes": [], "class_docstring": "\nA simple example, used on the jsoup website.\n", "original_string": "public class Wikipedia {\n    public static void main(String[] args) throws IOException {\n        Document doc = Jsoup.connect(\"http://en.wikipedia.org/\").get();\n        log(doc.title());\n\n        Elements newsHeadlines = doc.select(\"#mp-itn b a\");\n        for (Element headline : newsHeadlines) {\n            log(\"%s\\n\\t%s\", headline.attr(\"title\"), headline.absUrl(\"href\"));\n        }\n    }\n\n    private static void log(String msg, String... vals) {\n        System.out.println(String.format(msg, vals));\n    }\n}", "super_interfaces": [], "fields": []}]