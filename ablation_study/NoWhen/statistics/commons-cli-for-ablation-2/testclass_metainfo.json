[{"uris": "src/test/java/org/apache/commons/cli/ParseException_wrapTest.java.ParseException_wrapTest", "name": "ParseException_wrapTest", "file_path": "src/test/java/org/apache/commons/cli/ParseException_wrapTest.java", "superclasses": "", "methods": ["[void]testWrapWithUnsupportedOperationException()", "[void]testWrapWithParseException()", "[void]testWrapWithOtherException()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ParseException_wrapTest {\n\n    @Test\n    public void testWrapWithUnsupportedOperationException() {\n        final UnsupportedOperationException uoe = new UnsupportedOperationException(\"Unsupported operation\");\n        assertThrows(UnsupportedOperationException.class, () -> ParseException.wrap(uoe));\n    }\n\n    @Test\n    public void testWrapWithParseException() {\n        final ParseException pe = new ParseException(\"Parse error\");\n        assertEquals(pe, ParseException.wrap(pe));\n    }\n\n    @Test\n    public void testWrapWithOtherException() {\n        final IOException ioe = new IOException(\"IO error\");\n        final ParseException wrapped = ParseException.wrap(ioe);\n        assertEquals(ioe, wrapped.getCause());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/HelpFormatter_printOptionsTest.java.HelpFormatter_printOptionsTest", "name": "HelpFormatter_printOptionsTest", "file_path": "src/test/java/org/apache/commons/cli/HelpFormatter_printOptionsTest.java", "superclasses": "", "methods": ["[void]testPrintOptions()"], "method_uris": ["src/test/java/org/apache/commons/cli/HelpFormatter_printOptionsTest.java.HelpFormatter_printOptionsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class HelpFormatter_printOptionsTest {\n    private HelpFormatter formatter;\n    private StringWriter sw;\n\n    @BeforeEach\n    public void setUp() {\n        formatter = new HelpFormatter();\n        sw = new StringWriter();\n    }\n\n    @Test\n    public void testPrintOptions() {\n        final Options options = new Options();\n        options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n\n        formatter.printOptions(new PrintWriter(sw), 20, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD);\n\n        final String expected = \" -h,--help   This is\" + System.lineSeparator() +\n                \"             a\" + System.lineSeparator() +\n                \"             looooon\" + System.lineSeparator() +\n                \"             g\" + System.lineSeparator() +\n                \"             descrip\" + System.lineSeparator() +\n                \"             tion\" + System.lineSeparator();\n\n        assertEquals(expected, sw.toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private HelpFormatter formatter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HelpFormatter", "name": "formatter", "syntax_pass": true}, {"attribute_expression": "private StringWriter sw;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringWriter", "name": "sw", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/ApplicationTest.java.ApplicationTest", "name": "ApplicationTest", "file_path": "src/test/java/org/apache/commons/cli/ApplicationTest.java", "superclasses": "", "methods": ["[void]testAnt()", "[void]testGroovy()", "[void]testLs()", "[void]testMan()", "[void]testNLT()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nThis is a collection of tests that test real world applications command lines.\n\n<p>\nThe following applications are tested:\n<ul>\n<li>ls</li>\n<li>Ant</li>\n<li>Groovy</li>\n<li>man</li>\n</ul>\n</p>\n", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ApplicationTest {\n    /**\n     * Ant test\n     */\n    @Test\n    public void testAnt() throws Exception {\n        // use the GNU parser\n        final CommandLineParser parser = new GnuParser();\n        final Options options = new Options();\n        options.addOption(\"help\", false, \"print this message\");\n        options.addOption(\"projecthelp\", false, \"print project help information\");\n        options.addOption(\"version\", false, \"print the version information and exit\");\n        options.addOption(\"quiet\", false, \"be extra quiet\");\n        options.addOption(\"verbose\", false, \"be extra verbose\");\n        options.addOption(\"debug\", false, \"print debug information\");\n        options.addOption(\"logfile\", true, \"use given file for log\");\n        options.addOption(\"logger\", true, \"the class which is to perform the logging\");\n        options.addOption(\"listener\", true, \"add an instance of a class as a project listener\");\n        options.addOption(\"buildfile\", true, \"use given buildfile\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withDescription(\"use value for given property\")\n                                        .hasArgs()\n                                        .withValueSeparator()\n                                        .create('D'));\n                           //, null, true, , false, true);\n        //@formatter:on\n        options.addOption(\"find\", true, \"search for buildfile towards the root of the filesystem and use it\");\n\n        final String[] args = {\"-buildfile\", \"mybuild.xml\", \"-Dproperty=value\", \"-Dproperty1=value1\", \"-projecthelp\"};\n\n        final CommandLine line = parser.parse(options, args);\n\n        // check multiple values\n        final String[] opts = line.getOptionValues(\"D\");\n        assertEquals(\"property\", opts[0]);\n        assertEquals(\"value\", opts[1]);\n        assertEquals(\"property1\", opts[2]);\n        assertEquals(\"value1\", opts[3]);\n\n        // check single value\n        assertEquals(line.getOptionValue(\"buildfile\"), \"mybuild.xml\");\n\n        // check option\n        assertTrue(line.hasOption(\"projecthelp\"));\n    }\n\n    @Test\n    public void testGroovy() throws Exception {\n        final Options options = new Options();\n\n        //@formatter:off\n        options.addOption(\n            OptionBuilder.withLongOpt(\"define\").\n                withDescription(\"define a system property\").\n                hasArg(true).\n                withArgName(\"name=value\").\n                create('D'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"usage information\")\n                .withLongOpt(\"help\")\n                .create('h'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"debug mode will print out full stack traces\")\n                .withLongOpt(\"debug\")\n                .create('d'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"display the Groovy and JVM versions\")\n                .withLongOpt(\"version\")\n                .create('v'));\n        options.addOption(\n            OptionBuilder.withArgName(\"charset\")\n                .hasArg()\n                .withDescription(\"specify the encoding of the files\")\n                .withLongOpt(\"encoding\")\n                .create('c'));\n        options.addOption(\n            OptionBuilder.withArgName(\"script\")\n                .hasArg()\n                .withDescription(\"specify a command line script\")\n                .create('e'));\n        options.addOption(\n            OptionBuilder.withArgName(\"extension\")\n                .hasOptionalArg()\n                .withDescription(\"modify files in place; create backup if extension is given (e.g. \\'.bak\\')\")\n                .create('i'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line using implicit 'line' variable\")\n                .create('n'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n                .withDescription(\"process files line by line and print result (see also -n)\")\n                .create('p'));\n        options.addOption(\n            OptionBuilder.withArgName(\"port\")\n                .hasOptionalArg()\n                .withDescription(\"listen on a port and process inbound lines\")\n                .create('l'));\n        options.addOption(\n            OptionBuilder.withArgName(\"splitPattern\")\n                .hasOptionalArg()\n                .withDescription(\"split lines using splitPattern (default '\\\\s') using implicit 'split' variable\")\n                .withLongOpt(\"autosplit\")\n                .create('a'));\n        //@formatter:on\n\n        final Parser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-e\", \"println 'hello'\"}, true);\n\n        assertTrue(line.hasOption('e'));\n        assertEquals(\"println 'hello'\", line.getOptionValue('e'));\n    }\n\n    @Test\n    public void testLs() throws Exception {\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n        final Options options = new Options();\n        options.addOption(\"a\", \"all\", false, \"do not hide entries starting with .\");\n        options.addOption(\"A\", \"almost-all\", false, \"do not list implied . and ..\");\n        options.addOption(\"b\", \"escape\", false, \"print octal escapes for nongraphic characters\");\n        //@formatter:off\n        options.addOption(OptionBuilder.withLongOpt(\"block-size\")\n                                        .withDescription(\"use SIZE-byte blocks\")\n                                        .hasArg()\n                                        .withArgName(\"SIZE\")\n                                        .create());\n        //@formatter:on\n        options.addOption(\"B\", \"ignore-backups\", false, \"do not list implied entried ending with ~\");\n        options.addOption(\"c\", false, \"with -lt: sort by, and show, ctime (time of last modification of file status information) with \"\n            + \"-l:show ctime and sort by name otherwise: sort by ctime\");\n        options.addOption(\"C\", false, \"list entries by columns\");\n\n        final String[] args = {\"--block-size=10\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"block-size\"));\n        assertEquals(line.getOptionValue(\"block-size\"), \"10\");\n    }\n\n    /**\n     * author Slawek Zachcial\n     */\n    @Test\n    public void testMan() {\n        final String cmdLine = \"man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath] [-Ppager] [-Slist] [-msystem] [-pstring] [-Llocale] [-eextension] [section]\"\n            + \" page ...\";\n        //@formatter:off\n        final Options options = new Options().\n                addOption(\"a\", \"all\", false, \"find all matching manual pages.\").\n                addOption(\"d\", \"debug\", false, \"emit debugging messages.\").\n                addOption(\"e\", \"extension\", false, \"limit search to extension type 'extension'.\").\n                addOption(\"f\", \"whatis\", false, \"equivalent to whatis.\").\n                addOption(\"k\", \"apropos\", false, \"equivalent to apropos.\").\n                addOption(\"w\", \"location\", false, \"print physical location of man page(s).\").\n                addOption(\"l\", \"local-file\", false, \"interpret 'page' argument(s) as local file name(s)\").\n                addOption(\"u\", \"update\", false, \"force a cache consistency check.\").\n                //FIXME - should generate -r,--prompt string\n                addOption(\"r\", \"prompt\", true, \"provide 'less' pager with prompt.\").\n                addOption(\"c\", \"catman\", false, \"used by catman to reformat out of date cat pages.\").\n                addOption(\"7\", \"ascii\", false, \"display ASCII translation or certain latin1 chars.\").\n                addOption(\"t\", \"troff\", false, \"use troff format pages.\").\n                //FIXME - should generate -T,--troff-device device\n                addOption(\"T\", \"troff-device\", true, \"use groff with selected device.\").\n                addOption(\"Z\", \"ditroff\", false, \"use groff with selected device.\").\n                addOption(\"D\", \"default\", false, \"reset all options to their default values.\").\n                //FIXME - should generate -M,--manpath path\n                addOption(\"M\", \"manpath\", true, \"set search path for manual pages to 'path'.\").\n                //FIXME - should generate -P,--pager pager\n                addOption(\"P\", \"pager\", true, \"use program 'pager' to display output.\").\n                //FIXME - should generate -S,--sections list\n                addOption(\"S\", \"sections\", true, \"use colon separated section list.\").\n                //FIXME - should generate -m,--systems system\n                addOption(\"m\", \"systems\", true, \"search for man pages from other UNIX system(s).\").\n                //FIXME - should generate -L,--locale locale\n                addOption(\"L\", \"locale\", true, \"define the locale for this particular man search.\").\n                //FIXME - should generate -p,--preprocessor string\n                addOption(\"p\", \"preprocessor\", true, \"string indicates which preprocessor to run.\\n\" +\n                         \" e - [n]eqn  p - pic     t - tbl\\n\" +\n                         \" g - grap    r - refer   v - vgrind\").\n                addOption(\"V\", \"version\", false, \"show version.\").\n                addOption(\"h\", \"help\", false, \"show this usage message.\");\n        //@formatter:on\n\n        final HelpFormatter hf = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        hf.printHelp(new PrintWriter(out), 60, cmdLine, null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null, false);\n        //@formatter:off\n        assertEquals(\"usage: man [-c|-f|-k|-w|-tZT device] [-adlhu7V] [-Mpath]\" + eol +\n                        \"           [-Ppager] [-Slist] [-msystem] [-pstring]\" + eol +\n                        \"           [-Llocale] [-eextension] [section] page ...\" + eol +\n                        \" -7,--ascii                display ASCII translation or\" + eol +\n                        \"                           certain latin1 chars.\" + eol +\n                        \" -a,--all                  find all matching manual pages.\" + eol +\n                        \" -c,--catman               used by catman to reformat out of\" + eol +\n                        \"                           date cat pages.\" + eol +\n                        \" -d,--debug                emit debugging messages.\" + eol +\n                        \" -D,--default              reset all options to their\" + eol +\n                        \"                           default values.\" + eol +\n                        \" -e,--extension            limit search to extension type\" + eol +\n                        \"                           'extension'.\" + eol +\n                        \" -f,--whatis               equivalent to whatis.\" + eol +\n                        \" -h,--help                 show this usage message.\" + eol +\n                        \" -k,--apropos              equivalent to apropos.\" + eol +\n                        \" -l,--local-file           interpret 'page' argument(s) as\" + eol +\n                        \"                           local file name(s)\" + eol +\n                        \" -L,--locale <arg>         define the locale for this\" + eol +\n                        \"                           particular man search.\" + eol +\n                        \" -M,--manpath <arg>        set search path for manual pages\" + eol +\n                        \"                           to 'path'.\" + eol +\n                        \" -m,--systems <arg>        search for man pages from other\" + eol +\n                        \"                           UNIX system(s).\" + eol +\n                        \" -P,--pager <arg>          use program 'pager' to display\" + eol +\n                        \"                           output.\" + eol +\n                        \" -p,--preprocessor <arg>   string indicates which\" + eol +\n                        \"                           preprocessor to run.\" + eol +\n                        \"                           e - [n]eqn  p - pic     t - tbl\" + eol +\n                        \"                           g - grap    r - refer   v -\" + eol +\n                        \"                           vgrind\" + eol +\n                        \" -r,--prompt <arg>         provide 'less' pager with prompt.\" + eol +\n                        \" -S,--sections <arg>       use colon separated section list.\" + eol +\n                        \" -t,--troff                use troff format pages.\" + eol +\n                        \" -T,--troff-device <arg>   use groff with selected device.\" + eol +\n                        \" -u,--update               force a cache consistency check.\" + eol +\n                        \" -V,--version              show version.\" + eol +\n                        \" -w,--location             print physical location of man\" + eol +\n                        \"                           page(s).\" + eol +\n                        \" -Z,--ditroff              use groff with selected device.\" + eol,\n                out.toString());\n        //@formatter:on\n    }\n\n    /**\n     * Real world test with long and short options.\n     */\n    @Test\n    public void testNLT() throws Exception {\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n\n        //@formatter:off\n        final Option timeLimit = OptionBuilder.withLongOpt(\"limit\").hasArg()\n                                        .withValueSeparator()\n                                        .withDescription(\"Set time limit for execution, in minutes\")\n                                        .create(\"l\");\n\n        final Option age = OptionBuilder.withLongOpt(\"age\").hasArg()\n                                  .withValueSeparator()\n                                  .withDescription(\"Age (in days) of cache item before being recomputed\")\n                                  .create(\"a\");\n\n        final Option server = OptionBuilder.withLongOpt(\"server\").hasArg()\n                                     .withValueSeparator()\n                                     .withDescription(\"The NLT server address\")\n                                     .create(\"s\");\n\n        final Option numResults = OptionBuilder.withLongOpt(\"results\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Number of results per item\")\n                                         .create(\"r\");\n\n        final Option configFile = OptionBuilder.withLongOpt(\"file\").hasArg()\n                                         .withValueSeparator()\n                                         .withDescription(\"Use the specified configuration file\")\n                                         .create();\n        //@formatter:on\n\n        final Options options = new Options();\n        options.addOption(help);\n        options.addOption(version);\n        options.addOption(newRun);\n        options.addOption(trackerRun);\n        options.addOption(timeLimit);\n        options.addOption(age);\n        options.addOption(server);\n        options.addOption(numResults);\n        options.addOption(configFile);\n\n        // create the command line parser\n        final CommandLineParser parser = new PosixParser();\n\n        final String[] args = {\"-v\", \"-l\", \"10\", \"-age\", \"5\", \"-file\", \"filename\"};\n\n        final CommandLine line = parser.parse(options, args);\n        assertTrue(line.hasOption(\"v\"));\n        assertEquals(line.getOptionValue(\"l\"), \"10\");\n        assertEquals(line.getOptionValue(\"limit\"), \"10\");\n        assertEquals(line.getOptionValue(\"a\"), \"5\");\n        assertEquals(line.getOptionValue(\"age\"), \"5\");\n        assertEquals(line.getOptionValue(\"file\"), \"filename\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/DefaultParserTest.java.DefaultParserTest", "name": "DefaultParserTest", "file_path": "src/test/java/org/apache/commons/cli/DefaultParserTest.java", "superclasses": "AbstractParserTestCase", "methods": ["[void]testBuilder()", "[void]testDeprecated()", "[void]testLongOptionQuoteHandlingWithoutStrip()", "[void]testLongOptionQuoteHandlingWithStrip()", "[void]testLongOptionWithEqualsQuoteHandling()", "[void]testLongOptionWithEqualsQuoteHandlingWithoutStrip()", "[void]testLongOptionWithEqualsQuoteHandlingWithStrip()", "[void]testShortOptionConcatenatedQuoteHandling()", "[void]testShortOptionQuoteHandlingWithoutStrip()", "[void]testShortOptionQuoteHandlingWithStrip()"], "method_uris": ["src/test/java/org/apache/commons/cli/DefaultParserTest.java.DefaultParserTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTODO Needs a rework using JUnit parameterized tests.\n", "original_string": "public class DefaultParserTest extends AbstractParserTestCase {\n\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new DefaultParser();\n    }\n\n    @Test\n    public void testBuilder() {\n        // @formatter:off\n        parser = DefaultParser.builder()\n                .setStripLeadingAndTrailingQuotes(false)\n                .setAllowPartialMatching(false)\n                .setDeprecatedHandler(null)\n                .build();\n        // @formatter:on\n        assertEquals(DefaultParser.class, parser.getClass());\n    }\n\n    @Test\n    public void testDeprecated() throws ParseException {\n        final Set<Option> handler = new HashSet<>();\n        parser = DefaultParser.builder().setDeprecatedHandler(handler::add).build();\n        final Option opt1 = Option.builder().option(\"d1\").deprecated().build();\n        // @formatter:off\n        final Option opt2 = Option.builder().option(\"d2\").deprecated(DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"1.0\")\n                .setDescription(\"Do this instead.\").get()).build();\n        // @formatter:on\n        final Option opt3 = Option.builder().option(\"a\").build();\n        // @formatter:off\n        final CommandLine cl = parser.parse(new Options()\n                .addOption(opt1)\n                .addOption(opt2)\n                .addOption(opt3),\n                new String[] {\"-d1\", \"-d2\", \"-a\"});\n        // @formatter:on\n        // Trigger handler:\n        assertTrue(cl.hasOption(opt1.getOpt()));\n        assertTrue(cl.hasOption(opt2.getOpt()));\n        assertTrue(cl.hasOption(opt3.getOpt()));\n        // Assert handler was triggered\n        assertTrue(handler.contains(opt1));\n        assertTrue(handler.contains(opt2));\n        assertFalse(handler.contains(opt3));\n    }\n\n    @Test\n    public void testLongOptionQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testLongOptionQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }\n\n    @Override\n    @Test\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testLongOptionWithEqualsQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testLongOptionWithEqualsQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"--bfile=\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }\n\n    @Override\n    @Test\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n        final String[] args = {\"-b\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        //This is behavior is not consistent with the other parsers, but is required for backwards compatibility\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testShortOptionQuoteHandlingWithoutStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(false).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"\\\"quoted string\\\"\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" keeps quotes\");\n    }\n\n    @Test\n    public void testShortOptionQuoteHandlingWithStrip() throws Exception {\n        parser = DefaultParser.builder().setStripLeadingAndTrailingQuotes(true).build();\n        final String[] args = {\"-b\", \"\\\"quoted string\\\"\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/TypeHandlerTest.java.TypeHandlerTest", "name": "TypeHandlerTest", "file_path": "src/test/java/org/apache/commons/cli/TypeHandlerTest.java", "superclasses": "", "methods": ["[void]testCreateClass()", "[void]testCreateFile()", "[void]testCreateFiles()", "[void]testCreateNumber()", "[void]testCreateObject()", "[void]testCreateURL()", "[void]testCreateValue(String,Class<?>,Object)", "[void]testCreateValueExistingFile()", "[void]testnstantiableEquals()", "[void]testOpenFile()", "[void]testRegister()"], "method_uris": ["src/test/java/org/apache/commons/cli/TypeHandlerTest.java.TypeHandlerTest.[Stream<Date>]createDateFixtures()", "src/test/java/org/apache/commons/cli/TypeHandlerTest.java.TypeHandlerTest.[Stream<Arguments>]createValueTestParameters()"], "overrides": null, "attributes": [{"original_string": "    public static class Instantiable {\n\n        @Override\n        public boolean equals(final Object arg0) {\n            return arg0 instanceof Instantiable;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n    }", "definition": "    public static class Instantiable", "class_docstring": " Used for Class and Object creation tests.", "name": "Instantiable", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object arg0) {\n            return arg0 instanceof Instantiable;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "arg0", "type": "Object"}], "body": "                                                 {\n            return arg0 instanceof Instantiable;\n        }", "signature": "@Override\n        public boolean equals(final Object arg0)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return 1;\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    public static final class NotInstantiable {\n        private NotInstantiable() {\n        }\n\n    }", "definition": "    public static final class NotInstantiable", "class_docstring": " Used for Class and Object negative creation tests", "name": "NotInstantiable", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private NotInstantiable() {\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "NotInstantiable", "params": [], "body": "                                  {\n        }", "signature": "private NotInstantiable()"}]}], "class_docstring": "", "original_string": "public class TypeHandlerTest {\n\n    /** Used for Class and Object creation tests. */\n    public static class Instantiable {\n\n        @Override\n        public boolean equals(final Object arg0) {\n            return arg0 instanceof Instantiable;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n    }\n\n    /** Used for Class and Object negative creation tests */\n    public static final class NotInstantiable {\n        private NotInstantiable() {\n        }\n\n    }\n\n    /** Always returns the same Path. */\n    private static final Converter<Path, InvalidPathException> PATH_CONVERTER = s -> Paths.get(\"foo\");\n\n    private static Stream<Date> createDateFixtures() {\n        return Stream.of(Date.from(Instant.EPOCH), Date.from(Instant.ofEpochSecond(0)), Date.from(Instant.ofEpochSecond(40_000)));\n\n    }\n\n    private static Stream<Arguments> createValueTestParameters() throws MalformedURLException {\n        // force the PatternOptionBuilder to load / modify the TypeHandler table.\n        @SuppressWarnings(\"unused\")\n        final Class<?> loadStatic = PatternOptionBuilder.FILES_VALUE;\n        // reset the type handler table.\n        // TypeHandler.resetConverters();\n        final List<Arguments> list = new ArrayList<>();\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the machine on which the test is running. To avoid this\n         * problem, convert the time into a string and then unparse that using the converter. This produces strings that always match the correct time zone.\n         */\n        final Date date = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.CLASS_VALUE, Instantiable.class));\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.CLASS_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"what ever\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n        list.add(Arguments.of(dateFormat.format(date), PatternOptionBuilder.DATE_VALUE, date));\n        list.add(Arguments.of(\"Jun 06 17:48:57 EDT 2002\", PatternOptionBuilder.DATE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"non-existing.file\", PatternOptionBuilder.EXISTING_FILE_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"some-file.txt\", PatternOptionBuilder.FILE_VALUE, new File(\"some-file.txt\")));\n\n        list.add(Arguments.of(\"some-path.txt\", Path.class, new File(\"some-path.txt\").toPath()));\n\n        // the PatternOptionBuilder.FILES_VALUE is not registered so it should just return the string\n        list.add(Arguments.of(\"some.files\", PatternOptionBuilder.FILES_VALUE, \"some.files\"));\n\n        list.add(Arguments.of(\"just-a-string\", Integer.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Integer.class, 5));\n        list.add(Arguments.of(\"5.5\", Integer.class, ParseException.class));\n        list.add(Arguments.of(Long.toString(Long.MAX_VALUE), Integer.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Long.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Long.class, 5L));\n        list.add(Arguments.of(\"5.5\", Long.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Short.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Short.class, (short) 5));\n        list.add(Arguments.of(\"5.5\", Short.class, ParseException.class));\n        list.add(Arguments.of(Integer.toString(Integer.MAX_VALUE), Short.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Byte.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Byte.class, (byte) 5));\n        list.add(Arguments.of(\"5.5\", Byte.class, ParseException.class));\n        list.add(Arguments.of(Short.toString(Short.MAX_VALUE), Byte.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", Character.class, 'j'));\n        list.add(Arguments.of(\"5\", Character.class, '5'));\n        list.add(Arguments.of(\"5.5\", Character.class, '5'));\n        list.add(Arguments.of(\"\\\\u0124\", Character.class, Character.toChars(0x0124)[0]));\n\n        list.add(Arguments.of(\"just-a-string\", Double.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Double.class, 5d));\n        list.add(Arguments.of(\"5.5\", Double.class, 5.5));\n\n        list.add(Arguments.of(\"just-a-string\", Float.class, ParseException.class));\n        list.add(Arguments.of(\"5\", Float.class, 5f));\n        list.add(Arguments.of(\"5.5\", Float.class, 5.5f));\n        list.add(Arguments.of(Double.toString(Double.MAX_VALUE), Float.class, Float.POSITIVE_INFINITY));\n\n        list.add(Arguments.of(\"just-a-string\", BigInteger.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigInteger.class, new BigInteger(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigInteger.class, ParseException.class));\n\n        list.add(Arguments.of(\"just-a-string\", BigDecimal.class, ParseException.class));\n        list.add(Arguments.of(\"5\", BigDecimal.class, new BigDecimal(\"5\")));\n        list.add(Arguments.of(\"5.5\", BigDecimal.class, new BigDecimal(5.5)));\n\n        list.add(Arguments.of(\"1.5\", PatternOptionBuilder.NUMBER_VALUE, Double.valueOf(1.5)));\n        list.add(Arguments.of(\"15\", PatternOptionBuilder.NUMBER_VALUE, Long.valueOf(15)));\n        list.add(Arguments.of(\"not a number\", PatternOptionBuilder.NUMBER_VALUE, ParseException.class));\n\n        list.add(Arguments.of(Instantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, new Instantiable()));\n        list.add(Arguments.of(NotInstantiable.class.getName(), PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n        list.add(Arguments.of(\"unknown\", PatternOptionBuilder.OBJECT_VALUE, ParseException.class));\n\n        list.add(Arguments.of(\"String\", PatternOptionBuilder.STRING_VALUE, \"String\"));\n\n        final String urlString = \"https://commons.apache.org\";\n        list.add(Arguments.of(urlString, PatternOptionBuilder.URL_VALUE, new URL(urlString)));\n        list.add(Arguments.of(\"Malformed-url\", PatternOptionBuilder.URL_VALUE, ParseException.class));\n\n        return list.stream();\n\n    }\n\n    @Test\n    public void testCreateClass() throws ParseException {\n        final Class<?> cls = getClass();\n        assertEquals(cls, TypeHandler.createClass(cls.getName()));\n    }\n\n    // @ParameterizedTest\n    // @MethodSource(\"createDateFixtures\")\n    // public void testCreateDate(final Date date) {\n    //     assertEquals(date, TypeHandler.createDate(date.toString()));\n    // }\n\n    @Test\n    public void testCreateFile() {\n        final File file = new File(\"\").getAbsoluteFile();\n        assertEquals(file, TypeHandler.createFile(file.toString()));\n    }\n\n    @Test\n    public void testCreateFiles() {\n        assertThrows(UnsupportedOperationException.class, () -> TypeHandler.createFiles(null));\n    }\n\n    @Test\n    public void testCreateNumber() throws ParseException {\n        assertEquals(0L, TypeHandler.createNumber(\"0\"));\n        assertEquals(0d, TypeHandler.createNumber(\"0.0\"));\n    }\n\n    @Test\n    public void testCreateObject() throws ParseException {\n        assertTrue(TypeHandler.createObject(Date.class.getName()) instanceof Date);\n    }\n\n    @Test\n    public void testCreateURL() throws ParseException, MalformedURLException {\n        final URL file = Paths.get(\"\").toAbsolutePath().toUri().toURL();\n        assertEquals(file, TypeHandler.createURL(file.toString()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @ParameterizedTest(name = \"{0} as {1}\")\n    @MethodSource(\"createValueTestParameters\")\n    public void testCreateValue(final String str, final Class<?> type, final Object expected) throws Exception {\n        @SuppressWarnings(\"cast\")\n        final Object objectApiTest = type; // KEEP this cast\n        if (expected instanceof Class<?> && Throwable.class.isAssignableFrom((Class<?>) expected)) {\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, type));\n            assertThrows((Class<Throwable>) expected, () -> TypeHandler.createValue(str, objectApiTest));\n        } else {\n            assertEquals(expected, TypeHandler.createValue(str, type));\n            assertEquals(expected, TypeHandler.createValue(str, objectApiTest));\n        }\n    }\n\n    @Test\n    public void testCreateValueExistingFile() throws Exception {\n        try (FileInputStream result = TypeHandler.createValue(\"src/test/resources/org/apache/commons/cli/existing-readable.file\",\n                PatternOptionBuilder.EXISTING_FILE_VALUE)) {\n            assertNotNull(result);\n        }\n    }\n\n    /* proof of equality for later tests */\n    @Test\n    public void testnstantiableEquals() {\n        assertEquals(new Instantiable(), new Instantiable());\n    }\n\n    @Test\n    public void testOpenFile() throws ParseException, IOException {\n        try (FileInputStream fis = TypeHandler.openFile(\"src/test/resources/org/apache/commons/cli/existing-readable.file\")) {\n            IOUtils.consume(fis);\n        }\n    }\n\n    @Test\n    public void testRegister() {\n        final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n        final TypeHandler typeHandler = new TypeHandler(map);\n        assertEquals(Converter.PATH, typeHandler.getConverter(Path.class));\n        try {\n            map.put(Path.class, PATH_CONVERTER);\n            assertEquals(PATH_CONVERTER, typeHandler.getConverter(Path.class));\n        } finally {\n            map.remove(Path.class);\n            assertEquals(Converter.DEFAULT, typeHandler.getConverter(Path.class));\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Converter<Path, InvalidPathException> PATH_CONVERTER = s -> Paths.get(\"foo\");", "docstring": " Always returns the same Path.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Converter<Path, InvalidPathException>", "name": "PATH_CONVERTER = s -> Paths.get(\"foo\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/Option_equalsTest.java.Option_equalsTest", "name": "Option_equalsTest", "file_path": "src/test/java/org/apache/commons/cli/Option_equalsTest.java", "superclasses": "", "methods": ["[void]testEqualsSameObject()", "[void]testEqualsDifferentType()", "[void]testEqualsDifferentOptions()", "[void]testEqualsSameOptions()", "[void]testEqualsNull()"], "method_uris": ["src/test/java/org/apache/commons/cli/Option_equalsTest.java.Option_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Option_equalsTest {\n\n    private Option option1;\n    private Option option2;\n    private Option option3;\n\n    @BeforeEach\n    public void setUp() {\n        option1 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n        option2 = Option.builder(\"opt2\").longOpt(\"longOpt2\").build();\n        option3 = Option.builder(\"opt1\").longOpt(\"longOpt1\").build();\n    }\n\n    @Test\n    public void testEqualsSameObject() {\n        assertEquals(option1, option1);\n    }\n\n    @Test\n    public void testEqualsDifferentType() {\n        assertFalse(option1.equals(\"notAnOption\"));\n    }\n\n    @Test\n    public void testEqualsDifferentOptions() {\n        assertFalse(option1.equals(option2));\n    }\n\n    @Test\n    public void testEqualsSameOptions() {\n        assertEquals(option1, option3);\n    }\n\n    @Test\n    public void testEqualsNull() {\n        assertFalse(option1.equals(null));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Option option1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option1", "syntax_pass": true}, {"attribute_expression": "private Option option2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option2", "syntax_pass": true}, {"attribute_expression": "private Option option3;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option3", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/ArgumentIsOptionTest.java.ArgumentIsOptionTest", "name": "ArgumentIsOptionTest", "file_path": "src/test/java/org/apache/commons/cli/ArgumentIsOptionTest.java", "superclasses": "", "methods": ["[void]testOption()", "[void]testOptionAndOptionWithArgument()", "[void]testOptionWithArgument()"], "method_uris": ["src/test/java/org/apache/commons/cli/ArgumentIsOptionTest.java.ArgumentIsOptionTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ArgumentIsOptionTest {\n\n    private Options options;\n    private CommandLineParser parser;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options().addOption(\"p\", false, \"Option p\").addOption(\"attr\", true, \"Option accepts argument\");\n        parser = new PosixParser();\n    }\n\n    @Test\n    public void testOption() throws Exception {\n        final String[] args = {\"-p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertFalse(cl.hasOption(\"attr\"), \"Confirm -attr is not set\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }\n\n    @Test\n    public void testOptionAndOptionWithArgument() throws Exception {\n        final String[] args = {\"-p\", \"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertTrue(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }\n\n    @Test\n    public void testOptionWithArgument() throws Exception {\n        final String[] args = {\"-attr\", \"p\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"p\"), \"Confirm -p is set\");\n        assertTrue(cl.hasOption(\"attr\"), \"Confirm -attr is set\");\n        assertEquals(\"p\", cl.getOptionValue(\"attr\"), \"Confirm arg of -attr\");\n        assertEquals(0, cl.getArgs().length, \"Confirm all arguments recognized\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "private CommandLineParser parser;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CommandLineParser", "name": "parser", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/SolrCliTest.java.SolrCliTest", "name": "SolrCliTest", "file_path": "src/test/java/org/apache/commons/cli/SolrCliTest.java", "superclasses": "", "methods": ["[void]testOptions()"], "method_uris": ["src/test/java/org/apache/commons/cli/SolrCliTest.java.SolrCliTest.[String]getDefaultSolrUrl()"], "overrides": null, "attributes": [], "class_docstring": "\nTest fixtures used in SOLR tests.\n", "original_string": "class SolrCliTest {\n\n    public static final String ZK_HOST = \"localhost:9983\";\n\n    public static final String DEFAULT_CONFIG_SET = \"_default\";\n\n    public static final Option OPTION_ZKHOST_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"zkHost\")\n            .longOpt(\"zkHost\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --zk-host instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_ZKHOST =\n    // @formatter:off\n        Option.builder(\"z\")\n            .longOpt(\"zk-host\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_SOLRURL_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"solrUrl\")\n            .longOpt(\"solrUrl\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --solr-url instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_SOLRURL =\n    // @formatter:off\n        Option.builder(\"url\")\n            .longOpt(\"solr-url\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_VERBOSE =\n    // @formatter:off\n        Option.builder(\"v\")\n            .longOpt(\"verbose\")\n            .argName(\"verbose\")\n            .required(false)\n            .desc(\"Enable more verbose command output.\")\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_HELP =\n    // @formatter:off\n        Option.builder(\"h\")\n            .longOpt(\"help\")\n            .required(false)\n            .desc(\"Print this message.\")\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_RECURSE =\n    // @formatter:off\n        Option.builder(\"r\")\n            .longOpt(\"recurse\")\n            .argName(\"recurse\")\n            .hasArg()\n            .required(false)\n            .desc(\"Recurse (true|false), default is false.\")\n            .build();\n    // @formatter:on\n\n    public static final Option OPTION_CREDENTIALS =\n    // @formatter:off\n        Option.builder(\"u\")\n            .longOpt(\"credentials\")\n            .argName(\"credentials\")\n            .hasArg()\n            .required(false)\n            .desc(\"Credentials in the format username:password. Example: --credentials solr:SolrRocks\")\n            .build();\n    // @formatter:on\n\n    public static String getDefaultSolrUrl() {\n        final String scheme = \"http\";\n        final String host = \"localhost\";\n        final String port = \"8983\";\n        return String.format(Locale.ROOT, \"%s://%s:%s\", scheme.toLowerCase(Locale.ROOT), host, port);\n    }\n\n    @Test\n    public void testOptions() {\n        // sanity checks\n        assertNotNull(DEFAULT_CONFIG_SET);\n        assertNotNull(OPTION_CREDENTIALS);\n        assertNotNull(OPTION_HELP);\n        assertNotNull(OPTION_RECURSE);\n        assertNotNull(OPTION_SOLRURL);\n        assertNotNull(OPTION_SOLRURL_DEPRECATED);\n        assertNotNull(OPTION_VERBOSE);\n        assertNotNull(OPTION_ZKHOST);\n        assertNotNull(OPTION_ZKHOST_DEPRECATED);\n        assertNotNull(ZK_HOST);\n        assertNotNull(getDefaultSolrUrl());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String ZK_HOST = \"localhost:9983\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ZK_HOST = \"localhost:9983\"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_CONFIG_SET = \"_default\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_CONFIG_SET = \"_default\"", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_ZKHOST_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"zkHost\")\n            .longOpt(\"zkHost\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --zk-host instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_ZKHOST_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"zkHost\")\n            .longOpt(\"zkHost\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --zk-host instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_ZKHOST =\n    // @formatter:off\n        Option.builder(\"z\")\n            .longOpt(\"zk-host\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_ZKHOST =\n    // @formatter:off\n        Option.builder(\"z\")\n            .longOpt(\"zk-host\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Zookeeper connection string; unnecessary if ZK_HOST is defined in solr.in.sh; otherwise, defaults to \"\n                    + ZK_HOST\n                    + '.')\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_SOLRURL_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"solrUrl\")\n            .longOpt(\"solrUrl\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --solr-url instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_SOLRURL_DEPRECATED =\n    // @formatter:off\n        Option.builder(\"solrUrl\")\n            .longOpt(\"solrUrl\")\n            .deprecated(\n                DeprecatedAttributes.builder()\n                    .setForRemoval(true)\n                    .setSince(\"9.6\")\n                    .setDescription(\"Use --solr-url instead\")\n                    .get())\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_SOLRURL =\n    // @formatter:off\n        Option.builder(\"url\")\n            .longOpt(\"solr-url\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_SOLRURL =\n    // @formatter:off\n        Option.builder(\"url\")\n            .longOpt(\"solr-url\")\n            .argName(\"HOST\")\n            .hasArg()\n            .required(false)\n            .desc(\"Base Solr URL, which can be used to determine the zk-host if that's not known; defaults to: \"\n                    + getDefaultSolrUrl()\n                    + '.')\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_VERBOSE =\n    // @formatter:off\n        Option.builder(\"v\")\n            .longOpt(\"verbose\")\n            .argName(\"verbose\")\n            .required(false)\n            .desc(\"Enable more verbose command output.\")\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_VERBOSE =\n    // @formatter:off\n        Option.builder(\"v\")\n            .longOpt(\"verbose\")\n            .argName(\"verbose\")\n            .required(false)\n            .desc(\"Enable more verbose command output.\")\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_HELP =\n    // @formatter:off\n        Option.builder(\"h\")\n            .longOpt(\"help\")\n            .required(false)\n            .desc(\"Print this message.\")\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_HELP =\n    // @formatter:off\n        Option.builder(\"h\")\n            .longOpt(\"help\")\n            .required(false)\n            .desc(\"Print this message.\")\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_RECURSE =\n    // @formatter:off\n        Option.builder(\"r\")\n            .longOpt(\"recurse\")\n            .argName(\"recurse\")\n            .hasArg()\n            .required(false)\n            .desc(\"Recurse (true|false), default is false.\")\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_RECURSE =\n    // @formatter:off\n        Option.builder(\"r\")\n            .longOpt(\"recurse\")\n            .argName(\"recurse\")\n            .hasArg()\n            .required(false)\n            .desc(\"Recurse (true|false), default is false.\")\n            .build()", "syntax_pass": true}, {"attribute_expression": "public static final Option OPTION_CREDENTIALS =\n    // @formatter:off\n        Option.builder(\"u\")\n            .longOpt(\"credentials\")\n            .argName(\"credentials\")\n            .hasArg()\n            .required(false)\n            .desc(\"Credentials in the format username:password. Example: --credentials solr:SolrRocks\")\n            .build();", "docstring": " @formatter:on", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Option", "name": "OPTION_CREDENTIALS =\n    // @formatter:off\n        Option.builder(\"u\")\n            .longOpt(\"credentials\")\n            .argName(\"credentials\")\n            .hasArg()\n            .required(false)\n            .desc(\"Credentials in the format username:password. Example: --credentials solr:SolrRocks\")\n            .build()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/Options_addOptionGroupTest.java.Options_addOptionGroupTest", "name": "Options_addOptionGroupTest", "file_path": "src/test/java/org/apache/commons/cli/Options_addOptionGroupTest.java", "superclasses": "", "methods": ["[void]testAddOptionGroupWithRequiredGroup()", "[void]testAddOptionGroupWithNonRequiredGroup()", "[void]testAddOptionGroupSetsOptionRequiredToFalse()", "[void]testAddOptionGroupAddsOptionsToShortOpts()", "[void]testAddOptionGroupAddsOptionsToLongOpts()"], "method_uris": ["src/test/java/org/apache/commons/cli/Options_addOptionGroupTest.java.Options_addOptionGroupTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Options_addOptionGroupTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddOptionGroupWithRequiredGroup() {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(true);\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(Option.builder(\"a\").build()));\n        assertEquals(group, options.getOptionGroup(Option.builder(\"b\").build()));\n    }\n\n    @Test\n    public void testAddOptionGroupWithNonRequiredGroup() {\n        OptionGroup group = new OptionGroup();\n        group.setRequired(false);\n        group.addOption(Option.builder(\"x\").build());\n        group.addOption(Option.builder(\"y\").build());\n\n        options.addOptionGroup(group);\n\n        assertFalse(options.getRequiredOptions().contains(group));\n        assertEquals(group, options.getOptionGroup(Option.builder(\"x\").build()));\n        assertEquals(group, options.getOptionGroup(Option.builder(\"y\").build()));\n    }\n\n    @Test\n    public void testAddOptionGroupSetsOptionRequiredToFalse() {\n        OptionGroup group = new OptionGroup();\n        Option optionA = Option.builder(\"a\").required(true).build();\n        Option optionB = Option.builder(\"b\").required(true).build();\n        group.addOption(optionA);\n        group.addOption(optionB);\n\n        options.addOptionGroup(group);\n\n        assertFalse(optionA.isRequired());\n        assertFalse(optionB.isRequired());\n    }\n\n    @Test\n    public void testAddOptionGroupAddsOptionsToShortOpts() {\n        OptionGroup group = new OptionGroup();\n        Option optionA = Option.builder(\"a\").build();\n        Option optionB = Option.builder(\"b\").build();\n        group.addOption(optionA);\n        group.addOption(optionB);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.hasShortOption(\"a\"));\n        assertTrue(options.hasShortOption(\"b\"));\n    }\n\n    @Test\n    public void testAddOptionGroupAddsOptionsToLongOpts() {\n        OptionGroup group = new OptionGroup();\n        Option optionA = Option.builder(\"a\").longOpt(\"alpha\").build();\n        Option optionB = Option.builder(\"b\").longOpt(\"beta\").build();\n        group.addOption(optionA);\n        group.addOption(optionB);\n\n        options.addOptionGroup(group);\n\n        assertTrue(options.hasLongOption(\"alpha\"));\n        assertTrue(options.hasLongOption(\"beta\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/Options_addOptionsTest.java.Options_addOptionsTest", "name": "Options_addOptionsTest", "file_path": "src/test/java/org/apache/commons/cli/Options_addOptionsTest.java", "superclasses": "", "methods": ["[void]testAddOptionsSuccess()", "[void]testAddOptionsDuplicateKey()", "[void]testAddOptionsWithOptionGroups()"], "method_uris": ["src/test/java/org/apache/commons/cli/Options_addOptionsTest.java.Options_addOptionsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Options_addOptionsTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddOptionsSuccess() {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"alpha\", false, \"description\");\n        newOptions.addOption(\"b\", \"beta\", false, \"description\");\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }\n\n    @Test\n    public void testAddOptionsDuplicateKey() {\n        Options newOptions = new Options();\n        newOptions.addOption(\"a\", \"alpha\", false, \"description\");\n        newOptions.addOption(\"b\", \"beta\", false, \"description\");\n\n        options.addOption(\"a\", \"alpha\", false, \"description\");\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            options.addOptions(newOptions);\n        });\n    }\n\n    @Test\n    public void testAddOptionsWithOptionGroups() {\n        Options newOptions = new Options();\n        OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n        newOptions.addOptionGroup(group1);\n\n        options.addOptions(newOptions);\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n        assertEquals(1, options.getOptionGroups().size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/SolrCreateToolTest.java.SolrCreateToolTest", "name": "SolrCreateToolTest", "file_path": "src/test/java/org/apache/commons/cli/SolrCreateToolTest.java", "superclasses": "", "methods": ["[void]testHelpFormatter()", "[void]testHelpFormatterDeprecated()"], "method_uris": ["src/test/java/org/apache/commons/cli/SolrCreateToolTest.java.SolrCreateToolTest.[List<Option>]getOptions()", "src/test/java/org/apache/commons/cli/SolrCreateToolTest.java.SolrCreateToolTest.[String]printHelp(HelpFormatter)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SolrCreateToolTest {\n\n    public List<Option> getOptions() {\n        // @formatter:off\n        return Arrays.asList(\n            SolrCliTest.OPTION_ZKHOST,\n            SolrCliTest.OPTION_SOLRURL,\n            SolrCliTest.OPTION_ZKHOST_DEPRECATED,\n            SolrCliTest.OPTION_SOLRURL,\n            Option.builder(\"c\")\n                .longOpt(\"name\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(true)\n                .desc(\"Name of collection or core to create.\")\n                .build(),\n            Option.builder(\"s\")\n                .longOpt(\"shards\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of shards; default is 1.\")\n                .build(),\n            Option.builder(\"rf\")\n                .longOpt(\"replication-factor\")\n                .argName(\"#\")\n                .hasArg()\n                .required(false)\n                .desc(\"Number of copies of each document across the collection (replicas per shard); default is 1.\")\n                .build(),\n            Option.builder(\"d\")\n                .longOpt(\"confdir\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration directory to copy when creating the new collection; default is \"\n                        + SolrCliTest.DEFAULT_CONFIG_SET\n                        + '.')\n                .build(),\n            Option.builder(\"n\")\n                .longOpt(\"confname\")\n                .argName(\"NAME\")\n                .hasArg()\n                .required(false)\n                .desc(\"Configuration name; default is the collection name.\")\n                .build(),\n            SolrCliTest.OPTION_CREDENTIALS);\n      // @formatter:on\n    }\n\n    private String printHelp(final HelpFormatter formatter) {\n        final Options options = new Options();\n        getOptions().forEach(options::addOption);\n        final String cmdLineSyntax = getClass().getName();\n        final StringWriter out = new StringWriter();\n        final PrintWriter pw = new PrintWriter(out);\n        formatter.printHelp(pw, formatter.getWidth(), cmdLineSyntax, null, options, formatter.getLeftPadding(), formatter.getDescPadding(), null, false);\n        pw.flush();\n        final String actual = out.toString();\n        assertTrue(actual.contains(\"-z,--zk-host <HOST>              Zookeeper connection string; unnecessary\"));\n        return actual;\n    }\n\n    @Test\n    public void testHelpFormatter() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final String actual = printHelp(formatter);\n        assertFalse(actual.contains(\"Deprecated\"));\n    }\n\n    @Test\n    public void testHelpFormatterDeprecated() {\n        final HelpFormatter formatter = HelpFormatter.builder().setShowDeprecated(true).get();\n        final String actual = printHelp(formatter);\n        assertTrue(actual.contains(\"-zkHost,--zkHost <HOST>          [Deprecated] Zookeeper connection\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/PatternOptionBuilderTest.java.PatternOptionBuilderTest", "name": "PatternOptionBuilderTest", "file_path": "src/test/java/org/apache/commons/cli/PatternOptionBuilderTest.java", "superclasses": "", "methods": ["[void]testClassPattern()", "[void]testEmptyPattern()", "[void]testExistingFilePattern()", "[void]testExistingFilePatternFileNotExist()", "[void]testNumberPattern()", "[void]testObjectPattern()", "[void]testRequiredOption()", "[void]testSimplePattern()", "[void]testUntypedPattern()", "[void]testURLPattern()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTest case for the PatternOptionBuilder class.\n", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class PatternOptionBuilderTest {\n\n    @Test\n    public void testClassPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"c+d+\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-c\", \"java.util.Calendar\", \"-d\", \"System.DateTime\"});\n\n        assertEquals(Calendar.class, line.getOptionObject(\"c\"), \"c value\");\n        assertNull(line.getOptionObject(\"d\"), \"d value\");\n    }\n\n    @Test\n    public void testEmptyPattern() {\n        final Options options = PatternOptionBuilder.parsePattern(\"\");\n        assertTrue(options.getOptions().isEmpty());\n    }\n\n    @Test\n    public void testExistingFilePattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"g<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-g\", \"src/test/resources/org/apache/commons/cli/existing-readable.file\"});\n\n        final Object parsedReadableFileStream = line.getOptionObject(\"g\");\n\n        assertNotNull(parsedReadableFileStream, \"option g not parsed\");\n        assertInstanceOf(FileInputStream.class, parsedReadableFileStream, \"option g not FileInputStream\");\n    }\n\n    @Test\n    public void testExistingFilePatternFileNotExist() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"f<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-f\", \"non-existing.file\"});\n\n        assertNull(line.getOptionObject(\"f\"), \"option f parsed\");\n    }\n\n    @Test\n    public void testNumberPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"n%d%x%\");\n        final CommandLineParser parser = new PosixParser();\n        // 3,5 fails validation.\n        //assertThrows(ParseException.class, () -> parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"}));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-n\", \"1\", \"-d\", \"2.1\", \"-x\", \"3,5\"});\n        assertEquals(Long.class, line.getOptionObject(\"n\").getClass(), \"n object class\");\n        assertEquals(Long.valueOf(1), line.getOptionObject(\"n\"), \"n value\");\n\n        assertEquals(Double.class, line.getOptionObject(\"d\").getClass(), \"d object class\");\n        assertEquals(Double.valueOf(2.1), line.getOptionObject(\"d\"), \"d value\");\n\n        assertNull(line.getOptionObject(\"x\"), \"x object\");\n    }\n\n    @Test\n    public void testObjectPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"o@i@n@\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-o\", \"java.lang.String\", \"-i\", \"java.util.Calendar\", \"-n\", \"System.DateTime\"});\n\n        assertEquals(\"\", line.getOptionObject(\"o\"), \"o value\");\n        assertNull(line.getOptionObject(\"i\"), \"i value\");\n        assertNull(line.getOptionObject(\"n\"), \"n value\");\n    }\n\n    @Test\n    public void testRequiredOption() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"!n%m%\");\n        final CommandLineParser parser = new PosixParser();\n\n        try {\n            parser.parse(options, new String[] {\"\"});\n            fail(\"MissingOptionException wasn't thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().contains(\"n\"));\n        }\n    }\n\n    @Test\n    public void testSimplePattern() throws Exception {\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/m*z#\");\n        final Date expectedDate = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String[] args = {\"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\",\n            \"https://commons.apache.org\", \"-z\", dateFormat.format(expectedDate), \"-m\", \"test*\"};\n\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"foo\", line.getOptionValue(\"a\"), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject(\"a\"), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject(\"b\"), \"object flag b\");\n        assertTrue(line.hasOption(\"c\"), \"boolean true flag c\");\n        assertFalse(line.hasOption(\"d\"), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject(\"e\"), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject(\"f\"), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject(\"n\"), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"t\"), \"url flag t\");\n\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertEquals(\"foo\", line.getOptionValue('a'), \"flag a\");\n        assertEquals(\"foo\", line.getOptionObject('a'), \"string flag a\");\n        assertEquals(new Vector<>(), line.getOptionObject('b'), \"object flag b\");\n        assertTrue(line.hasOption('c'), \"boolean true flag c\");\n        assertFalse(line.hasOption('d'), \"boolean false flag d\");\n        assertEquals(new File(\"build.xml\"), line.getOptionObject('e'), \"file flag e\");\n        assertEquals(Calendar.class, line.getOptionObject('f'), \"class flag f\");\n        assertEquals(Double.valueOf(4.5), line.getOptionObject('n'), \"number flag n\");\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject('t'), \"url flag t\");\n\n        // FILES NOT SUPPORTED YET\n        assertThrows(UnsupportedOperationException.class, () -> line.getOptionObject('m'));\n\n        assertEquals(expectedDate, line.getOptionObject('z'), \"date flag z\");\n\n    }\n\n    @Test\n    public void testUntypedPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"abc\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-abc\"});\n\n        assertTrue(line.hasOption('a'));\n        assertNull(line.getOptionObject('a'), \"value a\");\n        assertTrue(line.hasOption('b'));\n        assertNull(line.getOptionObject('b'), \"value b\");\n        assertTrue(line.hasOption('c'));\n        assertNull(line.getOptionObject('c'), \"value c\");\n    }\n\n    @Test\n    public void testURLPattern() throws Exception {\n        final Options options = PatternOptionBuilder.parsePattern(\"u/v/\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] {\"-u\", \"https://commons.apache.org\", \"-v\", \"foo://commons.apache.org\"});\n\n        assertEquals(new URL(\"https://commons.apache.org\"), line.getOptionObject(\"u\"), \"u value\");\n        assertNull(line.getOptionObject(\"v\"), \"v value\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/DeprecatedAttributesTest.java.DeprecatedAttributesTest", "name": "DeprecatedAttributesTest", "file_path": "src/test/java/org/apache/commons/cli/DeprecatedAttributesTest.java", "superclasses": "", "methods": ["[void]testBuilderNonDefaults()", "[void]testBuilderNonDefaultsToString()", "[void]testDefaultBuilder()", "[void]testDefaultToString()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DeprecatedAttributesTest {\n\n    @Test\n    public void testBuilderNonDefaults() {\n        // @formatter:off\n        final DeprecatedAttributes value = DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get();\n        // @formatter:on\n        assertEquals(\"Use Bar instead!\", value.getDescription());\n        assertEquals(\"2.0\", value.getSince());\n        assertEquals(true, value.isForRemoval());\n    }\n\n    @Test\n    public void testBuilderNonDefaultsToString() {\n        // @formatter:off\n        assertEquals(\"Deprecated for removal since 2.0: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated for removal: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setForRemoval(true)\n                .get().toString());\n        assertEquals(\"Deprecated since 2.0: Use Bar instead!\",\n                DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .setSince(\"2.0\")\n                .get().toString());\n        assertEquals(\"Deprecated: Use Bar instead!\", DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .get().toString());\n        // @formatter:on\n    }\n\n    @Test\n    public void testDefaultBuilder() {\n        final DeprecatedAttributes defaultValue = DeprecatedAttributes.builder().get();\n        assertEquals(DeprecatedAttributes.DEFAULT.getDescription(), defaultValue.getDescription());\n        assertEquals(DeprecatedAttributes.DEFAULT.getSince(), defaultValue.getSince());\n        assertEquals(DeprecatedAttributes.DEFAULT.isForRemoval(), defaultValue.isForRemoval());\n    }\n\n    @Test\n    public void testDefaultToString() {\n        assertEquals(\"Deprecated\", DeprecatedAttributes.DEFAULT.toString());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/PatternOptionBuilder_getValueTypeTest.java.PatternOptionBuilder_getValueTypeTest", "name": "PatternOptionBuilder_getValueTypeTest", "file_path": "src/test/java/org/apache/commons/cli/PatternOptionBuilder_getValueTypeTest.java", "superclasses": "", "methods": ["[void]testGetValueTypeObject()", "[void]testGetValueTypeString()", "[void]testGetValueTypeNumber()", "[void]testGetValueTypeClass()", "[void]testGetValueTypeDate()", "[void]testGetValueTypeExistingFile()", "[void]testGetValueTypeFile()", "[void]testGetValueTypeFiles()", "[void]testGetValueTypeURL()", "[void]testGetValueTypeNull()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PatternOptionBuilder_getValueTypeTest {\n\n    @Test\n    public void testGetValueTypeObject() {\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, PatternOptionBuilder.getValueType('@'));\n    }\n\n    @Test\n    public void testGetValueTypeString() {\n        assertEquals(PatternOptionBuilder.STRING_VALUE, PatternOptionBuilder.getValueType(':'));\n    }\n\n    @Test\n    public void testGetValueTypeNumber() {\n        assertEquals(PatternOptionBuilder.NUMBER_VALUE, PatternOptionBuilder.getValueType('%'));\n    }\n\n    @Test\n    public void testGetValueTypeClass() {\n        assertEquals(PatternOptionBuilder.CLASS_VALUE, PatternOptionBuilder.getValueType('+'));\n    }\n\n    @Test\n    public void testGetValueTypeDate() {\n        assertEquals(PatternOptionBuilder.DATE_VALUE, PatternOptionBuilder.getValueType('#'));\n    }\n\n    @Test\n    public void testGetValueTypeExistingFile() {\n        assertEquals(PatternOptionBuilder.EXISTING_FILE_VALUE, PatternOptionBuilder.getValueType('<'));\n    }\n\n    @Test\n    public void testGetValueTypeFile() {\n        assertEquals(PatternOptionBuilder.FILE_VALUE, PatternOptionBuilder.getValueType('>'));\n    }\n\n    @Test\n    public void testGetValueTypeFiles() {\n        assertEquals(PatternOptionBuilder.FILES_VALUE, PatternOptionBuilder.getValueType('*'));\n    }\n\n    @Test\n    public void testGetValueTypeURL() {\n        assertEquals(PatternOptionBuilder.URL_VALUE, PatternOptionBuilder.getValueType('/'));\n    }\n\n    @Test\n    public void testGetValueTypeNull() {\n        assertNull(PatternOptionBuilder.getValueType('X'));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/UtilTest.java.UtilTest", "name": "UtilTest", "file_path": "src/test/java/org/apache/commons/cli/UtilTest.java", "superclasses": "", "methods": ["[void]testStripLeadingAndTrailingQuotes()", "[void]testStripLeadingHyphens()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UtilTest {\n\n    @Test\n    public void testStripLeadingAndTrailingQuotes() {\n        assertNull(Util.stripLeadingAndTrailingQuotes(null));\n        assertEquals(\"\", Util.stripLeadingAndTrailingQuotes(\"\"));\n        assertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\n        assertEquals(\"foo \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"foo \\\"bar\\\"\"));\n        assertEquals(\"\\\"foo\\\" bar\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" bar\"));\n        assertEquals(\"\\\"foo\\\" and \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" and \\\"bar\\\"\"));\n        assertEquals(\"\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"\"));\n    }\n\n    @Test\n    public void testStripLeadingHyphens() {\n        assertEquals(\"f\", Util.stripLeadingHyphens(\"-f\"));\n        assertEquals(\"foo\", Util.stripLeadingHyphens(\"--foo\"));\n        assertEquals(\"-foo\", Util.stripLeadingHyphens(\"---foo\"));\n        assertNull(Util.stripLeadingHyphens(null));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/Options_addOptionTest.java.Options_addOptionTest", "name": "Options_addOptionTest", "file_path": "src/test/java/org/apache/commons/cli/Options_addOptionTest.java", "superclasses": "", "methods": ["[void]testAddOptionWithLongOpt()", "[void]testAddOptionWithoutLongOpt()", "[void]testAddOptionRequired()", "[void]testAddOptionRequiredTwice()"], "method_uris": ["src/test/java/org/apache/commons/cli/Options_addOptionTest.java.Options_addOptionTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Options_addOptionTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testAddOptionWithLongOpt() {\n        Option opt = new Option(\"a\", \"apple\", false, \"an apple\");\n        options.addOption(opt);\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasLongOption(\"apple\"));\n        assertEquals(opt, options.getOption(\"apple\"));\n    }\n\n    @Test\n    public void testAddOptionWithoutLongOpt() {\n        Option opt = new Option(\"b\", false, \"a banana\");\n        options.addOption(opt);\n        assertTrue(options.hasOption(\"b\"));\n        assertFalse(options.hasLongOption(\"banana\"));\n        assertEquals(opt, options.getOption(\"b\"));\n    }\n\n    @Test\n    public void testAddOptionRequired() {\n        Option opt = new Option(\"c\", \"cherry\", true, \"a cherry\");\n        opt.setRequired(true);\n        options.addOption(opt);\n        assertTrue(options.hasOption(\"c\"));\n        assertTrue(options.hasLongOption(\"cherry\"));\n        assertTrue(options.getOption(\"cherry\").isRequired());\n    }\n\n    @Test\n    public void testAddOptionRequiredTwice() {\n        Option opt = new Option(\"d\", \"date\", true, \"a date\");\n        opt.setRequired(true);\n        options.addOption(opt);\n        options.addOption(opt);\n        assertTrue(options.hasOption(\"d\"));\n        assertTrue(options.hasLongOption(\"date\"));\n        assertTrue(options.getOption(\"date\").isRequired());\n        assertEquals(1, options.getRequiredOptions().size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/OptionGroupTest.java.OptionGroupTest", "name": "OptionGroupTest", "file_path": "src/test/java/org/apache/commons/cli/OptionGroupTest.java", "superclasses": "", "methods": ["[void]testGetNames()", "[void]testNoOptionsExtraArgs()", "[void]testSingleLongOption()", "[void]testSingleOption()", "[void]testSingleOptionFromGroup()", "[void]testToString()", "[void]testTwoLongOptionsFromGroup()", "[void]testTwoOptionsFromDifferentGroup()", "[void]testTwoOptionsFromGroup()", "[void]testTwoOptionsFromGroupWithProperties()", "[void]testTwoValidLongOptions()", "[void]testTwoValidOptions()", "[void]testValidLongOnlyOptions()"], "method_uris": ["src/test/java/org/apache/commons/cli/OptionGroupTest.java.OptionGroupTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class OptionGroupTest {\n    private Options options;\n    private final Parser parser = new PosixParser();\n\n    @BeforeEach\n    public void setUp() {\n        final Option file = new Option(\"f\", \"file\", false, \"file to process\");\n        final Option dir = new Option(\"d\", \"directory\", false, \"directory to process\");\n        final OptionGroup group = new OptionGroup();\n        group.addOption(file);\n        group.addOption(dir);\n        options = new Options().addOptionGroup(group);\n\n        final Option section = new Option(\"s\", \"section\", false, \"section to process\");\n        final Option chapter = new Option(\"c\", \"chapter\", false, \"chapter to process\");\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(section);\n        group2.addOption(chapter);\n\n        options.addOptionGroup(group2);\n\n        final Option importOpt = new Option(null, \"import\", false, \"section to process\");\n        final Option exportOpt = new Option(null, \"export\", false, \"chapter to process\");\n        final OptionGroup group3 = new OptionGroup();\n        group3.addOption(importOpt);\n        group3.addOption(exportOpt);\n        options.addOptionGroup(group3);\n\n        options.addOption(\"r\", \"revision\", false, \"revision number\");\n    }\n\n    @Test\n    public void testGetNames() {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n\n        group.addOption(OptionBuilder.create('a'));\n        group.addOption(OptionBuilder.create('b'));\n\n        assertNotNull(group.getNames(), \"null names\");\n        assertEquals(2, group.getNames().size());\n        assertTrue(group.getNames().contains(\"a\"));\n        assertTrue(group.getNames().contains(\"b\"));\n    }\n\n    @Test\n    public void testNoOptionsExtraArgs() throws Exception {\n        final String[] args = {\"arg1\", \"arg2\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm TWO extra args\");\n    }\n\n    @Test\n    public void testSingleLongOption() throws Exception {\n        final String[] args = {\"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testSingleOption() throws Exception {\n        final String[] args = {\"-r\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertFalse(cl.hasOption(\"f\"), \"Confirm -f is NOT set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testSingleOptionFromGroup() throws Exception {\n        final String[] args = {\"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testToString() {\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(null, \"foo\", false, \"Foo\"));\n        group1.addOption(new Option(null, \"bar\", false, \"Bar\"));\n\n        if (!\"[--bar Bar, --foo Foo]\".equals(group1.toString())) {\n            assertEquals(\"[--foo Foo, --bar Bar]\", group1.toString());\n        }\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"f\", \"foo\", false, \"Foo\"));\n        group2.addOption(new Option(\"b\", \"bar\", false, \"Bar\"));\n\n        if (!\"[-b Bar, -f Foo]\".equals(group2.toString())) {\n            assertEquals(\"[-f Foo, -b Bar]\", group2.toString());\n        }\n    }\n\n    @Test\n    public void testTwoLongOptionsFromGroup() throws Exception {\n        final String[] args = {\"--file\", \"--directory\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }\n\n    @Test\n    public void testTwoOptionsFromDifferentGroup() throws Exception {\n        final String[] args = {\"-f\", \"-s\"};\n\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"r\"), \"Confirm -r is NOT set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertTrue(cl.hasOption(\"s\"), \"Confirm -s is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO extra args\");\n    }\n\n    @Test\n    public void testTwoOptionsFromGroup() throws Exception {\n        final String[] args = {\"-f\", \"-d\"};\n\n        try {\n            parser.parse(options, args);\n            fail(\"two arguments from group not allowed\");\n        } catch (final AlreadySelectedException e) {\n            assertNotNull(e.getOptionGroup(), \"null option group\");\n            assertTrue(e.getOptionGroup().isSelected());\n            assertEquals(\"f\", e.getOptionGroup().getSelected(), \"selected option\");\n            assertEquals(\"d\", e.getOption().getOpt(), \"option\");\n        }\n    }\n\n    @Test\n    public void testTwoOptionsFromGroupWithProperties() throws Exception {\n        final String[] args = {\"-f\"};\n\n        final Properties properties = new Properties();\n        properties.put(\"d\", \"true\");\n\n        final CommandLine cl = parser.parse(options, args, properties);\n        assertTrue(cl.hasOption(\"f\"));\n        assertFalse(cl.hasOption(\"d\"));\n    }\n\n    @Test\n    public void testTwoValidLongOptions() throws Exception {\n        final String[] args = {\"--revision\", \"--file\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testTwoValidOptions() throws Exception {\n        final String[] args = {\"-r\", \"-f\"};\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"r\"), \"Confirm -r is set\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertFalse(cl.hasOption(\"d\"), \"Confirm -d is NOT set\");\n        assertFalse(cl.hasOption(\"s\"), \"Confirm -s is NOT set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is NOT set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args\");\n    }\n\n    @Test\n    public void testValidLongOnlyOptions() throws Exception {\n        final CommandLine cl1 = parser.parse(options, new String[] {\"--export\"});\n        assertTrue(cl1.hasOption(\"export\"), \"Confirm --export is set\");\n\n        final CommandLine cl2 = parser.parse(options, new String[] {\"--import\"});\n        assertTrue(cl2.hasOption(\"import\"), \"Confirm --import is set\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "private final Parser parser = new PosixParser();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Parser", "name": "parser = new PosixParser()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/CommandLineTest.java.CommandLineTest", "name": "CommandLineTest", "file_path": "src/test/java/org/apache/commons/cli/CommandLineTest.java", "superclasses": "", "methods": ["[void]getOptionValuesTest(String[],Option,OptionGroup,boolean,String[],boolean,String[],Option)", "[void]getOptionValueTest(String[],Option,OptionGroup,boolean,String,boolean,String,Option)", "[void]getParsedOptionValueTest(String[],Option,OptionGroup,boolean,Integer,boolean,Integer,Option)", "[void]hasOptionNoDeprecationHandlerTest(String[],Option,OptionGroup,boolean,boolean,boolean,boolean,Option)", "[void]hasOptionNullDeprecationHandlerTest(String[],Option,OptionGroup,boolean,boolean,boolean,boolean,Option)", "[void]hasOptionTest(String[],Option,OptionGroup,boolean,boolean,boolean,boolean,Option)", "[void]noDeprecationHandlerTest(String[],Option,OptionGroup,boolean,String,boolean,String,Option)", "[void]testBadGetParsedOptionValue()", "[void]testBuilder()", "[void]testBuilderNullArgs()", "[void]testBuilderNullOption()", "[void]testGetOptionProperties()", "[void]testGetOptionPropertiesWithOption()", "[void]testGetOptionsBuilder()", "[void]testGetOptionsCtor()", "[void]testNullOption()"], "method_uris": ["src/test/java/org/apache/commons/cli/CommandLineTest.java.CommandLineTest.[Stream<Arguments>]createHasOptionParameters()", "src/test/java/org/apache/commons/cli/CommandLineTest.java.CommandLineTest.[Stream<Arguments>]createOptionValueParameters()", "src/test/java/org/apache/commons/cli/CommandLineTest.java.CommandLineTest.[Stream<Arguments>]createOptionValuesParameters()", "src/test/java/org/apache/commons/cli/CommandLineTest.java.CommandLineTest.[Stream<Arguments>]createParsedOptionValueParameters()", "src/test/java/org/apache/commons/cli/CommandLineTest.java.CommandLineTest.[char]asChar(Option)", "src/test/java/org/apache/commons/cli/CommandLineTest.java.CommandLineTest.[void]assertWritten(boolean,ByteArrayOutputStream)", "src/test/java/org/apache/commons/cli/CommandLineTest.java.CommandLineTest.[void]checkHandler(boolean,List<Option>,Option)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CommandLineTest {\n\n    private enum Count { ONE, TWO, THREE }\n\n    private static Stream<Arguments> createHasOptionParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, true, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, true, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, false, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, false, false, true, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, false, true, true, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, false, true, true, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, true, false, true, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, true, false, true, optU));\n\n        return lst.stream();\n    }\n\n    private static Stream<Arguments> createOptionValueParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optT, optionGroup, true, \"foo\", true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"}, optT, optionGroup, false, null, false, \"foo\", optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\"}, optU, optionGroup, false, null, true, \"foo\", optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\"}, optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\"},  optU, optionGroup, false, \"foo\", false, \"foo\", optU));\n\n        return lst.stream();\n    }\n\n    private static Stream<Arguments> createOptionValuesParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").numberOfArgs(2).deprecated().optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").numberOfArgs(2).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n\n        final String[] foobar = { \"foo\", \"bar\" };\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optT, optionGroup, true, foobar, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"}, optT, optionGroup, false, null, false, foobar, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"foo\", \"bar\"}, optU, optionGroup, false, null, true, foobar, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"foo\", \"bar\"}, optU, optionGroup, false, foobar, false, foobar, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"foo\", \"bar\"},  optU, optionGroup, false, foobar, false, foobar, optU));\n\n        return lst.stream();\n    }\n\n    private static Stream<Arguments> createParsedOptionValueParameters() throws ParseException {\n        final List<Arguments> lst = new ArrayList<>();\n        final Option optT = Option.builder().option(\"T\").longOpt(\"tee\").deprecated().type(Integer.class).optionalArg(true).build();\n        final Option optU = Option.builder(\"U\").longOpt(\"you\").type(Integer.class).optionalArg(true).build();\n        final OptionGroup optionGroup = new OptionGroup().addOption(optT).addOption(optU);\n        final Integer expected = Integer.valueOf(1);\n\n        // T set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optT, optionGroup, true, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optT, optionGroup, true, expected, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optT, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"}, optT, optionGroup, false, null, false, expected, optU));\n\n\n        // U set\n        lst.add(Arguments.of(new String[] {\"-T\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"-T\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\"}, optU, optionGroup, false, null, true, null, optT));\n        lst.add(Arguments.of(new String[] {\"--tee\", \"1\"}, optU, optionGroup, false, null, true, expected, optT));\n\n        lst.add(Arguments.of(new String[] {\"-U\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"-U\", \"1\"}, optU, optionGroup, false, expected, false, expected, optU));\n        lst.add(Arguments.of(new String[] {\"--you\"}, optU, optionGroup, false, null, false, null, optU));\n        lst.add(Arguments.of(new String[] {\"--you\", \"1\"},  optU, optionGroup, false, expected, false, expected, optU));\n\n        return lst.stream();\n    }\n\n    char asChar(final Option opt) {\n        return opt.getOpt().charAt(0);\n    }\n\n    private void assertWritten(final boolean optDep, final ByteArrayOutputStream baos) {\n        System.out.flush();\n        if (optDep) {\n            assertEquals(\"Option 'T''tee': Deprecated\", baos.toString().trim());\n        } else {\n            assertEquals(\"\", baos.toString());\n        }\n        baos.reset();\n    }\n\n    /**\n     * verifies that the deprecation handler has been called only once or not at all.\n     * @param optDep {@code true} if the dependency should have been logged.\n     * @param handler The list that the deprecation is logged to.\n     * @param opt The option that triggered the logging. May be (@code null} if {@code optDep} is {@code false}.\n     */\n    void checkHandler(final boolean optDep, final List<Option> handler, final Option opt) {\n        if (optDep) {\n            assertEquals(1, handler.size());\n            assertEquals(opt, handler.get(0));\n        } else {\n            assertEquals(0, handler.size());\n        }\n        handler.clear();\n    }\n\n    /**\n     * Test for get option values with and without default values.  Verifies that deprecated options only report as\n     * deprecated once.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param optValue  The value expected from opt.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param grpValue the value expected from the group.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parse error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValuesParameters\")\n    public void getOptionValuesTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                    final String[] optValue, final boolean grpDep, final String[] grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertArrayEquals(optValue, commandLine.getOptionValues(opt));\n        checkHandler(optDep, handler, opt);\n\n\n        // test OptionGroup arg\n        assertArrayEquals(grpValue, commandLine.getOptionValues(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValues(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValues(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test null group arg\n        assertNull(commandLine.getOptionValues(nullGroup));\n        checkHandler(false, handler, grpOpt);\n    }\n\n    /**\n     * Test for get option value with and without default values.  Verifies that deprecated options only report as\n     * deprecated once.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param optValue  The value expected from opt.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param grpValue the value expected from the group.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parse error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void getOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option\n        assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test option group  arg\n        assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertNull(commandLine.getOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertNull(commandLine.getOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }\n\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createParsedOptionValueParameters\")\n    public void getParsedOptionValueTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                         final Integer optValue, final boolean grpDep, final Integer grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final Supplier<Integer> thinger = () -> 2;\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n        final Integer thing = 2;\n\n        // test char option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(asChar(opt), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt.getLongOpt(), thinger));\n        checkHandler(optDep, handler, opt);\n\n\n        // test Option arg\n        assertEquals(optValue, commandLine.getParsedOptionValue(opt));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thing));\n        checkHandler(optDep, handler, opt);\n\n        assertEquals(optValue == null ? thing : optValue, commandLine.getParsedOptionValue(opt, thinger));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(grpValue, commandLine.getParsedOptionValue(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thing));\n        checkHandler(grpDep, handler, grpOpt);\n\n        assertEquals(grpValue == null ? thing : grpValue, commandLine.getParsedOptionValue(optionGroup, thinger));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other Group arg\n        assertNull(commandLine.getParsedOptionValue(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(otherGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n        // test null Group arg\n        assertNull(commandLine.getParsedOptionValue(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thing));\n        checkHandler(false, handler, grpOpt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(nullGroup, thinger));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test not an option\n        assertNull(commandLine.getParsedOptionValue(\"Nope\"));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thing));\n        checkHandler(false, handler, opt);\n\n        assertEquals(thing, commandLine.getParsedOptionValue(\"Nope\", thinger));\n        checkHandler(false, handler, opt);\n    }\n\n    /**\n     * Tests the hasOption calls.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param has {@code true} if the opt is present.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param hasGrp {@code true} if the group is present.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parsing error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNoDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(optDep, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(optDep, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(grpDep, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }\n\n    /**\n     * Tests the hasOption calls.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param has {@code true} if the opt is present.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param hasGrp {@code true} if the group is present.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parsing error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionNullDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                                  final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(null).build().parse(options, args);\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            // test char option arg\n            assertEquals(has, commandLine.hasOption(asChar(opt)));\n            assertWritten(false, baos);\n\n\n            // test short option arg\n            assertEquals(has, commandLine.hasOption(opt.getOpt()));\n            assertWritten(false, baos);\n\n            // test long option arg\n            assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n            assertWritten(false, baos);\n\n            // test Option arg\n            assertEquals(has, commandLine.hasOption(opt));\n            assertWritten(false, baos);\n\n            // test OptionGroup arg\n            assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertFalse(commandLine.hasOption(\"Nope\"));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }\n\n    /**\n     * Tests the hasOption calls.\n     * @param args the argument strings to parse.\n     * @param opt the option to check for values with.\n     * @param optionGroup the option group to check for values with.\n     * @param optDep {@code true} if the opt is deprecated.\n     * @param has {@code true} if the opt is present.\n     * @param grpDep {@code true} if the group is deprecated.\n     * @param hasGrp {@code true} if the group is present.\n     * @param grpOpt the option that is expected to be processed by the group.\n     * @throws ParseException on parsing error.\n     */\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createHasOptionParameters\")\n    public void hasOptionTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                              final boolean has, final boolean grpDep, final boolean hasGrp, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final List<Option> handler = new ArrayList<>();\n        final CommandLine commandLine = DefaultParser.builder().setDeprecatedHandler(handler::add).build().parse(options, args);\n        final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n        final OptionGroup nullGroup = null;\n\n        // test char option arg\n        assertEquals(has, commandLine.hasOption(asChar(opt)));\n        checkHandler(optDep, handler, opt);\n\n        // test short option arg\n        assertEquals(has, commandLine.hasOption(opt.getOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test long option arg\n        assertEquals(has, commandLine.hasOption(opt.getLongOpt()));\n        checkHandler(optDep, handler, opt);\n\n        // test Option arg\n        assertEquals(has, commandLine.hasOption(opt));\n        checkHandler(optDep, handler, opt);\n\n        // test OptionGroup arg\n        assertEquals(hasGrp, commandLine.hasOption(optionGroup));\n        checkHandler(grpDep, handler, grpOpt);\n\n        // test other group arg\n        assertFalse(commandLine.hasOption(otherGroup));\n        checkHandler(false, handler, grpOpt);\n\n\n        // test null group arg\n        assertFalse(commandLine.hasOption(nullGroup));\n        checkHandler(false, handler, grpOpt);\n\n        // test not an option\n        assertFalse(commandLine.hasOption(\"Nope\"));\n        checkHandler(false, handler, opt);\n    }\n\n    @ParameterizedTest(name = \"{0}, {1}\")\n    @MethodSource(\"createOptionValueParameters\")\n    public void noDeprecationHandlerTest(final String[] args, final Option opt, final OptionGroup optionGroup, final boolean optDep,\n                                   final String optValue, final boolean grpDep, final String grpValue, final Option grpOpt) throws ParseException {\n        final Options options = new Options().addOptionGroup(optionGroup);\n        final CommandLine commandLine = DefaultParser.builder().build().parse(options, args);\n        final Supplier<String> thinger = () -> \"thing\";\n        final Supplier<String> nullSupplier = null;\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final PrintStream ps = System.out;\n        try {\n            System.setOut(new PrintStream(baos));\n\n            final OptionGroup otherGroup = new OptionGroup().addOption(Option.builder(\"o\").longOpt(\"other\").hasArg().build())\n                    .addOption(Option.builder().option(\"p\").longOpt(\"part\").hasArg().build());\n            final OptionGroup nullGroup = null;\n\n            // test char option\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt)));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(asChar(opt), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(asChar(opt), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test short option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test long option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt()));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt.getLongOpt(), thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt.getLongOpt(), nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test Option arg\n            assertEquals(optValue, commandLine.getOptionValue(opt));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, \"thing\"));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue == null ? \"thing\" : optValue, commandLine.getOptionValue(opt, thinger));\n            assertWritten(optDep, baos);\n\n            assertEquals(optValue, commandLine.getOptionValue(opt, nullSupplier));\n            assertWritten(optDep, baos);\n\n            // test optionGroup  arg\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, \"thing\"));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue == null ? \"thing\" : grpValue, commandLine.getOptionValue(optionGroup, thinger));\n            assertWritten(grpDep, baos);\n\n            assertEquals(grpValue, commandLine.getOptionValue(optionGroup, nullSupplier));\n            assertWritten(grpDep, baos);\n\n            // test other group arg\n            assertNull(commandLine.getOptionValue(otherGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(otherGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(otherGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test null Group arg\n            assertNull(commandLine.getOptionValue(nullGroup));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(nullGroup, thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(nullGroup, nullSupplier));\n            assertWritten(false, baos);\n\n            // test not an option\n            assertNull(commandLine.getOptionValue(\"Nope\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", \"thing\"));\n            assertWritten(false, baos);\n\n            assertEquals(\"thing\", commandLine.getOptionValue(\"Nope\", thinger));\n            assertWritten(false, baos);\n\n            assertNull(commandLine.getOptionValue(\"Nope\", nullSupplier));\n            assertWritten(false, baos);\n        } finally {\n            System.setOut(ps);\n        }\n    }\n\n    @Test\n    public void testBadGetParsedOptionValue() throws Exception {\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").hasArg().type(Number.class).build());\n        options.addOption(Option.builder(\"c\").hasArg().converter(s -> Count.valueOf(s.toUpperCase())).build());\n\n\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"foo\", \"-c\", \"bar\"});\n\n        assertEquals(NumberFormatException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"i\")).getCause().getClass());\n        assertEquals(IllegalArgumentException.class, assertThrows(ParseException.class, () -> cmd.getParsedOptionValue(\"c\")).getCause().getClass());\n    }\n\n\n    @Test\n    public void testBuilder() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }\n\n    @Test\n    public void testBuilderNullArgs() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(null).addArg(null);\n        builder.addOption(Option.builder(\"T\").build());\n        final CommandLine cmd = builder.build();\n\n        assertEquals(0, cmd.getArgs().length);\n        assertEquals(\"T\", cmd.getOptions()[0].getOpt());\n    }\n\n    @Test\n    public void testBuilderNullOption() {\n        final CommandLine.Builder builder = new CommandLine.Builder();\n        builder.addArg(\"foo\").addArg(\"bar\");\n        builder.addOption(null);\n        builder.addOption(null);\n        builder.addOption(null);\n        final CommandLine cmd = builder.build();\n\n        assertEquals(\"foo\", cmd.getArgs()[0]);\n        assertEquals(\"bar\", cmd.getArgList().get(1));\n        assertEquals(0, cmd.getOptions().length);\n    }\n\n    @Test\n    public void testGetOptionProperties() throws Exception {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        options.addOption(Option.builder(\"D\").valueSeparator().optionalArg(true).numberOfArgs(2).build());\n        options.addOption(Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build());\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(\"property\").getProperty(\"foo\"), \"property with long format\");\n    }\n\n    @Test\n    public void testGetOptionPropertiesWithOption() throws Exception {\n        final String[] args = {\"-Dparam1=value1\", \"-Dparam2=value2\", \"-Dparam3\", \"-Dparam4=value4\", \"-D\", \"--property\", \"foo=bar\"};\n\n        final Options options = new Options();\n        final Option optionD = Option.builder(\"D\").valueSeparator().numberOfArgs(2).optionalArg(true).build();\n        final Option optionProperty = Option.builder().valueSeparator().numberOfArgs(2).longOpt(\"property\").build();\n        options.addOption(optionD);\n        options.addOption(optionProperty);\n\n        final Parser parser = new GnuParser();\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(optionD);\n        assertNotNull(props, \"null properties\");\n        assertEquals(4, props.size(), \"number of properties in \" + props);\n        assertEquals(\"value1\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n        assertEquals(\"true\", props.getProperty(\"param3\"), \"property 3\");\n        assertEquals(\"value4\", props.getProperty(\"param4\"), \"property 4\");\n\n        assertEquals(\"bar\", cl.getOptionProperties(optionProperty).getProperty(\"foo\"), \"property with long format\");\n    }\n\n    @Test\n    public void testGetOptionsBuilder() {\n        final CommandLine cmd = CommandLine.builder().build();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(null);\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n\n        assertEquals(3, cmd.getOptions().length);\n    }\n\n    @Test\n    public void testGetOptionsCtor() {\n        final CommandLine cmd = new CommandLine();\n        assertNotNull(cmd.getOptions());\n        assertEquals(0, cmd.getOptions().length);\n\n        cmd.addOption(new Option(\"a\", null));\n        cmd.addOption(new Option(\"b\", null));\n        cmd.addOption(new Option(\"c\", null));\n        cmd.addOption(null);\n\n        assertEquals(3, cmd.getOptions().length);\n    }\n\n    @Test\n    public void testNullOption() throws Exception {\n        final Options options = new Options();\n        final Option optI = Option.builder(\"i\").hasArg().type(Number.class).build();\n        final Option optF = Option.builder(\"f\").hasArg().build();\n        options.addOption(optI);\n        options.addOption(optF);\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(options, new String[] {\"-i\", \"123\", \"-f\", \"foo\"});\n        assertNull(cmd.getOptionValue((Option) null));\n        assertNull(cmd.getParsedOptionValue((Option) null));\n        assertNull(cmd.getOptionValue((OptionGroup) null));\n        assertNull(cmd.getParsedOptionValue((OptionGroup) null));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/BasicParserTest.java.BasicParserTest", "name": "BasicParserTest", "file_path": "src/test/java/org/apache/commons/cli/BasicParserTest.java", "superclasses": "AbstractParserTestCase", "methods": ["[void]testAmbiguousLongWithoutEqualSingleDash()", "[void]testAmbiguousLongWithoutEqualSingleDash2()", "[void]testAmbiguousPartialLongOption1()", "[void]testAmbiguousPartialLongOption2()", "[void]testAmbiguousPartialLongOption3()", "[void]testAmbiguousPartialLongOption4()", "[void]testBursting()", "[void]testDoubleDash2()", "[void]testLongOptionWithEqualsQuoteHandling()", "[void]testLongWithEqualDoubleDash()", "[void]testLongWithEqualSingleDash()", "[void]testLongWithoutEqualSingleDash()", "[void]testMissingArgWithBursting()", "[void]testNegativeOption()", "[void]testPartialLongOptionSingleDash()", "[void]testPropertiesOption1()", "[void]testPropertiesOption2()", "[void]testShortOptionConcatenatedQuoteHandling()", "[void]testShortWithEqual()", "[void]testShortWithoutEqual()", "[void]testStopBursting()", "[void]testStopBursting2()", "[void]testUnambiguousPartialLongOption1()", "[void]testUnambiguousPartialLongOption2()", "[void]testUnambiguousPartialLongOption3()", "[void]testUnambiguousPartialLongOption4()", "[void]testUnrecognizedOptionWithBursting()"], "method_uris": ["src/test/java/org/apache/commons/cli/BasicParserTest.java.BasicParserTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTODO Needs a rework using JUnit parameterized tests.\n", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BasicParserTest extends AbstractParserTestCase {\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new BasicParser();\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testDoubleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualDoubleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testMissingArgWithBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPartialLongOptionSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testPropertiesOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithEqual() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testShortWithoutEqual() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testStopBursting2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the BasicParser\")\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/Options_getOptionTest.java.Options_getOptionTest", "name": "Options_getOptionTest", "file_path": "src/test/java/org/apache/commons/cli/Options_getOptionTest.java", "superclasses": "", "methods": ["[void]testGetOptionShort()", "[void]testGetOptionLong()", "[void]testGetOptionNotFound()", "[void]testGetOptionWithHyphens()", "[void]testGetOptionMixedCase()"], "method_uris": ["src/test/java/org/apache/commons/cli/Options_getOptionTest.java.Options_getOptionTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Options_getOptionTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testGetOptionShort() {\n        options.addOption(\"a\", \"first\", false, \"first option\");\n        Option option = options.getOption(\"a\");\n        assertNotNull(option);\n        assertEquals(\"a\", option.getOpt());\n    }\n\n    @Test\n    public void testGetOptionLong() {\n        options.addOption(\"b\", \"second\", true, \"second option\");\n        Option option = options.getOption(\"second\");\n        assertNotNull(option);\n        assertEquals(\"second\", option.getLongOpt());\n    }\n\n    @Test\n    public void testGetOptionNotFound() {\n        Option option = options.getOption(\"c\");\n        assertNull(option);\n    }\n\n    @Test\n    public void testGetOptionWithHyphens() {\n        options.addOption(\"d\", \"fourth\", false, \"fourth option\");\n        Option option = options.getOption(\"--fourth\");\n        assertNotNull(option);\n        assertEquals(\"fourth\", option.getLongOpt());\n    }\n\n    @Test\n    public void testGetOptionMixedCase() {\n        options.addOption(\"e\", \"fifth\", false, \"fifth option\");\n        Option option = options.getOption(\"fifth\");\n        assertNotNull(option);\n        assertEquals(\"fifth\", option.getLongOpt());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/OptionGroup_addOptionTest.java.OptionGroup_addOptionTest", "name": "OptionGroup_addOptionTest", "file_path": "src/test/java/org/apache/commons/cli/OptionGroup_addOptionTest.java", "superclasses": "", "methods": ["[void]testAddOption()", "[void]testAddMultipleOptions()"], "method_uris": ["src/test/java/org/apache/commons/cli/OptionGroup_addOptionTest.java.OptionGroup_addOptionTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class OptionGroup_addOptionTest {\n\n    private OptionGroup optionGroup;\n\n    @BeforeEach\n    public void setUp() {\n        optionGroup = new OptionGroup();\n    }\n\n    @Test\n    public void testAddOption() {\n        Option option = new Option(\"opt\", \"Option description\");\n        optionGroup.addOption(option);\n\n        assertTrue(optionGroup.getNames().contains(\"opt\"));\n        assertTrue(optionGroup.getOptions().contains(option));\n    }\n\n    @Test\n    public void testAddMultipleOptions() {\n        Option option1 = new Option(\"opt1\", \"Option 1 description\");\n        Option option2 = new Option(\"opt2\", \"Option 2 description\");\n\n        optionGroup.addOption(option1);\n        optionGroup.addOption(option2);\n\n        assertEquals(2, optionGroup.getNames().size());\n        assertTrue(optionGroup.getNames().contains(\"opt1\"));\n        assertTrue(optionGroup.getNames().contains(\"opt2\"));\n\n        assertEquals(2, optionGroup.getOptions().size());\n        assertTrue(optionGroup.getOptions().contains(option1));\n        assertTrue(optionGroup.getOptions().contains(option2));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private OptionGroup optionGroup;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OptionGroup", "name": "optionGroup", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/PosixParserTest.java.PosixParserTest", "name": "PosixParserTest", "file_path": "src/test/java/org/apache/commons/cli/PosixParserTest.java", "superclasses": "AbstractParserTestCase", "methods": ["[void]testAmbiguousLongWithoutEqualSingleDash()", "[void]testAmbiguousLongWithoutEqualSingleDash2()", "[void]testAmbiguousPartialLongOption4()", "[void]testDoubleDash2()", "[void]testLongWithEqualSingleDash()", "[void]testLongWithoutEqualSingleDash()", "[void]testLongWithUnexpectedArgument1()", "[void]testNegativeOption()", "[void]testShortWithEqual()", "[void]testUnambiguousPartialLongOption4()"], "method_uris": ["src/test/java/org/apache/commons/cli/PosixParserTest.java.PosixParserTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest case for the PosixParser.\n\nTODO Needs a rework using JUnit parameterized tests.\n", "original_string": "public class PosixParserTest extends AbstractParserTestCase {\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new PosixParser();\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testDoubleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testLongWithUnexpectedArgument1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testShortWithEqual() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the PosixParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/GnuParserTest.java.GnuParserTest", "name": "GnuParserTest", "file_path": "src/test/java/org/apache/commons/cli/GnuParserTest.java", "superclasses": "AbstractParserTestCase", "methods": ["[void]testAmbiguousLongWithoutEqualSingleDash()", "[void]testAmbiguousLongWithoutEqualSingleDash2()", "[void]testAmbiguousPartialLongOption1()", "[void]testAmbiguousPartialLongOption2()", "[void]testAmbiguousPartialLongOption3()", "[void]testAmbiguousPartialLongOption4()", "[void]testBursting()", "[void]testDoubleDash2()", "[void]testLongWithoutEqualSingleDash()", "[void]testLongWithUnexpectedArgument1()", "[void]testLongWithUnexpectedArgument2()", "[void]testMissingArgWithBursting()", "[void]testNegativeOption()", "[void]testPartialLongOptionSingleDash()", "[void]testShortWithUnexpectedArgument()", "[void]testStopBursting()", "[void]testStopBursting2()", "[void]testUnambiguousPartialLongOption1()", "[void]testUnambiguousPartialLongOption2()", "[void]testUnambiguousPartialLongOption3()", "[void]testUnambiguousPartialLongOption4()", "[void]testUnrecognizedOptionWithBursting()"], "method_uris": ["src/test/java/org/apache/commons/cli/GnuParserTest.java.GnuParserTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTODO Needs a rework using JUnit parameterized tests.\n", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class GnuParserTest extends AbstractParserTestCase {\n    @Override\n    @BeforeEach\n    public void setUp() {\n        super.setUp();\n        parser = new GnuParser();\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testAmbiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testDoubleDash2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithoutEqualSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testLongWithUnexpectedArgument2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testMissingArgWithBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser (CLI-184)\")\n    public void testNegativeOption() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testPartialLongOptionSingleDash() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testShortWithUnexpectedArgument() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testStopBursting2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption1() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption2() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption3() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnambiguousPartialLongOption4() throws Exception {\n    }\n\n    @Override\n    @Test\n    @Disabled(\"not supported by the GnuParser\")\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/TypeHandler_createValueTest.java.TypeHandler_createValueTest", "name": "TypeHandler_createValueTest", "file_path": "src/test/java/org/apache/commons/cli/TypeHandler_createValueTest.java", "superclasses": "", "methods": ["[void]testCreateValueWithClass()", "[void]testCreateValueWithFile()", "[void]testCreateValueWithURL()", "[void]testCreateValueWithInvalidInput()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TypeHandler_createValueTest {\n\n    @Test\n    public void testCreateValueWithClass() throws ParseException {\n        Class<?> clazz = TypeHandler.createValue(\"java.lang.String\", Class.class);\n        assertNotNull(clazz);\n        assertEquals(String.class, clazz);\n    }\n\n    @Test\n    public void testCreateValueWithFile() throws ParseException {\n        File file = TypeHandler.createValue(\"src/test/resources/testfile.txt\", File.class);\n        assertNotNull(file);\n        assertEquals(\"testfile.txt\", file.getName());\n    }\n\n    @Test\n    public void testCreateValueWithURL() throws ParseException {\n        URL url = TypeHandler.createValue(\"https://www.example.com\", URL.class);\n        assertNotNull(url);\n        assertEquals(\"https://www.example.com\", url.toString());\n    }\n\n    @Test\n    public void testCreateValueWithInvalidInput() {\n        assertThrows(ParseException.class, () -> {\n            TypeHandler.createValue(\"invalid\", URL.class);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/OptionValidatorTest.java.OptionValidatorTest", "name": "OptionValidatorTest", "file_path": "src/test/java/org/apache/commons/cli/OptionValidatorTest.java", "superclasses": "", "methods": ["[void]testExclusivity()", "[void]validateTest(String,boolean,String)"], "method_uris": ["src/test/java/org/apache/commons/cli/OptionValidatorTest.java.OptionValidatorTest.[Stream<Arguments>]optionParameters()", "src/test/java/org/apache/commons/cli/OptionValidatorTest.java.OptionValidatorTest.[void]setup()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class OptionValidatorTest {\n\n    /*\n     * Exemplars of various types of characters\n     */\n\n    private static final String LETTERS = \"a\\u00D1\"; // a and \u00d1\n\n    // '\\u0660' through '\\u0669', Arabic-Indic digits, '\\u06F0' through '\\u06F9',\n    // Extended Arabic-Indic digits\n    // '\\u0966' through '\\u096F', Devanagari digits, '\\uFF10' through '\\uFF19',\n    // Fullwidth digits\n    private static final String DIGITS = \"1\\u0661\\u06f2\\u0968\\uFF14\";\n\n    private static final String CURRENCY = \"\u20ac$\";\n\n    // this is the complete puncutation set do not modify it as Character.isJavaIdentifierPart filters\n    // the good and bad ones out in the setup.\n    private static final String PUNCTUATION = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\n\n    private static final String COMBINING_MARK = \"\\u0303\";\n\n    private static final String NON_SPACING_MARK = \"\\u0CBF\";\n\n    private static final String IDENTIFIER_IGNORABLE = \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\";\n\n    private static String acceptablePunctuation;\n\n    private static String notAcceptablePunctuation;\n\n    private static String additionalOptonChars;\n    private static String additionalLongChars;\n\n    private static String firstChars;\n    private static String notFirstChars;\n\n    private static String restChars;\n    private static String notRestChars;\n\n    private static Stream<Arguments> optionParameters() {\n\n        final List<Arguments> args = new ArrayList<>();\n\n        args.add(Arguments.of(\"CamelCase\", true, \"Camel case error\"));\n        args.add(Arguments.of(\"Snake_case\", true, \"Snake case error\"));\n        args.add(Arguments.of(\"_leadingUnderscore\", true, \"Leading underscore error\"));\n        args.add(Arguments.of(\"kabob-case\", true, \"Kabob case error\"));\n        args.add(Arguments.of(\"-leadingDash\", false, \"Leading dash error\"));\n        args.add(Arguments.of(\"lowercase\", true, \"Lower case error\"));\n        args.add(Arguments.of(\"UPPERCASE\", true, \"Upper case error\"));\n\n        // build passing test cases\n        for (final char c : firstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: First character '%s'\", c)));\n        }\n\n        for (final char c : restChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, true, String.format(\"testing: Middle character '%s'\", c)));\n        }\n\n        // build failing test cases\n        for (final char c : notFirstChars.toCharArray()) {\n            final String s = String.format(\"%sMoreText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad first character '%s'\", c)));\n        }\n\n        for (final char c : notRestChars.toCharArray()) {\n            final String s = String.format(\"Some%sText\", c);\n            args.add(Arguments.of(s, false, String.format(\"testing: Bad middle character '%s'\", c)));\n        }\n\n        return args.stream();\n    }\n\n    @BeforeAll\n    public static void setup() {\n        StringBuilder sb = new StringBuilder();\n        final StringBuilder sb2 = new StringBuilder();\n        int idx;\n\n        for (final char c : PUNCTUATION.toCharArray()) {\n            if (Character.isJavaIdentifierPart(c)) {\n                sb.append(c);\n            } else {\n                sb2.append(c);\n            }\n        }\n        acceptablePunctuation = sb.toString();\n        notAcceptablePunctuation = sb2.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            sb.append(c);\n        }\n        additionalLongChars = sb.toString();\n\n        sb = new StringBuilder();\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            sb.append(c);\n        }\n        additionalOptonChars = sb.toString();\n\n        final String javaIdentifierPart = LETTERS + DIGITS + CURRENCY + acceptablePunctuation + COMBINING_MARK\n                + NON_SPACING_MARK + IDENTIFIER_IGNORABLE;\n\n        firstChars = additionalOptonChars + javaIdentifierPart;\n\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalLongChars);\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notFirstChars = sb.toString();\n\n        restChars = additionalLongChars + javaIdentifierPart;\n        sb = new StringBuilder(notAcceptablePunctuation).append(additionalOptonChars);\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            while ((idx = sb.indexOf(Character.toString(c))) > -1) {\n                sb.deleteCharAt(idx);\n            }\n        }\n        notRestChars = sb.toString();\n\n    }\n\n    @Test\n    public void testExclusivity() {\n        /* since we modify acceptable chars by add and removing ADDITIONAL* chars we must verify that they do not exist in the\n         * base javaIdentiferPart that is used in OptionValidator to validate basic characters  */\n        for (final char c : OptionValidator.ADDITIONAL_LONG_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_LONG_CHARS\", c));\n        }\n        for (final char c : OptionValidator.ADDITIONAL_OPTION_CHARS) {\n            assertFalse(Character.isJavaIdentifierPart(c), () -> String.format(\"'%s' should not be in 'ADDITIONAL_OPTION_CHARS\", c));\n        }\n    }\n\n    @ParameterizedTest(name = \"{2}\")\n    @MethodSource(\"optionParameters\")\n    public void validateTest(final String str, final boolean expected, final String name) {\n        if (expected) {\n            assertEquals(str, OptionValidator.validate(str));\n        } else {\n            assertThrows(IllegalArgumentException.class, () -> OptionValidator.validate(str));\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String LETTERS = \"a\\u00D1\";", "docstring": "\nExemplars of various types of characters\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LETTERS = \"a\\u00D1\"", "syntax_pass": true}, {"attribute_expression": "private static final String DIGITS = \"1\\u0661\\u06f2\\u0968\\uFF14\";", "docstring": " Fullwidth digits", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "DIGITS = \"1\\u0661\\u06f2\\u0968\\uFF14\"", "syntax_pass": true}, {"attribute_expression": "private static final String CURRENCY = \"\u20ac$\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CURRENCY = \"\u20ac$\"", "syntax_pass": true}, {"attribute_expression": "private static final String PUNCTUATION = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";", "docstring": " the good and bad ones out in the setup.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PUNCTUATION = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"", "syntax_pass": true}, {"attribute_expression": "private static final String COMBINING_MARK = \"\\u0303\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "COMBINING_MARK = \"\\u0303\"", "syntax_pass": true}, {"attribute_expression": "private static final String NON_SPACING_MARK = \"\\u0CBF\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "NON_SPACING_MARK = \"\\u0CBF\"", "syntax_pass": true}, {"attribute_expression": "private static final String IDENTIFIER_IGNORABLE = \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "IDENTIFIER_IGNORABLE = \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\"", "syntax_pass": true}, {"attribute_expression": "private static String acceptablePunctuation;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "acceptablePunctuation", "syntax_pass": true}, {"attribute_expression": "private static String notAcceptablePunctuation;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "notAcceptablePunctuation", "syntax_pass": true}, {"attribute_expression": "private static String additionalOptonChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "additionalOptonChars", "syntax_pass": true}, {"attribute_expression": "private static String additionalLongChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "additionalLongChars", "syntax_pass": true}, {"attribute_expression": "private static String firstChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "firstChars", "syntax_pass": true}, {"attribute_expression": "private static String notFirstChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "notFirstChars", "syntax_pass": true}, {"attribute_expression": "private static String restChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "restChars", "syntax_pass": true}, {"attribute_expression": "private static String notRestChars;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "notRestChars", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/Options_toStringTest.java.Options_toStringTest", "name": "Options_toStringTest", "file_path": "src/test/java/org/apache/commons/cli/Options_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringWithNoOptions()", "[void]testToStringWithShortOptions()", "[void]testToStringWithLongOptions()", "[void]testToStringWithBothShortAndLongOptions()"], "method_uris": ["src/test/java/org/apache/commons/cli/Options_toStringTest.java.Options_toStringTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Options_toStringTest {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n    }\n\n    @Test\n    public void testToStringWithNoOptions() {\n        String expected = \"[ Options: [ short {} ] [ long {} ]\";\n        assertEquals(expected, options.toString());\n    }\n\n    @Test\n    public void testToStringWithShortOptions() {\n        options.addOption(\"a\", \"first\");\n        options.addOption(\"b\", \"second\");\n        String expected = \"[ Options: [ short {a=[ Option a :: first :: class java.lang.String ], b=[ Option b :: second :: class java.lang.String ]} ] [ long {} ]\";\n        assertEquals(expected, options.toString());\n    }\n\n    @Test\n    public void testToStringWithLongOptions() {\n        options.addOption(null, \"first\", false, \"first option\");\n        options.addOption(null, \"second\", false, \"second option\");\n        String expected = \"[ Options: [ short {first=[ Option null first :: first option :: class java.lang.String ], second=[ Option null second :: second option :: class java.lang.String ]} ] [ long {first=[ Option null first :: first option :: class java.lang.String ], second=[ Option null second :: second option :: class java.lang.String ]} ]\";\n        assertEquals(expected, options.toString());\n    }\n\n    @Test\n    public void testToStringWithBothShortAndLongOptions() {\n        options.addOption(\"a\", \"first\", false, \"first option\");\n        options.addOption(\"b\", \"second\", false, \"second option\");\n        String expected = \"[ Options: [ short {a=[ Option a first :: first option :: class java.lang.String ], b=[ Option b second :: second option :: class java.lang.String ]} ] [ long {first=[ Option a first :: first option :: class java.lang.String ], second=[ Option b second :: second option :: class java.lang.String ]} ]\";\n        assertEquals(expected, options.toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/OptionBuilder_createTest.java.OptionBuilder_createTest", "name": "OptionBuilder_createTest", "file_path": "src/test/java/org/apache/commons/cli/OptionBuilder_createTest.java", "superclasses": "", "methods": ["[void]testCreate_withLongOpt()", "[void]testCreate_withoutLongOpt()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class OptionBuilder_createTest {\n\n    @Test\n    public void testCreate_withLongOpt() {\n        // Given\n        OptionBuilder.withLongOpt(\"testLongOpt\");\n\n        // When\n        Option option = OptionBuilder.create();\n\n        // Then\n        assertNotNull(option);\n        assertEquals(\"testLongOpt\", option.getLongOpt());\n    }\n\n    @Test\n    public void testCreate_withoutLongOpt() {\n        // Given\n        OptionBuilder.withLongOpt(null);\n\n        // When & Then\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            OptionBuilder.create();\n        });\n        assertEquals(\"must specify longopt\", exception.getMessage());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/HelpFormatter_printUsageTest.java.HelpFormatter_printUsageTest", "name": "HelpFormatter_printUsageTest", "file_path": "src/test/java/org/apache/commons/cli/HelpFormatter_printUsageTest.java", "superclasses": "", "methods": ["[void]testPrintUsageWithSingleOption()", "[void]testPrintUsageWithMultipleOptions()", "[void]testPrintUsageWithOptionGroup()", "[void]testPrintUsageWithRequiredOption()"], "method_uris": ["src/test/java/org/apache/commons/cli/HelpFormatter_printUsageTest.java.HelpFormatter_printUsageTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class HelpFormatter_printUsageTest {\n    private HelpFormatter formatter;\n    private StringWriter sw;\n\n    @BeforeEach\n    public void setUp() {\n        formatter = new HelpFormatter();\n        sw = new StringWriter();\n    }\n\n    @Test\n    public void testPrintUsageWithSingleOption() {\n        final Options options = new Options();\n        options.addOption(\"f\", \"file\", true, \"The file to be processed\");\n\n        formatter.printUsage(new PrintWriter(sw), 20, \"app\", options);\n\n        final String expected = \"usage: app -f <file>\\n\";\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testPrintUsageWithMultipleOptions() {\n        final Options options = new Options();\n        options.addOption(\"f\", \"file\", true, \"The file to be processed\");\n        options.addOption(\"v\", \"version\", false, \"Print the version of the application\");\n\n        formatter.printUsage(new PrintWriter(sw), 20, \"app\", options);\n\n        final String expected = \"usage: app -f <file> [-v]\\n\";\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testPrintUsageWithOptionGroup() {\n        final Options options = new Options();\n        final OptionGroup group = new OptionGroup();\n        group.addOption(new Option(\"a\", \"optionA\", false, \"Option A\"));\n        group.addOption(new Option(\"b\", \"optionB\", false, \"Option B\"));\n        options.addOptionGroup(group);\n\n        formatter.printUsage(new PrintWriter(sw), 20, \"app\", options);\n\n        final String expected = \"usage: app [-a | -b]\\n\";\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testPrintUsageWithRequiredOption() {\n        final Options options = new Options();\n        options.addOption(Option.builder(\"f\").longOpt(\"file\").hasArg().argName(\"file\").desc(\"The file to be processed\").required().build());\n\n        formatter.printUsage(new PrintWriter(sw), 20, \"app\", options);\n\n        final String expected = \"usage: app -f <file>\\n\";\n        assertEquals(expected, sw.toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private HelpFormatter formatter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HelpFormatter", "name": "formatter", "syntax_pass": true}, {"attribute_expression": "private StringWriter sw;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringWriter", "name": "sw", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/DisablePartialMatchingTest.java.DisablePartialMatchingTest", "name": "DisablePartialMatchingTest", "file_path": "src/test/java/org/apache/commons/cli/DisablePartialMatchingTest.java", "superclasses": "", "methods": ["[void]testDisablePartialMatching()", "[void]testRegularPartialMatching()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DisablePartialMatchingTest {\n    @Test\n    public void testDisablePartialMatching() throws Exception {\n        final CommandLineParser parser = new DefaultParser(false);\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertTrue(line.hasOption(\"extract\"), \"There should be an extract option because partial matching is off\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }\n\n    @Test\n    public void testRegularPartialMatching() throws Exception {\n        final CommandLineParser parser = new DefaultParser();\n\n        final Options options = new Options();\n\n        options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n        options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n        options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n\n        final CommandLine line = parser.parse(options, new String[] {\"-de\", \"--option=foobar\"});\n\n        assertTrue(line.hasOption(\"debug\"), \"There should be an option debug in any case...\");\n        assertFalse(line.hasOption(\"extract\"), \"There should not be an extract option because partial matching only selects debug\");\n        assertTrue(line.hasOption(\"option\"), \"There should be an option option with a argument value\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/HelpFormatterTest.java.HelpFormatterTest", "name": "HelpFormatterTest", "file_path": "src/test/java/org/apache/commons/cli/HelpFormatterTest.java", "superclasses": "", "methods": ["[void]testAccessors()", "[void]testAutomaticUsage()", "[void]testDefaultArgName()", "[void]testFindWrapPos()", "[void]testHeaderStartingWithLineSeparator0()", "[void]testHeaderStartingWithLineSeparator1()", "[void]testHelpWithLongOptSeparator()", "[void]testIndentedHeaderAndFooter()", "[void]testOptionWithoutShortFormat()", "[void]testOptionWithoutShortFormat2()", "[void]testPrintDeprecatedOptions(HelpFormatter,Option,String)", "[void]testPrintHelpNewlineFooter()", "[void]testPrintHelpNewlineHeader()", "[void]testPrintHelpWithEmptySyntax()", "[void]testPrintHelpWithSince()", "[void]testPrintOptionGroupUsage()", "[void]testPrintOptions()", "[void]testPrintOptionWithEmptyArgNameUsage()", "[void]testPrintRequiredOptionGroupUsage()", "[void]testPrintSortedUsage()", "[void]testPrintSortedUsageWithNullComparator()", "[void]testPrintUsage()", "[void]testRenderSince()", "[void]testRenderWrappedTextMultiLine()", "[void]testRenderWrappedTextMultiLinePadded()", "[void]testRenderWrappedTextSingleLine()", "[void]testRenderWrappedTextSingleLinePadded()", "[void]testRenderWrappedTextSingleLinePadded2()", "[void]testRenderWrappedTextWordCut()", "[void]testRtrim()", "[void]testUsageWithLongOptSeparator()"], "method_uris": ["src/test/java/org/apache/commons/cli/HelpFormatterTest.java.HelpFormatterTest.[Stream<Arguments>]deprecatedOptionsProvider()"], "overrides": null, "attributes": [], "class_docstring": "\nTest case for the HelpFormatter class.\n", "original_string": "public class HelpFormatterTest {\n    private static final String EOL = System.lineSeparator();\n\n    static Stream<Arguments> deprecatedOptionsProvider() {\n        final List<Arguments> lst = new ArrayList<>();\n        Option option = Option.builder(\"a\").longOpt(\"aaa\").desc(\"dddd dddd dddd\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        HelpFormatter hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated] dddd dddd dddd\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"dddd dddd dddd [Deprecated for removal since now: Why why why]\"));\n\n        option = Option.builder(\"a\").longOpt(\"aaa\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"now\")\n                        .setDescription(\"Why why why\").get())\n                .build();\n\n        hf = HelpFormatter.builder().get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(false).get();\n        lst.add(Arguments.of(hf, option, \"\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(true).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated]\"));\n\n        hf = HelpFormatter.builder().setShowDeprecated(o -> String.format(\"%s [%s]\", HelpFormatter.getDescription(o), o.getDeprecated())).get();\n        lst.add(Arguments.of(hf, option, \"[Deprecated for removal since now: Why why why]\"));\n\n        return lst.stream();\n    }\n\n    @Test\n    public void testAccessors() {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        formatter.setArgName(\"argname\");\n        assertEquals(\"argname\", formatter.getArgName(), \"arg name\");\n\n        formatter.setDescPadding(3);\n        assertEquals(3, formatter.getDescPadding(), \"desc padding\");\n\n        formatter.setLeftPadding(7);\n        assertEquals(7, formatter.getLeftPadding(), \"left padding\");\n\n        formatter.setLongOptPrefix(\"~~\");\n        assertEquals(\"~~\", formatter.getLongOptPrefix(), \"long opt prefix\");\n\n        formatter.setNewLine(\"\\n\");\n        assertEquals(\"\\n\", formatter.getNewLine(), \"new line\");\n\n        formatter.setOptPrefix(\"~\");\n        assertEquals(\"~\", formatter.getOptPrefix(), \"opt prefix\");\n\n        formatter.setSyntaxPrefix(\"-> \");\n        assertEquals(\"-> \", formatter.getSyntaxPrefix(), \"syntax prefix\");\n\n        formatter.setWidth(80);\n        assertEquals(80, formatter.getWidth(), \"width\");\n    }\n\n    @Test\n    public void testAutomaticUsage() {\n        final HelpFormatter hf = new HelpFormatter();\n        Options options;\n        String expected = \"usage: app [-a]\";\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n\n        expected = \"usage: app [-a] [-b]\";\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\").addOption(\"b\", false, \"bbb\");\n        hf.printUsage(pw, 60, \"app\", options);\n        pw.flush();\n        assertEquals(expected, out.toString().trim(), \"simple auto usage\");\n        out.reset();\n    }\n\n    @Test\n    public void testDefaultArgName() {\n        final Option option = Option.builder(\"f\").hasArg().required(true).build();\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setArgName(\"argument\");\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f <argument>\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testFindWrapPos() {\n        final HelpFormatter hf = new HelpFormatter();\n\n        String text = \"This is a test.\";\n        // text width should be max 8; the wrap position is 7\n        assertEquals(7, hf.findWrapPos(text, 8, 0), \"wrap position\");\n\n        // starting from 8 must give -1 - the wrap pos is after end\n        assertEquals(-1, hf.findWrapPos(text, 8, 8), \"wrap position 2\");\n\n        // words longer than the width are cut\n        text = \"aaaa aa\";\n        assertEquals(3, hf.findWrapPos(text, 3, 0), \"wrap position 3\");\n\n        // last word length is equal to the width\n        text = \"aaaaaa aaaaaa\";\n        assertEquals(6, hf.findWrapPos(text, 6, 0), \"wrap position 4\");\n        assertEquals(-1, hf.findWrapPos(text, 6, 7), \"wrap position 4\");\n\n        text = \"aaaaaa\\n aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 5\");\n\n        text = \"aaaaaa\\t aaaaaa\";\n        assertEquals(7, hf.findWrapPos(text, 6, 0), \"wrap position 6\");\n    }\n\n    @Test\n    public void testHeaderStartingWithLineSeparator0() {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testHeaderStartingWithLineSeparator1() {\n        // related to Bugzilla #21215\n        final Options options = new Options();\n        final String header = EOL + \"Header\";\n        final String footer = \"Footer\";\n        final Builder builder = HelpFormatter.builder();\n        StringWriter out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL +\n                \"Header\" + EOL +\n                \"\" + EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(80, \"foobar\", header, options, footer);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", header, options, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                EOL +\n                \"Header\" + EOL +\n                EOL +\n                \"Footer\" + EOL,\n                out.toString());\n        //@formatter:on\n        out = new StringWriter();\n        builder.setPrintWriter(new PrintWriter(out)).get().printHelp(\"foobar\", options, false);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testHelpWithLongOptSeparator() {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        assertEquals(HelpFormatter.DEFAULT_LONG_OPT_SEPARATOR, formatter.getLongOptSeparator());\n        formatter.setLongOptSeparator(\"=\");\n        assertEquals(\"=\", formatter.getLongOptSeparator());\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"create\", \"header\", options, 2, 2, \"footer\");\n\n        //@formatter:off\n        assertEquals(\n                \"usage: create\" + EOL +\n                \"header\" + EOL +\n                \"     --age=<arg>    the age\" + EOL +\n                \"  -f <arg>          the file\" + EOL +\n                \"  -s,--size=<SIZE>  the size\" + EOL +\n                \"footer\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testIndentedHeaderAndFooter() {\n        // related to CLI-207\n        final Options options = new Options();\n        final HelpFormatter formatter = new HelpFormatter();\n        final String header = \"  Header1\\n  Header2\";\n        final String footer = \"  Footer1\\n  Footer2\";\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"  Header1\" + EOL +\n                \"  Header2\" + EOL +\n                \"\" + EOL +\n                \"  Footer1\" + EOL +\n                \"  Footer2\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testOptionWithoutShortFormat() {\n        // related to Bugzilla #19383 (CLI-67)\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", \"\", options, 2, 2, \"\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: foobar [-a] [--bbb] [-c]\" + EOL +\n                \"  -a,--aaa  aaaaaaa\" + EOL +\n                \"     --bbb  bbbbbbb\" + EOL +\n                \"  -c        ccccccc\" + EOL,\n                out.toString());\n        //@formatter:on\n    }\n\n    @Test\n    public void testOptionWithoutShortFormat2() {\n        // related to Bugzilla #27635 (CLI-26)\n        final Option help = new Option(\"h\", \"help\", false, \"print this message\");\n        final Option version = new Option(\"v\", \"version\", false, \"print version information\");\n        final Option newRun = new Option(\"n\", \"new\", false, \"Create NLT cache entries only for new items\");\n        final Option trackerRun = new Option(\"t\", \"tracker\", false, \"Create NLT cache entries only for tracker items\");\n        //@formatter:off\n        final Option timeLimit = Option.builder(\"l\")\n                .longOpt(\"limit\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Set time limit for execution, in mintues\")\n                .build();\n        final Option age = Option.builder(\"a\").longOpt(\"age\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Age (in days) of cache item before being recomputed\")\n                .build();\n        final Option server = Option.builder(\"s\").longOpt(\"server\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"The NLT server address\")\n                .build();\n        final Option numResults = Option.builder(\"r\").longOpt(\"results\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Number of results per item\")\n                .build();\n        final Option configFile = Option.builder().longOpt(\"config\")\n                .hasArg()\n                .valueSeparator()\n                .desc(\"Use the specified configuration file\")\n                .build();\n        //@formatter:on\n\n        final Options mOptions = new Options();\n        mOptions.addOption(help);\n        mOptions.addOption(version);\n        mOptions.addOption(newRun);\n        mOptions.addOption(trackerRun);\n        mOptions.addOption(timeLimit);\n        mOptions.addOption(age);\n        mOptions.addOption(server);\n        mOptions.addOption(numResults);\n        mOptions.addOption(configFile);\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final String eol = System.lineSeparator();\n        final StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"commandline\", \"header\", mOptions, 2, 2, \"footer\", true);\n        //@formatter:off\n        assertEquals(\n                \"usage: commandline [-a <arg>] [--config <arg>] [-h] [-l <arg>] [-n] [-r <arg>]\" + eol +\n                \"       [-s <arg>] [-t] [-v]\" + eol +\n                \"header\" + eol +\n                \"  -a,--age <arg>      Age (in days) of cache item before being recomputed\" + eol +\n                \"     --config <arg>   Use the specified configuration file\" + eol +\n                \"  -h,--help           print this message\" + eol +\n                \"  -l,--limit <arg>    Set time limit for execution, in mintues\" + eol +\n                \"  -n,--new            Create NLT cache entries only for new items\" + eol +\n                \"  -r,--results <arg>  Number of results per item\" + eol +\n                \"  -s,--server <arg>   The NLT server address\" + eol +\n                \"  -t,--tracker        Create NLT cache entries only for tracker items\" + eol +\n                \"  -v,--version        print version information\" + eol +\n                \"footer\" + eol,\n                out.toString());\n        //@formatter:on\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"deprecatedOptionsProvider\")\n    public void testPrintDeprecatedOptions(final HelpFormatter hf, final Option option, final String expectedTxt) {\n        final StringBuffer sb = new StringBuffer();\n\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        final StringBuilder expected = new StringBuilder().append(lpad).append(\"-a,--aaa\");\n\n        options = new Options().addOption(option);\n        if (expectedTxt.length() > 0) {\n            expected.append(dpad).append(expectedTxt);\n        }\n        hf.renderOptions(sb, 160, options, leftPad, descPad);\n        assertEquals(expected.toString(), sb.toString());\n    }\n\n    @Test\n    public void testPrintHelpNewlineFooter() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            \"header\" + EOL,\n            options,\n            0,\n            0,\n            EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          \"header\" + EOL +\n                          \"-ab\" + EOL +\n                          EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"footer newline\");\n    }\n\n    @Test\n    public void testPrintHelpNewlineHeader() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintWriter pw = new PrintWriter(out);\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"b\");\n\n        formatter.printHelp(\n            pw,\n            80,\n            \"test\" + EOL,\n            EOL,\n            options,\n            0,\n            0,\n            \"footer\" + EOL\n        );\n        final String expected = \"usage: test\" + EOL +\n                          EOL +\n                          \"-ab\" + EOL +\n                          \"footer\" + EOL;\n        pw.flush();\n        assertEquals(expected, out.toString(), \"header newline\");\n    }\n\n    @Test\n    public void testPrintHelpWithEmptySyntax() {\n        final HelpFormatter formatter = new HelpFormatter();\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options()), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(null, new Options(), false), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), true), \"null command line syntax should be rejected\");\n        assertThrows(IllegalArgumentException.class, () -> formatter.printHelp(\"\", new Options(), false), \"null command line syntax should be rejected\");\n    }\n\n    @Test\n    public void testPrintHelpWithSince() {\n        final String [] expected = {\"usage: Command syntax\", \"Header\", \"Options            Since   Description\",\n                \"  -n,--no-since    -          Description for n\", \"  -W,--with-since  1.19.0     Descripton for W\", \"footer\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (PrintWriter pw = new PrintWriter(new OutputStreamWriter(baos))) {\n            formatter.printHelp(pw, 80, \"Command syntax\", \"Header\", options, 2, 5, \"footer\", false);\n        }\n        assertArrayEquals(expected, baos.toString().split(System.lineSeparator()));\n    }\n\n    @Test\n    public void testPrintOptionGroupUsage() {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app [-a | -b | -c]\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testPrintOptions() {\n        final StringBuffer sb = new StringBuffer();\n        final HelpFormatter hf = new HelpFormatter();\n        final int leftPad = 1;\n        final int descPad = 3;\n        final String lpad = hf.createPadding(leftPad);\n        final String dpad = hf.createPadding(descPad);\n        Options options;\n        String expected;\n\n        options = new Options().addOption(\"a\", false, \"aaaa aaaa aaaa aaaa aaaa\");\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa aaaa aaaa\";\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple non-wrapped option\");\n\n        int nextLineTabStop = leftPad + descPad + \"-a\".length();\n        expected = lpad + \"-a\" + dpad + \"aaaa aaaa aaaa\" + EOL + hf.createPadding(nextLineTabStop) + \"aaaa aaaa\";\n        sb.setLength(0);\n        hf.renderOptions(sb, nextLineTabStop + 17, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"simple wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 60, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long non-wrapped option\");\n\n        nextLineTabStop = leftPad + descPad + \"-a,--aaa\".length();\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"long wrapped option\");\n\n        options = new Options().addOption(\"a\", \"aaa\", false, \"dddd dddd dddd dddd\").addOption(\"b\", false, \"feeee eeee eeee eeee\");\n        expected = lpad + \"-a,--aaa\" + dpad + \"dddd dddd\" + EOL + hf.createPadding(nextLineTabStop) + \"dddd dddd\" + EOL + lpad + \"-b      \" + dpad\n            + \"feeee eeee\" + EOL + hf.createPadding(nextLineTabStop) + \"eeee eeee\";\n        sb.setLength(0);\n        hf.renderOptions(sb, 25, options, leftPad, descPad);\n        assertEquals(expected, sb.toString(), \"multiple wrapped options\");\n    }\n\n    @Test\n    public void testPrintOptionWithEmptyArgNameUsage() {\n        final Option option = new Option(\"f\", true, null);\n        option.setArgName(\"\");\n        option.setRequired(true);\n\n        final Options options = new Options();\n        options.addOption(option);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testPrintRequiredOptionGroupUsage() {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(Option.builder(\"a\").build());\n        group.addOption(Option.builder(\"b\").build());\n        group.addOption(Option.builder(\"c\").build());\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final StringWriter out = new StringWriter();\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -a | -b | -c\" + EOL, out.toString());\n    }\n\n    // uses the test for CLI-131 to implement CLI-155\n    @Test\n    public void testPrintSortedUsage() {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"a\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"c\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator((opt1, opt2) -> opt2.getKey().compareToIgnoreCase(opt1.getKey()));\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }\n\n    @Test\n    public void testPrintSortedUsageWithNullComparator() {\n        final Options opts = new Options();\n        opts.addOption(new Option(\"c\", \"first\"));\n        opts.addOption(new Option(\"b\", \"second\"));\n        opts.addOption(new Option(\"a\", \"third\"));\n\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        helpFormatter.setOptionComparator(null);\n\n        final StringWriter out = new StringWriter();\n        helpFormatter.printUsage(new PrintWriter(out), 80, \"app\", opts);\n\n        assertEquals(\"usage: app [-c] [-b] [-a]\" + EOL, out.toString());\n    }\n\n    // This test ensures the options are properly sorted\n    // See https://issues.apache.org/jira/browse/CLI-131\n    @Test\n    public void testPrintUsage() {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Option optionB = new Option(\"b\", \"second\");\n        final Option optionC = new Option(\"c\", \"third\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        opts.addOption(optionB);\n        opts.addOption(optionC);\n        final HelpFormatter helpFormatter = new HelpFormatter();\n        final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n        try (PrintWriter printWriter = new PrintWriter(bytesOut)) {\n            helpFormatter.printUsage(printWriter, 80, \"app\", opts);\n        }\n        assertEquals(\"usage: app [-a] [-b] [-c]\" + EOL, bytesOut.toString());\n    }\n\n    @Test\n    public void testRenderSince() throws IOException {\n        final String[] expected = {\"Options            Since   Description\", \"  -n,--no-since    -          Description for n\",\n            \"  -W,--with-since  1.19.0     Descripton for W\"};\n        final Options options = new Options()\n                .addOption(Option.builder(\"W\").longOpt(\"with-since\").since(\"1.19.0\").desc(\"Descripton for W\").build())\n                .addOption(Option.builder(\"n\").longOpt(\"no-since\").desc(\"Description for n\").build());\n        final HelpFormatter formatter = HelpFormatter.builder().setShowSince(true).get();\n\n        final StringBuffer sb = new StringBuffer();\n        formatter.renderOptions(sb, 50, options, 2, 5);\n        assertArrayEquals(expected, sb.toString().split(System.lineSeparator()));\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(formatter);\n        when(spy.appendOptions(sb, 50, options, 2, 5)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderOptions(sb, 50, options, 2, 5));\n    }\n\n    @Test\n    public void testRenderWrappedTextMultiLine() {\n        // multi line text\n        final int width = 16;\n        final int padding = 0;\n        //@formatter:off\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                                \"aaaaaa\" + EOL +\n                                \"aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, expected);\n        assertEquals(expected, sb.toString(), \"multi line text\");\n    }\n\n    @Test\n    public void testRenderWrappedTextMultiLinePadded() {\n        // multi-line padded text\n        final int width = 16;\n        final int padding = 4;\n        //@formatter:off\n        final String text = \"aaaa aaaa aaaa\" + EOL +\n                      \"aaaaaa\" + EOL +\n                      \"aaaaa\";\n        final String expected = \"aaaa aaaa aaaa\" + EOL +\n                          \"    aaaaaa\" + EOL +\n                          \"    aaaaa\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"multi-line padded text\");\n    }\n\n    @Test\n    public void testRenderWrappedTextSingleLine() throws IOException {\n        // single line text\n        final int width = 12;\n        final int padding = 0;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line text\");\n        // check internal exception handling for coverage\n        final HelpFormatter spy = spy(new HelpFormatter());\n        when(spy.appendWrappedText(sb, width, padding, text)).thenThrow(IOException.class);\n        assertThrows(UncheckedIOException.class, () -> spy.renderWrappedText(sb, width, padding, text));\n\n    }\n\n    @Test\n    public void testRenderWrappedTextSingleLinePadded() {\n        // single line padded text\n        final int width = 12;\n        final int padding = 4;\n        final String text = \"This is a test.\";\n        final String expected = \"This is a\" + EOL + \"    test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text\");\n    }\n\n    @Test\n    public void testRenderWrappedTextSingleLinePadded2() {\n        // single line padded text 2\n        final int width = 53;\n        final int padding = 24;\n        //@formatter:off\n        final String text = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n                            \"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\n        final String expected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" + EOL +\n                                \"                        form DATE[-DATE] where DATE\" + EOL +\n                                \"                        has form YYYY[MM[DD]]\";\n        //@formatter:on\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"single line padded text 2\");\n    }\n\n    @Test\n    public void testRenderWrappedTextWordCut() {\n        final int width = 7;\n        final int padding = 0;\n        final String text = \"Thisisatest.\";\n        final String expected = \"Thisisa\" + EOL + \"test.\";\n\n        final StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text);\n        assertEquals(expected, sb.toString(), \"cut and wrap\");\n    }\n\n    @Test\n    public void testRtrim() {\n        final HelpFormatter formatter = new HelpFormatter();\n\n        assertNull(formatter.rtrim(null));\n        assertEquals(\"\", formatter.rtrim(\"\"));\n        assertEquals(\"  foo\", formatter.rtrim(\"  foo  \"));\n    }\n\n    @Test\n    public void testUsageWithLongOptSeparator() {\n        final Options options = new Options();\n        options.addOption(\"f\", true, \"the file\");\n        options.addOption(Option.builder(\"s\").longOpt(\"size\").desc(\"the size\").hasArg().argName(\"SIZE\").build());\n        options.addOption(Option.builder().longOpt(\"age\").desc(\"the age\").hasArg().build());\n\n        final HelpFormatter formatter = new HelpFormatter();\n        formatter.setLongOptSeparator(\"=\");\n\n        final StringWriter out = new StringWriter();\n\n        formatter.printUsage(new PrintWriter(out), 80, \"create\", options);\n\n        assertEquals(\"usage: create [--age=<arg>] [-f <arg>] [-s <SIZE>]\", out.toString().trim());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String EOL = System.lineSeparator();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "EOL = System.lineSeparator()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/ValueTest.java.ValueTest", "name": "ValueTest", "file_path": "src/test/java/org/apache/commons/cli/ValueTest.java", "superclasses": "", "methods": ["[void]testLongNoArg()", "[void]testLongNoArgWithOption()", "[void]testLongOptionalArgValue(CommandLineParser)", "[void]testLongOptionalArgValues(CommandLineParser)", "[void]testLongOptionalArgValuesWithOption(CommandLineParser)", "[void]testLongOptionalArgValueWithOption(CommandLineParser)", "[void]testLongOptionalNArgValues(CommandLineParser)", "[void]testLongOptionalNArgValuesWithOption(CommandLineParser)", "[void]testLongOptionalNoValue(CommandLineParser)", "[void]testLongOptionalNoValueWithOption(CommandLineParser)", "[void]testLongWithArg()", "[void]testLongWithArgWithOption()", "[void]testShortNoArg()", "[void]testShortNoArgWithOption()", "[void]testShortOptionalArgNoValue(CommandLineParser)", "[void]testShortOptionalArgNoValueWithOption(CommandLineParser)", "[void]testShortOptionalArgValue(CommandLineParser)", "[void]testShortOptionalArgValues(CommandLineParser)", "[void]testShortOptionalArgValuesWithOption(CommandLineParser)", "[void]testShortOptionalArgValueWithOption(CommandLineParser)", "[void]testShortOptionalNArgValues(CommandLineParser)", "[void]testShortOptionalNArgValuesSeparated()", "[void]testShortOptionalNArgValuesWithOption()", "[void]testShortWithArg()", "[void]testShortWithArgWithOption()"], "method_uris": ["src/test/java/org/apache/commons/cli/ValueTest.java.ValueTest.[Stream<CommandLineParser>]parsers()", "src/test/java/org/apache/commons/cli/ValueTest.java.ValueTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ValueTest {\n\n    private static final Option NULL_OPTION = null;\n    private static final String NULL_STRING = null;\n\n    protected static Stream<CommandLineParser> parsers() {\n        return Stream.of(new DefaultParser(), new PosixParser());\n    }\n\n    private final Options opts = new Options();\n\n    private CommandLine cl;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        opts.addOption(\"a\", false, \"toggle -a\");\n        opts.addOption(\"b\", true, \"set -b\");\n        opts.addOption(\"c\", \"c\", false, \"toggle -c\");\n        opts.addOption(\"d\", \"d\", true, \"set -d\");\n\n        opts.addOption(OptionBuilder.hasOptionalArg().create('e'));\n        opts.addOption(OptionBuilder.hasOptionalArg().withLongOpt(\"fish\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs().withLongOpt(\"gravy\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n        opts.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        opts.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n        opts.addOption(Option.builder().option(\"v\").hasArg().valueSeparator().build());\n\n        final String[] args = { \"-a\", \"-b\", \"foo\", \"--c\", \"--d\", \"bar\" };\n\n        cl = new PosixParser().parse(opts, args);\n    }\n\n    @Test\n    public void testLongNoArg() {\n        assertTrue(cl.hasOption(\"c\"));\n        assertNull(cl.getOptionValue(\"c\"));\n    }\n\n    @Test\n    public void testLongNoArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"c\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"c\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertEquals(\"face\", cmd.getOptionValue(\"fish\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValue(\"gravy\"));\n        assertEquals(\"gold\", cmd.getOptionValues(\"gravy\")[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(\"gravy\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--gravy\", \"gold\", \"garden\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValue(opts.getOption(\"gravy\")));\n        assertEquals(\"gold\", cmd.getOptionValues(opts.getOption(\"gravy\"))[0]);\n        assertEquals(\"garden\", cmd.getOptionValues(opts.getOption(\"gravy\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalArgValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\", \"face\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertEquals(\"face\", cmd.getOptionValue(opts.getOption(\"fish\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--hide\", \"house\", \"hair\", \"head\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValue(\"hide\"));\n        assertEquals(\"house\", cmd.getOptionValues(\"hide\")[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(\"hide\")[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final CommandLine cmd = parser.parse(opts, new String[] { \"--hide\", \"house\", \"hair\", \"head\" });\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValue(opts.getOption(\"hide\")));\n        assertEquals(\"house\", cmd.getOptionValues(opts.getOption(\"hide\"))[0]);\n        assertEquals(\"hair\", cmd.getOptionValues(opts.getOption(\"hide\"))[1]);\n        assertEquals(cmd.getArgs().length, 1);\n        assertEquals(\"head\", cmd.getArgs()[0]);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"fish\"));\n        assertNull(cmd.getOptionValue(\"fish\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testLongOptionalNoValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"--fish\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"fish\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"fish\")));\n    }\n\n    @Test\n    public void testLongWithArg() {\n        assertTrue(cl.hasOption(\"d\"));\n        assertNotNull(cl.getOptionValue(\"d\"));\n        assertEquals(cl.getOptionValue(\"d\"), \"bar\");\n    }\n\n    @Test\n    public void testLongWithArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"d\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"d\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"d\")), \"bar\");\n    }\n\n    @Test\n    public void testShortNoArg() {\n        assertTrue(cl.hasOption(\"a\"));\n        assertNull(cl.getOptionValue(\"a\"));\n    }\n\n    @Test\n    public void testShortNoArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"a\")));\n        assertNull(cl.getOptionValue(opts.getOption(\"a\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertNull(cmd.getOptionValue(\"e\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgNoValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertNull(cmd.getOptionValue(opts.getOption(\"e\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValue(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"e\"));\n        assertEquals(\"everything\", cmd.getOptionValue(\"e\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"j\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"j\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"j\")[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValuesWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-j\", \"ink\", \"idea\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"j\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"j\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"j\"))[1]);\n        assertEquals(cmd.getArgs().length, 0);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalArgValueWithOption(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-e\", \"everything\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(opts.getOption(\"e\")));\n        assertEquals(\"everything\", cmd.getOptionValue(opts.getOption(\"e\")));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"parsers\")\n    public void testShortOptionalNArgValues(final CommandLineParser parser) throws Exception {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"i\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"i\")[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }\n\n    @Test\n    public void testShortOptionalNArgValuesSeparated() throws Exception {\n        final String[] args = { \"-v=ink\", \"-v=idea\", \"-v=isotope\", \"-v=ice\" };\n        final CommandLineParser parser = new DefaultParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"v\"));\n        assertEquals(\"ink\", cmd.getOptionValues(\"v\")[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(\"v\")[1]);\n        assertEquals(\"isotope\", cmd.getOptionValues(\"v\")[2]);\n        assertEquals(\"ice\", cmd.getOptionValues(\"v\")[3]);\n    }\n\n    @Test\n    public void testShortOptionalNArgValuesWithOption() throws Exception {\n        final String[] args = { \"-i\", \"ink\", \"idea\", \"isotope\", \"ice\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(opts, args);\n        assertNull(cmd.getOptionValues(NULL_OPTION));\n        assertNull(cmd.getOptionValues(NULL_STRING));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(opts.getOption(\"i\")));\n        assertEquals(\"ink\", cmd.getOptionValues(opts.getOption(\"i\"))[0]);\n        assertEquals(\"idea\", cmd.getOptionValues(opts.getOption(\"i\"))[1]);\n        assertEquals(cmd.getArgs().length, 2);\n        assertEquals(\"isotope\", cmd.getArgs()[0]);\n        assertEquals(\"ice\", cmd.getArgs()[1]);\n    }\n\n    @Test\n    public void testShortWithArg() {\n        assertTrue(cl.hasOption(\"b\"));\n        assertNotNull(cl.getOptionValue(\"b\"));\n        assertEquals(cl.getOptionValue(\"b\"), \"foo\");\n    }\n\n    @Test\n    public void testShortWithArgWithOption() {\n        assertTrue(cl.hasOption(opts.getOption(\"b\")));\n        assertNotNull(cl.getOptionValue(opts.getOption(\"b\")));\n        assertEquals(cl.getOptionValue(opts.getOption(\"b\")), \"foo\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Option NULL_OPTION = null;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Option", "name": "NULL_OPTION = null", "syntax_pass": true}, {"attribute_expression": "private static final String NULL_STRING = null;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "NULL_STRING = null", "syntax_pass": true}, {"attribute_expression": "private final Options opts = new Options();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Options", "name": "opts = new Options()", "syntax_pass": true}, {"attribute_expression": "private CommandLine cl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CommandLine", "name": "cl", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/OptionTest.java.OptionTest", "name": "OptionTest", "file_path": "src/test/java/org/apache/commons/cli/OptionTest.java", "superclasses": "", "methods": ["[void]testAddValue()", "[void]testBuilderEmpty()", "[void]testBuilderInsufficientParams1()", "[void]testBuilderInsufficientParams2()", "[void]testBuilderInvalidOptionName0()", "[void]testBuilderInvalidOptionName1()", "[void]testBuilderInvalidOptionName2()", "[void]testBuilderInvalidOptionName3()", "[void]testBuilderInvalidOptionName4()", "[void]testBuilderMethods()", "[void]testClear()", "[void]testClone()", "[void]testEquals()", "[void]testGetValue()", "[void]testHasArgName()", "[void]testHasArgs()", "[void]testHashCode()", "[void]testSerialization()", "[void]testSubclass()", "[void]testTypeClass()", "[void]testTypeObject()"], "method_uris": ["src/test/java/org/apache/commons/cli/OptionTest.java.OptionTest.[void]checkOption(Option,String,String,String,int,String,boolean,boolean,char,Class<?>,String,Boolean,String)", "src/test/java/org/apache/commons/cli/OptionTest.java.OptionTest.[Option]roundTrip(Option)"], "overrides": null, "attributes": [{"original_string": "    private static final class DefaultOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        private final String defaultValue;\n\n        DefaultOption(final String opt, final String description, final String defaultValue) throws IllegalArgumentException {\n            super(opt, true, description);\n            this.defaultValue = defaultValue;\n        }\n\n        @Override\n        public String getValue() {\n            return super.getValue() != null ? super.getValue() : defaultValue;\n        }\n    }", "definition": "    private static final class DefaultOption extends Option", "class_docstring": "", "name": "DefaultOption", "super_interfaces": [], "superclasses": "Option", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final String defaultValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "defaultValue", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        DefaultOption(final String opt, final String description, final String defaultValue) throws IllegalArgumentException {\n            super(opt, true, description);\n            this.defaultValue = defaultValue;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DefaultOption", "params": [{"name": "opt", "type": "String"}, {"name": "description", "type": "String"}, {"name": "defaultValue", "type": "String"}], "body": "                                                                                                                             {\n            super(opt, true, description);\n            this.defaultValue = defaultValue;\n        }", "signature": "DefaultOption(final String opt, final String description, final String defaultValue)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getValue() {\n            return super.getValue() != null ? super.getValue() : defaultValue;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getValue", "params": [], "body": "                                 {\n            return super.getValue() != null ? super.getValue() : defaultValue;\n        }", "signature": "@Override\n        public String getValue()"}]}, {"original_string": "    private static final class TestOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);\n        }\n\n        @Override\n        public boolean addValue(final String value) {\n            processValue(value);\n            return true;\n        }\n    }", "definition": "    private static final class TestOption extends Option", "class_docstring": "", "name": "TestOption", "super_interfaces": [], "superclasses": "Option", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestOption", "params": [{"name": "opt", "type": "String"}, {"name": "hasArg", "type": "boolean"}, {"name": "description", "type": "String"}], "body": "                                                                                                                     {\n            super(opt, hasArg, description);\n        }", "signature": "TestOption(final String opt, final boolean hasArg, final String description)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean addValue(final String value) {\n            processValue(value);\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addValue", "params": [{"name": "value", "type": "String"}], "body": "                                                    {\n            processValue(value);\n            return true;\n        }", "signature": "@Override\n        public boolean addValue(final String value)"}]}], "class_docstring": "", "original_string": "public class OptionTest {\n\n    private static final class DefaultOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        private final String defaultValue;\n\n        DefaultOption(final String opt, final String description, final String defaultValue) throws IllegalArgumentException {\n            super(opt, true, description);\n            this.defaultValue = defaultValue;\n        }\n\n        @Override\n        public String getValue() {\n            return super.getValue() != null ? super.getValue() : defaultValue;\n        }\n    }\n\n    private static final class TestOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);\n        }\n\n        @Override\n        public boolean addValue(final String value) {\n            processValue(value);\n            return true;\n        }\n    }\n\n    private static void checkOption(final Option option, final String opt, final String description, final String longOpt, final int numArgs,\n            final String argName, final boolean required, final boolean optionalArg, final char valueSeparator, final Class<?> cls, final String deprecatedDesc,\n            final Boolean deprecatedForRemoval, final String deprecatedSince) {\n        assertEquals(opt, option.getOpt());\n        assertEquals(description, option.getDescription());\n        assertEquals(longOpt, option.getLongOpt());\n        assertEquals(numArgs, option.getArgs());\n        assertEquals(argName, option.getArgName());\n        assertEquals(required, option.isRequired());\n\n        assertEquals(optionalArg, option.hasOptionalArg());\n        assertEquals(numArgs > 0, option.hasArg());\n        assertEquals(numArgs > 0, option.acceptsArg());\n        assertEquals(valueSeparator, option.getValueSeparator());\n        assertEquals(cls, option.getType());\n        if (deprecatedDesc != null) {\n            assertEquals(deprecatedDesc, option.getDeprecated().getDescription());\n        }\n        if (deprecatedForRemoval != null) {\n            assertEquals(deprecatedForRemoval, option.getDeprecated().isForRemoval());\n        }\n        if (deprecatedSince != null) {\n            assertEquals(deprecatedSince, option.getDeprecated().getSince());\n        }\n    }\n\n    private Option roundTrip(final Option o) throws IOException, ClassNotFoundException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(o);\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream ois = new ObjectInputStream(bais);\n        return (Option) ois.readObject();\n    }\n\n    @Test\n    public void testAddValue() {\n        final Option option = new Option(\"f\", null);\n        assertThrows(UnsupportedOperationException.class, () -> option.addValue(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> option.processValue(\"\"));\n    }\n\n    @Test\n    public void testBuilderEmpty() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().build());\n    }\n\n    @Test\n    public void testBuilderInsufficientParams1() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().desc(\"desc\").build());\n    }\n\n    @Test\n    public void testBuilderInsufficientParams2() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(null).desc(\"desc\").build());\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName0() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(null).build());\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"\"));\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\" \"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName1() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid?\"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName2() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder().option(\"invalid@\"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName3() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid?\"));\n    }\n\n    @Test\n    public void testBuilderInvalidOptionName4() {\n        assertThrows(IllegalArgumentException.class, () -> Option.builder(\"invalid@\"));\n    }\n\n    @Test\n    public void testBuilderMethods() {\n        final char defaultSeparator = (char) 0;\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").longOpt(\"aaa\").build(), \"a\", \"desc\", \"aaa\", Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").hasArg(true).build(), \"a\", \"desc\", null, 1, null, false, false, defaultSeparator, String.class, null, null,\n                null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").numberOfArgs(3).build(), \"a\", \"desc\", null, 3, null, false, false, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(true).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, true, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").required(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n\n        checkOption(Option.builder(\"a\").desc(\"desc\").argName(\"arg1\").build(), \"a\", \"desc\", null, Option.UNINITIALIZED, \"arg1\", false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(false).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").optionalArg(true).build(), \"a\", \"desc\", null, 1, null, false, true, defaultSeparator, String.class, null,\n                null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").valueSeparator(':').build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, ':',\n                String.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                Integer.class, null, null, null);\n        checkOption(Option.builder(\"a\").desc(\"desc\").type(null).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator,\n                String.class, null, null, null);\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false,\n                defaultSeparator, Integer.class, null, null, null);\n        // Deprecated\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated().build(), \"a\", \"desc\", null, Option.UNINITIALIZED, null, false,\n                false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().get()).build(), \"a\", \"desc\", null,\n                Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"\", false, \"\");\n        checkOption(Option.builder().option(\"a\").desc(\"desc\").type(Integer.class).deprecated(DeprecatedAttributes.builder().setDescription(\"X\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", false, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"\");\n        checkOption(\n                Option.builder().option(\"a\").desc(\"desc\").type(Integer.class)\n                        .deprecated(DeprecatedAttributes.builder().setDescription(\"X\").setForRemoval(true).setSince(\"2.0\").get()).build(),\n                \"a\", \"desc\", null, Option.UNINITIALIZED, null, false, false, defaultSeparator, Integer.class, \"X\", true, \"2.0\");\n    }\n\n    @Test\n    public void testClear() {\n        final TestOption option = new TestOption(\"x\", true, \"\");\n        assertEquals(0, option.getValuesList().size());\n        option.addValue(\"a\");\n        assertEquals(1, option.getValuesList().size());\n        option.clearValues();\n        assertEquals(0, option.getValuesList().size());\n    }\n\n    // See https://issues.apache.org/jira/browse/CLI-21\n    @Test\n    public void testClone() {\n        final TestOption a = new TestOption(\"a\", true, \"\");\n        final TestOption b = (TestOption) a.clone();\n        assertEquals(a, b);\n        assertNotSame(a, b);\n        a.setDescription(\"a\");\n        assertEquals(\"\", b.getDescription());\n        b.setArgs(2);\n        b.addValue(\"b1\");\n        b.addValue(\"b2\");\n        assertEquals(1, a.getArgs());\n        assertEquals(0, a.getValuesList().size());\n        assertEquals(2, b.getValues().length);\n    }\n\n    @Test\n    public void testEquals() {\n        final Option option1a = new Option(\"1\", null);\n        final Option option1b = new Option(\"1\", null);\n        final Option option2 = new Option(\"2\", null);\n        assertEquals(option1a, option1a);\n        assertEquals(option1a, option1b);\n        assertEquals(option1b, option1a);\n        assertNotEquals(option1a, option2);\n        assertNotEquals(option1b, option2);\n        assertNotEquals(option2, option1a);\n        assertNotEquals(option2, \"\");\n    }\n\n    @Test\n    public void testGetValue() {\n        final Option option = new Option(\"f\", null);\n        option.setArgs(Option.UNLIMITED_VALUES);\n\n        assertEquals(\"default\", option.getValue(\"default\"));\n        assertNull(option.getValue(0));\n\n        option.processValue(\"foo\");\n\n        assertEquals(\"foo\", option.getValue());\n        assertEquals(\"foo\", option.getValue(0));\n        assertEquals(\"foo\", option.getValue(\"default\"));\n    }\n\n    @Test\n    public void testHasArgName() {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgName(null);\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"\");\n        assertFalse(option.hasArgName());\n\n        option.setArgName(\"file\");\n        assertTrue(option.hasArgName());\n    }\n\n    @Test\n    public void testHasArgs() {\n        final Option option = new Option(\"f\", null);\n\n        option.setArgs(0);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(1);\n        assertFalse(option.hasArgs());\n\n        option.setArgs(10);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNLIMITED_VALUES);\n        assertTrue(option.hasArgs());\n\n        option.setArgs(Option.UNINITIALIZED);\n        assertFalse(option.hasArgs());\n    }\n\n    @Test\n    public void testHashCode() {\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test2\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder().longOpt(\"test\").build().hashCode());\n        assertNotEquals(Option.builder(\"test\").build().hashCode(), Option.builder(\"test\").longOpt(\"long test\").build().hashCode());\n    }\n\n    @Test\n    public void testSerialization() throws IOException, ClassNotFoundException {\n        final Option option = Option.builder(\"o\").type(TypeHandlerTest.Instantiable.class).build();\n        assertEquals(Converter.DEFAULT, option.getConverter());\n        Option roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify unregistered class converters and verifiers get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        option.setConverter(Converter.DATE);\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n        // verify registered class converters and verifiers do not get reset to default.\n        // converters are NOT Serializable, use a serialization proxy if you want that.\n        // verify earlier values still set.\n        assertEquals(Converter.DATE, option.getConverter());\n        roundtrip = roundTrip(option);\n        assertEquals(Converter.DEFAULT, roundtrip.getConverter());\n    }\n\n    @Test\n    public void testSubclass() {\n        final Option option = new DefaultOption(\"f\", \"file\", \"myfile.txt\");\n        final Option clone = (Option) option.clone();\n        assertEquals(\"myfile.txt\", clone.getValue());\n        assertEquals(DefaultOption.class, clone.getClass());\n    }\n\n    @Test\n    public void testTypeClass() {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        option.setType(CharSequence.class);\n        assertEquals(CharSequence.class, option.getType());\n    }\n\n    @Test\n    public void testTypeObject() {\n        final Option option = new Option(\"f\", null);\n        assertEquals(String.class, option.getType());\n        @SuppressWarnings(\"cast\")\n        final Object type = CharSequence.class; // Do NOT remove cast\n        option.setType(type);\n        assertEquals(CharSequence.class, option.getType());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/OptionsTest.java.OptionsTest", "name": "OptionsTest", "file_path": "src/test/java/org/apache/commons/cli/OptionsTest.java", "superclasses": "", "methods": ["[void]testAddConflictingOptions()", "[void]testAddNonConflictingOptions()", "[void]testAddOptions()", "[void]testAddOptions2X()", "[void]testDeprecated()", "[void]testDuplicateLong()", "[void]testDuplicateSimple()", "[void]testGetMatchingOpts()", "[void]testGetOptionsGroups()", "[void]testHelpOptions()", "[void]testLong()", "[void]testMissingOptionException()", "[void]testMissingOptionsException()", "[void]testSimple()", "[void]testToString()"], "method_uris": ["src/test/java/org/apache/commons/cli/OptionsTest.java.OptionsTest.[void]assertToStrings(Option)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class OptionsTest {\n\n    private void assertToStrings(final Option option) {\n        // Should never throw.\n        // Should return a String, not null.\n        assertNotNull(option.toString());\n        assertNotNull(option.toDeprecatedString());\n    }\n\n    @Test\n    public void testAddConflictingOptions() {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"x\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"b\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options2.addOption(Option.builder(\"c\").build());\n        assertThrows(IllegalArgumentException.class, () -> options1.addOptions(options2));\n    }\n\n    @Test\n    public void testAddNonConflictingOptions() {\n        final Options options1 = new Options();\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n        options1.addOptionGroup(group1);\n        options1.addOption(Option.builder(\"x\").build());\n        options1.addOption(Option.builder(\"y\").build());\n\n        final Options options2 = new Options();\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(Option.builder(\"c\").type(Integer.class).build());\n        group2.addOption(Option.builder(\"d\").type(Integer.class).build());\n        options2.addOptionGroup(group2);\n        options1.addOption(Option.builder(\"e\").build());\n        options1.addOption(Option.builder(\"f\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options1);\n        underTest.addOptions(options2);\n\n        final List<OptionGroup> expected = Arrays.asList(group1, group2);\n        assertTrue(expected.size() == underTest.getOptionGroups().size() && expected.containsAll(underTest.getOptionGroups()));\n        final Set<Option> expectOpt = new HashSet<>(options1.getOptions());\n        expectOpt.addAll(options2.getOptions());\n        assertEquals(8, expectOpt.size());\n        assertTrue(expectOpt.size() == underTest.getOptions().size() && expectOpt.containsAll(underTest.getOptions()));\n    }\n\n    @Test\n    public void testAddOptions() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        final Options underTest = new Options();\n        underTest.addOptions(options);\n\n        assertEquals(options.getOptionGroups(), underTest.getOptionGroups());\n        assertArrayEquals(options.getOptions().toArray(), underTest.getOptions().toArray());\n    }\n\n    @Test\n    public void testAddOptions2X() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(Option.builder(\"a\").build());\n        group1.addOption(Option.builder(\"b\").build());\n\n        options.addOptionGroup(group1);\n\n        options.addOption(Option.builder(\"X\").build());\n        options.addOption(Option.builder(\"y\").build());\n\n        assertThrows(IllegalArgumentException.class, () -> options.addOptions(options));\n    }\n\n    @Test\n    public void testDeprecated() {\n        final Options options = new Options();\n        options.addOption(Option.builder().option(\"a\").build());\n        options.addOption(Option.builder().option(\"b\").deprecated().build());\n        options.addOption(Option.builder().option(\"c\")\n                .deprecated(DeprecatedAttributes.builder().setForRemoval(true).setSince(\"2.0\").setDescription(\"Use X.\").get()).build());\n        options.addOption(Option.builder().option(\"d\").deprecated().longOpt(\"longD\").hasArgs().build());\n        // toString()\n        assertTrue(options.getOption(\"a\").toString().startsWith(\"[ Option a\"));\n        assertTrue(options.getOption(\"b\").toString().startsWith(\"[ Option b\"));\n        assertTrue(options.getOption(\"c\").toString().startsWith(\"[ Option c\"));\n        // toDeprecatedString()\n        assertFalse(options.getOption(\"a\").toDeprecatedString().startsWith(\"Option a\"));\n        assertEquals(\"Option 'b': Deprecated\", options.getOption(\"b\").toDeprecatedString());\n        assertEquals(\"Option 'c': Deprecated for removal since 2.0: Use X.\", options.getOption(\"c\").toDeprecatedString());\n        assertToStrings(options.getOption(\"a\"));\n        assertToStrings(options.getOption(\"b\"));\n        assertToStrings(options.getOption(\"c\"));\n        assertToStrings(options.getOption(\"d\"));\n    }\n\n    @Test\n    public void testDuplicateLong() {\n        final Options options = new Options();\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"a\", \"--a\", false, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }\n\n    @Test\n    public void testDuplicateSimple() {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        assertToStrings(options.getOption(\"a\"));\n        options.addOption(\"a\", true, \"toggle -a*\");\n        assertEquals(\"toggle -a*\", options.getOption(\"a\").getDescription(), \"last one in wins\");\n        assertToStrings(options.getOption(\"a\"));\n    }\n\n    @Test\n    public void testGetMatchingOpts() {\n        final Options options = new Options();\n        OptionBuilder.withLongOpt(\"version\");\n        options.addOption(OptionBuilder.create());\n        OptionBuilder.withLongOpt(\"verbose\");\n        options.addOption(OptionBuilder.create());\n        assertTrue(options.getMatchingOptions(\"foo\").isEmpty());\n        assertEquals(1, options.getMatchingOptions(\"version\").size());\n        assertEquals(2, options.getMatchingOptions(\"ver\").size());\n        assertToStrings(options.getOption(\"version\"));\n        assertToStrings(options.getOption(\"verbose\"));\n    }\n\n    @Test\n    public void testGetOptionsGroups() {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(OptionBuilder.create('a'));\n        group1.addOption(OptionBuilder.create('b'));\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(OptionBuilder.create('x'));\n        group2.addOption(OptionBuilder.create('y'));\n\n        options.addOptionGroup(group1);\n        options.addOptionGroup(group2);\n\n        assertNotNull(options.getOptionGroups());\n        assertEquals(2, options.getOptionGroups().size());\n    }\n\n    @Test\n    public void testHelpOptions() {\n        OptionBuilder.withLongOpt(\"long-only1\");\n        final Option longOnly1 = OptionBuilder.create();\n        OptionBuilder.withLongOpt(\"long-only2\");\n        final Option longOnly2 = OptionBuilder.create();\n        final Option shortOnly1 = OptionBuilder.create(\"1\");\n        final Option shortOnly2 = OptionBuilder.create(\"2\");\n        OptionBuilder.withLongOpt(\"bothA\");\n        final Option bothA = OptionBuilder.create(\"a\");\n        OptionBuilder.withLongOpt(\"bothB\");\n        final Option bothB = OptionBuilder.create(\"b\");\n\n        final Options options = new Options();\n        options.addOption(longOnly1);\n        options.addOption(longOnly2);\n        options.addOption(shortOnly1);\n        options.addOption(shortOnly2);\n        options.addOption(bothA);\n        options.addOption(bothB);\n\n        final Collection<Option> allOptions = new ArrayList<>();\n        allOptions.add(longOnly1);\n        allOptions.add(longOnly2);\n        allOptions.add(shortOnly1);\n        allOptions.add(shortOnly2);\n        allOptions.add(bothA);\n        allOptions.add(bothB);\n\n        final Collection<Option> helpOptions = options.helpOptions();\n\n        assertTrue(helpOptions.containsAll(allOptions), \"Everything in all should be in help\");\n        assertTrue(allOptions.containsAll(helpOptions), \"Everything in help should be in all\");\n    }\n\n    @Test\n    public void testLong() {\n        final Options options = new Options();\n\n        options.addOption(\"a\", \"--a\", false, \"toggle -a\");\n        options.addOption(\"b\", \"--b\", true, \"set -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }\n\n    @Test\n    public void testMissingOptionException() throws ParseException {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: f\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testMissingOptionsException() throws ParseException {\n        final Options options = new Options();\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"f\"));\n        OptionBuilder.isRequired();\n        options.addOption(OptionBuilder.create(\"x\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: f, x\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testSimple() {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"toggle -b\");\n\n        assertTrue(options.hasOption(\"a\"));\n        assertTrue(options.hasOption(\"b\"));\n    }\n\n    @Test\n    public void testToString() {\n        final Options options = new Options();\n        options.addOption(\"f\", \"foo\", true, \"Foo\");\n        options.addOption(\"b\", \"bar\", false, \"Bar\");\n\n        final String s = options.toString();\n        assertNotNull(s, \"null string returned\");\n        assertTrue(s.toLowerCase().contains(\"foo\"), \"foo option missing\");\n        assertTrue(s.toLowerCase().contains(\"bar\"), \"bar option missing\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/UnrecognizedOptionExceptionTest.java.UnrecognizedOptionExceptionTest", "name": "UnrecognizedOptionExceptionTest", "file_path": "src/test/java/org/apache/commons/cli/UnrecognizedOptionExceptionTest.java", "superclasses": "", "methods": ["[void]testConstructor()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link UnrecognizedOptionException}.\n", "original_string": "public class UnrecognizedOptionExceptionTest {\n\n    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\").getMessage());\n        assertEquals(\"a\", new UnrecognizedOptionException(\"a\", \"b\").getMessage());\n        assertEquals(\"b\", new UnrecognizedOptionException(\"a\", \"b\").getOption());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/PatternOptionBuilder_parsePatternTest.java.PatternOptionBuilder_parsePatternTest", "name": "PatternOptionBuilder_parsePatternTest", "file_path": "src/test/java/org/apache/commons/cli/PatternOptionBuilder_parsePatternTest.java", "superclasses": "", "methods": ["[void]testParsePattern_SingleOption()", "[void]testParsePattern_OptionWithValueCode()", "[void]testParsePattern_OptionWithRequiredFlag()", "[void]testParsePattern_MultipleOptions()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PatternOptionBuilder_parsePatternTest {\n\n    @Test\n    public void testParsePattern_SingleOption() {\n        Options options = PatternOptionBuilder.parsePattern(\"a\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOptions().iterator().next();\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n    }\n\n    @Test\n    public void testParsePattern_OptionWithValueCode() {\n        Options options = PatternOptionBuilder.parsePattern(\"a@\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOptions().iterator().next();\n        assertEquals(\"a\", option.getOpt());\n        assertTrue(option.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, option.getType());\n    }\n\n    @Test\n    public void testParsePattern_OptionWithRequiredFlag() {\n        Options options = PatternOptionBuilder.parsePattern(\"a!\");\n        assertEquals(1, options.getOptions().size());\n        Option option = options.getOptions().iterator().next();\n        assertEquals(\"a\", option.getOpt());\n        assertFalse(option.hasArg());\n        assertTrue(option.isRequired());\n    }\n\n    @Test\n    public void testParsePattern_MultipleOptions() {\n        Options options = PatternOptionBuilder.parsePattern(\"ab@c!\");\n        assertEquals(3, options.getOptions().size());\n        Option optionA = options.getOption(\"a\");\n        Option optionB = options.getOption(\"b\");\n        Option optionC = options.getOption(\"c\");\n\n        assertNotNull(optionA);\n        assertFalse(optionA.hasArg());\n\n        assertNotNull(optionB);\n        assertTrue(optionB.hasArg());\n        assertEquals(PatternOptionBuilder.OBJECT_VALUE, optionB.getType());\n\n        assertNotNull(optionC);\n        assertFalse(optionC.hasArg());\n        assertTrue(optionC.isRequired());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/AlreadySelectedExceptionTest.java.AlreadySelectedExceptionTest", "name": "AlreadySelectedExceptionTest", "file_path": "src/test/java/org/apache/commons/cli/AlreadySelectedExceptionTest.java", "superclasses": "", "methods": ["[void]testConstructor()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link AlreadySelectedException}.\n", "original_string": "public class AlreadySelectedExceptionTest {\n\n    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new AlreadySelectedException(\"a\").getMessage());\n        assertNull(new AlreadySelectedException(\"a\").getOption());\n        final Option option = new Option(\"a\", \"d\");\n        final OptionGroup group = new OptionGroup();\n        assertNotNull(new AlreadySelectedException(group, option).getMessage());\n        assertEquals(option, new AlreadySelectedException(group, option).getOption());\n        assertEquals(group, new AlreadySelectedException(group, option).getOptionGroup());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/ConverterTests.java.ConverterTests", "name": "ConverterTests", "file_path": "src/test/java/org/apache/commons/cli/ConverterTests.java", "superclasses": "", "methods": ["[void]classTests()", "[void]dateTests()", "[void]fileTests()", "[void]numberTests(String,Number)", "[void]objectTests()", "[void]urlTests()"], "method_uris": ["src/test/java/org/apache/commons/cli/ConverterTests.java.ConverterTests.[Stream<Arguments>]numberTestParameters()"], "overrides": null, "attributes": [{"original_string": "    public class AClassWithoutADefaultConstructor {\n        public AClassWithoutADefaultConstructor(final int i) {\n        }\n    }", "definition": "    public class AClassWithoutADefaultConstructor", "class_docstring": " A class without a default constructor.", "name": "AClassWithoutADefaultConstructor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AClassWithoutADefaultConstructor(final int i) {\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AClassWithoutADefaultConstructor", "params": [{"name": "i", "type": "int"}], "body": "                                                             {\n        }", "signature": "public AClassWithoutADefaultConstructor(final int i)"}]}], "class_docstring": "\nTests for standard Converters.\n", "original_string": "public class ConverterTests {\n\n    // A class without a default constructor.\n    public class AClassWithoutADefaultConstructor {\n        public AClassWithoutADefaultConstructor(final int i) {\n        }\n    }\n\n    private static Stream<Arguments> numberTestParameters() {\n        final List<Arguments> lst = new ArrayList<>();\n\n        lst.add(Arguments.of(\"123\", Long.valueOf(\"123\")));\n        lst.add(Arguments.of(\"12.3\", Double.valueOf(\"12.3\")));\n        lst.add(Arguments.of(\"-123\", Long.valueOf(\"-123\")));\n        lst.add(Arguments.of(\"-12.3\", Double.valueOf(\"-12.3\")));\n        lst.add(Arguments.of(\".3\", Double.valueOf(\"0.3\")));\n        lst.add(Arguments.of(\"-.3\", Double.valueOf(\"-0.3\")));\n        lst.add(Arguments.of(\"0x5F\", null));\n        lst.add(Arguments.of(\"2,3\", null));\n        lst.add(Arguments.of(\"1.2.3\", null));\n\n        return lst.stream();\n    }\n\n    @Test\n    public void classTests() throws Exception {\n\n        assertNotNull(Converter.CLASS.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.CLASS.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.CLASS.apply(\"foo.bar\"));\n        assertNotNull(Converter.CLASS.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }\n\n    @Test\n    public void dateTests() throws Exception {\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"whatever\"));\n\n        /*\n         * Dates calculated from strings are dependent upon configuration and environment settings for the\n         * machine on which the test is running.  To avoid this problem, convert the time into a string\n         * and then unparse that using the converter.  This produces strings that always match the correct\n         * time zone.\n         */\n        final Date expected = new Date(1023400137000L);\n        final DateFormat dateFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\");\n        final String formatted = dateFormat.format(expected);\n        assertEquals(expected, Converter.DATE.apply(formatted));\n\n        assertThrows(java.text.ParseException.class, () -> Converter.DATE.apply(\"Jun 06 17:48:57 EDT 2002\"));\n    }\n\n    @Test\n    public void fileTests() throws Exception {\n        final URL url = this.getClass().getClassLoader().getResource(\"./org/apache/commons/cli/existing-readable.file\");\n        final String fileName = url.toString().substring(\"file:\".length());\n        assertNotNull(Converter.FILE.apply(fileName));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"numberTestParameters\")\n    public void numberTests(final String str, final Number expected) throws Exception {\n        if (expected != null) {\n            assertEquals(expected, Converter.NUMBER.apply(str));\n        } else {\n            assertThrows(NumberFormatException.class, () -> Converter.NUMBER.apply(str));\n        }\n    }\n\n    @Test\n    public void objectTests() throws Exception {\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getName()), this.getClass().getName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getCanonicalName()), this.getClass().getCanonicalName());\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(this.getClass().getSimpleName()),\n                this.getClass().getSimpleName());\n        assertNotNull(Converter.OBJECT.apply(this.getClass().getTypeName()), this.getClass().getTypeName());\n\n        assertThrows(ClassNotFoundException.class, () -> Converter.OBJECT.apply(\"foo.bar\"));\n        assertThrows(NoSuchMethodException.class, () -> Converter.OBJECT.apply(AClassWithoutADefaultConstructor.class.getName()));\n    }\n\n    @Test\n    public void urlTests() throws Exception {\n        assertEquals(new URL(\"http://apache.org\"), Converter.URL.apply(\"http://apache.org\"));\n        assertThrows(java.net.MalformedURLException.class, () -> Converter.URL.apply(\"foo.bar\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/Option_cloneTest.java.Option_cloneTest", "name": "Option_cloneTest", "file_path": "src/test/java/org/apache/commons/cli/Option_cloneTest.java", "superclasses": "", "methods": ["[void]testClone()"], "method_uris": ["src/test/java/org/apache/commons/cli/Option_cloneTest.java.Option_cloneTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Option_cloneTest {\n\n    private Option option;\n\n    @BeforeEach\n    public void setUp() {\n        option = Option.builder(\"o\").longOpt(\"option\").hasArg().build();\n        option.getValuesList().add(\"value1\");\n        option.getValuesList().add(\"value2\");\n    }\n\n    @Test\n    public void testClone() {\n        final Option clonedOption = (Option) option.clone();\n\n        // Verify that the clone is not the same instance\n        assertNotSame(option, clonedOption);\n\n        // Verify that the clone has the same state\n        assertEquals(option.getOpt(), clonedOption.getOpt());\n        assertEquals(option.getLongOpt(), clonedOption.getLongOpt());\n        assertEquals(option.getDescription(), clonedOption.getDescription());\n        assertEquals(option.getValuesList(), clonedOption.getValuesList());\n\n        // Verify that the clone is equal to the original\n        assertTrue(option.equals(clonedOption));\n        assertEquals(option.hashCode(), clonedOption.hashCode());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Option option;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/OptionBuilder_hasOptionalArgsTest.java.OptionBuilder_hasOptionalArgsTest", "name": "OptionBuilder_hasOptionalArgsTest", "file_path": "src/test/java/org/apache/commons/cli/OptionBuilder_hasOptionalArgsTest.java", "superclasses": "", "methods": ["[void]testHasOptionalArgs()", "[void]testHasOptionalArgsWithCreate()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class OptionBuilder_hasOptionalArgsTest {\n\n    @Test\n    public void testHasOptionalArgs() {\n        OptionBuilder.hasOptionalArgs();\n        Option option = OptionBuilder.create(\"opt\");\n        assertEquals(Option.UNLIMITED_VALUES, option.getArgs());\n        assertTrue(option.hasOptionalArg());\n    }\n\n    @Test\n    public void testHasOptionalArgsWithCreate() {\n        OptionBuilder.hasOptionalArgs();\n        Option option = OptionBuilder.create(\"opt\");\n        assertEquals(Option.UNLIMITED_VALUES, option.getArgs());\n        assertTrue(option.hasOptionalArg());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/ParseExceptionTest.java.ParseExceptionTest", "name": "ParseExceptionTest", "file_path": "src/test/java/org/apache/commons/cli/ParseExceptionTest.java", "superclasses": "", "methods": ["[void]testConstructor()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link ParseException}.\n", "original_string": "public class ParseExceptionTest {\n\n    @Test\n    public void testConstructor() {\n        assertEquals(\"a\", new ParseException(\"a\").getMessage());\n        final Throwable t = new IOException();\n        assertEquals(t, new ParseException(t).getCause());\n        assertEquals(t, ParseException.wrap(t).getCause());\n        final ParseException pe = new ParseException(\"A\");\n        assertEquals(pe, ParseException.wrap(pe));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/OptionBuilderTest.java.OptionBuilderTest", "name": "OptionBuilderTest", "file_path": "src/test/java/org/apache/commons/cli/OptionBuilderTest.java", "superclasses": "", "methods": ["[void]testBaseOptionCharOpt()", "[void]testBaseOptionStringOpt()", "[void]testBuilderIsResettedAlways()", "[void]testCompleteOption()", "[void]testCreateIncompleteOption()", "[void]testIllegalOptions()", "[void]testOptionArgNumbers()", "[void]testSpecialOptChars()", "[void]testTwoCompleteOptions()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // OptionBuilder is marked deprecated\npublic class OptionBuilderTest {\n    @Test\n    public void testBaseOptionCharOpt() {\n        final Option base = OptionBuilder.withDescription(\"option description\").create('o');\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }\n\n    @Test\n    public void testBaseOptionStringOpt() {\n        final Option base = OptionBuilder.withDescription(\"option description\").create(\"o\");\n\n        assertEquals(\"o\", base.getOpt());\n        assertEquals(\"option description\", base.getDescription());\n        assertFalse(base.hasArg());\n    }\n\n    @Test\n    public void testBuilderIsResettedAlways() {\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create('\"');\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n\n        try {\n            OptionBuilder.withDescription(\"JUnit\").create();\n            fail(\"IllegalArgumentException expected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n        }\n        assertNull(OptionBuilder.create('x').getDescription(), \"we inherited a description\");\n    }\n\n    @Test\n    public void testCompleteOption() {\n        //@formatter:off\n        final Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n    }\n\n    @Test\n    public void testCreateIncompleteOption() {\n        try {\n            OptionBuilder.hasArg().create();\n            fail(\"Incomplete option should be rejected\");\n        } catch (final IllegalArgumentException e) {\n            // expected\n\n            // implicitly reset the builder\n            OptionBuilder.create(\"opt\");\n        }\n    }\n\n    @Test\n    public void testIllegalOptions() {\n        // bad single character option\n        try {\n            OptionBuilder.withDescription(\"option description\").create('\"');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // bad character in option string\n        try {\n            OptionBuilder.create(\"opt`\");\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException exp) {\n            // success\n        }\n\n        // valid option\n        try {\n            OptionBuilder.create(\"opt\");\n            // success\n        } catch (final IllegalArgumentException exp) {\n            fail(\"IllegalArgumentException caught\");\n        }\n    }\n\n    @Test\n    public void testOptionArgNumbers() {\n        //@formatter:off\n        final Option opt = OptionBuilder.withDescription(\"option description\")\n                                  .hasArgs(2)\n                                  .create('o');\n        //@formatter:on\n        assertEquals(2, opt.getArgs());\n    }\n\n    @Test\n    public void testSpecialOptChars() throws Exception {\n        // '?'\n        final Option opt1 = OptionBuilder.withDescription(\"help options\").create('?');\n        assertEquals(\"?\", opt1.getOpt());\n\n        // '@'\n        final Option opt2 = OptionBuilder.withDescription(\"read from stdin\").create('@');\n        assertEquals(\"@\", opt2.getOpt());\n\n        // ' '\n        try {\n            OptionBuilder.create(' ');\n            fail(\"IllegalArgumentException not caught\");\n        } catch (final IllegalArgumentException e) {\n            // success\n        }\n    }\n\n    @Test\n    public void testTwoCompleteOptions() {\n        //@formatter:off\n        Option simple = OptionBuilder.withLongOpt(\"simple option\")\n                                     .hasArg()\n                                     .isRequired()\n                                     .hasArgs()\n                                     .withType(Float.class)\n                                     .withDescription(\"this is a simple option\")\n                                     .create('s');\n        //@formatter:on\n\n        assertEquals(\"s\", simple.getOpt());\n        assertEquals(\"simple option\", simple.getLongOpt());\n        assertEquals(\"this is a simple option\", simple.getDescription());\n        assertEquals(simple.getType(), Float.class);\n        assertTrue(simple.hasArg());\n        assertTrue(simple.isRequired());\n        assertTrue(simple.hasArgs());\n\n        //@formatter:off\n        simple = OptionBuilder.withLongOpt(\"dimple option\")\n                              .hasArg()\n                              .withDescription(\"this is a dimple option\")\n                              .create('d');\n        //@formatter:on\n\n        assertEquals(\"d\", simple.getOpt());\n        assertEquals(\"dimple option\", simple.getLongOpt());\n        assertEquals(\"this is a dimple option\", simple.getDescription());\n        assertEquals(String.class, simple.getType());\n        assertTrue(simple.hasArg());\n        assertFalse(simple.isRequired());\n        assertFalse(simple.hasArgs());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/CommandLine_hasOptionTest.java.CommandLine_hasOptionTest", "name": "CommandLine_hasOptionTest", "file_path": "src/test/java/org/apache/commons/cli/CommandLine_hasOptionTest.java", "superclasses": "", "methods": ["[void]testHasOptionPresent()", "[void]testHasOptionAbsent()", "[void]testHasOptionDeprecated()"], "method_uris": ["src/test/java/org/apache/commons/cli/CommandLine_hasOptionTest.java.CommandLine_hasOptionTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CommandLine_hasOptionTest {\n    private CommandLine commandLine;\n\n    @BeforeEach\n    public void setUp() {\n        commandLine = new CommandLine();\n        commandLine.addOption(Option.builder(\"a\").build());\n        commandLine.addOption(Option.builder(\"b\").hasArg().build());\n    }\n\n    @Test\n    public void testHasOptionPresent() {\n        assertTrue(commandLine.hasOption(\"a\"));\n    }\n\n    @Test\n    public void testHasOptionAbsent() {\n        assertFalse(commandLine.hasOption(\"c\"));\n    }\n\n    @Test\n    public void testHasOptionDeprecated() {\n        Option deprecatedOption = Option.builder(\"d\").hasArg().deprecated().build();\n        commandLine.addOption(deprecatedOption);\n        assertTrue(commandLine.hasOption(\"d\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CommandLine commandLine;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CommandLine", "name": "commandLine", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/OptionBuilder_hasOptionalArgTest.java.OptionBuilder_hasOptionalArgTest", "name": "OptionBuilder_hasOptionalArgTest", "file_path": "src/test/java/org/apache/commons/cli/OptionBuilder_hasOptionalArgTest.java", "superclasses": "", "methods": ["[void]testHasOptionalArg()", "[void]testHasOptionalArgWithReset()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class OptionBuilder_hasOptionalArgTest {\n\n    @Test\n    public void testHasOptionalArg() {\n        // Given\n        OptionBuilder.hasOptionalArg();\n\n        // When\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n    }\n\n    @Test\n    public void testHasOptionalArgWithReset() {\n        // Given\n        OptionBuilder.hasOptionalArg();\n\n        // When\n        Option option = OptionBuilder.create(\"opt\");\n\n        // Then\n        assertTrue(option.hasOptionalArg());\n        assertEquals(1, option.getArgs());\n\n        // Reset and verify\n        OptionBuilder.hasOptionalArg(); // Reset by setting optional arg again\n        Option newOption = OptionBuilder.create(\"newOpt\");\n        assertTrue(newOption.hasOptionalArg());\n        assertEquals(1, newOption.getArgs());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/DeprecatedAttributes_toStringTest.java.DeprecatedAttributes_toStringTest", "name": "DeprecatedAttributes_toStringTest", "file_path": "src/test/java/org/apache/commons/cli/DeprecatedAttributes_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringDefault()", "[void]testToStringForRemoval()", "[void]testToStringSince()", "[void]testToStringDescription()", "[void]testToStringAllFields()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DeprecatedAttributes_toStringTest {\n\n    @Test\n    public void testToStringDefault() {\n        DeprecatedAttributes attributes = DeprecatedAttributes.DEFAULT;\n        assertEquals(\"Deprecated\", attributes.toString());\n    }\n\n    @Test\n    public void testToStringForRemoval() {\n        DeprecatedAttributes attributes = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .get();\n        assertEquals(\"Deprecated for removal\", attributes.toString());\n    }\n\n    @Test\n    public void testToStringSince() {\n        DeprecatedAttributes attributes = DeprecatedAttributes.builder()\n                .setSince(\"2.0\")\n                .get();\n        assertEquals(\"Deprecated since 2.0\", attributes.toString());\n    }\n\n    @Test\n    public void testToStringDescription() {\n        DeprecatedAttributes attributes = DeprecatedAttributes.builder()\n                .setDescription(\"Use Bar instead!\")\n                .get();\n        assertEquals(\"Deprecated: Use Bar instead!\", attributes.toString());\n    }\n\n    @Test\n    public void testToStringAllFields() {\n        DeprecatedAttributes attributes = DeprecatedAttributes.builder()\n                .setForRemoval(true)\n                .setSince(\"2.0\")\n                .setDescription(\"Use Bar instead!\")\n                .get();\n        assertEquals(\"Deprecated for removal since 2.0: Use Bar instead!\", attributes.toString());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/ValuesTest.java.ValuesTest", "name": "ValuesTest", "file_path": "src/test/java/org/apache/commons/cli/ValuesTest.java", "superclasses": "", "methods": ["[void]testCharSeparator()", "[void]testComplexValues()", "[void]testExtraArgs()", "[void]testMultipleArgValues()", "[void]testShortArgs()", "[void]testShortArgsWithValue()", "[void]testTwoArgValues()"], "method_uris": ["src/test/java/org/apache/commons/cli/ValuesTest.java.ValuesTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class ValuesTest {\n    private CommandLine cmd;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        final Options options = new Options();\n\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"b\", true, \"set -b\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(\"d\", \"d\", true, \"set -d\");\n\n        options.addOption(OptionBuilder.withLongOpt(\"e\").hasArgs().withDescription(\"set -e \").create('e'));\n        options.addOption(\"f\", \"f\", false, \"jk\");\n        options.addOption(OptionBuilder.withLongOpt(\"g\").hasArgs(2).withDescription(\"set -g\").create('g'));\n        options.addOption(OptionBuilder.withLongOpt(\"h\").hasArg().withDescription(\"set -h\").create('h'));\n        options.addOption(OptionBuilder.withLongOpt(\"i\").withDescription(\"set -i\").create('i'));\n        options.addOption(OptionBuilder.withLongOpt(\"j\").hasArgs().withDescription(\"set -j\").withValueSeparator('=').create('j'));\n        options.addOption(OptionBuilder.withLongOpt(\"k\").hasArgs().withDescription(\"set -k\").withValueSeparator('=').create('k'));\n        options.addOption(OptionBuilder.withLongOpt(\"m\").hasArgs().withDescription(\"set -m\").withValueSeparator().create('m'));\n\n        //@formatter:off\n        final String[] args = {\n            \"-a\",\n            \"-b\", \"foo\",\n            \"--c\",\n            \"--d\", \"bar\",\n            \"-e\", \"one\", \"two\",\n            \"-f\",\n            \"arg1\", \"arg2\",\n            \"-g\", \"val1\", \"val2\", \"arg3\",\n            \"-h\", \"val1\", \"-i\",\n            \"-h\", \"val2\",\n            \"-jkey=value\",\n            \"-j\", \"key=value\",\n            \"-kkey1=value1\",\n            \"-kkey2=value2\",\n            \"-mkey=value\"\n        };\n        //@formatter:on\n\n        final CommandLineParser parser = new PosixParser();\n\n        cmd = parser.parse(options, args);\n    }\n\n    @Test\n    public void testCharSeparator() {\n        // tests the char methods of CommandLine that delegate to the String methods\n        assertTrue(cmd.hasOption(\"j\"), \"Option j is not set\");\n        assertTrue(cmd.hasOption('j'), \"Option j is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues(\"j\"));\n        assertArrayEquals(new String[] {\"key\", \"value\", \"key\", \"value\"}, cmd.getOptionValues('j'));\n\n        assertTrue(cmd.hasOption(\"k\"), \"Option k is not set\");\n        assertTrue(cmd.hasOption('k'), \"Option k is not set\");\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues(\"k\"));\n        assertArrayEquals(new String[] {\"key1\", \"value1\", \"key2\", \"value2\"}, cmd.getOptionValues('k'));\n\n        assertTrue(cmd.hasOption(\"m\"), \"Option m is not set\");\n        assertTrue(cmd.hasOption('m'), \"Option m is not set\");\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues(\"m\"));\n        assertArrayEquals(new String[] {\"key\", \"value\"}, cmd.getOptionValues('m'));\n    }\n\n    @Test\n    public void testComplexValues() {\n        assertTrue(cmd.hasOption(\"i\"), \"Option i is not set\");\n        assertTrue(cmd.hasOption(\"h\"), \"Option h is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"h\"));\n    }\n\n    @Test\n    public void testExtraArgs() {\n        assertArrayEquals(new String[] {\"arg1\", \"arg2\", \"arg3\"}, cmd.getArgs(), \"Extra args\");\n    }\n\n    @Test\n    public void testMultipleArgValues() {\n        assertTrue(cmd.hasOption(\"e\"), \"Option e is not set\");\n        assertArrayEquals(new String[] {\"one\", \"two\"}, cmd.getOptionValues(\"e\"));\n    }\n\n    @Test\n    public void testShortArgs() {\n        assertTrue(cmd.hasOption(\"a\"), \"Option a is not set\");\n        assertTrue(cmd.hasOption(\"c\"), \"Option c is not set\");\n\n        assertNull(cmd.getOptionValues(\"a\"));\n        assertNull(cmd.getOptionValues(\"c\"));\n    }\n\n    @Test\n    public void testShortArgsWithValue() {\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"foo\", cmd.getOptionValue(\"b\"));\n        assertEquals(1, cmd.getOptionValues(\"b\").length);\n\n        assertTrue(cmd.hasOption(\"b\"), \"Option b is not set\");\n        assertEquals(\"bar\", cmd.getOptionValue(\"d\"));\n        assertEquals(1, cmd.getOptionValues(\"d\").length);\n    }\n\n    @Test\n    public void testTwoArgValues() {\n        assertTrue(cmd.hasOption(\"g\"), \"Option g is not set\");\n        assertArrayEquals(new String[] {\"val1\", \"val2\"}, cmd.getOptionValues(\"g\"));\n    }\n\n    /**\n     * jkeyes - commented out this test as the new architecture breaks this type of functionality. I have left the test here\n     * in case I get a brainwave on how to resolve this.\n     */\n    /*\n     * public void testGetValue() { // the 'm' option assertTrue(_option.getValues().length == 2); assertEquals(\n     * _option.getValue(), \"key\"); assertEquals(_option.getValue(0), \"key\"); assertEquals(_option.getValue(1),\n     * \"value\");\n     *\n     * try { assertEquals(_option.getValue(2), \"key\"); fail(\"IndexOutOfBounds not caught\"); } catch (\n     * IndexOutOfBoundsException exp) {\n     *\n     * }\n     *\n     * try { assertEquals(_option.getValue(-1), \"key\"); fail(\"IndexOutOfBounds not caught\"); } catch (\n     * IndexOutOfBoundsException exp) {\n     *\n     * } }\n     */\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CommandLine cmd;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CommandLine", "name": "cmd", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI148Test.java.BugCLI148Test", "name": "BugCLI148Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI148Test.java", "superclasses": "", "methods": ["[void]testWorkaround1()", "[void]testWorkaround2()"], "method_uris": ["src/test/java/org/apache/commons/cli/bug/BugCLI148Test.java.BugCLI148Test.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nhttps://issues.apache.org/jira/browse/CLI-148\n", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI148Test {\n    private Options options;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('t'));\n        options.addOption(OptionBuilder.hasArg().create('s'));\n    }\n\n    @Test\n    public void testWorkaround1() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t-something\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }\n\n    @Test\n    public void testWorkaround2() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-t\", \"\\\"-something\\\"\"};\n\n        final CommandLine commandLine = parser.parse(options, args);\n        assertEquals(\"-something\", commandLine.getOptionValue('t'));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI13Test.java.BugCLI13Test", "name": "BugCLI13Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI13Test.java", "superclasses": "", "methods": ["[void]testCLI13()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI13Test {\n\n    @Test\n    public void testCLI13() throws ParseException {\n        final String debugOpt = \"debug\";\n        @SuppressWarnings(\"static-access\")\n        //@formatter:off\n        final Option debug = OptionBuilder\n            .withArgName(debugOpt)\n            .withDescription(\"turn on debugging\")\n            .withLongOpt(debugOpt)\n            .hasArg()\n            .create('d');\n        //@formatter:on\n        final Options options = new Options();\n        options.addOption(debug);\n        final CommandLine commandLine = new PosixParser().parse(options, new String[] {\"-d\", \"true\"});\n\n        assertEquals(\"true\", commandLine.getOptionValue(debugOpt));\n        assertEquals(\"true\", commandLine.getOptionValue('d'));\n        assertTrue(commandLine.hasOption('d'));\n        assertTrue(commandLine.hasOption(debugOpt));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI266Test.java.BugCLI266Test", "name": "BugCLI266Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI266Test.java", "superclasses": "", "methods": ["[void]testOptionComparatorDefaultOrder()", "[void]testOptionComparatorInsertedOrder()"], "method_uris": ["src/test/java/org/apache/commons/cli/bug/BugCLI266Test.java.BugCLI266Test.[void]buildOptionsGroup(Options)", "src/test/java/org/apache/commons/cli/bug/BugCLI266Test.java.BugCLI266Test.[Options]getOptions()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BugCLI266Test {\n\n    private final List<String> insertedOrder = Arrays.asList(\"h\", \"d\", \"f\", \"x\", \"s\", \"p\", \"t\", \"w\", \"o\");\n    private final List<String> sortOrder = Arrays.asList(\"d\", \"f\", \"h\", \"o\", \"p\", \"s\", \"t\", \"w\", \"x\");\n\n    private void buildOptionsGroup(final Options options) {\n        final OptionGroup firstGroup = new OptionGroup();\n        final OptionGroup secondGroup = new OptionGroup();\n        firstGroup.setRequired(true);\n        secondGroup.setRequired(true);\n\n        //@formatter:off\n        firstGroup.addOption(Option.builder(\"d\")\n                .longOpt(\"db\")\n                .hasArg()\n                .argName(\"table-name\")\n                .build());\n        firstGroup.addOption(Option.builder(\"f\")\n                .longOpt(\"flat-file\")\n                .hasArg()\n                .argName(\"input.csv\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(firstGroup);\n        //@formatter:off\n        secondGroup.addOption(Option.builder(\"x\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        secondGroup.addOption(Option.builder(\"s\")\n                .build());\n        secondGroup.addOption(Option.builder(\"p\")\n                .hasArg()\n                .argName(\"arg1\")\n                .build());\n        //@formatter:on\n        options.addOptionGroup(secondGroup);\n    }\n\n    private Options getOptions() {\n        final Options options = new Options();\n        //@formatter:off\n        final Option help = Option.builder(\"h\")\n                .longOpt(\"help\")\n                .desc(\"Prints this help message\")\n                .build();\n        //@formatter:on\n        options.addOption(help);\n\n        buildOptionsGroup(options);\n\n        //@formatter:off\n        final Option t = Option.builder(\"t\")\n                .required()\n                .hasArg()\n                .argName(\"file\")\n                .build();\n        final Option w = Option.builder(\"w\")\n                .required()\n                .hasArg()\n                .argName(\"word\")\n                .build();\n        final Option o = Option.builder(\"o\")\n                .hasArg()\n                .argName(\"directory\")\n                .build();\n        //@formatter:on\n        options.addOption(t);\n        options.addOption(w);\n        options.addOption(o);\n        return options;\n    }\n\n    @Test\n    public void testOptionComparatorDefaultOrder() {\n        final HelpFormatter formatter = new HelpFormatter();\n        final List<Option> options = new ArrayList<>(getOptions().getOptions());\n        Collections.sort(options, formatter.getOptionComparator());\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), sortOrder.get(i));\n            i++;\n        }\n    }\n\n    @Test\n    public void testOptionComparatorInsertedOrder() {\n        final Collection<Option> options = getOptions().getOptions();\n        int i = 0;\n        for (final Option o : options) {\n            assertEquals(o.getOpt(), insertedOrder.get(i));\n            i++;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<String> insertedOrder = Arrays.asList(\"h\", \"d\", \"f\", \"x\", \"s\", \"p\", \"t\", \"w\", \"o\");", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "insertedOrder = Arrays.asList(\"h\", \"d\", \"f\", \"x\", \"s\", \"p\", \"t\", \"w\", \"o\")", "syntax_pass": true}, {"attribute_expression": "private final List<String> sortOrder = Arrays.asList(\"d\", \"f\", \"h\", \"o\", \"p\", \"s\", \"t\", \"w\", \"x\");", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "sortOrder = Arrays.asList(\"d\", \"f\", \"h\", \"o\", \"p\", \"s\", \"t\", \"w\", \"x\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugsTest.java.BugsTest", "name": "BugsTest", "file_path": "src/test/java/org/apache/commons/cli/bug/BugsTest.java", "superclasses": "", "methods": ["[void]test11456()", "[void]test11457()", "[void]test11458()", "[void]test11680()", "[void]test12210()", "[void]test13425()", "[void]test13666()", "[void]test13666_Builder()", "[void]test13935()", "[void]test14786()", "[void]test15046()", "[void]test15648()", "[void]test31148()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugsTest {\n    @Test\n    public void test11456() throws Exception {\n        // POSIX\n        Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        String[] args = {\"-a\", \"-bvalue\"};\n\n        CommandLineParser parser = new PosixParser();\n\n        CommandLine cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n\n        // GNU\n        options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArg().create('a'));\n        options.addOption(OptionBuilder.hasArg().create('b'));\n        args = new String[] {\"-a\", \"-b\", \"value\"};\n\n        parser = new GnuParser();\n\n        cmd = parser.parse(options, args);\n        assertEquals(cmd.getOptionValue('b'), \"value\");\n    }\n\n    @Test\n    public void test11457() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n        final String[] args = {\"--verbose\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n        assertTrue(cmd.hasOption(\"verbose\"));\n    }\n\n    @Test\n    public void test11458() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator('=').hasArgs().create('D'));\n        options.addOption(OptionBuilder.withValueSeparator(':').hasArgs().create('p'));\n        final String[] args = {\"-DJAVA_HOME=/opt/java\", \"-pfile1:file2:file3\"};\n\n        final CommandLineParser parser = new PosixParser();\n\n        final CommandLine cmd = parser.parse(options, args);\n\n        String[] values = cmd.getOptionValues('D');\n\n        assertEquals(values[0], \"JAVA_HOME\");\n        assertEquals(values[1], \"/opt/java\");\n\n        values = cmd.getOptionValues('p');\n\n        assertEquals(values[0], \"file1\");\n        assertEquals(values[1], \"file2\");\n        assertEquals(values[2], \"file3\");\n\n        final Iterator<Option> iter = cmd.iterator();\n        while (iter.hasNext()) {\n            final Option opt = iter.next();\n            switch (opt.getId()) {\n            case 'D':\n                assertEquals(opt.getValue(0), \"JAVA_HOME\");\n                assertEquals(opt.getValue(1), \"/opt/java\");\n                break;\n            case 'p':\n                assertEquals(opt.getValue(0), \"file1\");\n                assertEquals(opt.getValue(1), \"file2\");\n                assertEquals(opt.getValue(2), \"file3\");\n                break;\n            default:\n                fail(\"-D option not found\");\n            }\n        }\n    }\n\n    @Test\n    public void test11680() throws Exception {\n        final Options options = new Options();\n        final Option optionF = options.addOption(\"f\", true, \"foobar\").getOption(\"f\");\n        final Option optionM = options.addOption(\"m\", true, \"missing\").getOption(\"m\");\n        final String[] args = { \"-f\", \"foo\" };\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine cmd = parser.parse(options, args);\n        // 1.7.0 API:\n        cmd.getOptionValue(optionF, () -> \"default f\");\n        cmd.getOptionValue(optionM, () -> \"default m\");\n        // 1.7.0 API:\n        cmd.getOptionValue('f', () -> \"default f\");\n        cmd.getOptionValue('m', () -> \"default m\");\n        // 1.5.0 API:\n        cmd.getOptionValue(optionF, \"default f\");\n        cmd.getOptionValue(optionM, \"default m\");\n        // Original API:\n        cmd.getOptionValue(\"f\", \"default f\");\n        cmd.getOptionValue(\"m\", \"default m\");\n        //\n        assertNull(cmd.getOptionValue((String) null, (String) null));\n        assertEquals(\"default\", cmd.getOptionValue((String) null, \"default\"));\n    }\n\n    @Test\n    public void test12210() throws Exception {\n        // create the main options object which will handle the first parameter\n        final Options mainOptions = new Options();\n        // There can be 2 main exclusive options: -exec|-rep\n\n        // Therefore, place them in an option group\n\n        String[] argv = {\"-exec\", \"-exec_opt1\", \"-exec_opt2\"};\n        final OptionGroup grp = new OptionGroup();\n\n        grp.addOption(new Option(\"exec\", false, \"description for this option\"));\n\n        grp.addOption(new Option(\"rep\", false, \"description for this option\"));\n\n        mainOptions.addOptionGroup(grp);\n\n        // for the exec option, there are 2 options...\n        final Options execOptions = new Options();\n        execOptions.addOption(\"exec_opt1\", false, \" desc\");\n        execOptions.addOption(\"exec_opt2\", false, \" desc\");\n\n        // similarly, for rep there are 2 options...\n        final Options repOptions = new Options();\n        repOptions.addOption(\"repopto\", false, \"desc\");\n        repOptions.addOption(\"repoptt\", false, \"desc\");\n\n        // create the parser\n        final GnuParser parser = new GnuParser();\n\n        // finally, parse the arguments:\n\n        // first parse the main options to see what the user has specified\n        // We set stopAtNonOption to true so it does not touch the remaining\n        // options\n        CommandLine cmd = parser.parse(mainOptions, argv, true);\n        // get the remaining options...\n        argv = cmd.getArgs();\n\n        if (cmd.hasOption(\"exec\")) {\n            cmd = parser.parse(execOptions, argv, false);\n            // process the exec_op1 and exec_opt2...\n            assertTrue(cmd.hasOption(\"exec_opt1\"));\n            assertTrue(cmd.hasOption(\"exec_opt2\"));\n        } else if (cmd.hasOption(\"rep\")) {\n            cmd = parser.parse(repOptions, argv, false);\n            // process the rep_op1 and rep_opt2...\n        } else {\n            fail(\"exec option not found\");\n        }\n    }\n\n    @Test\n    public void test13425() throws Exception {\n        final Options options = new Options();\n        //@formatter:off\n        final Option oldpass = OptionBuilder.withLongOpt(\"old-password\")\n            .withDescription(\"Use this option to specify the old password\")\n            .hasArg()\n            .create('o');\n        final Option newpass = OptionBuilder.withLongOpt(\"new-password\")\n            .withDescription(\"Use this option to specify the new password\")\n            .hasArg()\n            .create('n');\n        //@formatter:on\n\n        final String[] args = {\"-o\", \"-n\", \"newpassword\"};\n\n        options.addOption(oldpass);\n        options.addOption(newpass);\n\n        final Parser parser = new PosixParser();\n\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException not caught.\");\n        } catch (final MissingArgumentException expected) {\n        }\n    }\n\n    @Test\n    public void test13666() throws Exception {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final PrintStream oldSystemOut = System.out;\n        try {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final String eol = System.lineSeparator();\n            System.setOut(new PrintStream(baos));\n            final HelpFormatter formatter = new HelpFormatter();\n            formatter.printHelp(\"dir\", options);\n            assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n        } finally {\n            System.setOut(oldSystemOut);\n        }\n    }\n\n    @Test\n    public void test13666_Builder() throws Exception {\n        final Options options = new Options();\n        final Option dirOption = OptionBuilder.withDescription(\"dir\").hasArg().create('d');\n        options.addOption(dirOption);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final String eol = System.lineSeparator();\n        final HelpFormatter formatter = HelpFormatter.builder().setPrintWriter(new PrintWriter(baos)).get();\n        formatter.printHelp(\"dir\", options);\n        assertEquals(\"usage: dir\" + eol + \" -d <arg>   dir\" + eol, baos.toString());\n    }\n\n    @Test\n    public void test13935() throws Exception {\n        final OptionGroup directions = new OptionGroup();\n\n        final Option left = new Option(\"l\", \"left\", false, \"go left\");\n        final Option right = new Option(\"r\", \"right\", false, \"go right\");\n        final Option straight = new Option(\"s\", \"straight\", false, \"go straight\");\n        final Option forward = new Option(\"f\", \"forward\", false, \"go forward\");\n        forward.setRequired(true);\n\n        directions.addOption(left);\n        directions.addOption(right);\n        directions.setRequired(true);\n\n        final Options opts = new Options();\n        opts.addOptionGroup(directions);\n        opts.addOption(straight);\n\n        final CommandLineParser parser = new PosixParser();\n\n        String[] args = {};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\"};\n        try {\n            parser.parse(opts, args);\n            fail(\"Expected ParseException\");\n        } catch (final ParseException expected) {\n        }\n\n        args = new String[] {\"-s\", \"-l\"};\n        CommandLine line = parser.parse(opts, args);\n        assertNotNull(line);\n\n        opts.addOption(forward);\n        args = new String[] {\"-s\", \"-l\", \"-f\"};\n        line = parser.parse(opts, args);\n        assertNotNull(line);\n    }\n\n    @Test\n    public void test14786() throws Exception {\n        final Option o = OptionBuilder.isRequired().withDescription(\"test\").create(\"test\");\n        final Options opts = new Options();\n        opts.addOption(o);\n        opts.addOption(o);\n\n        final CommandLineParser parser = new GnuParser();\n\n        final String[] args = {\"-test\"};\n\n        final CommandLine line = parser.parse(opts, args);\n        assertTrue(line.hasOption(\"test\"));\n    }\n\n    @Test\n    public void test15046() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] cliArgs = {\"-z\", \"c\"};\n\n        final Options options = new Options();\n        options.addOption(new Option(\"z\", \"timezone\", true, \"affected option\"));\n\n        parser.parse(options, cliArgs);\n\n        // now add conflicting option\n        options.addOption(\"c\", \"conflict\", true, \"conflict option\");\n        final CommandLine line = parser.parse(options, cliArgs);\n        assertEquals(line.getOptionValue('z'), \"c\");\n        assertFalse(line.hasOption(\"c\"));\n    }\n\n    @Test\n    public void test15648() throws Exception {\n        final CommandLineParser parser = new PosixParser();\n        final String[] args = {\"-m\", \"\\\"Two Words\\\"\"};\n        final Option m = OptionBuilder.hasArgs().create(\"m\");\n        final Options options = new Options();\n        options.addOption(m);\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Two Words\", line.getOptionValue(\"m\"));\n    }\n\n    @Test\n    public void test31148() throws ParseException {\n        final Option multiArgOption = new Option(\"o\", \"option with multiple args\");\n        multiArgOption.setArgs(1);\n\n        final Options options = new Options();\n        options.addOption(multiArgOption);\n\n        final Parser parser = new PosixParser();\n        final String[] args = {};\n        final Properties props = new Properties();\n        props.setProperty(\"o\", \"ovalue\");\n        final CommandLine cl = parser.parse(options, args, props);\n\n        assertTrue(cl.hasOption('o'));\n        assertEquals(\"ovalue\", cl.getOptionValue('o'));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI71Test.java.BugCLI71Test", "name": "BugCLI71Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI71Test.java", "superclasses": "", "methods": ["[void]testBasic()", "[void]testGetsDefaultIfOptional()", "[void]testLackOfError()", "[void]testMistakenArgument()"], "method_uris": ["src/test/java/org/apache/commons/cli/bug/BugCLI71Test.java.BugCLI71Test.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI71Test {\n    private Options options;\n    private CommandLineParser parser;\n\n    @BeforeEach\n    public void setUp() {\n        options = new Options();\n\n        final Option algorithm = new Option(\"a\", \"algo\", true, \"the algorithm which it to perform executing\");\n        algorithm.setArgName(\"algorithm name\");\n        options.addOption(algorithm);\n\n        final Option key = new Option(\"k\", \"key\", true, \"the key the setted algorithm uses to process\");\n        algorithm.setArgName(\"value\");\n        options.addOption(key);\n\n        parser = new PosixParser();\n    }\n\n    @Test\n    public void testBasic() throws Exception {\n        final String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        final CommandLine line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"A\", line.getOptionValue(\"k\"));\n    }\n\n    @Test\n    public void testGetsDefaultIfOptional() throws Exception {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        options.getOption(\"k\").setOptionalArg(true);\n        final CommandLine line = parser.parse(options, args);\n\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue('k', \"a\"));\n    }\n\n    @Test\n    public void testLackOfError() throws Exception {\n        final String[] args = {\"-k\", \"-a\", \"Caesar\"};\n        try {\n            parser.parse(options, args);\n            fail(\"MissingArgumentException expected\");\n        } catch (final MissingArgumentException e) {\n            assertEquals(\"k\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n    }\n\n    @Test\n    public void testMistakenArgument() throws Exception {\n        String[] args = {\"-a\", \"Caesar\", \"-k\", \"A\"};\n        CommandLine line = parser.parse(options, args);\n        args = new String[] {\"-a\", \"Caesar\", \"-k\", \"a\"};\n        line = parser.parse(options, args);\n        assertEquals(\"Caesar\", line.getOptionValue(\"a\"));\n        assertEquals(\"a\", line.getOptionValue(\"k\"));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "private CommandLineParser parser;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CommandLineParser", "name": "parser", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI325Test.java.BugCLI325Test", "name": "BugCLI325Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI325Test.java", "superclasses": "", "methods": ["[void]testCli325()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BugCLI325Test {\n\n    @Test\n    public void testCli325() throws ParseException {\n        // @formatter:off\n        final Option option = Option.builder(\"x\")\n                .hasArgs()\n                .valueSeparator()\n                .desc(\"Multiple arg option with value separator.\")\n                .build();\n        // @formatter:on\n        final String[] args = {\"-x\", \"A=a\", \"B=b\"};\n        final CommandLine cmdLine = DefaultParser.builder().build().parse(new Options().addOption(option), args);\n        final Properties props = cmdLine.getOptionProperties(option);\n        assertEquals(2, props.size());\n        assertEquals(\"a\", props.get(\"A\"));\n        assertEquals(\"b\", props.get(\"B\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI265Test.java.BugCLI265Test", "name": "BugCLI265Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI265Test.java", "superclasses": "", "methods": ["[void]testShouldParseConcatenatedShortOptions()", "[void]testShouldParseShortOptionWithoutValue()", "[void]testShouldParseShortOptionWithValue()"], "method_uris": ["src/test/java/org/apache/commons/cli/bug/BugCLI265Test.java.BugCLI265Test.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest for CLI-265.\n<p>\nThe issue is that a short option with an optional value will use whatever comes next as value.\n", "original_string": "public class BugCLI265Test {\n\n    private DefaultParser parser;\n    private Options options;\n\n    @BeforeEach\n    public void setUp() {\n        parser = new DefaultParser();\n\n        final Option optionT1 = Option.builder(\"t1\").hasArg().numberOfArgs(1).optionalArg(true).argName(\"t1_path\").build();\n        final Option optionA = Option.builder(\"a\").hasArg(false).build();\n        final Option optionB = Option.builder(\"b\").hasArg(false).build();\n        final Option optionLast = Option.builder(\"last\").hasArg(false).build();\n\n        options = new Options().addOption(optionT1).addOption(optionA).addOption(optionB).addOption(optionLast);\n    }\n\n    @Test\n    public void testShouldParseConcatenatedShortOptions() throws Exception {\n        final String[] concatenatedShortOptions = {\"-t1\", \"-ab\"};\n\n        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNull(commandLine.getOptionValue(\"t1\"));\n        assertTrue(commandLine.hasOption(\"a\"));\n        assertTrue(commandLine.hasOption(\"b\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }\n\n    @Test\n    public void testShouldParseShortOptionWithoutValue() throws Exception {\n        final String[] twoShortOptions = {\"-t1\", \"-last\"};\n\n        final CommandLine commandLine = parser.parse(options, twoShortOptions);\n\n        assertTrue(commandLine.hasOption(\"t1\"));\n        assertNotEquals(commandLine.getOptionValue(\"t1\"), \"Second option has been used as value for first option\", \"-last\");\n        assertTrue(commandLine.hasOption(\"last\"), \"Second option has not been detected\");\n    }\n\n    @Test\n    public void testShouldParseShortOptionWithValue() throws Exception {\n        final String[] shortOptionWithValue = {\"-t1\", \"path/to/my/db\"};\n\n        final CommandLine commandLine = parser.parse(options, shortOptionWithValue);\n\n        assertEquals(\"path/to/my/db\", commandLine.getOptionValue(\"t1\"));\n        assertFalse(commandLine.hasOption(\"last\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DefaultParser parser;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DefaultParser", "name": "parser", "syntax_pass": true}, {"attribute_expression": "private Options options;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI133Test.java.BugCLI133Test", "name": "BugCLI133Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI133Test.java", "superclasses": "", "methods": ["[void]testOrder()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@SuppressWarnings(\"deprecation\") // tests some deprecated classes\npublic class BugCLI133Test {\n    @Test\n    public void testOrder() throws ParseException {\n        final Option optionA = new Option(\"a\", \"first\");\n        final Options opts = new Options();\n        opts.addOption(optionA);\n        final PosixParser posixParser = new PosixParser();\n        final CommandLine line = posixParser.parse(opts, null);\n        assertFalse(line.hasOption((String) null));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI162Test.java.BugCLI162Test", "name": "BugCLI162Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI162Test.java", "superclasses": "", "methods": ["[void]testInfiniteLoop()", "[void]testLongLineChunking()", "[void]testLongLineChunkingIndentIgnored()", "[void]testPrintHelpLongLines()"], "method_uris": ["src/test/java/org/apache/commons/cli/bug/BugCLI162Test.java.BugCLI162Test.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BugCLI162Test {\n    /** Constant for the line separator. */\n    private static final String CR = System.lineSeparator();\n\n    // Constants used for options\n    private static final String OPT = \"-\";\n\n    private static final String OPT_COLUMN_NAMES = \"l\";\n\n    private static final String OPT_CONNECTION = \"c\";\n\n    private static final String OPT_DESCRIPTION = \"e\";\n\n    private static final String OPT_DRIVER = \"d\";\n\n    private static final String OPT_DRIVER_INFO = \"n\";\n\n    private static final String OPT_FILE_BINDING = \"b\";\n\n    private static final String OPT_FILE_JDBC = \"j\";\n\n    private static final String OPT_FILE_SFMD = \"f\";\n\n    private static final String OPT_HELP = \"h\";\n\n    private static final String OPT_HELP_LONG = \"help\";\n\n    private static final String OPT_INTERACTIVE = \"i\";\n\n    private static final String OPT_JDBC_TO_SFMD = \"2\";\n\n    private static final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";\n\n    private static final String OPT_METADATA = \"m\";\n\n    private static final String OPT_PARAM_MODES_INT = \"o\";\n\n    private static final String OPT_PARAM_MODES_NAME = \"O\";\n\n    private static final String OPT_PARAM_NAMES = \"a\";\n\n    private static final String OPT_PARAM_TYPES_INT = \"y\";\n\n    private static final String OPT_PARAM_TYPES_NAME = \"Y\";\n\n    private static final String OPT_PASSWORD = \"p\";\n\n    private static final String OPT_PASSWORD_L = \"password\";\n\n    private static final String OPT_SQL = \"s\";\n\n    private static final String OPT_SQL_L = \"sql\";\n\n    private static final String OPT_STACK_TRACE = \"t\";\n\n    private static final String OPT_TIMING = \"g\";\n\n    private static final String OPT_TRIM_L = \"trim\";\n\n    private static final String OPT_USER = \"u\";\n\n    private static final String OPT_WRITE_TO_FILE = \"w\";\n\n    private static final String PMODE_IN = \"IN\";\n\n    private static final String PMODE_INOUT = \"INOUT\";\n\n    private static final String PMODE_OUT = \"OUT\";\n\n    private static final String PMODE_UNK = \"Unknown\";\n\n    private static final String PMODES = PMODE_IN + \", \" + PMODE_INOUT + \", \" + PMODE_OUT + \", \" + PMODE_UNK;\n\n    // @formatter:off\n    private static final String EXPECTED = \"usage: org.apache.commons.cli.bug.BugCLI162Test\" + CR +\n            \" -2,--jdbc2sfmd <arg>        Converts the JDBC file in the first argument\" + CR +\n            \"                             to an SMFD file specified in the second\" + CR +\n            \"                             argument.\" + CR +\n            \" -a,--paramNames <arg>       Parameter XML names; default names are\" + CR +\n            \"                             param1, param2, etc. Example: -a \\\"pname1\" + CR +\n            \"                             pname2\\\"\" + CR +\n            \" -b,--jdbc <arg>             Writes a JDBC binding node file for the given\" + CR +\n            \"                             SQL\" + CR +\n            \" -c,--url <arg>              Connection URL\" + CR +\n            \" -d,--driver <arg>           JDBC driver class name\" + CR +\n            \" -e,--description <arg>      SFMD description. A default description is\" + CR +\n            \"                             used if omited. Example: -e \\\"Runs such and\" + CR +\n            \"                             such\\\"\" + CR +\n            \" -f,--sfmd <arg>             Writes a SFMD file for the given SQL\" + CR +\n            \" -g,--printTiming            Prints timing information\" + CR +\n            \" -h,--help                   Prints help and quits\" + CR +\n            \" -i,--interactive            Runs in interactive mode, reading and writing\" + CR +\n            \"                             from the console, 'go' or '/' sends a\" + CR +\n            \"                             statement\" + CR +\n            \" -j,--node <arg>             Writes a JDBC node file for the given SQL\" + CR +\n            \"                             (internal debugging)\" + CR +\n            \" -l,--columnNames <arg>      Column XML names; default names column\" + CR +\n            \"                             labels. Example: -l \\\"cname1 cname2\\\"\" + CR +\n            \" -m,--printMetaData          Prints metadata information\" + CR +\n            \" -n,--info                   Prints driver information and properties. If\" + CR +\n            \"                             -c is not specified, all drivers on the\" + CR +\n            \"                             classpath are displayed.\" + CR +\n            \" -o,--paramModes <arg>       Parameters modes (1=IN, 2=INOUT, 4=OUT,\" + CR +\n            \"                             0=Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -o \\\"4\" + CR +\n            \"                             1\\\"\" + CR +\n            \" -O,--paramModeNames <arg>   Parameters mode names (IN, INOUT, OUT,\" + CR +\n            \"                             Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -O \\\"OUT\" + CR +\n            \"                             IN\\\"\" + CR +\n            \" -p,--password <arg>         The database password for the user specified\" + CR +\n            \"                             with the -u option. You can obfuscate the\" + CR +\n            \"                             password with\" + CR +\n            \"                             org.mortbay.jetty.security.Password, see\" + CR +\n            \"                             https://docs.codehaus.org/display/JETTY/Secur\" + CR +\n            \"                             ing+Passwords\" + CR +\n            \" -s,--sql <arg>              Runs SQL or {call stored_procedure(?, ?)} or\" + CR +\n            \"                             {?=call function(?, ?)}\" + CR +\n            \" -t,--printStack             Prints stack traces on errors\" + CR +\n            \"    --trim <arg>             Trims leading and trailing spaces from all\" + CR +\n            \"                             column values. Column XML names can be\" + CR +\n            \"                             optionally specified to set which columns to\" + CR +\n            \"                             trim.\" + CR +\n            \" -u,--user <arg>             A database user name\" + CR +\n            \" -w,--outfile <arg>          Writes the SQL output to the given file\" + CR +\n            \" -y,--paramTypes <arg>       Parameter types from java.sql.Types. -y and\" + CR +\n            \"                             -Y are mutually exclusive. Example: -y \\\"-10\" + CR +\n            \"                             12\\\"\" + CR +\n            \" -Y,--paramTypeNames <arg>   Parameter java.sql.Types names. -y and -Y are\" + CR +\n            \"                             mutually exclusive. Example: -Y \\\"CURSOR\" + CR +\n            \"                             VARCHAR\\\"\" + CR;\n    // @formatter:on\n\n    private HelpFormatter formatter;\n\n    private StringWriter sw;\n\n    @BeforeEach\n    public void setUp() {\n        formatter = new HelpFormatter();\n        sw = new StringWriter();\n    }\n\n    @Test\n    public void testInfiniteLoop() {\n        final Options options = new Options();\n        options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n        // used to hang & crash\n        formatter.printHelp(new PrintWriter(sw), 20, \"app\", null, options, HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n\n        //@formatter:off\n        final String expected = \"usage: app\" + CR +\n                \" -h,--help   This is\" + CR +\n                \"             a\" + CR +\n                \"             looooon\" + CR +\n                \"             g\" + CR +\n                \"             descrip\" + CR +\n                \"             tion\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString());\n    }\n\n    @Test\n    public void testLongLineChunking() {\n        final Options options = new Options();\n        //@formatter:off\n        options.addOption(\"x\", \"extralongarg\", false,\n                          \"This description has ReallyLongValuesThatAreLongerThanTheWidthOfTheColumns \" +\n                          \"and also other ReallyLongValuesThatAreHugerAndBiggerThanTheWidthOfTheColumnsBob, \" +\n                          \"yes. \");\n        //@formatter:on\n        formatter.printHelp(new PrintWriter(sw), 35, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.commons.cli.bug.B\" + CR +\n                          \"       ugCLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg     This\" + CR +\n                          \"                      description\" + CR +\n                          \"                      has\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreLon\" + CR +\n                          \"                      gerThanTheWid\" + CR +\n                          \"                      thOfTheColumn\" + CR +\n                          \"                      s and also\" + CR +\n                          \"                      other\" + CR +\n                          \"                      ReallyLongVal\" + CR +\n                          \"                      uesThatAreHug\" + CR +\n                          \"                      erAndBiggerTh\" + CR +\n                          \"                      anTheWidthOfT\" + CR +\n                          \"                      heColumnsBob,\" + CR +\n                          \"                      yes.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }\n\n    @Test\n    public void testLongLineChunkingIndentIgnored() {\n        final Options options = new Options();\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\");\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        //@formatter:off\n        final String expected = \"usage:\" + CR +\n                          \"       org.apache.comm\" + CR +\n                          \"       ons.cli.bug.Bug\" + CR +\n                          \"       CLI162Test\" + CR +\n                          \"Header\" + CR +\n                          \"-x,--extralongarg\" + CR +\n                          \" This description is\" + CR +\n                          \" Long.\" + CR +\n                          \"Footer\" + CR;\n        //@formatter:on\n        assertEquals(expected, sw.toString(), \"Long arguments did not split as expected\");\n    }\n\n    @Test\n    public void testPrintHelpLongLines() {\n        // Options build\n        final Options commandLineOptions;\n        commandLineOptions = new Options();\n        commandLineOptions.addOption(OPT_HELP, OPT_HELP_LONG, false, \"Prints help and quits\");\n        commandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\n        //@formatter:off\n        commandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n            + OPT\n            + OPT_CONNECTION\n            + \" is not specified, all drivers on the classpath are displayed.\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\n        commandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\n        //@formatter:off\n        commandLineOptions\n                .addOption(\n                        OPT_PASSWORD,\n                        OPT_PASSWORD_L,\n                        true,\n                        \"The database password for the user specified with the \"\n                            + OPT\n                            + OPT_USER\n                            + \" option. You can obfuscate the password with org.mortbay.jetty.security.Password,\"\n                            + \" see https://docs.codehaus.org/display/JETTY/Securing+Passwords\");\n        //@formatter:on\n        commandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\n        commandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\n        commandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\n        commandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\n        commandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n            \"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\n        commandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n            \"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\n        commandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\n        commandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\n        commandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\n        //@formatter:off\n        Option option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n            + OPT\n            + OPT_COLUMN_NAMES\n            + \" \\\"cname1 cname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n            + OPT\n            + OPT_PARAM_NAMES\n            + \" \\\"pname1 pname2\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //\n        final OptionGroup pOutTypesOptionGroup = new OptionGroup();\n        final String pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\n        final String typesClassName = Types.class.getName();\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n            + typesClassName\n            + \". \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_INT\n            + \" \\\"-10 12\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n            + typesClassName\n            + \" names. \"\n            + pOutTypesOptionGroupDoc\n            + \" Example: \"\n            + OPT\n            + OPT_PARAM_TYPES_NAME\n            + \" \\\"CURSOR VARCHAR\\\"\");\n        //@formatter:on\n        commandLineOptions.addOption(option);\n        commandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n        //\n        final OptionGroup modesOptionGroup = new OptionGroup();\n        final String modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n            + ParameterMetaData.parameterModeIn\n            + \"=IN, \"\n            + ParameterMetaData.parameterModeInOut\n            + \"=INOUT, \"\n            + ParameterMetaData.parameterModeOut\n            + \"=OUT, \"\n            + ParameterMetaData.parameterModeUnknown\n            + \"=Unknown\"\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_INT\n            + \" \\\"\"\n            + ParameterMetaData.parameterModeOut\n            + \" \"\n            + ParameterMetaData.parameterModeIn\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        //@formatter:off\n        option = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n            + PMODES\n            + \"). \"\n            + modesOptionGroupDoc\n            + \" Example for 2 parameters, OUT and IN: \"\n            + OPT\n            + OPT_PARAM_MODES_NAME\n            + \" \\\"\"\n            + PMODE_OUT\n            + \" \"\n            + PMODE_IN\n            + \"\\\"\");\n        //@formatter:on\n        modesOptionGroup.addOption(option);\n        commandLineOptions.addOptionGroup(modesOptionGroup);\n        option = new Option(null, OPT_TRIM_L, true,\n            \"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\n        option.setOptionalArg(true);\n        commandLineOptions.addOption(option);\n        option = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n            \"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\n        option.setArgs(2);\n        commandLineOptions.addOption(option);\n\n        formatter.printHelp(new PrintWriter(sw), HelpFormatter.DEFAULT_WIDTH, this.getClass().getName(), null, commandLineOptions,\n            HelpFormatter.DEFAULT_LEFT_PAD, HelpFormatter.DEFAULT_DESC_PAD, null);\n        //@formatter:on\n        assertEquals(EXPECTED, sw.toString());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String CR = System.lineSeparator();", "docstring": " Constant for the line separator.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CR = System.lineSeparator()", "syntax_pass": true}, {"attribute_expression": "private static final String OPT = \"-\";", "docstring": " Constants used for options", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT = \"-\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_COLUMN_NAMES = \"l\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_COLUMN_NAMES = \"l\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_CONNECTION = \"c\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_CONNECTION = \"c\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_DESCRIPTION = \"e\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_DESCRIPTION = \"e\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_DRIVER = \"d\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_DRIVER = \"d\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_DRIVER_INFO = \"n\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_DRIVER_INFO = \"n\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_FILE_BINDING = \"b\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_FILE_BINDING = \"b\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_FILE_JDBC = \"j\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_FILE_JDBC = \"j\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_FILE_SFMD = \"f\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_FILE_SFMD = \"f\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_HELP = \"h\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_HELP = \"h\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_HELP_LONG = \"help\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_HELP_LONG = \"help\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_INTERACTIVE = \"i\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_INTERACTIVE = \"i\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_JDBC_TO_SFMD = \"2\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_JDBC_TO_SFMD = \"2\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_METADATA = \"m\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_METADATA = \"m\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_MODES_INT = \"o\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_MODES_INT = \"o\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_MODES_NAME = \"O\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_MODES_NAME = \"O\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_NAMES = \"a\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_NAMES = \"a\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_TYPES_INT = \"y\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_TYPES_INT = \"y\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PARAM_TYPES_NAME = \"Y\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PARAM_TYPES_NAME = \"Y\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PASSWORD = \"p\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PASSWORD = \"p\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_PASSWORD_L = \"password\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_PASSWORD_L = \"password\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_SQL = \"s\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_SQL = \"s\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_SQL_L = \"sql\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_SQL_L = \"sql\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_STACK_TRACE = \"t\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_STACK_TRACE = \"t\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_TIMING = \"g\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_TIMING = \"g\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_TRIM_L = \"trim\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_TRIM_L = \"trim\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_USER = \"u\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_USER = \"u\"", "syntax_pass": true}, {"attribute_expression": "private static final String OPT_WRITE_TO_FILE = \"w\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "OPT_WRITE_TO_FILE = \"w\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODE_IN = \"IN\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODE_IN = \"IN\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODE_INOUT = \"INOUT\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODE_INOUT = \"INOUT\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODE_OUT = \"OUT\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODE_OUT = \"OUT\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODE_UNK = \"Unknown\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODE_UNK = \"Unknown\"", "syntax_pass": true}, {"attribute_expression": "private static final String PMODES = PMODE_IN + \", \" + PMODE_INOUT + \", \" + PMODE_OUT + \", \" + PMODE_UNK;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PMODES = PMODE_IN + \", \" + PMODE_INOUT + \", \" + PMODE_OUT + \", \" + PMODE_UNK", "syntax_pass": true}, {"attribute_expression": "private static final String EXPECTED = \"usage: org.apache.commons.cli.bug.BugCLI162Test\" + CR +\n            \" -2,--jdbc2sfmd <arg>        Converts the JDBC file in the first argument\" + CR +\n            \"                             to an SMFD file specified in the second\" + CR +\n            \"                             argument.\" + CR +\n            \" -a,--paramNames <arg>       Parameter XML names; default names are\" + CR +\n            \"                             param1, param2, etc. Example: -a \\\"pname1\" + CR +\n            \"                             pname2\\\"\" + CR +\n            \" -b,--jdbc <arg>             Writes a JDBC binding node file for the given\" + CR +\n            \"                             SQL\" + CR +\n            \" -c,--url <arg>              Connection URL\" + CR +\n            \" -d,--driver <arg>           JDBC driver class name\" + CR +\n            \" -e,--description <arg>      SFMD description. A default description is\" + CR +\n            \"                             used if omited. Example: -e \\\"Runs such and\" + CR +\n            \"                             such\\\"\" + CR +\n            \" -f,--sfmd <arg>             Writes a SFMD file for the given SQL\" + CR +\n            \" -g,--printTiming            Prints timing information\" + CR +\n            \" -h,--help                   Prints help and quits\" + CR +\n            \" -i,--interactive            Runs in interactive mode, reading and writing\" + CR +\n            \"                             from the console, 'go' or '/' sends a\" + CR +\n            \"                             statement\" + CR +\n            \" -j,--node <arg>             Writes a JDBC node file for the given SQL\" + CR +\n            \"                             (internal debugging)\" + CR +\n            \" -l,--columnNames <arg>      Column XML names; default names column\" + CR +\n            \"                             labels. Example: -l \\\"cname1 cname2\\\"\" + CR +\n            \" -m,--printMetaData          Prints metadata information\" + CR +\n            \" -n,--info                   Prints driver information and properties. If\" + CR +\n            \"                             -c is not specified, all drivers on the\" + CR +\n            \"                             classpath are displayed.\" + CR +\n            \" -o,--paramModes <arg>       Parameters modes (1=IN, 2=INOUT, 4=OUT,\" + CR +\n            \"                             0=Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -o \\\"4\" + CR +\n            \"                             1\\\"\" + CR +\n            \" -O,--paramModeNames <arg>   Parameters mode names (IN, INOUT, OUT,\" + CR +\n            \"                             Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -O \\\"OUT\" + CR +\n            \"                             IN\\\"\" + CR +\n            \" -p,--password <arg>         The database password for the user specified\" + CR +\n            \"                             with the -u option. You can obfuscate the\" + CR +\n            \"                             password with\" + CR +\n            \"                             org.mortbay.jetty.security.Password, see\" + CR +\n            \"                             https://docs.codehaus.org/display/JETTY/Secur\" + CR +\n            \"                             ing+Passwords\" + CR +\n            \" -s,--sql <arg>              Runs SQL or {call stored_procedure(?, ?)} or\" + CR +\n            \"                             {?=call function(?, ?)}\" + CR +\n            \" -t,--printStack             Prints stack traces on errors\" + CR +\n            \"    --trim <arg>             Trims leading and trailing spaces from all\" + CR +\n            \"                             column values. Column XML names can be\" + CR +\n            \"                             optionally specified to set which columns to\" + CR +\n            \"                             trim.\" + CR +\n            \" -u,--user <arg>             A database user name\" + CR +\n            \" -w,--outfile <arg>          Writes the SQL output to the given file\" + CR +\n            \" -y,--paramTypes <arg>       Parameter types from java.sql.Types. -y and\" + CR +\n            \"                             -Y are mutually exclusive. Example: -y \\\"-10\" + CR +\n            \"                             12\\\"\" + CR +\n            \" -Y,--paramTypeNames <arg>   Parameter java.sql.Types names. -y and -Y are\" + CR +\n            \"                             mutually exclusive. Example: -Y \\\"CURSOR\" + CR +\n            \"                             VARCHAR\\\"\" + CR;", "docstring": " @formatter:off", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "EXPECTED = \"usage: org.apache.commons.cli.bug.BugCLI162Test\" + CR +\n            \" -2,--jdbc2sfmd <arg>        Converts the JDBC file in the first argument\" + CR +\n            \"                             to an SMFD file specified in the second\" + CR +\n            \"                             argument.\" + CR +\n            \" -a,--paramNames <arg>       Parameter XML names; default names are\" + CR +\n            \"                             param1, param2, etc. Example: -a \\\"pname1\" + CR +\n            \"                             pname2\\\"\" + CR +\n            \" -b,--jdbc <arg>             Writes a JDBC binding node file for the given\" + CR +\n            \"                             SQL\" + CR +\n            \" -c,--url <arg>              Connection URL\" + CR +\n            \" -d,--driver <arg>           JDBC driver class name\" + CR +\n            \" -e,--description <arg>      SFMD description. A default description is\" + CR +\n            \"                             used if omited. Example: -e \\\"Runs such and\" + CR +\n            \"                             such\\\"\" + CR +\n            \" -f,--sfmd <arg>             Writes a SFMD file for the given SQL\" + CR +\n            \" -g,--printTiming            Prints timing information\" + CR +\n            \" -h,--help                   Prints help and quits\" + CR +\n            \" -i,--interactive            Runs in interactive mode, reading and writing\" + CR +\n            \"                             from the console, 'go' or '/' sends a\" + CR +\n            \"                             statement\" + CR +\n            \" -j,--node <arg>             Writes a JDBC node file for the given SQL\" + CR +\n            \"                             (internal debugging)\" + CR +\n            \" -l,--columnNames <arg>      Column XML names; default names column\" + CR +\n            \"                             labels. Example: -l \\\"cname1 cname2\\\"\" + CR +\n            \" -m,--printMetaData          Prints metadata information\" + CR +\n            \" -n,--info                   Prints driver information and properties. If\" + CR +\n            \"                             -c is not specified, all drivers on the\" + CR +\n            \"                             classpath are displayed.\" + CR +\n            \" -o,--paramModes <arg>       Parameters modes (1=IN, 2=INOUT, 4=OUT,\" + CR +\n            \"                             0=Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -o \\\"4\" + CR +\n            \"                             1\\\"\" + CR +\n            \" -O,--paramModeNames <arg>   Parameters mode names (IN, INOUT, OUT,\" + CR +\n            \"                             Unknown). -o and -O are mutually exclusive.\" + CR +\n            \"                             Example for 2 parameters, OUT and IN: -O \\\"OUT\" + CR +\n            \"                             IN\\\"\" + CR +\n            \" -p,--password <arg>         The database password for the user specified\" + CR +\n            \"                             with the -u option. You can obfuscate the\" + CR +\n            \"                             password with\" + CR +\n            \"                             org.mortbay.jetty.security.Password, see\" + CR +\n            \"                             https://docs.codehaus.org/display/JETTY/Secur\" + CR +\n            \"                             ing+Passwords\" + CR +\n            \" -s,--sql <arg>              Runs SQL or {call stored_procedure(?, ?)} or\" + CR +\n            \"                             {?=call function(?, ?)}\" + CR +\n            \" -t,--printStack             Prints stack traces on errors\" + CR +\n            \"    --trim <arg>             Trims leading and trailing spaces from all\" + CR +\n            \"                             column values. Column XML names can be\" + CR +\n            \"                             optionally specified to set which columns to\" + CR +\n            \"                             trim.\" + CR +\n            \" -u,--user <arg>             A database user name\" + CR +\n            \" -w,--outfile <arg>          Writes the SQL output to the given file\" + CR +\n            \" -y,--paramTypes <arg>       Parameter types from java.sql.Types. -y and\" + CR +\n            \"                             -Y are mutually exclusive. Example: -y \\\"-10\" + CR +\n            \"                             12\\\"\" + CR +\n            \" -Y,--paramTypeNames <arg>   Parameter java.sql.Types names. -y and -Y are\" + CR +\n            \"                             mutually exclusive. Example: -Y \\\"CURSOR\" + CR +\n            \"                             VARCHAR\\\"\" + CR", "syntax_pass": true}, {"attribute_expression": "private HelpFormatter formatter;", "docstring": " @formatter:on", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HelpFormatter", "name": "formatter", "syntax_pass": true}, {"attribute_expression": "private StringWriter sw;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringWriter", "name": "sw", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI18Test.java.BugCLI18Test", "name": "BugCLI18Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI18Test.java", "superclasses": "", "methods": ["[void]testCLI18()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nhttps://issues.apache.org/jira/browse/CLI-18\n", "original_string": "public class BugCLI18Test {\n    @Test\n    public void testCLI18() {\n        final Options options = new Options();\n        options.addOption(new Option(\"a\", \"aaa\", false, \"aaaaaaa\"));\n        options.addOption(new Option(null, \"bbb\", false, \"bbbbbbb dksh fkshd fkhs dkfhsdk fhskd hksdks dhfowehfsdhfkjshf skfhkshf sf jkshfk sfh skfh skf f\"));\n        options.addOption(new Option(\"c\", null, false, \"ccccccc\"));\n\n        final HelpFormatter formatter = new HelpFormatter();\n        final StringWriter out = new StringWriter();\n\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\",\n            \"dsfkfsh kdh hsd hsdh fkshdf ksdh fskdh fsdh fkshfk sfdkjhskjh fkjh fkjsh khsdkj hfskdhf skjdfh ksf khf s\", options, 2, 2,\n            \"blort j jgj j jg jhghjghjgjhgjhg jgjhgj jhg jhg hjg jgjhghjg jhg hjg jhgjg jgjhghjg jg jgjhgjgjg jhg jhgjh\" + '\\r' + '\\n' + \"rarrr\", true);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI312Test.java.BugCLI312Test", "name": "BugCLI312Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI312Test.java", "superclasses": "", "methods": ["[void]testNoOptionValues()", "[void]testPropertyStyleOption_withGetOptionProperties()", "[void]testPropertyStyleOption_withGetOptions()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nDemonstrates inconsistencies in parsing Java property-style options.\n", "original_string": "public class BugCLI312Test {\n    @Test\n    public void testNoOptionValues() {\n        final Option o1 = Option.builder(\"A\").build();\n        final Option o2 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n        final Options options = new Options().addOption(o1).addOption(o2);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        assertThrows(MissingArgumentException.class, () -> parser.parse(options, \"-D -A\".split(\" \")));\n    }\n\n    @Test\n    public void testPropertyStyleOption_withGetOptionProperties() throws ParseException {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        final Properties properties = cl.getOptionProperties(\"D\");\n        assertEquals(\"true\", properties.getProperty(\"v\"));\n        assertEquals(\"1\", properties.getProperty(\"w\"));\n        assertEquals(\"2\", properties.getProperty(\"x\"));\n        assertEquals(\"true\", properties.getProperty(\"y\"));\n        assertEquals(\"3\", properties.getProperty(\"z\"));\n        assertEquals(5, properties.size());\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testPropertyStyleOption_withGetOptions() throws ParseException {\n        final Option o1 = Option.builder().option(\"D\").longOpt(\"define\").numberOfArgs(2).valueSeparator('=').build();\n\n        final Options options = new Options();\n        options.addOption(o1);\n\n        final CommandLineParser parser = new DefaultParser();\n\n        final CommandLine cl = parser.parse(options, \"-Dv -Dw=1 -D x=2 -D y -D z=3 other\".split(\" \"));\n        assertArrayEquals(new String[] {\"v\", \"w\", \"1\", \"x\", \"2\", \"y\", \"z\", \"3\"}, cl.getOptionValues('D'));\n\n        int defineOptionsFound = 0;\n        for (final Option o : cl.getOptions()) {\n            if (\"D\".equals(o.getOpt())) {\n                defineOptionsFound++;\n\n                switch (defineOptionsFound) {\n                case 1:\n                    assertArrayEquals(new String[] {\"v\"}, o.getValues());\n                    break;\n                case 2:\n                    assertArrayEquals(new String[] {\"w\", \"1\"}, o.getValues());\n                    break;\n                case 3:\n                    assertArrayEquals(new String[] {\"x\", \"2\"}, o.getValues());\n                    break;\n                case 4:\n                    assertArrayEquals(new String[] {\"y\"}, o.getValues());\n                    break;\n                case 5:\n                    assertArrayEquals(new String[] {\"z\", \"3\"}, o.getValues());\n                    break;\n                default:\n                    fail(\"Didn't expect \" + defineOptionsFound + \" occurrences of -D\");\n                    break;\n                }\n            }\n        }\n        assertEquals(\"other\", cl.getArgList().get(0));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/cli/bug/BugCLI252Test.java.BugCLI252Test", "name": "BugCLI252Test", "file_path": "src/test/java/org/apache/commons/cli/bug/BugCLI252Test.java", "superclasses": "", "methods": ["[void]testAmbiquousOptionName()", "[void]testExactOptionNameMatch()"], "method_uris": ["src/test/java/org/apache/commons/cli/bug/BugCLI252Test.java.BugCLI252Test.[Options]getOptions()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BugCLI252Test {\n\n    private Options getOptions() {\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"prefix\").build());\n        options.addOption(Option.builder().longOpt(\"prefixplusplus\").build());\n        return options;\n    }\n\n    @Test\n    public void testAmbiquousOptionName() {\n        assertThrows(AmbiguousOptionException.class, () ->\n                new DefaultParser().parse(getOptions(), new String[]{\"--pref\"})\n        );\n    }\n\n    @Test\n    public void testExactOptionNameMatch() throws ParseException {\n        new DefaultParser().parse(getOptions(), new String[] {\"--prefix\"});\n    }\n\n}", "super_interfaces": [], "fields": []}]