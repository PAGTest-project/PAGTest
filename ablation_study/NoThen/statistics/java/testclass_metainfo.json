[{"uris": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest", "name": "ExpressionFactoryTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java", "superclasses": "", "methods": ["[void]creates_cucumber_expression_for_empty()", "[void]creates_cucumber_expression_by_default()", "[void]creates_regular_expression_for_anchors()", "[void]creates_regular_expression_for_slashes()", "[void]creates_cucumber_expression_for_parenthesis_with_alpha()", "[void]creates_cucumber_expression_for_escaped_parenthesis_with_regex_symbols()", "[void]creates_cucumber_expression_for_escaped_parenthesis_with_alpha()", "[void]creates_cucumber_expression_for_parenthesis_with_regex_symbols()", "[void]creates_cucumber_expression_for_only_begin_anchor()", "[void]creates_cucumber_expression_for_only_end_anchor()", "[void]creates_regular_expression_for_slashed_anchors()", "[void]explains_cukexp_regexp_mix()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[void]assertRegularExpression(String)", "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[void]assertRegularExpression(String,String)", "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[void]assertCucumberExpression(String)", "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[void]assertExpression(Class<? extends Expression>,String,String)", "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactoryTest.java.ExpressionFactoryTest.[Expression]createExpression(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ExpressionFactoryTest {\n    \n    @Test\n    public void creates_cucumber_expression_for_empty() {\n        assertCucumberExpression(\"\");\n    }\n    \n    @Test\n    public void creates_cucumber_expression_by_default() {\n        assertCucumberExpression(\"strings are cukexp by default\");\n    }\n\n    @Test\n    public void creates_regular_expression_for_anchors() {\n        assertRegularExpression(\"^definitely a regexp$\");\n    }\n\n    @Test\n    public void creates_regular_expression_for_slashes() {\n        assertRegularExpression(\"surely a regexp\", \"/surely a regexp/\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_parenthesis_with_alpha() {\n        assertCucumberExpression(\"this look(s) like a cukexp\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_regex_symbols() {\n        assertCucumberExpression(\"this looks\\\\( i.e: no regex symbols) like a cukexp\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_escaped_parenthesis_with_alpha() {\n        assertCucumberExpression(\"a heavy storm forecast \\\\(BF {int}+)\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_parenthesis_with_regex_symbols() {\n        assertCucumberExpression(\"the temperature is (+){int} degrees celsius\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_only_begin_anchor() {\n        assertRegularExpression(\"^this looks like a regexp\");\n    }\n\n    @Test\n    public void creates_cucumber_expression_for_only_end_anchor() {\n        assertRegularExpression(\"this looks like a regexp$\");\n    }\n\n    @Test\n    public void creates_regular_expression_for_slashed_anchors() {\n        assertRegularExpression(\"^please remove slashes$\", \"/^please remove slashes$/\");\n    }\n\n    @Test\n    public void explains_cukexp_regexp_mix() {\n        final Executable testMethod = () -> createExpression(\"^the seller has {int} strike(s)$\");\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from ^the seller has {int} strike(s)$\")));\n    }\n\n    private void assertRegularExpression(String expressionString) {\n        assertRegularExpression(expressionString, expressionString);\n    }\n\n    private void assertRegularExpression(String expectedSource, String expressionString) {\n        assertExpression(RegularExpression.class, expectedSource, expressionString);\n    }\n\n    private void assertCucumberExpression(String expressionString) {\n        assertExpression(CucumberExpression.class, expressionString, expressionString);\n    }\n\n    private void assertExpression(Class<? extends Expression> expectedClass, String expectedSource, String expressionString) {\n        Expression expression = createExpression(expressionString);\n        assertEquals(expectedClass, expression.getClass());\n        if (expectedSource != null) {\n            assertEquals(expectedSource, expression.getSource());\n        }\n    }\n\n    private Expression createExpression(String expressionString) {\n        return new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH)).createExpression(expressionString);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ArgumentTest.java.ArgumentTest", "name": "ArgumentTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ArgumentTest.java", "superclasses": "", "methods": ["[void]exposes_parameter_type()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ArgumentTest {\n    @Test\n    public void exposes_parameter_type() {\n        TreeRegexp treeRegexp = new TreeRegexp(\"three (.*) mice\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        List<Argument<?>> arguments = Argument.build(\n                treeRegexp.match(\"three blind mice\"),\n                singletonList(parameterTypeRegistry.lookupByTypeName(\"string\")));\n        Argument<?> argument = arguments.get(0);\n        assertEquals(\"string\", argument.getParameterType().getName());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest", "name": "CucumberExpressionTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java", "superclasses": "", "methods": ["[void]acceptance_tests_pass(Expectation)", "[void]exposes_source()", "[void]matches_anonymous_parameter_type_with_hint()", "[void]documents_match_arguments()", "[void]matches_byte()", "[void]matches_short()", "[void]matches_long()", "[void]matches_biginteger()", "[void]matches_bigdecimal()", "[void]matches_double_with_comma_for_locale_using_comma()", "[void]matches_float_with_zero()", "[void]unmatched_optional_groups_have_null_values()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest.[List<Path>]acceptance_tests_pass()", "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest.[List<?>]match(String,String)", "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest.[List<?>]match(String,String,Locale)", "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTest.java.CucumberExpressionTest.[List<?>]match(String,String,ParameterTypeRegistry)"], "overrides": null, "attributes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n        public String exception;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public String text;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}, {"attribute_expression": "public List<?> expected_args;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "List<?>", "name": "expected_args", "syntax_pass": true}, {"attribute_expression": "public String exception;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "exception", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}], "class_docstring": "", "original_string": "class CucumberExpressionTest {\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n            List<Argument<?>> match = expression.match(expectation.text);\n            List<?> values = match == null ? null : match.stream()\n                    .map(Argument::getValue)\n                    .collect(Collectors.toList());\n\n            assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n        } else {\n            Executable executable = () -> {\n                CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n                expression.match(expectation.text);\n            };\n            CucumberExpressionException exception = assertThrows(CucumberExpressionException.class, executable);\n            assertThat(exception.getMessage(), equalTo(expectation.exception));\n        }\n    }\n\n    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n        public String exception;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    // Misc tests\n\n    @Test\n    void exposes_source() {\n        String expr = \"I have {int} cuke(s)\";\n        assertEquals(expr, new CucumberExpression(expr, new ParameterTypeRegistry(Locale.ENGLISH)).getSource());\n    }\n\n    // Java-specific\n    @Test\n    void matches_anonymous_parameter_type_with_hint() {\n        assertEquals(singletonList(0.22f), match(\"{}\", \"0.22\", Float.class));\n    }\n\n    @Test\n    void documents_match_arguments() {\n        String expr = \"I have {int} cuke(s)\";\n        Expression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have 7 cukes\");\n        assertEquals(7, args.get(0).getValue());\n    }\n\n    @Test\n    void matches_byte() {\n        assertEquals(singletonList(Byte.MAX_VALUE), match(\"{byte}\", \"127\"));\n    }\n\n    @Test\n    void matches_short() {\n        assertEquals(singletonList(Short.MAX_VALUE), match(\"{short}\", String.valueOf(Short.MAX_VALUE)));\n    }\n\n    @Test\n    void matches_long() {\n        assertEquals(singletonList(Long.MAX_VALUE), match(\"{long}\", String.valueOf(Long.MAX_VALUE)));\n    }\n\n    @Test\n    void matches_biginteger() {\n        BigInteger bigInteger = BigInteger.valueOf(Long.MAX_VALUE);\n        bigInteger = bigInteger.pow(10);\n        assertEquals(singletonList(bigInteger), match(\"{biginteger}\", bigInteger.toString()));\n    }\n\n    @Test\n    void matches_bigdecimal() {\n        BigDecimal bigDecimal = BigDecimal.valueOf(Math.PI);\n        assertEquals(singletonList(bigDecimal), match(\"{bigdecimal}\", bigDecimal.toString()));\n    }\n\n    @Test\n    void matches_double_with_comma_for_locale_using_comma() {\n        List<?> values = match(\"{double}\", \"1,22\", Locale.FRANCE);\n        assertEquals(singletonList(1.22), values);\n    }\n\n    @Test\n    void matches_float_with_zero() {\n        List<?> values = match(\"{float}\", \"0\", Locale.ENGLISH);\n        assertEquals(0.0f, values.get(0));\n    }\n\n    @Test\n    void unmatched_optional_groups_have_null_values() {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"textAndOrNumber\",\n                singletonList(\"([A-Z]+)?(?: )?([0-9]+)?\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args);\n                    }\n                },\n                false,\n                false)\n        );\n        assertThat(match(\"{textAndOrNumber}\", \"TLA\", parameterTypeRegistry), is(singletonList(asList(\"TLA\", null))));\n        assertThat(match(\"{textAndOrNumber}\", \"123\", parameterTypeRegistry), is(singletonList(asList(null, \"123\"))));\n    }\n\n    private List<?> match(String expr, String text, Type... typeHints) {\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }\n\n    private List<?> match(String expr, String text, Locale locale, Type... typeHints) {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(locale);\n        return match(expr, text, parameterTypeRegistry, typeHints);\n    }\n\n    private List<?> match(String expr, String text, ParameterTypeRegistry parameterTypeRegistry, Type... typeHints) {\n        CucumberExpression expression = new CucumberExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(text, typeHints);\n        if (args == null) {\n            return null;\n        } else {\n            List<Object> list = new ArrayList<>();\n            for (Argument<?> arg : args) {\n                Object value = arg.getValue();\n                list.add(value);\n            }\n            return list;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/RegularExpression_getSourceTest.java.RegularExpression_getSourceTest", "name": "RegularExpression_getSourceTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/RegularExpression_getSourceTest.java", "superclasses": "", "methods": ["[void]testGetSource()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RegularExpression_getSourceTest {\n\n    @Test\n    public void testGetSource() {\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n\n        String source = regularExpression.getSource();\n\n        assertEquals(\"\\\\d+\", source);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_useRegexpMatchAsStrongTypeHintTest.java.ParameterType_useRegexpMatchAsStrongTypeHintTest", "name": "ParameterType_useRegexpMatchAsStrongTypeHintTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_useRegexpMatchAsStrongTypeHintTest.java", "superclasses": "", "methods": ["[void]testUseRegexpMatchAsStrongTypeHintTrue()", "[void]testUseRegexpMatchAsStrongTypeHintFalse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ParameterType_useRegexpMatchAsStrongTypeHintTest {\n\n    @Test\n    public void testUseRegexpMatchAsStrongTypeHintTrue() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                true\n        );\n        assertTrue(parameterType.useRegexpMatchAsStrongTypeHint());\n    }\n\n    @Test\n    public void testUseRegexpMatchAsStrongTypeHintFalse() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false,\n                false\n        );\n        assertFalse(parameterType.useRegexpMatchAsStrongTypeHint());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/EnumParameterTypeTest.java.EnumParameterTypeTest", "name": "EnumParameterTypeTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/EnumParameterTypeTest.java", "superclasses": "", "methods": ["[void]converts_to_enum()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class EnumParameterTypeTest {\n\n    public enum Mood {\n        happy,\n        meh,\n        sad\n    }\n\n    @Test\n    public void converts_to_enum() {\n        ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);\n        registry.defineParameterType(ParameterType.fromEnum(Mood.class));\n\n        CucumberExpression expression = new CucumberExpression(\"I am {Mood}\", registry);\n        List<Argument<?>> args = expression.match(\"I am happy\");\n        assertEquals(Mood.happy, args.get(0).getValue());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/GenericParameterTypeTest.java.GenericParameterTypeTest", "name": "GenericParameterTypeTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/GenericParameterTypeTest.java", "superclasses": "", "methods": ["[void]transforms_to_a_list_of_string()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class GenericParameterTypeTest {\n\n    @Test\n    public void transforms_to_a_list_of_string() {\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"stringlist\",\n                singletonList(\".*\"),\n                new TypeReference<List<String>>() {\n                }.getType(),\n                new CaptureGroupTransformer<List<String>>() {\n                    @Override\n                    public List<String> transform(String... args) {\n                        return asList(args[0].split(\",\"));\n                    }\n                },\n                false,\n                false)\n        );\n        Expression expression = new CucumberExpression(\"I have {stringlist} yay\", parameterTypeRegistry);\n        List<Argument<?>> args = expression.match(\"I have three,blind,mice yay\");\n        assertEquals(asList(\"three\", \"blind\", \"mice\"), args.get(0).getValue());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/TreeRegexp_getGroupBuilderTest.java.TreeRegexp_getGroupBuilderTest", "name": "TreeRegexp_getGroupBuilderTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/TreeRegexp_getGroupBuilderTest.java", "superclasses": "", "methods": ["[void]testGetGroupBuilder()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class TreeRegexp_getGroupBuilderTest {\n\n    @Test\n    void testGetGroupBuilder() {\n        // Given\n        Pattern pattern = Pattern.compile(\"a(b)c\");\n        TreeRegexp treeRegexp = new TreeRegexp(pattern);\n\n        // When\n        GroupBuilder groupBuilder = treeRegexp.getGroupBuilder();\n\n        // Then\n        assertNotNull(groupBuilder);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest", "name": "KeyboardFriendlyDecimalFormatSymbolsTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java", "superclasses": "", "methods": ["[void]listMinusSigns()", "[void]listDecimalAndGroupingSeparators()", "[void]listExponentSigns()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[void]listMinusSigns(Function<Locale, DecimalFormatSymbols>)", "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[void]listDecimalAndGroupingSeparators(Function<Locale, DecimalFormatSymbols>)", "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[void]listExponentSigns(Function<Locale, DecimalFormatSymbols>)", "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[Stream<Locale>]getAvailableLocalesAsStream()", "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[String]render(Character)", "src/test/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbolsTest.java.KeyboardFriendlyDecimalFormatSymbolsTest.[String]render(List<Locale>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class KeyboardFriendlyDecimalFormatSymbolsTest {\n\n    @Test\n    void listMinusSigns(){\n        System.out.println(\"Original minus signs:\");\n        listMinusSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly minus signs:\");\n        listMinusSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }\n\n    private static void listMinusSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getMinusSign()))\n                .forEach((c, locales) -> System.out.println(render(c) + \" \" + render(locales)));\n    }\n\n    @Test\n    void listDecimalAndGroupingSeparators(){\n        System.out.println(\"Original decimal and group separators:\");\n        listDecimalAndGroupingSeparators(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly decimal and group separators:\");\n        listDecimalAndGroupingSeparators(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }\n\n    private static void listDecimalAndGroupingSeparators(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> {\n                    DecimalFormatSymbols symbols = supplier.apply(locale);\n                    return new SimpleEntry<>(symbols.getDecimalSeparator(), symbols.getGroupingSeparator());\n                }))\n                .entrySet()\n                .stream()\n                .sorted(comparing(entry -> entry.getKey().getKey()))\n                .forEach((entry) -> {\n                    SimpleEntry<Character, Character> characters = entry.getKey();\n                    List<Locale> locales = entry.getValue();\n                    System.out.println(render(characters.getKey()) + \" \" + render(characters.getValue()) + \" \" + render(locales));\n                });\n    }\n\n    @Test\n    void listExponentSigns(){\n        System.out.println(\"Original exponent signs:\");\n        listExponentSigns(DecimalFormatSymbols::getInstance);\n        System.out.println();\n        System.out.println(\"Friendly exponent signs:\");\n        listExponentSigns(KeyboardFriendlyDecimalFormatSymbols::getInstance);\n        System.out.println();\n    }\n\n    private static void listExponentSigns(Function<Locale, DecimalFormatSymbols> supplier) {\n        getAvailableLocalesAsStream()\n                .collect(groupingBy(locale -> supplier.apply(locale).getExponentSeparator()))\n                .forEach((s, locales) -> {\n                    if (s.length() == 1) {\n                        System.out.println(render(s.charAt(0)) + \" \" + render(locales));\n                    } else {\n                        System.out.println(s + \" \" + render(locales));\n                    }\n                });\n    }\n\n    private static Stream<Locale> getAvailableLocalesAsStream() {\n        return Arrays.stream(DecimalFormatSymbols.getAvailableLocales());\n    }\n\n    private static String render(Character character) {\n        return character + \" (\" + (int) character + \")\";\n    }\n\n    private static String render(List<Locale> locales) {\n        return locales.size() + \": \" + locales.stream()\n                .sorted(comparing(Locale::getDisplayName))\n                .map(Locale::getDisplayName)\n                .collect(toList());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionGeneratorTest.java.CucumberExpressionGeneratorTest", "name": "CucumberExpressionGeneratorTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionGeneratorTest.java", "superclasses": "", "methods": ["[void]documents_expression_generation()", "[void]generates_expression_for_no_args()", "[void]generates_expression_with_escaped_left_parenthesis()", "[void]generates_expression_with_escaped_left_curly_brace()", "[void]generates_expression_with_escaped_slashes()", "[void]generates_expression_for_int_double_arg()", "[void]generates_expression_for_numbers_with_symbols_and_currency()", "[void]generates_expression_for_numbers_with_text_on_both_sides()", "[void]generates_expression_for_strings()", "[void]generates_expression_with_percent_sign()", "[void]generates_expression_for_just_int()", "[void]numbers_all_arguments_when_type_is_reserved_keyword()", "[void]numbers_only_second_argument_when_type_is_not_reserved_keyword()", "[void]does_not_suggest_parameter_type_when_surrounded_by_alphanum()", "[void]does_suggest_parameter_type_when_surrounded_by_space()", "[void]prefers_leftmost_match_when_there_is_overlap()", "[void]prefers_widest_match_when_pos_is_same()", "[void]generates_all_combinations_of_expressions_when_several_parameter_types_match()", "[void]exposes_transforms_in_generated_expression()", "[void]matches_parameter_types_with_optional_capture_groups()", "[void]generates_at_most_256_expressions()", "[void]prefers_expression_with_longest_non_empty_match()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionGeneratorTest.java.CucumberExpressionGeneratorTest.[void]assertExpression(String,List<String>,String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CucumberExpressionGeneratorTest {\n\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    private final CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);\n    private static final DateFormat df = DateFormat.getDateInstance();\n\n    @Test\n    public void documents_expression_generation() {\n        CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);\n        String undefinedStepText = \"I have 2 cucumbers and 1.5 tomato\";\n        GeneratedExpression generatedExpression = generator.generateExpressions(undefinedStepText).get(0);\n        assertEquals(\"I have {int} cucumbers and {double} tomato\", generatedExpression.getSource());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }\n\n    @Test\n    public void generates_expression_for_no_args() {\n        assertExpression(\"hello\", Collections.<String>emptyList(), \"hello\");\n    }\n\n    @Test\n    public void generates_expression_with_escaped_left_parenthesis() {\n        assertExpression(\n                \"\\\\(iii)\", Collections.<String>emptyList(),\n                \"(iii)\");\n    }\n\n    @Test\n    public void generates_expression_with_escaped_left_curly_brace() {\n        assertExpression(\n                \"\\\\{iii}\", Collections.<String>emptyList(),\n                \"{iii}\");\n    }\n\n    @Test\n    public void generates_expression_with_escaped_slashes() {\n        assertExpression(\n                \"The {int}\\\\/{int}\\\\/{int} hey\", asList(\"int1\", \"int2\", \"int3\"),\n                \"The 1814/05/17 hey\");\n    }\n\n    @Test\n    public void generates_expression_for_int_double_arg() {\n        assertExpression(\n                \"I have {int} cukes and {double} euro\", asList(\"int1\", \"double1\"),\n                \"I have 2 cukes and 1.5 euro\");\n    }\n\n    @Test\n    public void generates_expression_for_numbers_with_symbols_and_currency() {\n        assertExpression(\n                \"Some ${double} of cukes at {int}\u00b0 Celsius\", asList(\"double1\", \"int1\"),\n                \"Some $5000.00 of cukes at 42\u00b0 Celsius\");\n    }\n\n    @Test\n    public void generates_expression_for_numbers_with_text_on_both_sides() {\n        assertExpression(\n                \"i18n\", asList(),\n                \"i18n\");\n    }\n\n    @Test\n    public void generates_expression_for_strings() {\n        assertExpression(\n                \"I like {string} and {string}\", asList(\"string\", \"string2\"),\n                \"I like \\\"bangers\\\" and 'mash'\");\n    }\n\n    @Test\n    public void generates_expression_with_percent_sign() {\n        assertExpression(\n                \"I am {int}% foobar\", singletonList(\"int1\"),\n                \"I am 20% foobar\");\n    }\n\n    @Test\n    public void generates_expression_for_just_int() {\n        assertExpression(\n                \"{int}\", singletonList(\"int1\"),\n                \"99999\");\n    }\n\n    @Test\n    public void numbers_all_arguments_when_type_is_reserved_keyword() {\n        assertExpression(\n                \"I have {int} cukes and {int} euro\", asList(\"int1\", \"int2\"),\n                \"I have 2 cukes and 5 euro\");\n    }\n\n    @Test\n    public void numbers_only_second_argument_when_type_is_not_reserved_keyword() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"[A-Z]{3}\",\n                Currency.class,\n                new Transformer<Currency>() {\n                    @Override\n                    public Currency transform(String arg) {\n                        return Currency.getInstance(arg);\n                    }\n                }\n        ));\n        assertExpression(\n                \"I have a {currency} account and a {currency} account\", asList(\"currency\", \"currency2\"),\n                \"I have a EUR account and a GBP account\");\n    }\n\n    @Test\n    public void does_not_suggest_parameter_type_when_surrounded_by_alphanum() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"I like muppets\", Collections.<String>emptyList(),\n                \"I like muppets\");\n    }\n\n    @Test\n    public void does_suggest_parameter_type_when_surrounded_by_space() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"direction\",\n                \"(up|down)\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                },\n                true,\n                false\n        ));\n        assertExpression(\n                \"it went {direction} and {direction}\", asList(\"direction\", \"direction2\"),\n                \"it went up and down\");\n    }\n\n    @Test\n    public void prefers_leftmost_match_when_there_is_overlap() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"right\",\n                \"c d\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"left\",\n                \"b c\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String arg) {\n                        return arg;\n                    }\n                }\n        ));\n        assertExpression(\n                \"a {left} d e f g\", singletonList(\"left\"),\n                \"a b c d e f g\");\n    }\n\n    @Test\n    public void prefers_widest_match_when_pos_is_same() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"airport\",\n                \"[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"leg\",\n                \"[A-Z]{3}-[A-Z]{3}\",\n                String.class,\n                (Transformer<String>) s -> s\n        ));\n        assertExpression(\n                \"leg {leg}\", singletonList(\"leg\"),\n                \"leg LHR-CDG\");\n    }\n\n    @Test\n    public void generates_all_combinations_of_expressions_when_several_parameter_types_match() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"currency\",\n                \"x\",\n                Currency.class,\n                (Transformer<Currency>) Currency::getInstance,\n                true,\n                true\n        ));\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"date\",\n                \"x\",\n                Date.class,\n                new Transformer<Date>() {\n                    @Override\n                    public Date transform(String arg) {\n                        try {\n                            return df.parse(arg);\n                        } catch (ParseException e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                },\n                true,\n                false\n        ));\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I have x and x and another x\");\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I have {currency} and {currency} and another {currency}\",\n                \"I have {currency} and {currency} and another {date}\",\n                \"I have {currency} and {date} and another {currency}\",\n                \"I have {currency} and {date} and another {date}\",\n                \"I have {date} and {currency} and another {currency}\",\n                \"I have {date} and {currency} and another {date}\",\n                \"I have {date} and {date} and another {currency}\",\n                \"I have {date} and {date} and another {date}\"\n        ), expressions);\n    }\n\n    @Test\n    public void exposes_transforms_in_generated_expression() {\n        GeneratedExpression generatedExpression = generator.generateExpressions(\"I have 2 cukes and 1.5 euro\").get(0);\n        assertEquals(Integer.class, generatedExpression.getParameterTypes().get(0).getType());\n        assertEquals(Double.class, generatedExpression.getParameterTypes().get(1).getType());\n    }\n\n    @Test\n    public void matches_parameter_types_with_optional_capture_groups() {\n        ParameterType<String> optionalFlight = new ParameterType<>(\n                \"optional-flight\",\n                \"(1st flight)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        ParameterType<String> optionalHotel = new ParameterType<>(\n                \"optional-hotel\",\n                \"(1 hotel)?\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n\n        parameterTypeRegistry.defineParameterType(optionalFlight);\n        parameterTypeRegistry.defineParameterType(optionalHotel);\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"I reach Stage 4: 1st flight -1 hotel\");\n        assertEquals(\"I reach Stage {int}: {optional-flight} {int} hotel\", generatedExpressions.get(0).getSource());\n    }\n\n    @Test\n    public void generates_at_most_256_expressions() {\n        for (int i = 0; i < 4; i++) {\n            ParameterType<String> myType = new ParameterType<>(\n                    \"my-type-\" + i,\n                    \"[a-z]\",\n                    String.class,\n                    (Transformer<String>) arg -> arg,\n                    true,\n                    false\n            );\n            parameterTypeRegistry.defineParameterType(myType);\n\n        }\n        // This would otherwise generate 4^11=419430 expressions and consume just shy of 1.5GB.\n        assertEquals(256, generator.generateExpressions(\"a b c d e f g h i j k\").size());\n    }\n\n    @Test\n    public void prefers_expression_with_longest_non_empty_match() {\n        ParameterType<String> zeroOrMore = new ParameterType<>(\n                \"zero-or-more\",\n                \"[a-z]*\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(zeroOrMore);\n        ParameterType<String> exactlyOne = new ParameterType<>(\n                \"exactly-one\",\n                \"[a-z]\",\n                String.class,\n                (Transformer<String>) arg -> arg,\n                true,\n                false\n        );\n        parameterTypeRegistry.defineParameterType(exactlyOne);\n\n        List<GeneratedExpression> generatedExpressions = generator.generateExpressions(\"a simple step\");\n        assertEquals(2, generatedExpressions.size());\n        assertEquals(\"{exactly-one} {zero-or-more} {zero-or-more}\", generatedExpressions.get(0).getSource());\n        assertEquals(\"{zero-or-more} {zero-or-more} {zero-or-more}\", generatedExpressions.get(1).getSource());\n    }\n\n    private void assertExpression(String expectedExpression, List<String> expectedArgumentNames, String text) {\n        GeneratedExpression generatedExpression = generator.generateExpressions(text).get(0);\n        assertEquals(expectedExpression, generatedExpression.getSource());\n        assertEquals(expectedArgumentNames, generatedExpression.getParameterNames());\n\n        // Check that the generated expression matches the text\n        CucumberExpression cucumberExpression = new CucumberExpression(generatedExpression.getSource(), parameterTypeRegistry);\n        List<Argument<?>> match = cucumberExpression.match(text);\n        if (match == null) {\n            fail(String.format(\"Expected text '%s' to match generated expression '%s'\", text, generatedExpression.getSource()));\n        }\n        assertEquals(expectedArgumentNames.size(), match.size());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}, {"attribute_expression": "private final CucumberExpressionGenerator generator = new CucumberExpressionGenerator(parameterTypeRegistry);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CucumberExpressionGenerator", "name": "generator = new CucumberExpressionGenerator(parameterTypeRegistry)", "syntax_pass": true}, {"attribute_expression": "private static final DateFormat df = DateFormat.getDateInstance();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "DateFormat", "name": "df = DateFormat.getDateInstance()", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry_setDefaultParameterTransformerTest.java.ParameterTypeRegistry_setDefaultParameterTransformerTest", "name": "ParameterTypeRegistry_setDefaultParameterTransformerTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry_setDefaultParameterTransformerTest.java", "superclasses": "", "methods": ["[void]testSetDefaultParameterTransformer()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry_setDefaultParameterTransformerTest.java.ParameterTypeRegistry_setDefaultParameterTransformerTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ParameterTypeRegistry_setDefaultParameterTransformerTest {\n\n    private ParameterTypeRegistry parameterTypeRegistry;\n    private ParameterByTypeTransformer mockTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        mockTransformer = new ParameterByTypeTransformer() {\n            @Override\n            public Object transform(String fromValue, Type toValueType) {\n                return null;\n            }\n        };\n    }\n\n    @Test\n    public void testSetDefaultParameterTransformer() {\n        // Given\n        ParameterByTypeTransformer originalTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n\n        // When\n        parameterTypeRegistry.setDefaultParameterTransformer(mockTransformer);\n\n        // Then\n        assertSame(mockTransformer, parameterTypeRegistry.getDefaultParameterTransformer());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}, {"attribute_expression": "private ParameterByTypeTransformer mockTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterByTypeTransformer", "name": "mockTransformer", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/RegexpUtils_escapeRegexTest.java.RegexpUtils_escapeRegexTest", "name": "RegexpUtils_escapeRegexTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/RegexpUtils_escapeRegexTest.java", "superclasses": "", "methods": ["[void]testEscapeRegex_NoSpecialChars()", "[void]testEscapeRegex_WithSpecialChars()", "[void]testEscapeRegex_AllSpecialChars()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class RegexpUtils_escapeRegexTest {\n\n    @Test\n    void testEscapeRegex_NoSpecialChars() {\n        String input = \"hello world\";\n        String expected = \"hello world\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testEscapeRegex_WithSpecialChars() {\n        String input = \"hello.world$\";\n        String expected = \"hello\\\\.world\\\\$\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    void testEscapeRegex_AllSpecialChars() {\n        String input = \"^$(){}[].+*?\\\\\";\n        String expected = \"\\\\^\\\\$\\\\(\\\\)\\\\{\\\\}\\\\[\\\\]\\\\.\\\\+\\\\*\\\\?\\\\\\\\\";\n        String actual = RegexpUtils.escapeRegex(input);\n        assertEquals(expected, actual);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CustomParameterTypeTest.java.CustomParameterTypeTest", "name": "CustomParameterTypeTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CustomParameterTypeTest.java", "superclasses": "", "methods": ["[void]throws_exception_for_illegal_character_in_parameter_name()", "[void]matches_CucumberExpression_parameters_with_custom_parameter_type()", "[void]matches_CucumberExpression_parameters_with_multiple_capture_groups()", "[void]warns_when_CucumberExpression_parameters_with_multiple_capture_groups_has_a_transformer()", "[void]warns_when_anonymous_parameter_has_multiple_capture_groups()", "[void]matches_CucumberExpression_parameters_with_custom_parameter_type_using_optional_group()", "[void]defers_transformation_until_queried_from_argument()", "[void]conflicting_parameter_type_is_detected_for_type_name()", "[void]conflicting_parameter_type_is_not_detected_for_type()", "[void]conflicting_parameter_type_is_not_detected_for_regexp()", "[void]matches_RegularExpression_arguments_with_custom_parameter_type_without_name()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/CustomParameterTypeTest.java.CustomParameterTypeTest.[void]create_parameter()"], "overrides": null, "attributes": [{"original_string": "    public static class Coordinate {\n        private final int x;\n        private final int y;\n        private final int z;\n\n        Coordinate(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Coordinate that = (Coordinate) o;\n            return x == that.x && y == that.y && z == that.z;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            result = 31 * result + z;\n            return result;\n        }\n    }", "definition": "    public static class Coordinate", "class_docstring": "", "name": "Coordinate", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final int x;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "x", "syntax_pass": true}, {"attribute_expression": "private final int y;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "y", "syntax_pass": true}, {"attribute_expression": "private final int z;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "z", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Coordinate(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Coordinate", "params": [{"name": "x", "type": "int"}, {"name": "y", "type": "int"}, {"name": "z", "type": "int"}], "body": "                                        {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }", "signature": "Coordinate(int x, int y, int z)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Coordinate that = (Coordinate) o;\n            return x == that.x && y == that.y && z == that.z;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                        {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Coordinate that = (Coordinate) o;\n            return x == that.x && y == that.y && z == that.z;\n        }", "signature": "@Override\n        public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            result = 31 * result + z;\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            int result = x;\n            result = 31 * result + y;\n            result = 31 * result + z;\n            return result;\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    public static class Color {\n        final String name;\n\n        Color(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof Color && ((Color) obj).name.equals(name);\n        }\n    }", "definition": "    public static class Color", "class_docstring": "// RegularExpression", "name": "Color", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "final String name;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Color(String name) {\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Color", "params": [{"name": "name", "type": "String"}], "body": "                           {\n            this.name = name;\n        }", "signature": "Color(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return name.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof Color && ((Color) obj).name.equals(name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                          {\n            return obj instanceof Color && ((Color) obj).name.equals(name);\n        }", "signature": "@Override\n        public boolean equals(Object obj)"}]}, {"original_string": "    public static class CssColor {\n        final String name;\n\n        CssColor(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof CssColor && ((CssColor) obj).name.equals(name);\n        }\n    }", "definition": "    public static class CssColor", "class_docstring": "", "name": "CssColor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "final String name;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        CssColor(String name) {\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CssColor", "params": [{"name": "name", "type": "String"}], "body": "                              {\n            this.name = name;\n        }", "signature": "CssColor(String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return name.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof CssColor && ((CssColor) obj).name.equals(name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                          {\n            return obj instanceof CssColor && ((CssColor) obj).name.equals(name);\n        }", "signature": "@Override\n        public boolean equals(Object obj)"}]}], "class_docstring": "", "original_string": "public class CustomParameterTypeTest {\n\n    private ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    public static class Coordinate {\n        private final int x;\n        private final int y;\n        private final int z;\n\n        Coordinate(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Coordinate that = (Coordinate) o;\n            return x == that.x && y == that.y && z == that.z;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = x;\n            result = 31 * result + y;\n            result = 31 * result + z;\n            return result;\n        }\n    }\n\n    @BeforeEach\n    public void create_parameter() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",                                  // name\n                \"red|blue|yellow\",                        // regexp\n                Color.class,                              // type\n                Color::new,                               // transform\n                false,                                    // useForSnippets\n                false                                     // preferForRegexpMatch\n        ));\n    }\n\n    @Test\n    public void throws_exception_for_illegal_character_in_parameter_name() {\n\n        final Executable testMethod = () -> new ParameterType<>(\n                \"(string)\",\n                \".*\",\n                String.class,\n                (Transformer<String>) s -> s,\n                false,\n                false\n        );\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(thrownException.getMessage(), is(equalTo(\"Illegal character in parameter name {(string)}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\")));\n    }\n\n    @Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type() {\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }\n\n    @Test\n    public void matches_CucumberExpression_parameters_with_multiple_capture_groups() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new CaptureGroupTransformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String[] args) {\n                        return new Coordinate(\n                                parseInt(args[0]),\n                                parseInt(args[1]),\n                                parseInt(args[2]));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n        Integer thick = (Integer) arguments.get(0).getValue();\n        Coordinate from = (Coordinate) arguments.get(1).getValue();\n        Coordinate to = (Coordinate) arguments.get(2).getValue();\n        assertEquals(Integer.valueOf(5), thick);\n        assertEquals(new Coordinate(10, 20, 30), from);\n        assertEquals(new Coordinate(40, 50, 60), to);\n    }\n\n    @Test\n    public void warns_when_CucumberExpression_parameters_with_multiple_capture_groups_has_a_transformer() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"coordinate\",\n                \"(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\",\n                Coordinate.class,\n                new Transformer<Coordinate>() {\n                    @Override\n                    public Coordinate transform(String args) {\n                        throw new IllegalStateException();\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"A {int} thick line from {coordinate} to {coordinate}\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"ParameterType {coordinate} was registered with a Transformer but has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\"\n        )));\n    }\n\n    @Test\n    public void warns_when_anonymous_parameter_has_multiple_capture_groups() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        Expression expression = new RegularExpression(Pattern.compile(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))$\"), parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"A 5 thick line from 10,20,30 to 40,50,60\",\n                Integer.class, Coordinate.class, Coordinate.class);\n\n        arguments.get(0).getValue();\n\n        final Executable testMethod = () -> arguments.get(1).getValue();\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Anonymous ParameterType has multiple capture groups [(\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)]. \" +\n                        \"You can only use a single capture group in an anonymous ParameterType.\"\n        )));\n    }\n\n    @Test\n    public void matches_CucumberExpression_parameters_with_custom_parameter_type_using_optional_group() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"color\",\n                asList(\"red|blue|yellow\", \"(?:dark|light) (?:red|blue|yellow)\"),\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a dark red ball\").get(0).getValue();\n        assertEquals(new Color(\"dark red\"), argumentValue);\n    }\n\n    @Test\n    public void defers_transformation_until_queried_from_argument() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"throwing\",\n                \"bad\",\n                CssColor.class,\n                new Transformer<CssColor>() {\n                    @Override\n                    public CssColor transform(String arg) {\n                        throw new RuntimeException(String.format(\"Can't transform [%s]\", arg));\n                    }\n                },\n                false,\n                false\n        ));\n        Expression expression = new CucumberExpression(\"I have a {throwing} parameter\", parameterTypeRegistry);\n        List<Argument<?>> arguments = expression.match(\"I have a bad parameter\");\n        try {\n            arguments.get(0).getValue();\n            fail(\"should have failed\");\n        } catch (RuntimeException expected) {\n            assertEquals(\"ParameterType {throwing} failed to transform [bad] to \" + CssColor.class, expected.getMessage());\n        }\n    }\n\n    @Test\n    public void conflicting_parameter_type_is_detected_for_type_name() {\n        try {\n            parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                    \"color\",\n                    \".*\",\n                    CssColor.class,\n                    CssColor::new,\n                    false,\n                    false\n            ));\n            fail(\"should have failed\");\n        } catch (DuplicateTypeNameException expected) {\n            assertEquals(\"There is already a parameter type with name color\", expected.getMessage());\n        }\n    }\n\n    @Test\n    public void conflicting_parameter_type_is_not_detected_for_type() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"whatever\",\n                \".*\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n    }\n\n    ///// Conflicting parameter types\n\n    @Test\n    public void conflicting_parameter_type_is_not_detected_for_regexp() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"css-color\",\n                \"red|blue|yellow\",\n                CssColor.class,\n                CssColor::new,\n                false,\n                false\n        ));\n\n        assertEquals(new CssColor(\"blue\"), new CucumberExpression(\"I have a {css-color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n        assertEquals(new Color(\"blue\"), new CucumberExpression(\"I have a {color} ball\", parameterTypeRegistry).match(\"I have a blue ball\").get(0).getValue());\n    }\n\n    @Test\n    public void matches_RegularExpression_arguments_with_custom_parameter_type_without_name() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                null,\n                \"red|blue|yellow\",\n                Color.class,\n                Color::new,\n                false,\n                false\n        ));\n\n        Expression expression = new RegularExpression(compile(\"I have a (red|blue|yellow) ball\"), parameterTypeRegistry);\n        Object argumentValue = expression.match(\"I have a red ball\").get(0).getValue();\n        assertEquals(new Color(\"red\"), argumentValue);\n    }\n\n    ///// RegularExpression\n\n    public static class Color {\n        final String name;\n\n        Color(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof Color && ((Color) obj).name.equals(name);\n        }\n    }\n\n    public static class CssColor {\n        final String name;\n\n        CssColor(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return obj instanceof CssColor && ((CssColor) obj).name.equals(name);\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTransformationTest.java.CucumberExpressionTransformationTest", "name": "CucumberExpressionTransformationTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTransformationTest.java", "superclasses": "", "methods": ["[void]acceptance_tests_pass(Expectation)"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTransformationTest.java.CucumberExpressionTransformationTest.[List<Path>]acceptance_tests_pass()"], "overrides": null, "attributes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public String expected_regex;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public String expected_regex;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expected_regex", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}], "class_docstring": "", "original_string": "class CucumberExpressionTransformationTest {\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"transformation\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        CucumberExpression expression = new CucumberExpression(expectation.expression, parameterTypeRegistry);\n        assertEquals(expectation.expected_regex, expression.getRegexp().pattern());\n    }\n\n    static class Expectation {\n        public String expression;\n        public String expected_regex;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_weightTest.java.ParameterType_weightTest", "name": "ParameterType_weightTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_weightTest.java", "superclasses": "", "methods": ["[void]testWeightForIntegerClass()", "[void]testWeightForNonIntegerType()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ParameterType_weightTest {\n\n    @Test\n    void testWeightForIntegerClass() {\n        ParameterType<Integer> parameterType = new ParameterType<>(\"test\", \"(\\\\d+)\", Integer.class, (String arg) -> Integer.parseInt(arg));\n        assertEquals(1000, parameterType.weight());\n    }\n\n    @Test\n    void testWeightForNonIntegerType() {\n        ParameterType<String> parameterType = new ParameterType<>(\"test\", \"(\\\\w+)\", String.class, (String arg) -> arg);\n        assertEquals(0, parameterType.weight());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getRegexpTest.java.CucumberExpression_getRegexpTest", "name": "CucumberExpression_getRegexpTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getRegexpTest.java", "superclasses": "", "methods": ["[void]testGetRegexp()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getRegexpTest.java.CucumberExpression_getRegexpTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CucumberExpression_getRegexpTest {\n\n    private ParameterTypeRegistry parameterTypeRegistry;\n\n    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }\n\n    @Test\n    public void testGetRegexp() {\n        String expression = \"I have {int} cucumbers\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expression, parameterTypeRegistry);\n\n        Pattern expectedPattern = Pattern.compile(\"I have (-?\\\\d+) cucumbers\");\n        assertEquals(expectedPattern.pattern(), cucumberExpression.getRegexp().pattern());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest", "name": "PatternCompilerProviderTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java", "superclasses": "", "methods": ["[void]use_default_compiler_if_none_registered()", "[void]use_found_pattern_compiler_if_one_provided()", "[void]throws_error_if_more_than_one_pattern_compiler()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest.[void]setUp()", "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest.[void]tearDown()", "src/test/java/io/cucumber/cucumberexpressions/PatternCompilerProviderTest.java.PatternCompilerProviderTest.[PatternCompiler]getTestCompiler()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PatternCompilerProviderTest {\n\n    @BeforeEach\n    public void setUp() {\n        PatternCompilerProvider.service = null;\n    }\n\n    @AfterEach\n    public void tearDown() {\n        PatternCompilerProvider.service = null;\n    }\n\n    @Test\n    public void use_default_compiler_if_none_registered() {\n        PatternCompilerProvider.findPatternCompiler(Collections.emptyIterator());\n        assertSame(DefaultPatternCompiler.class, PatternCompilerProvider.service.getClass());\n    }\n\n    @Test\n    public void use_found_pattern_compiler_if_one_provided() {\n        PatternCompiler compiler = getTestCompiler();\n        PatternCompilerProvider.findPatternCompiler(Collections.singletonList(compiler).iterator());\n        assertSame(compiler, PatternCompilerProvider.service);\n    }\n\n    @Test\n    public void throws_error_if_more_than_one_pattern_compiler() {\n\n        final Executable testMethod = () -> PatternCompilerProvider.findPatternCompiler(Arrays.asList(new DefaultPatternCompiler(), getTestCompiler()).iterator());\n\n        final IllegalStateException thrownException = assertThrows(IllegalStateException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"More than one PatternCompiler: [class io.cucumber.cucumberexpressions.DefaultPatternCompiler, class io.cucumber.cucumberexpressions.PatternCompilerProviderTest$1]\")));\n    }\n\n    private PatternCompiler getTestCompiler() {\n        return new PatternCompiler() {\n            @Override\n            public Pattern compile(String regexp, int flags) {\n                return null;\n            }\n        };\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/TreeRegexpTest.java.TreeRegexpTest", "name": "TreeRegexpTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/TreeRegexpTest.java", "superclasses": "", "methods": ["[void]exposes_group_source()", "[void]builds_tree()", "[void]ignores_question_mark_colon_non_capturing_group()", "[void]ignores_question_mark_exclamation_mark_non_capturing_group()", "[void]ignores_question_mark_equal_sign_non_capturing_group()", "[void]ignores_question_mark_less_than_equal_sign_non_capturing_group()", "[void]ignores_question_mark_less_than_exclamation_mark_non_capturing_group()", "[void]ignores_question_mark_greater_then_non_capturing_group()", "[void]matches_named_capturing_group()", "[void]matches_optional_group()", "[void]matches_nested_groups()", "[void]captures_non_capturing_groups_with_capturing_groups_inside()", "[void]detects_multiple_non_capturing_groups()", "[void]works_with_escaped_backslash()", "[void]works_with_slash_which_doesnt_need_escaping_in_java()", "[void]works_digit_and_word()", "[void]captures_start_and_end()", "[void]doesnt_consider_parenthesis_in_character_class_as_group()", "[void]works_with_flags()", "[void]works_with_inline_flags()", "[void]works_with_non_capturing_inline_flags()", "[void]empty_capturing_group()", "[void]empty_non_capturing_group()", "[void]empty_look_ahead()", "[void]uses_loaded_pattern_compiler_service()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TreeRegexpTest {\n\n    @Test\n    public void exposes_group_source() {\n        TreeRegexp tr = new TreeRegexp(\"(a(?:b)?)(c)\");\n        List<String> list = new ArrayList<>();\n        for (GroupBuilder gb : tr.getGroupBuilder().getChildren()) {\n            String source = gb.getSource();\n            list.add(source);\n        }\n        assertEquals(asList(\"a(?:b)?\", \"c\"), list);\n    }\n\n    @Test\n    public void builds_tree() {\n        TreeRegexp tr = new TreeRegexp(\"(a(b(c))(d))\");\n        Group g = tr.match(\"abcd\");\n        assertEquals(\"abcd\", g.getChildren().get(0).getValue());\n        assertEquals(\"bc\", g.getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"c\", g.getChildren().get(0).getChildren().get(0).getChildren().get(0).getValue());\n        assertEquals(\"d\", g.getChildren().get(0).getChildren().get(1).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_colon_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?:b)(c)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void ignores_question_mark_exclamation_mark_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?!b)(.+)\");\n        Group g = tr.match(\"aBc\");\n        assertEquals(\"aBc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void ignores_question_mark_equal_sign_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?=b)(.+)\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_less_than_equal_sign_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<=c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_less_than_exclamation_mark_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(.+)(?<!b)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"bc\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void ignores_question_mark_greater_then_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?>b)(c)$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"c\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void matches_named_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(\"a(?<name>b)c$\");\n        Group g = tr.match(\"abc\");\n        assertEquals(\"abc\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n        assertEquals(\"b\", g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void matches_optional_group() {\n        TreeRegexp tr = new TreeRegexp(\"^Something( with an optional argument)?\");\n        Group g = tr.match(\"Something\");\n        assertNull(g.getChildren().get(0).getValue());\n    }\n\n    @Test\n    public void matches_nested_groups() {\n        TreeRegexp tr = new TreeRegexp(\"^A (\\\\d+) thick line from ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)) to ((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+))\");\n        Group g = tr.match(\"A 5 thick line from 10,20,30 to 40,50,60\");\n\n        assertEquals(\"5\", g.getChildren().get(0).getValue());\n        assertEquals(\"10,20,30\", g.getChildren().get(1).getValue());\n        assertEquals(\"10\", g.getChildren().get(1).getChildren().get(0).getValue());\n        assertEquals(\"20\", g.getChildren().get(1).getChildren().get(1).getValue());\n        assertEquals(\"30\", g.getChildren().get(1).getChildren().get(2).getValue());\n        assertEquals(\"40,50,60\", g.getChildren().get(2).getValue());\n        assertEquals(\"40\", g.getChildren().get(2).getChildren().get(0).getValue());\n        assertEquals(\"50\", g.getChildren().get(2).getChildren().get(1).getValue());\n        assertEquals(\"60\", g.getChildren().get(2).getChildren().get(2).getValue());\n    }\n\n    @Test\n    public void captures_non_capturing_groups_with_capturing_groups_inside() {\n        TreeRegexp tr = new TreeRegexp(\"the stdout(?: from \\\"(.*?)\\\")?\");\n        Group g = tr.match(\"the stdout\");\n        assertEquals(\"the stdout\", g.getValue());\n        assertNull(g.getChildren().get(0).getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void detects_multiple_non_capturing_groups() {\n        TreeRegexp tr = new TreeRegexp(\"(?:a)(:b)(\\\\?c)(d)\");\n        Group g = tr.match(\"a:b?cd\");\n        assertEquals(3, g.getChildren().size());\n    }\n\n    @Test\n    public void works_with_escaped_backslash() {\n        TreeRegexp tr = new TreeRegexp(\"foo\\\\\\\\(bar|baz)\");\n        Group g = tr.match(\"foo\\\\bar\");\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void works_with_slash_which_doesnt_need_escaping_in_java() {\n        TreeRegexp tr = new TreeRegexp(\"^I go to '/(.+)'$\");\n        Group g = tr.match(\"I go to '/hello'\");\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void works_digit_and_word() {\n        TreeRegexp tr = new TreeRegexp(\"^(\\\\d) (\\\\w+) (\\\\w+)$\");\n        Group g = tr.match(\"2 you \u043f\u0440\u0438\u0432\u0435\u0442\");\n        assertEquals(3, g.getChildren().size());\n    }\n\n    @Test\n    public void captures_start_and_end() {\n        TreeRegexp tr = new TreeRegexp(\"^the step \\\"([^\\\"]*)\\\" has status \\\"([^\\\"]*)\\\"$\");\n        Group g = tr.match(\"the step \\\"a pending step\\\" has status \\\"pending\\\"\");\n        assertEquals(10, g.getChildren().get(0).getStart());\n        assertEquals(24, g.getChildren().get(0).getEnd());\n        assertEquals(38, g.getChildren().get(1).getStart());\n        assertEquals(45, g.getChildren().get(1).getEnd());\n    }\n\n    @Test\n    public void doesnt_consider_parenthesis_in_character_class_as_group() {\n        TreeRegexp tr = new TreeRegexp(\"^drawings: ([A-Z_, ()]+)$\");\n        Group g = tr.match(\"drawings: FU(BAR)\");\n        assertEquals(\"drawings: FU(BAR)\", g.getValue());\n        assertEquals(\"FU(BAR)\", g.getChildren().get(0).getValue());\n        assertEquals(0, g.getChildren().get(0).getChildren().size());\n    }\n\n    @Test\n    public void works_with_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"HELLO\", Pattern.CASE_INSENSITIVE));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n    }\n\n    @Test\n    public void works_with_inline_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i)HELLO\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void works_with_non_capturing_inline_flags() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?i:HELLO)\"));\n        Group g = tr.match(\"hello\");\n        assertEquals(\"hello\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void empty_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"()\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(1, g.getChildren().size());\n    }\n\n    @Test\n    public void empty_non_capturing_group() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void empty_look_ahead() {\n        TreeRegexp tr = new TreeRegexp(Pattern.compile(\"(?<=)\"));\n        Group g = tr.match(\"\");\n        assertEquals(\"\", g.getValue());\n        assertEquals(0, g.getChildren().size());\n    }\n\n    @Test\n    public void uses_loaded_pattern_compiler_service() {\n        String regexp = \"[0-9]\";\n        TreeRegexp tr = new TreeRegexp(regexp);\n        assertNull(tr.match(\"1a\"));\n\n        PatternCompilerProvider.service = (re, flags) -> Pattern.compile(re + \"[a-z]\", flags);\n\n        tr = new TreeRegexp(regexp);\n        assertEquals(\"1a\", tr.match(\"1a\").getValue());\n        PatternCompilerProvider.service = null;\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_preferForRegexpMatchTest.java.ParameterType_preferForRegexpMatchTest", "name": "ParameterType_preferForRegexpMatchTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_preferForRegexpMatchTest.java", "superclasses": "", "methods": ["[void]testPreferForRegexpMatch_True()", "[void]testPreferForRegexpMatch_False()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ParameterType_preferForRegexpMatchTest {\n\n    @Test\n    public void testPreferForRegexpMatch_True() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                true\n        );\n        assertTrue(parameterType.preferForRegexpMatch());\n    }\n\n    @Test\n    public void testPreferForRegexpMatch_False() {\n        ParameterType<Object> parameterType = new ParameterType<>(\n                \"name\",\n                singletonList(\"regexp\"),\n                Object.class,\n                new CaptureGroupTransformer<Object>() {\n                    @Override\n                    public Object transform(String[] args) {\n                        return null;\n                    }\n                },\n                true,\n                false\n        );\n        assertFalse(parameterType.preferForRegexpMatch());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionParserTest.java.CucumberExpressionParserTest", "name": "CucumberExpressionParserTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionParserTest.java", "superclasses": "", "methods": ["[void]acceptance_tests_pass(Expectation)"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionParserTest.java.CucumberExpressionParserTest.[List<Path>]acceptance_tests_pass()"], "overrides": null, "attributes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public YamlableNode expected_ast;\n        public String exception;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public YamlableNode expected_ast;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "YamlableNode", "name": "expected_ast", "syntax_pass": true}, {"attribute_expression": "public String exception;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "exception", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}, {"original_string": "    static class YamlableNode {\n        public Ast.Node.Type type;\n        public List<YamlableNode> nodes;\n        public String token;\n        public int start;\n        public int end;\n\n        public Node toNode() {\n            if (token != null) {\n                return new Node(type, start, end, token);\n            } else {\n                return new Node(type, start, end, nodes.stream().map(YamlableNode::toNode).collect(Collectors.toList()));\n            }\n        }\n    }", "definition": "    static class YamlableNode", "class_docstring": "", "name": "YamlableNode", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public Ast.Node.Type type;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Ast.Node.Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "public List<YamlableNode> nodes;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "List<YamlableNode>", "name": "nodes", "syntax_pass": true}, {"attribute_expression": "public String token;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "token", "syntax_pass": true}, {"attribute_expression": "public int start;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "public int end;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Node toNode() {\n            if (token != null) {\n                return new Node(type, start, end, token);\n            } else {\n                return new Node(type, start, end, nodes.stream().map(YamlableNode::toNode).collect(Collectors.toList()));\n            }\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Node", "classes": []}, "name": "toNode", "params": [], "body": "                             {\n            if (token != null) {\n                return new Node(type, start, end, token);\n            } else {\n                return new Node(type, start, end, nodes.stream().map(YamlableNode::toNode).collect(Collectors.toList()));\n            }\n        }", "signature": "public Node toNode()"}]}], "class_docstring": "", "original_string": "class CucumberExpressionParserTest {\n\n    private final CucumberExpressionParser parser = new CucumberExpressionParser();\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"parser\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            Node node = parser.parse(expectation.expression);\n            assertThat(node, is(expectation.expected_ast.toNode()));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> parser.parse(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }\n\n    static class Expectation {\n        public String expression;\n        public YamlableNode expected_ast;\n        public String exception;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    static class YamlableNode {\n        public Ast.Node.Type type;\n        public List<YamlableNode> nodes;\n        public String token;\n        public int start;\n        public int end;\n\n        public Node toNode() {\n            if (token != null) {\n                return new Node(type, start, end, token);\n            } else {\n                return new Node(type, start, end, nodes.stream().map(YamlableNode::toNode).collect(Collectors.toList()));\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final CucumberExpressionParser parser = new CucumberExpressionParser();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CucumberExpressionParser", "name": "parser = new CucumberExpressionParser()", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizerTest.java.CucumberExpressionTokenizerTest", "name": "CucumberExpressionTokenizerTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizerTest.java", "superclasses": "", "methods": ["[void]acceptance_tests_pass(Expectation)"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizerTest.java.CucumberExpressionTokenizerTest.[List<Path>]acceptance_tests_pass()"], "overrides": null, "attributes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public List<YamlableToken> expected_tokens;\n        public String exception;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public List<YamlableToken> expected_tokens;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "List<YamlableToken>", "name": "expected_tokens", "syntax_pass": true}, {"attribute_expression": "public String exception;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "exception", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}, {"original_string": "    static class YamlableToken {\n        public String text;\n        public Token.Type type;\n        public int start;\n        public int end;\n\n        public Token toToken() {\n            return new Token(text, type, start, end);\n        }\n    }", "definition": "    static class YamlableToken", "class_docstring": "", "name": "YamlableToken", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String text;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}, {"attribute_expression": "public Token.Type type;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "Token.Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "public int start;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "public int end;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Token toToken() {\n            return new Token(text, type, start, end);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Token", "classes": []}, "name": "toToken", "params": [], "body": "                               {\n            return new Token(text, type, start, end);\n        }", "signature": "public Token toToken()"}]}], "class_docstring": "", "original_string": "class CucumberExpressionTokenizerTest {\n\n    private final CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"cucumber-expression\", \"tokenizer\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        if (expectation.exception == null) {\n            List<Token> tokens = tokenizer.tokenize(expectation.expression);\n            List<Token> expectedTokens = expectation.expected_tokens\n                    .stream()\n                    .map(YamlableToken::toToken)\n                    .collect(Collectors.toList());\n            assertThat(tokens, is(expectedTokens));\n        } else {\n            CucumberExpressionException exception = assertThrows(\n                    CucumberExpressionException.class,\n                    () -> tokenizer.tokenize(expectation.expression));\n            assertThat(exception.getMessage(), is(expectation.exception));\n        }\n    }\n\n    static class Expectation {\n        public String expression;\n        public List<YamlableToken> expected_tokens;\n        public String exception;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    static class YamlableToken {\n        public String text;\n        public Token.Type type;\n        public int start;\n        public int end;\n\n        public Token toToken() {\n            return new Token(text, type, start, end);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CucumberExpressionTokenizer", "name": "tokenizer = new CucumberExpressionTokenizer()", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactoryTest.java.CombinatorialGeneratedExpressionFactoryTest", "name": "CombinatorialGeneratedExpressionFactoryTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactoryTest.java", "superclasses": "", "methods": ["[void]generates_multiple_expressions()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    public static class Color {\n        Color(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Color", "class_docstring": "", "name": "Color", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Color(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Color", "params": [{"name": "s", "type": "String"}], "body": "                        {\n            assertNotNull(s);\n        }", "signature": "Color(String s)"}]}, {"original_string": "    public static class CssColor {\n        CssColor(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class CssColor", "class_docstring": "", "name": "CssColor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        CssColor(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CssColor", "params": [{"name": "s", "type": "String"}], "body": "                           {\n            assertNotNull(s);\n        }", "signature": "CssColor(String s)"}]}, {"original_string": "    public static class Date {\n        Date(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Date", "class_docstring": "", "name": "Date", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Date(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Date", "params": [{"name": "s", "type": "String"}], "body": "                       {\n            assertNotNull(s);\n        }", "signature": "Date(String s)"}]}, {"original_string": "    public static class DateTime {\n        DateTime(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class DateTime", "class_docstring": "", "name": "DateTime", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        DateTime(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DateTime", "params": [{"name": "s", "type": "String"}], "body": "                           {\n            assertNotNull(s);\n        }", "signature": "DateTime(String s)"}]}, {"original_string": "    public static class Timestamp {\n        Timestamp(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Timestamp", "class_docstring": "", "name": "Timestamp", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Timestamp(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Timestamp", "params": [{"name": "s", "type": "String"}], "body": "                            {\n            assertNotNull(s);\n        }", "signature": "Timestamp(String s)"}]}], "class_docstring": "", "original_string": "public class CombinatorialGeneratedExpressionFactoryTest {\n\n    private static final String WORD = \"\\\\w+\";\n\n    @Test\n    public void generates_multiple_expressions() {\n        List<ParameterType<?>> first = new ArrayList<>();\n        first.add(new ParameterType<>(\"color\", WORD, Color.class, Color::new));\n        first.add(new ParameterType<>(\"csscolor\", WORD, CssColor.class, CssColor::new));\n\n        List<ParameterType<?>> second = new ArrayList<>();\n        second.add(new ParameterType<>(\"date\", WORD, Date.class, Date::new));\n        second.add(new ParameterType<>(\"datetime\", WORD, DateTime.class, DateTime::new));\n        second.add(new ParameterType<>(\"timestamp\", WORD, Timestamp.class, Timestamp::new));\n        List<List<ParameterType<?>>> parameterTypeCombinations = asList(first, second);\n\n        CombinatorialGeneratedExpressionFactory factory = new CombinatorialGeneratedExpressionFactory(\n                \"I bought a {%s} ball on {%s}\",\n                parameterTypeCombinations\n        );\n        List<GeneratedExpression> generatedExpressions = factory.generateExpressions();\n        List<String> expressions = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            expressions.add(source);\n        }\n        assertEquals(asList(\n                \"I bought a {color} ball on {date}\",\n                \"I bought a {color} ball on {datetime}\",\n                \"I bought a {color} ball on {timestamp}\",\n                \"I bought a {csscolor} ball on {date}\",\n                \"I bought a {csscolor} ball on {datetime}\",\n                \"I bought a {csscolor} ball on {timestamp}\"\n        ), expressions);\n    }\n\n    public static class Color {\n        Color(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class CssColor {\n        CssColor(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Date {\n        Date(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class DateTime {\n        DateTime(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Timestamp {\n        Timestamp(String s) {\n            assertNotNull(s);\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String WORD = \"\\\\w+\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "WORD = \"\\\\w+\"", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_useForSnippetsTest.java.ParameterType_useForSnippetsTest", "name": "ParameterType_useForSnippetsTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_useForSnippetsTest.java", "superclasses": "", "methods": ["[void]testUseForSnippetsTrue()", "[void]testUseForSnippetsFalse()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/ParameterType_useForSnippetsTest.java.ParameterType_useForSnippetsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ParameterType_useForSnippetsTest {\n\n    private ParameterType<?> parameterType;\n\n    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, true, false);\n    }\n\n    @Test\n    public void testUseForSnippetsTrue() {\n        assertTrue(parameterType.useForSnippets());\n    }\n\n    @Test\n    public void testUseForSnippetsFalse() {\n        ParameterType<?> parameterTypeFalse = new ParameterType<>(\"name\", \"regexp\", String.class, (String arg) -> arg, false, false);\n        assertFalse(parameterTypeFalse.useForSnippets());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ParameterType<?> parameterType;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterType<?>", "name": "parameterType", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactory_createExpressionTest.java.ExpressionFactory_createExpressionTest", "name": "ExpressionFactory_createExpressionTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ExpressionFactory_createExpressionTest.java", "superclasses": "", "methods": ["[void]testCreateExpression_EmptyString()", "[void]testCreateExpression_RegularExpressionWithAnchors()", "[void]testCreateExpression_RegularExpressionWithSlashes()", "[void]testCreateExpression_CucumberExpression()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ExpressionFactory_createExpressionTest {\n\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.getDefault());\n    private final ExpressionFactory expressionFactory = new ExpressionFactory(parameterTypeRegistry);\n\n    @Test\n    void testCreateExpression_EmptyString() {\n        Expression expression = expressionFactory.createExpression(\"\");\n        assertTrue(expression instanceof CucumberExpression);\n    }\n\n    @Test\n    void testCreateExpression_RegularExpressionWithAnchors() {\n        Expression expression = expressionFactory.createExpression(\"^start$\");\n        assertTrue(expression instanceof RegularExpression);\n    }\n\n    @Test\n    void testCreateExpression_RegularExpressionWithSlashes() {\n        Expression expression = expressionFactory.createExpression(\"/regex/\");\n        assertTrue(expression instanceof RegularExpression);\n    }\n\n    @Test\n    void testCreateExpression_CucumberExpression() {\n        Expression expression = expressionFactory.createExpression(\"some text\");\n        assertTrue(expression instanceof CucumberExpression);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.getDefault());", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.getDefault())", "syntax_pass": true}, {"attribute_expression": "private final ExpressionFactory expressionFactory = new ExpressionFactory(parameterTypeRegistry);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ExpressionFactory", "name": "expressionFactory = new ExpressionFactory(parameterTypeRegistry)", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeComparatorTest.java.ParameterTypeComparatorTest", "name": "ParameterTypeComparatorTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeComparatorTest.java", "superclasses": "", "methods": ["[void]sorts_parameter_types_by_preferential_then_name()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    public static class A {\n        A(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class A", "class_docstring": "", "name": "A", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        A(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "A", "params": [{"name": "s", "type": "String"}], "body": "                    {\n            assertNotNull(s);\n        }", "signature": "A(String s)"}]}, {"original_string": "    public static class B {\n        B(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class B", "class_docstring": "", "name": "B", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        B(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "B", "params": [{"name": "s", "type": "String"}], "body": "                    {\n            assertNotNull(s);\n        }", "signature": "B(String s)"}]}, {"original_string": "    public static class C {\n        C(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class C", "class_docstring": "", "name": "C", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        C(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "C", "params": [{"name": "s", "type": "String"}], "body": "                    {\n            assertNotNull(s);\n        }", "signature": "C(String s)"}]}, {"original_string": "    public static class D {\n        D(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class D", "class_docstring": "", "name": "D", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        D(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "D", "params": [{"name": "s", "type": "String"}], "body": "                    {\n            assertNotNull(s);\n        }", "signature": "D(String s)"}]}], "class_docstring": "", "original_string": "public class ParameterTypeComparatorTest {\n\n    public static class A {\n        A(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class B {\n        B(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class C {\n        C(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class D {\n        D(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    @Test\n    public void sorts_parameter_types_by_preferential_then_name() {\n        SortedSet<ParameterType<?>> set = new TreeSet<>();\n        set.add(new ParameterType<>(\"c\", \"c\", C.class, C::new, false, true));\n        set.add(new ParameterType<>(\"a\", \"a\", A.class, A::new, false, false));\n        set.add(new ParameterType<>(\"d\", \"d\", D.class, D::new, false, false));\n        set.add(new ParameterType<>(\"b\", \"b\", B.class, B::new, false, true));\n\n        List<String> names = new ArrayList<>();\n        for (ParameterType parameterType : set) {\n            names.add(parameterType.getName());\n        }\n        assertEquals(asList(\"b\", \"c\", \"a\", \"d\"), names);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformerTest.java.BuiltInParameterTransformerTest", "name": "BuiltInParameterTransformerTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformerTest.java", "superclasses": "", "methods": ["[void]simple_object_mapper_only_supports_class_types()", "[void]simple_object_mapper_only_supports_some_class_types()", "[void]simple_object_mapper_only_supports_some_optional_types()", "[void]simple_object_mapper_only_supports_some_generic_types()", "[void]should_throw_exception_for_unknown_enum_values()", "[void]should_transform_boolean()", "[void]should_transform_char()", "[void]should_throw_exception_for_empty_string_with_type_char()", "[void]should_throw_exception_for_nonsingelchar_string_with_type_char()", "[void]should_transform_optional()", "[void]should_transform_optional_generic_string()", "[void]should_transform_optional_generic_integer()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BuiltInParameterTransformerTest {\n\n    private final BuiltInParameterTransformer objectMapper = new BuiltInParameterTransformer(ENGLISH);\n\n    @Test\n    public void simple_object_mapper_only_supports_class_types() {\n\n        Type abstractListOfE = ArrayList.class.getGenericSuperclass();\n        final Executable testMethod = () -> objectMapper.transform(\"something\", abstractListOfE);\n\n        String expected = \"\" +\n                \"Can't transform 'something' to java.util.AbstractList<E>\\n\" +\n                \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                \"Consider using a different object mapper or register a parameter type for java.util.AbstractList<E>\";\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }\n\n    @Test\n    public void simple_object_mapper_only_supports_some_class_types() {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", Date.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class java.util.Date\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.util.Date\"\n        )));\n    }\n\n    @Test\n    public void simple_object_mapper_only_supports_some_optional_types() {\n        Type optionalDate = new TypeReference<Optional<Date>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.Optional<java.util.Date>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.Optional<java.util.Date>\"\n        )));\n    }\n\n    @Test\n    public void simple_object_mapper_only_supports_some_generic_types() {\n        Type optionalDate = new TypeReference<Supplier<String>>() {}.getType();\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", optionalDate);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to java.util.function.Supplier<java.lang.String>\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for java.util.function.Supplier<java.lang.String>\"\n        )));\n    }\n\n    @Test\n    public void should_throw_exception_for_unknown_enum_values() {\n\n        final Executable testMethod = () -> objectMapper.transform(\"something\", TestEnum.class);\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'something' to class io.cucumber.cucumberexpressions.BuiltInParameterTransformerTest$TestEnum. \" +\n                        \"Not an enum constant\"\n        )));\n    }\n\n    @Test\n    public void should_transform_boolean() {\n        for (String value : Arrays.asList(\"true\", \"True\", \"false\", \"False\")) {\n            objectMapper.transform(value, Boolean.class);\n        }\n    }\n\n    @Test\n    public void should_transform_char() {\n        assertThat(objectMapper.transform(\"A\", char.class), is(equalTo('A')));\n        assertThat(objectMapper.transform(\"b\", Character.class), is(equalTo('b')));\n    }\n\n    @Test\n    public void should_throw_exception_for_empty_string_with_type_char() {\n        final Executable testMethod = () -> objectMapper.transform(\"\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform '' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }\n\n    @Test\n    public void should_throw_exception_for_nonsingelchar_string_with_type_char() {\n        Executable testMethod = () -> objectMapper.transform(\"ab\", Character.class);\n\n        final IllegalArgumentException thrownException = assertThrows(IllegalArgumentException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\n                \"Can't transform 'ab' to class java.lang.Character\\nBuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for class java.lang.Character\"\n        )));\n    }\n\n    @Test\n    public void should_transform_optional() {\n        assertThat(objectMapper.transform(\"abc\", Optional.class), is(equalTo(Optional.of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", Optional.class), is(equalTo(Optional.of(\"\"))));\n        assertThat(objectMapper.transform(null, Optional.class), is(equalTo(Optional.empty())));\n    }\n\n    @Test\n    public void should_transform_optional_generic_string() {\n        Type optionalStringType = new TypeReference<Optional<String>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"abc\", optionalStringType), is(equalTo(Optional.<String>of(\"abc\"))));\n        assertThat(objectMapper.transform(\"\", optionalStringType), is(equalTo(Optional.<String>of(\"\"))));\n        assertThat(objectMapper.transform(null, optionalStringType), is(equalTo(Optional.<String>empty())));\n    }\n\n    @Test\n    public void should_transform_optional_generic_integer() {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {}.getType();\n\n        assertThat(objectMapper.transform(\"42\", optionalIntType), is(equalTo(Optional.<Integer>of(42))));\n        assertThat(objectMapper.transform(null, optionalIntType), is(equalTo(Optional.<Integer>empty())));\n    }\n\n    private enum TestEnum {\n        TEST\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BuiltInParameterTransformer objectMapper = new BuiltInParameterTransformer(ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BuiltInParameterTransformer", "name": "objectMapper = new BuiltInParameterTransformer(ENGLISH)", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getSourceTest.java.CucumberExpression_getSourceTest", "name": "CucumberExpression_getSourceTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getSourceTest.java", "superclasses": "", "methods": ["[void]testGetSource()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/CucumberExpression_getSourceTest.java.CucumberExpression_getSourceTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CucumberExpression_getSourceTest {\n    private ParameterTypeRegistry parameterTypeRegistry;\n\n    @BeforeEach\n    public void setUp() {\n        parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n    }\n\n    @Test\n    public void testGetSource() {\n        String expressionString = \"some expression\";\n        CucumberExpression cucumberExpression = new CucumberExpression(expressionString, parameterTypeRegistry);\n        assertEquals(expressionString, cucumberExpression.getSource());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java.RegularExpressionTest", "name": "RegularExpressionTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java", "superclasses": "", "methods": ["[void]acceptance_tests_pass(Expectation)", "[void]documentation_match_arguments()", "[void]matches_positive_int()", "[void]matches_positive_int_with_hint()", "[void]matches_positive_int_with_conflicting_type_hint()", "[void]matches_nested_capture_group_without_match()", "[void]matches_nested_capture_group_with_match()", "[void]ignores_non_capturing_groups()", "[void]matches_capture_group_nested_in_optional_one()", "[void]works_with_escaped_parenthesis()", "[void]exposes_source_and_regexp()", "[void]uses_float_type_hint_when_group_doesnt_match_known_param_type()", "[void]uses_double_type_hint_when_group_doesnt_match_known_param_type()", "[void]matches_empty_string()", "[void]uses_two_type_hints_to_resolve_anonymous_parameter_type()", "[void]retains_all_content_captured_by_the_capture_group()", "[void]uses_parameter_type_registry_when_parameter_type_is_defined()", "[void]ignores_type_hint_when_parameter_type_has_strong_type_hint()", "[void]follows_type_hint_when_parameter_type_does_not_have_strong_type_hint()", "[void]matches_anonymous_parameter_type_with_hint()", "[void]matches_anonymous_parameter_type()", "[void]matches_optional_boolean_capture_group()", "[void]parameter_types_can_be_optional_when_used_in_regex()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java.RegularExpressionTest.[List<Path>]acceptance_tests_pass()", "src/test/java/io/cucumber/cucumberexpressions/RegularExpressionTest.java.RegularExpressionTest.[List<?>]match(Pattern,String)"], "overrides": null, "attributes": [{"original_string": "    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n    }", "definition": "    static class Expectation", "class_docstring": "", "name": "Expectation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "public String expression;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "public String text;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}, {"attribute_expression": "public List<?> expected_args;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "List<?>", "name": "expected_args", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }", "definition": "    static class Converter implements ArgumentConverter", "class_docstring": "", "name": "Converter", "super_interfaces": ["ArgumentConverter"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Yaml yaml = new Yaml();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Yaml", "name": "yaml = new Yaml()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Expectation", "classes": []}, "name": "convert", "params": [{"name": "source", "type": "Object"}, {"name": "context", "type": "ParameterContext"}], "body": "                                                                                                               {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }", "signature": "@Override\n        public Expectation convert(Object source, ParameterContext context)"}]}], "class_docstring": "", "original_string": "public class RegularExpressionTest {\n\n    private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    private static List<Path> acceptance_tests_pass() throws IOException {\n        List<Path> paths = new ArrayList<>();\n        newDirectoryStream(Paths.get(\"..\", \"testdata\", \"regular-expression\", \"matching\")).forEach(paths::add);\n        paths.sort(Comparator.naturalOrder());\n        return paths;\n    }\n\n    @ParameterizedTest\n    @MethodSource\n    void acceptance_tests_pass(@ConvertWith(Converter.class) Expectation expectation) {\n        RegularExpression expression = new RegularExpression(Pattern.compile(expectation.expression), parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(expectation.text);\n        List<?> values = match == null ? null : match.stream()\n                .map(Argument::getValue)\n                .collect(Collectors.toList());\n\n        assertThat(values, CustomMatchers.equalOrCloseTo(expectation.expected_args));\n    }\n\n    static class Expectation {\n        public String expression;\n        public String text;\n        public List<?> expected_args;\n    }\n\n    static class Converter implements ArgumentConverter {\n        Yaml yaml = new Yaml();\n\n        @Override\n        public Expectation convert(Object source, ParameterContext context) throws ArgumentConversionException {\n            try {\n                Path path = (Path) source;\n                InputStream inputStream = newInputStream(path);\n                return yaml.loadAs(inputStream, Expectation.class);\n            } catch (IOException e) {\n                throw new ArgumentConversionException(\"Could not load \" + source, e);\n            }\n        }\n    }\n\n    @Test\n    public void documentation_match_arguments() {\n        Pattern expr = Pattern.compile(\"I have (\\\\d+) cukes? in my (\\\\w+) now\");\n        Expression expression = new RegularExpression(expr, parameterTypeRegistry);\n        List<Argument<?>> match = expression.match(\"I have 7 cukes in my belly now\");\n        assertEquals(7, match.get(0).getValue());\n        assertEquals(\"belly\", match.get(1).getValue());\n    }\n\n    @Test\n    public void matches_positive_int() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\");\n        assertEquals(singletonList(22), match);\n    }\n\n    @Test\n    public void matches_positive_int_with_hint() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", Integer.class);\n        assertEquals(singletonList(22), match);\n    }\n\n    @Test\n    public void matches_positive_int_with_conflicting_type_hint() {\n        List<?> match = match(compile(\"(\\\\d+)\"), \"22\", String.class);\n        assertEquals(singletonList(\"22\"), match);\n    }\n\n    @Test\n    public void matches_nested_capture_group_without_match() {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user\");\n        assertEquals(singletonList(null), match);\n    }\n\n    @Test\n    public void matches_nested_capture_group_with_match() {\n        List<?> match = match(compile(\"^a user( named \\\"([^\\\"]*)\\\")?$\"), \"a user named \\\"Charlie\\\"\");\n        assertEquals(singletonList(\"Charlie\"), match);\n    }\n\n    @Test\n    public void ignores_non_capturing_groups() {\n        String expr = \"(\\\\S+) ?(can|cannot)? (?:delete|cancel) the (\\\\d+)(?:st|nd|rd|th) (attachment|slide) ?(?:upload)?\";\n        String step = \"I can cancel the 1st slide upload\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(asList(\"I\", \"can\", 1, \"slide\"), match);\n    }\n\n    @Test\n    public void matches_capture_group_nested_in_optional_one() {\n        String regex = \"^a (pre-commercial transaction |pre buyer fee model )?purchase(?: for \\\\$(\\\\d+))?$\";\n        assertEquals(asList(null, null), match(compile(regex), \"a purchase\"));\n        assertEquals(asList(null, 33), match(compile(regex), \"a purchase for $33\"));\n        assertEquals(asList(\"pre buyer fee model \", null), match(compile(regex), \"a pre buyer fee model purchase\"));\n    }\n\n    @Test\n    public void works_with_escaped_parenthesis() {\n        String expr = \"Across the line\\\\(s\\\\)\";\n        String step = \"Across the line(s)\";\n        List<?> match = match(compile(expr), step);\n        assertEquals(emptyList(), match);\n    }\n\n    @Test\n    public void exposes_source_and_regexp() {\n        String regexp = \"I have (\\\\d+) cukes? in my (.+) now\";\n        RegularExpression expression = new RegularExpression(Pattern.compile(regexp),\n                new ParameterTypeRegistry(Locale.ENGLISH));\n        assertEquals(regexp, expression.getSource());\n        assertEquals(regexp, expression.getRegexp().pattern());\n    }\n\n    @Test\n    public void uses_float_type_hint_when_group_doesnt_match_known_param_type() {\n        List<?> match = match(compile(\"a (.*)\"), \"a 22\", Float.class);\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n    }\n\n    @Test\n    public void uses_double_type_hint_when_group_doesnt_match_known_param_type() {\n        List<?> match = match(compile(\"a (\\\\d\\\\d.\\\\d)\"), \"a 33.5\", Double.class);\n        assertEquals(Double.class, match.get(0).getClass());\n        assertEquals(33.5d, (Double) match.get(0), 0.00001);\n    }\n\n    @Test\n    public void matches_empty_string() {\n        List<?> match = match(compile(\"^The value equals \\\"([^\\\"]*)\\\"$\"), \"The value equals \\\"\\\"\", String.class);\n        assertEquals(String.class, match.get(0).getClass());\n        assertEquals(\"\", match.get(0));\n    }\n\n    @Test\n    public void uses_two_type_hints_to_resolve_anonymous_parameter_type() {\n        List<?> match = match(compile(\"a (.*) and a (.*)\"), \"a 22 and a 33.5\", Float.class, Double.class);\n\n        assertEquals(Float.class, match.get(0).getClass());\n        assertEquals(22f, (Float) match.get(0), 0.00001);\n\n        assertEquals(Double.class, match.get(1).getClass());\n        assertEquals(33.5d, (Double) match.get(1), 0.00001);\n    }\n\n    @Test\n    public void retains_all_content_captured_by_the_capture_group() {\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" and quote \\\"\"), match);\n    }\n\n    @Test\n    public void uses_parameter_type_registry_when_parameter_type_is_defined() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"[\\\"a-z ]+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s.toUpperCase();\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"a quote ([\\\"a-z ]+)\"), \"a quote \\\" and quote \\\"\", String.class);\n        assertEquals(singletonList(\"\\\" AND QUOTE \\\"\"), match);\n    }\n\n    @Test\n    public void ignores_type_hint_when_parameter_type_has_strong_type_hint() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, true\n        ));\n        assertEquals(asList(42), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }\n\n    @Test\n    public void follows_type_hint_when_parameter_type_does_not_have_strong_type_hint() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \"one|two|three\",\n                Integer.class,\n                new Transformer<Integer>() {\n                    @Override\n                    public Integer transform(String s) {\n                        return 42;\n                    }\n                }, false, false, false\n        ));\n        assertEquals(asList(\"one\"), match(compile(\"(one|two|three)\"), \"one\", String.class));\n    }\n\n    @Test\n    public void matches_anonymous_parameter_type_with_hint() {\n        assertEquals(singletonList(0.22f), match(compile(\"(.*)\"), \"0.22\", Float.class));\n    }\n\n    @Test\n    public void matches_anonymous_parameter_type() {\n        assertEquals(singletonList(\"0.22\"), match(compile(\"(.*)\"), \"0.22\"));\n    }\n\n    @Test\n    public void matches_optional_boolean_capture_group() {\n        Pattern pattern = compile(\"^(true|false)?$\");\n        assertEquals(singletonList(true), match(pattern, \"true\", Boolean.class));\n        assertEquals(singletonList(false), match(pattern, \"false\", Boolean.class));\n        assertEquals(singletonList(null), match(pattern, \"\", Boolean.class));\n    }\n\n    @Test\n    public void parameter_types_can_be_optional_when_used_in_regex() {\n        parameterTypeRegistry.defineParameterType(new ParameterType<>(\n                \"test\",\n                \".+\",\n                String.class,\n                new Transformer<String>() {\n                    @Override\n                    public String transform(String s) {\n                        return s;\n                    }\n                }\n        ));\n        List<?> match = match(compile(\"^text(?: (.+))? text2$\"), \"text text2\", String.class);\n        assertEquals(singletonList(null), match);\n    }\n\n    private List<?> match(Pattern pattern, String text, Type... types) {\n        RegularExpression regularExpression = new RegularExpression(pattern, parameterTypeRegistry);\n        List<Argument<?>> arguments = regularExpression.match(text, types);\n        List<Object> values = new ArrayList<>();\n        for (Argument<?> argument : arguments) {\n            values.add(argument.getValue());\n        }\n        return values;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistryTest.java.ParameterTypeRegistryTest", "name": "ParameterTypeRegistryTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterTypeRegistryTest.java", "superclasses": "", "methods": ["[void]does_not_allow_more_than_one_preferential_parameter_type_for_each_regexp()", "[void]looks_up_preferential_parameter_type_by_regexp()", "[void]throws_ambiguous_exception_on_lookup_when_no_parameter_types_are_preferential()", "[void]does_not_allow_anonymous_parameter_type_to_be_registered()", "[void]parse_decimal_numbers_in_english()", "[void]parse_decimal_numbers_in_german()", "[void]parse_decimal_numbers_in_canadian_french()", "[void]parse_decimal_numbers_in_norwegian()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    public static class Name {\n        Name(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Name", "class_docstring": "", "name": "Name", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Name(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Name", "params": [{"name": "s", "type": "String"}], "body": "                       {\n            assertNotNull(s);\n        }", "signature": "Name(String s)"}]}, {"original_string": "    public static class Person {\n        Person(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Person", "class_docstring": "", "name": "Person", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Person(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Person", "params": [{"name": "s", "type": "String"}], "body": "                         {\n            assertNotNull(s);\n        }", "signature": "Person(String s)"}]}, {"original_string": "    public static class Place {\n        Place(String s) {\n            assertNotNull(s);\n        }\n    }", "definition": "    public static class Place", "class_docstring": "", "name": "Place", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Place(String s) {\n            assertNotNull(s);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Place", "params": [{"name": "s", "type": "String"}], "body": "                        {\n            assertNotNull(s);\n        }", "signature": "Place(String s)"}]}], "class_docstring": "", "original_string": "public class ParameterTypeRegistryTest {\n\n    private static final String CAPITALISED_WORD = \"[A-Z]+\\\\w+\";\n\n    public static class Name {\n        Name(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Person {\n        Person(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    public static class Place {\n        Place(String s) {\n            assertNotNull(s);\n        }\n    }\n\n    private final ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);\n\n    @Test\n    public void does_not_allow_more_than_one_preferential_parameter_type_for_each_regexp() {\n\n        registry.defineParameterType(new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, true));\n        registry.defineParameterType(new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, false));\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\n                \"place\",\n                CAPITALISED_WORD,\n                Place.class,\n                Place::new,\n                false,\n                true\n        ));\n\n        final CucumberExpressionException thrownException = assertThrows(CucumberExpressionException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"There can only be one preferential parameter type per regexp. The regexp /[A-Z]+\\\\w+/ is used for two preferential parameter types, {name} and {place}\")));\n    }\n\n    @Test\n    public void looks_up_preferential_parameter_type_by_regexp() {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, false, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, false, true);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, false, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n        assertSame(person, registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\"));\n    }\n\n    @Test\n    public void throws_ambiguous_exception_on_lookup_when_no_parameter_types_are_preferential() {\n        ParameterType<Name> name = new ParameterType<>(\"name\", CAPITALISED_WORD, Name.class, Name::new, true, false);\n        ParameterType<Person> person = new ParameterType<>(\"person\", CAPITALISED_WORD, Person.class, Person::new, true, false);\n        ParameterType<Place> place = new ParameterType<>(\"place\", CAPITALISED_WORD, Place.class, Place::new, true, false);\n        registry.defineParameterType(name);\n        registry.defineParameterType(person);\n        registry.defineParameterType(place);\n\n        String expected = \"\" +\n                \"Your Regular Expression /([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)/\\n\" +\n                \"matches multiple parameter types with regexp /[A-Z]+\\\\w+/:\\n\" +\n                \"   {name}\\n\" +\n                \"   {person}\\n\" +\n                \"   {place}\\n\" +\n                \"\\n\" +\n                \"I couldn't decide which one to use. You have two options:\\n\" +\n                \"\\n\" +\n                \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                \"   {name} and {name}\\n\" +\n                \"   {name} and {person}\\n\" +\n                \"   {name} and {place}\\n\" +\n                \"   {person} and {name}\\n\" +\n                \"   {person} and {person}\\n\" +\n                \"   {person} and {place}\\n\" +\n                \"   {place} and {name}\\n\" +\n                \"   {place} and {person}\\n\" +\n                \"   {place} and {place}\\n\" +\n                \"\\n\" +\n                \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                \"\\n\";\n\n        final Executable testMethod = () -> registry.lookupByRegexp(CAPITALISED_WORD, Pattern.compile(\"([A-Z]+\\\\w+) and ([A-Z]+\\\\w+)\"), \"Lisa and Bob\");\n\n        final AmbiguousParameterTypeException thrownException = assertThrows(AmbiguousParameterTypeException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(expected)));\n    }\n\n    @Test\n    public void does_not_allow_anonymous_parameter_type_to_be_registered() {\n\n        final Executable testMethod = () -> registry.defineParameterType(new ParameterType<>(\"\", \".*\", Object.class, (Transformer<Object>) arg -> arg));\n\n        final DuplicateTypeNameException thrownException = assertThrows(DuplicateTypeNameException.class, testMethod);\n        assertThat(\"Unexpected message\", thrownException.getMessage(), is(equalTo(\"The anonymous parameter type has already been defined\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_english() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.ENGLISH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"\"), nullValue());\n        assertThat(expression.match(\".\"), nullValue());\n        assertThat(expression.match(\",\"), nullValue());\n        assertThat(expression.match(\"-\"), nullValue());\n        assertThat(expression.match(\"E\"), nullValue());\n        assertThat(expression.match(\"1,\"), nullValue());\n        assertThat(expression.match(\",1\"), nullValue());\n        assertThat(expression.match(\"1.\"), nullValue());\n\n        assertThat(expression.match(\"1\").get(0).getValue(), is(BigDecimal.ONE));\n        assertThat(expression.match(\"-1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"1.1\").get(0).getValue(), is(new BigDecimal(\"1.1\")));\n        assertThat(expression.match(\"1,000\").get(0).getValue(), is(new BigDecimal(\"1000\")));\n        assertThat(expression.match(\"1,000,0\").get(0).getValue(), is(new BigDecimal(\"10000\")));\n        assertThat(expression.match(\"1,000.1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1,000,10\").get(0).getValue(), is(new BigDecimal(\"100010\")));\n        assertThat(expression.match(\"1,0.1\").get(0).getValue(), is(new BigDecimal(\"10.1\")));\n        assertThat(expression.match(\"1,000,000.1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1.1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n\n        assertThat(expression.match(\".1\").get(0).getValue(), is(new BigDecimal(\"0.1\")));\n        assertThat(expression.match(\"-.1\").get(0).getValue(), is(new BigDecimal(\"-0.1\")));\n        assertThat(expression.match(\"-.10000001\").get(0).getValue(), is(new BigDecimal(\"-0.10000001\")));\n        assertThat(expression.match(\"1E1\").get(0).getValue(), is(new BigDecimal(\"1E1\"))); // precision 1 with scale -1, can not be expressed as a decimal\n        assertThat(expression.match(\".1E1\").get(0).getValue(), is(new BigDecimal(\"1\")));\n        assertThat(expression.match(\"E1\"), nullValue());\n        assertThat(expression.match(\"-.1E-1\").get(0).getValue(), is(new BigDecimal(\"-0.01\")));\n        assertThat(expression.match(\"-.1E-2\").get(0).getValue(), is(new BigDecimal(\"-0.001\")));\n        assertThat(expression.match(\"-.1E+1\"), nullValue());\n        assertThat(expression.match(\"-.1E+2\"), nullValue());\n        assertThat(expression.match(\"-.1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n        assertThat(expression.match(\"-.10E2\").get(0).getValue(), is(new BigDecimal(\"-10\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_german() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.GERMAN));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_canadian_french() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.CANADA_FRENCH));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }\n\n    @Test\n    public void parse_decimal_numbers_in_norwegian() {\n        ExpressionFactory factory = new ExpressionFactory(new ParameterTypeRegistry(Locale.forLanguageTag(\"no\")));\n        Expression expression = factory.createExpression(\"{bigdecimal}\");\n\n        assertThat(expression.match(\"1.000,1\").get(0).getValue(), is(new BigDecimal(\"1000.1\")));\n        assertThat(expression.match(\"1.000.000,1\").get(0).getValue(), is(new BigDecimal(\"1000000.1\")));\n        assertThat(expression.match(\"-1,1\").get(0).getValue(), is(new BigDecimal(\"-1.1\")));\n        assertThat(expression.match(\"-,1E1\").get(0).getValue(), is(new BigDecimal(\"-1\")));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String CAPITALISED_WORD = \"[A-Z]+\\\\w+\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CAPITALISED_WORD = \"[A-Z]+\\\\w+\"", "syntax_pass": true}, {"attribute_expression": "private final ParameterTypeRegistry registry = new ParameterTypeRegistry(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "registry = new ParameterTypeRegistry(Locale.ENGLISH)", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/RegexpUtilsTest.java.RegexpUtilsTest", "name": "RegexpUtilsTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/RegexpUtilsTest.java", "superclasses": "", "methods": ["[void]escape_regex_characters()", "[void]escape_all_regexp_characters()", "[void]escape_escaped_regexp_characters()", "[void]do_not_escape_when_there_is_nothing_to_escape()", "[void]gives_no_error_for_unicode_characters()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class RegexpUtilsTest {\n\n    @Test\n    void escape_regex_characters(){\n        assertEquals(\"hello \\\\$world\", escapeRegex(\"hello $world\"));\n    }\n\n    @Test\n    void escape_all_regexp_characters() {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\(\\\\)\\\\{\\\\}\\\\.\\\\|\\\\?\\\\*\\\\+\\\\\\\\\", escapeRegex(\"^$[](){}.|?*+\\\\\"));\n    }\n\n    @Test\n    void escape_escaped_regexp_characters() {\n        assertEquals(\"\\\\^\\\\$\\\\[\\\\]\\\\\\\\\\\\(\\\\\\\\\\\\)\\\\{\\\\}\\\\\\\\\\\\\\\\\\\\.\\\\|\\\\?\\\\*\\\\+\", escapeRegex(\"^$[]\\\\(\\\\){}\\\\\\\\.|?*+\"));\n    }\n\n\n    @Test\n    void do_not_escape_when_there_is_nothing_to_escape() {\n        assertEquals(\"hello world\", escapeRegex(\"hello world\"));\n    }\n\n    @Test\n    void gives_no_error_for_unicode_characters() {\n        assertEquals(\"\ud83e\udd52\", escapeRegex(\"\ud83e\udd52\"));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getRegexpsTest.java.ParameterType_getRegexpsTest", "name": "ParameterType_getRegexpsTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getRegexpsTest.java", "superclasses": "", "methods": ["[void]testGetRegexps()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ParameterType_getRegexpsTest {\n\n    @Test\n    public void testGetRegexps() {\n        List<String> expectedRegexps = Arrays.asList(\"\\\\d+\", \"\\\\w+\");\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", expectedRegexps, String.class, (String arg) -> arg, true, false);\n        List<String> actualRegexps = parameterType.getRegexps();\n        assertEquals(expectedRegexps, actualRegexps);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer_transformTest.java.BuiltInParameterTransformer_transformTest", "name": "BuiltInParameterTransformer_transformTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer_transformTest.java", "superclasses": "", "methods": ["[void]testTransformStringToBigDecimal()", "[void]testTransformStringToOptionalBigDecimal()", "[void]testTransformStringToUnsupportedType()", "[void]testTransformNullValue()", "[void]testTransformStringToEnum()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer_transformTest.java.BuiltInParameterTransformer_transformTest.[void]setUp()"], "overrides": null, "attributes": [{"original_string": "    private static class ParameterizedTypeImpl implements java.lang.reflect.ParameterizedType {\n        private final Type rawType;\n        private final Type[] typeArguments;\n\n        public ParameterizedTypeImpl(Type rawType, Type[] typeArguments) {\n            this.rawType = rawType;\n            this.typeArguments = typeArguments;\n        }\n\n        @Override\n        public Type[] getActualTypeArguments() {\n            return typeArguments;\n        }\n\n        @Override\n        public Type getRawType() {\n            return rawType;\n        }\n\n        @Override\n        public Type getOwnerType() {\n            return null;\n        }\n    }", "definition": "    private static class ParameterizedTypeImpl implements java.lang.reflect.ParameterizedType", "class_docstring": "", "name": "ParameterizedTypeImpl", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Type rawType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type", "name": "rawType", "syntax_pass": true}, {"attribute_expression": "private final Type[] typeArguments;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type[]", "name": "typeArguments", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ParameterizedTypeImpl(Type rawType, Type[] typeArguments) {\n            this.rawType = rawType;\n            this.typeArguments = typeArguments;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterizedTypeImpl", "params": [{"name": "rawType", "type": "Type"}, {"name": "typeArguments", "type": "Type[]"}], "body": "                                                                         {\n            this.rawType = rawType;\n            this.typeArguments = typeArguments;\n        }", "signature": "public ParameterizedTypeImpl(Type rawType, Type[] typeArguments)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Type[] getActualTypeArguments() {\n            return typeArguments;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type[]", "classes": []}, "name": "getActualTypeArguments", "params": [], "body": "                                               {\n            return typeArguments;\n        }", "signature": "@Override\n        public Type[] getActualTypeArguments()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Type getRawType() {\n            return rawType;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "getRawType", "params": [], "body": "                                 {\n            return rawType;\n        }", "signature": "@Override\n        public Type getRawType()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Type getOwnerType() {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "getOwnerType", "params": [], "body": "                                   {\n            return null;\n        }", "signature": "@Override\n        public Type getOwnerType()"}]}], "class_docstring": "", "original_string": "class BuiltInParameterTransformer_transformTest {\n\n    private BuiltInParameterTransformer transformer;\n\n    @BeforeEach\n    void setUp() {\n        transformer = new BuiltInParameterTransformer(Locale.ENGLISH);\n    }\n\n    @Test\n    void testTransformStringToBigDecimal() {\n        String fromValue = \"123.45\";\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(new BigDecimal(\"123.45\"), result);\n    }\n\n    @Test\n    void testTransformStringToOptionalBigDecimal() {\n        String fromValue = \"123.45\";\n        Type toValueType = new ParameterizedTypeImpl(Optional.class, new Type[]{BigDecimal.class});\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(Optional.of(new BigDecimal(\"123.45\")), result);\n    }\n\n    @Test\n    void testTransformStringToUnsupportedType() {\n        String fromValue = \"test\";\n        Type toValueType = this.getClass();\n        assertThrows(IllegalArgumentException.class, () -> {\n            transformer.transform(fromValue, toValueType);\n        });\n    }\n\n    @Test\n    void testTransformNullValue() {\n        String fromValue = null;\n        Type toValueType = BigDecimal.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertNull(result);\n    }\n\n    @Test\n    void testTransformStringToEnum() {\n        String fromValue = \"VALUE1\";\n        Type toValueType = TestEnum.class;\n        Object result = transformer.transform(fromValue, toValueType);\n        assertEquals(TestEnum.VALUE1, result);\n    }\n\n    private enum TestEnum {\n        VALUE1, VALUE2\n    }\n\n    private static class ParameterizedTypeImpl implements java.lang.reflect.ParameterizedType {\n        private final Type rawType;\n        private final Type[] typeArguments;\n\n        public ParameterizedTypeImpl(Type rawType, Type[] typeArguments) {\n            this.rawType = rawType;\n            this.typeArguments = typeArguments;\n        }\n\n        @Override\n        public Type[] getActualTypeArguments() {\n            return typeArguments;\n        }\n\n        @Override\n        public Type getRawType() {\n            return rawType;\n        }\n\n        @Override\n        public Type getOwnerType() {\n            return null;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private BuiltInParameterTransformer transformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BuiltInParameterTransformer", "name": "transformer", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getNameTest.java.ParameterType_getNameTest", "name": "ParameterType_getNameTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getNameTest.java", "superclasses": "", "methods": ["[void]testGetName()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ParameterType_getNameTest {\n\n    @Test\n    public void testGetName() {\n        ParameterType<String> parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (String arg) -> arg);\n        assertEquals(\"testName\", parameterType.getName());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getTypeTest.java.ParameterType_getTypeTest", "name": "ParameterType_getTypeTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterType_getTypeTest.java", "superclasses": "", "methods": ["[void]getType_returnsCorrectType()"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/ParameterType_getTypeTest.java.ParameterType_getTypeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ParameterType_getTypeTest {\n\n    private ParameterType<String> parameterType;\n\n    @BeforeEach\n    public void setUp() {\n        parameterType = new ParameterType<>(\"testName\", \"testRegexp\", String.class, (Transformer<String>) s -> s, true, false);\n    }\n\n    @Test\n    public void getType_returnsCorrectType() {\n        Type expectedType = String.class;\n        Type actualType = parameterType.getType();\n        assertEquals(expectedType, actualType);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ParameterType<String> parameterType;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterType<String>", "name": "parameterType", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/NumberParserTest.java.NumberParserTest", "name": "NumberParserTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/NumberParserTest.java", "superclasses": "", "methods": ["[void]can_parse_float()", "[void]can_parse_double()", "[void]can_parse_big_decimals()", "[void]can_parse_negative()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class NumberParserTest {\n\n    private final NumberParser english = new NumberParser(Locale.ENGLISH);\n    private final NumberParser german = new NumberParser(Locale.GERMAN);\n    private final NumberParser canadianFrench = new NumberParser(Locale.CANADA_FRENCH);\n    private final NumberParser norwegian = new NumberParser(forLanguageTag(\"no\"));\n    private final NumberParser canadian = new NumberParser(Locale.CANADA);\n\n    @Test\n    void can_parse_float() {\n        assertEquals(1042.2f, english.parseFloat(\"1,042.2\"), 0);\n        assertEquals(1042.2f, canadian.parseFloat(\"1,042.2\"), 0);\n\n        assertEquals(1042.2f, german.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, canadianFrench.parseFloat(\"1.042,2\"), 0);\n        assertEquals(1042.2f, norwegian.parseFloat(\"1.042,2\"), 0);\n    }\n\n    @Test\n    void can_parse_double() {\n        assertEquals(1042.000000000000002, english.parseDouble(\"1,042.000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadian.parseDouble(\"1,042.000000000000002\"), 0);\n\n        assertEquals(1042.000000000000002, german.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, canadianFrench.parseDouble(\"1.042,000000000000002\"), 0);\n        assertEquals(1042.000000000000002, norwegian.parseDouble(\"1.042,000000000000002\"), 0);\n    }\n\n    @Test\n    void can_parse_big_decimals() {\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), english.parseBigDecimal(\"1,042.0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadian.parseBigDecimal(\"1,042.0000000000000000000002\"));\n\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), german.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), canadianFrench.parseBigDecimal(\"1.042,0000000000000000000002\"));\n        assertEquals(new BigDecimal(\"1042.0000000000000000000002\"), norwegian.parseBigDecimal(\"1.042,0000000000000000000002\"));\n    }\n\n    @Test\n    void can_parse_negative() {\n        assertEquals(-1042.2f, english.parseFloat(\"-1,042.2\"), 0);\n        assertEquals(-1042.2f, canadian.parseFloat(\"-1,042.2\"), 0);\n\n        assertEquals(-1042.2f, german.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, canadianFrench.parseFloat(\"-1.042,2\"), 0);\n        assertEquals(-1042.2f, norwegian.parseFloat(\"-1.042,2\"), 0);\n    }\n\n    // @Test\n    // void can_parse_exponents() {\n    //     assertEquals(new BigDecimal(\"100\"), english.parseBigDecimal(\"1.00E2\"));\n    //     assertEquals(new BigDecimal(\"100\"), canadian.parseBigDecimal(\"1.00e2\"));\n    //     assertEquals(new BigDecimal(\"100\"), german.parseBigDecimal(\"1,00E2\"));\n    //     assertEquals(new BigDecimal(\"100\"), canadianFrench.parseBigDecimal(\"1,00E2\"));\n    //     assertEquals(new BigDecimal(\"100\"), norwegian.parseBigDecimal(\"1,00E2\"));\n\n    //     assertEquals(new BigDecimal(\"0.01\"), english.parseBigDecimal(\"1E-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), canadian.parseBigDecimal(\"1e-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), german.parseBigDecimal(\"1E-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), canadianFrench.parseBigDecimal(\"1E-2\"));\n    //     assertEquals(new BigDecimal(\"0.01\"), norwegian.parseBigDecimal(\"1E-2\"));\n    // }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final NumberParser english = new NumberParser(Locale.ENGLISH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "english = new NumberParser(Locale.ENGLISH)", "syntax_pass": true}, {"attribute_expression": "private final NumberParser german = new NumberParser(Locale.GERMAN);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "german = new NumberParser(Locale.GERMAN)", "syntax_pass": true}, {"attribute_expression": "private final NumberParser canadianFrench = new NumberParser(Locale.CANADA_FRENCH);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "canadianFrench = new NumberParser(Locale.CANADA_FRENCH)", "syntax_pass": true}, {"attribute_expression": "private final NumberParser norwegian = new NumberParser(forLanguageTag(\"no\"));", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "norwegian = new NumberParser(forLanguageTag(\"no\"))", "syntax_pass": true}, {"attribute_expression": "private final NumberParser canadian = new NumberParser(Locale.CANADA);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "canadian = new NumberParser(Locale.CANADA)", "syntax_pass": true}]}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/RegularExpression_getRegexpTest.java.RegularExpression_getRegexpTest", "name": "RegularExpression_getRegexpTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/RegularExpression_getRegexpTest.java", "superclasses": "", "methods": ["[void]testGetRegexp()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RegularExpression_getRegexpTest {\n\n    @Test\n    public void testGetRegexp() {\n        Pattern expectedPattern = Pattern.compile(\"\\\\d+\");\n        ParameterTypeRegistry parameterTypeRegistry = new ParameterTypeRegistry(java.util.Locale.getDefault());\n        RegularExpression regularExpression = new RegularExpression(expectedPattern, parameterTypeRegistry);\n        assertEquals(expectedPattern, regularExpression.getRegexp());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformerTest.java.ParameterByTypeTransformerTest", "name": "ParameterByTypeTransformerTest", "file_path": "src/test/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformerTest.java", "superclasses": "", "methods": ["[void]should_convert_null_to_null(ParameterByTypeTransformer)", "[void]should_convert_null_to_optional(ParameterByTypeTransformer)", "[void]should_convert_null_to_optional_generic(ParameterByTypeTransformer)", "[void]should_convert_to_string(ParameterByTypeTransformer)", "[void]should_convert_to_optional_string(ParameterByTypeTransformer)", "[void]should_convert_to_object(ParameterByTypeTransformer)", "[void]should_convert_to_big_integer(ParameterByTypeTransformer)", "[void]should_convert_to_big_decimal(ParameterByTypeTransformer)", "[void]should_convert_to_byte(ParameterByTypeTransformer)", "[void]should_convert_to_short(ParameterByTypeTransformer)", "[void]should_convert_to_integer(ParameterByTypeTransformer)", "[void]should_convert_to_optional_integer(ParameterByTypeTransformer)", "[void]should_convert_to_long(ParameterByTypeTransformer)", "[void]should_convert_to_float(ParameterByTypeTransformer)", "[void]should_convert_to_double(ParameterByTypeTransformer)", "[void]should_convert_to_enum(ParameterByTypeTransformer)"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/ParameterByTypeTransformerTest.java.ParameterByTypeTransformerTest.[Stream<ParameterByTypeTransformer>]objectMapperImplementations()"], "overrides": null, "attributes": [{"original_string": "    private static class TestJacksonDefaultTransformer implements ParameterByTypeTransformer {\n        ObjectMapper delegate = initMapper();\n\n        private static ObjectMapper initMapper() {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.registerModule(new Jdk8Module());\n            return objectMapper;\n        }\n\n        @Override\n        public Object transform(String fromValue, Type toValueType) {\n            TypeFactory typeFactory = delegate.getTypeFactory();\n            return delegate.convertValue(fromValue, typeFactory.constructType(toValueType));\n        }\n\n    }", "definition": "    private static class TestJacksonDefaultTransformer implements ParameterByTypeTransformer", "class_docstring": "", "name": "TestJacksonDefaultTransformer", "super_interfaces": ["ParameterByTypeTransformer"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "ObjectMapper delegate = initMapper();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ObjectMapper", "name": "delegate = initMapper()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private static ObjectMapper initMapper() {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.registerModule(new Jdk8Module());\n            return objectMapper;\n        }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ObjectMapper", "classes": []}, "name": "initMapper", "params": [], "body": "                                                 {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.registerModule(new Jdk8Module());\n            return objectMapper;\n        }", "signature": "private static ObjectMapper initMapper()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object transform(String fromValue, Type toValueType) {\n            TypeFactory typeFactory = delegate.getTypeFactory();\n            return delegate.convertValue(fromValue, typeFactory.constructType(toValueType));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "transform", "params": [{"name": "fromValue", "type": "String"}, {"name": "toValueType", "type": "Type"}], "body": "                                                                    {\n            TypeFactory typeFactory = delegate.getTypeFactory();\n            return delegate.convertValue(fromValue, typeFactory.constructType(toValueType));\n        }", "signature": "@Override\n        public Object transform(String fromValue, Type toValueType)"}]}], "class_docstring": "", "original_string": "public class ParameterByTypeTransformerTest {\n\n    static Stream<ParameterByTypeTransformer> objectMapperImplementations() {\n        return Stream.of(\n                new BuiltInParameterTransformer(ENGLISH),\n                new TestJacksonDefaultTransformer()\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_null(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertNull(defaultTransformer.transform(null, Object.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, Optional.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_null_to_optional_generic(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.empty(), defaultTransformer.transform(null, optionalIntType));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_string(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", String.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_string(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalStringType = new TypeReference<Optional<String>>() {\n        }.getType();\n\n        assertEquals(Optional.of(\"Barbara Liskov\"), defaultTransformer.transform(\"Barbara Liskov\", optionalStringType));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_object(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(\"Barbara Liskov\",\n                defaultTransformer.transform(\"Barbara Liskov\", Object.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(new BigInteger(\"10000008\"),\n                defaultTransformer.transform(\"10000008\", BigInteger.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_big_decimal(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(new BigDecimal(\"1.0000008\"),\n                defaultTransformer.transform(\"1.0000008\", BigDecimal.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_byte(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", Byte.class));\n        assertEquals(Byte.decode(\"42\"), defaultTransformer.transform(\"42\", byte.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_short(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", Short.class));\n        assertEquals(Short.decode(\"42\"), defaultTransformer.transform(\"42\", short.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", Integer.class));\n        assertEquals(Integer.decode(\"42\"), defaultTransformer.transform(\"42\", int.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_optional_integer(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        Type optionalIntType = new TypeReference<Optional<Integer>>() {\n        }.getType();\n\n        assertEquals(Optional.of(Integer.decode(\"42\")), defaultTransformer.transform(\"42\", optionalIntType));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_long(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", Long.class));\n        assertEquals(Long.decode(\"42\"), defaultTransformer.transform(\"42\", long.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_float(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", Float.class));\n        assertEquals(4.2f, defaultTransformer.transform(\"4.2\", float.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_double(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", Double.class));\n        assertEquals(4.2, defaultTransformer.transform(\"4.2\", double.class));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"objectMapperImplementations\")\n    public void should_convert_to_enum(final ParameterByTypeTransformer defaultTransformer) throws Throwable {\n        assertEquals(TestEnum.TEST, defaultTransformer.transform(\"TEST\", TestEnum.class));\n    }\n\n    private static class TestJacksonDefaultTransformer implements ParameterByTypeTransformer {\n        ObjectMapper delegate = initMapper();\n\n        private static ObjectMapper initMapper() {\n            ObjectMapper objectMapper = new ObjectMapper();\n            objectMapper.registerModule(new Jdk8Module());\n            return objectMapper;\n        }\n\n        @Override\n        public Object transform(String fromValue, Type toValueType) {\n            TypeFactory typeFactory = delegate.getTypeFactory();\n            return delegate.convertValue(fromValue, typeFactory.constructType(toValueType));\n        }\n\n    }\n\n    private enum TestEnum {\n        TEST\n    }\n\n}", "super_interfaces": [], "fields": []}]