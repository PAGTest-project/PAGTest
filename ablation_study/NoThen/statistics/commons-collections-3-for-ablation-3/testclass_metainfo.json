[{"uris": "src/test/java/org/apache/commons/collections4/ArrayUtilsTest.java.ArrayUtilsTest", "name": "ArrayUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/ArrayUtilsTest.java", "superclasses": "", "methods": ["[void]testContains()", "[void]testContains_LANG_1261()", "[void]testIndexOf()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ArrayUtilsTest {\n\n    @Test\n    public void testContains() {\n        final Object[] array = { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n        assertFalse(ArrayUtils.contains(null, null));\n        assertFalse(ArrayUtils.contains(null, \"1\"));\n        assertTrue(ArrayUtils.contains(array, \"0\"));\n        assertTrue(ArrayUtils.contains(array, \"1\"));\n        assertTrue(ArrayUtils.contains(array, \"2\"));\n        assertTrue(ArrayUtils.contains(array, \"3\"));\n        assertTrue(ArrayUtils.contains(array, null));\n        assertFalse(ArrayUtils.contains(array, \"notInArray\"));\n    }\n\n    @Test\n    public void testContains_LANG_1261() {\n        class LANG1261ParentObject {\n            @Override\n            public boolean equals(final Object o) {\n                return true;\n            }\n        }\n        class LANG1261ChildObject extends LANG1261ParentObject {\n        }\n        final Object[] array = new LANG1261ChildObject[] { new LANG1261ChildObject() };\n        assertTrue(ArrayUtils.contains(array, new LANG1261ParentObject()));\n    }\n\n    @Test\n    public void testIndexOf() {\n        final Object[] array = { \"0\", \"1\", \"2\", \"3\", null, \"0\" };\n        assertEquals(-1, ArrayUtils.indexOf(null, null));\n        assertEquals(-1, ArrayUtils.indexOf(null, \"0\"));\n        assertEquals(-1, ArrayUtils.indexOf(new Object[0], \"0\"));\n        assertEquals(0, ArrayUtils.indexOf(array, \"0\"));\n        assertEquals(1, ArrayUtils.indexOf(array, \"1\"));\n        assertEquals(2, ArrayUtils.indexOf(array, \"2\"));\n        assertEquals(3, ArrayUtils.indexOf(array, \"3\"));\n        assertEquals(4, ArrayUtils.indexOf(array, null));\n        assertEquals(-1, ArrayUtils.indexOf(array, \"notInArray\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/SetUtils_hashSetTest.java.SetUtils_hashSetTest", "name": "SetUtils_hashSetTest", "file_path": "src/test/java/org/apache/commons/collections4/SetUtils_hashSetTest.java", "superclasses": "", "methods": ["[void]testHashSetWithItems()", "[void]testHashSetWithNull()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SetUtils_hashSetTest {\n\n    @Test\n    public void testHashSetWithItems() {\n        // Given\n        String[] items = {\"item1\", \"item2\"};\n\n        // When\n        HashSet<String> result = SetUtils.hashSet(items);\n\n        // Then\n        assertNotNull(result);\n        assertEquals(2, result.size());\n        assertTrue(result.contains(\"item1\"));\n        assertTrue(result.contains(\"item2\"));\n    }\n\n    @Test\n    public void testHashSetWithNull() {\n        // Given\n        String[] items = null;\n\n        // When\n        HashSet<String> result = SetUtils.hashSet(items);\n\n        // Then\n        assertNull(result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/MultiMapUtils_getValuesAsSetTest.java.MultiMapUtils_getValuesAsSetTest", "name": "MultiMapUtils_getValuesAsSetTest", "file_path": "src/test/java/org/apache/commons/collections4/MultiMapUtils_getValuesAsSetTest.java", "superclasses": "", "methods": ["[void]testGetValuesAsSet_WithNullMap()", "[void]testGetValuesAsSet_WithEmptyMap()", "[void]testGetValuesAsSet_WithArrayListValuedHashMap()", "[void]testGetValuesAsSet_WithHashSetValuedHashMap()", "[void]testGetValuesAsSet_WithNonExistentKey()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiMapUtils_getValuesAsSetTest {\n\n    @Test\n    public void testGetValuesAsSet_WithNullMap() {\n        MultiValuedMap<String, String> map = null;\n        Set<String> result = MultiMapUtils.getValuesAsSet(map, \"key\");\n        assertNull(result);\n    }\n\n    @Test\n    public void testGetValuesAsSet_WithEmptyMap() {\n        MultiValuedMap<String, String> map = MultiMapUtils.emptyMultiValuedMap();\n        Set<String> result = MultiMapUtils.getValuesAsSet(map, \"key\");\n        assertTrue(result.isEmpty());\n    }\n\n    @Test\n    public void testGetValuesAsSet_WithArrayListValuedHashMap() {\n        MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();\n        map.put(\"key\", \"value1\");\n        map.put(\"key\", \"value2\");\n        Set<String> result = MultiMapUtils.getValuesAsSet(map, \"key\");\n        assertEquals(new HashSet<>(Arrays.asList(\"value1\", \"value2\")), result);\n    }\n\n    @Test\n    public void testGetValuesAsSet_WithHashSetValuedHashMap() {\n        MultiValuedMap<String, String> map = new HashSetValuedHashMap<>();\n        map.put(\"key\", \"value1\");\n        map.put(\"key\", \"value2\");\n        Set<String> result = MultiMapUtils.getValuesAsSet(map, \"key\");\n        assertEquals(new HashSet<>(Arrays.asList(\"value1\", \"value2\")), result);\n    }\n\n    @Test\n    public void testGetValuesAsSet_WithNonExistentKey() {\n        MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();\n        map.put(\"key1\", \"value1\");\n        Set<String> result = MultiMapUtils.getValuesAsSet(map, \"key2\");\n        assertTrue(result.isEmpty());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_forEachTest.java.IteratorUtils_forEachTest", "name": "IteratorUtils_forEachTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_forEachTest.java", "superclasses": "", "methods": ["[void]testForEach_NullIterator()", "[void]testForEach_NonNullIterator()", "[void]testForEach_NullClosure()", "[void]testForEach_IteratorThrowsException()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_forEachTest {\n\n    @Test\n    public void testForEach_NullIterator() {\n        Closure<Object> closure = NOPClosure.nopClosure();\n        IteratorUtils.forEach(null, closure);\n        // No exception should be thrown\n    }\n\n    @Test\n    public void testForEach_NonNullIterator() {\n        Iterator<String> iterator = mock(Iterator.class);\n        Closure<String> closure = mock(Closure.class);\n\n        when(iterator.hasNext()).thenReturn(true, false);\n        when(iterator.next()).thenReturn(\"test\");\n\n        IteratorUtils.forEach(iterator, closure);\n\n        verify(closure, times(1)).accept(\"test\");\n    }\n\n    @Test\n    public void testForEach_NullClosure() {\n        Iterator<String> iterator = mock(Iterator.class);\n        assertThrows(NullPointerException.class, () -> {\n            IteratorUtils.forEach(iterator, null);\n        });\n    }\n\n    @Test\n    public void testForEach_IteratorThrowsException() {\n        Iterator<String> iterator = mock(Iterator.class);\n        Closure<String> closure = mock(Closure.class);\n\n        when(iterator.hasNext()).thenReturn(true);\n        when(iterator.next()).thenThrow(new NoSuchElementException());\n\n        assertThrows(NoSuchElementException.class, () -> {\n            IteratorUtils.forEach(iterator, closure);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/SetUtils_hashCodeForSetTest.java.SetUtils_hashCodeForSetTest", "name": "SetUtils_hashCodeForSetTest", "file_path": "src/test/java/org/apache/commons/collections4/SetUtils_hashCodeForSetTest.java", "superclasses": "", "methods": ["[void]testHashCodeForSet_NullSet()", "[void]testHashCodeForSet_EmptySet()", "[void]testHashCodeForSet_NonEmptySet()", "[void]testHashCodeForSet_SetWithNullElements()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SetUtils_hashCodeForSetTest {\n\n    @Test\n    public void testHashCodeForSet_NullSet() {\n        // Given\n        Collection<Object> set = null;\n\n        // When\n        int result = SetUtils.hashCodeForSet(set);\n\n        // Then\n        assertEquals(0, result);\n    }\n\n    @Test\n    public void testHashCodeForSet_EmptySet() {\n        // Given\n        Collection<Object> set = Collections.emptySet();\n\n        // When\n        int result = SetUtils.hashCodeForSet(set);\n\n        // Then\n        assertEquals(0, result);\n    }\n\n    @Test\n    public void testHashCodeForSet_NonEmptySet() {\n        // Given\n        Collection<Object> set = Arrays.asList(\"a\", \"b\", \"c\");\n\n        // When\n        int result = SetUtils.hashCodeForSet(set);\n\n        // Then\n        assertEquals(\"a\".hashCode() + \"b\".hashCode() + \"c\".hashCode(), result);\n    }\n\n    @Test\n    public void testHashCodeForSet_SetWithNullElements() {\n        // Given\n        Collection<Object> set = Arrays.asList(\"a\", null, \"b\");\n\n        // When\n        int result = SetUtils.hashCodeForSet(set);\n\n        // Then\n        assertEquals(\"a\".hashCode() + \"b\".hashCode(), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/TransformerUtilsTest.java.TransformerUtilsTest", "name": "TransformerUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/TransformerUtilsTest.java", "superclasses": "", "methods": ["[void]testChainedTransformer()", "[void]testCloneTransformer()", "[void]testConstantTransformer()", "[void]testExceptionTransformer()", "[void]testExecutorTransformer()", "[void]testFactoryTransformer()", "[void]testIfTransformer()", "[void]testInstantiateTransformerNull()", "[void]testInvokerTransformer()", "[void]testInvokerTransformer2()", "[void]testMapTransformer()", "[void]testNopTransformer()", "[void]testNullTransformer()", "[void]testPredicateTransformer()", "[void]testSingletonPatternInSerialization()", "[void]testStringValueTransformer()", "[void]testSwitchMapTransformer()", "[void]testSwitchTransformer()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests the TransformerUtils class.\n", "original_string": "public class TransformerUtilsTest {\n\n    private static final Object cObject = new Object();\n    private static final Object cString = \"Hello\";\n    private static final Object cInteger = Integer.valueOf(6);\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testChainedTransformer() {\n        final Transformer<Object, Object> a = TransformerUtils.<Object, Object>constantTransformer(\"A\");\n        final Transformer<Object, Object> b = TransformerUtils.constantTransformer((Object) \"B\");\n        assertEquals(\"A\", TransformerUtils.chainedTransformer(b, a).apply(null));\n        assertEquals(\"B\", TransformerUtils.chainedTransformer(a, b).apply(null));\n        assertEquals(\"A\", TransformerUtils.chainedTransformer(b, a).apply(null));\n        assertEquals(\"A\", TransformerUtils.chainedTransformer(b, a).transform(null));\n        assertEquals(\"B\", TransformerUtils.chainedTransformer(a, b).transform(null));\n        assertEquals(\"A\", TransformerUtils.chainedTransformer(b, a).transform(null));\n        final Collection<Transformer<Object, Object>> coll = new ArrayList<>();\n        coll.add(b);\n        coll.add(a);\n        assertEquals(\"A\", TransformerUtils.chainedTransformer(coll).transform(null));\n\n        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer());\n        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(Collections.<Transformer<Object, Object>>emptyList()));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.chainedTransformer(null, null)),\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.chainedTransformer((Transformer[]) null)),\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.chainedTransformer((Collection<Transformer<Object, Object>>) null)),\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.chainedTransformer(null, null)),\n                () -> assertThrows(NullPointerException.class, () -> {\n                    final Collection<Transformer<Object, Object>> coll1 = new ArrayList<>();\n                    coll1.add(null);\n                    coll1.add(null);\n                    TransformerUtils.chainedTransformer(coll1);\n                })\n        );\n    }\n\n    @Test\n    public void testCloneTransformer() {\n        assertNull(TransformerUtils.cloneTransformer().transform(null));\n        assertEquals(cString, TransformerUtils.cloneTransformer().transform(cString));\n        assertEquals(cInteger, TransformerUtils.cloneTransformer().transform(cInteger));\n\n        assertThrows(IllegalArgumentException.class, () -> assertEquals(cObject, TransformerUtils.cloneTransformer().transform(cObject)));\n    }\n\n    @Test\n    public void testConstantTransformer() {\n        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(null));\n        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cObject));\n        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cString));\n        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cInteger));\n        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.constantTransformer(null));\n    }\n\n    @Test\n    public void testExceptionTransformer() {\n        assertAll(\n                () -> assertNotNull(TransformerUtils.exceptionTransformer()),\n                () -> assertSame(TransformerUtils.exceptionTransformer(), TransformerUtils.exceptionTransformer()),\n                () -> assertThrows(FunctorException.class, () -> TransformerUtils.exceptionTransformer().transform(null)),\n                () -> assertThrows(FunctorException.class, () -> TransformerUtils.exceptionTransformer().transform(cString))\n        );\n    }\n\n    @Test\n    public void testExecutorTransformer() {\n        assertNull(TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(null));\n        assertEquals(cObject, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cObject));\n        assertEquals(cString, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cString));\n        assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));\n\n        assertThrows(NullPointerException.class, () -> TransformerUtils.asTransformer((Closure<Object>) null));\n    }\n\n    @Test\n    public void testFactoryTransformer() {\n        assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(null));\n        assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cObject));\n        assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cString));\n        assertNull(TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cInteger));\n\n        assertThrows(NullPointerException.class, () -> TransformerUtils.asTransformer((Factory<Object>) null));\n    }\n\n    @Test\n    public void testIfTransformer() {\n        final Transformer<Object, String> a = TransformerUtils.constantTransformer(\"A\");\n        final Transformer<Object, String> b = TransformerUtils.constantTransformer(\"B\");\n        final Transformer<Object, String> c = TransformerUtils.constantTransformer(\"C\");\n\n        assertEquals(\"A\", TransformerUtils.ifTransformer(TruePredicate.truePredicate(), a, b).transform(null));\n        assertEquals(\"B\", TransformerUtils.ifTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));\n\n        final Predicate<Integer> lessThanFivePredicate = value -> value < 5;\n        // if/else tests\n        assertEquals(\"A\", TransformerUtils.ifTransformer(lessThanFivePredicate, a, b).transform(1));\n        assertEquals(\"B\", TransformerUtils.ifTransformer(lessThanFivePredicate, a, b).transform(5));\n\n        // if tests\n        final Predicate<String> equalsAPredicate = EqualPredicate.equalPredicate(\"A\");\n        assertEquals(\"C\", TransformerUtils.ifTransformer(equalsAPredicate, c).transform(\"A\"));\n        assertEquals(\"B\", TransformerUtils.ifTransformer(equalsAPredicate, c).transform(\"B\"));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.ifTransformer(null, null)),\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.ifTransformer(TruePredicate.truePredicate(), null)),\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.ifTransformer(null, ConstantTransformer.constantTransformer(\"A\"))),\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.ifTransformer(null, null, null))\n        );\n    }\n\n    @Test\n    public void testInstantiateTransformerNull() {\n        assertAll(\n                () -> assertThrows(IllegalArgumentException.class, () -> TransformerUtils.instantiateTransformer(null, new Object[]{\"str\"})),\n                () -> assertThrows(IllegalArgumentException.class, () -> TransformerUtils.instantiateTransformer(new Class[]{}, new Object[]{\"str\"}))\n        );\n\n        Transformer<Class<?>, Object> trans = TransformerUtils.instantiateTransformer(new Class[] { Long.class }, new Object[] { null });\n\n        final Transformer<Class<?>, Object> finalTrans = trans;\n        assertThrows(FunctorException.class, () -> finalTrans.transform(String.class));\n\n        trans = TransformerUtils.instantiateTransformer();\n        assertEquals(StringUtils.EMPTY, trans.transform(String.class));\n\n        trans = TransformerUtils.instantiateTransformer(new Class[] { Long.TYPE }, new Object[] {1000L});\n        assertEquals(new Date(1000L), trans.transform(Date.class));\n    }\n\n    @Test\n    public void testInvokerTransformer() {\n        final List<Object> list = new ArrayList<>();\n        assertEquals(0, TransformerUtils.invokerTransformer(\"size\").transform(list));\n        list.add(new Object());\n        assertEquals(1, TransformerUtils.invokerTransformer(\"size\").transform(list));\n        assertNull(TransformerUtils.invokerTransformer(\"size\").transform(null));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.invokerTransformer(null)),\n                () -> assertThrows(FunctorException.class, () -> TransformerUtils.invokerTransformer(\"noSuchMethod\").transform(new Object()))\n        );\n    }\n\n    @Test\n    public void testInvokerTransformer2() {\n        final List<Object> list = new ArrayList<>();\n        assertEquals(Boolean.FALSE, TransformerUtils.invokerTransformer(\"contains\",\n                new Class[] { Object.class }, new Object[] { cString }).transform(list));\n        list.add(cString);\n        assertEquals(Boolean.TRUE, TransformerUtils.invokerTransformer(\"contains\",\n                new Class[] { Object.class }, new Object[] { cString }).transform(list));\n        assertNull(TransformerUtils.invokerTransformer(\"contains\",\n                new Class[]{Object.class}, new Object[]{cString}).transform(null));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.invokerTransformer(null, null, null)),\n                () -> assertThrows(FunctorException.class, () -> TransformerUtils.invokerTransformer(\"noSuchMethod\", new Class[]{Object.class},\n                        new Object[]{cString}).transform(new Object())),\n                () -> assertThrows(IllegalArgumentException.class, () -> TransformerUtils.invokerTransformer(\"badArgs\", null, new Object[]{cString})),\n                () -> assertThrows(IllegalArgumentException.class, () -> TransformerUtils.invokerTransformer(\"badArgs\", new Class[]{Object.class}, null)),\n                () -> assertThrows(IllegalArgumentException.class, () -> TransformerUtils.invokerTransformer(\"badArgs\", new Class[]{}, new Object[]{cString}))\n        );\n    }\n\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testMapTransformer() {\n        final Map<Object, Integer> map = new HashMap<>();\n        map.put(null, 0);\n        map.put(cObject, 1);\n        map.put(cString, 2);\n        assertEquals(Integer.valueOf(0), TransformerUtils.mapTransformer(map).transform(null));\n        assertEquals(Integer.valueOf(1), TransformerUtils.mapTransformer(map).transform(cObject));\n        assertEquals(Integer.valueOf(2), TransformerUtils.mapTransformer(map).transform(cString));\n        assertNull(TransformerUtils.mapTransformer(map).transform(cInteger));\n        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.mapTransformer(null));\n    }\n\n    @Test\n    public void testNopTransformer() {\n        assertNotNull(TransformerUtils.nullTransformer());\n        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());\n        assertNull(TransformerUtils.nopTransformer().transform(null));\n        assertEquals(cObject, TransformerUtils.nopTransformer().transform(cObject));\n        assertEquals(cString, TransformerUtils.nopTransformer().transform(cString));\n        assertEquals(cInteger, TransformerUtils.nopTransformer().transform(cInteger));\n    }\n\n    @Test\n    public void testNullTransformer() {\n        assertNotNull(TransformerUtils.nullTransformer());\n        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());\n        assertNull(TransformerUtils.nullTransformer().transform(null));\n        assertNull(TransformerUtils.nullTransformer().transform(cObject));\n        assertNull(TransformerUtils.nullTransformer().transform(cString));\n        assertNull(TransformerUtils.nullTransformer().transform(cInteger));\n    }\n\n    @Test\n    public void testPredicateTransformer() {\n        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(null));\n        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cObject));\n        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cString));\n        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cInteger));\n\n        assertThrows(IllegalArgumentException.class, () -> TransformerUtils.asTransformer((Predicate<Object>) null));\n    }\n\n    /**\n     * Test that all Transformer singletons hold singleton pattern in\n     * serialization/deserialization process.\n     */\n    @Test\n    public void testSingletonPatternInSerialization() {\n        final Object[] singletons = {\n            ExceptionTransformer.INSTANCE,\n            NOPTransformer.INSTANCE,\n            StringValueTransformer.stringValueTransformer(),\n        };\n\n        for (final Object original : singletons) {\n            TestUtils.assertSameAfterSerialization(\"Singleton pattern broken for \" + original.getClass(), original);\n        }\n    }\n\n    @Test\n    public void testStringValueTransformer() {\n        assertNotNull( \"StringValueTransformer should NEVER return a null value.\",\n            TransformerUtils.stringValueTransformer().transform(null));\n        assertEquals( \"null\",\n            TransformerUtils.stringValueTransformer().transform(null), \"StringValueTransformer should return \\\"null\\\" when given a null argument.\");\n        assertEquals( \"6\",\n            TransformerUtils.stringValueTransformer().transform(6), \"StringValueTransformer should return toString value\");\n    }\n\n    @Test\n    public void testSwitchMapTransformer() {\n        final Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n        final Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n        final Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n\n        Map<String, Transformer<String, String>> map = new HashMap<>();\n        map.put(\"HELLO\", a);\n        map.put(\"THERE\", b);\n        assertNull(TransformerUtils.switchMapTransformer(map).transform(\"WELL\"));\n        assertEquals(\"A\", TransformerUtils.switchMapTransformer(map).transform(\"HELLO\"));\n        assertEquals(\"B\", TransformerUtils.switchMapTransformer(map).transform(\"THERE\"));\n        map.put(null, c);\n        assertEquals(\"C\", TransformerUtils.switchMapTransformer(map).transform(\"WELL\"));\n\n        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(new HashMap<>()));\n        map = new HashMap<>();\n        map.put(null, null);\n        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(map));\n\n        assertThrows(NullPointerException.class, () -> TransformerUtils.switchMapTransformer(null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSwitchTransformer() {\n        final Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n        final Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n        final Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n\n        assertEquals(\"A\", TransformerUtils.switchTransformer(TruePredicate.truePredicate(), a, b).transform(null));\n        assertEquals(\"B\", TransformerUtils.switchTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));\n\n        assertNull(TransformerUtils.<Object, String>switchTransformer(\n                new Predicate[]{EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\")},\n                new Transformer[]{a, b}).transform(\"WELL\"));\n        assertEquals(\"A\", TransformerUtils.switchTransformer(\n            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n            new Transformer[] { a, b }).transform(\"HELLO\"));\n        assertEquals(\"B\", TransformerUtils.switchTransformer(\n            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n            new Transformer[] { a, b }).transform(\"THERE\"));\n\n        assertEquals(\"C\", TransformerUtils.switchTransformer(\n            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n            new Transformer[] { a, b }, c).transform(\"WELL\"));\n\n        Map<Predicate<String>, Transformer<String, String>> map = new HashMap<>();\n        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n        assertNull(TransformerUtils.switchTransformer(map).transform(\"WELL\"));\n        assertEquals(\"A\", TransformerUtils.switchTransformer(map).transform(\"HELLO\"));\n        assertEquals(\"B\", TransformerUtils.switchTransformer(map).transform(\"THERE\"));\n        map.put(null, c);\n        assertEquals(\"C\", TransformerUtils.switchTransformer(map).transform(\"WELL\"));\n\n        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new Predicate[0], new Transformer[0]));\n        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new HashMap<>()));\n        map = new HashMap<>();\n        map.put(null, null);\n        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(map));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.switchTransformer(null, null)),\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.switchTransformer(null, (Transformer[]) null)),\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.switchTransformer(null)),\n                () -> assertThrows(NullPointerException.class, () -> TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2])),\n                () -> assertThrows(IllegalArgumentException.class, () -> TransformerUtils.switchTransformer(\n                        new Predicate[]{TruePredicate.truePredicate()},\n                        new Transformer[]{a, b}))\n        );\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object cObject = new Object();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "cObject = new Object()", "syntax_pass": true}, {"attribute_expression": "private static final Object cString = \"Hello\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "cString = \"Hello\"", "syntax_pass": true}, {"attribute_expression": "private static final Object cInteger = Integer.valueOf(6);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "cInteger = Integer.valueOf(6)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_toListTest.java.IteratorUtils_toListTest", "name": "IteratorUtils_toListTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_toListTest.java", "superclasses": "", "methods": ["[void]testToList_SuccessfulConversion()", "[void]testToList_NullIterator()", "[void]testToList_InvalidEstimatedSize()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_toListTest {\n\n    @Test\n    public void testToList_SuccessfulConversion() {\n        // Given\n        List<String> inputList = new ArrayList<>();\n        inputList.add(\"A\");\n        inputList.add(\"B\");\n        Iterator<String> iterator = inputList.iterator();\n\n        // When\n        List<String> result = IteratorUtils.toList(iterator, 2);\n\n        // Then\n        assertEquals(inputList, result);\n    }\n\n    @Test\n    public void testToList_NullIterator() {\n        // Given\n        Iterator<String> iterator = null;\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> {\n            IteratorUtils.toList(iterator, 2);\n        });\n    }\n\n    @Test\n    public void testToList_InvalidEstimatedSize() {\n        // Given\n        List<String> inputList = new ArrayList<>();\n        inputList.add(\"A\");\n        Iterator<String> iterator = inputList.iterator();\n\n        // When & Then\n        assertThrows(IllegalArgumentException.class, () -> {\n            IteratorUtils.toList(iterator, 0);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_filteredListIteratorTest.java.IteratorUtils_filteredListIteratorTest", "name": "IteratorUtils_filteredListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_filteredListIteratorTest.java", "superclasses": "", "methods": ["[void]testFilteredListIterator_Success()", "[void]testFilteredListIterator_NullListIterator()", "[void]testFilteredListIterator_NullPredicate()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_filteredListIteratorTest {\n\n    @Test\n    public void testFilteredListIterator_Success() {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        ListIterator<String> listIterator = list.listIterator();\n        Predicate<String> predicate = TruePredicate.truePredicate();\n\n        ListIterator<String> filteredIterator = IteratorUtils.filteredListIterator(listIterator, predicate);\n\n        assertNotNull(filteredIterator);\n    }\n\n    @Test\n    public void testFilteredListIterator_NullListIterator() {\n        Predicate<String> predicate = TruePredicate.truePredicate();\n\n        assertThrows(NullPointerException.class, () -> {\n            IteratorUtils.filteredListIterator(null, predicate);\n        });\n    }\n\n    @Test\n    public void testFilteredListIterator_NullPredicate() {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        ListIterator<String> listIterator = list.listIterator();\n\n        assertThrows(NullPointerException.class, () -> {\n            IteratorUtils.filteredListIterator(listIterator, null);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/ComparatorUtils_transformedComparatorTest.java.ComparatorUtils_transformedComparatorTest", "name": "ComparatorUtils_transformedComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/ComparatorUtils_transformedComparatorTest.java", "superclasses": "", "methods": ["[void]testTransformedComparatorWithNullComparator()", "[void]testTransformedComparatorWithNonNullComparator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ComparatorUtils_transformedComparatorTest {\n\n    @Test\n    public void testTransformedComparatorWithNullComparator() {\n        // Given\n        Transformer<String, Integer> transformer = new ConstantTransformer<>(1);\n\n        // When\n        Comparator<String> comparator = ComparatorUtils.transformedComparator(null, transformer);\n\n        // Then\n        assertNotNull(comparator);\n        assertEquals(TransformingComparator.class, comparator.getClass());\n    }\n\n    @Test\n    public void testTransformedComparatorWithNonNullComparator() {\n        // Given\n        Comparator<Integer> integerComparator = Comparator.naturalOrder();\n        Transformer<String, Integer> transformer = new ConstantTransformer<>(1);\n\n        // When\n        Comparator<String> comparator = ComparatorUtils.transformedComparator(integerComparator, transformer);\n\n        // Then\n        assertNotNull(comparator);\n        assertEquals(TransformingComparator.class, comparator.getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/EnumerationUtils_getTest.java.EnumerationUtils_getTest", "name": "EnumerationUtils_getTest", "file_path": "src/test/java/org/apache/commons/collections4/EnumerationUtils_getTest.java", "superclasses": "", "methods": ["[void]testGet_ValidIndex()", "[void]testGet_InvalidIndex()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class EnumerationUtils_getTest {\n\n    @Test\n    void testGet_ValidIndex() {\n        Vector<String> vector = new Vector<>();\n        vector.add(\"A\");\n        vector.add(\"B\");\n        vector.add(\"C\");\n        Enumeration<String> enumeration = vector.elements();\n\n        assertEquals(\"B\", EnumerationUtils.get(enumeration, 1));\n    }\n\n    @Test\n    void testGet_InvalidIndex() {\n        Vector<String> vector = new Vector<>();\n        vector.add(\"A\");\n        Enumeration<String> enumeration = vector.elements();\n\n        assertThrows(IndexOutOfBoundsException.class, () -> EnumerationUtils.get(enumeration, 1));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/MapUtilsTest.java.MapUtilsTest", "name": "MapUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/MapUtilsTest.java", "superclasses": "", "methods": ["[void]testConvertResourceBundle()", "[void]testDebugAndVerbosePrintCasting()", "[void]testDebugAndVerbosePrintNullMap()", "[void]testDebugPrint()", "[void]testDebugPrintNullKey()", "[void]testDebugPrintNullKeyToMap1()", "[void]testDebugPrintNullKeyToMap2()", "[void]testDebugPrintNullLabel()", "[void]testDebugPrintNullLabelAndMap()", "[void]testDebugPrintNullStream()", "[void]testDebugPrintSelfReference()", "[void]testEmptyIfNull()", "[void]testFixedSizeMap()", "[void]testFixedSizeSortedMap()", "[void]testGetBooleanValue()", "[void]testGetByteValue()", "[void]testGetDoubleValue()", "[void]testGetFloatValue()", "[void]testGetIntValue()", "[void]testGetLongValue()", "[void]testGetMap()", "[void]testGetNumber()", "[void]testGetNumberValueWithInvalidString()", "[void]testGetObject()", "[void]testGetShortValue()", "[void]testGetString()", "[void]testInvertEmptyMap()", "[void]testInvertMap()", "[void]testInvertMapNull()", "[void]testIsEmptyWithEmptyMap()", "[void]testIsEmptyWithNonEmptyMap()", "[void]testIsEmptyWithNull()", "[void]testIsNotEmptyWithEmptyMap()", "[void]testIsNotEmptyWithNonEmptyMap()", "[void]testIsNotEmptyWithNull()", "[void]testIterableMap()", "[void]testIterableSortedMap()", "[void]testLazyMap()", "[void]testLazyMapFactory()", "[void]testLazyMapTransformer()", "[void]testLazySortedMapFactory()", "[void]testLazySortedMapTransformer()", "[void]testOrderedMap()", "[void]testPopulateMap()", "[void]testPopulateMultiMap()", "[void]testPredicatedMap()", "[void]testPutAll_Map_array()", "[void]testSafeAddToMap()", "[void]testSize()", "[void]testSize0()", "[void]testSizeNull()", "[void]testToProperties()", "[void]testToPropertiesEmpty()", "[void]testTransformedMap()", "[void]testTransformedSortedMap()", "[void]testUnmodifiableMap()", "[void]testUnmodifiableSortedMap()", "[void]testVerbosePrint()", "[void]testVerbosePrintNullKey()", "[void]testVerbosePrintNullKeyToMap1()", "[void]testVerbosePrintNullKeyToMap2()", "[void]testVerbosePrintNullLabel()", "[void]testVerbosePrintNullLabelAndMap()", "[void]testVerbosePrintNullStream()", "[void]testVerbosePrintSelfReference()"], "method_uris": ["src/test/java/org/apache/commons/collections4/MapUtilsTest.java.MapUtilsTest.[char]getDecimalSeparator()", "src/test/java/org/apache/commons/collections4/MapUtilsTest.java.MapUtilsTest.[Predicate<Object>]getPredicate()"], "overrides": null, "attributes": [{"original_string": "    static class X implements Comparable<X> {\n\n        int key;\n        String name;\n\n        X(final int key, final String name) {\n            this.key = key;\n            this.name = name;\n        }\n\n        @Override\n        public int compareTo(final X o) {\n            return key - o.key | name.compareTo(o.name);\n        }\n\n    }", "definition": "    static class X implements Comparable<X>", "class_docstring": "\nTest class for populateMap(MultiMap).\n", "name": "X", "super_interfaces": ["Comparable<X>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "int key;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "key", "syntax_pass": true}, {"attribute_expression": "String name;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        X(final int key, final String name) {\n            this.key = key;\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "X", "params": [{"name": "key", "type": "int"}, {"name": "name", "type": "String"}], "body": "                                            {\n            this.key = key;\n            this.name = name;\n        }", "signature": "X(final int key, final String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int compareTo(final X o) {\n            return key - o.key | name.compareTo(o.name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compareTo", "params": [{"name": "o", "type": "X"}], "body": "                                        {\n            return key - o.key | name.compareTo(o.name);\n        }", "signature": "@Override\n        public int compareTo(final X o)"}]}], "class_docstring": "\nTests for MapUtils.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class MapUtilsTest {\n\n    /**\n     * Test class for populateMap(MultiMap).\n     */\n    static class X implements Comparable<X> {\n\n        int key;\n        String name;\n\n        X(final int key, final String name) {\n            this.key = key;\n            this.name = name;\n        }\n\n        @Override\n        public int compareTo(final X o) {\n            return key - o.key | name.compareTo(o.name);\n        }\n\n    }\n    private static final String THREE = \"Three\";\n\n    private static final String TWO = \"Two\";\n\n    private char getDecimalSeparator() {\n        final NumberFormat numberFormat = NumberFormat.getInstance();\n        if (numberFormat instanceof DecimalFormat) {\n            return ((DecimalFormat) numberFormat).getDecimalFormatSymbols().getDecimalSeparator();\n        }\n        return '.';\n    }\n\n    public Predicate<Object> getPredicate() {\n        return String.class::isInstance;\n    }\n\n    @Test\n    public void testConvertResourceBundle() {\n        final Map<String, String> in = new HashMap<>(5, 1);\n        in.put(\"1\", \"A\");\n        in.put(\"2\", \"B\");\n        in.put(\"3\", \"C\");\n        in.put(\"4\", \"D\");\n        in.put(\"5\", \"E\");\n\n        final ResourceBundle b = new ListResourceBundle() {\n            @Override\n            public Object[][] getContents() {\n                final Object[][] contents = new Object[in.size()][2];\n                int n = 0;\n                for (final Object key : in.keySet()) {\n                    final Object val = in.get(key);\n                    contents[n][0] = key;\n                    contents[n][1] = val;\n                    ++n;\n                }\n                return contents;\n            }\n        };\n\n        final Map<String, Object> out = MapUtils.toMap(b);\n\n        assertEquals(in, out);\n    }\n\n    @Test\n    public void testDebugAndVerbosePrintCasting() {\n        final Map<Integer, String> inner = new HashMap<>(2, 1);\n        inner.put(2, \"B\");\n        inner.put(3, \"C\");\n\n        final Map<Integer, Object> outer = new HashMap<>(2, 1);\n        outer.put(0, inner);\n        outer.put(1, \"A\");\n\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        try {\n            MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n        } catch (final ClassCastException e) {\n            fail(\"No Casting should be occurring!\");\n        }\n    }\n\n    @Test\n    public void testDebugAndVerbosePrintNullMap() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String LABEL = \"Print Map\";\n        outPrint.println(LABEL + \" = \" + String.valueOf((Object) null));\n        final String EXPECTED_OUT = out.toString();\n\n        out.reset();\n\n        MapUtils.debugPrint(outPrint, LABEL, null);\n        assertEquals(EXPECTED_OUT, out.toString());\n\n        out.reset();\n\n        MapUtils.verbosePrint(outPrint, LABEL, null);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testDebugPrint() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String LABEL = \"Print Map\";\n        final String INDENT = \"    \";\n\n        outPrint.println(LABEL + \" = \");\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n        outPrint.println(INDENT + \"1 = \");\n        outPrint.println(INDENT + \"{\");\n        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n        outPrint.println(INDENT + INDENT + \"3 = C \" + String.class.getName());\n        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n        outPrint.println(INDENT + \"7 = (this Map) \" + TreeMap.class.getName());\n        outPrint.println(\"} \" + TreeMap.class.getName());\n\n        final String EXPECTED_OUT = out.toString();\n\n        out.reset();\n\n        final Map<Integer, String> inner = new TreeMap<>(); // treeMap guarantees order across JDKs for test\n        inner.put(2, \"B\");\n        inner.put(3, \"C\");\n\n        final Map<Integer, Object> outer = new TreeMap<>();\n        outer.put(1, inner);\n        outer.put(0, \"A\");\n        outer.put(7, outer);\n\n        MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testDebugPrintNullKey() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String INDENT = \"    \";\n\n        final Map<Object, String> map = new HashMap<>();\n        map.put(null, \"A\");\n\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"null = A \" + String.class.getName());\n        outPrint.println(\"} \" + HashMap.class.getName());\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.debugPrint(outPrint, null, map);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testDebugPrintNullKeyToMap1() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String INDENT = \"    \";\n\n        final Map<Object, Map<?, ?>> map = new HashMap<>();\n        map.put(null, map);\n\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"null = (this Map) \" + HashMap.class.getName());\n        outPrint.println(\"} \" + HashMap.class.getName());\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.debugPrint(outPrint, null, map);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testDebugPrintNullKeyToMap2() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String INDENT = \"    \";\n\n        final Map<Object, Object> map = new HashMap<>();\n        final Map<Object, Object> map2 = new HashMap<>();\n        map.put(null, map2);\n        map2.put(\"2\", \"B\");\n\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"null = \");\n        outPrint.println(INDENT + \"{\");\n        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n        outPrint.println(INDENT + \"} \" + HashMap.class.getName());\n        outPrint.println(\"} \" + HashMap.class.getName());\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.debugPrint(outPrint, null, map);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testDebugPrintNullLabel() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String INDENT = \"    \";\n\n        final Map<Integer, String> map = new TreeMap<>(); // treeMap guarantees order across JDKs for test\n        map.put(2, \"B\");\n        map.put(3, \"C\");\n        map.put(4, null);\n\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"2 = B \" + String.class.getName());\n        outPrint.println(INDENT + \"3 = C \" + String.class.getName());\n        outPrint.println(INDENT + \"4 = null\");\n        outPrint.println(\"} \" + TreeMap.class.getName());\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.debugPrint(outPrint, null, map);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testDebugPrintNullLabelAndMap() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        outPrint.println(\"null\");\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.debugPrint(outPrint, null, null);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testDebugPrintNullStream() {\n        assertThrows(NullPointerException.class, () -> MapUtils.debugPrint(null, \"Map\", new HashMap<>()),\n                \"Should generate NullPointerException\");\n    }\n\n    @Test\n    public void testDebugPrintSelfReference() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String LABEL = \"Print Map\";\n        final String INDENT = \"    \";\n\n        final Map<Integer, Object> grandfather = new TreeMap<>(); // treeMap guarantees order across JDKs for test\n        final Map<Integer, Object> father = new TreeMap<>();\n        final Map<Integer, Object> son    = new TreeMap<>();\n\n        grandfather.put(0, \"A\");\n        grandfather.put(1, father);\n\n        father.put(2, \"B\");\n        father.put(3, grandfather);\n        father.put(4, son);\n\n        son.put(5, \"C\");\n        son.put(6, grandfather);\n        son.put(7, father);\n\n        outPrint.println(LABEL + \" = \");\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n        outPrint.println(INDENT + \"1 = \");\n        outPrint.println(INDENT + \"{\");\n        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map) \" + TreeMap.class.getName());\n        outPrint.println(INDENT + INDENT + \"4 = \");\n        outPrint.println(INDENT + INDENT + \"{\");\n        outPrint.println(INDENT + INDENT + INDENT + \"5 = C \" + String.class.getName());\n        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map) \" + TreeMap.class.getName());\n        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map) \" + TreeMap.class.getName());\n        outPrint.println(INDENT + INDENT + \"} \" + TreeMap.class.getName());\n        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n        outPrint.println(\"} \" + TreeMap.class.getName());\n\n        final String EXPECTED_OUT = out.toString();\n\n        out.reset();\n        MapUtils.debugPrint(outPrint, \"Print Map\", grandfather);\n\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testEmptyIfNull() {\n        assertTrue(MapUtils.emptyIfNull(null).isEmpty());\n\n        final Map<Long, Long> map = new HashMap<>();\n        assertSame(map, MapUtils.emptyIfNull(map));\n    }\n\n    @Test\n    public void testFixedSizeMap() {\n        final Exception exception = assertThrows(IllegalArgumentException.class, () -> MapUtils.fixedSizeMap(new HashMap<>()).put(new Object(), new Object()));\n    }\n\n    @Test\n    public void testFixedSizeSortedMap() {\n        final Exception exception = assertThrows(IllegalArgumentException.class, () -> MapUtils.fixedSizeSortedMap(new TreeMap<>()).put(1L, 1L));\n    }\n\n    @Test\n    public void testGetBooleanValue() {\n        final Map<String, Object> in = new HashMap<>();\n        in.put(\"key\", true);\n        in.put(\"keyNumberTrue\", 1);\n        in.put(\"keyNumberFalse\", 0);\n        in.put(\"keyUnmapped\", new Object());\n\n        assertFalse(MapUtils.getBooleanValue(null, \"keyString\", null));\n        assertFalse(MapUtils.getBooleanValue(in, null, null));\n        assertFalse(MapUtils.getBooleanValue(null, null, null));\n        assertTrue(MapUtils.getBooleanValue(in, \"key\", true));\n        assertTrue(MapUtils.getBooleanValue(in, \"key\"));\n        assertTrue(MapUtils.getBooleanValue(in, \"noKey\", true));\n        assertTrue(MapUtils.getBooleanValue(in, \"noKey\", key -> true));\n        assertFalse(MapUtils.getBooleanValue(in, \"noKey\"));\n        assertTrue(MapUtils.getBoolean(in, \"key\", true));\n        assertTrue(MapUtils.getBoolean(in, \"noKey\", true));\n        assertTrue(MapUtils.getBoolean(in, \"noKey\", key -> {\n            if (System.currentTimeMillis() > 0) {\n                return true;\n            }\n            return false;\n        }));\n        assertNull(MapUtils.getBoolean(in, \"noKey\", key -> null));\n        assertFalse(MapUtils.getBooleanValue(in, \"noKey\", key -> null));\n        assertNull(MapUtils.getBoolean(null, \"noKey\"));\n        // Values are Numbers\n        assertFalse(MapUtils.getBoolean(in, \"keyNumberFalse\"));\n        assertTrue(MapUtils.getBoolean(in, \"keyNumberTrue\"));\n        assertNull(MapUtils.getBoolean(in, \"keyString\"));\n        assertNull(MapUtils.getBoolean(null, \"keyString\"));\n        assertNull(MapUtils.getBoolean(in, null));\n        assertNull(MapUtils.getBoolean(null, null));\n\n        final Map<String, String> inStr = new HashMap<>();\n        inStr.put(\"str1\", \"true\");\n\n        assertTrue(MapUtils.getBooleanValue(inStr, \"str1\", true));\n        assertTrue(MapUtils.getBoolean(inStr, \"str1\", true));\n    }\n\n    @Test\n    public void testGetByteValue() {\n        final Map<String, Byte> in = new HashMap<>();\n        final byte val = 100;\n        in.put(\"key\", val);\n\n        assertEquals(val, MapUtils.getByteValue(in, \"key\", val), 0);\n        assertEquals(val, MapUtils.getByteValue(in, \"key\"), 0);\n        assertEquals(val, MapUtils.getByteValue(in, \"noKey\", val), 0);\n        assertEquals(val, MapUtils.getByteValue(in, \"noKey\", key -> ((byte) 100)), 0);\n        assertEquals(0, MapUtils.getByteValue(in, \"noKey\"), 0);\n        assertEquals(val, MapUtils.getByte(in, \"key\", val), 0);\n        assertEquals(val, MapUtils.getByte(in, \"noKey\", val), 0);\n        assertEquals(val, MapUtils.getByte(in, \"noKey\", key -> val), 0);\n\n        final Map<String, String> inStr = new HashMap<>();\n        inStr.put(\"str1\", \"100\");\n\n        assertEquals(MapUtils.getByteValue(inStr, \"str1\", val), val, 0);\n    }\n\n    @Test\n    public void testGetDoubleValue() {\n        final Map<String, Double> in = new HashMap<>();\n        in.put(\"key\", 2.0);\n\n        assertEquals(2.0, MapUtils.getDoubleValue(in, \"key\", 0.0), 0);\n        assertEquals(2.0, MapUtils.getDoubleValue(in, \"key\"), 0);\n        assertEquals(1.0, MapUtils.getDoubleValue(in, \"noKey\", 1.0), 0);\n        assertEquals(5.0, MapUtils.getDoubleValue(in, \"noKey\", key -> 5.0D), 0);\n\n        assertEquals(0, MapUtils.getDoubleValue(in, \"noKey\"), 0);\n        assertEquals(2.0, MapUtils.getDouble(in, \"key\", 0.0), 0);\n        assertEquals(1.0, MapUtils.getDouble(in, \"noKey\", 1.0), 0);\n        assertEquals(1.0, MapUtils.getDouble(in, \"noKey\", key -> 1.0), 0);\n\n        final Map<String, String> inStr = new HashMap<>();\n        final char decimalSeparator = getDecimalSeparator();\n        inStr.put(\"str1\", \"2\" + decimalSeparator + \"0\");\n\n        assertEquals(MapUtils.getDoubleValue(inStr, \"str1\", 0.0), 2.0, 0);\n    }\n\n    @Test\n    public void testGetFloatValue() {\n        final Map<String, Float> in = new HashMap<>();\n        in.put(\"key\", 2.0f);\n\n        assertEquals(2.0, MapUtils.getFloatValue(in, \"key\", 0.0f), 0);\n        assertEquals(2.0, MapUtils.getFloatValue(in, \"key\"), 0);\n        assertEquals(1.0, MapUtils.getFloatValue(in, \"noKey\", 1.0f), 0);\n        assertEquals(1.0, MapUtils.getFloatValue(in, \"noKey\", key -> 1.0F), 0);\n        assertEquals(0, MapUtils.getFloatValue(in, \"noKey\"), 0);\n        assertEquals(2.0, MapUtils.getFloat(in, \"key\", 0.0f), 0);\n        assertEquals(1.0, MapUtils.getFloat(in, \"noKey\", 1.0f), 0);\n        assertEquals(1.0, MapUtils.getFloat(in, \"noKey\", key -> 1.0F), 0);\n\n        final Map<String, String> inStr = new HashMap<>();\n        final char decimalSeparator = getDecimalSeparator();\n        inStr.put(\"str1\", \"2\" + decimalSeparator + \"0\");\n\n        assertEquals(MapUtils.getFloatValue(inStr, \"str1\", 0.0f), 2.0, 0);\n    }\n\n    @Test\n    public void testGetIntValue() {\n        final Map<String, Integer> in = new HashMap<>();\n        in.put(\"key\", 2);\n\n        assertEquals(2, MapUtils.getIntValue(in, \"key\", 0), 0);\n        assertEquals(2, MapUtils.getIntValue(in, \"key\"), 0);\n        assertEquals(0, MapUtils.getIntValue(in, \"noKey\", 0), 0);\n        assertEquals(0, MapUtils.getIntValue(in, \"noKey\", key -> 0), 0);\n        assertEquals(0, MapUtils.getIntValue(in, \"noKey\"), 0);\n        assertEquals(2, MapUtils.getInteger(in, \"key\", 0), 0);\n        assertEquals(0, MapUtils.getInteger(in, \"noKey\", 0), 0);\n        assertEquals(0, MapUtils.getInteger(in, \"noKey\", key -> 0), 0);\n\n        final Map<String, String> inStr = new HashMap<>();\n        inStr.put(\"str1\", \"2\");\n\n        assertEquals(MapUtils.getIntValue(inStr, \"str1\", 0), 2, 0);\n    }\n\n    @Test\n    public void testGetLongValue() {\n        final Map<String, Long> in = new HashMap<>();\n        in.put(\"key\", 2L);\n\n        assertEquals(2.0, MapUtils.getLongValue(in, \"key\", 0L), 0);\n        assertEquals(2.0, MapUtils.getLongValue(in, \"key\"), 0);\n        assertEquals(1, MapUtils.getLongValue(in, \"noKey\", 1L), 0);\n        assertEquals(1, MapUtils.getLongValue(in, \"noKey\", key -> 1L), 0);\n        assertEquals(0, MapUtils.getLongValue(in, \"noKey\"), 0);\n        assertEquals(2.0, MapUtils.getLong(in, \"key\", 0L), 0);\n        assertEquals(1, MapUtils.getLong(in, \"noKey\", 1L), 0);\n        assertEquals(1, MapUtils.getLong(in, \"noKey\", key -> 1L), 0);\n\n        final Map<String, Number> in1 = new HashMap<>();\n        in1.put(\"key\", 2);\n\n        assertEquals(Long.valueOf(2), MapUtils.getLong(in1, \"key\"));\n\n        final Map<String, String> inStr = new HashMap<>();\n        inStr.put(\"str1\", \"2\");\n\n        assertEquals(MapUtils.getLongValue(inStr, \"str1\", 0L), 2, 0);\n        assertEquals(MapUtils.getLong(inStr, \"str1\", 1L), 2, 0);\n    }\n\n    @Test\n    public void testGetMap() {\n        final Map<String, Map<String, String>> in = new HashMap<>();\n        final Map<String, String> valMap = new HashMap<>();\n        valMap.put(\"key1\", \"value1\");\n        in.put(\"key1\", valMap);\n        final Map<?, ?> outValue =  MapUtils.getMap(in, \"key1\", (Map<?, ?>) null);\n\n        assertEquals(\"value1\", outValue.get(\"key1\"));\n        assertNull(outValue.get(\"key2\"));\n        assertNull(MapUtils.getMap(in, \"key2\", (Map<?, ?>) null));\n        assertNull(MapUtils.getMap(null, \"key2\", (Map<?, ?>) null));\n    }\n\n    @Test\n    public void testGetNumber() {\n        final Map<String, Number> in = new HashMap<>();\n        final Number val = 1000;\n        in.put(\"key\", val);\n\n        assertEquals(val.intValue(), MapUtils.getNumber(in, \"key\", val).intValue(), 0);\n        assertEquals(val.intValue(), MapUtils.getNumber(in, \"noKey\", val).intValue(), 0);\n        assertEquals(val.intValue(), MapUtils.getNumber(in, \"noKey\", key -> {\n            if (true) {\n                return val;\n            }\n            return null;\n        }).intValue(), 0);\n    }\n\n    @Test\n    public void testGetNumberValueWithInvalidString() {\n        final Map<String, String> map = new HashMap<>();\n        map.put(\"key\", \"one\");\n\n        assertNull(MapUtils.getNumber(map, \"key\"));\n    }\n\n    @Test\n    public void testGetObject() {\n        final Map<String, Object> in = new HashMap<>();\n        in.put(\"key\", \"str\");\n\n        assertEquals(\"str\", MapUtils.getObject(in, \"key\", \"default\"));\n        assertEquals(\"str\", MapUtils.getObject(in, \"key\"));\n        assertNull(MapUtils.getObject(null, \"key\"));\n        assertEquals(\"default\", MapUtils.getObject(in, \"noKey\", \"default\"));\n        assertEquals(\"default\", MapUtils.getObject(null, \"noKey\", \"default\"));\n    }\n\n    @Test\n    public void testGetShortValue() {\n        final Map<String, Short> in = new HashMap<>();\n        final short val = 10;\n        in.put(\"key\", val);\n\n        assertEquals(val, MapUtils.getShortValue(in, \"key\", val), 0);\n        assertEquals(val, MapUtils.getShortValue(in, \"key\"), 0);\n        assertEquals(val, MapUtils.getShortValue(in, \"noKey\", val), 0);\n        assertEquals(val, MapUtils.getShortValue(in, \"noKey\", key -> val), 0);\n        assertEquals(0, MapUtils.getShortValue(in, \"noKey\"), 0);\n        assertEquals(val, MapUtils.getShort(in, \"key\", val), 0);\n        assertEquals(val, MapUtils.getShort(in, \"noKey\", val), 0);\n        assertEquals(val, MapUtils.getShort(in, \"noKey\", key -> val), 0);\n\n        final Map<String, String> inStr = new HashMap<>();\n        inStr.put(\"str1\", \"10\");\n\n        assertEquals(MapUtils.getShortValue(inStr, \"str1\", val), val, 0);\n    }\n\n    @Test\n    public void testGetString() {\n        final Map<String, String> in = new HashMap<>();\n        in.put(\"key\", \"str\");\n\n        assertEquals(\"str\", MapUtils.getString(in, \"key\", \"default\"));\n        assertEquals(\"str\", MapUtils.getString(in, \"key\"));\n        assertNull(MapUtils.getString(null, \"key\"));\n        assertEquals(\"default\", MapUtils.getString(in, \"noKey\", \"default\"));\n        assertEquals(\"default\", MapUtils.getString(in, \"noKey\", key -> {\n            if (\"noKey\".equals(key)) {\n                return \"default\";\n            }\n            return StringUtils.EMPTY;\n        }));\n        assertEquals(\"default\", MapUtils.getString(null, \"noKey\", \"default\"));\n    }\n\n    @Test\n    public void testInvertEmptyMap() {\n        final Map<String, String> emptyMap = new HashMap<>();\n        final Map<String, String> resultMap = MapUtils.invertMap(emptyMap);\n        assertEquals(emptyMap, resultMap);\n    }\n\n    @Test\n    public void testInvertMap() {\n        final Map<String, String> in = new HashMap<>(5, 1);\n        in.put(\"1\", \"A\");\n        in.put(\"2\", \"B\");\n        in.put(\"3\", \"C\");\n        in.put(\"4\", \"D\");\n        in.put(\"5\", \"E\");\n\n        final Set<String> inKeySet = new HashSet<>(in.keySet());\n        final Set<String> inValSet = new HashSet<>(in.values());\n\n        final Map<String, String> out = MapUtils.invertMap(in);\n\n        final Set<String> outKeySet = new HashSet<>(out.keySet());\n        final Set<String> outValSet = new HashSet<>(out.values());\n\n        assertEquals(inKeySet, outValSet);\n        assertEquals(inValSet, outKeySet);\n\n        assertEquals(\"1\", out.get(\"A\"));\n        assertEquals(\"2\", out.get(\"B\"));\n        assertEquals(\"3\", out.get(\"C\"));\n        assertEquals(\"4\", out.get(\"D\"));\n        assertEquals(\"5\", out.get(\"E\"));\n    }\n\n    @Test\n    public void testInvertMapNull() {\n        final Map<String, String> nullMap = null;\n        final Exception exception = assertThrows(NullPointerException.class, () -> MapUtils.invertMap(nullMap));\n        final String actualMessage = exception.getMessage();\n        assertTrue(actualMessage.contains(\"map\"));\n    }\n\n    @Test\n    public void testIsEmptyWithEmptyMap() {\n        final Map<Object, Object> map = new HashMap<>();\n        assertTrue(MapUtils.isEmpty(map));\n    }\n\n    @Test\n    public void testIsEmptyWithNonEmptyMap() {\n        final Map<String, String> map = new HashMap<>();\n        map.put(\"item\", \"value\");\n        assertFalse(MapUtils.isEmpty(map));\n    }\n\n    @Test\n    public void testIsEmptyWithNull() {\n        final Map<Object, Object> map = null;\n        assertTrue(MapUtils.isEmpty(map));\n    }\n\n    @Test\n    public void testIsNotEmptyWithEmptyMap() {\n        final Map<Object, Object> map = new HashMap<>();\n        assertFalse(MapUtils.isNotEmpty(map));\n    }\n\n    @Test\n    public void testIsNotEmptyWithNonEmptyMap() {\n        final Map<String, String> map = new HashMap<>();\n        map.put(\"item\", \"value\");\n        assertTrue(MapUtils.isNotEmpty(map));\n    }\n\n    @Test\n    public void testIsNotEmptyWithNull() {\n        final Map<Object, Object> map = null;\n        assertFalse(MapUtils.isNotEmpty(map));\n    }\n\n    @Test\n    public void testIterableMap() {\n        assertThrows(NullPointerException.class, () -> MapUtils.iterableMap(null),\n                \"Should throw NullPointerException\");\n\n        final HashMap<String, String> map = new HashMap<>();\n        map.put(\"foo\", \"foov\");\n        map.put(\"bar\", \"barv\");\n        map.put(\"baz\", \"bazv\");\n        final IterableMap<String, String> iMap = MapUtils.iterableMap(map);\n        assertEquals(map, iMap);\n        assertNotSame(map, iMap);\n        final HashedMap<String, String> hMap = new HashedMap<>(map);\n        assertSame(hMap, MapUtils.iterableMap(hMap));\n    }\n\n    @Test\n    public void testIterableSortedMap() {\n        assertThrows(NullPointerException.class, () -> MapUtils.iterableSortedMap(null),\n                \"Should throw NullPointerException\");\n\n        final TreeMap<String, String> map = new TreeMap<>();\n        map.put(\"foo\", \"foov\");\n        map.put(\"bar\", \"barv\");\n        map.put(\"baz\", \"bazv\");\n        final IterableSortedMap<String, String> iMap = MapUtils.iterableSortedMap(map);\n        assertEquals(map, iMap);\n        assertNotSame(map, iMap);\n        assertSame(iMap, MapUtils.iterableMap(iMap));\n    }\n\n    @Test\n    public void testLazyMap() {\n        final Map<String, Integer> lazyMap = MapUtils.lazyMap(new HashMap<>(), () -> 1);\n        lazyMap.put(TWO, 2);\n\n        assertEquals(Integer.valueOf(2), lazyMap.get(TWO));\n        assertEquals(Integer.valueOf(1), lazyMap.get(THREE));\n    }\n\n    @Test\n    public void testLazyMapFactory() {\n        final Factory<Integer> factory = FactoryUtils.constantFactory(Integer.valueOf(5));\n        Map<Object, Object> map = MapUtils.lazyMap(new HashMap<>(), factory);\n        assertInstanceOf(LazyMap.class, map);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> MapUtils.lazyMap(new HashMap<>(), (Factory<Object>) null),\n                        \"Expecting NullPointerException for null factory\"),\n                () -> assertThrows(NullPointerException.class, () -> MapUtils.lazyMap((Map<Object, Object>) null, factory),\n                        \"Expecting NullPointerException for null map\")\n        );\n\n        final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);\n        map = MapUtils.lazyMap(new HashMap<>(), transformer);\n        assertInstanceOf(LazyMap.class, map);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> MapUtils.lazyMap(new HashMap<>(), (Transformer<Object, Object>) null),\n                        \"Expecting NullPointerException for null transformer\"),\n                () -> assertThrows(NullPointerException.class, () -> MapUtils.lazyMap((Map<Object, Object>) null, transformer),\n                        \"Expecting NullPointerException for null map\")\n        );\n    }\n\n    @Test\n    public void testLazyMapTransformer() {\n        final Map<Object, Object> map = MapUtils.lazyMap(new HashMap<>(), (Transformer<Object, Object>) mapKey -> {\n            if (mapKey instanceof String) {\n                return Integer.valueOf((String) mapKey);\n            }\n            return null;\n        });\n\n        assertEquals(0, map.size());\n        final Integer i1 = (Integer) map.get(\"5\");\n        assertEquals(Integer.valueOf(5), i1);\n        assertEquals(1, map.size());\n        final Integer i2 = (Integer) map.get(new String(new char[] {'5'}));\n        assertEquals(Integer.valueOf(5), i2);\n        assertEquals(1, map.size());\n        assertSame(i1, i2);\n    }\n\n    @Test\n    public void testLazySortedMapFactory() {\n        final SortedMap<String, Integer> lazySortedMap = MapUtils.lazySortedMap(new TreeMap<>(), () -> 1);\n        lazySortedMap.put(TWO, 2);\n\n        assertEquals(Integer.valueOf(2), lazySortedMap.get(TWO));\n        assertEquals(Integer.valueOf(1), lazySortedMap.get(THREE));\n\n        final Set<Map.Entry<String, Integer>> entrySet = new HashSet<>();\n        entrySet.add(new AbstractMap.SimpleEntry<>(THREE, 1));\n        entrySet.add(new AbstractMap.SimpleEntry<>(TWO, 2));\n\n        assertEquals(entrySet, lazySortedMap.entrySet());\n    }\n\n    @Test\n    public void testLazySortedMapTransformer() {\n        final SortedMap<String, Integer> lazySortedMap = MapUtils.lazySortedMap(new TreeMap<>(), s -> 1);\n        lazySortedMap.put(TWO, 2);\n\n        assertEquals(Integer.valueOf(2), lazySortedMap.get(TWO));\n        assertEquals(Integer.valueOf(1), lazySortedMap.get(THREE));\n\n        final Set<Map.Entry<String, Integer>> entrySet = new HashSet<>();\n        entrySet.add(new AbstractMap.SimpleEntry<>(THREE, 1));\n        entrySet.add(new AbstractMap.SimpleEntry<>(TWO, 2));\n\n        assertEquals(entrySet, lazySortedMap.entrySet());\n    }\n\n    @Test\n    public void testOrderedMap() {\n        final Map<String, String> inMap = new HashMap<>();\n        inMap.put(\"key1\", \"value1\");\n        inMap.put(\"key2\", \"value2\");\n        final Map<String, String> map = MapUtils.orderedMap(inMap);\n        assertInstanceOf(OrderedMap.class, map);\n    }\n\n    @Test\n    public void testPopulateMap() {\n        // Setup Test Data\n        final List<String> list = new ArrayList<>();\n        list.add(\"1\");\n        list.add(\"3\");\n        list.add(\"5\");\n        list.add(\"7\");\n        list.add(\"2\");\n        list.add(\"4\");\n        list.add(\"6\");\n\n        // Now test key transform population\n        Map<Object, Object> map = new HashMap<>();\n        MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(list.size(), map.size());\n\n        for (final String element : list) {\n            assertTrue(map.containsKey(Integer.valueOf(element)));\n            assertFalse(map.containsKey(element));\n            assertTrue(map.containsValue(element));\n            assertEquals(element, map.get(Integer.valueOf(element)));\n        }\n\n        // Now test both Key-Value transform population\n        map = new HashMap<>();\n        MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n\n        assertEquals(list.size(), map.size());\n        for (final String element : list) {\n            assertTrue(map.containsKey(Integer.valueOf(element)));\n            assertFalse(map.containsKey(element));\n            assertTrue(map.containsValue(Integer.valueOf(element)));\n            assertEquals(Integer.valueOf(element), map.get(Integer.valueOf(element)));\n        }\n    }\n\n    @Test\n    public void testPopulateMultiMap() {\n        // Setup Test Data\n        final List<X> list = new ArrayList<>();\n        list.add(new X(1, \"x1\"));\n        list.add(new X(2, \"x2\"));\n        list.add(new X(2, \"x3\"));\n        list.add(new X(5, \"x4\"));\n        list.add(new X(5, \"x5\"));\n\n        // Now test key transform population\n        final MultiValueMap<Integer, X> map = MultiValueMap.multiValueMap(new TreeMap<>());\n        MapUtils.populateMap(map, list, (Transformer<X, Integer>) input -> input.key, TransformerUtils.<X>nopTransformer());\n        assertEquals(list.size(), map.totalSize());\n\n        for (final X element : list) {\n            assertTrue(map.containsKey(element.key));\n            assertTrue(map.containsValue(element));\n        }\n    }\n\n    @Test\n    public void testPredicatedMap() {\n        final Predicate<Object> p = getPredicate();\n        final Map<Object, Object> map = MapUtils.predicatedMap(new HashMap<>(), p, p);\n        assertInstanceOf(PredicatedMap.class, map);\n\n        assertThrows(NullPointerException.class, () -> MapUtils.predicatedMap(null, p, p),\n                \"Expecting NullPointerException for null map.\");\n    }\n\n    @Test\n    public void testPutAll_Map_array() {\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> MapUtils.putAll(null, null)),\n                () -> assertThrows(NullPointerException.class, () -> MapUtils.putAll(null, new Object[0]))\n        );\n\n        Map<String, String> test = MapUtils.putAll(new HashMap<>(), org.apache.commons.lang3.ArrayUtils.EMPTY_STRING_ARRAY);\n        assertEquals(0, test.size());\n\n        // sub array\n        test = MapUtils.putAll(new HashMap<>(), new String[][] {\n                {\"RED\", \"#FF0000\"},\n                {\"GREEN\", \"#00FF00\"},\n                {\"BLUE\", \"#0000FF\"}\n        });\n        assertTrue(test.containsKey(\"RED\"));\n        assertEquals(\"#FF0000\", test.get(\"RED\"));\n        assertTrue(test.containsKey(\"GREEN\"));\n        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n        assertTrue(test.containsKey(\"BLUE\"));\n        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n        assertEquals(3, test.size());\n        assertAll(\n                () -> assertThrows(IllegalArgumentException.class, () -> MapUtils.putAll(new HashMap<>(), new String[][]{\n                        {\"RED\", \"#FF0000\"},\n                    null,\n                        {\"BLUE\", \"#0000FF\"}\n                })),\n                () -> assertThrows(IllegalArgumentException.class, () -> MapUtils.putAll(new HashMap<>(), new String[][]{\n                        {\"RED\", \"#FF0000\"},\n                        {\"GREEN\"},\n                        {\"BLUE\", \"#0000FF\"}\n                })),\n                () -> assertThrows(IllegalArgumentException.class, () -> MapUtils.putAll(new HashMap<>(), new String[][]{\n                        {\"RED\", \"#FF0000\"},\n                        {},\n                        {\"BLUE\", \"#0000FF\"}\n                }))\n        );\n\n        // flat array\n        test = MapUtils.putAll(new HashMap<>(), new String[] {\n            \"RED\", \"#FF0000\",\n            \"GREEN\", \"#00FF00\",\n            \"BLUE\", \"#0000FF\"\n        });\n        assertTrue(test.containsKey(\"RED\"));\n        assertEquals(\"#FF0000\", test.get(\"RED\"));\n        assertTrue(test.containsKey(\"GREEN\"));\n        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n        assertTrue(test.containsKey(\"BLUE\"));\n        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n        assertEquals(3, test.size());\n\n        test = MapUtils.putAll(new HashMap<>(), new String[] {\n            \"RED\", \"#FF0000\",\n            \"GREEN\", \"#00FF00\",\n            \"BLUE\", \"#0000FF\",\n            \"PURPLE\" // ignored\n        });\n        assertTrue(test.containsKey(\"RED\"));\n        assertEquals(\"#FF0000\", test.get(\"RED\"));\n        assertTrue(test.containsKey(\"GREEN\"));\n        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n        assertTrue(test.containsKey(\"BLUE\"));\n        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n        assertEquals(3, test.size());\n\n        test = MapUtils.putAll(new HashMap<>(), null);\n        assertEquals(0, test.size());\n\n        // map entry\n        test = MapUtils.putAll(new HashMap<>(), new Object[] {\n            new DefaultMapEntry<>(\"RED\", \"#FF0000\"),\n            new DefaultMapEntry<>(\"GREEN\", \"#00FF00\"),\n            new DefaultMapEntry<>(\"BLUE\", \"#0000FF\")\n        });\n        assertTrue(test.containsKey(\"RED\"));\n        assertEquals(\"#FF0000\", test.get(\"RED\"));\n        assertTrue(test.containsKey(\"GREEN\"));\n        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n        assertTrue(test.containsKey(\"BLUE\"));\n        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n        assertEquals(3, test.size());\n\n        // key value\n        test = MapUtils.putAll(new HashMap<>(), new Object[] {\n            new DefaultKeyValue<>(\"RED\", \"#FF0000\"),\n            new DefaultKeyValue<>(\"GREEN\", \"#00FF00\"),\n            new DefaultKeyValue<>(\"BLUE\", \"#0000FF\")\n        });\n        assertTrue(test.containsKey(\"RED\"));\n        assertEquals(\"#FF0000\", test.get(\"RED\"));\n        assertTrue(test.containsKey(\"GREEN\"));\n        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n        assertTrue(test.containsKey(\"BLUE\"));\n        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n        assertEquals(3, test.size());\n    }\n\n    @Test\n    public void testSafeAddToMap() {\n\n        final Map<String, Object> inMap = new HashMap<>();\n\n        MapUtils.safeAddToMap(inMap, \"key1\", \"value1\");\n        MapUtils.safeAddToMap(inMap, \"key2\", null);\n        assertEquals(\"value1\", inMap.get(\"key1\"));\n        assertEquals(StringUtils.EMPTY, inMap.get(\"key2\"));\n    }\n\n    @Test\n    public void testSize() {\n        final HashMap<Object, Object> map = new HashMap<>();\n        map.put(\"A\", \"1\");\n        map.put(\"B\", \"2\");\n        assertEquals(2, MapUtils.size(map));\n    }\n\n    @Test\n    public void testSize0() {\n        assertEquals(0, MapUtils.size(new HashMap<>()));\n    }\n\n    @Test\n    public void testSizeNull() {\n        assertEquals(0, MapUtils.size(null));\n    }\n\n    @Test\n    public void testToProperties() {\n        final Map<String, String> in = new HashMap<>();\n        in.put(\"key1\", \"A\");\n        in.put(\"key2\", \"B\");\n        in.put(\"key3\", \"C\");\n\n        final Properties out =  MapUtils.toProperties(in);\n\n        assertEquals(in.get(\"key1\"), out.get(\"key1\"));\n        assertEquals(in.get(\"key2\"), out.get(\"key2\"));\n        assertEquals(in.get(\"key3\"), out.get(\"key3\"));\n    }\n\n    @Test\n    public void testToPropertiesEmpty() {\n        final Map<String, String> in = null;\n        final Properties out =  MapUtils.toProperties(in);\n\n        assertEquals(out.size(), 0);\n    }\n\n    @Test\n    public void testTransformedMap() {\n        final Map<Long, Long> map = new HashMap<>();\n\n        final Map<Long, Long> transformedMap = MapUtils.transformedMap(map, i -> i + 1, i -> i + 10);\n        transformedMap.put(1L, 100L);\n\n        final Set<Map.Entry<Long, Long>> entrySet = new HashSet<>();\n        entrySet.add(new AbstractMap.SimpleEntry<>(2L, 110L));\n\n        assertEquals(entrySet, transformedMap.entrySet());\n    }\n\n    @Test\n    public void testTransformedSortedMap() {\n        final SortedMap<Long, Long> sortedMap = new TreeMap<>();\n\n        final SortedMap<Long, Long> transformedSortedMap = MapUtils.transformedSortedMap(sortedMap, i -> i + 1, i -> i + 10);\n        transformedSortedMap.put(2L, 200L);\n        transformedSortedMap.put(1L, 100L);\n\n        final Set<Map.Entry<Long, Long>> entrySet = new HashSet<>();\n        entrySet.add(new AbstractMap.SimpleEntry<>(2L, 110L));\n        entrySet.add(new AbstractMap.SimpleEntry<>(3L, 210L));\n\n        assertEquals(entrySet, transformedSortedMap.entrySet());\n    }\n\n    @Test\n    public void testUnmodifiableMap() {\n        final Exception exception = assertThrows(UnsupportedOperationException.class, () -> MapUtils.unmodifiableMap(new HashMap<>()).clear());\n    }\n\n    @Test\n    public void testUnmodifiableSortedMap() {\n        final Exception exception = assertThrows(UnsupportedOperationException.class, () -> MapUtils.unmodifiableSortedMap(new TreeMap<>()).clear());\n    }\n\n    @Test\n    public void testVerbosePrint() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String LABEL = \"Print Map\";\n        final String INDENT = \"    \";\n\n        outPrint.println(LABEL + \" = \");\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"0 = A\");\n        outPrint.println(INDENT + \"1 = \");\n        outPrint.println(INDENT + \"{\");\n        outPrint.println(INDENT + INDENT + \"2 = B\");\n        outPrint.println(INDENT + INDENT + \"3 = C\");\n        outPrint.println(INDENT + \"}\");\n        outPrint.println(INDENT + \"7 = (this Map)\");\n        outPrint.println(\"}\");\n\n        final String EXPECTED_OUT = out.toString();\n\n        out.reset();\n\n        final Map<Integer, String> inner = new TreeMap<>(); // treeMap guarantees order across JDKs for test\n        inner.put(2, \"B\");\n        inner.put(3, \"C\");\n\n        final Map<Integer, Object> outer = new TreeMap<>();\n        outer.put(1, inner);\n        outer.put(0, \"A\");\n        outer.put(7, outer);\n\n        MapUtils.verbosePrint(outPrint, \"Print Map\", outer);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testVerbosePrintNullKey() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String INDENT = \"    \";\n\n        final Map<Object, String> map = new HashMap<>();\n        map.put(null, \"A\");\n\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"null = A\");\n        outPrint.println(\"}\");\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.verbosePrint(outPrint, null, map);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testVerbosePrintNullKeyToMap1() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String INDENT = \"    \";\n\n        final Map<Object, Map<?, ?>> map = new HashMap<>();\n        map.put(null, map);\n\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"null = (this Map)\");\n        outPrint.println(\"}\");\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.verbosePrint(outPrint, null, map);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testVerbosePrintNullKeyToMap2() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String INDENT = \"    \";\n\n        final Map<Object, Object> map = new HashMap<>();\n        final Map<Object, Object> map2 = new HashMap<>();\n        map.put(null, map2);\n        map2.put(\"2\", \"B\");\n\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"null = \");\n        outPrint.println(INDENT + \"{\");\n        outPrint.println(INDENT + INDENT + \"2 = B\");\n        outPrint.println(INDENT + \"}\");\n        outPrint.println(\"}\");\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.verbosePrint(outPrint, null, map);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testVerbosePrintNullLabel() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String INDENT = \"    \";\n\n        final Map<Integer, String> map = new TreeMap<>(); // treeMap guarantees order across JDKs for test\n        map.put(2, \"B\");\n        map.put(3, \"C\");\n        map.put(4, null);\n\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"2 = B\");\n        outPrint.println(INDENT + \"3 = C\");\n        outPrint.println(INDENT + \"4 = null\");\n        outPrint.println(\"}\");\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.verbosePrint(outPrint, null, map);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testVerbosePrintNullLabelAndMap() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        outPrint.println(\"null\");\n        final String EXPECTED_OUT = out.toString();\n        out.reset();\n\n        MapUtils.verbosePrint(outPrint, null, null);\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n    @Test\n    public void testVerbosePrintNullStream() {\n        assertThrows(NullPointerException.class, () -> MapUtils.verbosePrint(null, \"Map\", new HashMap<>()),\n                \"Should generate NullPointerException\");\n    }\n\n    @Test\n    public void testVerbosePrintSelfReference() {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final PrintStream outPrint = new PrintStream(out);\n\n        final String LABEL = \"Print Map\";\n        final String INDENT = \"    \";\n\n        final Map<Integer, Object> grandfather = new TreeMap<>(); // treeMap guarantees order across JDKs for test\n        final Map<Integer, Object> father = new TreeMap<>();\n        final Map<Integer, Object> son    = new TreeMap<>();\n\n        grandfather.put(0, \"A\");\n        grandfather.put(1, father);\n\n        father.put(2, \"B\");\n        father.put(3, grandfather);\n        father.put(4, son);\n\n        son.put(5, \"C\");\n        son.put(6, grandfather);\n        son.put(7, father);\n\n        outPrint.println(LABEL + \" = \");\n        outPrint.println(\"{\");\n        outPrint.println(INDENT + \"0 = A\");\n        outPrint.println(INDENT + \"1 = \");\n        outPrint.println(INDENT + \"{\");\n        outPrint.println(INDENT + INDENT + \"2 = B\");\n        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map)\");\n        outPrint.println(INDENT + INDENT + \"4 = \");\n        outPrint.println(INDENT + INDENT + \"{\");\n        outPrint.println(INDENT + INDENT + INDENT + \"5 = C\");\n        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map)\");\n        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map)\");\n        outPrint.println(INDENT + INDENT + \"}\");\n        outPrint.println(INDENT + \"}\");\n        outPrint.println(\"}\");\n\n        final String EXPECTED_OUT = out.toString();\n\n        out.reset();\n        MapUtils.verbosePrint(outPrint, \"Print Map\", grandfather);\n\n        assertEquals(EXPECTED_OUT, out.toString());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String THREE = \"Three\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "THREE = \"Three\"", "syntax_pass": true}, {"attribute_expression": "private static final String TWO = \"Two\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "TWO = \"Two\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java.SplitMapUtilsTest", "name": "SplitMapUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java", "superclasses": "", "methods": ["[void]testAlreadyReadableMap()", "[void]testAlreadyWritableMap()", "[void]testReadableMap()", "[void]testWritableMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java.SplitMapUtilsTest.[void]attemptGetOperation(Runnable)", "src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java.SplitMapUtilsTest.[void]attemptPutOperation(Runnable)", "src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java.SplitMapUtilsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for {@link TransformedSplitMap}\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class SplitMapUtilsTest {\n\n    private Map<String, Integer> backingMap;\n    private TransformedSplitMap<String, String, String, Integer> transformedMap;\n\n    private final Transformer<String, Integer> stringToInt = Integer::valueOf;\n\n    private void attemptGetOperation(final Runnable r) {\n        assertThrows(UnsupportedOperationException.class, () -> r.run(),\n                \"Put exposed as writable Map must not allow Get operations\");\n    }\n\n    private void attemptPutOperation(final Runnable r) {\n        assertThrows(UnsupportedOperationException.class, () -> r.run(),\n                \"Get exposed as writable Map must not allow Put operations\");\n    }\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        backingMap = new HashMap<>();\n        transformedMap = TransformedSplitMap.transformingMap(backingMap, NOPTransformer.<String>nopTransformer(),\n                stringToInt);\n        for (int i = 0; i < 10; i++) {\n            transformedMap.put(String.valueOf(i), String.valueOf(i));\n        }\n    }\n\n    @Test\n    public void testAlreadyReadableMap() {\n        final HashedMap<String, Integer> hashedMap = new HashedMap<>();\n        assertSame(hashedMap, SplitMapUtils.readableMap(hashedMap));\n    }\n\n    @Test\n    public void testAlreadyWritableMap() {\n        final HashedMap<String, String> hashedMap = new HashedMap<>();\n        assertSame(hashedMap, SplitMapUtils.writableMap(hashedMap));\n    }\n\n    @Test\n    public void testReadableMap() {\n        final IterableMap<String, Integer> map = SplitMapUtils.readableMap(transformedMap);\n\n        // basic\n        for (int i = 0; i < 10; i++) {\n            assertFalse(map.containsValue(String.valueOf(i)));\n            assertEquals(i, map.get(String.valueOf(i)).intValue());\n        }\n\n        // mapIterator\n        final MapIterator<String, Integer> it = map.mapIterator();\n        while (it.hasNext()) {\n            final String k = it.next();\n            assertEquals(k, it.getKey());\n            assertEquals(Integer.valueOf(k), it.getValue());\n        }\n\n        // unmodifiable\n        assertInstanceOf(Unmodifiable.class, map);\n\n        // check individual operations\n        int sz = map.size();\n\n        attemptPutOperation(map::clear);\n\n        assertEquals(sz, map.size());\n\n        attemptPutOperation(() -> map.put(\"foo\", 100));\n\n        final HashMap<String, Integer> m = new HashMap<>();\n        m.put(\"foo\", 100);\n        m.put(\"bar\", 200);\n        m.put(\"baz\", 300);\n        attemptPutOperation(() -> map.putAll(m));\n\n        // equals, hashCode\n        final IterableMap<String, Integer> other = SplitMapUtils.readableMap(transformedMap);\n        assertEquals(other, map);\n        assertEquals(other.hashCode(), map.hashCode());\n\n        // remove\n        for (int i = 0; i < 10; i++) {\n            assertEquals(i, map.remove(String.valueOf(i)).intValue());\n            assertEquals(--sz, map.size());\n        }\n        assertTrue(map.isEmpty());\n        assertSame(map, SplitMapUtils.readableMap(map));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testWritableMap() {\n        final Map<String, String> map = SplitMapUtils.writableMap(transformedMap);\n        attemptGetOperation(() -> map.get(null));\n        attemptGetOperation(map::entrySet);\n        attemptGetOperation(map::keySet);\n        attemptGetOperation(map::values);\n        attemptGetOperation(map::size);\n        attemptGetOperation(map::isEmpty);\n        attemptGetOperation(() -> map.containsKey(null));\n        attemptGetOperation(() -> map.containsValue(null));\n        attemptGetOperation(() -> map.remove(null));\n\n        // equals, hashCode\n        final Map<String, String> other = SplitMapUtils.writableMap(transformedMap);\n        assertEquals(other, map);\n        assertEquals(other.hashCode(), map.hashCode());\n\n        // put\n        int sz = backingMap.size();\n        assertFalse(backingMap.containsKey(\"foo\"));\n        map.put(\"new\", \"66\");\n        assertEquals(++sz, backingMap.size());\n\n        // putAll\n        final Map<String, String> more = new HashMap<>();\n        more.put(\"foo\", \"77\");\n        more.put(\"bar\", \"88\");\n        more.put(\"baz\", \"99\");\n        map.putAll(more);\n        assertEquals(sz + more.size(), backingMap.size());\n\n        // clear\n        map.clear();\n        assertTrue(backingMap.isEmpty());\n        assertSame(map, SplitMapUtils.writableMap((Put<String, String>) map));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Map<String, Integer> backingMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, Integer>", "name": "backingMap", "syntax_pass": true}, {"attribute_expression": "private TransformedSplitMap<String, String, String, Integer> transformedMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransformedSplitMap<String, String, String, Integer>", "name": "transformedMap", "syntax_pass": true}, {"attribute_expression": "private final Transformer<String, Integer> stringToInt = Integer::valueOf;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<String, Integer>", "name": "stringToInt = Integer::valueOf", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/MultiMapUtils_getCollectionTest.java.MultiMapUtils_getCollectionTest", "name": "MultiMapUtils_getCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/MultiMapUtils_getCollectionTest.java", "superclasses": "", "methods": ["[void]testGetCollection_WithNonNullMap()", "[void]testGetCollection_WithNullMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MultiMapUtils_getCollectionTest {\n\n    @Test\n    void testGetCollection_WithNonNullMap() {\n        MultiValuedMap<String, String> mockMap = mock(MultiValuedMap.class);\n        Collection<String> mockCollection = mock(Collection.class);\n        when(mockMap.get(\"key\")).thenReturn(mockCollection);\n\n        Collection<String> result = MultiMapUtils.getCollection(mockMap, \"key\");\n\n        assertNotNull(result);\n        assertEquals(mockCollection, result);\n    }\n\n    @Test\n    void testGetCollection_WithNullMap() {\n        Collection<String> result = MultiMapUtils.getCollection(null, \"key\");\n\n        assertNull(result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/SetUtils_isEqualSetTest.java.SetUtils_isEqualSetTest", "name": "SetUtils_isEqualSetTest", "file_path": "src/test/java/org/apache/commons/collections4/SetUtils_isEqualSetTest.java", "superclasses": "", "methods": ["[void]testIsEqualSet_SameReference()", "[void]testIsEqualSet_NullAndNonNull()", "[void]testIsEqualSet_DifferentSizes()", "[void]testIsEqualSet_EqualSets()", "[void]testIsEqualSet_DifferentSets()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SetUtils_isEqualSetTest {\n\n    @Test\n    public void testIsEqualSet_SameReference() {\n        Collection<?> set1 = new HashSet<>(Arrays.asList(1, 2, 3));\n        assertTrue(SetUtils.isEqualSet(set1, set1));\n    }\n\n    @Test\n    public void testIsEqualSet_NullAndNonNull() {\n        Collection<?> set1 = null;\n        Collection<?> set2 = new HashSet<>(Arrays.asList(1, 2, 3));\n        assertFalse(SetUtils.isEqualSet(set1, set2));\n        assertFalse(SetUtils.isEqualSet(set2, set1));\n    }\n\n    @Test\n    public void testIsEqualSet_DifferentSizes() {\n        Collection<?> set1 = new HashSet<>(Arrays.asList(1, 2, 3));\n        Collection<?> set2 = new HashSet<>(Arrays.asList(1, 2));\n        assertFalse(SetUtils.isEqualSet(set1, set2));\n    }\n\n    @Test\n    public void testIsEqualSet_EqualSets() {\n        Collection<?> set1 = new HashSet<>(Arrays.asList(1, 2, 3));\n        Collection<?> set2 = new HashSet<>(Arrays.asList(3, 2, 1));\n        assertTrue(SetUtils.isEqualSet(set1, set2));\n    }\n\n    @Test\n    public void testIsEqualSet_DifferentSets() {\n        Collection<?> set1 = new HashSet<>(Arrays.asList(1, 2, 3));\n        Collection<?> set2 = new HashSet<>(Arrays.asList(1, 2, 4));\n        assertFalse(SetUtils.isEqualSet(set1, set2));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java.IteratorUtilsTest", "name": "IteratorUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java", "superclasses": "", "methods": ["[void]testArrayIterator()", "[void]testArrayListIterator()", "[void]testAsEnumerationNull()", "[void]testAsIterable()", "[void]testAsIterableNull()", "[void]testAsIterator()", "[void]testAsIteratorNull()", "[void]testAsMultipleIterable()", "[void]testAsMultipleIterableNull()", "[void]testChainedIterator()", "[void]testCollatedIterator()", "[void]testCollatedIteratorCollectionNull()", "[void]testCollatedIteratorNull()", "[void]testEmptyIterator()", "[void]testEmptyListIterator()", "[void]testEmptyMapIterator()", "[void]testEmptyOrderedIterator()", "[void]testEmptyOrderedMapIterator()", "[void]testFilteredIterator()", "[void]testFilteredListIterator()", "[void]testFind()", "[void]testFirstFromIterator()", "[void]testForEach()", "[void]testForEachButLast()", "[void]testGetAtIndexFromIterator()", "[void]testGetIterator()", "[void]testIndexOf()", "[void]testLoopingIterator()", "[void]testLoopingListIterator()", "[void]testNodeIterator()", "[void]testNodeListIterator()", "[void]testObjectGraphIterator()", "[void]testPeekingIterator()", "[void]testPushBackIterator()", "[void]testSingletonIterator()", "[void]testSingletonListIterator()", "[void]testToArray()", "[void]testToArray2()", "[void]testToList()", "[void]testToListIterator()", "[void]testToListIteratorNull()", "[void]testTransformedIterator()", "[void]testUnmodifiableIteratorImmutability()", "[void]testUnmodifiableIteratorIteration()", "[void]testUnmodifiableListIteratorImmutability()", "[void]testUnmodifiableListIteratorIteration()", "[void]testUnmodifiableMapIterator()", "[void]testZippingIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java.IteratorUtilsTest.[NodeList]createNodeList(Node[])", "src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java.IteratorUtilsTest.[Node[]]createNodes()", "src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java.IteratorUtilsTest.[Iterator<String>]getImmutableIterator()", "src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java.IteratorUtilsTest.[ListIterator<String>]getImmutableListIterator()", "src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java.IteratorUtilsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for IteratorUtils.\n", "original_string": "public class IteratorUtilsTest {\n\n    /**\n     * Collection of {@link Integer}s\n     */\n    private List<Integer> collectionA;\n\n    /**\n     * Collection of even {@link Integer}s\n     */\n    private List<Integer> collectionEven;\n\n    /**\n     * Collection of odd {@link Integer}s\n     */\n    private List<Integer> collectionOdd;\n\n    private final Collection<Integer> emptyCollection = new ArrayList<>(1);\n\n    private Iterable<Integer> iterableA;\n\n    /**\n     * Creates a NodeList containing the specified nodes.\n     */\n    private NodeList createNodeList(final Node[] nodes) {\n        return new NodeList() {\n            @Override\n            public int getLength() {\n                return nodes.length;\n            }\n\n            @Override\n            public Node item(final int index) {\n                return nodes[index];\n            }\n        };\n    }\n\n    /**\n     * creates an array of four Node instances, mocked by EasyMock.\n     */\n    private Node[] createNodes() {\n        final Node node1 = createMock(Node.class);\n        final Node node2 = createMock(Node.class);\n        final Node node3 = createMock(Node.class);\n        final Node node4 = createMock(Node.class);\n        replay(node1);\n        replay(node2);\n        replay(node3);\n        replay(node4);\n\n        return new Node[] { node1, node2, node3, node4 };\n    }\n\n    /**\n     * Gets an immutable Iterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n     */\n    private Iterator<String> getImmutableIterator() {\n        final List<String> list = new ArrayList<>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        return IteratorUtils.unmodifiableIterator(list.iterator());\n    }\n\n    /**\n     * Gets an immutable ListIterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n     */\n    private ListIterator<String> getImmutableListIterator() {\n        final List<String> list = new ArrayList<>();\n        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n        list.add(\"d\");\n        return IteratorUtils.unmodifiableListIterator(list.listIterator());\n    }\n\n    @BeforeEach\n    public void setUp() {\n        collectionA = new ArrayList<>();\n        collectionA.add(1);\n        collectionA.add(2);\n        collectionA.add(2);\n        collectionA.add(3);\n        collectionA.add(3);\n        collectionA.add(3);\n        collectionA.add(4);\n        collectionA.add(4);\n        collectionA.add(4);\n        collectionA.add(4);\n\n        iterableA = collectionA;\n\n        collectionEven = Arrays.asList(2, 4, 6, 8, 10, 12);\n        collectionOdd = Arrays.asList(1, 3, 5, 7, 9, 11);\n    }\n\n    @Test\n    public void testArrayIterator() {\n        final Object[] objArray = { \"a\", \"b\", \"c\" };\n        ResettableIterator<Object> iterator = IteratorUtils.arrayIterator(objArray);\n        assertEquals(\"a\", iterator.next());\n        assertEquals(\"b\", iterator.next());\n        iterator.reset();\n        assertEquals(\"a\", iterator.next());\n        assertAll(\n                () -> assertThrows(IllegalArgumentException.class, () -> IteratorUtils.arrayIterator(Integer.valueOf(0)),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.arrayIterator((Object[]) null),\n                        \"Expecting NullPointerException\")\n        );\n\n        iterator = IteratorUtils.arrayIterator(objArray, 1);\n        assertEquals(\"b\", iterator.next());\n\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> IteratorUtils.arrayIterator(objArray, -1),\n                \"Expecting IndexOutOfBoundsException\");\n\n        iterator = IteratorUtils.arrayIterator(objArray, 3);\n        assertFalse(iterator.hasNext());\n        iterator.reset();\n\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> IteratorUtils.arrayIterator(objArray, 4),\n                \"Expecting IndexOutOfBoundsException\");\n\n        iterator = IteratorUtils.arrayIterator(objArray, 2, 3);\n        assertEquals(\"c\", iterator.next());\n        assertAll(\n                () -> assertThrows(ArrayIndexOutOfBoundsException.class, () -> IteratorUtils.arrayIterator(objArray, 2, 4),\n                        \"Expecting IndexOutOfBoundsException\"),\n                () -> assertThrows(ArrayIndexOutOfBoundsException.class, () -> IteratorUtils.arrayIterator(objArray, -1, 1),\n                        \"Expecting IndexOutOfBoundsException\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> IteratorUtils.arrayIterator(objArray, 2, 1),\n                        \"Expecting IllegalArgumentException\")\n        );\n\n        final int[] intArray = { 0, 1, 2 };\n        iterator = IteratorUtils.arrayIterator(intArray);\n        assertEquals(0, iterator.next());\n        assertEquals(1, iterator.next());\n        iterator.reset();\n        assertEquals(0, iterator.next());\n\n        iterator = IteratorUtils.arrayIterator(intArray, 1);\n        assertEquals(1, iterator.next());\n\n        assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayIterator(intArray, -1),\n                \"Expecting IndexOutOfBoundsException\");\n\n        iterator = IteratorUtils.arrayIterator(intArray, 3);\n        assertFalse(iterator.hasNext());\n        iterator.reset();\n\n        assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayIterator(intArray, 4),\n                \"Expecting IndexOutOfBoundsException\");\n\n        iterator = IteratorUtils.arrayIterator(intArray, 2, 3);\n        assertEquals(2, iterator.next());\n        assertAll(\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayIterator(intArray, 2, 4),\n                        \"Expecting IndexOutOfBoundsException\"),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayIterator(intArray, -1, 1),\n                        \"Expecting IndexOutOfBoundsException\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> IteratorUtils.arrayIterator(intArray, 2, 1),\n                        \"Expecting IllegalArgumentException\")\n        );\n    }\n\n    @Test\n    public void testArrayListIterator() {\n        final Object[] objArray = { \"a\", \"b\", \"c\", \"d\" };\n        ResettableListIterator<Object> iterator = IteratorUtils.arrayListIterator(objArray);\n        assertFalse(iterator.hasPrevious());\n        assertEquals(-1, iterator.previousIndex());\n        assertEquals(0, iterator.nextIndex());\n        assertEquals(\"a\", iterator.next());\n        assertEquals(\"a\", iterator.previous());\n        assertEquals(\"a\", iterator.next());\n        assertEquals(0, iterator.previousIndex());\n        assertEquals(1, iterator.nextIndex());\n        assertEquals(\"b\", iterator.next());\n        assertEquals(\"c\", iterator.next());\n        assertEquals(\"d\", iterator.next());\n        assertEquals(4, iterator.nextIndex()); // size of list\n        assertEquals(3, iterator.previousIndex());\n        assertAll(\n                () -> assertThrows(IllegalArgumentException.class, () -> IteratorUtils.arrayListIterator(Integer.valueOf(0)),\n                        \"Expecting IllegalArgumentException\"),\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.arrayListIterator((Object[]) null),\n                        \"Expecting NullPointerException\")\n        );\n\n        iterator = IteratorUtils.arrayListIterator(objArray, 1);\n        assertEquals(-1, iterator.previousIndex());\n        assertFalse(iterator.hasPrevious());\n        assertEquals(0, iterator.nextIndex());\n        assertEquals(\"b\", iterator.next());\n        assertEquals(0, iterator.previousIndex());\n        assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayListIterator(objArray, -1),\n                \"Expecting IndexOutOfBoundsException.\");\n\n        iterator = IteratorUtils.arrayListIterator(objArray, 3);\n        assertTrue(iterator.hasNext());\n\n        final ResettableListIterator<Object> finalIterator = iterator;\n        assertAll(\n                () -> assertThrows(NoSuchElementException.class, () -> finalIterator.previous(),\n                        \"Expecting NoSuchElementException.\"),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayListIterator(objArray, 5),\n                        \"Expecting IndexOutOfBoundsException.\")\n        );\n\n        iterator = IteratorUtils.arrayListIterator(objArray, 2, 3);\n        assertEquals(\"c\", iterator.next());\n        assertAll(\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayListIterator(objArray, 2, 5),\n                        \"Expecting IndexOutOfBoundsException\"),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayListIterator(objArray, -1, 1),\n                        \"Expecting IndexOutOfBoundsException\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> IteratorUtils.arrayListIterator(objArray, 2, 1),\n                        \"Expecting IllegalArgumentException\")\n        );\n\n        final int[] intArray = { 0, 1, 2 };\n        iterator = IteratorUtils.arrayListIterator(intArray);\n        assertEquals(iterator.previousIndex(), -1);\n        assertFalse(iterator.hasPrevious());\n        assertEquals(0, iterator.nextIndex());\n        assertEquals(0, iterator.next());\n        assertEquals(0, iterator.previousIndex());\n        assertEquals(1, iterator.nextIndex());\n        assertEquals(1, iterator.next());\n        assertEquals(1, iterator.previousIndex());\n        assertEquals(2, iterator.nextIndex());\n        assertEquals(1, iterator.previous());\n        assertEquals(1, iterator.next());\n\n        iterator = IteratorUtils.arrayListIterator(intArray, 1);\n        assertEquals(-1, iterator.previousIndex());\n        assertFalse(iterator.hasPrevious());\n        assertEquals(0, iterator.nextIndex());\n        assertEquals(1, iterator.next());\n        assertEquals(1, iterator.previous());\n        assertEquals(1, iterator.next());\n        assertEquals(0, iterator.previousIndex());\n        assertEquals(1, iterator.nextIndex());\n        assertEquals(2, iterator.next());\n        assertEquals(1, iterator.previousIndex());\n        assertEquals(2, iterator.nextIndex());\n        assertEquals(2, iterator.previous());\n        assertEquals(0, iterator.previousIndex());\n        assertEquals(1, iterator.nextIndex());\n\n        assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayListIterator(intArray, -1),\n                \"Expecting IndexOutOfBoundsException\");\n\n        iterator = IteratorUtils.arrayListIterator(intArray, 3);\n        assertFalse(iterator.hasNext());\n\n        assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayListIterator(intArray, 4),\n                \"Expecting IndexOutOfBoundsException\");\n\n        iterator = IteratorUtils.arrayListIterator(intArray, 2, 3);\n        assertFalse(iterator.hasPrevious());\n        assertEquals(-1, iterator.previousIndex());\n        assertEquals(2, iterator.next());\n        assertTrue(iterator.hasPrevious());\n        assertFalse(iterator.hasNext());\n        assertAll(\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayListIterator(intArray, 2, 4),\n                        \"Expecting IndexOutOfBoundsException\"),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.arrayListIterator(intArray, -1, 1),\n                        \"Expecting IndexOutOfBoundsException\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> IteratorUtils.arrayListIterator(intArray, 2, 1),\n                        \"Expecting IllegalArgumentException\")\n        );\n    }\n\n    @Test\n    public void testAsEnumerationNull() {\n        assertThrows(NullPointerException.class, () -> IteratorUtils.asEnumeration(null));\n    }\n\n    @Test\n    public void testAsIterable() {\n        final List<Integer> list = new ArrayList<>();\n        list.add(Integer.valueOf(0));\n        list.add(Integer.valueOf(1));\n        list.add(Integer.valueOf(2));\n        final Iterator<Integer> iterator = list.iterator();\n\n        final Iterable<Integer> iterable = IteratorUtils.asIterable(iterator);\n        int expected = 0;\n        for (final Integer actual : iterable) {\n            assertEquals(expected, actual.intValue());\n            ++expected;\n        }\n        // insure iteration occurred\n        assertTrue(expected > 0);\n\n        // single use iterator\n        assertFalse(IteratorUtils.asIterable(iterator).iterator().hasNext(), \"should not be able to iterate twice\");\n    }\n\n    @Test\n    public void testAsIterableNull() {\n        assertThrows(NullPointerException.class, () -> IteratorUtils.asIterable(null),\n                \"Expecting NullPointerException\");\n    }\n\n    @Test\n    public void testAsIterator() {\n        final Vector<String> vector = new Vector<>();\n        vector.addElement(\"zero\");\n        vector.addElement(\"one\");\n        final Enumeration<String> en = vector.elements();\n        assertTrue(IteratorUtils.asIterator(en) instanceof Iterator, \"create instance fail\");\n        assertThrows(NullPointerException.class, () -> IteratorUtils.asIterator(null));\n    }\n\n    @Test\n    public void testAsIteratorNull() {\n        final Collection coll = new ArrayList();\n        coll.add(\"test\");\n        final Vector<String> vector = new Vector<>();\n        vector.addElement(\"test\");\n        vector.addElement(\"one\");\n        final Enumeration<String> en = vector.elements();\n        assertTrue(IteratorUtils.asIterator(en, coll) instanceof Iterator, \"create instance fail\");\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.asIterator(null, coll)),\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.asIterator(en, null))\n        );\n    }\n\n    @Test\n    public void testAsMultipleIterable() {\n        final List<Integer> list = new ArrayList<>();\n        list.add(Integer.valueOf(0));\n        list.add(Integer.valueOf(1));\n        list.add(Integer.valueOf(2));\n        final Iterator<Integer> iterator = list.iterator();\n\n        final Iterable<Integer> iterable = IteratorUtils.asMultipleUseIterable(iterator);\n        int expected = 0;\n        for (final Integer actual : iterable) {\n            assertEquals(expected, actual.intValue());\n            ++expected;\n        }\n        // insure iteration occurred\n        assertTrue(expected > 0);\n\n        // multiple use iterator\n        expected = 0;\n        for (final Integer actual : iterable) {\n            assertEquals(expected, actual.intValue());\n            ++expected;\n        }\n        // insure iteration occurred\n        assertTrue(expected > 0);\n    }\n\n    @Test\n    public void testAsMultipleIterableNull() {\n        assertThrows(NullPointerException.class, () -> IteratorUtils.asMultipleUseIterable(null),\n                \"Expecting NullPointerException\");\n    }\n\n    @Test\n    public void testChainedIterator() {\n        final ArrayList arrayList = new ArrayList();\n        final Iterator iterator = arrayList.iterator();\n        assertTrue(IteratorUtils.chainedIterator(iterator) instanceof Iterator, \"create instance fail\");\n        final Collection<Iterator<?>> coll = new ArrayList();\n        assertTrue(IteratorUtils.chainedIterator(coll) instanceof Iterator, \"create instance fail\");\n    }\n\n    /**\n     * Tests methods collatedIterator(...)\n     */\n    @Test\n    public void testCollatedIterator() {\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null),\n                        \"expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.collatedIterator(null, null, collectionEven.iterator()),\n                        \"expecting NullPointerException\")\n        );\n\n        // natural ordering\n        Iterator<Integer> it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(),\n                collectionEven.iterator());\n\n        List<Integer> result = IteratorUtils.toList(it);\n        assertEquals(12, result.size());\n\n        final List<Integer> combinedList = new ArrayList<>(collectionOdd);\n        combinedList.addAll(collectionEven);\n        Collections.sort(combinedList);\n\n        assertEquals(combinedList, result);\n\n        it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), emptyCollection.iterator());\n        result = IteratorUtils.toList(it);\n        assertEquals(collectionOdd, result);\n\n        final Comparator<Integer> reverseComparator = ComparatorUtils\n                .reversedComparator(ComparatorUtils.<Integer>naturalComparator());\n\n        Collections.reverse(collectionOdd);\n        Collections.reverse(collectionEven);\n        Collections.reverse(combinedList);\n\n        it = IteratorUtils.collatedIterator(reverseComparator, collectionOdd.iterator(), collectionEven.iterator());\n        result = IteratorUtils.toList(it);\n        assertEquals(combinedList, result);\n    }\n\n    @Test\n    public void testCollatedIteratorCollectionNull() {\n        final Collection<Iterator<?>> coll = new ArrayList<>();\n        coll.add(collectionOdd.iterator());\n        // natural ordering\n        final Iterator<?> it = IteratorUtils.collatedIterator(null, coll);\n        final List<?> result = IteratorUtils.toList(it);\n        assertEquals(6, result.size());\n        assertThrows(NullPointerException.class, () -> IteratorUtils.collatedIterator(null, (Collection<Iterator<?>>) null));\n    }\n\n    @Test\n    public void testCollatedIteratorNull() {\n        final ArrayList arrayList = new ArrayList();\n        // natural ordering\n        Iterator<Integer> it = IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionOdd.iterator(),\n                collectionOdd.iterator());\n\n        List<Integer> result = IteratorUtils.toList(it);\n        assertEquals(18, result.size());\n\n        it = IteratorUtils.collatedIterator(null, collectionOdd.iterator());\n        result = IteratorUtils.toList(it);\n        assertEquals(collectionOdd, result);\n\n        final Comparator<Integer> reverseComparator = ComparatorUtils\n                .reversedComparator(ComparatorUtils.<Integer>naturalComparator());\n\n        Collections.reverse(collectionOdd);\n\n        it = IteratorUtils.collatedIterator(reverseComparator, collectionOdd.iterator());\n        result = IteratorUtils.toList(it);\n        assertEquals(collectionOdd, result);\n        assertThrows(NullPointerException.class, () -> IteratorUtils.collatedIterator(null, arrayList.iterator(), arrayList.listIterator(), null));\n    }\n\n    /**\n     * Test empty iterator\n     */\n    @Test\n    public void testEmptyIterator() {\n        assertSame(EmptyIterator.INSTANCE, IteratorUtils.EMPTY_ITERATOR);\n        assertSame(EmptyIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_ITERATOR);\n        assertTrue(IteratorUtils.EMPTY_ITERATOR instanceof Iterator);\n        assertTrue(IteratorUtils.EMPTY_ITERATOR instanceof ResettableIterator);\n        assertFalse(IteratorUtils.EMPTY_ITERATOR instanceof OrderedIterator);\n        assertFalse(IteratorUtils.EMPTY_ITERATOR instanceof ListIterator);\n        assertFalse(IteratorUtils.EMPTY_ITERATOR instanceof MapIterator);\n        assertFalse(IteratorUtils.EMPTY_ITERATOR.hasNext());\n        IteratorUtils.EMPTY_ITERATOR.reset();\n        assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.EMPTY_ITERATOR);\n        assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.emptyIterator());\n        assertAll(\n                () -> assertThrows(NoSuchElementException.class, () -> IteratorUtils.EMPTY_ITERATOR.next()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_ITERATOR.remove())\n        );\n    }\n\n    /**\n     * Test empty list iterator\n     */\n    @Test\n    public void testEmptyListIterator() {\n        assertSame(EmptyListIterator.INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);\n        assertSame(EmptyListIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);\n        assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof Iterator);\n        assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof ListIterator);\n        assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableIterator);\n        assertTrue(IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableListIterator);\n        assertFalse(IteratorUtils.EMPTY_LIST_ITERATOR instanceof MapIterator);\n        assertFalse(IteratorUtils.EMPTY_LIST_ITERATOR.hasNext());\n        assertEquals(0, IteratorUtils.EMPTY_LIST_ITERATOR.nextIndex());\n        assertEquals(-1, IteratorUtils.EMPTY_LIST_ITERATOR.previousIndex());\n        IteratorUtils.EMPTY_LIST_ITERATOR.reset();\n        assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.EMPTY_LIST_ITERATOR);\n        assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.emptyListIterator());\n        assertAll(\n                () -> assertThrows(NoSuchElementException.class, () -> IteratorUtils.EMPTY_LIST_ITERATOR.next()),\n                () -> assertThrows(NoSuchElementException.class, () -> IteratorUtils.EMPTY_LIST_ITERATOR.previous()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_LIST_ITERATOR.remove()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.emptyListIterator().set(null)),\n                () -> assertThrows(UnsupportedOperationException.class, () -> IteratorUtils.emptyListIterator().add(null))\n        );\n    }\n\n    /**\n     * Test empty map iterator\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEmptyMapIterator() {\n        assertSame(EmptyMapIterator.INSTANCE, IteratorUtils.EMPTY_MAP_ITERATOR);\n        assertTrue(IteratorUtils.EMPTY_MAP_ITERATOR instanceof Iterator);\n        assertTrue(IteratorUtils.EMPTY_MAP_ITERATOR instanceof MapIterator);\n        assertTrue(IteratorUtils.EMPTY_MAP_ITERATOR instanceof ResettableIterator);\n        assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR instanceof ListIterator);\n        assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedIterator);\n        assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedMapIterator);\n        assertFalse(IteratorUtils.EMPTY_MAP_ITERATOR.hasNext());\n        ((ResettableIterator<Object>) IteratorUtils.EMPTY_MAP_ITERATOR).reset();\n        assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.EMPTY_MAP_ITERATOR);\n        assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.emptyMapIterator());\n        assertAll(\n                () -> assertThrows(NoSuchElementException.class, () -> IteratorUtils.EMPTY_MAP_ITERATOR.next()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_MAP_ITERATOR.remove()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_MAP_ITERATOR.getKey()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_MAP_ITERATOR.getValue()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_MAP_ITERATOR.setValue(null))\n        );\n    }\n\n    /**\n     * Test empty map iterator\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEmptyOrderedIterator() {\n        assertSame(EmptyOrderedIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_ITERATOR);\n        assertTrue(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof Iterator);\n        assertTrue(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof OrderedIterator);\n        assertTrue(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ResettableIterator);\n        assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ListIterator);\n        assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof MapIterator);\n        assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR.hasNext());\n        assertFalse(IteratorUtils.EMPTY_ORDERED_ITERATOR.hasPrevious());\n        ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_ITERATOR).reset();\n        assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.EMPTY_ORDERED_ITERATOR);\n        assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.emptyOrderedIterator());\n        assertAll(\n                () -> assertThrows(NoSuchElementException.class, () -> IteratorUtils.EMPTY_ORDERED_ITERATOR.next()),\n                () -> assertThrows(NoSuchElementException.class, () -> IteratorUtils.EMPTY_ORDERED_ITERATOR.previous()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_ORDERED_ITERATOR.remove())\n        );\n    }\n\n    /**\n     * Test empty map iterator\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEmptyOrderedMapIterator() {\n        assertSame(EmptyOrderedMapIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);\n        assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof Iterator);\n        assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof MapIterator);\n        assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof OrderedMapIterator);\n        assertTrue(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ResettableIterator);\n        assertFalse(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ListIterator);\n        assertFalse(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasNext());\n        assertFalse(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasPrevious());\n        ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR).reset();\n        assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);\n        assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.emptyOrderedMapIterator());\n        assertAll(\n                () -> assertThrows(NoSuchElementException.class, () -> IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.next()),\n                () -> assertThrows(NoSuchElementException.class, () -> IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.previous()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.remove()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getKey()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getValue()),\n                () -> assertThrows(IllegalStateException.class, () -> IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.setValue(null))\n        );\n    }\n\n    @Test\n    public void testFilteredIterator() {\n        final ArrayList arrayList = new ArrayList();\n        final Iterator iterator = arrayList.iterator();\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.filteredIterator(iterator, null)),\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.filteredIterator(null, null))\n        );\n    }\n\n    @Test\n    public void testFilteredListIterator() {\n        final List arrayList = new ArrayList();\n        arrayList.add(\"test\");\n        final Predicate predicate = INSTANCE;\n        assertTrue(IteratorUtils.filteredListIterator(arrayList.listIterator(), predicate) instanceof ListIterator,\n                \"create instance fail\");\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.filteredListIterator(null, predicate)),\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.filteredListIterator(arrayList.listIterator(), null))\n        );\n    }\n\n    @Test\n    public void testFind() {\n        Predicate<Number> testPredicate = equalPredicate((Number) 4);\n        Integer test = IteratorUtils.find(iterableA.iterator(), testPredicate);\n        assertEquals(4, (int) test);\n        testPredicate = equalPredicate((Number) 45);\n        test = IteratorUtils.find(iterableA.iterator(), testPredicate);\n        assertNull(test);\n        assertNull(IteratorUtils.find(null, testPredicate));\n\n        assertThrows(NullPointerException.class, () -> IteratorUtils.find(iterableA.iterator(), null),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testFirstFromIterator() throws Exception {\n        // Iterator, entry exists\n        final Iterator<Integer> iterator = iterableA.iterator();\n        assertEquals(1, (int) IteratorUtils.first(iterator));\n    }\n\n    @Test\n    public void testForEach() {\n        final List<Integer> listA = new ArrayList<>();\n        listA.add(1);\n\n        final List<Integer> listB = new ArrayList<>();\n        listB.add(2);\n\n        final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<List<Integer>> col = new ArrayList<>();\n        col.add(listA);\n        col.add(listB);\n        IteratorUtils.forEach(col.iterator(), testClosure);\n        assertTrue(listA.isEmpty() && listB.isEmpty());\n\n        assertThrows(NullPointerException.class, () -> IteratorUtils.forEach(col.iterator(), null),\n                \"expecting NullPointerException\");\n\n        IteratorUtils.forEach(null, testClosure);\n\n        // null should be OK\n        col.add(null);\n        IteratorUtils.forEach(col.iterator(), testClosure);\n    }\n\n    @Test\n    public void testForEachButLast() {\n        final List<Integer> listA = new ArrayList<>();\n        listA.add(1);\n\n        final List<Integer> listB = new ArrayList<>();\n        listB.add(2);\n\n        final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<List<Integer>> col = new ArrayList<>();\n        col.add(listA);\n        col.add(listB);\n        List<Integer> last = IteratorUtils.forEachButLast(col.iterator(), testClosure);\n        assertTrue(listA.isEmpty() && !listB.isEmpty());\n        assertSame(listB, last);\n\n        assertThrows(NullPointerException.class, () -> IteratorUtils.forEachButLast(col.iterator(), null),\n                \"expecting NullPointerException\");\n\n        IteratorUtils.forEachButLast(null, testClosure);\n\n        // null should be OK\n        col.add(null);\n        col.add(null);\n        last = IteratorUtils.forEachButLast(col.iterator(), testClosure);\n        assertNull(last);\n    }\n\n    @Test\n    public void testGetAtIndexFromIterator() throws Exception {\n        // Iterator, entry exists\n        Iterator<Integer> iterator = iterableA.iterator();\n        assertEquals(1, (int) IteratorUtils.get(iterator, 0));\n        iterator = iterableA.iterator();\n        assertEquals(2, (int) IteratorUtils.get(iterator, 1));\n\n        // Iterator, non-existent entry\n        final Iterator<Integer> finalIterator = iterator;\n        assertThrows(IndexOutOfBoundsException.class, () -> IteratorUtils.get(finalIterator, 10),\n                \"Expecting IndexOutOfBoundsException.\");\n\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator() {\n        final Object[] objArray = { \"a\", \"b\", \"c\" };\n        final Map<String, String> inMap = new HashMap<>();\n        final Node[] nodes = createNodes();\n        final NodeList nodeList = createNodeList(nodes);\n\n        assertTrue(IteratorUtils.getIterator(null) instanceof EmptyIterator, \"returns empty iterator when null passed\");\n        assertTrue(IteratorUtils.getIterator(iterableA.iterator()) instanceof Iterator, \"returns Iterator when Iterator directly \");\n        assertTrue(IteratorUtils.getIterator(iterableA) instanceof Iterator, \"returns Iterator when iterable passed\");\n        assertTrue(IteratorUtils.getIterator(objArray) instanceof ObjectArrayIterator,\n                \"returns ObjectArrayIterator when Object array passed\");\n        assertTrue(IteratorUtils.getIterator(inMap) instanceof Iterator, \"returns Iterator when Map passed\");\n        assertTrue(IteratorUtils.getIterator(nodeList) instanceof NodeListIterator, \"returns NodeListIterator when nodeList passed\");\n        assertTrue(IteratorUtils.getIterator(new Vector().elements()) instanceof EnumerationIterator,\n                \"returns EnumerationIterator when Enumeration passed\");\n        final Node node1 = createMock(Node.class);\n        assertTrue(IteratorUtils.getIterator(node1) instanceof NodeListIterator,\n                \"returns NodeListIterator when nodeList passed\");\n        final Dictionary dic = createMock(Dictionary.class);\n        assertTrue(IteratorUtils.getIterator(dic) instanceof EnumerationIterator,\n                \"returns EnumerationIterator when Dictionary passed\");\n        final int[] arr = new int[8];\n        assertTrue(IteratorUtils.getIterator(arr) instanceof ArrayIterator, \"returns ArrayIterator when array passed\");\n    }\n\n    @Test\n    public void testIndexOf() {\n        Predicate<Number> testPredicate = equalPredicate((Number) 4);\n        int index = IteratorUtils.indexOf(iterableA.iterator(), testPredicate);\n        assertEquals(6, index);\n        testPredicate = equalPredicate((Number) 45);\n        index = IteratorUtils.indexOf(iterableA.iterator(), testPredicate);\n        assertEquals(-1, index);\n        assertEquals(-1, IteratorUtils.indexOf(null, testPredicate));\n\n        assertThrows(NullPointerException.class, () -> IteratorUtils.indexOf(iterableA.iterator(), null),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testLoopingIterator() {\n        final ArrayList arrayList = new ArrayList();\n        arrayList.add(\"test\");\n        final Collection coll = new ArrayList();\n        coll.add(\"test\");\n        final Iterator iterator = arrayList.iterator();\n        assertTrue(IteratorUtils.loopingIterator(coll) instanceof ResettableIterator, \"create instance fail\");\n        assertThrows(NullPointerException.class, () -> IteratorUtils.loopingIterator(null));\n    }\n\n    @Test\n    public void testLoopingListIterator() {\n        final ArrayList arrayList = new ArrayList();\n        arrayList.add(\"test\");\n        final Iterator iterator = arrayList.iterator();\n        assertTrue(IteratorUtils.loopingListIterator(arrayList) instanceof ResettableIterator, \"create instance fail\");\n        assertThrows(NullPointerException.class, () -> IteratorUtils.loopingListIterator(null));\n    }\n\n    /**\n     * Tests method nodeListIterator(Node)\n     */\n    @Test\n    public void testNodeIterator() {\n        final Node[] nodes = createNodes();\n        final NodeList nodeList = createNodeList(nodes);\n        final Node parentNode = createMock(Node.class);\n        expect(parentNode.getChildNodes()).andStubReturn(nodeList);\n        replay(parentNode);\n\n        final Iterator<Node> iterator = IteratorUtils.nodeListIterator(parentNode);\n        int expectedNodeIndex = 0;\n        for (final Node actual : IteratorUtils.asIterable(iterator)) {\n            assertEquals(nodes[expectedNodeIndex], actual);\n            ++expectedNodeIndex;\n        }\n\n        // insure iteration occurred\n        assertTrue(expectedNodeIndex > 0);\n\n        // single use iterator\n        assertFalse(IteratorUtils.asIterable(iterator).iterator().hasNext(), \"should not be able to iterate twice\");\n\n        assertThrows(NullPointerException.class, () -> IteratorUtils.nodeListIterator((Node) null),\n                \"Expecting NullPointerException\");\n    }\n\n    /**\n     * Tests method nodeListIterator(NodeList)\n     */\n    @Test\n    public void testNodeListIterator() {\n        final Node[] nodes = createNodes();\n        final NodeList nodeList = createNodeList(nodes);\n\n        final Iterator<Node> iterator = IteratorUtils.nodeListIterator(nodeList);\n        int expectedNodeIndex = 0;\n        for (final Node actual : IteratorUtils.asIterable(iterator)) {\n            assertEquals(nodes[expectedNodeIndex], actual);\n            ++expectedNodeIndex;\n        }\n\n        // insure iteration occurred\n        assertTrue(expectedNodeIndex > 0);\n\n        // single use iterator\n        assertFalse(IteratorUtils.asIterable(iterator).iterator().hasNext(), \"should not be able to iterate twice\");\n\n        assertThrows(NullPointerException.class, () -> IteratorUtils.nodeListIterator((NodeList) null),\n                \"Expecting NullPointerException\");\n    }\n\n    @Test\n    public void testObjectGraphIterator() {\n        assertTrue(IteratorUtils.objectGraphIterator(null, null) instanceof Iterator, \"create instance fail\");\n    }\n\n    @Test\n    public void testPeekingIterator() {\n        final ArrayList arrayList = new ArrayList();\n        final Iterator iterator = arrayList.iterator();\n        assertTrue(IteratorUtils.peekingIterator(iterator) instanceof Iterator, \"create instance fail\");\n        assertThrows(NullPointerException.class, () -> IteratorUtils.peekingIterator(null));\n    }\n\n    @Test\n    public void testPushBackIterator() {\n        final ArrayList arrayList = new ArrayList();\n        final Iterator iterator = arrayList.iterator();\n        assertTrue(IteratorUtils.pushbackIterator(iterator) instanceof Iterator, \"create instance fail\");\n        assertThrows(NullPointerException.class, () -> IteratorUtils.pushbackIterator(null));\n    }\n\n    @Test\n    public void testSingletonIterator() {\n        assertTrue(IteratorUtils.singletonIterator(new Object()) instanceof ResettableIterator, \"create instance fail\");\n    }\n\n    @Test\n    public void testSingletonListIterator() {\n        assertTrue(IteratorUtils.singletonListIterator(new Object()) instanceof Iterator, \"create instance fail\");\n    }\n\n    @Test\n    public void testToArray() {\n        final List<Object> list = new ArrayList<>();\n        list.add(Integer.valueOf(1));\n        list.add(\"Two\");\n        list.add(null);\n        final Object[] result = IteratorUtils.toArray(list.iterator());\n        assertEquals(list, Arrays.asList(result));\n\n        assertThrows(NullPointerException.class, () -> IteratorUtils.toArray(null),\n                \"Expecting NullPointerException\");\n    }\n\n    @Test\n    public void testToArray2() {\n        final List<String> list = new ArrayList<>();\n        list.add(\"One\");\n        list.add(\"Two\");\n        list.add(null);\n        final String[] result = IteratorUtils.toArray(list.iterator(), String.class);\n        assertEquals(list, Arrays.asList(result));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.toArray(list.iterator(), null),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.toArray(null, String.class),\n                        \"Expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    public void testToList() {\n        final List<Object> list = new ArrayList<>();\n        list.add(Integer.valueOf(1));\n        list.add(\"Two\");\n        list.add(null);\n        final List<Object> result = IteratorUtils.toList(list.iterator());\n        assertEquals(list, result);\n        // add\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.toList(null, 10),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> IteratorUtils.toList(list.iterator(), -1),\n                        \"Expecting IllegalArgumentException\")\n        );\n    }\n\n    @Test\n    public void testToListIterator() {\n        final List<Integer> list = new ArrayList<>();\n        list.add(Integer.valueOf(0));\n        list.add(Integer.valueOf(1));\n        list.add(Integer.valueOf(2));\n        final Iterator<Integer> iterator = list.iterator();\n\n        final ListIterator<Integer> liItr = IteratorUtils.toListIterator(iterator);\n        int expected = 0;\n        while (liItr.hasNext()) {\n            assertEquals(expected, liItr.next().intValue());\n            ++expected;\n        }\n    }\n\n    @Test\n    public void testToListIteratorNull() {\n        assertThrows(NullPointerException.class, () -> IteratorUtils.toListIterator(null),\n                \"Expecting NullPointerException\");\n    }\n\n    @Test\n    public void testTransformedIterator() {\n        final ArrayList arrayList = new ArrayList();\n        final Iterator iterator = arrayList.iterator();\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.transformedIterator(iterator, null)),\n                () -> assertThrows(NullPointerException.class, () -> IteratorUtils.transformedIterator(null, null))\n        );\n    }\n\n    /**\n     * Test remove() for an immutable Iterator.\n     */\n    @Test\n    public void testUnmodifiableIteratorImmutability() {\n        final Iterator<String> iterator = getImmutableIterator();\n\n        assertThrows(UnsupportedOperationException.class, () -> iterator.remove(),\n                \"remove() should throw an UnsupportedOperationException\");\n\n        iterator.next();\n\n        assertThrows(UnsupportedOperationException.class, () -> iterator.remove(),\n                \"remove() should throw an UnsupportedOperationException\");\n    }\n\n    /**\n     * Test next() and hasNext() for an immutable Iterator.\n     */\n    @Test\n    public void testUnmodifiableIteratorIteration() {\n        final Iterator<String> iterator = getImmutableIterator();\n\n        assertTrue(iterator.hasNext());\n\n        assertEquals(\"a\", iterator.next());\n\n        assertTrue(iterator.hasNext());\n\n        assertEquals(\"b\", iterator.next());\n\n        assertTrue(iterator.hasNext());\n\n        assertEquals(\"c\", iterator.next());\n\n        assertTrue(iterator.hasNext());\n\n        assertEquals(\"d\", iterator.next());\n\n        assertFalse(iterator.hasNext());\n    }\n\n    /**\n     * Test remove() for an immutable ListIterator.\n     */\n    @Test\n    public void testUnmodifiableListIteratorImmutability() {\n        final ListIterator<String> listIterator = getImmutableListIterator();\n        assertAll(\n                () -> assertThrows(UnsupportedOperationException.class, () -> listIterator.remove(),\n                        \"remove() should throw an UnsupportedOperationException\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> listIterator.set(\"a\"),\n                        \"set(Object) should throw an UnsupportedOperationException\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> listIterator.add(\"a\"),\n                        \"add(Object) should throw an UnsupportedOperationException\")\n        );\n\n        listIterator.next();\n        assertAll(\n                () -> assertThrows(UnsupportedOperationException.class, () -> listIterator.remove(),\n                        \"remove() should throw an UnsupportedOperationException\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> listIterator.set(\"a\"),\n                        \"set(Object) should throw an UnsupportedOperationException\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> listIterator.add(\"a\"),\n                        \"add(Object) should throw an UnsupportedOperationException\")\n        );\n    }\n\n    /**\n     * Test next(), hasNext(), previous() and hasPrevious() for an immutable ListIterator.\n     */\n    @Test\n    public void testUnmodifiableListIteratorIteration() {\n        final ListIterator<String> listIterator = getImmutableListIterator();\n\n        assertFalse(listIterator.hasPrevious());\n        assertTrue(listIterator.hasNext());\n\n        assertEquals(\"a\", listIterator.next());\n\n        assertTrue(listIterator.hasPrevious());\n        assertTrue(listIterator.hasNext());\n\n        assertEquals(\"b\", listIterator.next());\n\n        assertTrue(listIterator.hasPrevious());\n        assertTrue(listIterator.hasNext());\n\n        assertEquals(\"c\", listIterator.next());\n\n        assertTrue(listIterator.hasPrevious());\n        assertTrue(listIterator.hasNext());\n\n        assertEquals(\"d\", listIterator.next());\n\n        assertTrue(listIterator.hasPrevious());\n        assertFalse(listIterator.hasNext());\n\n        assertEquals(\"d\", listIterator.previous());\n\n        assertTrue(listIterator.hasPrevious());\n        assertTrue(listIterator.hasNext());\n\n        assertEquals(\"c\", listIterator.previous());\n\n        assertTrue(listIterator.hasPrevious());\n        assertTrue(listIterator.hasNext());\n\n        assertEquals(\"b\", listIterator.previous());\n\n        assertTrue(listIterator.hasPrevious());\n        assertTrue(listIterator.hasNext());\n\n        assertEquals(\"a\", listIterator.previous());\n\n        assertFalse(listIterator.hasPrevious());\n        assertTrue(listIterator.hasNext());\n    }\n\n    @Test\n    public void testUnmodifiableMapIterator() {\n        final Set<?> set = new LinkedHashSet<>();\n        final MapIterator iterator = new EntrySetToMapIteratorAdapter(set);\n        assertTrue(IteratorUtils.unmodifiableMapIterator(iterator) instanceof MapIterator, \"create instance fail\");\n        assertThrows(NullPointerException.class, () -> IteratorUtils.unmodifiableMapIterator(null));\n    }\n\n    @Test\n    public void testZippingIterator() {\n        final ArrayList arrayList = new ArrayList();\n        final Iterator iterator = arrayList.iterator();\n        assertTrue(IteratorUtils.zippingIterator(iterator, iterator, iterator) instanceof ZippingIterator, \"create instance fail\");\n        assertTrue(IteratorUtils.zippingIterator(iterator, iterator) instanceof ZippingIterator, \"create instance fail\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<Integer> collectionA;", "docstring": "\nCollection of {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Integer>", "name": "collectionA", "syntax_pass": true}, {"attribute_expression": "private List<Integer> collectionEven;", "docstring": "\nCollection of even {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Integer>", "name": "collectionEven", "syntax_pass": true}, {"attribute_expression": "private List<Integer> collectionOdd;", "docstring": "\nCollection of odd {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Integer>", "name": "collectionOdd", "syntax_pass": true}, {"attribute_expression": "private final Collection<Integer> emptyCollection = new ArrayList<>(1);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<Integer>", "name": "emptyCollection = new ArrayList<>(1)", "syntax_pass": true}, {"attribute_expression": "private Iterable<Integer> iterableA;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Integer>", "name": "iterableA", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/TransformerUtils_switchMapTransformerTest.java.TransformerUtils_switchMapTransformerTest", "name": "TransformerUtils_switchMapTransformerTest", "file_path": "src/test/java/org/apache/commons/collections4/TransformerUtils_switchMapTransformerTest.java", "superclasses": "", "methods": ["[void]testSwitchMapTransformer_WithDefaultTransformer()", "[void]testSwitchMapTransformer_WithoutDefaultTransformer()", "[void]testSwitchMapTransformer_WithNullInput()", "[void]testSwitchMapTransformer_WithEmptyMap()", "[void]testSwitchMapTransformer_WithNullMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformerUtils_switchMapTransformerTest {\n\n    @Test\n    public void testSwitchMapTransformer_WithDefaultTransformer() {\n        // Given\n        Map<Integer, Transformer<Integer, String>> map = new HashMap<>();\n        map.put(1, ConstantTransformer.constantTransformer(\"One\"));\n        map.put(2, ConstantTransformer.constantTransformer(\"Two\"));\n        map.put(null, ConstantTransformer.constantTransformer(\"Default\"));\n\n        // When\n        Transformer<Integer, String> transformer = TransformerUtils.switchMapTransformer(map);\n\n        // Then\n        assertEquals(\"One\", transformer.transform(1));\n        assertEquals(\"Two\", transformer.transform(2));\n        assertEquals(\"Default\", transformer.transform(3));\n    }\n\n    @Test\n    public void testSwitchMapTransformer_WithoutDefaultTransformer() {\n        // Given\n        Map<Integer, Transformer<Integer, String>> map = new HashMap<>();\n        map.put(1, ConstantTransformer.constantTransformer(\"One\"));\n        map.put(2, ConstantTransformer.constantTransformer(\"Two\"));\n\n        // When\n        Transformer<Integer, String> transformer = TransformerUtils.switchMapTransformer(map);\n\n        // Then\n        assertEquals(\"One\", transformer.transform(1));\n        assertEquals(\"Two\", transformer.transform(2));\n        assertNull(transformer.transform(3));\n    }\n\n    @Test\n    public void testSwitchMapTransformer_WithNullInput() {\n        // Given\n        Map<Integer, Transformer<Integer, String>> map = new HashMap<>();\n        map.put(1, ConstantTransformer.constantTransformer(\"One\"));\n        map.put(null, ConstantTransformer.constantTransformer(\"Default\"));\n\n        // When\n        Transformer<Integer, String> transformer = TransformerUtils.switchMapTransformer(map);\n\n        // Then\n        assertEquals(\"Default\", transformer.transform(null));\n    }\n\n    @Test\n    public void testSwitchMapTransformer_WithEmptyMap() {\n        // Given\n        Map<Integer, Transformer<Integer, String>> map = new HashMap<>();\n\n        // When\n        Transformer<Integer, String> transformer = TransformerUtils.switchMapTransformer(map);\n\n        // Then\n        assertNull(transformer.transform(1));\n    }\n\n    @Test\n    public void testSwitchMapTransformer_WithNullMap() {\n        // Given\n        Map<Integer, Transformer<Integer, String>> map = null;\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> TransformerUtils.switchMapTransformer(map));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/BagUtilsTest.java.BagUtilsTest", "name": "BagUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/BagUtilsTest.java", "superclasses": "", "methods": ["[void]testPredicatedBag()", "[void]testPredicatedSortedBag()", "[void]testSynchronizedBag()", "[void]testSynchronizedSortedBag()", "[void]testTransformedBag()", "[void]testTransformedSortedBag()", "[void]testUnmodifiableBag()", "[void]testUnmodifiableSortedBag()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests for BagUtils factory methods.\n", "original_string": "public class BagUtilsTest {\n\n    protected Predicate<Object> truePredicate = TruePredicate.truePredicate();\n    protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();\n\n    @Test\n    public void testPredicatedBag() {\n        final Bag<Object> bag = BagUtils.predicatedBag(new HashBag<>(), truePredicate);\n        assertInstanceOf(PredicatedBag.class, bag, \"Returned object should be a PredicatedBag.\");\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> BagUtils.predicatedBag(null, truePredicate),\n                        \"Expecting NullPointerException for null bag.\"),\n                () -> assertThrows(NullPointerException.class, () -> BagUtils.predicatedBag(new HashBag<>(), null),\n                        \"Expecting NullPointerException for null predicate.\")\n        );\n    }\n\n    @Test\n    public void testPredicatedSortedBag() {\n        final Bag<Object> bag = BagUtils.predicatedSortedBag(new TreeBag<>(), truePredicate);\n        assertInstanceOf(PredicatedSortedBag.class, bag, \"Returned object should be a PredicatedSortedBag.\");\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> BagUtils.predicatedSortedBag(null, truePredicate),\n                        \"Expecting NullPointerException for null bag.\"),\n                () -> assertThrows(NullPointerException.class, () -> BagUtils.predicatedSortedBag(new TreeBag<>(), null),\n                        \"Expecting NullPointerException for null predicate.\")\n        );\n    }\n\n    @Test\n    public void testSynchronizedBag() {\n        final Bag<Object> bag = BagUtils.synchronizedBag(new HashBag<>());\n        assertInstanceOf(SynchronizedBag.class, bag, \"Returned object should be a SynchronizedBag.\");\n        assertThrows(NullPointerException.class, () -> BagUtils.synchronizedBag(null),\n                \"Expecting NullPointerException for null bag.\");\n    }\n\n    @Test\n    public void testSynchronizedSortedBag() {\n        final Bag<Object> bag = BagUtils.synchronizedSortedBag(new TreeBag<>());\n        assertInstanceOf(SynchronizedSortedBag.class, bag, \"Returned object should be a SynchronizedSortedBag.\");\n        assertThrows(NullPointerException.class, () -> BagUtils.synchronizedSortedBag(null),\n                \"Expecting NullPointerException for null bag.\");\n    }\n\n    @Test\n    public void testTransformedBag() {\n        final Bag<Object> bag = BagUtils.transformingBag(new HashBag<>(), nopTransformer);\n        assertInstanceOf(TransformedBag.class, bag, \"Returned object should be an TransformedBag.\");\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> BagUtils.transformingBag(null, nopTransformer),\n                        \"Expecting NullPointerException for null bag.\"),\n                () -> assertThrows(NullPointerException.class, () -> BagUtils.transformingBag(new HashBag<>(), null),\n                        \"Expecting NullPointerException for null transformer.\")\n        );\n    }\n\n    @Test\n    public void testTransformedSortedBag() {\n        final Bag<Object> bag = BagUtils.transformingSortedBag(new TreeBag<>(), nopTransformer);\n        assertInstanceOf(TransformedSortedBag.class, bag, \"Returned object should be an TransformedSortedBag\");\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> BagUtils.transformingSortedBag(null, nopTransformer),\n                        \"Expecting NullPointerException for null bag.\"),\n                () -> assertThrows(NullPointerException.class, () -> BagUtils.transformingSortedBag(new TreeBag<>(), null),\n                        \"Expecting NullPointerException for null transformer.\")\n        );\n    }\n\n    @Test\n    public void testUnmodifiableBag() {\n        final Bag<Object> bag = BagUtils.unmodifiableBag(new HashBag<>());\n        assertInstanceOf(UnmodifiableBag.class, bag, \"Returned object should be an UnmodifiableBag.\");\n        assertThrows(NullPointerException.class, () -> BagUtils.unmodifiableBag(null),\n                \"Expecting NullPointerException for null bag.\");\n        assertSame(bag, BagUtils.unmodifiableBag(bag), \"UnmodifiableBag shall not be decorated\");\n    }\n\n    @Test\n    public void testUnmodifiableSortedBag() {\n        final SortedBag<Object> bag = BagUtils.unmodifiableSortedBag(new TreeBag<>());\n        assertInstanceOf(UnmodifiableSortedBag.class, bag, \"Returned object should be an UnmodifiableSortedBag.\");\n        assertThrows(NullPointerException.class, () -> BagUtils.unmodifiableSortedBag(null),\n                \"Expecting NullPointerException for null bag.\");\n        assertSame(bag, BagUtils.unmodifiableSortedBag(bag), \"UnmodifiableSortedBag shall not be decorated\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<Object> truePredicate = TruePredicate.truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<Object>", "name": "truePredicate = TruePredicate.truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Transformer<Object, Object>", "name": "nopTransformer = TransformerUtils.nopTransformer()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_indexOfTest.java.IteratorUtils_indexOfTest", "name": "IteratorUtils_indexOfTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_indexOfTest.java", "superclasses": "", "methods": ["[void]testIndexOf_ElementFound()", "[void]testIndexOf_ElementNotFound()", "[void]testIndexOf_NullIterator()", "[void]testIndexOf_NullPredicate()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_indexOfTest {\n\n    @Test\n    public void testIndexOf_ElementFound() {\n        Iterator<Integer> iterator = Arrays.asList(1, 2, 3, 4, 5).iterator();\n        Predicate<Integer> predicate = i -> i == 3;\n\n        int result = IteratorUtils.indexOf(iterator, new org.apache.commons.collections4.Predicate<Integer>() {\n            @Override\n            public boolean evaluate(Integer object) {\n                return predicate.test(object);\n            }\n        });\n\n        assertEquals(2, result);\n    }\n\n    @Test\n    public void testIndexOf_ElementNotFound() {\n        Iterator<Integer> iterator = Arrays.asList(1, 2, 3, 4, 5).iterator();\n        Predicate<Integer> predicate = i -> i == 6;\n\n        int result = IteratorUtils.indexOf(iterator, new org.apache.commons.collections4.Predicate<Integer>() {\n            @Override\n            public boolean evaluate(Integer object) {\n                return predicate.test(object);\n            }\n        });\n\n        assertEquals(CollectionUtils.INDEX_NOT_FOUND, result);\n    }\n\n    @Test\n    public void testIndexOf_NullIterator() {\n        Predicate<Integer> predicate = i -> i == 3;\n\n        int result = IteratorUtils.indexOf(null, new org.apache.commons.collections4.Predicate<Integer>() {\n            @Override\n            public boolean evaluate(Integer object) {\n                return predicate.test(object);\n            }\n        });\n\n        assertEquals(CollectionUtils.INDEX_NOT_FOUND, result);\n    }\n\n    @Test\n    public void testIndexOf_NullPredicate() {\n        Iterator<Integer> iterator = Arrays.asList(1, 2, 3, 4, 5).iterator();\n\n        assertThrows(NullPointerException.class, () -> {\n            IteratorUtils.indexOf(iterator, null);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/ComparatorUtils_maxTest.java.ComparatorUtils_maxTest", "name": "ComparatorUtils_maxTest", "file_path": "src/test/java/org/apache/commons/collections4/ComparatorUtils_maxTest.java", "superclasses": "", "methods": ["[void]testMaxWithDefaultComparator()", "[void]testMaxWithCustomComparator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ComparatorUtils_maxTest {\n\n    @Test\n    public void testMaxWithDefaultComparator() {\n        // Given\n        Integer o1 = 5;\n        Integer o2 = 10;\n\n        // When\n        Integer result = ComparatorUtils.max(o1, o2, null);\n\n        // Then\n        assertEquals(o2, result);\n    }\n\n    @Test\n    public void testMaxWithCustomComparator() {\n        // Given\n        Integer o1 = 5;\n        Integer o2 = 10;\n        Comparator<Integer> reverseComparator = Comparator.reverseOrder();\n\n        // When\n        Integer result = ComparatorUtils.max(o1, o2, reverseComparator);\n\n        // Then\n        assertEquals(o1, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/ArrayStackTest.java.ArrayStackTest", "name": "ArrayStackTest", "file_path": "src/test/java/org/apache/commons/collections4/ArrayStackTest.java", "superclasses": "", "methods": ["[void]testNewStack()", "[void]testPushPeekPop()", "[void]testSearch()"], "method_uris": ["src/test/java/org/apache/commons/collections4/ArrayStackTest.java.ArrayStackTest.[]ArrayStackTest()", "src/test/java/org/apache/commons/collections4/ArrayStackTest.java.ArrayStackTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/ArrayStackTest.java.ArrayStackTest.[ArrayStack<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests ArrayStack.\n", "original_string": "@SuppressWarnings(\"deprecation\") // we test a deprecated class\npublic class ArrayStackTest<E> extends AbstractArrayListTest<E> {\n\n    public ArrayStackTest() {\n        super(ArrayStackTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public ArrayStack<E> makeObject() {\n        return new ArrayStack<>();\n    }\n\n    @Test\n    public void testNewStack() {\n        final ArrayStack<E> stack = makeObject();\n        assertTrue(stack.empty(), \"New stack is empty\");\n        assertEquals(0, stack.size(), \"New stack has size zero\");\n\n        assertThrows(EmptyStackException.class, () -> stack.peek());\n\n        assertThrows(EmptyStackException.class, () -> stack.pop());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPushPeekPop() {\n        final ArrayStack<E> stack = makeObject();\n\n        stack.push((E) \"First Item\");\n        assertFalse(stack.empty(), \"Stack is not empty\");\n        assertEquals(1, stack.size(), \"Stack size is one\");\n        assertEquals(\"First Item\", (String) stack.peek(),\n                \"Top item is 'First Item'\");\n        assertEquals(1, stack.size(), \"Stack size is one\");\n\n        stack.push((E) \"Second Item\");\n        assertEquals(2, stack.size(), \"Stack size is two\");\n        assertEquals(\"Second Item\", (String) stack.peek(),\n                \"Top item is 'Second Item'\");\n        assertEquals(2, stack.size(), \"Stack size is two\");\n\n        assertEquals(\"Second Item\", (String) stack.pop(),\n                \"Popped item is 'Second Item'\");\n        assertEquals(\"First Item\", (String) stack.peek(),\n                \"Top item is 'First Item'\");\n        assertEquals(1, stack.size(), \"Stack size is one\");\n\n        assertEquals(\"First Item\", (String) stack.pop(),\n                \"Popped item is 'First Item'\");\n        assertEquals(0, stack.size(), \"Stack size is zero\");\n    }\n\n    @Test\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void testSearch() {\n        final ArrayStack<E> stack = makeObject();\n\n        stack.push((E) \"First Item\");\n        stack.push((E) \"Second Item\");\n        assertEquals(1, stack.search(\"Second Item\"),\n                \"Top item is 'Second Item'\");\n        assertEquals(2, stack.search(\"First Item\"),\n                \"Next Item is 'First Item'\");\n        assertEquals(-1, stack.search(\"Missing Item\"),\n                \"Cannot find 'Missing Item'\");\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/ArrayStack.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/ArrayStack.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_sizeTest.java.IteratorUtils_sizeTest", "name": "IteratorUtils_sizeTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_sizeTest.java", "superclasses": "", "methods": ["[void]testSizeWithNullIterator()", "[void]testSizeWithEmptyIterator()", "[void]testSizeWithSingletonIterator()", "[void]testSizeWithArrayIterator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_sizeTest {\n\n    @Test\n    public void testSizeWithNullIterator() {\n        // Given\n        Iterator<?> iterator = null;\n\n        // When\n        int size = IteratorUtils.size(iterator);\n\n        // Then\n        assertEquals(0, size);\n    }\n\n    @Test\n    public void testSizeWithEmptyIterator() {\n        // Given\n        Iterator<?> iterator = IteratorUtils.emptyIterator();\n\n        // When\n        int size = IteratorUtils.size(iterator);\n\n        // Then\n        assertEquals(0, size);\n    }\n\n    @Test\n    public void testSizeWithSingletonIterator() {\n        // Given\n        Iterator<?> iterator = IteratorUtils.singletonIterator(\"element\");\n\n        // When\n        int size = IteratorUtils.size(iterator);\n\n        // Then\n        assertEquals(1, size);\n    }\n\n    @Test\n    public void testSizeWithArrayIterator() {\n        // Given\n        Iterator<?> iterator = IteratorUtils.arrayIterator(new String[]{\"a\", \"b\", \"c\"});\n\n        // When\n        int size = IteratorUtils.size(iterator);\n\n        // Then\n        assertEquals(3, size);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_toStringTest.java.IteratorUtils_toStringTest", "name": "IteratorUtils_toStringTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringWithDefaultDelimiter()", "[void]testToStringWithEmptyIterator()", "[void]testToStringWithSingleElement()", "[void]testToStringWithNullElement()", "[void]testToStringWithCustomDelimiter()"], "method_uris": ["src/test/java/org/apache/commons/collections4/IteratorUtils_toStringTest.java.IteratorUtils_toStringTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_toStringTest {\n\n    private Iterator<String> iterator;\n\n    @BeforeEach\n    public void setUp() {\n        iterator = new ArrayIterator<>(new String[]{\"a\", \"b\", \"c\"});\n    }\n\n    @Test\n    public void testToStringWithDefaultDelimiter() {\n        String result = IteratorUtils.toString(iterator);\n        assertEquals(\"[a, b, c]\", result);\n    }\n\n    @Test\n    public void testToStringWithEmptyIterator() {\n        iterator = new ArrayIterator<>(new String[]{});\n        String result = IteratorUtils.toString(iterator);\n        assertEquals(\"[]\", result);\n    }\n\n    @Test\n    public void testToStringWithSingleElement() {\n        iterator = new ArrayIterator<>(new String[]{\"a\"});\n        String result = IteratorUtils.toString(iterator);\n        assertEquals(\"[a]\", result);\n    }\n\n    @Test\n    public void testToStringWithNullElement() {\n        iterator = new ArrayIterator<>(new String[]{\"a\", null, \"c\"});\n        String result = IteratorUtils.toString(iterator);\n        assertEquals(\"[a, null, c]\", result);\n    }\n\n    @Test\n    public void testToStringWithCustomDelimiter() {\n        String result = IteratorUtils.toString(iterator, TransformerUtils.stringValueTransformer(), \"|\", \"{\", \"}\");\n        assertEquals(\"{a|b|c}\", result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Iterator<String> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<String>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/ComparatorUtilsTest.java.ComparatorUtilsTest", "name": "ComparatorUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/ComparatorUtilsTest.java", "superclasses": "", "methods": ["[void]testBooleanComparator()", "[void]testChainedComparator()", "[void]testMax()", "[void]testMin()", "[void]testNullHighComparator()", "[void]testNullLowComparator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests ComparatorUtils.\n", "original_string": "public class ComparatorUtilsTest {\n\n    @Test\n    public void testBooleanComparator() {\n        Comparator<Boolean> comp = ComparatorUtils.booleanComparator(true);\n        assertTrue(comp.compare(Boolean.TRUE, Boolean.FALSE) < 0);\n        assertEquals(0, comp.compare(Boolean.TRUE, Boolean.TRUE));\n        assertTrue(comp.compare(Boolean.FALSE, Boolean.TRUE) > 0);\n\n        comp = ComparatorUtils.booleanComparator(false);\n        assertTrue(comp.compare(Boolean.TRUE, Boolean.FALSE) > 0);\n        assertEquals(0, comp.compare(Boolean.TRUE, Boolean.TRUE));\n        assertTrue(comp.compare(Boolean.FALSE, Boolean.TRUE) < 0);\n    }\n\n    @Test\n    public void testChainedComparator() {\n        // simple test: chain 2 natural comparators\n        final Comparator<Integer> comp = ComparatorUtils.chainedComparator(ComparatorUtils.<Integer>naturalComparator(),\n                ComparatorUtils.naturalComparator());\n        assertTrue(comp.compare(1, 2) < 0);\n        assertEquals(0, comp.compare(1, 1));\n        assertTrue(comp.compare(2, 1) > 0);\n    }\n\n    @Test\n    public void testMax() {\n        final Comparator<Integer> reversed =\n                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());\n\n        assertEquals(Integer.valueOf(10), ComparatorUtils.max(1, 10, null));\n        assertEquals(Integer.valueOf(10), ComparatorUtils.max(10, -10, null));\n\n        assertEquals(Integer.valueOf(1), ComparatorUtils.max(1, 10, reversed));\n        assertEquals(Integer.valueOf(-10), ComparatorUtils.max(10, -10, reversed));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ComparatorUtils.max(1, null, null),\n                        \"expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> ComparatorUtils.max(null, 10, null),\n                        \"expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    public void testMin() {\n        final Comparator<Integer> reversed =\n                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());\n\n        assertEquals(Integer.valueOf(1), ComparatorUtils.min(1, 10, null));\n        assertEquals(Integer.valueOf(-10), ComparatorUtils.min(10, -10, null));\n\n        assertEquals(Integer.valueOf(10), ComparatorUtils.min(1, 10, reversed));\n        assertEquals(Integer.valueOf(10), ComparatorUtils.min(10, -10, reversed));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ComparatorUtils.min(1, null, null),\n                        \"expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> ComparatorUtils.min(null, 10, null),\n                        \"expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    public void testNullHighComparator() {\n        final Comparator<Integer> comp = ComparatorUtils.nullHighComparator(null);\n        assertTrue(comp.compare(null, 10) > 0);\n        assertEquals(0, comp.compare(null, null));\n        assertTrue(comp.compare(10, null) < 0);\n    }\n\n    @Test\n    public void testNullLowComparator() {\n        final Comparator<Integer> comp = ComparatorUtils.nullLowComparator(null);\n        assertTrue(comp.compare(null, 10) < 0);\n        assertEquals(0, comp.compare(null, null));\n        assertTrue(comp.compare(10, null) > 0);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/QueueUtilsTest.java.QueueUtilsTest", "name": "QueueUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/QueueUtilsTest.java", "superclasses": "", "methods": ["[void]testEmptyQueue()", "[void]testPredicatedQueue()", "[void]testSynchronizedQueue()", "[void]testTransformedQueue()", "[void]testUnmodifiableQueue()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests for QueueUtils factory methods.\n", "original_string": "public class QueueUtilsTest {\n\n    protected Predicate<Object> truePredicate = TruePredicate.truePredicate();\n    protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();\n\n    @Test\n    public void testEmptyQueue() {\n        final Queue<Object> queue = QueueUtils.emptyQueue();\n        assertInstanceOf(UnmodifiableQueue.class, queue, \"Returned object should be an UnmodifiableQueue.\");\n        assertTrue(queue.isEmpty(), \"Returned queue is not empty.\");\n\n        assertThrows(UnsupportedOperationException.class, () -> queue.add(new Object()),\n                \"Expecting UnsupportedOperationException for empty queue.\");\n    }\n\n    @Test\n    public void testPredicatedQueue() {\n        final Queue<Object> queue = QueueUtils.predicatedQueue(new LinkedList<>(), truePredicate);\n        assertInstanceOf(PredicatedQueue.class, queue, \"Returned object should be a PredicatedQueue.\");\n\n        assertThrows(NullPointerException.class, () -> QueueUtils.predicatedQueue(null, truePredicate),\n                \"Expecting NullPointerException for null queue.\");\n\n        assertThrows(NullPointerException.class, () -> QueueUtils.predicatedQueue(new LinkedList<>(), null),\n                \"Expecting NullPointerException for null predicate.\");\n    }\n\n    @Test\n    public void testSynchronizedQueue() {\n        final Queue<Object> queue = QueueUtils.synchronizedQueue(new LinkedList<>());\n        assertInstanceOf(SynchronizedQueue.class, queue, \"Returned object should be a SynchronizedQueue.\");\n\n        assertThrows(NullPointerException.class, () -> QueueUtils.synchronizedQueue(null),\n                \"Expecting NullPointerException for null queue.\");\n    }\n\n    @Test\n    public void testTransformedQueue() {\n        final Queue<Object> queue = QueueUtils.transformingQueue(new LinkedList<>(), nopTransformer);\n        assertInstanceOf(TransformedQueue.class, queue, \"Returned object should be an TransformedQueue.\");\n\n        assertThrows(NullPointerException.class, () -> QueueUtils.transformingQueue(null, nopTransformer),\n                \"Expecting NullPointerException for null queue.\");\n\n        assertThrows(NullPointerException.class, () -> QueueUtils.transformingQueue(new LinkedList<>(), null),\n                \"Expecting NullPointerException for null transformer.\");\n    }\n\n    @Test\n    public void testUnmodifiableQueue() {\n        final Queue<Object> queue = QueueUtils.unmodifiableQueue(new LinkedList<>());\n        assertInstanceOf(UnmodifiableQueue.class, queue, \"Returned object should be an UnmodifiableQueue.\");\n\n        assertThrows(NullPointerException.class, () -> QueueUtils.unmodifiableQueue(null),\n                \"Expecting NullPointerException for null queue.\");\n\n        assertSame(queue, QueueUtils.unmodifiableQueue(queue), \"UnmodifiableQueue shall not be decorated\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<Object> truePredicate = TruePredicate.truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<Object>", "name": "truePredicate = TruePredicate.truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Transformer<Object, Object>", "name": "nopTransformer = TransformerUtils.nopTransformer()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/ClosureUtilsTest.java.ClosureUtilsTest", "name": "ClosureUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/ClosureUtilsTest.java", "superclasses": "", "methods": ["[void]testChainedClosure()", "[void]testDoWhileClosure()", "[void]testExceptionClosure()", "[void]testForClosure()", "[void]testIfClosure()", "[void]testInvokeClosure()", "[void]testNopClosure()", "[void]testSingletonPatternInSerialization()", "[void]testSwitchClosure()", "[void]testSwitchMapClosure()", "[void]testTransformerClosure()", "[void]testWhileClosure()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    static class MockClosure<T> implements Closure<T> {\n        int count;\n\n        @Override\n        public void execute(final T object) {\n            count++;\n        }\n\n        public void reset() {\n            count = 0;\n        }\n    }", "definition": "    static class MockClosure<T> implements Closure<T>", "class_docstring": "", "name": "MockClosure", "super_interfaces": ["Closure<T>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "int count;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "count", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void execute(final T object) {\n            count++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "execute", "params": [{"name": "object", "type": "T"}], "body": "                                            {\n            count++;\n        }", "signature": "@Override\n        public void execute(final T object)"}, {"syntax_pass": true, "original_string": "        public void reset() {\n            count = 0;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                            {\n            count = 0;\n        }", "signature": "public void reset()"}]}, {"original_string": "    static class MockTransformer<T> implements Transformer<T, T> {\n        int count;\n\n        @Override\n        public T transform(final T object) {\n            count++;\n            return object;\n        }\n    }", "definition": "    static class MockTransformer<T> implements Transformer<T, T>", "class_docstring": "", "name": "MockTransformer", "super_interfaces": ["Transformer<T, T>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "int count;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "count", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public T transform(final T object) {\n            count++;\n            return object;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "transform", "params": [{"name": "object", "type": "T"}], "body": "                                           {\n            count++;\n            return object;\n        }", "signature": "@Override\n        public T transform(final T object)"}]}], "class_docstring": "\nTests the ClosureUtils class.\n", "original_string": "public class ClosureUtilsTest {\n\n    static class MockClosure<T> implements Closure<T> {\n        int count;\n\n        @Override\n        public void execute(final T object) {\n            count++;\n        }\n\n        public void reset() {\n            count = 0;\n        }\n    }\n\n    static class MockTransformer<T> implements Transformer<T, T> {\n        int count;\n\n        @Override\n        public T transform(final T object) {\n            count++;\n            return object;\n        }\n    }\n\n    private static final Object cString = \"Hello\";\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testChainedClosure() {\n        MockClosure<Object> a = new MockClosure<>();\n        MockClosure<Object> b = new MockClosure<>();\n        ClosureUtils.chainedClosure(a, b).accept(null);\n        assertEquals(1, a.count);\n        assertEquals(1, b.count);\n\n        a = new MockClosure<>();\n        b = new MockClosure<>();\n        ClosureUtils.<Object>chainedClosure(a, b, a).execute(null);\n        assertEquals(2, a.count);\n        assertEquals(1, b.count);\n\n        a = new MockClosure<>();\n        b = new MockClosure<>();\n        final Collection<Closure<Object>> coll = new ArrayList<>();\n        coll.add(b);\n        coll.add(a);\n        coll.add(b);\n        ClosureUtils.<Object>chainedClosure(coll).execute(null);\n        assertEquals(1, a.count);\n        assertEquals(2, b.count);\n\n        assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure());\n        assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure(Collections.<Closure<Object>>emptyList()));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.chainedClosure(null, null)),\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.<Object>chainedClosure((Closure[]) null)),\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.<Object>chainedClosure((Collection<Closure<Object>>) null)),\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.<Object>chainedClosure(null, null)),\n                () -> {\n                    final Collection<Closure<Object>> finalColl = new ArrayList<>();\n                    finalColl.add(null);\n                    finalColl.add(null);\n                    assertThrows(NullPointerException.class, () -> ClosureUtils.chainedClosure(finalColl));\n                }\n        );\n    }\n\n    @Test\n    public void testDoWhileClosure() {\n        MockClosure<Object> cmd = new MockClosure<>();\n        ClosureUtils.doWhileClosure(cmd, FalsePredicate.falsePredicate()).execute(null);\n        assertEquals(1, cmd.count);\n\n        cmd = new MockClosure<>();\n        ClosureUtils.doWhileClosure(cmd, PredicateUtils.uniquePredicate()).execute(null);\n        assertEquals(2, cmd.count);\n\n        assertThrows(NullPointerException.class, () -> ClosureUtils.doWhileClosure(null, null));\n    }\n\n    @Test\n    public void testExceptionClosure() {\n        assertNotNull(ClosureUtils.exceptionClosure());\n        assertSame(ClosureUtils.exceptionClosure(), ClosureUtils.exceptionClosure());\n        assertAll(\n                () -> assertThrows(FunctorException.class, () -> ClosureUtils.exceptionClosure().execute(null)),\n                () -> assertThrows(FunctorException.class, () -> ClosureUtils.exceptionClosure().execute(cString))\n        );\n    }\n\n    @Test\n    public void testForClosure() {\n        final MockClosure<Object> cmd = new MockClosure<>();\n        ClosureUtils.forClosure(5, cmd).execute(null);\n        assertEquals(5, cmd.count);\n        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(0, new MockClosure<>()));\n        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(-1, new MockClosure<>()));\n        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(1, null));\n        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(3, null));\n        assertSame(cmd, ClosureUtils.forClosure(1, cmd));\n    }\n\n    @Test\n    public void testIfClosure() {\n        MockClosure<Object> a = new MockClosure<>();\n        MockClosure<Object> b;\n        ClosureUtils.ifClosure(TruePredicate.truePredicate(), a).execute(null);\n        assertEquals(1, a.count);\n\n        a = new MockClosure<>();\n        ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a).execute(null);\n        assertEquals(0, a.count);\n\n        a = new MockClosure<>();\n        b = new MockClosure<>();\n        ClosureUtils.ifClosure(TruePredicate.<Object>truePredicate(), a, b).execute(null);\n        assertEquals(1, a.count);\n        assertEquals(0, b.count);\n\n        a = new MockClosure<>();\n        b = new MockClosure<>();\n        ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a, b).execute(null);\n        assertEquals(0, a.count);\n        assertEquals(1, b.count);\n    }\n\n    @Test\n    public void testInvokeClosure() {\n        StringBuilder buf = new StringBuilder(\"Hello\"); // Only StringBuffer has setLength() method\n        ClosureUtils.invokerClosure(\"reverse\").execute(buf);\n        assertEquals(\"olleH\", buf.toString());\n        buf = new StringBuilder(\"Hello\");\n        ClosureUtils.invokerClosure(\"setLength\", new Class[] {Integer.TYPE}, new Object[] {Integer.valueOf(2)}).execute(buf);\n        assertEquals(\"He\", buf.toString());\n    }\n\n    @Test\n    public void testNopClosure() {\n        final StringBuilder buf = new StringBuilder(\"Hello\");\n        ClosureUtils.nopClosure().execute(null);\n        assertEquals(\"Hello\", buf.toString());\n        ClosureUtils.nopClosure().execute(\"Hello\");\n        assertEquals(\"Hello\", buf.toString());\n    }\n\n    /**\n     * Test that all Closure singletons hold singleton pattern in\n     * serialization/deserialization process.\n     */\n    @Test\n    public void testSingletonPatternInSerialization() {\n        final Object[] singletons = {\n            ExceptionClosure.INSTANCE,\n            NOPClosure.INSTANCE,\n        };\n\n        for (final Object original : singletons) {\n            TestUtils.assertSameAfterSerialization(\n                    \"Singleton pattern broken for \" + original.getClass(),\n                    original\n            );\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSwitchClosure() {\n        final MockClosure<String> a = new MockClosure<>();\n        final MockClosure<String> b = new MockClosure<>();\n        ClosureUtils.<String>switchClosure(\n            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n            new Closure[] { a, b }).execute(\"WELL\");\n        assertEquals(0, a.count);\n        assertEquals(0, b.count);\n\n        a.reset();\n        b.reset();\n        ClosureUtils.<String>switchClosure(\n            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n            new Closure[] { a, b }).execute(\"HELLO\");\n        assertEquals(1, a.count);\n        assertEquals(0, b.count);\n\n        a.reset();\n        b.reset();\n        final MockClosure<String> c = new MockClosure<>();\n        ClosureUtils.<String>switchClosure(\n            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n            new Closure[] { a, b }, c).execute(\"WELL\");\n        assertEquals(0, a.count);\n        assertEquals(0, b.count);\n        assertEquals(1, c.count);\n\n        a.reset();\n        b.reset();\n        final Map<Predicate<String>, Closure<String>> map = new HashMap<>();\n        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n        ClosureUtils.<String>switchClosure(map).execute(null);\n        assertEquals(0, a.count);\n        assertEquals(0, b.count);\n\n        a.reset();\n        b.reset();\n        map.clear();\n        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n        ClosureUtils.switchClosure(map).execute(\"THERE\");\n        assertEquals(0, a.count);\n        assertEquals(1, b.count);\n\n        a.reset();\n        b.reset();\n        c.reset();\n        map.clear();\n        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n        map.put(null, c);\n        ClosureUtils.switchClosure(map).execute(\"WELL\");\n        assertEquals(0, a.count);\n        assertEquals(0, b.count);\n        assertEquals(1, c.count);\n\n        assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new Predicate[0], new Closure[0]));\n        assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new HashMap<>()));\n        map.clear();\n        map.put(null, null);\n        assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchClosure(map));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.switchClosure(null, null)),\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.<String>switchClosure((Predicate<String>[]) null, (Closure<String>[]) null)),\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.<String>switchClosure((Map<Predicate<String>, Closure<String>>) null)),\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.<String>switchClosure(new Predicate[2], new Closure[2])),\n                () -> assertThrows(IllegalArgumentException.class, () -> ClosureUtils.<String>switchClosure(\n                        new Predicate[]{TruePredicate.<String>truePredicate()},\n                        new Closure[]{a, b}))\n        );\n    }\n\n    @Test\n    public void testSwitchMapClosure() {\n        final MockClosure<String> a = new MockClosure<>();\n        final MockClosure<String> b = new MockClosure<>();\n        final Map<String, Closure<String>> map = new HashMap<>();\n        map.put(\"HELLO\", a);\n        map.put(\"THERE\", b);\n        ClosureUtils.switchMapClosure(map).execute(null);\n        assertEquals(0, a.count);\n        assertEquals(0, b.count);\n\n        a.reset();\n        b.reset();\n        map.clear();\n        map.put(\"HELLO\", a);\n        map.put(\"THERE\", b);\n        ClosureUtils.switchMapClosure(map).execute(\"THERE\");\n        assertEquals(0, a.count);\n        assertEquals(1, b.count);\n\n        a.reset();\n        b.reset();\n        map.clear();\n        final MockClosure<String> c = new MockClosure<>();\n        map.put(\"HELLO\", a);\n        map.put(\"THERE\", b);\n        map.put(null, c);\n        ClosureUtils.switchMapClosure(map).execute(\"WELL\");\n        assertEquals(0, a.count);\n        assertEquals(0, b.count);\n        assertEquals(1, c.count);\n\n        assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchMapClosure(new HashMap<>()));\n\n        assertThrows(NullPointerException.class, () -> ClosureUtils.switchMapClosure(null));\n    }\n\n    @Test\n    public void testTransformerClosure() {\n        final MockTransformer<Object> mock = new MockTransformer<>();\n        final Closure<Object> closure = ClosureUtils.asClosure(mock);\n        closure.execute(null);\n        assertEquals(1, mock.count);\n        closure.execute(null);\n        assertEquals(2, mock.count);\n\n        assertEquals(ClosureUtils.nopClosure(), ClosureUtils.asClosure(null));\n    }\n\n    @Test\n    public void testWhileClosure() {\n        MockClosure<Object> cmd = new MockClosure<>();\n        ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), cmd).execute(null);\n        assertEquals(0, cmd.count);\n\n        cmd = new MockClosure<>();\n        ClosureUtils.whileClosure(PredicateUtils.uniquePredicate(), cmd).execute(null);\n        assertEquals(1, cmd.count);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.whileClosure(null, ClosureUtils.nopClosure())),\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), null)),\n                () -> assertThrows(NullPointerException.class, () -> ClosureUtils.whileClosure(null, null))\n        );\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object cString = \"Hello\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "cString = \"Hello\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_getTest.java.IteratorUtils_getTest", "name": "IteratorUtils_getTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_getTest.java", "superclasses": "", "methods": ["[void]testGetValidIndex()", "[void]testGetInvalidIndex()", "[void]testGetFromEmptyIterator()", "[void]testGetNegativeIndex()"], "method_uris": ["src/test/java/org/apache/commons/collections4/IteratorUtils_getTest.java.IteratorUtils_getTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_getTest {\n\n    private List<String> list;\n    private Iterator<String> iterator;\n\n    @BeforeEach\n    public void setUp() {\n        list = new ArrayList<>();\n        list.add(\"A\");\n        list.add(\"B\");\n        list.add(\"C\");\n        iterator = list.iterator();\n    }\n\n    @Test\n    public void testGetValidIndex() {\n        assertEquals(\"B\", IteratorUtils.get(iterator, 1));\n    }\n\n    @Test\n    public void testGetInvalidIndex() {\n        assertThrows(IndexOutOfBoundsException.class, () -> {\n            IteratorUtils.get(iterator, 3);\n        });\n    }\n\n    @Test\n    public void testGetFromEmptyIterator() {\n        Iterator<String> emptyIterator = new ArrayList<String>().iterator();\n        assertThrows(IndexOutOfBoundsException.class, () -> {\n            IteratorUtils.get(emptyIterator, 0);\n        });\n    }\n\n    @Test\n    public void testGetNegativeIndex() {\n        assertThrows(IndexOutOfBoundsException.class, () -> {\n            IteratorUtils.get(iterator, -1);\n        });\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<String> list;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private Iterator<String> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<String>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_zippingIteratorTest.java.IteratorUtils_zippingIteratorTest", "name": "IteratorUtils_zippingIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_zippingIteratorTest.java", "superclasses": "", "methods": ["[void]testZippingIterator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_zippingIteratorTest {\n\n    @Test\n    public void testZippingIterator() {\n        Iterator<Integer> iterator1 = Arrays.asList(1, 2, 3).iterator();\n        Iterator<Integer> iterator2 = Arrays.asList(4, 5, 6).iterator();\n        Iterator<Integer> iterator3 = Arrays.asList(7, 8, 9).iterator();\n\n        ZippingIterator<Integer> zippingIterator = IteratorUtils.zippingIterator(iterator1, iterator2, iterator3);\n\n        assertNotNull(zippingIterator);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/TransformerUtils_ifTransformerTest.java.TransformerUtils_ifTransformerTest", "name": "TransformerUtils_ifTransformerTest", "file_path": "src/test/java/org/apache/commons/collections4/TransformerUtils_ifTransformerTest.java", "superclasses": "", "methods": ["[void]testIfTransformerWithTruePredicate()", "[void]testIfTransformerWithFalsePredicate()", "[void]testIfTransformerWithEqualPredicate()", "[void]testIfTransformerWithExceptionTransformer()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformerUtils_ifTransformerTest {\n\n    private static final Object CONSTANT_VALUE = new Object();\n\n    @Test\n    public void testIfTransformerWithTruePredicate() {\n        Predicate<Object> truePredicate = TruePredicate.truePredicate();\n        Transformer<Object, Object> trueTransformer = ConstantTransformer.constantTransformer(CONSTANT_VALUE);\n        Transformer<Object, Object> falseTransformer = ConstantTransformer.constantTransformer(null);\n\n        Transformer<Object, Object> ifTransformer = TransformerUtils.ifTransformer(truePredicate, trueTransformer, falseTransformer);\n\n        assertSame(CONSTANT_VALUE, ifTransformer.transform(new Object()));\n    }\n\n    @Test\n    public void testIfTransformerWithFalsePredicate() {\n        Predicate<Object> falsePredicate = FalsePredicate.falsePredicate();\n        Transformer<Object, Object> trueTransformer = ConstantTransformer.constantTransformer(CONSTANT_VALUE);\n        Transformer<Object, Object> falseTransformer = ConstantTransformer.constantTransformer(null);\n\n        Transformer<Object, Object> ifTransformer = TransformerUtils.ifTransformer(falsePredicate, trueTransformer, falseTransformer);\n\n        assertNull(ifTransformer.transform(new Object()));\n    }\n\n    @Test\n    public void testIfTransformerWithEqualPredicate() {\n        Object input = new Object();\n        Predicate<Object> equalPredicate = EqualPredicate.equalPredicate(input);\n        Transformer<Object, Object> trueTransformer = ConstantTransformer.constantTransformer(CONSTANT_VALUE);\n        Transformer<Object, Object> falseTransformer = ConstantTransformer.constantTransformer(null);\n\n        Transformer<Object, Object> ifTransformer = TransformerUtils.ifTransformer(equalPredicate, trueTransformer, falseTransformer);\n\n        assertSame(CONSTANT_VALUE, ifTransformer.transform(input));\n        assertNull(ifTransformer.transform(new Object()));\n    }\n\n    @Test\n    public void testIfTransformerWithExceptionTransformer() {\n        Predicate<Object> truePredicate = TruePredicate.truePredicate();\n        Transformer<Object, Object> trueTransformer = ExceptionTransformer.exceptionTransformer();\n        Transformer<Object, Object> falseTransformer = ConstantTransformer.constantTransformer(null);\n\n        Transformer<Object, Object> ifTransformer = TransformerUtils.ifTransformer(truePredicate, trueTransformer, falseTransformer);\n\n        assertThrows(FunctorException.class, () -> ifTransformer.transform(new Object()));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object CONSTANT_VALUE = new Object();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "CONSTANT_VALUE = new Object()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/MultiMapUtilsTest.java.MultiMapUtilsTest", "name": "MultiMapUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/MultiMapUtilsTest.java", "superclasses": "", "methods": ["[void]testEmptyIfNull()", "[void]testEmptyUnmodifiableMultiValuedMap()", "[void]testGetCollection()", "[void]testGetValuesAsBag()", "[void]testGetValuesAsList()", "[void]testGetValuesAsSet()", "[void]testIsEmptyWithEmptyMap()", "[void]testIsEmptyWithNonEmptyMap()", "[void]testIsEmptyWithNull()", "[void]testTypeSafeEmptyMultiValuedMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests for MultiMapUtils\n", "original_string": "public class MultiMapUtilsTest {\n\n    @Test\n    public void testEmptyIfNull() {\n        assertTrue(MultiMapUtils.emptyIfNull(null).isEmpty());\n\n        final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();\n        map.put(\"item\", \"value\");\n        assertFalse(MultiMapUtils.emptyIfNull(map).isEmpty());\n    }\n\n    @Test\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public void testEmptyUnmodifiableMultiValuedMap() {\n        final MultiValuedMap map = MultiMapUtils.EMPTY_MULTI_VALUED_MAP;\n        assertTrue(map.isEmpty());\n\n        assertThrows(UnsupportedOperationException.class, () -> map.put(\"key\", \"value\"));\n    }\n\n    @Test\n    public void testGetCollection() {\n        assertNull(MultiMapUtils.getCollection(null, \"key1\"));\n\n        final String[] values = { \"v1\", \"v2\", \"v3\" };\n        final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();\n        for (final String val : values) {\n            map.put(\"key1\", val);\n        }\n\n        final Collection<String> col = MultiMapUtils.getCollection(map, \"key1\");\n        assertEquals(Arrays.asList(values), col);\n    }\n\n    @Test\n    public void testGetValuesAsBag() {\n        assertNull(MultiMapUtils.getValuesAsBag(null, \"key1\"));\n\n        final String[] values = { \"v1\", \"v2\", \"v3\" };\n        final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();\n        for (final String val : values) {\n            map.put(\"key1\", val);\n            map.put(\"key1\", val);\n        }\n\n        final Bag<String> bag = MultiMapUtils.getValuesAsBag(map, \"key1\");\n        assertEquals(6, bag.size());\n        for (final String val : values) {\n            assertTrue(bag.contains(val));\n            assertEquals(2, bag.getCount(val));\n        }\n    }\n\n    @Test\n    public void testGetValuesAsList() {\n        assertNull(MultiMapUtils.getValuesAsList(null, \"key1\"));\n\n        final String[] values = { \"v1\", \"v2\", \"v3\" };\n        final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();\n        for (final String val : values) {\n            map.put(\"key1\", val);\n        }\n\n        final List<String> list = MultiMapUtils.getValuesAsList(map, \"key1\");\n        assertEquals(Arrays.asList(values), list);\n    }\n\n    @Test\n    public void testGetValuesAsSet() {\n        assertNull(MultiMapUtils.getValuesAsList(null, \"key1\"));\n\n        final String[] values = { \"v1\", \"v2\", \"v3\" };\n        final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();\n        for (final String val : values) {\n            map.put(\"key1\", val);\n            map.put(\"key1\", val);\n        }\n\n        final Set<String> set = MultiMapUtils.getValuesAsSet(map, \"key1\");\n        assertEquals(new HashSet<>(Arrays.asList(values)), set);\n    }\n\n    @Test\n    public void testIsEmptyWithEmptyMap() {\n        assertTrue(MultiMapUtils.isEmpty(new ArrayListValuedHashMap<>()));\n    }\n\n    @Test\n    public void testIsEmptyWithNonEmptyMap() {\n        final MultiValuedMap<String, String> map = new ArrayListValuedHashMap<>();\n        map.put(\"item\", \"value\");\n        assertFalse(MultiMapUtils.isEmpty(map));\n    }\n\n    @Test\n    public void testIsEmptyWithNull() {\n        assertTrue(MultiMapUtils.isEmpty(null));\n    }\n\n    @Test\n    public void testTypeSafeEmptyMultiValuedMap() {\n        final MultiValuedMap<String, String> map = MultiMapUtils.<String, String>emptyMultiValuedMap();\n        assertTrue(map.isEmpty());\n\n        assertThrows(UnsupportedOperationException.class, () -> map.put(\"key\", \"value\"));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/ArrayStack_peekTest.java.ArrayStack_peekTest", "name": "ArrayStack_peekTest", "file_path": "src/test/java/org/apache/commons/collections4/ArrayStack_peekTest.java", "superclasses": "", "methods": ["[void]testPeekWithNonEmptyStack()", "[void]testPeekWithEmptyStack()", "[void]testPeekAfterPop()", "[void]testPeekWithSingleItemStack()", "[void]testPeekWithMultiplePushesAndPops()"], "method_uris": ["src/test/java/org/apache/commons/collections4/ArrayStack_peekTest.java.ArrayStack_peekTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ArrayStack_peekTest {\n\n    private ArrayStack<String> stack;\n\n    @BeforeEach\n    public void setUp() {\n        stack = new ArrayStack<>();\n    }\n\n    @Test\n    public void testPeekWithNonEmptyStack() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        assertEquals(\"Second Item\", stack.peek(), \"Top item should be 'Second Item'\");\n    }\n\n    @Test\n    public void testPeekWithEmptyStack() {\n        assertThrows(EmptyStackException.class, () -> stack.peek(), \"Peeking an empty stack should throw EmptyStackException\");\n    }\n\n    @Test\n    public void testPeekAfterPop() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        stack.pop();\n        assertEquals(\"First Item\", stack.peek(), \"Top item should be 'First Item' after pop\");\n    }\n\n    @Test\n    public void testPeekWithSingleItemStack() {\n        stack.push(\"Single Item\");\n        assertEquals(\"Single Item\", stack.peek(), \"Top item should be 'Single Item'\");\n    }\n\n    @Test\n    public void testPeekWithMultiplePushesAndPops() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        stack.push(\"Third Item\");\n        stack.pop();\n        stack.pop();\n        assertEquals(\"First Item\", stack.peek(), \"Top item should be 'First Item' after multiple pushes and pops\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ArrayStack<String> stack;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayStack<String>", "name": "stack", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java.CollectionUtilsTest", "name": "CollectionUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java", "superclasses": "MockTestCase", "methods": ["[void]cardinality()", "[void]cardinalityOfNull()", "[void]countMatches()", "[void]exists()", "[void]find()", "[void]forAllButLastDoCollection()", "[void]forAllButLastDoIterator()", "[void]forAllDoCollection()", "[void]forAllDoFailure()", "[void]forAllDoIterator()", "[void]getFromEnumeration()", "[void]getFromIterable()", "[void]getFromIterator()", "[void]testAddAllForElements()", "[void]testAddAllForEnumeration()", "[void]testAddAllForIterable()", "[void]testaddAllNullColl1()", "[void]testAddAllNullColl2()", "[void]testAddAllNullColl3()", "[void]testAddAllNullColl4()", "[void]testAddAllNullColl5()", "[void]testAddIgnoreNull()", "[void]testAddIgnoreNullNullColl()", "[void]testCollate()", "[void]testCollateException0()", "[void]testCollateException1()", "[void]testCollateException2()", "[void]testCollateIgnoreDuplicates()", "[void]testCollect()", "[void]testContainsAll()", "[void]testContainsAnyInArray()", "[void]testContainsAnyInArrayNullArray()", "[void]testContainsAnyInArrayNullColl1()", "[void]testContainsAnyInArrayNullColl2()", "[void]testContainsAnyInCollection()", "[void]testContainsAnyNullColl1()", "[void]testContainsAnyNullColl2()", "[void]testContainsAnyNullColl3()", "[void]testDisjunction()", "[void]testDisjunctionAsSymmetricDifference()", "[void]testDisjunctionAsUnionMinusIntersection()", "[void]testDisjunctionNullColl1()", "[void]testDisjunctionNullColl2()", "[void]testEmptyCollection()", "[void]testEmptyIfNull()", "[void]testExtractSingleton()", "[void]testFilter()", "[void]testFilterInverse()", "[void]testFilterInverseNullParameters()", "[void]testFilterNullParameters()", "[void]testGet()", "[void]testGet1()", "[void]testGetCardinalityMap()", "[void]testGetCardinalityMapNull()", "[void]testGetEnumeration()", "[void]testGetFromHashMap()", "[void]testGetFromLinkedHashMap()", "[void]testGetFromList()", "[void]testGetFromMapIndexOutOfRange()", "[void]testGetFromObject()", "[void]testGetFromObjectArray()", "[void]testGetFromPrimitiveArray()", "[void]testGetFromTreeMap()", "[void]testGetIterator()", "[void]testGetNegative()", "[void]testGetPositiveOutOfBounds()", "[void]testHashCode()", "[void]testHashCodeNullCollection()", "[void]testHashCodeNullEquator()", "[void]testIntersection()", "[void]testIntersectionNullColl1()", "[void]testIntersectionNullColl2()", "[void]testIntersectionUsesMethodEquals()", "[void]testIsEmpty()", "[void]testIsEmptyWithEmptyCollection()", "[void]testIsEmptyWithNonEmptyCollection()", "[void]testIsEmptyWithNull()", "[void]testIsEqualCollection()", "[void]testIsEqualCollection2()", "[void]testIsEqualCollectionEquator()", "[void]testIsEqualCollectionNullColl1()", "[void]testIsEqualCollectionNullColl2()", "[void]testIsEqualCollectionNullEquator()", "[void]testIsEqualCollectionReturnsFalse()", "[void]testIsEqualCollectionToSelf()", "[void]testIsFull()", "[void]testIsFullNullColl()", "[void]testIsNotEmptyWithEmptyCollection()", "[void]testIsNotEmptyWithNonEmptyCollection()", "[void]testIsNotEmptyWithNull()", "[void]testIsProperSubCollection()", "[void]testIsProperSubCollectionNullColl1()", "[void]testIsProperSubCollectionNullColl2()", "[void]testIsSubCollection()", "[void]testIsSubCollection2()", "[void]testIsSubCollectionNullColl1()", "[void]testIsSubCollectionNullColl2()", "[void]testIsSubCollectionOfSelf()", "[void]testMatchesAll()", "[void]testMaxSize()", "[void]testMaxSizeNullColl()", "[void]testPermutations()", "[void]testPermutationsWithNullCollection()", "[void]testPredicatedCollection()", "[void]testPredicatedCollectionNullColl()", "[void]testPredicatedCollectionNullPredicate()", "[void]testRemoveAll()", "[void]testRemoveAllNullBaseColl()", "[void]testRemoveAllNullSubColl()", "[void]testRemoveAllWithEquator()", "[void]testRemoveCount()", "[void]testRemoveCountNegative()", "[void]testRemoveCountStartNegative()", "[void]testRemoveCountWithNull()", "[void]testRemoveCountWrongCount()", "[void]testRemoveRange()", "[void]testRemoveRangeEndIndexNegative()", "[void]testRemoveRangeEndLowStart()", "[void]testRemoveRangeNull()", "[void]testRemoveRangeStartIndexNegative()", "[void]testRemoveRangeWrongEndIndex()", "[void]testRetainAll()", "[void]testRetainAllNullBaseColl()", "[void]testRetainAllNullSubColl()", "[void]testRetainAllWithEquator()", "[void]testReverse()", "[void]testReverseArrayNull()", "[void]testSelect()", "[void]testSelectRejected()", "[void]testSelectWithOutputCollections()", "[void]testSize_Array()", "[void]testSize_Enumeration()", "[void]testSize_Iterator()", "[void]testSize_List()", "[void]testSize_Map()", "[void]testSize_Other()", "[void]testSize_PrimitiveArray()", "[void]testSizeIsEmpty_Array()", "[void]testSizeIsEmpty_Enumeration()", "[void]testSizeIsEmpty_Iterator()", "[void]testSizeIsEmpty_List()", "[void]testSizeIsEmpty_Map()", "[void]testSizeIsEmpty_Null()", "[void]testSizeIsEmpty_Other()", "[void]testSizeIsEmpty_PrimitiveArray()", "[void]testSubtract()", "[void]testSubtractNullColl1()", "[void]testSubtractNullColl2()", "[void]testSubtractWithPredicate()", "[void]testSynchronizedCollection()", "[void]testTransform1()", "[void]testTransform2()", "[void]testTransformedCollection()", "[void]testTransformedCollection_2()", "[void]testTransformingCollectionNullColl()", "[void]testTransformingCollectionNullTransformer()", "[void]testUnion()", "[void]testUnionNullColl1()", "[void]testUnionNullColl2()", "[void]testUnmodifiableCollection()"], "method_uris": ["src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java.CollectionUtilsTest.[void]assertCollectResult(Collection<Number>)", "src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java.CollectionUtilsTest.[void]next(Iterator<T>,T)", "src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java.CollectionUtilsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for CollectionUtils.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class CollectionUtilsTest extends MockTestCase {\n\n    private static final Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;\n\n    /**\n     * Collection of {@link Integer}s\n     */\n    private List<Integer> collectionA;\n\n    /**\n     * Collection of {@link Long}s\n     */\n    private List<Long> collectionB;\n\n    /**\n     * Collection of {@link Integer}s that are equivalent to the Longs in\n     * collectionB.\n     */\n    private Collection<Integer> collectionC;\n\n    /**\n     * Sorted Collection of {@link Integer}s\n     */\n    private Collection<Integer> collectionD;\n\n    /**\n     * Sorted Collection of {@link Integer}s\n     */\n    private Collection<Integer> collectionE;\n\n    /**\n     * Collection of {@link Integer}s, bound as {@link Number}s\n     */\n    private Collection<Number> collectionA2;\n\n    /**\n     * Collection of {@link Long}s, bound as {@link Number}s\n     */\n    private Collection<Number> collectionB2;\n\n    /**\n     * Collection of {@link Integer}s (cast as {@link Number}s) that are\n     * equivalent to the Longs in collectionB.\n     */\n    private Collection<Number> collectionC2;\n\n    private Iterable<Integer> iterableA;\n\n    private Iterable<Long> iterableB;\n\n    private Iterable<Integer> iterableC;\n\n    private Iterable<Number> iterableA2;\n\n    private Iterable<Number> iterableB2;\n\n    private final Collection<Integer> emptyCollection = new ArrayList<>(1);\n\n    Transformer<Object, Integer> TRANSFORM_TO_INTEGER = input -> Integer.valueOf(((Long) input).intValue());\n\n    private void assertCollectResult(final Collection<Number> collection) {\n        assertTrue(collectionA.contains(1) && !collectionA.contains(2L));\n        assertTrue(collection.contains(2L) && !collection.contains(1));\n    }\n\n    @Test\n    @Deprecated\n    public void cardinality() {\n        assertEquals(1, CollectionUtils.cardinality(1, iterableA));\n        assertEquals(2, CollectionUtils.cardinality(2, iterableA));\n        assertEquals(3, CollectionUtils.cardinality(3, iterableA));\n        assertEquals(4, CollectionUtils.cardinality(4, iterableA));\n        assertEquals(0, CollectionUtils.cardinality(5, iterableA));\n\n        assertEquals(0, CollectionUtils.cardinality(1L, iterableB));\n        assertEquals(4, CollectionUtils.cardinality(2L, iterableB));\n        assertEquals(3, CollectionUtils.cardinality(3L, iterableB));\n        assertEquals(2, CollectionUtils.cardinality(4L, iterableB));\n        assertEquals(1, CollectionUtils.cardinality(5L, iterableB));\n\n        // Ensure that generic bounds accept valid parameters, but return\n        // expected results\n        // e.g. no longs in the \"int\" Iterable<Number>, and vice versa.\n        assertEquals(0, CollectionUtils.cardinality(2L, iterableA2));\n        assertEquals(0, CollectionUtils.cardinality(2, iterableB2));\n\n        final Set<String> set = new HashSet<>();\n        set.add(\"A\");\n        set.add(\"C\");\n        set.add(\"E\");\n        set.add(\"E\");\n        assertEquals(1, CollectionUtils.cardinality(\"A\", set));\n        assertEquals(0, CollectionUtils.cardinality(\"B\", set));\n        assertEquals(1, CollectionUtils.cardinality(\"C\", set));\n        assertEquals(0, CollectionUtils.cardinality(\"D\", set));\n        assertEquals(1, CollectionUtils.cardinality(\"E\", set));\n\n        final Bag<String> bag = new HashBag<>();\n        bag.add(\"A\", 3);\n        bag.add(\"C\");\n        bag.add(\"E\");\n        bag.add(\"E\");\n        assertEquals(3, CollectionUtils.cardinality(\"A\", bag));\n        assertEquals(0, CollectionUtils.cardinality(\"B\", bag));\n        assertEquals(1, CollectionUtils.cardinality(\"C\", bag));\n        assertEquals(0, CollectionUtils.cardinality(\"D\", bag));\n        assertEquals(2, CollectionUtils.cardinality(\"E\", bag));\n    }\n\n    @Test\n    @Deprecated\n    public void cardinalityOfNull() {\n        final List<String> list = new ArrayList<>();\n        assertEquals(0, CollectionUtils.cardinality(null, list));\n        {\n            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n            assertNull(freq.get(null));\n        }\n        list.add(\"A\");\n        assertEquals(0, CollectionUtils.cardinality(null, list));\n        {\n            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n            assertNull(freq.get(null));\n        }\n        list.add(null);\n        assertEquals(1, CollectionUtils.cardinality(null, list));\n        {\n            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n            assertEquals(Integer.valueOf(1), freq.get(null));\n        }\n        list.add(\"B\");\n        assertEquals(1, CollectionUtils.cardinality(null, list));\n        {\n            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n            assertEquals(Integer.valueOf(1), freq.get(null));\n        }\n        list.add(null);\n        assertEquals(2, CollectionUtils.cardinality(null, list));\n        {\n            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n            assertEquals(Integer.valueOf(2), freq.get(null));\n        }\n        list.add(\"B\");\n        assertEquals(2, CollectionUtils.cardinality(null, list));\n        {\n            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n            assertEquals(Integer.valueOf(2), freq.get(null));\n        }\n        list.add(null);\n        assertEquals(3, CollectionUtils.cardinality(null, list));\n        {\n            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n            assertEquals(Integer.valueOf(3), freq.get(null));\n        }\n    }\n\n    @Test\n    @Deprecated\n    public void countMatches() {\n        assertEquals(4, CollectionUtils.countMatches(iterableB, EQUALS_TWO));\n        assertEquals(0, CollectionUtils.countMatches(iterableA, null));\n        assertEquals(0, CollectionUtils.countMatches(null, EQUALS_TWO));\n        assertEquals(0, CollectionUtils.countMatches(null, null));\n    }\n\n    @Test\n    @Deprecated\n    public void exists() {\n        final List<Integer> list = new ArrayList<>();\n        assertFalse(CollectionUtils.exists(null, null));\n        assertFalse(CollectionUtils.exists(list, null));\n        assertFalse(CollectionUtils.exists(null, EQUALS_TWO));\n        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n        list.add(1);\n        list.add(3);\n        list.add(4);\n        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n\n        list.add(2);\n        assertTrue(CollectionUtils.exists(list, EQUALS_TWO));\n    }\n\n    @Test\n    @Deprecated\n    public void find() {\n        Predicate<Number> testPredicate = equalPredicate((Number) 4);\n        Integer test = CollectionUtils.find(collectionA, testPredicate);\n        assertEquals(4, (int) test);\n        testPredicate = equalPredicate((Number) 45);\n        test = CollectionUtils.find(collectionA, testPredicate);\n        assertNull(test);\n        assertNull(CollectionUtils.find(null, testPredicate));\n        assertNull(CollectionUtils.find(collectionA, null));\n    }\n\n    @Test\n    @Deprecated\n    public void forAllButLastDoCollection() {\n        final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<List<? extends Number>> col = new ArrayList<>();\n        col.add(collectionA);\n        col.add(collectionB);\n        List<? extends Number> lastElement = CollectionUtils.forAllButLastDo(col, testClosure);\n        assertSame(lastElement, collectionB);\n        assertTrue(collectionA.isEmpty() && !collectionB.isEmpty());\n\n        col.clear();\n        col.add(collectionB);\n        lastElement = CollectionUtils.forAllButLastDo(col, testClosure);\n        assertSame(lastElement, collectionB);\n        assertFalse(collectionB.isEmpty());\n\n        col.clear();\n        lastElement = CollectionUtils.forAllButLastDo(col, testClosure);\n        assertNull(lastElement);\n\n        final Collection<String> strings = Arrays.asList(\"a\", \"b\", \"c\");\n        final StringBuilder result = new StringBuilder();\n        result.append(CollectionUtils.forAllButLastDo(strings, (Closure<String>) input -> result.append(input + \";\")));\n        assertEquals(\"a;b;c\", result.toString());\n\n        final Collection<String> oneString = Arrays.asList(\"a\");\n        final StringBuilder resultOne = new StringBuilder();\n        resultOne.append(CollectionUtils.forAllButLastDo(oneString, (Closure<String>) input -> resultOne.append(input + \";\")));\n        assertEquals(\"a\", resultOne.toString());\n        assertNull(CollectionUtils.forAllButLastDo(strings, (Closure<String>) null)); // do not remove cast\n        assertNull(CollectionUtils.forAllButLastDo((Collection<String>) null, (Closure<String>) null)); // do not remove cast\n    }\n\n    @Test\n    @Deprecated\n    public void forAllButLastDoIterator() {\n        final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<List<? extends Number>> col = new ArrayList<>();\n        col.add(collectionA);\n        col.add(collectionB);\n        final List<? extends Number> lastElement = CollectionUtils.forAllButLastDo(col.iterator(), testClosure);\n        assertSame(lastElement, collectionB);\n        assertTrue(collectionA.isEmpty() && !collectionB.isEmpty());\n\n        assertNull(CollectionUtils.forAllButLastDo(col.iterator(), (Closure<List<? extends Number>>) null));\n        assertNull(CollectionUtils.forAllButLastDo((Iterator<String>) null, (Closure<String>) null)); // do not remove cast\n    }\n\n    @Test\n    @Deprecated\n    public void forAllDoCollection() {\n        final Closure<Collection<Integer>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<Collection<Integer>> col = new ArrayList<>();\n        col.add(collectionA);\n        col.add(collectionC);\n        Closure<Collection<Integer>> resultClosure = CollectionUtils.forAllDo(col, testClosure);\n        assertSame(testClosure, resultClosure);\n        assertTrue(collectionA.isEmpty() && collectionC.isEmpty());\n        // fix for various java 1.6 versions: keep the cast\n        resultClosure = CollectionUtils.forAllDo(col, (Closure<Collection<Integer>>) null);\n        assertNull(resultClosure);\n        assertTrue(collectionA.isEmpty() && collectionC.isEmpty());\n        resultClosure = CollectionUtils.forAllDo((Collection<Collection<Integer>>) null, testClosure);\n        col.add(null);\n        // null should be OK\n        CollectionUtils.forAllDo(col, testClosure);\n    }\n\n    @Test\n    @Deprecated\n    public void forAllDoFailure() {\n        final Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<String> col = new ArrayList<>();\n        col.add(\"x\");\n        assertThrows(FunctorException.class, () -> CollectionUtils.forAllDo(col, testClosure));\n    }\n\n    @Test\n    @Deprecated\n    public void forAllDoIterator() {\n        final Closure<Collection<Integer>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<Collection<Integer>> col = new ArrayList<>();\n        col.add(collectionA);\n        col.add(collectionC);\n        Closure<Collection<Integer>> resultClosure = CollectionUtils.forAllDo(col.iterator(), testClosure);\n        assertSame(testClosure, resultClosure);\n        assertTrue(collectionA.isEmpty() && collectionC.isEmpty());\n        // fix for various java 1.6 versions: keep the cast\n        resultClosure = CollectionUtils.forAllDo(col.iterator(), (Closure<Collection<Integer>>) null);\n        assertNull(resultClosure);\n        assertTrue(collectionA.isEmpty() && collectionC.isEmpty());\n        resultClosure = CollectionUtils.forAllDo((Iterator<Collection<Integer>>) null, testClosure);\n        col.add(null);\n        // null should be OK\n        CollectionUtils.forAllDo(col.iterator(), testClosure);\n    }\n\n    @Test\n    @Deprecated\n    public void getFromEnumeration() throws Exception {\n        // Enumeration, entry exists\n        final Vector<String> vector = new Vector<>();\n        vector.addElement(\"zero\");\n        vector.addElement(\"one\");\n        Enumeration<String> en = vector.elements();\n        assertEquals(\"zero\", CollectionUtils.get(en, 0));\n        en = vector.elements();\n        assertEquals(\"one\", CollectionUtils.get(en, 1));\n\n        // Enumerator, non-existent entry\n        final Enumeration<String> finalEn = en;\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(finalEn, 3),\n                \"Expecting IndexOutOfBoundsException.\");\n\n        assertFalse(en.hasMoreElements());\n    }\n\n    @Test\n    @Deprecated\n    public void getFromIterable() throws Exception {\n        // Collection, entry exists\n        final Bag<String> bag = new HashBag<>();\n        bag.add(\"element\", 1);\n        assertEquals(\"element\", CollectionUtils.get(bag, 0));\n\n        // Collection, non-existent entry\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(bag, 1));\n    }\n\n    @Test\n    @Deprecated\n    public void getFromIterator() throws Exception {\n        // Iterator, entry exists\n        Iterator<Integer> iterator = iterableA.iterator();\n        assertEquals(1, (int) CollectionUtils.get(iterator, 0));\n        iterator = iterableA.iterator();\n        assertEquals(2, (int) CollectionUtils.get(iterator, 1));\n\n        // Iterator, non-existent entry\n        final Iterator<Integer> finalIterator = iterator;\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(finalIterator, 10),\n                \"Expecting IndexOutOfBoundsException.\");\n\n        assertFalse(iterator.hasNext());\n    }\n\n    /**\n     * Records the next object returned for a mock iterator\n     */\n    private <T> void next(final Iterator<T> iterator, final T t) {\n        expect(iterator.hasNext()).andReturn(true);\n        expect(iterator.next()).andReturn(t);\n    }\n\n    @BeforeEach\n    public void setUp() {\n        collectionA = new ArrayList<>();\n        collectionA.add(1);\n        collectionA.add(2);\n        collectionA.add(2);\n        collectionA.add(3);\n        collectionA.add(3);\n        collectionA.add(3);\n        collectionA.add(4);\n        collectionA.add(4);\n        collectionA.add(4);\n        collectionA.add(4);\n        collectionB = new LinkedList<>();\n        collectionB.add(5L);\n        collectionB.add(4L);\n        collectionB.add(4L);\n        collectionB.add(3L);\n        collectionB.add(3L);\n        collectionB.add(3L);\n        collectionB.add(2L);\n        collectionB.add(2L);\n        collectionB.add(2L);\n        collectionB.add(2L);\n\n        collectionC = new ArrayList<>();\n        for (final Long l : collectionB) {\n            collectionC.add(l.intValue());\n        }\n\n        iterableA = collectionA;\n        iterableB = collectionB;\n        iterableC = collectionC;\n        collectionA2 = new ArrayList<>(collectionA);\n        collectionB2 = new LinkedList<>(collectionB);\n        collectionC2 = new LinkedList<>(collectionC);\n        iterableA2 = collectionA2;\n        iterableB2 = collectionB2;\n\n        collectionD = new ArrayList<>();\n        collectionD.add(1);\n        collectionD.add(3);\n        collectionD.add(3);\n        collectionD.add(3);\n        collectionD.add(5);\n        collectionD.add(7);\n        collectionD.add(7);\n        collectionD.add(10);\n\n        collectionE = new ArrayList<>();\n        collectionE.add(2);\n        collectionE.add(4);\n        collectionE.add(4);\n        collectionE.add(5);\n        collectionE.add(6);\n        collectionE.add(6);\n        collectionE.add(9);\n    }\n\n    @Test\n    public void testAddAllForElements() {\n        CollectionUtils.addAll(collectionA, 5);\n        assertTrue(collectionA.contains(5));\n    }\n\n    @Test\n    public void testAddAllForEnumeration() {\n        final Hashtable<Integer, Integer> h = new Hashtable<>();\n        h.put(5, 5);\n        final Enumeration<? extends Integer> enumeration = h.keys();\n        CollectionUtils.addAll(collectionA, enumeration);\n        assertTrue(collectionA.contains(5));\n    }\n\n    /**\n     * This test ensures that {@link Iterable}s are supported by {@link CollectionUtils}.\n     * Specifically, it uses mocks to ensure that if the passed in\n     * {@link Iterable} is a {@link Collection} then\n     * {@link Collection#addAll(Collection)} is called instead of iterating.\n     */\n    @Test\n    public void testAddAllForIterable() {\n        final Collection<Integer> inputCollection = createMock(Collection.class);\n        final Iterable<Integer> inputIterable = inputCollection;\n        final Iterable<Long> iterable = createMock(Iterable.class);\n        final Iterator<Long> iterator = createMock(Iterator.class);\n        final Collection<Number> c = createMock(Collection.class);\n\n        expect(iterable.iterator()).andReturn(iterator);\n        next(iterator, 1L);\n        next(iterator, 2L);\n        next(iterator, 3L);\n        expect(iterator.hasNext()).andReturn(false);\n        expect(c.add(1L)).andReturn(true);\n        expect(c.add(2L)).andReturn(true);\n        expect(c.add(3L)).andReturn(true);\n        // Check that the collection is added using\n        // Collection.addAll(Collection)\n        expect(c.addAll(inputCollection)).andReturn(true);\n\n        // Ensure the method returns false if nothing is added\n        expect(iterable.iterator()).andReturn(iterator);\n        next(iterator, 1L);\n        expect(iterator.hasNext()).andReturn(false);\n        expect(c.add(1L)).andReturn(false);\n        expect(c.addAll(inputCollection)).andReturn(false);\n\n        replay();\n        assertTrue(CollectionUtils.addAll(c, iterable));\n        assertTrue(CollectionUtils.addAll(c, inputIterable));\n\n        assertFalse(CollectionUtils.addAll(c, iterable));\n        assertFalse(CollectionUtils.addAll(c, inputIterable));\n        verify();\n    }\n\n    @Test\n    public void testaddAllNullColl1() {\n        final List<Integer> list = new ArrayList<>();\n        assertThrows(NullPointerException.class, () -> CollectionUtils.addAll(null, list));\n    }\n\n    @Test\n    public void testAddAllNullColl2() {\n        final List<Integer> list = new ArrayList<>();\n        final Iterable<Integer> list2 = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.addAll(list, list2));\n    }\n\n    @Test\n    public void testAddAllNullColl3() {\n        final List<Integer> list = new ArrayList<>();\n        final Iterator<Integer> list2 = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.addAll(list, list2));\n    }\n\n    @Test\n    public void testAddAllNullColl4() {\n        final List<Integer> list = new ArrayList<>();\n        final Enumeration<Integer> enumArray = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.addAll(list, enumArray));\n    }\n\n    @Test\n    public void testAddAllNullColl5() {\n        final List<Integer> list = new ArrayList<>();\n        final Integer[] array = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.addAll(list, array));\n    }\n\n    @Test\n    public void testAddIgnoreNull() {\n        final Set<String> set = new HashSet<>();\n        set.add(\"1\");\n        set.add(\"2\");\n        set.add(\"3\");\n        assertFalse(CollectionUtils.addIgnoreNull(set, null));\n        assertEquals(3, set.size());\n        assertFalse(CollectionUtils.addIgnoreNull(set, \"1\"));\n        assertEquals(3, set.size());\n        assertTrue(CollectionUtils.addIgnoreNull(set, \"4\"));\n        assertEquals(4, set.size());\n        assertTrue(set.contains(\"4\"));\n    }\n\n    @Test\n    public void testAddIgnoreNullNullColl() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.addIgnoreNull(null, \"1\"));\n    }\n\n    @Test\n    public void testCollate() {\n        List<Integer> result = CollectionUtils.collate(emptyCollection, emptyCollection);\n        assertEquals(0, result.size(), \"Merge empty with empty\");\n\n        result = CollectionUtils.collate(collectionA, emptyCollection);\n        assertEquals(collectionA, result, \"Merge empty with non-empty\");\n\n        List<Integer> result1 = CollectionUtils.collate(collectionD, collectionE);\n        List<Integer> result2 = CollectionUtils.collate(collectionE, collectionD);\n        assertEquals(result1, result2, \"Merge two lists 1\");\n\n        final List<Integer> combinedList = new ArrayList<>(collectionD);\n        combinedList.addAll(collectionE);\n        Collections.sort(combinedList);\n\n        assertEquals(combinedList, result2, \"Merge two lists 2\");\n\n        final Comparator<Integer> reverseComparator =\n                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());\n\n        result = CollectionUtils.collate(emptyCollection, emptyCollection, reverseComparator);\n        assertEquals(0, result.size(), \"Comparator Merge empty with empty\");\n\n        Collections.reverse((List<Integer>) collectionD);\n        Collections.reverse((List<Integer>) collectionE);\n        Collections.reverse(combinedList);\n\n        result1 = CollectionUtils.collate(collectionD, collectionE, reverseComparator);\n        result2 = CollectionUtils.collate(collectionE, collectionD, reverseComparator);\n        assertEquals(result1, result2, \"Comparator Merge two lists 1\");\n        assertEquals(combinedList, result2, \"Comparator Merge two lists 2\");\n    }\n\n    @Test\n    public void testCollateException0() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.collate(null, collectionC));\n    }\n\n    @Test\n    public void testCollateException1() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.collate(collectionA, null));\n    }\n\n    @Test\n    public void testCollateException2() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.collate(collectionA, collectionC, null));\n    }\n\n    @Test\n    public void testCollateIgnoreDuplicates() {\n        final List<Integer> result1 = CollectionUtils.collate(collectionD, collectionE, false);\n        final List<Integer> result2 = CollectionUtils.collate(collectionE, collectionD, false);\n        assertEquals(result1, result2, \"Merge two lists 1 - ignore duplicates\");\n\n        final Set<Integer> combinedSet = new HashSet<>(collectionD);\n        combinedSet.addAll(collectionE);\n        final List<Integer> combinedList = new ArrayList<>(combinedSet);\n        Collections.sort(combinedList);\n\n        assertEquals(combinedList, result2, \"Merge two lists 2 - ignore duplicates\");\n    }\n\n    @Test\n    public void testCollect() {\n        final Transformer<Number, Long> transformer = TransformerUtils.constantTransformer(2L);\n        Collection<Number> collection = CollectionUtils.<Integer, Number>collect(iterableA, transformer);\n        assertEquals(collection.size(), collectionA.size());\n        assertCollectResult(collection);\n\n        ArrayList<Number> list;\n        list = CollectionUtils.collect(collectionA, transformer, new ArrayList<>());\n        assertEquals(list.size(), collectionA.size());\n        assertCollectResult(list);\n\n        Iterator<Integer> iterator = null;\n        list = CollectionUtils.collect(iterator, transformer, new ArrayList<>());\n\n        iterator = iterableA.iterator();\n        list = CollectionUtils.collect(iterator, transformer, list);\n        assertEquals(collection.size(), collectionA.size());\n        assertCollectResult(collection);\n\n        iterator = collectionA.iterator();\n        collection = CollectionUtils.<Integer, Number>collect(iterator, transformer);\n        assertEquals(collection.size(), collectionA.size());\n        assertTrue(collection.contains(2L) && !collection.contains(1));\n        collection = CollectionUtils.collect((Iterator<Integer>) null, (Transformer<Integer, Number>) null);\n        assertTrue(collection.isEmpty());\n\n        final int size = collectionA.size();\n        collectionB = CollectionUtils.collect((Collection<Integer>) null, transformer, collectionB);\n        assertTrue(collectionA.size() == size && collectionA.contains(1));\n        CollectionUtils.collect(collectionB, null, collectionA);\n        assertTrue(collectionA.size() == size && collectionA.contains(1));\n    }\n\n    @Test\n    public void testContainsAll() {\n        final Collection<String> empty = new ArrayList<>(0);\n        final Collection<String> one = new ArrayList<>(1);\n        one.add(\"1\");\n        final Collection<String> two = new ArrayList<>(1);\n        two.add(\"2\");\n        final Collection<String> three = new ArrayList<>(1);\n        three.add(\"3\");\n        final Collection<String> odds = new ArrayList<>(2);\n        odds.add(\"1\");\n        odds.add(\"3\");\n        final Collection<String> multiples = new ArrayList<>(3);\n        multiples.add(\"1\");\n        multiples.add(\"3\");\n        multiples.add(\"1\");\n\n        assertFalse(CollectionUtils.containsAll(one, odds), \"containsAll({1},{1,3}) should return false.\");\n        assertTrue(CollectionUtils.containsAll(odds, one), \"containsAll({1,3},{1}) should return true.\");\n        assertFalse(CollectionUtils.containsAll(three, odds), \"containsAll({3},{1,3}) should return false.\");\n        assertTrue(CollectionUtils.containsAll(odds, three), \"containsAll({1,3},{3}) should return true.\");\n        assertTrue(CollectionUtils.containsAll(two, two), \"containsAll({2},{2}) should return true.\");\n        assertTrue(CollectionUtils.containsAll(odds, odds), \"containsAll({1,3},{1,3}) should return true.\");\n\n        assertFalse(CollectionUtils.containsAll(two, odds), \"containsAll({2},{1,3}) should return false.\");\n        assertFalse(CollectionUtils.containsAll(odds, two), \"containsAll({1,3},{2}) should return false.\");\n        assertFalse(CollectionUtils.containsAll(one, three), \"containsAll({1},{3}) should return false.\");\n        assertFalse(CollectionUtils.containsAll(three, one), \"containsAll({3},{1}) should return false.\");\n        assertTrue(CollectionUtils.containsAll(odds, empty), \"containsAll({1,3},{}) should return true.\");\n        assertFalse(CollectionUtils.containsAll(empty, odds), \"containsAll({},{1,3}) should return false.\");\n        assertTrue(CollectionUtils.containsAll(empty, empty), \"containsAll({},{}) should return true.\");\n\n        assertTrue(CollectionUtils.containsAll(odds, multiples), \"containsAll({1,3},{1,3,1}) should return true.\");\n        assertTrue(CollectionUtils.containsAll(odds, odds), \"containsAll({1,3,1},{1,3,1}) should return true.\");\n    }\n\n    @Test\n    public void testContainsAnyInArray() {\n        final Collection<String> empty = new ArrayList<>(0);\n        final String[] emptyArr = {};\n        final Collection<String> one = new ArrayList<>(1);\n        one.add(\"1\");\n        final String[] oneArr = {\"1\"};\n        final Collection<String> two = new ArrayList<>(1);\n        two.add(\"2\");\n        final String[] twoArr = {\"2\"};\n        final Collection<String> three = new ArrayList<>(1);\n        three.add(\"3\");\n        final String[] threeArr = {\"3\"};\n        final Collection<String> odds = new ArrayList<>(2);\n        odds.add(\"1\");\n        odds.add(\"3\");\n        final String[] oddsArr = {\"1\", \"3\"};\n\n        assertTrue(CollectionUtils.containsAny(one, oddsArr), \"containsAny({1},{1,3}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(odds, oneArr), \"containsAny({1,3},{1}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(three, oddsArr), \"containsAny({3},{1,3}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(odds, threeArr), \"containsAny({1,3},{3}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(two, twoArr), \"containsAny({2},{2}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(odds, oddsArr), \"containsAny({1,3},{1,3}) should return true.\");\n\n        assertFalse(CollectionUtils.containsAny(two, oddsArr), \"containsAny({2},{1,3}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(odds, twoArr), \"containsAny({1,3},{2}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(one, threeArr), \"containsAny({1},{3}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(three, oneArr), \"containsAny({3},{1}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(odds, emptyArr), \"containsAny({1,3},{}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(empty, oddsArr), \"containsAny({},{1,3}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(empty, emptyArr), \"containsAny({},{}) should return false.\");\n    }\n\n    @Test\n    public void testContainsAnyInArrayNullArray() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        final String[] array = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.containsAny(list, array));\n    }\n\n    @Test\n    public void testContainsAnyInArrayNullColl1() {\n        final String[] oneArr = {\"1\"};\n        assertThrows(NullPointerException.class, () -> CollectionUtils.containsAny(null, oneArr));\n    }\n\n    @Test\n    public void testContainsAnyInArrayNullColl2() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        final Collection<String> list2 = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.containsAny(list, list2));\n    }\n\n    @Test\n    public void testContainsAnyInCollection() {\n        final Collection<String> empty = new ArrayList<>(0);\n        final Collection<String> one = new ArrayList<>(1);\n        one.add(\"1\");\n        final Collection<String> two = new ArrayList<>(1);\n        two.add(\"2\");\n        final Collection<String> three = new ArrayList<>(1);\n        three.add(\"3\");\n        final Collection<String> odds = new ArrayList<>(2);\n        odds.add(\"1\");\n        odds.add(\"3\");\n\n        assertTrue(CollectionUtils.containsAny(one, odds), \"containsAny({1},{1,3}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(odds, one), \"containsAny({1,3},{1}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(three, odds), \"containsAny({3},{1,3}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(odds, three), \"containsAny({1,3},{3}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(two, two), \"containsAny({2},{2}) should return true.\");\n        assertTrue(CollectionUtils.containsAny(odds, odds), \"containsAny({1,3},{1,3}) should return true.\");\n\n        assertFalse(CollectionUtils.containsAny(two, odds), \"containsAny({2},{1,3}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(odds, two), \"containsAny({1,3},{2}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(one, three), \"containsAny({1},{3}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(three, one), \"containsAny({3},{1}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(odds, empty), \"containsAny({1,3},{}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(empty, odds), \"containsAny({},{1,3}) should return false.\");\n        assertFalse(CollectionUtils.containsAny(empty, empty), \"containsAny({},{}) should return false.\");\n    }\n\n    @Test\n    public void testContainsAnyNullColl1() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.containsAny(null, list));\n    }\n\n    @Test\n    public void testContainsAnyNullColl2() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        final Collection<String> list2 = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.containsAny(list, list2));\n    }\n\n    @Test\n    public void testContainsAnyNullColl3() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        final String[] array = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.containsAny(list, array));\n    }\n\n    @Test\n    public void testDisjunction() {\n        final Collection<Integer> col = CollectionUtils.disjunction(iterableA, iterableC);\n        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n        assertEquals(Integer.valueOf(1), freq.get(1));\n        assertEquals(Integer.valueOf(2), freq.get(2));\n        assertNull(freq.get(3));\n        assertEquals(Integer.valueOf(2), freq.get(4));\n        assertEquals(Integer.valueOf(1), freq.get(5));\n\n        final Collection<Number> col2 = CollectionUtils.disjunction(collectionC2, collectionA);\n        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n        assertEquals(Integer.valueOf(1), freq2.get(1));\n        assertEquals(Integer.valueOf(2), freq2.get(2));\n        assertNull(freq2.get(3));\n        assertEquals(Integer.valueOf(2), freq2.get(4));\n        assertEquals(Integer.valueOf(1), freq2.get(5));\n    }\n\n    @Test\n    public void testDisjunctionAsSymmetricDifference() {\n        final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n        final Collection<Number> amb = CollectionUtils.<Number>subtract(collectionA, collectionC);\n        final Collection<Number> bma = CollectionUtils.<Number>subtract(collectionC, collectionA);\n        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.union(amb, bma)));\n    }\n\n    @Test\n    public void testDisjunctionAsUnionMinusIntersection() {\n        final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n        final Collection<Number> un = CollectionUtils.<Number>union(collectionA, collectionC);\n        final Collection<Number> inter = CollectionUtils.<Number>intersection(collectionA, collectionC);\n        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.subtract(un, inter)));\n    }\n\n    @Test\n    public void testDisjunctionNullColl1() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.disjunction(null, list));\n    }\n\n    @Test\n    public void testDisjunctionNullColl2() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.disjunction(list, null));\n    }\n\n    @Test\n    public void testEmptyCollection() throws Exception {\n        final Collection<Number> coll = CollectionUtils.emptyCollection();\n        assertEquals(CollectionUtils.EMPTY_COLLECTION, coll);\n    }\n\n    @Test\n    public void testEmptyIfNull() {\n        assertTrue(CollectionUtils.emptyIfNull(null).isEmpty());\n        final Collection<Object> collection = new ArrayList<>();\n        assertSame(collection, CollectionUtils.emptyIfNull(collection));\n    }\n\n    @Test\n    public void testExtractSingleton() {\n        assertAll(\n                () -> {\n                    final ArrayList<String> collNull = null;\n                    assertThrows(NullPointerException.class, () -> CollectionUtils.extractSingleton(collNull),\n                            \"expected NullPointerException from extractSingleton(null)\");\n                },\n                () -> {\n                    final ArrayList<String> collEmpty = new ArrayList<>();\n                    assertThrows(IllegalArgumentException.class, () -> CollectionUtils.extractSingleton(collEmpty),\n                            \"expected IllegalArgumentException from extractSingleton(empty)\");\n                },\n                () -> {\n                    final ArrayList<String> coll = new ArrayList<>();\n                    coll.add(\"foo\");\n                    assertEquals(\"foo\", CollectionUtils.extractSingleton(coll));\n                    coll.add(\"bar\");\n\n                    assertThrows(IllegalArgumentException.class, () -> CollectionUtils.extractSingleton(coll),\n                            \"expected IllegalArgumentException from extractSingleton(size == 2)\");\n                }\n        );\n    }\n\n    //Up to here\n    @Test\n    public void testFilter() {\n        final List<Integer> ints = new ArrayList<>();\n        ints.add(1);\n        ints.add(2);\n        ints.add(3);\n        ints.add(3);\n        final Iterable<Integer> iterable = ints;\n        assertTrue(CollectionUtils.filter(iterable, EQUALS_TWO));\n        assertEquals(1, ints.size());\n        assertEquals(2, (int) ints.get(0));\n    }\n\n    @Test\n    public void testFilterInverse() {\n        final List<Integer> ints = new ArrayList<>();\n        ints.add(1);\n        ints.add(2);\n        ints.add(3);\n        ints.add(3);\n        final Iterable<Integer> iterable = ints;\n        assertTrue(CollectionUtils.filterInverse(iterable, EQUALS_TWO));\n        assertEquals(3, ints.size());\n        assertEquals(1, (int) ints.get(0));\n        assertEquals(3, (int) ints.get(1));\n        assertEquals(3, (int) ints.get(2));\n    }\n\n    @Test\n    public void testFilterInverseNullParameters() throws Exception {\n        final List<Long> longs = Collections.nCopies(4, 10L);\n        assertFalse(CollectionUtils.filterInverse(longs, null));\n        assertEquals(4, longs.size());\n        assertFalse(CollectionUtils.filterInverse(null, EQUALS_TWO));\n        assertEquals(4, longs.size());\n        assertFalse(CollectionUtils.filterInverse(null, null));\n        assertEquals(4, longs.size());\n    }\n\n    @Test\n    public void testFilterNullParameters() throws Exception {\n        final List<Long> longs = Collections.nCopies(4, 10L);\n        assertFalse(CollectionUtils.filter(longs, null));\n        assertEquals(4, longs.size());\n        assertFalse(CollectionUtils.filter(null, EQUALS_TWO));\n        assertEquals(4, longs.size());\n        assertFalse(CollectionUtils.filter(null, null));\n        assertEquals(4, longs.size());\n    }\n\n    @Test\n    public void testGet() {\n        assertEquals(2, CollectionUtils.get((Object) collectionA, 2));\n        assertEquals(2, CollectionUtils.get((Object) collectionA.iterator(), 2));\n        final Map<Integer, Integer> map = CollectionUtils.getCardinalityMap(collectionA);\n        // Test assumes a defined iteration order so convert to a LinkedHashMap\n        final Map<Integer, Integer> linkedMap = new LinkedHashMap<>(map);\n        assertEquals(linkedMap.entrySet().iterator().next(), CollectionUtils.get((Object) linkedMap, 0));\n    }\n\n    @Test\n    public void testGet1() {\n        assertThrows(IllegalArgumentException.class, () -> CollectionUtils.get((Object) null, 0));\n    }\n\n    @Test\n    public void testGetCardinalityMap() {\n        final Map<Number, Integer> freqA = CollectionUtils.<Number>getCardinalityMap(iterableA);\n        assertEquals(1, (int) freqA.get(1));\n        assertEquals(2, (int) freqA.get(2));\n        assertEquals(3, (int) freqA.get(3));\n        assertEquals(4, (int) freqA.get(4));\n        assertNull(freqA.get(5));\n\n        final Map<Long, Integer> freqB = CollectionUtils.getCardinalityMap(iterableB);\n        assertNull(freqB.get(1L));\n        assertEquals(4, (int) freqB.get(2L));\n        assertEquals(3, (int) freqB.get(3L));\n        assertEquals(2, (int) freqB.get(4L));\n        assertEquals(1, (int) freqB.get(5L));\n    }\n\n    @Test\n    public void testGetCardinalityMapNull() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.getCardinalityMap(null));\n    }\n\n    @Test\n    public void testGetEnumeration() {\n        final Vector<Integer> vectorA = new Vector<>(collectionA);\n        final Enumeration<Integer> e = vectorA.elements();\n        assertEquals(Integer.valueOf(2), CollectionUtils.get(e, 2));\n        assertTrue(e.hasMoreElements());\n        assertEquals(Integer.valueOf(4), CollectionUtils.get(e, 6));\n        assertFalse(e.hasMoreElements());\n    }\n\n    @Test\n    public void testGetFromHashMap() {\n        // Unordered map, entries exist\n        final Map<String, String> expected = new HashMap<>();\n        expected.put(\"zeroKey\", \"zero\");\n        expected.put(\"oneKey\", \"one\");\n\n        Map.Entry<String, String> entry = CollectionUtils.get(expected, 0);\n        assertTrue(entry.toString().equals(\"zeroKey=zero\") || entry.toString().equals(\"oneKey=one\"));\n        entry = CollectionUtils.get(expected, 1);\n        assertTrue(entry.toString().equals(\"zeroKey=zero\") || entry.toString().equals(\"oneKey=one\"));\n\n        // Map index out of range\n        assertAll(\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(expected, 2),\n                        \"Expecting IndexOutOfBoundsException.\"),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(expected, -2),\n                        \"Expecting IndexOutOfBoundsException.\")\n        );\n    }\n\n    @Test\n    public void testGetFromLinkedHashMap() {\n        // Ordered map, entries exist\n        final Map<String, String> expected = new LinkedHashMap<>();\n        expected.put(\"zeroKey\", \"zero\");\n        expected.put(\"oneKey\", \"one\");\n\n        final Map<String, String> found = new LinkedHashMap<>();\n        Map.Entry<String, String> entry = CollectionUtils.get(expected, 0);\n        found.put(entry.getKey(), entry.getValue());\n        entry = CollectionUtils.get(expected, 1);\n        found.put(entry.getKey(), entry.getValue());\n        assertEquals(expected, found);\n    }\n\n    /**\n     * Tests that {@link List}s are handled correctly - e.g. using\n     * {@link List#get(int)}.\n     */\n    @Test\n    public void testGetFromList() throws Exception {\n        // List, entry exists\n        final List<String> list = createMock(List.class);\n        expect(list.get(0)).andReturn(\"zero\");\n        expect(list.get(1)).andReturn(\"one\");\n        replay();\n        final String string = CollectionUtils.get(list, 0);\n        assertEquals(\"zero\", string);\n        assertEquals(\"one\", CollectionUtils.get(list, 1));\n        // list, non-existent entry -- IndexOutOfBoundsException\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(new ArrayList<>(), 2));\n    }\n\n    @Test\n    public void testGetFromMapIndexOutOfRange() {\n        // Ordered map, entries exist\n        final Map<String, String> expected = new LinkedHashMap<>();\n        expected.put(\"zeroKey\", \"zero\");\n        expected.put(\"oneKey\", \"one\");\n\n        // Map index out of range\n        assertAll(\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(expected, 2),\n                        \"Expecting IndexOutOfBoundsException.\"),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(expected, -2),\n                        \"Expecting IndexOutOfBoundsException.\")\n        );\n    }\n\n    @Test\n    public void testGetFromObject() throws Exception {\n        // Invalid object\n        final Object obj = new Object();\n        assertThrows(IllegalArgumentException.class, () -> CollectionUtils.get(obj, 0));\n    }\n\n    @Test\n    public void testGetFromObjectArray() throws Exception {\n        // Object array, entry exists\n        final Object[] objArray = new Object[2];\n        objArray[0] = \"zero\";\n        objArray[1] = \"one\";\n        assertEquals(\"zero\", CollectionUtils.get(objArray, 0));\n        assertEquals(\"one\", CollectionUtils.get(objArray, 1));\n\n        // Object array, non-existent entry --\n        // ArrayIndexOutOfBoundsException\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(objArray, 2));\n    }\n\n    @Test\n    public void testGetFromPrimitiveArray() throws Exception {\n        // Primitive array, entry exists\n        final int[] array = new int[2];\n        array[0] = 10;\n        array[1] = 20;\n        assertEquals(10, CollectionUtils.get(array, 0));\n        assertEquals(20, CollectionUtils.get(array, 1));\n\n        // Object array, non-existent entry --\n        // ArrayIndexOutOfBoundsException\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get(array, 2));\n    }\n\n    @Test\n    public void testGetFromTreeMap() {\n        // Ordered map, entries exist\n        final Map<String, String> expected = new LinkedHashMap<>();\n        expected.put(\"zeroKey\", \"zero\");\n        expected.put(\"oneKey\", \"one\");\n\n        // Sorted map, entries exist, should respect order\n        final SortedMap<String, String> map = new TreeMap<>();\n        map.put(\"zeroKey\", \"zero\");\n        map.put(\"oneKey\", \"one\");\n        Map.Entry<String, String> test = CollectionUtils.get(map, 1);\n        assertEquals(\"zeroKey\", test.getKey());\n        assertEquals(\"zero\", test.getValue());\n        test = CollectionUtils.get(map, 0);\n        assertEquals(\"oneKey\", test.getKey());\n        assertEquals(\"one\", test.getValue());\n    }\n\n    @Test\n    public void testGetIterator() {\n        final Iterator<Integer> it = collectionA.iterator();\n        assertEquals(Integer.valueOf(2), CollectionUtils.get((Object) it, 2));\n        assertTrue(it.hasNext());\n        assertEquals(Integer.valueOf(4), CollectionUtils.get((Object) it, 6));\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    public void testGetNegative() {\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get((Object) collectionA, -3));\n    }\n\n    @Test\n    public void testGetPositiveOutOfBounds() {\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.get((Object) collectionA.iterator(), 30));\n    }\n\n    @Test\n    public void testHashCode() {\n        final Equator<Integer> e = new Equator<Integer>() {\n            @Override\n            public boolean equate(final Integer o1, final Integer o2) {\n                if (o1 % 2 == 0 ^ o2 % 2 == 0) {\n                    return false;\n                }\n                return true;\n            }\n\n            @Override\n            public int hash(final Integer o) {\n                return o == null ? 0 : Objects.hashCode(o);\n            }\n        };\n\n        assertEquals(collectionA.hashCode(), CollectionUtils.hashCode(collectionA, e));\n    }\n\n    @Test\n    public void testHashCodeNullCollection() {\n        final Equator<Integer> e = new Equator<Integer>() {\n            @Override\n            public boolean equate(final Integer o1, final Integer o2) {\n                if (o1 % 2 == 0 ^ o2 % 2 == 0) {\n                    return false;\n                }\n                return true;\n            }\n\n            @Override\n            public int hash(final Integer o) {\n                return o == null ? 0 : Objects.hashCode(o);\n            }\n        };\n\n        final Collection<Integer> collection = null;\n        assertEquals(0, CollectionUtils.hashCode(collection, e));\n    }\n\n    @Test\n    public void testHashCodeNullEquator() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.hashCode(collectionB, null));\n    }\n\n    @Test\n    public void testIntersection() {\n        final Collection<Integer> col = CollectionUtils.intersection(iterableA, iterableC);\n        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n        assertNull(freq.get(1));\n        assertEquals(Integer.valueOf(2), freq.get(2));\n        assertEquals(Integer.valueOf(3), freq.get(3));\n        assertEquals(Integer.valueOf(2), freq.get(4));\n        assertNull(freq.get(5));\n\n        final Collection<Number> col2 = CollectionUtils.intersection(collectionC2, collectionA);\n        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n        assertNull(freq2.get(1));\n        assertEquals(Integer.valueOf(2), freq2.get(2));\n        assertEquals(Integer.valueOf(3), freq2.get(3));\n        assertEquals(Integer.valueOf(2), freq2.get(4));\n        assertNull(freq2.get(5));\n    }\n\n    @Test\n    public void testIntersectionNullColl1() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.intersection(null, list));\n    }\n\n    @Test\n    public void testIntersectionNullColl2() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.intersection(list, null));\n    }\n\n    @Test\n    public void testIntersectionUsesMethodEquals() {\n        // Let elta and eltb be objects...\n        final Integer elta = 17;\n        final Integer eltb = 17;\n\n        // ...which are the same (==)\n        assertSame(elta, eltb);\n\n        // Let cola and colb be collections...\n        final Collection<Number> cola = new ArrayList<>();\n        final Collection<Integer> colb = new ArrayList<>();\n\n        // ...which contain elta and eltb,\n        // respectively.\n        cola.add(elta);\n        colb.add(eltb);\n\n        // Then the intersection of the two\n        // should contain one element.\n        final Collection<Number> intersection = CollectionUtils.intersection(cola, colb);\n        assertEquals(1, intersection.size());\n\n        // In practice, this element will be the same (==) as elta\n        // or eltb, although this isn't strictly part of the\n        // contract.\n        final Object eltc = intersection.iterator().next();\n        assertTrue(eltc == elta && eltc == eltb);\n\n        // In any event, this element remains equal,\n        // to both elta and eltb.\n        assertEquals(elta, eltc);\n        assertEquals(eltc, elta);\n        assertEquals(eltb, eltc);\n        assertEquals(eltc, eltb);\n    }\n\n    @Test\n    public void testIsEmpty() {\n        assertFalse(CollectionUtils.isNotEmpty(null));\n        assertTrue(CollectionUtils.isNotEmpty(collectionA));\n    }\n\n    @Test\n    public void testIsEmptyWithEmptyCollection() {\n        assertTrue(CollectionUtils.isEmpty(new ArrayList<>()));\n    }\n\n    @Test\n    public void testIsEmptyWithNonEmptyCollection() {\n        assertFalse(CollectionUtils.isEmpty(Collections.singletonList(\"item\")));\n    }\n\n    @Test\n    public void testIsEmptyWithNull() {\n        assertTrue(CollectionUtils.isEmpty(null));\n    }\n\n    @Test\n    public void testIsEqualCollection() {\n        assertFalse(CollectionUtils.isEqualCollection(collectionA, collectionC));\n        assertFalse(CollectionUtils.isEqualCollection(collectionC, collectionA));\n    }\n\n    @Test\n    public void testIsEqualCollection2() {\n        final Collection<String> a = new ArrayList<>();\n        final Collection<String> b = new ArrayList<>();\n        assertTrue(CollectionUtils.isEqualCollection(a, b));\n        assertTrue(CollectionUtils.isEqualCollection(b, a));\n        a.add(\"1\");\n        assertFalse(CollectionUtils.isEqualCollection(a, b));\n        assertFalse(CollectionUtils.isEqualCollection(b, a));\n        b.add(\"1\");\n        assertTrue(CollectionUtils.isEqualCollection(a, b));\n        assertTrue(CollectionUtils.isEqualCollection(b, a));\n        a.add(\"2\");\n        assertFalse(CollectionUtils.isEqualCollection(a, b));\n        assertFalse(CollectionUtils.isEqualCollection(b, a));\n        b.add(\"2\");\n        assertTrue(CollectionUtils.isEqualCollection(a, b));\n        assertTrue(CollectionUtils.isEqualCollection(b, a));\n        a.add(\"1\");\n        assertFalse(CollectionUtils.isEqualCollection(a, b));\n        assertFalse(CollectionUtils.isEqualCollection(b, a));\n        b.add(\"1\");\n        assertTrue(CollectionUtils.isEqualCollection(a, b));\n        assertTrue(CollectionUtils.isEqualCollection(b, a));\n    }\n\n    @Test\n    public void testIsEqualCollectionEquator() {\n        final Collection<Integer> collB = CollectionUtils.collect(collectionB, TRANSFORM_TO_INTEGER);\n\n        // odd / even equator\n        final Equator<Integer> e = new Equator<Integer>() {\n            @Override\n            public boolean equate(final Integer o1, final Integer o2) {\n                if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {\n                    return false;\n                }\n                return true;\n            }\n\n            @Override\n            public int hash(final Integer o) {\n                return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();\n            }\n        };\n\n        assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA, e));\n        assertTrue(CollectionUtils.isEqualCollection(collectionA, collB, e));\n        assertTrue(CollectionUtils.isEqualCollection(collB, collectionA, e));\n\n        final Equator<Number> defaultEquator = DefaultEquator.defaultEquator();\n        assertFalse(CollectionUtils.isEqualCollection(collectionA, collectionB, defaultEquator));\n        assertFalse(CollectionUtils.isEqualCollection(collectionA, collB, defaultEquator));\n    }\n\n    @Test\n    public void testIsEqualCollectionNullColl1() {\n        final Collection<Integer> list = new ArrayList<>(1);\n        list.add(1);\n\n        final Equator<Integer> e = new Equator<Integer>() {\n            @Override\n            public boolean equate(final Integer o1, final Integer o2) {\n                if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {\n                    return false;\n                }\n                return true;\n            }\n\n            @Override\n            public int hash(final Integer o) {\n                return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();\n            }\n        };\n        assertThrows(NullPointerException.class, () -> CollectionUtils.isEqualCollection(null, list, e));\n    }\n\n    @Test\n    public void testIsEqualCollectionNullColl2() {\n        final Collection<Integer> list = new ArrayList<>(1);\n        list.add(1);\n\n        final Equator<Integer> e = new Equator<Integer>() {\n            @Override\n            public boolean equate(final Integer o1, final Integer o2) {\n                if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {\n                    return false;\n                }\n                return true;\n            }\n\n            @Override\n            public int hash(final Integer o) {\n                return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();\n            }\n        };\n        assertThrows(NullPointerException.class, () -> CollectionUtils.isEqualCollection(list, null, e));\n    }\n\n    @Test\n    public void testIsEqualCollectionNullEquator() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.isEqualCollection(collectionA, collectionA, null));\n    }\n\n    @Test\n    public void testIsEqualCollectionReturnsFalse() {\n        final List<Integer> b = new ArrayList<>(collectionA);\n        // remove an extra '2', and add a 5.  This will increase the size of the cardinality\n        b.remove(1);\n        b.add(5);\n        assertFalse(CollectionUtils.isEqualCollection(collectionA, b));\n        assertFalse(CollectionUtils.isEqualCollection(b, collectionA));\n    }\n\n    @Test\n    public void testIsEqualCollectionToSelf() {\n        assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA));\n        assertTrue(CollectionUtils.isEqualCollection(collectionB, collectionB));\n    }\n\n    @Test\n    public void testIsFull() {\n        final Set<String> set = new HashSet<>();\n        set.add(\"1\");\n        set.add(\"2\");\n        set.add(\"3\");\n        assertFalse(CollectionUtils.isFull(set));\n\n        final CircularFifoQueue<String> buf = new CircularFifoQueue<>(set);\n        assertFalse(CollectionUtils.isFull(buf));\n        buf.remove(\"2\");\n        assertFalse(CollectionUtils.isFull(buf));\n        buf.add(\"2\");\n        assertFalse(CollectionUtils.isFull(buf));\n    }\n\n    @Test\n    public void testIsFullNullColl() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.isFull(null));\n    }\n\n    @Test\n    public void testIsNotEmptyWithEmptyCollection() {\n        assertFalse(CollectionUtils.isNotEmpty(new ArrayList<>()));\n    }\n\n    @Test\n    public void testIsNotEmptyWithNonEmptyCollection() {\n        assertTrue(CollectionUtils.isNotEmpty(Collections.singletonList(\"item\")));\n    }\n\n    @Test\n    public void testIsNotEmptyWithNull() {\n        assertFalse(CollectionUtils.isNotEmpty(null));\n    }\n\n    @Test\n    public void testIsProperSubCollection() {\n        final Collection<String> a = new ArrayList<>();\n        final Collection<String> b = new ArrayList<>();\n        assertFalse(CollectionUtils.isProperSubCollection(a, b));\n        b.add(\"1\");\n        assertTrue(CollectionUtils.isProperSubCollection(a, b));\n        assertFalse(CollectionUtils.isProperSubCollection(b, a));\n        assertFalse(CollectionUtils.isProperSubCollection(b, b));\n        assertFalse(CollectionUtils.isProperSubCollection(a, a));\n        a.add(\"1\");\n        a.add(\"2\");\n        b.add(\"2\");\n        assertFalse(CollectionUtils.isProperSubCollection(b, a));\n        assertFalse(CollectionUtils.isProperSubCollection(a, b));\n        a.add(\"1\");\n        assertTrue(CollectionUtils.isProperSubCollection(b, a));\n        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.intersection(collectionA, collectionC), collectionA));\n        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.subtract(a, b), a));\n        assertFalse(CollectionUtils.isProperSubCollection(a, CollectionUtils.subtract(a, b)));\n    }\n\n    @Test\n    public void testIsProperSubCollectionNullColl1() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.isProperSubCollection(null, list));\n    }\n\n    @Test\n    public void testIsProperSubCollectionNullColl2() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.isProperSubCollection(list, null));\n    }\n\n    @Test\n    public void testIsSubCollection() {\n        assertFalse(CollectionUtils.isSubCollection(collectionA, collectionC));\n        assertFalse(CollectionUtils.isSubCollection(collectionC, collectionA));\n    }\n\n    @Test\n    public void testIsSubCollection2() {\n        final Collection<Integer> c = new ArrayList<>();\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(1);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(2);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(2);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(3);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(3);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(3);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(4);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(4);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(4);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertFalse(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(4);\n        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n        c.add(5);\n        assertFalse(CollectionUtils.isSubCollection(c, collectionA));\n        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n    }\n\n    @Test\n    public void testIsSubCollectionNullColl1() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.isSubCollection(null, list));\n    }\n\n    @Test\n    public void testIsSubCollectionNullColl2() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.isSubCollection(list, null));\n    }\n\n    @Test\n    public void testIsSubCollectionOfSelf() {\n        assertTrue(CollectionUtils.isSubCollection(collectionA, collectionA));\n        assertTrue(CollectionUtils.isSubCollection(collectionB, collectionB));\n    }\n\n    @Test\n    @Deprecated\n    public void testMatchesAll() {\n        assertFalse(CollectionUtils.matchesAll(null, null));\n        assertFalse(CollectionUtils.matchesAll(collectionA, null));\n\n        final Predicate<Integer> lessThanFive = object -> object < 5;\n        assertTrue(CollectionUtils.matchesAll(collectionA, lessThanFive));\n\n        final Predicate<Integer> lessThanFour = object -> object < 4;\n        assertFalse(CollectionUtils.matchesAll(collectionA, lessThanFour));\n\n        assertTrue(CollectionUtils.matchesAll(null, lessThanFour));\n        assertTrue(CollectionUtils.matchesAll(emptyCollection, lessThanFour));\n    }\n\n    @Test\n    public void testMaxSize() {\n        final Set<String> set = new HashSet<>();\n        set.add(\"1\");\n        set.add(\"2\");\n        set.add(\"3\");\n        assertEquals(-1, CollectionUtils.maxSize(set));\n\n        final Queue<String> buf = new CircularFifoQueue<>(set);\n        assertEquals(3, CollectionUtils.maxSize(buf));\n        buf.remove(\"2\");\n        assertEquals(3, CollectionUtils.maxSize(buf));\n        buf.add(\"2\");\n        assertEquals(3, CollectionUtils.maxSize(buf));\n    }\n\n    @Test\n    public void testMaxSizeNullColl() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.maxSize(null));\n    }\n\n    @Test\n    public void testPermutations() {\n        final List<Integer> sample = collectionA.subList(0, 5);\n        final Collection<List<Integer>> permutations = CollectionUtils.permutations(sample);\n\n        // result size = n!\n        final int collSize = sample.size();\n        int factorial = 1;\n        for (int i = 1; i <= collSize; i++) {\n            factorial *= i;\n        }\n        assertEquals(factorial, permutations.size());\n    }\n\n    @Test\n    public void testPermutationsWithNullCollection() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.permutations(null));\n    }\n\n    @Test\n    public void testPredicatedCollection() {\n        final Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);\n        final Collection<Number> collection = CollectionUtils.predicatedCollection(new ArrayList<>(), predicate);\n        assertInstanceOf(PredicatedCollection.class, collection, \"returned object should be a PredicatedCollection\");\n    }\n\n    @Test\n    public void testPredicatedCollectionNullColl() {\n        final Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);\n        assertThrows(NullPointerException.class, () -> CollectionUtils.predicatedCollection(null, predicate));\n    }\n\n    @Test\n    public void testPredicatedCollectionNullPredicate() {\n        final Collection<Integer> list = new ArrayList<>();\n        assertThrows(NullPointerException.class, () -> CollectionUtils.predicatedCollection(list, null));\n    }\n\n    @Test\n    public void testRemoveAll() {\n        final List<String> base = new ArrayList<>();\n        base.add(\"A\");\n        base.add(\"B\");\n        base.add(\"C\");\n        final List<String> sub = new ArrayList<>();\n        sub.add(\"A\");\n        sub.add(\"C\");\n        sub.add(\"X\");\n\n        final Collection<String> result = CollectionUtils.removeAll(base, sub);\n        assertEquals(1, result.size());\n        assertFalse(result.contains(\"A\"));\n        assertTrue(result.contains(\"B\"));\n        assertFalse(result.contains(\"C\"));\n        assertEquals(3, base.size());\n        assertTrue(base.contains(\"A\"));\n        assertTrue(base.contains(\"B\"));\n        assertTrue(base.contains(\"C\"));\n        assertEquals(3, sub.size());\n        assertTrue(sub.contains(\"A\"));\n        assertTrue(sub.contains(\"C\"));\n        assertTrue(sub.contains(\"X\"));\n    }\n\n    @Test\n    public void testRemoveAllNullBaseColl() {\n        final List<String> sub = new ArrayList<>();\n        sub.add(\"A\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.removeAll(null, sub));\n    }\n\n    @Test\n    public void testRemoveAllNullSubColl() {\n        final List<String> base = new ArrayList<>();\n        base.add(\"A\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.removeAll(base, null));\n    }\n\n    @Test\n    public void testRemoveAllWithEquator() {\n        final List<String> base = new ArrayList<>();\n        base.add(\"AC\");\n        base.add(\"BB\");\n        base.add(\"CA\");\n\n        final List<String> remove = new ArrayList<>();\n        remove.add(\"AA\");\n        remove.add(\"CX\");\n        remove.add(\"XZ\");\n\n        // use an equator which compares the second letter only\n        final Collection<String> result = CollectionUtils.removeAll(base, remove, new Equator<String>() {\n\n            @Override\n            public boolean equate(final String o1, final String o2) {\n                return o1.charAt(1) == o2.charAt(1);\n            }\n\n            @Override\n            public int hash(final String o) {\n                return o.charAt(1);\n            }\n        });\n\n        assertEquals(2, result.size());\n        assertTrue(result.contains(\"AC\"));\n        assertTrue(result.contains(\"BB\"));\n        assertFalse(result.contains(\"CA\"));\n        assertEquals(3, base.size());\n        assertTrue(base.contains(\"AC\"));\n        assertTrue(base.contains(\"BB\"));\n        assertTrue(base.contains(\"CA\"));\n        assertEquals(3, remove.size());\n        assertTrue(remove.contains(\"AA\"));\n        assertTrue(remove.contains(\"CX\"));\n        assertTrue(remove.contains(\"XZ\"));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> CollectionUtils.removeAll(null, null, DefaultEquator.defaultEquator()),\n                        \"expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> CollectionUtils.removeAll(base, remove, null),\n                        \"expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    public void testRemoveCount() {\n        final List<Integer> list = new ArrayList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n\n        Collection<Integer> result = CollectionUtils.removeCount(list, 0, 0);\n        assertEquals(4, list.size());\n        assertEquals(0, result.size());\n\n        result = CollectionUtils.removeCount(list, 0, 1);\n        assertEquals(3, list.size());\n        assertEquals(2, (int) list.get(0));\n        assertEquals(1, result.size());\n        assertTrue(result.contains(1));\n\n        list.add(5);\n        list.add(6);\n        result = CollectionUtils.removeCount(list, 1, 3);\n\n        assertEquals(2, list.size());\n        assertEquals(2, (int) list.get(0));\n        assertEquals(6, (int) list.get(1));\n        assertEquals(3, result.size());\n        assertTrue(result.contains(3));\n        assertTrue(result.contains(4));\n        assertTrue(result.contains(5));\n    }\n\n    @Test\n    public void testRemoveCountNegative() {\n        final Collection<Integer> list = new ArrayList<>();\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.removeCount(list, 0, -1));\n    }\n\n    @Test\n    public void testRemoveCountStartNegative() {\n        final Collection<Integer> list = new ArrayList<>();\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.removeCount(list, -1, 1));\n    }\n\n    @Test\n    public void testRemoveCountWithNull() {\n        final Collection<Integer> list = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.removeCount(list, 0, 1));\n    }\n\n    @Test\n    public void testRemoveCountWrongCount() {\n        final Collection<Integer> list = new ArrayList<>();\n        list.add(1);\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.removeCount(list, 0, 2));\n    }\n\n    @Test\n    public void testRemoveRange() {\n        final List<Integer> list = new ArrayList<>();\n        list.add(1);\n        Collection<Integer> result = CollectionUtils.removeRange(list, 0, 0);\n        assertEquals(1, list.size());\n        assertEquals(0, result.size());\n\n        list.add(2);\n        list.add(3);\n        result = CollectionUtils.removeRange(list, 1, 3);\n        assertEquals(1, list.size());\n        assertEquals(1, (int) list.get(0));\n        assertEquals(2, result.size());\n        assertTrue(result.contains(2));\n        assertTrue(result.contains(3));\n    }\n\n    @Test\n    public void testRemoveRangeEndIndexNegative() {\n        final Collection<Integer> list = new ArrayList<>();\n        list.add(1);\n        assertThrows(IllegalArgumentException.class, () -> CollectionUtils.removeRange(list, 0, -1));\n    }\n\n    @Test\n    public void testRemoveRangeEndLowStart() {\n        final Collection<Integer> list = new ArrayList<>();\n        list.add(1);\n        list.add(2);\n        assertThrows(IllegalArgumentException.class, () -> CollectionUtils.removeRange(list, 1, 0));\n    }\n\n    @Test\n    public void testRemoveRangeNull() {\n        final Collection<Integer> list = null;\n        assertThrows(NullPointerException.class, () -> CollectionUtils.removeRange(list, 0, 0));\n    }\n\n    @Test\n    public void testRemoveRangeStartIndexNegative() {\n        final Collection<Integer> list = new ArrayList<>();\n        list.add(1);\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.removeRange(list, -1, 1));\n    }\n\n    @Test\n    public void testRemoveRangeWrongEndIndex() {\n        final Collection<Integer> list = new ArrayList<>();\n        list.add(1);\n        assertThrows(IndexOutOfBoundsException.class, () -> CollectionUtils.removeRange(list, 0, 2));\n    }\n\n    @Test\n    public void testRetainAll() {\n        final List<String> base = new ArrayList<>();\n        base.add(\"A\");\n        base.add(\"B\");\n        base.add(\"C\");\n        final List<Object> sub = new ArrayList<>();\n        sub.add(\"A\");\n        sub.add(\"C\");\n        sub.add(\"X\");\n\n        final Collection<String> result = CollectionUtils.retainAll(base, sub);\n        assertEquals(2, result.size());\n        assertTrue(result.contains(\"A\"));\n        assertFalse(result.contains(\"B\"));\n        assertTrue(result.contains(\"C\"));\n        assertEquals(3, base.size());\n        assertTrue(base.contains(\"A\"));\n        assertTrue(base.contains(\"B\"));\n        assertTrue(base.contains(\"C\"));\n        assertEquals(3, sub.size());\n        assertTrue(sub.contains(\"A\"));\n        assertTrue(sub.contains(\"C\"));\n        assertTrue(sub.contains(\"X\"));\n    }\n\n    @Test\n    public void testRetainAllNullBaseColl() {\n        final List<Object> sub = new ArrayList<>();\n        sub.add(\"A\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.retainAll(null, sub));\n    }\n\n    @Test\n    public void testRetainAllNullSubColl() {\n        final List<String> base = new ArrayList<>();\n        base.add(\"A\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.retainAll(base, null));\n    }\n\n    @Test\n    public void testRetainAllWithEquator() {\n        final List<String> base = new ArrayList<>();\n        base.add(\"AC\");\n        base.add(\"BB\");\n        base.add(\"CA\");\n\n        final List<String> retain = new ArrayList<>();\n        retain.add(\"AA\");\n        retain.add(\"CX\");\n        retain.add(\"XZ\");\n\n        // use an equator which compares the second letter only\n        final Collection<String> result = CollectionUtils.retainAll(base, retain, new Equator<String>() {\n\n            @Override\n            public boolean equate(final String o1, final String o2) {\n                return o1.charAt(1) == o2.charAt(1);\n            }\n\n            @Override\n            public int hash(final String o) {\n                return o.charAt(1);\n            }\n        });\n        assertEquals(1, result.size());\n        assertTrue(result.contains(\"CA\"));\n        assertFalse(result.contains(\"BB\"));\n        assertFalse(result.contains(\"AC\"));\n\n        assertEquals(3, base.size());\n        assertTrue(base.contains(\"AC\"));\n        assertTrue(base.contains(\"BB\"));\n        assertTrue(base.contains(\"CA\"));\n\n        assertEquals(3, retain.size());\n        assertTrue(retain.contains(\"AA\"));\n        assertTrue(retain.contains(\"CX\"));\n        assertTrue(retain.contains(\"XZ\"));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> CollectionUtils.retainAll(null, null, null),\n                        \"expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> CollectionUtils.retainAll(base, retain, null),\n                        \"expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    public void testReverse() {\n        CollectionUtils.reverseArray(new Object[] {});\n        final Integer[] a = collectionA.toArray(ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY);\n        CollectionUtils.reverseArray(a);\n        // assume our implementation is correct if it returns the same order as the Java function\n        Collections.reverse(collectionA);\n        assertEquals(collectionA, Arrays.asList(a));\n    }\n\n    @Test\n    public void testReverseArrayNull() {\n        assertThrows(NullPointerException.class, () -> CollectionUtils.reverseArray(null));\n    }\n\n    @Test\n    public void testSelect() {\n        final List<Integer> list = new ArrayList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        // Ensure that the collection is the input type or a super type\n        final Collection<Integer> output1 = CollectionUtils.select(list, EQUALS_TWO);\n        final Collection<Number> output2 = CollectionUtils.<Number>select(list, EQUALS_TWO);\n        final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<>());\n        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n        assertEquals(4, list.size());\n        assertEquals(1, output1.size());\n        assertEquals(2, output2.iterator().next());\n    }\n\n    @Test\n    public void testSelectRejected() {\n        final List<Long> list = new ArrayList<>();\n        list.add(1L);\n        list.add(2L);\n        list.add(3L);\n        list.add(4L);\n        final Collection<Long> output1 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n        final Collection<? extends Number> output2 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n        final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<>());\n        assertTrue(CollectionUtils.isEqualCollection(output1, output2));\n        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n        assertEquals(4, list.size());\n        assertEquals(3, output1.size());\n        assertTrue(output1.contains(1L));\n        assertTrue(output1.contains(3L));\n        assertTrue(output1.contains(4L));\n    }\n\n    @Test\n    public void testSelectWithOutputCollections() {\n        final List<Integer> input = new ArrayList<>();\n        input.add(1);\n        input.add(2);\n        input.add(3);\n        input.add(4);\n\n        final List<Integer> output = new ArrayList<>();\n        final List<Integer> rejected = new ArrayList<>();\n\n        CollectionUtils.select(input, EQUALS_TWO, output, rejected);\n\n        // output contains 2\n        assertEquals(1, output.size());\n        assertEquals(2, CollectionUtils.extractSingleton(output).intValue());\n\n        // rejected contains 1, 3, and 4\n        final Integer[] expected = {1, 3, 4};\n        assertArrayEquals(expected, rejected.toArray());\n\n        output.clear();\n        rejected.clear();\n        CollectionUtils.select((List<Integer>) null, EQUALS_TWO, output, rejected);\n        assertTrue(output.isEmpty());\n        assertTrue(rejected.isEmpty());\n    }\n\n    @Test\n    public void testSize_Array() {\n        final Object[] objectArray = {};\n        assertEquals(0, CollectionUtils.size(objectArray));\n\n        final String[] stringArray = new String[3];\n        assertEquals(3, CollectionUtils.size(stringArray));\n        stringArray[0] = \"a\";\n        stringArray[1] = \"b\";\n        stringArray[2] = \"c\";\n        assertEquals(3, CollectionUtils.size(stringArray));\n    }\n\n    @Test\n    public void testSize_Enumeration() {\n        final Vector<String> list = new Vector<>();\n        assertEquals(0, CollectionUtils.size(list.elements()));\n        list.add(\"a\");\n        assertEquals(1, CollectionUtils.size(list.elements()));\n        list.add(\"b\");\n        assertEquals(2, CollectionUtils.size(list.elements()));\n    }\n\n    @Test\n    public void testSize_Iterator() {\n        final List<String> list = new ArrayList<>();\n        assertEquals(0, CollectionUtils.size(list.iterator()));\n        list.add(\"a\");\n        assertEquals(1, CollectionUtils.size(list.iterator()));\n        list.add(\"b\");\n        assertEquals(2, CollectionUtils.size(list.iterator()));\n    }\n\n    @Test\n    public void testSize_List() {\n        List<String> list = null;\n        assertEquals(0, CollectionUtils.size(list));\n        list = new ArrayList<>();\n        assertEquals(0, CollectionUtils.size(list));\n        list.add(\"a\");\n        assertEquals(1, CollectionUtils.size(list));\n        list.add(\"b\");\n        assertEquals(2, CollectionUtils.size(list));\n    }\n\n    @Test\n    public void testSize_Map() {\n        final Map<String, String> map = new HashMap<>();\n        assertEquals(0, CollectionUtils.size(map));\n        map.put(\"1\", \"a\");\n        assertEquals(1, CollectionUtils.size(map));\n        map.put(\"2\", \"b\");\n        assertEquals(2, CollectionUtils.size(map));\n    }\n\n    @Test\n    public void testSize_Other() {\n        assertThrows(IllegalArgumentException.class, () -> CollectionUtils.size(\"not a list\"));\n    }\n\n    @Test\n    public void testSize_PrimitiveArray() {\n        final int[] intArray = {};\n        assertEquals(0, CollectionUtils.size(intArray));\n\n        final double[] doubleArray = new double[3];\n        assertEquals(3, CollectionUtils.size(doubleArray));\n        doubleArray[0] = 0.0d;\n        doubleArray[1] = 1.0d;\n        doubleArray[2] = 2.5d;\n        assertEquals(3, CollectionUtils.size(doubleArray));\n    }\n\n    @Test\n    public void testSizeIsEmpty_Array() {\n        final Object[] objectArray = {};\n        assertTrue(CollectionUtils.sizeIsEmpty(objectArray));\n\n        final String[] stringArray = new String[3];\n        assertFalse(CollectionUtils.sizeIsEmpty(stringArray));\n        stringArray[0] = \"a\";\n        stringArray[1] = \"b\";\n        stringArray[2] = \"c\";\n        assertFalse(CollectionUtils.sizeIsEmpty(stringArray));\n    }\n\n    @Test\n    public void testSizeIsEmpty_Enumeration() {\n        final Vector<String> list = new Vector<>();\n        assertTrue(CollectionUtils.sizeIsEmpty(list.elements()));\n        list.add(\"a\");\n        assertFalse(CollectionUtils.sizeIsEmpty(list.elements()));\n        final Enumeration<String> en = list.elements();\n        en.nextElement();\n        assertTrue(CollectionUtils.sizeIsEmpty(en));\n    }\n\n    @Test\n    public void testSizeIsEmpty_Iterator() {\n        final List<String> list = new ArrayList<>();\n        assertTrue(CollectionUtils.sizeIsEmpty(list.iterator()));\n        list.add(\"a\");\n        assertFalse(CollectionUtils.sizeIsEmpty(list.iterator()));\n        final Iterator<String> it = list.iterator();\n        it.next();\n        assertTrue(CollectionUtils.sizeIsEmpty(it));\n    }\n\n    @Test\n    public void testSizeIsEmpty_List() {\n        final List<String> list = new ArrayList<>();\n        assertTrue(CollectionUtils.sizeIsEmpty(list));\n        list.add(\"a\");\n        assertFalse(CollectionUtils.sizeIsEmpty(list));\n    }\n\n    @Test\n    public void testSizeIsEmpty_Map() {\n        final Map<String, String> map = new HashMap<>();\n        assertTrue(CollectionUtils.sizeIsEmpty(map));\n        map.put(\"1\", \"a\");\n        assertFalse(CollectionUtils.sizeIsEmpty(map));\n    }\n\n    @Test\n    public void testSizeIsEmpty_Null() {\n        assertTrue(CollectionUtils.sizeIsEmpty(null));\n    }\n\n    @Test\n    public void testSizeIsEmpty_Other() {\n        assertThrows(IllegalArgumentException.class, () -> CollectionUtils.sizeIsEmpty(\"not a list\"),\n                \"Expecting IllegalArgumentException\");\n    }\n\n    @Test\n    public void testSizeIsEmpty_PrimitiveArray() {\n        final int[] intArray = {};\n        assertTrue(CollectionUtils.sizeIsEmpty(intArray));\n\n        final double[] doubleArray = new double[3];\n        assertFalse(CollectionUtils.sizeIsEmpty(doubleArray));\n        doubleArray[0] = 0.0d;\n        doubleArray[1] = 1.0d;\n        doubleArray[2] = 2.5d;\n        assertFalse(CollectionUtils.sizeIsEmpty(doubleArray));\n    }\n\n    @Test\n    public void testSubtract() {\n        final Collection<Integer> col = CollectionUtils.subtract(iterableA, iterableC);\n        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n        assertEquals(Integer.valueOf(1), freq.get(1));\n        assertNull(freq.get(2));\n        assertNull(freq.get(3));\n        assertEquals(Integer.valueOf(2), freq.get(4));\n        assertNull(freq.get(5));\n\n        final Collection<Number> col2 = CollectionUtils.subtract(collectionC2, collectionA);\n        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n        assertEquals(Integer.valueOf(1), freq2.get(5));\n        assertNull(freq2.get(4));\n        assertNull(freq2.get(3));\n        assertEquals(Integer.valueOf(2), freq2.get(2));\n        assertNull(freq2.get(1));\n    }\n\n    @Test\n    public void testSubtractNullColl1() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.subtract(null, list));\n    }\n\n    @Test\n    public void testSubtractNullColl2() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.subtract(list, null));\n    }\n\n    @Test\n    public void testSubtractWithPredicate() {\n        // greater than 3\n        final Predicate<Number> predicate = n -> n.longValue() > 3L;\n\n        final Collection<Number> col = CollectionUtils.subtract(iterableA, collectionC, predicate);\n        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col);\n        assertEquals(Integer.valueOf(1), freq2.get(1));\n        assertEquals(Integer.valueOf(2), freq2.get(2));\n        assertEquals(Integer.valueOf(3), freq2.get(3));\n        assertEquals(Integer.valueOf(2), freq2.get(4));\n        assertNull(freq2.get(5));\n    }\n\n    @Test\n    @Deprecated\n    public void testSynchronizedCollection() {\n        final Collection<Object> col = CollectionUtils.synchronizedCollection(new ArrayList<>());\n        assertInstanceOf(SynchronizedCollection.class, col, \"Returned object should be a SynchronizedCollection.\");\n\n        assertThrows(NullPointerException.class, () -> CollectionUtils.synchronizedCollection(null),\n                \"Expecting NullPointerException for null collection.\");\n    }\n\n    @Test\n    public void testTransform1() {\n        List<Number> list = new ArrayList<>();\n        list.add(1L);\n        list.add(2L);\n        list.add(3L);\n        CollectionUtils.transform(list, TRANSFORM_TO_INTEGER);\n        assertEquals(3, list.size());\n        assertEquals(1, list.get(0));\n        assertEquals(2, list.get(1));\n        assertEquals(3, list.get(2));\n\n        list = new ArrayList<>();\n        list.add(1L);\n        list.add(2L);\n        list.add(3L);\n        CollectionUtils.transform(null, TRANSFORM_TO_INTEGER);\n        assertEquals(3, list.size());\n        CollectionUtils.transform(list, null);\n        assertEquals(3, list.size());\n        CollectionUtils.transform(null, null);\n        assertEquals(3, list.size());\n    }\n\n    @Test\n    public void testTransform2() {\n        final Set<Number> set = new HashSet<>();\n        set.add(1L);\n        set.add(2L);\n        set.add(3L);\n        CollectionUtils.transform(set, input -> 4);\n        assertEquals(1, set.size());\n        assertEquals(4, set.iterator().next());\n    }\n\n    @Test\n    public void testTransformedCollection() {\n        final Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();\n        final Collection<Object> collection = CollectionUtils.transformingCollection(new ArrayList<>(), transformer);\n        assertInstanceOf(TransformedCollection.class, collection, \"returned object should be a TransformedCollection\");\n    }\n\n    @Test\n    public void testTransformedCollection_2() {\n        final List<Object> list = new ArrayList<>();\n        list.add(\"1\");\n        list.add(\"2\");\n        list.add(\"3\");\n        final Collection<Object> result = CollectionUtils.transformingCollection(list, TRANSFORM_TO_INTEGER);\n        assertTrue(result.contains(\"1\")); // untransformed\n        assertTrue(result.contains(\"2\")); // untransformed\n        assertTrue(result.contains(\"3\")); // untransformed\n    }\n\n    @Test\n    public void testTransformingCollectionNullColl() {\n        final Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();\n        assertThrows(NullPointerException.class, () -> CollectionUtils.transformingCollection(null, transformer));\n    }\n\n    @Test\n    public void testTransformingCollectionNullTransformer() {\n        final List<String> list = new ArrayList<>();\n        assertThrows(NullPointerException.class, () -> CollectionUtils.transformingCollection(list, null));\n    }\n\n    @Test\n    public void testUnion() {\n        final Collection<Integer> col = CollectionUtils.union(iterableA, iterableC);\n        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n        assertEquals(Integer.valueOf(1), freq.get(1));\n        assertEquals(Integer.valueOf(4), freq.get(2));\n        assertEquals(Integer.valueOf(3), freq.get(3));\n        assertEquals(Integer.valueOf(4), freq.get(4));\n        assertEquals(Integer.valueOf(1), freq.get(5));\n\n        final Collection<Number> col2 = CollectionUtils.union(collectionC2, iterableA);\n        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n        assertEquals(Integer.valueOf(1), freq2.get(1));\n        assertEquals(Integer.valueOf(4), freq2.get(2));\n        assertEquals(Integer.valueOf(3), freq2.get(3));\n        assertEquals(Integer.valueOf(4), freq2.get(4));\n        assertEquals(Integer.valueOf(1), freq2.get(5));\n    }\n\n    @Test\n    public void testUnionNullColl1() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.union(null, list));\n    }\n\n    @Test\n    public void testUnionNullColl2() {\n        final Collection<String> list = new ArrayList<>(1);\n        list.add(\"1\");\n        assertThrows(NullPointerException.class, () -> CollectionUtils.union(list, null));\n    }\n\n    @Test\n    @Deprecated\n    public void testUnmodifiableCollection() {\n        final Collection<Object> col = CollectionUtils.unmodifiableCollection(new ArrayList<>());\n        assertInstanceOf(UnmodifiableCollection.class, col, \"Returned object should be a UnmodifiableCollection.\");\n\n        assertThrows(NullPointerException.class, () -> CollectionUtils.unmodifiableCollection(null),\n                \"Expecting NullPointerException for null collection.\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Predicate<Number>", "name": "EQUALS_TWO = input -> input.intValue() == 2", "syntax_pass": true}, {"attribute_expression": "private List<Integer> collectionA;", "docstring": "\nCollection of {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Integer>", "name": "collectionA", "syntax_pass": true}, {"attribute_expression": "private List<Long> collectionB;", "docstring": "\nCollection of {@link Long}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Long>", "name": "collectionB", "syntax_pass": true}, {"attribute_expression": "private Collection<Integer> collectionC;", "docstring": "\nCollection of {@link Integer}s that are equivalent to the Longs in\ncollectionB.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<Integer>", "name": "collectionC", "syntax_pass": true}, {"attribute_expression": "private Collection<Integer> collectionD;", "docstring": "\nSorted Collection of {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<Integer>", "name": "collectionD", "syntax_pass": true}, {"attribute_expression": "private Collection<Integer> collectionE;", "docstring": "\nSorted Collection of {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<Integer>", "name": "collectionE", "syntax_pass": true}, {"attribute_expression": "private Collection<Number> collectionA2;", "docstring": "\nCollection of {@link Integer}s, bound as {@link Number}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<Number>", "name": "collectionA2", "syntax_pass": true}, {"attribute_expression": "private Collection<Number> collectionB2;", "docstring": "\nCollection of {@link Long}s, bound as {@link Number}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<Number>", "name": "collectionB2", "syntax_pass": true}, {"attribute_expression": "private Collection<Number> collectionC2;", "docstring": "\nCollection of {@link Integer}s (cast as {@link Number}s) that are\nequivalent to the Longs in collectionB.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<Number>", "name": "collectionC2", "syntax_pass": true}, {"attribute_expression": "private Iterable<Integer> iterableA;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Integer>", "name": "iterableA", "syntax_pass": true}, {"attribute_expression": "private Iterable<Long> iterableB;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Long>", "name": "iterableB", "syntax_pass": true}, {"attribute_expression": "private Iterable<Integer> iterableC;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Integer>", "name": "iterableC", "syntax_pass": true}, {"attribute_expression": "private Iterable<Number> iterableA2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Number>", "name": "iterableA2", "syntax_pass": true}, {"attribute_expression": "private Iterable<Number> iterableB2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Number>", "name": "iterableB2", "syntax_pass": true}, {"attribute_expression": "private final Collection<Integer> emptyCollection = new ArrayList<>(1);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<Integer>", "name": "emptyCollection = new ArrayList<>(1)", "syntax_pass": true}, {"attribute_expression": "Transformer<Object, Integer> TRANSFORM_TO_INTEGER = input -> Integer.valueOf(((Long) input).intValue());", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Transformer<Object, Integer>", "name": "TRANSFORM_TO_INTEGER = input -> Integer.valueOf(((Long) input).intValue())", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/EnumerationUtils_toListTest.java.EnumerationUtils_toListTest", "name": "EnumerationUtils_toListTest", "file_path": "src/test/java/org/apache/commons/collections4/EnumerationUtils_toListTest.java", "superclasses": "", "methods": ["[void]testToListWithStringTokenizer()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class EnumerationUtils_toListTest {\n\n    @Test\n    public void testToListWithStringTokenizer() {\n        StringTokenizer tokenizer = new StringTokenizer(\"a b c\");\n        List<String> result = EnumerationUtils.toList(tokenizer);\n        assertEquals(3, result.size());\n        assertEquals(\"a\", result.get(0));\n        assertEquals(\"b\", result.get(1));\n        assertEquals(\"c\", result.get(2));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/FluentIterableTest.java.FluentIterableTest", "name": "FluentIterableTest", "file_path": "src/test/java/org/apache/commons/collections4/FluentIterableTest.java", "superclasses": "", "methods": ["[void]testAllMatch()", "[void]testAnyMatch()", "[void]testAppendElements()", "[void]testAppendIterable()", "[void]testAsEnumeration()", "[void]testCollate()", "[void]testCollateWithComparator()", "[void]testContains()", "[void]testCopyInto()", "[void]testEval()", "[void]testFactoryMethodOf()", "[void]testFilter()", "[void]testForEach()", "[void]testGet()", "[void]testIsEmpty()", "[void]testIterator()", "[void]testLimit()", "[void]testReverse()", "[void]testSize()", "[void]testSkip()", "[void]testToArray()", "[void]testToString()", "[void]testTransform()", "[void]testUnique()", "[void]testUnmodifiable()", "[void]testZip()"], "method_uris": ["src/test/java/org/apache/commons/collections4/FluentIterableTest.java.FluentIterableTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for FluentIterable.\n", "original_string": "public class FluentIterableTest {\n\n    private static final Predicate<Number> EVEN = input -> input.intValue() % 2 == 0;\n\n    /**\n     * Iterable of {@link Integer}s\n     */\n    private Iterable<Integer> iterableA;\n\n    /**\n     * Iterable of {@link Long}s\n     */\n    private Iterable<Long> iterableB;\n\n    /**\n     * Collection of even {@link Integer}s\n     */\n    private Iterable<Integer> iterableEven;\n\n    /**\n     * Collection of odd {@link Integer}s\n     */\n    private Iterable<Integer> iterableOdd;\n\n    /**\n     * An empty Iterable.\n     */\n    private Iterable<Integer> emptyIterable;\n\n    @BeforeEach\n    public void setUp() {\n        final Collection<Integer> collectionA = new ArrayList<>();\n        collectionA.add(1);\n        collectionA.add(2);\n        collectionA.add(2);\n        collectionA.add(3);\n        collectionA.add(3);\n        collectionA.add(3);\n        collectionA.add(4);\n        collectionA.add(4);\n        collectionA.add(4);\n        collectionA.add(4);\n        iterableA = collectionA;\n\n        final Collection<Long> collectionB = new LinkedList<>();\n        collectionB.add(5L);\n        collectionB.add(4L);\n        collectionB.add(4L);\n        collectionB.add(3L);\n        collectionB.add(3L);\n        collectionB.add(3L);\n        collectionB.add(2L);\n        collectionB.add(2L);\n        collectionB.add(2L);\n        collectionB.add(2L);\n        iterableB = collectionB;\n\n        iterableEven = Arrays.asList(2, 4, 6, 8, 10, 12);\n        iterableOdd = Arrays.asList(1, 3, 5, 7, 9, 11);\n\n        emptyIterable = Collections.emptyList();\n    }\n\n    @Test\n    public void testAllMatch() {\n        assertTrue(FluentIterable.of(iterableEven).allMatch(EVEN));\n        assertFalse(FluentIterable.of(iterableOdd).allMatch(EVEN));\n        assertFalse(FluentIterable.of(iterableA).allMatch(EVEN));\n\n        assertThrows(NullPointerException.class, () -> FluentIterable.of(iterableEven).allMatch(null),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testAnyMatch() {\n        assertTrue(FluentIterable.of(iterableEven).anyMatch(EVEN));\n        assertFalse(FluentIterable.of(iterableOdd).anyMatch(EVEN));\n        assertTrue(FluentIterable.of(iterableA).anyMatch(EVEN));\n\n        assertThrows(NullPointerException.class, () -> FluentIterable.of(iterableEven).anyMatch(null),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testAppendElements() {\n        final FluentIterable<Integer> it = FluentIterable.of(iterableA).append(10, 20, 30);\n        assertEquals(IterableUtils.size(iterableA) + 3, IterableUtils.size(it));\n        assertTrue(IterableUtils.contains(it, 1));\n        assertTrue(IterableUtils.contains(it, 10));\n        assertTrue(IterableUtils.contains(it, 20));\n        assertTrue(IterableUtils.contains(it, 30));\n        assertFalse(IterableUtils.contains(it, 40));\n\n        final FluentIterable<Integer> empty = FluentIterable.of(emptyIterable).append();\n        assertTrue(IterableUtils.isEmpty(empty));\n    }\n\n    @Test\n    public void testAppendIterable() {\n        final List<Integer> listB = Arrays.asList(10, 20, 30);\n        final FluentIterable<Integer> it = FluentIterable.of(iterableA).append(listB);\n        assertEquals(IterableUtils.size(iterableA) + listB.size(), IterableUtils.size(it));\n        assertTrue(IterableUtils.contains(it, 1));\n        assertTrue(IterableUtils.contains(it, 10));\n        assertTrue(IterableUtils.contains(it, 20));\n        assertTrue(IterableUtils.contains(it, 30));\n        assertFalse(IterableUtils.contains(it, 40));\n    }\n\n    @Test\n    public void testAsEnumeration() {\n        Enumeration<Long> enumeration = FluentIterable.of(iterableB).asEnumeration();\n        final List<Long> result = EnumerationUtils.toList(enumeration);\n        assertEquals(iterableB, result);\n\n        enumeration = FluentIterable.<Long>empty().asEnumeration();\n        assertFalse(enumeration.hasMoreElements());\n    }\n\n    @Test\n    public void testCollate() {\n        final List<Integer> result = FluentIterable.of(iterableOdd).collate(iterableEven).toList();\n        final List<Integer> combinedList = new ArrayList<>();\n        CollectionUtils.addAll(combinedList, iterableOdd);\n        CollectionUtils.addAll(combinedList, iterableEven);\n        Collections.sort(combinedList);\n        assertEquals(combinedList, result);\n\n        assertThrows(NullPointerException.class, () -> FluentIterable.of(iterableOdd).collate(null).toList(),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testCollateWithComparator() {\n        List<Integer> result =\n                FluentIterable\n                    .of(iterableOdd)\n                    .collate(iterableEven, ComparatorUtils.<Integer>naturalComparator())\n                    .toList();\n\n        final List<Integer> combinedList = new ArrayList<>();\n        CollectionUtils.addAll(combinedList, iterableOdd);\n        CollectionUtils.addAll(combinedList, iterableEven);\n        Collections.sort(combinedList);\n        assertEquals(combinedList, result);\n\n        // null comparator is equivalent to natural ordering\n        result = FluentIterable.of(iterableOdd).collate(iterableEven, null).toList();\n        assertEquals(combinedList, result);\n    }\n\n    @Test\n    public void testContains() {\n        assertTrue(FluentIterable.of(iterableEven).contains(2));\n        assertFalse(FluentIterable.of(iterableEven).contains(1));\n        assertFalse(FluentIterable.of(iterableEven).contains(null));\n        assertTrue(FluentIterable.of(iterableEven).append((Integer) null).contains(null));\n    }\n\n    @Test\n    public void testCopyInto() {\n        List<Integer> result = new ArrayList<>();\n        FluentIterable.of(iterableA).copyInto(result);\n\n        List<Integer> expected = IterableUtils.toList(iterableA);\n        assertEquals(expected.size(), result.size());\n        assertEquals(expected, result);\n\n        result = new ArrayList<>();\n        result.add(10);\n        result.add(9);\n        result.add(8);\n        FluentIterable.of(iterableA).copyInto(result);\n\n        expected = new ArrayList<>(Arrays.asList(10, 9, 8));\n        expected.addAll(IterableUtils.toList(iterableA));\n        assertEquals(expected.size(), result.size());\n        assertEquals(expected, result);\n\n        assertThrows(NullPointerException.class, () -> FluentIterable.of(iterableA).copyInto(null),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testEval() {\n        final List<Integer> listNumbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n        final FluentIterable<Integer> iterable = FluentIterable.of(listNumbers).filter(EVEN);\n        final FluentIterable<Integer> materialized = iterable.eval();\n\n        listNumbers.addAll(Arrays.asList(11, 12, 13, 14, 15, 16, 17, 18, 19, 20));\n        assertEquals(5, materialized.size());\n        assertEquals(10, iterable.size());\n\n        assertEquals(Arrays.asList(2, 4, 6, 8, 10), materialized.toList());\n        assertEquals(Arrays.asList(2, 4, 6, 8, 10, 12, 14, 16, 18, 20), iterable.toList());\n    }\n\n    @Test\n    public void testFactoryMethodOf() {\n        FluentIterable<Integer> iterable = FluentIterable.of(1, 2, 3, 4, 5);\n        List<Integer> result = iterable.toList();\n        assertEquals(Arrays.asList(1, 2, 3, 4, 5), result);\n\n        iterable = FluentIterable.of(1);\n        assertEquals(1, iterable.size());\n        assertFalse(iterable.isEmpty());\n        assertEquals(Arrays.asList(1), iterable.toList());\n\n        result = FluentIterable.of(new Integer[0]).toList();\n        assertTrue(result.isEmpty());\n\n        final Iterable<Integer> it = null;\n        assertThrows(NullPointerException.class, () -> FluentIterable.of(it).toList(),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testFilter() {\n        final Predicate<Integer> smallerThan3 = object -> object.intValue() < 3;\n        List<Integer> result = FluentIterable.of(iterableA).filter(smallerThan3).toList();\n        assertEquals(3, result.size());\n        assertEquals(Arrays.asList(1, 2, 2), result);\n\n        // empty iterable\n        result = FluentIterable.of(emptyIterable).filter(smallerThan3).toList();\n        assertEquals(0, result.size());\n\n        assertThrows(NullPointerException.class, () -> FluentIterable.of(iterableA).filter(null).toList(),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testForEach() {\n        final AtomicInteger sum = new AtomicInteger();\n        final Closure<Integer> closure = sum::addAndGet;\n\n        FluentIterable.of(iterableA).forEach(closure);\n        int expectedSum = 0;\n        for (final Integer i : iterableA) {\n            expectedSum += i;\n        }\n        assertEquals(expectedSum, sum.get());\n\n        assertThrows(NullPointerException.class, () -> FluentIterable.of(iterableA).forEach((Closure<Integer>) null),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testGet() {\n        assertEquals(2, FluentIterable.of(iterableEven).get(0).intValue());\n\n        assertThrows(IndexOutOfBoundsException.class, () -> FluentIterable.of(iterableEven).get(-1),\n                \"expecting IndexOutOfBoundsException\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> FluentIterable.of(iterableEven).get(IterableUtils.size(iterableEven)),\n                \"expecting IndexOutOfBoundsException\");\n    }\n\n    @Test\n    public void testIsEmpty() {\n        assertTrue(FluentIterable.of(emptyIterable).isEmpty());\n        assertFalse(FluentIterable.of(iterableOdd).isEmpty());\n    }\n\n    @Test\n    public void testIterator() {\n        Iterator<Integer> iterator = FluentIterable.of(iterableA).iterator();\n        assertTrue(iterator.hasNext());\n\n        iterator = FluentIterable.<Integer>empty().iterator();\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testLimit() {\n        List<Integer> result = FluentIterable.of(iterableA).limit(3).toList();\n        assertEquals(3, result.size());\n        assertEquals(Arrays.asList(1, 2, 2), result);\n\n        // limit larger than input\n        result = FluentIterable.of(iterableA).limit(100).toList();\n        final List<Integer> expected = IterableUtils.toList(iterableA);\n        assertEquals(expected.size(), result.size());\n        assertEquals(expected, result);\n\n        // limit is 0\n        result = FluentIterable.of(iterableA).limit(0).toList();\n        assertEquals(0, result.size());\n\n        // empty iterable\n        result = FluentIterable.of(emptyIterable).limit(3).toList();\n        assertEquals(0, result.size());\n\n        assertThrows(IllegalArgumentException.class, () -> FluentIterable.of(iterableA).limit(-2).toList(),\n                \"expecting IllegalArgumentException\");\n    }\n\n    @Test\n    public void testReverse() {\n        List<Integer> result = FluentIterable.of(iterableA).reverse().toList();\n        final List<Integer> expected = IterableUtils.toList(iterableA);\n        Collections.reverse(expected);\n        assertEquals(expected, result);\n\n        // empty iterable\n        result = FluentIterable.of(emptyIterable).reverse().toList();\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testSize() {\n        assertEquals(0, FluentIterable.of(emptyIterable).size());\n        assertEquals(IterableUtils.toList(iterableOdd).size(), FluentIterable.of(iterableOdd).size());\n    }\n\n    @Test\n    public void testSkip() {\n        List<Integer> result = FluentIterable.of(iterableA).skip(4).toList();\n        assertEquals(6, result.size());\n        assertEquals(Arrays.asList(3, 3, 4, 4, 4, 4), result);\n\n        // skip larger than input\n        result = FluentIterable.of(iterableA).skip(100).toList();\n        assertEquals(0, result.size());\n\n        // skip 0 elements\n        result = FluentIterable.of(iterableA).skip(0).toList();\n        final List<Integer> expected = IterableUtils.toList(iterableA);\n        assertEquals(expected.size(), result.size());\n        assertEquals(expected, result);\n\n        // empty iterable\n        result = FluentIterable.of(emptyIterable).skip(3).toList();\n        assertEquals(0, result.size());\n\n        assertThrows(IllegalArgumentException.class, () -> FluentIterable.of(iterableA).skip(-4).toList(),\n                \"expecting IllegalArgumentException\");\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @Test\n    public void testToArray() {\n        final Long[] arr = {1L, 2L, 3L, 4L, 5L};\n        final Long[] result = FluentIterable.of(arr).toArray(Long.class);\n        assertNotNull(result);\n        assertArrayEquals(arr, result);\n\n        assertThrows(ArrayStoreException.class, () -> FluentIterable.of(arr).toArray((Class) String.class));\n    }\n\n    @Test\n    public void testToString() {\n        String result = FluentIterable.of(iterableA).toString();\n        assertEquals(iterableA.toString(), result);\n\n        result = FluentIterable.empty().toString();\n        assertEquals(\"[]\", result);\n    }\n\n    @Test\n    public void testTransform() {\n        final Transformer<Integer, Integer> squared = object -> object * object;\n        List<Integer> result = FluentIterable.of(iterableA).transform(squared).toList();\n        assertEquals(10, result.size());\n        assertEquals(Arrays.asList(1, 4, 4, 9, 9, 9, 16, 16, 16, 16), result);\n\n        // empty iterable\n        result = FluentIterable.of(emptyIterable).transform(squared).toList();\n        assertEquals(0, result.size());\n\n        assertThrows(NullPointerException.class, () -> FluentIterable.of(iterableA).transform(null).toList(),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testUnique() {\n        List<Integer> result = FluentIterable.of(iterableA).unique().toList();\n        assertEquals(4, result.size());\n        assertEquals(Arrays.asList(1, 2, 3, 4), result);\n\n        // empty iterable\n        result = FluentIterable.of(emptyIterable).unique().toList();\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        final FluentIterable<Integer> iterable1 = FluentIterable.of(iterableA).unmodifiable();\n        final Iterator<Integer> it = iterable1.iterator();\n        assertEquals(1, it.next().intValue());\n\n        assertThrows(UnsupportedOperationException.class, () -> it.remove(),\n                \"expecting UnsupportedOperationException\");\n\n        // calling unmodifiable on an already unmodifiable iterable shall return the same instance\n        final FluentIterable<Integer> iterable2 = iterable1.unmodifiable();\n        assertSame(iterable1, iterable2);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testZip() {\n        List<Integer> result = FluentIterable.of(iterableOdd).zip(iterableEven).toList();\n        List<Integer> combinedList = new ArrayList<>();\n        CollectionUtils.addAll(combinedList, iterableOdd);\n        CollectionUtils.addAll(combinedList, iterableEven);\n        Collections.sort(combinedList);\n        assertEquals(combinedList, result);\n\n        assertThrows(NullPointerException.class, () -> FluentIterable.of(iterableOdd).zip((Iterable<Integer>) null).toList(),\n                \"expecting NullPointerException\");\n\n        result = FluentIterable\n                    .of(Arrays.asList(1, 4, 7))\n                    .zip(Arrays.asList(2, 5, 8), Arrays.asList(3, 6, 9))\n                    .toList();\n        combinedList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n        assertEquals(combinedList, result);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Predicate<Number> EVEN = input -> input.intValue() % 2 == 0;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Predicate<Number>", "name": "EVEN = input -> input.intValue() % 2 == 0", "syntax_pass": true}, {"attribute_expression": "private Iterable<Integer> iterableA;", "docstring": "\nIterable of {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Integer>", "name": "iterableA", "syntax_pass": true}, {"attribute_expression": "private Iterable<Long> iterableB;", "docstring": "\nIterable of {@link Long}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Long>", "name": "iterableB", "syntax_pass": true}, {"attribute_expression": "private Iterable<Integer> iterableEven;", "docstring": "\nCollection of even {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Integer>", "name": "iterableEven", "syntax_pass": true}, {"attribute_expression": "private Iterable<Integer> iterableOdd;", "docstring": "\nCollection of odd {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Integer>", "name": "iterableOdd", "syntax_pass": true}, {"attribute_expression": "private Iterable<Integer> emptyIterable;", "docstring": "\nAn empty Iterable.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Integer>", "name": "emptyIterable", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_getIteratorTest.java.IteratorUtils_getIteratorTest", "name": "IteratorUtils_getIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_getIteratorTest.java", "superclasses": "", "methods": ["[void]testGetIterator_nullInput()", "[void]testGetIterator_iteratorInput()", "[void]testGetIterator_iterableInput()", "[void]testGetIterator_objectArrayInput()", "[void]testGetIterator_enumerationInput()", "[void]testGetIterator_mapInput()", "[void]testGetIterator_nodeListInput()", "[void]testGetIterator_nodeInput()", "[void]testGetIterator_dictionaryInput()", "[void]testGetIterator_arrayInput()", "[void]testGetIterator_objectWithIteratorMethodInput()", "[void]testGetIterator_singletonIteratorInput()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_getIteratorTest {\n\n    @Test\n    public void testGetIterator_nullInput() {\n        Iterator<?> iterator = IteratorUtils.getIterator(null);\n        assertTrue(!iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_iteratorInput() {\n        Iterator<String> inputIterator = Arrays.asList(\"a\", \"b\", \"c\").iterator();\n        Iterator<?> iterator = IteratorUtils.getIterator(inputIterator);\n        assertTrue(iterator == inputIterator);\n    }\n\n    @Test\n    public void testGetIterator_iterableInput() {\n        Iterable<String> iterable = Arrays.asList(\"a\", \"b\", \"c\");\n        Iterator<?> iterator = IteratorUtils.getIterator(iterable);\n        assertTrue(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_objectArrayInput() {\n        Object[] array = {\"a\", \"b\", \"c\"};\n        Iterator<?> iterator = IteratorUtils.getIterator(array);\n        assertTrue(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_enumerationInput() {\n        Vector<String> vector = new Vector<>(Arrays.asList(\"a\", \"b\", \"c\"));\n        Enumeration<String> enumeration = vector.elements();\n        Iterator<?> iterator = IteratorUtils.getIterator(enumeration);\n        assertTrue(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_mapInput() {\n        Map<String, String> map = new HashMap<>();\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        Iterator<?> iterator = IteratorUtils.getIterator(map);\n        assertTrue(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_nodeListInput() {\n        NodeList nodeList = new NodeList() {\n            @Override\n            public Node item(int index) {\n                return index < 3 ? new Node() {\n                    @Override\n                    public short getNodeType() {\n                        return 0;\n                    }\n\n                    @Override\n                    public String getNodeName() {\n                        return null;\n                    }\n\n                    @Override\n                    public String getNodeValue() throws DOMException {\n                        return null;\n                    }\n\n                    @Override\n                    public void setNodeValue(String nodeValue) throws DOMException {\n\n                    }\n\n                    @Override\n                    public Node getParentNode() {\n                        return null;\n                    }\n\n                    @Override\n                    public NodeList getChildNodes() {\n                        return null;\n                    }\n\n                    @Override\n                    public Node getFirstChild() {\n                        return null;\n                    }\n\n                    @Override\n                    public Node getLastChild() {\n                        return null;\n                    }\n\n                    @Override\n                    public Node getPreviousSibling() {\n                        return null;\n                    }\n\n                    @Override\n                    public Node getNextSibling() {\n                        return null;\n                    }\n\n                    @Override\n                    public NamedNodeMap getAttributes() {\n                        return null;\n                    }\n\n                    @Override\n                    public Document getOwnerDocument() {\n                        return null;\n                    }\n\n                    @Override\n                    public Node insertBefore(Node newChild, Node refChild) throws DOMException {\n                        return null;\n                    }\n\n                    @Override\n                    public Node replaceChild(Node newChild, Node oldChild) throws DOMException {\n                        return null;\n                    }\n\n                    @Override\n                    public Node removeChild(Node oldChild) throws DOMException {\n                        return null;\n                    }\n\n                    @Override\n                    public Node appendChild(Node newChild) throws DOMException {\n                        return null;\n                    }\n\n                    @Override\n                    public boolean hasChildNodes() {\n                        return false;\n                    }\n\n                    @Override\n                    public Node cloneNode(boolean deep) {\n                        return null;\n                    }\n\n                    @Override\n                    public void normalize() {\n\n                    }\n\n                    @Override\n                    public boolean isSupported(String feature, String version) {\n                        return false;\n                    }\n\n                    @Override\n                    public String getNamespaceURI() {\n                        return null;\n                    }\n\n                    @Override\n                    public String getPrefix() {\n                        return null;\n                    }\n\n                    @Override\n                    public void setPrefix(String prefix) throws DOMException {\n\n                    }\n\n                    @Override\n                    public String getLocalName() {\n                        return null;\n                    }\n\n                    @Override\n                    public boolean hasAttributes() {\n                        return false;\n                    }\n\n                    @Override\n                    public String getBaseURI() {\n                        return null;\n                    }\n\n                    @Override\n                    public short compareDocumentPosition(Node other) throws DOMException {\n                        return 0;\n                    }\n\n                    @Override\n                    public String getTextContent() throws DOMException {\n                        return null;\n                    }\n\n                    @Override\n                    public void setTextContent(String textContent) throws DOMException {\n\n                    }\n\n                    @Override\n                    public boolean isSameNode(Node other) {\n                        return false;\n                    }\n\n                    @Override\n                    public String lookupPrefix(String namespaceURI) {\n                        return null;\n                    }\n\n                    @Override\n                    public boolean isDefaultNamespace(String namespaceURI) {\n                        return false;\n                    }\n\n                    @Override\n                    public String lookupNamespaceURI(String prefix) {\n                        return null;\n                    }\n\n                    @Override\n                    public boolean isEqualNode(Node arg) {\n                        return false;\n                    }\n\n                    @Override\n                    public Object getFeature(String feature, String version) {\n                        return null;\n                    }\n\n                    @Override\n                    public Object setUserData(String key, Object data, UserDataHandler handler) {\n                        return null;\n                    }\n\n                    @Override\n                    public Object getUserData(String key) {\n                        return null;\n                    }\n                } : null;\n            }\n\n            @Override\n            public int getLength() {\n                return 3;\n            }\n        };\n        Iterator<?> iterator = IteratorUtils.getIterator(nodeList);\n        assertTrue(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_nodeInput() {\n        Node node = new Node() {\n            @Override\n            public short getNodeType() {\n                return 0;\n            }\n\n            @Override\n            public String getNodeName() {\n                return null;\n            }\n\n            @Override\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setNodeValue(String nodeValue) throws DOMException {\n\n            }\n\n            @Override\n            public Node getParentNode() {\n                return null;\n            }\n\n            @Override\n            public NodeList getChildNodes() {\n                return new NodeList() {\n                    @Override\n                    public Node item(int index) {\n                        return index < 3 ? new Node() {\n                            @Override\n                            public short getNodeType() {\n                                return 0;\n                            }\n\n                            @Override\n                            public String getNodeName() {\n                                return null;\n                            }\n\n                            @Override\n                            public String getNodeValue() throws DOMException {\n                                return null;\n                            }\n\n                            @Override\n                            public void setNodeValue(String nodeValue) throws DOMException {\n\n                            }\n\n                            @Override\n                            public Node getParentNode() {\n                                return null;\n                            }\n\n                            @Override\n                            public NodeList getChildNodes() {\n                                return null;\n                            }\n\n                            @Override\n                            public Node getFirstChild() {\n                                return null;\n                            }\n\n                            @Override\n                            public Node getLastChild() {\n                                return null;\n                            }\n\n                            @Override\n                            public Node getPreviousSibling() {\n                                return null;\n                            }\n\n                            @Override\n                            public Node getNextSibling() {\n                                return null;\n                            }\n\n                            @Override\n                            public NamedNodeMap getAttributes() {\n                                return null;\n                            }\n\n                            @Override\n                            public Document getOwnerDocument() {\n                                return null;\n                            }\n\n                            @Override\n                            public Node insertBefore(Node newChild, Node refChild) throws DOMException {\n                                return null;\n                            }\n\n                            @Override\n                            public Node replaceChild(Node newChild, Node oldChild) throws DOMException {\n                                return null;\n                            }\n\n                            @Override\n                            public Node removeChild(Node oldChild) throws DOMException {\n                                return null;\n                            }\n\n                            @Override\n                            public Node appendChild(Node newChild) throws DOMException {\n                                return null;\n                            }\n\n                            @Override\n                            public boolean hasChildNodes() {\n                                return false;\n                            }\n\n                            @Override\n                            public Node cloneNode(boolean deep) {\n                                return null;\n                            }\n\n                            @Override\n                            public void normalize() {\n\n                            }\n\n                            @Override\n                            public boolean isSupported(String feature, String version) {\n                                return false;\n                            }\n\n                            @Override\n                            public String getNamespaceURI() {\n                                return null;\n                            }\n\n                            @Override\n                            public String getPrefix() {\n                                return null;\n                            }\n\n                            @Override\n                            public void setPrefix(String prefix) throws DOMException {\n\n                            }\n\n                            @Override\n                            public String getLocalName() {\n                                return null;\n                            }\n\n                            @Override\n                            public boolean hasAttributes() {\n                                return false;\n                            }\n\n                            @Override\n                            public String getBaseURI() {\n                                return null;\n                            }\n\n                            @Override\n                            public short compareDocumentPosition(Node other) throws DOMException {\n                                return 0;\n                            }\n\n                            @Override\n                            public String getTextContent() throws DOMException {\n                                return null;\n                            }\n\n                            @Override\n                            public void setTextContent(String textContent) throws DOMException {\n\n                            }\n\n                            @Override\n                            public boolean isSameNode(Node other) {\n                                return false;\n                            }\n\n                            @Override\n                            public String lookupPrefix(String namespaceURI) {\n                                return null;\n                            }\n\n                            @Override\n                            public boolean isDefaultNamespace(String namespaceURI) {\n                                return false;\n                            }\n\n                            @Override\n                            public String lookupNamespaceURI(String prefix) {\n                                return null;\n                            }\n\n                            @Override\n                            public boolean isEqualNode(Node arg) {\n                                return false;\n                            }\n\n                            @Override\n                            public Object getFeature(String feature, String version) {\n                                return null;\n                            }\n\n                            @Override\n                            public Object setUserData(String key, Object data, UserDataHandler handler) {\n                                return null;\n                            }\n\n                            @Override\n                            public Object getUserData(String key) {\n                                return null;\n                            }\n                        } : null;\n                    }\n\n                    @Override\n                    public int getLength() {\n                        return 3;\n                    }\n                };\n            }\n\n            @Override\n            public Node getFirstChild() {\n                return null;\n            }\n\n            @Override\n            public Node getLastChild() {\n                return null;\n            }\n\n            @Override\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            @Override\n            public Node getNextSibling() {\n                return null;\n            }\n\n            @Override\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            @Override\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            @Override\n            public Node insertBefore(Node newChild, Node refChild) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Node replaceChild(Node newChild, Node oldChild) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Node removeChild(Node oldChild) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Node appendChild(Node newChild) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            @Override\n            public Node cloneNode(boolean deep) {\n                return null;\n            }\n\n            @Override\n            public void normalize() {\n\n            }\n\n            @Override\n            public boolean isSupported(String feature, String version) {\n                return false;\n            }\n\n            @Override\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            @Override\n            public String getPrefix() {\n                return null;\n            }\n\n            @Override\n            public void setPrefix(String prefix) throws DOMException {\n\n            }\n\n            @Override\n            public String getLocalName() {\n                return null;\n            }\n\n            @Override\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            @Override\n            public String getBaseURI() {\n                return null;\n            }\n\n            @Override\n            public short compareDocumentPosition(Node other) throws DOMException {\n                return 0;\n            }\n\n            @Override\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setTextContent(String textContent) throws DOMException {\n\n            }\n\n            @Override\n            public boolean isSameNode(Node other) {\n                return false;\n            }\n\n            @Override\n            public String lookupPrefix(String namespaceURI) {\n                return null;\n            }\n\n            @Override\n            public boolean isDefaultNamespace(String namespaceURI) {\n                return false;\n            }\n\n            @Override\n            public String lookupNamespaceURI(String prefix) {\n                return null;\n            }\n\n            @Override\n            public boolean isEqualNode(Node arg) {\n                return false;\n            }\n\n            @Override\n            public Object getFeature(String feature, String version) {\n                return null;\n            }\n\n            @Override\n            public Object setUserData(String key, Object data, UserDataHandler handler) {\n                return null;\n            }\n\n            @Override\n            public Object getUserData(String key) {\n                return null;\n            }\n        };\n        Iterator<?> iterator = IteratorUtils.getIterator(node);\n        assertTrue(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_dictionaryInput() {\n        Dictionary<String, String> dictionary = new Hashtable<>();\n        dictionary.put(\"key1\", \"value1\");\n        dictionary.put(\"key2\", \"value2\");\n        Iterator<?> iterator = IteratorUtils.getIterator(dictionary);\n        assertTrue(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_arrayInput() {\n        int[] array = {1, 2, 3};\n        Iterator<?> iterator = IteratorUtils.getIterator(array);\n        assertTrue(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_objectWithIteratorMethodInput() {\n        Object obj = new Object() {\n            public Iterator<String> iterator() {\n                return Arrays.asList(\"a\", \"b\", \"c\").iterator();\n            }\n        };\n        Iterator<?> iterator = IteratorUtils.getIterator(obj);\n        assertTrue(iterator.hasNext());\n    }\n\n    @Test\n    public void testGetIterator_singletonIteratorInput() {\n        Object obj = new Object();\n        Iterator<?> iterator = IteratorUtils.getIterator(obj);\n        assertTrue(iterator.hasNext());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/MultiSetUtilsTest.java.MultiSetUtilsTest", "name": "MultiSetUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/MultiSetUtilsTest.java", "superclasses": "", "methods": ["[void]testEmptyMultiSet()", "[void]testPredicatedMultiSet()", "[void]testSynchronizedMultiSet()", "[void]testUnmodifiableMultiSet()"], "method_uris": ["src/test/java/org/apache/commons/collections4/MultiSetUtilsTest.java.MultiSetUtilsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for MultiSetUtils.\n", "original_string": "public class MultiSetUtilsTest {\n\n    private String[] fullArray;\n    private MultiSet<String> multiSet;\n\n    @BeforeEach\n    public void setUp() {\n        fullArray = new String[]{\n            \"a\", \"a\", \"b\", \"c\", \"d\", \"d\", \"d\"\n        };\n        multiSet = new HashMultiSet<>(Arrays.asList(fullArray));\n    }\n\n    /**\n     * Tests {@link MultiSetUtils#emptyMultiSet()}.\n     */\n    @Test\n    public void testEmptyMultiSet() {\n        final MultiSet<Integer> empty = MultiSetUtils.emptyMultiSet();\n        assertEquals(0, empty.size());\n\n        assertThrows(UnsupportedOperationException.class, () -> empty.add(55),\n                \"Empty multi set must be read-only\");\n    }\n\n    /**\n     * Tests {@link MultiSetUtils#predicatedMultiSet(org.apache.commons.collections4.MultiSet, org.apache.commons.collections4.Predicate)}.\n     */\n    @Test\n    public void testPredicatedMultiSet() {\n        final Predicate<String> predicate = object -> object.length() == 1;\n        final MultiSet<String> predicated = MultiSetUtils.predicatedMultiSet(multiSet, predicate);\n        assertEquals(multiSet.size(), predicated.size());\n        assertEquals(multiSet.getCount(\"a\"), predicated.getCount(\"a\"));\n\n        assertThrows(NullPointerException.class, () -> MultiSetUtils.predicatedMultiSet(null, predicate),\n                \"Expecting NPE\");\n\n        assertThrows(NullPointerException.class, () -> MultiSetUtils.predicatedMultiSet(multiSet, null),\n                \"Expecting NPE\");\n\n        assertThrows(IllegalArgumentException.class, () -> MultiSetUtils.predicatedMultiSet(multiSet, object -> object.equals(\"a\")),\n                \"Predicate is violated for all elements not being 'a'\");\n    }\n\n    /**\n     * Tests {@link MultiSetUtils#unmodifiableMultiSet(org.apache.commons.collections4.MultiSet) ()}.\n     */\n    @Test\n    public void testSynchronizedMultiSet() {\n        final MultiSet<String> synced = MultiSetUtils.synchronizedMultiSet(multiSet);\n        assertEquals(multiSet, synced);\n        synced.add(\"a\"); // ensure adding works\n    }\n\n    /**\n     * Tests {@link MultiSetUtils#unmodifiableMultiSet(org.apache.commons.collections4.MultiSet) ()}.\n     */\n    @Test\n    public void testUnmodifiableMultiSet() {\n        final MultiSet<String> unmodifiable = MultiSetUtils.unmodifiableMultiSet(multiSet);\n        assertEquals(multiSet, unmodifiable);\n\n        assertThrows(UnsupportedOperationException.class, () -> unmodifiable.add(\"a\"),\n                \"Empty multi set must be read-only\");\n\n        assertThrows(NullPointerException.class, () -> MultiSetUtils.unmodifiableMultiSet(null),\n                \"Expecting NPE\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private String[] fullArray;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String[]", "name": "fullArray", "syntax_pass": true}, {"attribute_expression": "private MultiSet<String> multiSet;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MultiSet<String>", "name": "multiSet", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_chainedIteratorTest.java.IteratorUtils_chainedIteratorTest", "name": "IteratorUtils_chainedIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_chainedIteratorTest.java", "superclasses": "", "methods": ["[void]testChainedIterator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_chainedIteratorTest {\n\n    @Test\n    public void testChainedIterator() {\n        // Given\n        List<Integer> list1 = Arrays.asList(1, 2, 3);\n        List<Integer> list2 = Arrays.asList(4, 5, 6);\n        Iterator<Integer> iterator1 = list1.iterator();\n        Iterator<Integer> iterator2 = list2.iterator();\n\n        // When\n        Iterator<Integer> chainedIterator = IteratorUtils.chainedIterator(iterator1, iterator2);\n\n        // Then\n        assertTrue(chainedIterator.hasNext());\n        assertEquals(1, chainedIterator.next());\n        assertEquals(2, chainedIterator.next());\n        assertEquals(3, chainedIterator.next());\n        assertEquals(4, chainedIterator.next());\n        assertEquals(5, chainedIterator.next());\n        assertEquals(6, chainedIterator.next());\n        assertTrue(!chainedIterator.hasNext());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/SetUtilsTest.java.SetUtilsTest", "name": "SetUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/SetUtilsTest.java", "superclasses": "", "methods": ["[void]testDifference()", "[void]testDisjunction()", "[void]testEmptyIfNull()", "[void]testEquals()", "[void]testHashCode()", "[void]testHashSet()", "[void]testIntersection()", "[void]testNewIdentityHashSet()", "[void]testpredicatedSet()", "[void]testUnion()", "[void]testUnmodifiableSet()", "[void]testUnmodifiableSetWrap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/SetUtilsTest.java.SetUtilsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for SetUtils.\n", "original_string": "public class SetUtilsTest {\n\n    private Set<Integer> setA;\n    private Set<Integer> setB;\n\n    @BeforeEach\n    public void setUp() {\n        setA = new HashSet<>();\n        setA.add(1);\n        setA.add(2);\n        setA.add(3);\n        setA.add(4);\n        setA.add(5);\n\n        setB = new HashSet<>();\n        setB.add(3);\n        setB.add(4);\n        setB.add(5);\n        setB.add(6);\n        setB.add(7);\n    }\n\n    @Test\n    public void testDifference() {\n        final SetView<Integer> set = SetUtils.difference(setA, setB);\n        assertEquals(2, set.size());\n        assertTrue(set.contains(1));\n        assertTrue(set.contains(2));\n        for (final Integer i : setB) {\n            assertFalse(set.contains(i));\n        }\n\n        final Set<Integer> set2 = SetUtils.difference(setA, SetUtils.<Integer>emptySet());\n        assertEquals(setA, set2);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.difference(setA, null),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.difference(null, setA),\n                        \"Expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    public void testDisjunction() {\n        final SetView<Integer> set = SetUtils.disjunction(setA, setB);\n        assertEquals(4, set.size());\n        assertTrue(set.contains(1));\n        assertTrue(set.contains(2));\n        assertTrue(set.contains(6));\n        assertTrue(set.contains(7));\n        assertFalse(set.contains(3));\n        assertFalse(set.contains(4));\n        assertFalse(set.contains(5));\n\n        final Set<Integer> set2 = SetUtils.disjunction(setA, SetUtils.<Integer>emptySet());\n        assertEquals(setA, set2);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.disjunction(setA, null),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.disjunction(null, setA),\n                        \"Expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    public void testEmptyIfNull() {\n        assertTrue(SetUtils.emptyIfNull(null).isEmpty());\n\n        final Set<Long> set = new HashSet<>();\n        assertSame(set, SetUtils.emptyIfNull(set));\n    }\n\n    @Test\n    public void testEquals() {\n        final Collection<String> data = Arrays.asList(\"a\", \"b\", \"c\");\n\n        final Set<String> a = new HashSet<>(data);\n        final Set<String> b = new HashSet<>(data);\n\n        assertEquals(a, b);\n        assertTrue(SetUtils.isEqualSet(a, b));\n        a.clear();\n        assertFalse(SetUtils.isEqualSet(a, b));\n        assertFalse(SetUtils.isEqualSet(a, null));\n        assertFalse(SetUtils.isEqualSet(null, b));\n        assertTrue(SetUtils.isEqualSet(null, null));\n    }\n\n    @Test\n    public void testHashCode() {\n        final Collection<String> data = Arrays.asList(\"a\", \"b\", \"c\");\n\n        final Set<String> a = new HashSet<>(data);\n        final Set<String> b = new HashSet<>(data);\n\n        assertEquals(a.hashCode(), b.hashCode());\n        assertEquals(a.hashCode(), SetUtils.hashCodeForSet(a));\n        assertEquals(b.hashCode(), SetUtils.hashCodeForSet(b));\n        assertEquals(SetUtils.hashCodeForSet(a), SetUtils.hashCodeForSet(b));\n        a.clear();\n        assertNotEquals(SetUtils.hashCodeForSet(a), SetUtils.hashCodeForSet(b));\n        assertEquals(0, SetUtils.hashCodeForSet(null));\n    }\n\n    @Test\n    public void testHashSet() {\n        final Set<?> set1 = SetUtils.unmodifiableSet();\n        assertTrue(set1.isEmpty(), \"set is empty\");\n\n        final Set<Integer> set2 = SetUtils.hashSet(1, 2, 2, 3);\n        assertEquals(3, set2.size(), \"set has 3 elements\");\n        assertTrue(set2.contains(1), \"set contains 1\");\n        assertTrue(set2.contains(2), \"set contains 2\");\n        assertTrue(set2.contains(3), \"set contains 3\");\n\n        final Set<String> set3 = SetUtils.hashSet(\"1\", \"2\", \"2\", \"3\");\n        assertEquals(3, set3.size(), \"set has 3 elements\");\n        assertTrue(set3.contains(\"1\"), \"set contains 1\");\n        assertTrue(set3.contains(\"2\"), \"set contains 2\");\n        assertTrue(set3.contains(\"3\"), \"set contains 3\");\n\n        final Set<?> set4 = SetUtils.hashSet(null, null);\n        assertEquals(1, set4.size(), \"set has 1 element\");\n        assertTrue(set4.contains(null), \"set contains null\");\n\n        final Set<?> set5 = SetUtils.hashSet((Object[]) null);\n        assertNull(set5, \"set is null\");\n    }\n\n    @Test\n    public void testIntersection() {\n        final SetView<Integer> set = SetUtils.intersection(setA, setB);\n        assertEquals(3, set.size());\n        assertTrue(set.contains(3));\n        assertTrue(set.contains(4));\n        assertTrue(set.contains(5));\n        assertFalse(set.contains(1));\n        assertFalse(set.contains(2));\n        assertFalse(set.contains(6));\n        assertFalse(set.contains(7));\n\n        final Set<Integer> set2 = SetUtils.intersection(setA, SetUtils.<Integer>emptySet());\n        assertEquals(SetUtils.<Integer>emptySet(), set2);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.intersection(setA, null),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.intersection(null, setA),\n                        \"Expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    public void testNewIdentityHashSet() {\n        final Set<String> set = SetUtils.newIdentityHashSet();\n        final String a = new String(\"a\");\n        set.add(a);\n        set.add(new String(\"b\"));\n        set.add(a);\n\n        assertEquals(2, set.size());\n\n        set.add(new String(\"a\"));\n        assertEquals(3, set.size());\n\n        set.remove(a);\n        assertEquals(2, set.size());\n    }\n\n    @Test\n    public void testpredicatedSet() {\n        final Predicate<Object> predicate = String.class::isInstance;\n        final Set<Object> set = SetUtils.predicatedSet(new HashSet<>(), predicate);\n        assertInstanceOf(PredicatedSet.class, set, \"returned object should be a PredicatedSet\");\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.predicatedSet(new HashSet<>(), null),\n                        \"Expecting NullPointerException for null predicate.\"),\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.predicatedSet(null, predicate),\n                        \"Expecting NullPointerException for null set.\")\n        );\n    }\n\n    @Test\n    public void testUnion() {\n        final SetView<Integer> set = SetUtils.union(setA, setB);\n        assertEquals(7, set.size());\n        assertTrue(set.containsAll(setA));\n        assertTrue(set.containsAll(setB));\n\n        final Set<Integer> set2 = SetUtils.union(setA, SetUtils.<Integer>emptySet());\n        assertEquals(setA, set2);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.union(setA, null),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> SetUtils.union(null, setA),\n                        \"Expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    public void testUnmodifiableSet() {\n        final Set<?> set1 = SetUtils.unmodifiableSet();\n        assertTrue(set1.isEmpty(), \"set is empty\");\n\n        final Set<Integer> set2 = SetUtils.unmodifiableSet(1, 2, 2, 3);\n        assertEquals(3, set2.size(), \"set has 3 elements\");\n        assertTrue(set2.contains(1), \"set contains 1\");\n        assertTrue(set2.contains(2), \"set contains 2\");\n        assertTrue(set2.contains(3), \"set contains 3\");\n\n        final Set<String> set3 = SetUtils.unmodifiableSet(\"1\", \"2\", \"2\", \"3\");\n        assertEquals(3, set3.size(), \"set has 3 elements\");\n        assertTrue(set3.contains(\"1\"), \"set contains 1\");\n        assertTrue(set3.contains(\"2\"), \"set contains 2\");\n        assertTrue(set3.contains(\"3\"), \"set contains 3\");\n\n        final Set<?> set4 = SetUtils.unmodifiableSet(null, null);\n        assertEquals(1, set4.size(), \"set has 1 element\");\n        assertTrue(set4.contains(null), \"set contains null\");\n\n        final Set<?> set5 = SetUtils.unmodifiableSet((Object[]) null);\n        assertNull(set5, \"set is null\");\n    }\n\n    @Test\n    public void testUnmodifiableSetWrap() {\n        final Set<Integer> set1 = SetUtils.unmodifiableSet(1, 2, 2, 3);\n        final Set<Integer> set2 = SetUtils.unmodifiableSet(set1);\n        assertSame(set1, set2);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Set<Integer> setA;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Set<Integer>", "name": "setA", "syntax_pass": true}, {"attribute_expression": "private Set<Integer> setB;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Set<Integer>", "name": "setB", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/TransformerUtils_switchTransformerTest.java.TransformerUtils_switchTransformerTest", "name": "TransformerUtils_switchTransformerTest", "file_path": "src/test/java/org/apache/commons/collections4/TransformerUtils_switchTransformerTest.java", "superclasses": "", "methods": ["[void]testSwitchTransformerWithTruePredicate()", "[void]testSwitchTransformerWithFalsePredicate()", "[void]testSwitchTransformerWithEqualPredicate()", "[void]testSwitchTransformerWithExceptionTransformer()", "[void]testSwitchTransformerWithNullDefaultTransformer()", "[void]testSwitchTransformerWithNOPTransformer()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformerUtils_switchTransformerTest {\n\n    @Test\n    public void testSwitchTransformerWithTruePredicate() {\n        Predicate<String> truePredicate = TruePredicate.truePredicate();\n        Transformer<String, Integer> trueTransformer = ConstantTransformer.constantTransformer(1);\n        Transformer<String, Integer> falseTransformer = ConstantTransformer.constantTransformer(0);\n\n        Transformer<String, Integer> transformer = TransformerUtils.switchTransformer(truePredicate, trueTransformer, falseTransformer);\n\n        assertEquals(1, transformer.transform(\"anyInput\"));\n    }\n\n    @Test\n    public void testSwitchTransformerWithFalsePredicate() {\n        Predicate<String> falsePredicate = FalsePredicate.falsePredicate();\n        Transformer<String, Integer> trueTransformer = ConstantTransformer.constantTransformer(1);\n        Transformer<String, Integer> falseTransformer = ConstantTransformer.constantTransformer(0);\n\n        Transformer<String, Integer> transformer = TransformerUtils.switchTransformer(falsePredicate, trueTransformer, falseTransformer);\n\n        assertEquals(0, transformer.transform(\"anyInput\"));\n    }\n\n    @Test\n    public void testSwitchTransformerWithEqualPredicate() {\n        Predicate<String> equalPredicate = EqualPredicate.equalPredicate(\"match\");\n        Transformer<String, Integer> trueTransformer = ConstantTransformer.constantTransformer(1);\n        Transformer<String, Integer> falseTransformer = ConstantTransformer.constantTransformer(0);\n\n        Transformer<String, Integer> transformer = TransformerUtils.switchTransformer(equalPredicate, trueTransformer, falseTransformer);\n\n        assertEquals(1, transformer.transform(\"match\"));\n        assertEquals(0, transformer.transform(\"noMatch\"));\n    }\n\n    @Test\n    public void testSwitchTransformerWithExceptionTransformer() {\n        Predicate<String> truePredicate = TruePredicate.truePredicate();\n        Transformer<String, Integer> trueTransformer = ExceptionTransformer.exceptionTransformer();\n        Transformer<String, Integer> falseTransformer = ConstantTransformer.constantTransformer(0);\n\n        Transformer<String, Integer> transformer = TransformerUtils.switchTransformer(truePredicate, trueTransformer, falseTransformer);\n\n        assertThrows(FunctorException.class, () -> transformer.transform(\"anyInput\"));\n    }\n\n    @Test\n    public void testSwitchTransformerWithNullDefaultTransformer() {\n        Predicate<String> falsePredicate = FalsePredicate.falsePredicate();\n        Transformer<String, Integer> trueTransformer = ConstantTransformer.constantTransformer(1);\n        Transformer<String, Integer> falseTransformer = null;\n\n        Transformer<String, Integer> transformer = TransformerUtils.switchTransformer(falsePredicate, trueTransformer, falseTransformer);\n\n        assertNull(transformer.transform(\"anyInput\"));\n    }\n\n    @Test\n    public void testSwitchTransformerWithNOPTransformer() {\n        Predicate<String> truePredicate = TruePredicate.truePredicate();\n        Transformer<String, String> trueTransformer = NOPTransformer.nopTransformer();\n        Transformer<String, String> falseTransformer = StringValueTransformer.stringValueTransformer();\n\n        Transformer<String, String> transformer = TransformerUtils.switchTransformer(truePredicate, trueTransformer, falseTransformer);\n\n        assertEquals(\"anyInput\", transformer.transform(\"anyInput\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/PredicateUtilsTest.java.PredicateUtilsTest", "name": "PredicateUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/PredicateUtilsTest.java", "superclasses": "AbstractPredicateTest", "methods": ["[void]testAllPredicate()", "[void]testAllPredicateEx1()", "[void]testAllPredicateEx2()", "[void]testAllPredicateEx3()", "[void]testAllPredicateEx4()", "[void]testAllPredicateEx5()", "[void]testAllPredicateEx6()", "[void]testAndPredicate()", "[void]testAndPredicateEx()", "[void]testAnyPredicate()", "[void]testAnyPredicateEx1()", "[void]testAnyPredicateEx2()", "[void]testAnyPredicateEx3()", "[void]testAnyPredicateEx4()", "[void]testAnyPredicateEx5()", "[void]testAnyPredicateEx6()", "[void]testAsPredicateTransformer()", "[void]testAsPredicateTransformerEx1()", "[void]testAsPredicateTransformerEx2()", "[void]testEitherPredicate()", "[void]testEitherPredicateEx()", "[void]testExceptionPredicate()", "[void]testFalsePredicate()", "[void]testIdentityPredicate()", "[void]testInstanceOfPredicate()", "[void]testInvokerPredicate()", "[void]testInvokerPredicate2()", "[void]testInvokerPredicate2Ex1()", "[void]testInvokerPredicate2Ex2()", "[void]testInvokerPredicate2Ex3()", "[void]testInvokerPredicateEx1()", "[void]testInvokerPredicateEx2()", "[void]testInvokerPredicateEx3()", "[void]testIsNotNullPredicate()", "[void]testNeitherPredicate()", "[void]testNeitherPredicateEx()", "[void]testNonePredicate()", "[void]testNonePredicateEx1()", "[void]testNonePredicateEx2()", "[void]testNonePredicateEx3()", "[void]testNonePredicateEx4()", "[void]testNonePredicateEx5()", "[void]testNonePredicateEx6()", "[void]testNotPredicate()", "[void]testNotPredicateEx()", "[void]testNullIsExceptionPredicate()", "[void]testNullIsExceptionPredicateEx1()", "[void]testNullIsFalsePredicate()", "[void]testNullIsFalsePredicateEx1()", "[void]testNullIsTruePredicate()", "[void]testNullIsTruePredicateEx1()", "[void]testOnePredicate()", "[void]testOnePredicateEx1()", "[void]testOnePredicateEx2()", "[void]testOnePredicateEx3()", "[void]testOnePredicateEx4()", "[void]testOnePredicateEx5()", "[void]testOnePredicateEx6()", "[void]testOrPredicate()", "[void]testOrPredicateEx()", "[void]testSingletonPatternInSerialization()", "[void]testTransformedPredicate()", "[void]testTruePredicate()", "[void]testUniquePredicate()"], "method_uris": ["src/test/java/org/apache/commons/collections4/PredicateUtilsTest.java.PredicateUtilsTest.[Predicate<?>]generatePredicate()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the PredicateUtils class.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class PredicateUtilsTest extends AbstractPredicateTest {\n\n    @Override\n    protected Predicate<?> generatePredicate() {\n        return truePredicate();  //Just return something to satisfy super class.\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAllPredicate() {\n        assertPredicateTrue(AllPredicate.allPredicate(), null);\n        assertTrue(AllPredicate.allPredicate(truePredicate(), truePredicate(), truePredicate()).test(null));\n        assertFalse(AllPredicate.allPredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).test(null));\n        assertFalse(AllPredicate.allPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).test(null));\n        assertFalse(AllPredicate.allPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        final Collection<Predicate<Object>> coll = new ArrayList<>();\n        coll.add(TruePredicate.truePredicate());\n        coll.add(TruePredicate.truePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertTrue(AllPredicate.allPredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(TruePredicate.truePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertFalse(AllPredicate.allPredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertFalse(AllPredicate.allPredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        assertFalse(AllPredicate.allPredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        assertPredicateFalse(AllPredicate.allPredicate(coll), null);\n        coll.clear();\n        coll.add(TruePredicate.truePredicate());\n        assertPredicateTrue(AllPredicate.allPredicate(coll), null);\n        coll.clear();\n        assertPredicateTrue(AllPredicate.allPredicate(coll), null);\n    }\n\n    @Test\n    public void testAllPredicateEx1() {\n        assertThrows(NullPointerException.class, () -> AllPredicate.allPredicate((Predicate<Object>[]) null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAllPredicateEx2() {\n        assertThrows(NullPointerException.class, () -> AllPredicate.<Object>allPredicate(new Predicate[] { null }));\n    }\n\n    @Test\n    public void testAllPredicateEx3() {\n        assertThrows(NullPointerException.class, () -> AllPredicate.allPredicate(null, null));\n    }\n\n    @Test\n    public void testAllPredicateEx4() {\n        assertThrows(NullPointerException.class, () -> AllPredicate.allPredicate((Collection<Predicate<Object>>) null));\n    }\n\n    @Test\n    public void testAllPredicateEx5() {\n        AllPredicate.allPredicate(Collections.emptyList());\n    }\n\n    @Test\n    public void testAllPredicateEx6() {\n        final Collection<Predicate<Object>> coll = new ArrayList<>();\n        coll.add(null);\n        coll.add(null);\n        assertThrows(NullPointerException.class, () -> AllPredicate.allPredicate(coll));\n    }\n\n    @Test\n    public void testAndPredicate() {\n        assertTrue(PredicateUtils.andPredicate(truePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.andPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n    }\n\n    @Test\n    public void testAndPredicateEx() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.andPredicate(null, null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAnyPredicate() {\n        assertPredicateFalse(PredicateUtils.anyPredicate(), null);\n\n        assertTrue(PredicateUtils.anyPredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.anyPredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.anyPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.anyPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        final Collection<Predicate<Object>> coll = new ArrayList<>();\n        coll.add(TruePredicate.truePredicate());\n        coll.add(TruePredicate.truePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertTrue(PredicateUtils.anyPredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(TruePredicate.truePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertTrue(PredicateUtils.anyPredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertTrue(PredicateUtils.anyPredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        assertFalse(PredicateUtils.anyPredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        assertPredicateFalse(PredicateUtils.anyPredicate(coll), null);\n        coll.clear();\n        coll.add(TruePredicate.truePredicate());\n        assertPredicateTrue(PredicateUtils.anyPredicate(coll), null);\n        coll.clear();\n        assertPredicateFalse(PredicateUtils.anyPredicate(coll), null);\n    }\n\n    @Test\n    public void testAnyPredicateEx1() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.anyPredicate((Predicate<Object>[]) null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAnyPredicateEx2() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.anyPredicate(new Predicate[] {null}));\n    }\n\n    @Test\n    public void testAnyPredicateEx3() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.anyPredicate(null, null));\n    }\n\n    @Test\n    public void testAnyPredicateEx4() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.anyPredicate((Collection<Predicate<Object>>) null));\n    }\n\n    @Test\n    public void testAnyPredicateEx5() {\n        PredicateUtils.anyPredicate(Collections.emptyList());\n    }\n\n    @Test\n    public void testAnyPredicateEx6() {\n        final Collection<Predicate<Object>> coll = new ArrayList<>();\n        coll.add(null);\n        coll.add(null);\n        assertThrows(NullPointerException.class, () -> PredicateUtils.anyPredicate(coll));\n    }\n\n    @Test\n    public void testAsPredicateTransformer() {\n        assertFalse(PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(false));\n        assertTrue(PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(true));\n    }\n\n    @Test\n    public void testAsPredicateTransformerEx1() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.asPredicate(null));\n    }\n\n    @Test\n    public void testAsPredicateTransformerEx2() {\n        assertThrows(FunctorException.class, () -> PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(null));\n    }\n\n    @Test\n    public void testEitherPredicate() {\n        assertFalse(PredicateUtils.eitherPredicate(truePredicate(), truePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.eitherPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n    }\n\n    @Test\n    public void testEitherPredicateEx() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.eitherPredicate(null, null));\n    }\n\n    @Test\n    public void testExceptionPredicate() {\n        assertNotNull(PredicateUtils.exceptionPredicate());\n        assertSame(PredicateUtils.exceptionPredicate(), PredicateUtils.exceptionPredicate());\n\n        assertThrows(FunctorException.class, () -> PredicateUtils.exceptionPredicate().evaluate(null));\n\n        assertThrows(FunctorException.class, () -> PredicateUtils.exceptionPredicate().evaluate(cString));\n    }\n\n    @Test\n    public void testFalsePredicate() {\n        assertNotNull(FalsePredicate.falsePredicate());\n        assertSame(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate());\n        assertFalse(FalsePredicate.falsePredicate().evaluate(null));\n        assertFalse(FalsePredicate.falsePredicate().evaluate(cObject));\n        assertFalse(FalsePredicate.falsePredicate().evaluate(cString));\n        assertFalse(FalsePredicate.falsePredicate().evaluate(cInteger));\n    }\n\n    @Test\n    public void testIdentityPredicate() {\n        assertSame(nullPredicate(), PredicateUtils.identityPredicate(null));\n        assertNotNull(PredicateUtils.identityPredicate(6));\n        assertFalse(PredicateUtils.identityPredicate(6).evaluate(null));\n        assertFalse(PredicateUtils.<Object>identityPredicate(6).evaluate(cObject));\n        assertFalse(PredicateUtils.<Object>identityPredicate(6).evaluate(cString));\n        assertTrue(PredicateUtils.identityPredicate(6).evaluate(cInteger)); // Cannot use valueOf here\n        assertTrue(PredicateUtils.identityPredicate(cInteger).evaluate(cInteger));\n    }\n\n    @Test\n    public void testInstanceOfPredicate() {\n        assertNotNull(PredicateUtils.instanceofPredicate(String.class));\n        assertFalse(PredicateUtils.instanceofPredicate(String.class).evaluate(null));\n        assertFalse(PredicateUtils.instanceofPredicate(String.class).evaluate(cObject));\n        assertTrue(PredicateUtils.instanceofPredicate(String.class).evaluate(cString));\n        assertFalse(PredicateUtils.instanceofPredicate(String.class).evaluate(cInteger));\n    }\n\n    @Test\n    public void testInvokerPredicate() {\n        final List<Object> list = new ArrayList<>();\n        assertTrue(PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n        list.add(new Object());\n        assertFalse(PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n    }\n\n    @Test\n    public void testInvokerPredicate2() {\n        final List<String> list = new ArrayList<>();\n        assertFalse(PredicateUtils.invokerPredicate(\n                \"contains\", new Class[]{Object.class}, new Object[]{cString}).evaluate(list));\n        list.add(cString);\n        assertTrue(PredicateUtils.invokerPredicate(\n                \"contains\", new Class[]{Object.class}, new Object[]{cString}).evaluate(list));\n    }\n\n    @Test\n    public void testInvokerPredicate2Ex1() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.invokerPredicate(null, null, null));\n    }\n\n    @Test\n    public void testInvokerPredicate2Ex2() {\n        assertThrows(FunctorException.class, () -> PredicateUtils.\n                invokerPredicate(\"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(null));\n    }\n\n    @Test\n    public void testInvokerPredicate2Ex3() {\n        assertThrows(FunctorException.class, () -> PredicateUtils.invokerPredicate(\n                \"noSuchMethod\", new Class[] {Object.class}, new Object[] {cString}).evaluate(new Object()));\n    }\n\n    @Test\n    public void testInvokerPredicateEx1() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.invokerPredicate(null));\n    }\n\n    @Test\n    public void testInvokerPredicateEx2() {\n        assertThrows(FunctorException.class, () -> PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(null));\n    }\n\n    @Test\n    public void testInvokerPredicateEx3() {\n        assertThrows(FunctorException.class, () -> PredicateUtils.invokerPredicate(\"noSuchMethod\").evaluate(new Object()));\n    }\n\n    @Test\n    public void testIsNotNullPredicate() {\n        assertNotNull(PredicateUtils.notNullPredicate());\n        assertSame(PredicateUtils.notNullPredicate(), PredicateUtils.notNullPredicate());\n        assertFalse(PredicateUtils.notNullPredicate().evaluate(null));\n        assertTrue(PredicateUtils.notNullPredicate().evaluate(cObject));\n        assertTrue(PredicateUtils.notNullPredicate().evaluate(cString));\n        assertTrue(PredicateUtils.notNullPredicate().evaluate(cInteger));\n    }\n\n    @Test\n    public void testNeitherPredicate() {\n        assertFalse(PredicateUtils.neitherPredicate(truePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.neitherPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n    }\n\n    @Test\n    public void testNeitherPredicateEx() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.neitherPredicate(null, null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testNonePredicate() {\n        assertPredicateTrue(PredicateUtils.nonePredicate(), null);\n        assertFalse(PredicateUtils.nonePredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.nonePredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.nonePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.nonePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        final Collection<Predicate<Object>> coll = new ArrayList<>();\n        coll.add(TruePredicate.truePredicate());\n        coll.add(TruePredicate.truePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertFalse(PredicateUtils.nonePredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(TruePredicate.truePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertFalse(PredicateUtils.nonePredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertFalse(PredicateUtils.nonePredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        assertTrue(PredicateUtils.nonePredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        assertPredicateTrue(PredicateUtils.nonePredicate(coll), null);\n        coll.clear();\n        coll.add(TruePredicate.truePredicate());\n        assertPredicateFalse(PredicateUtils.nonePredicate(coll), null);\n        coll.clear();\n        assertPredicateTrue(PredicateUtils.nonePredicate(coll), null);\n    }\n\n    @Test\n    public void testNonePredicateEx1() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.nonePredicate((Predicate<Object>[]) null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testNonePredicateEx2() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.nonePredicate(new Predicate[] {null}));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testNonePredicateEx3() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.nonePredicate(null, null));\n    }\n\n    @Test\n    public void testNonePredicateEx4() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.nonePredicate((Collection<Predicate<Object>>) null));\n    }\n\n    @Test\n    public void testNonePredicateEx5() {\n        PredicateUtils.nonePredicate(Collections.emptyList());\n    }\n\n    @Test\n    public void testNonePredicateEx6() {\n        final Collection<Predicate<Object>> coll = new ArrayList<>();\n        coll.add(null);\n        coll.add(null);\n        assertThrows(NullPointerException.class, () -> PredicateUtils.nonePredicate(coll));\n    }\n\n    @Test\n    public void testNotPredicate() {\n        assertNotNull(PredicateUtils.notPredicate(TruePredicate.truePredicate()));\n        assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(cObject));\n        assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(cString));\n        assertFalse(PredicateUtils.notPredicate(truePredicate()).evaluate(cInteger));\n    }\n\n    @Test\n    public void testNotPredicateEx() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.notPredicate(null));\n    }\n\n    @Test\n    public void testNullIsExceptionPredicate() {\n        assertTrue(PredicateUtils.nullIsExceptionPredicate(truePredicate()).evaluate(new Object()));\n        assertThrows(FunctorException.class, () -> PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(null));\n    }\n\n    @Test\n    public void testNullIsExceptionPredicateEx1() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.nullIsExceptionPredicate(null));\n    }\n\n    @Test\n    public void testNullIsFalsePredicate() {\n        assertFalse(PredicateUtils.nullIsFalsePredicate(truePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.nullIsFalsePredicate(truePredicate()).evaluate(new Object()));\n        assertFalse(PredicateUtils.nullIsFalsePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n    }\n\n    @Test\n    public void testNullIsFalsePredicateEx1() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.nullIsFalsePredicate(null));\n    }\n\n    @Test\n    public void testNullIsTruePredicate() {\n        assertTrue(PredicateUtils.nullIsTruePredicate(truePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.nullIsTruePredicate(truePredicate()).evaluate(new Object()));\n        assertFalse(PredicateUtils.nullIsTruePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n    }\n\n    @Test\n    public void testNullIsTruePredicateEx1() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.nullIsTruePredicate(null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testOnePredicate() {\n        assertPredicateFalse(PredicateUtils.onePredicate((Predicate<Object>[]) new Predicate[] {}), null);\n        assertFalse(PredicateUtils.onePredicate(truePredicate(), truePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.onePredicate(truePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.onePredicate(truePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.onePredicate(FalsePredicate.falsePredicate(), truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.onePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.onePredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        final Collection<Predicate<Object>> coll = new ArrayList<>();\n        coll.add(TruePredicate.truePredicate());\n        coll.add(TruePredicate.truePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertFalse(PredicateUtils.onePredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(TruePredicate.truePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertFalse(PredicateUtils.onePredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(TruePredicate.truePredicate());\n        assertTrue(PredicateUtils.onePredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        coll.add(FalsePredicate.falsePredicate());\n        assertFalse(PredicateUtils.onePredicate(coll).evaluate(null));\n        coll.clear();\n        coll.add(FalsePredicate.falsePredicate());\n        assertPredicateFalse(PredicateUtils.onePredicate(coll), null);\n        coll.clear();\n        coll.add(TruePredicate.truePredicate());\n        assertPredicateTrue(PredicateUtils.onePredicate(coll), null);\n        coll.clear();\n        assertPredicateFalse(PredicateUtils.onePredicate(coll), null);\n    }\n\n    @Test\n    public void testOnePredicateEx1() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.onePredicate((Predicate<Object>[]) null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testOnePredicateEx2() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.onePredicate(new Predicate[] {null}));\n    }\n\n    @Test\n    public void testOnePredicateEx3() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.onePredicate(null, null));\n    }\n\n    @Test\n    public void testOnePredicateEx4() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.onePredicate((Collection<Predicate<Object>>) null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testOnePredicateEx5() {\n        PredicateUtils.onePredicate(Collections.EMPTY_LIST);\n    }\n\n    @Test\n    public void testOnePredicateEx6() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.onePredicate(Arrays.asList(null, null)));\n    }\n\n    @Test\n    public void testOrPredicate() {\n        assertTrue(PredicateUtils.orPredicate(truePredicate(), truePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.orPredicate(truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n        assertTrue(PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), truePredicate()).evaluate(null));\n        assertFalse(PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n    }\n\n    @Test\n    public void testOrPredicateEx() {\n        assertThrows(NullPointerException.class, () -> PredicateUtils.orPredicate(null, null));\n    }\n\n    /**\n     * Test that all Predicate singletons hold singleton pattern in\n     * serialization/deserialization process.\n     */\n    @Test\n    public void testSingletonPatternInSerialization() {\n        final Object[] singletons = {\n            ExceptionPredicate.INSTANCE,\n            FalsePredicate.INSTANCE,\n            NotNullPredicate.INSTANCE,\n            NullPredicate.INSTANCE,\n            TruePredicate.INSTANCE\n        };\n\n        for (final Object original : singletons) {\n            TestUtils.assertSameAfterSerialization(\n                    \"Singleton pattern broken for \" + original.getClass(),\n                    original\n            );\n        }\n    }\n\n    @Test\n    public void testTransformedPredicate() {\n        assertTrue(PredicateUtils.transformedPredicate(\n                TransformerUtils.nopTransformer(),\n                truePredicate()).evaluate(new Object()));\n\n        final Map<Object, Object> map = new HashMap<>();\n        map.put(Boolean.TRUE, \"Hello\");\n        final Transformer<Object, Object> t = TransformerUtils.mapTransformer(map);\n        final Predicate<Object> p = EqualPredicate.<Object>equalPredicate(\"Hello\");\n        assertFalse(PredicateUtils.transformedPredicate(t, p).evaluate(null));\n        assertTrue(PredicateUtils.transformedPredicate(t, p).evaluate(Boolean.TRUE));\n\n        assertThrows(NullPointerException.class, () -> PredicateUtils.transformedPredicate(null, null));\n    }\n\n    @Test\n    public void testTruePredicate() {\n        assertNotNull(TruePredicate.truePredicate());\n        assertSame(TruePredicate.truePredicate(), TruePredicate.truePredicate());\n        assertTrue(truePredicate().evaluate(null));\n        assertTrue(truePredicate().evaluate(cObject));\n        assertTrue(truePredicate().evaluate(cString));\n        assertTrue(truePredicate().evaluate(cInteger));\n    }\n\n    @Test\n    public void testUniquePredicate() {\n        final Predicate<Object> p = PredicateUtils.uniquePredicate();\n        assertTrue(p.evaluate(new Object()));\n        assertTrue(p.evaluate(new Object()));\n        assertTrue(p.evaluate(new Object()));\n        assertTrue(p.evaluate(cString));\n        assertFalse(p.evaluate(cString));\n        assertFalse(p.evaluate(cString));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/EnumerationUtilsTest.java.EnumerationUtilsTest", "name": "EnumerationUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/EnumerationUtilsTest.java", "superclasses": "", "methods": ["[void]testAsIterableFor()", "[void]testAsIterableForNull()", "[void]testGetFromEnumeration()", "[void]testToListWithHashtable()", "[void]testToListWithStringTokenizer()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests EnumerationUtils.\n", "original_string": "public class EnumerationUtilsTest {\n\n    public static final String TO_LIST_FIXTURE = \"this is a test\";\n\n    @Test\n    public void testAsIterableFor() {\n        final Vector<String> vector = new Vector<>();\n        vector.addElement(\"zero\");\n        vector.addElement(\"one\");\n        final Enumeration<String> en = vector.elements();\n        final Iterator<String> iterator = EnumerationUtils.asIterable(en).iterator();\n        assertTrue(iterator.hasNext());\n        assertEquals(\"zero\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"one\", iterator.next());\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testAsIterableForNull() {\n        assertThrows(NullPointerException.class, () -> EnumerationUtils.asIterable((Enumeration) null).iterator().next());\n    }\n\n    @Test\n    public void testGetFromEnumeration() throws Exception {\n        // Enumeration, entry exists\n        final Vector<String> vector = new Vector<>();\n        vector.addElement(\"zero\");\n        vector.addElement(\"one\");\n        Enumeration<String> en = vector.elements();\n        assertEquals(\"zero\", EnumerationUtils.get(en, 0));\n        en = vector.elements();\n        assertEquals(\"one\", EnumerationUtils.get(en, 1));\n\n        // Enumerator, non-existent entry\n        final Enumeration<String> finalEn = en;\n        assertThrows(IndexOutOfBoundsException.class, () -> EnumerationUtils.get(finalEn, 3));\n\n        assertFalse(en.hasMoreElements());\n    }\n\n    @Test\n    public void testToListWithHashtable() {\n        final Hashtable<String, Integer> expected = new Hashtable<>();\n        expected.put(\"one\", Integer.valueOf(1));\n        expected.put(\"two\", Integer.valueOf(2));\n        expected.put(\"three\", Integer.valueOf(3));\n        // validate elements.\n        final List<Integer> actualEltList = EnumerationUtils.toList(expected.elements());\n        assertEquals(expected.size(), actualEltList.size());\n        assertTrue(actualEltList.contains(Integer.valueOf(1)));\n        assertTrue(actualEltList.contains(Integer.valueOf(2)));\n        assertTrue(actualEltList.contains(Integer.valueOf(3)));\n        final List<Integer> expectedEltList = new ArrayList<>();\n        expectedEltList.add(Integer.valueOf(1));\n        expectedEltList.add(Integer.valueOf(2));\n        expectedEltList.add(Integer.valueOf(3));\n        assertTrue(actualEltList.containsAll(expectedEltList));\n\n        // validate keys.\n        final List<String> actualKeyList = EnumerationUtils.toList(expected.keys());\n        assertEquals(expected.size(), actualEltList.size());\n        assertTrue(actualKeyList.contains(\"one\"));\n        assertTrue(actualKeyList.contains(\"two\"));\n        assertTrue(actualKeyList.contains(\"three\"));\n        final List<String> expectedKeyList = new ArrayList<>();\n        expectedKeyList.add(\"one\");\n        expectedKeyList.add(\"two\");\n        expectedKeyList.add(\"three\");\n        assertTrue(actualKeyList.containsAll(expectedKeyList));\n    }\n\n    @Test\n    public void testToListWithStringTokenizer() {\n        final List<String> expectedList1 = new ArrayList<>();\n        final StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);\n        while (st.hasMoreTokens()) {\n            expectedList1.add(st.nextToken());\n        }\n        final List<String> expectedList2 = new ArrayList<>();\n        expectedList2.add(\"this\");\n        expectedList2.add(\"is\");\n        expectedList2.add(\"a\");\n        expectedList2.add(\"test\");\n        final List<String> actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));\n        assertEquals(expectedList1, expectedList2);\n        assertEquals(expectedList1, actualList);\n        assertEquals(expectedList2, actualList);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String TO_LIST_FIXTURE = \"this is a test\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TO_LIST_FIXTURE = \"this is a test\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_transformedIteratorTest.java.IteratorUtils_transformedIteratorTest", "name": "IteratorUtils_transformedIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_transformedIteratorTest.java", "superclasses": "", "methods": ["[void]testTransformedIterator_Success()", "[void]testTransformedIterator_NullIterator()", "[void]testTransformedIterator_NullTransformer()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_transformedIteratorTest {\n\n    @Test\n    public void testTransformedIterator_Success() {\n        Iterator<String> inputIterator = Arrays.asList(\"1\", \"2\", \"3\").iterator();\n        Transformer<String, Integer> transformer = new ConstantTransformer<>(1);\n\n        Iterator<Integer> result = IteratorUtils.transformedIterator(inputIterator, transformer);\n\n        assertNotNull(result);\n    }\n\n    @Test\n    public void testTransformedIterator_NullIterator() {\n        Transformer<String, Integer> transformer = new ConstantTransformer<>(1);\n\n        assertThrows(NullPointerException.class, () -> {\n            IteratorUtils.transformedIterator(null, transformer);\n        });\n    }\n\n    @Test\n    public void testTransformedIterator_NullTransformer() {\n        Iterator<String> inputIterator = Arrays.asList(\"1\", \"2\", \"3\").iterator();\n\n        assertThrows(NullPointerException.class, () -> {\n            IteratorUtils.transformedIterator(inputIterator, null);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/ListUtilsTest.java.ListUtilsTest", "name": "ListUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/ListUtilsTest.java", "superclasses": "", "methods": ["[void]testDefaultIfNull()", "[void]testEmptyIfNull()", "[void]testEquals()", "[void]testGetFirst()", "[void]testGetLast()", "[void]testHashCode()", "[void]testIndexOf()", "[void]testIntersectEmptyWithEmptyList()", "[void]testIntersectionOrderInsensitivity()", "[void]testIntersectListWithNoOverlapAndDifferentTypes()", "[void]testIntersectListWithSelf()", "[void]testIntersectNonEmptySubset()", "[void]testIntersectNonEmptyWithEmptyList()", "[void]testLazyFactoryList()", "[void]testLazyTransformerList()", "[void]testLongestCommonSubsequence()", "[void]testLongestCommonSubsequenceWithString()", "[void]testPartition()", "[void]testPredicatedList()", "[void]testRemoveAll()", "[void]testRetainAll()", "[void]testSelect()", "[void]testSelectRejected()", "[void]testSubtract()", "[void]testSubtractNullElement()", "[void]testSum()", "[void]testUnion()"], "method_uris": ["src/test/java/org/apache/commons/collections4/ListUtilsTest.java.ListUtilsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for ListUtils.\n", "original_string": "public class ListUtilsTest {\n\n    private static final String a = \"a\";\n    private static final String b = \"b\";\n    private static final String c = \"c\";\n    private static final String d = \"d\";\n    private static final String e = \"e\";\n    private static final String x = \"x\";\n\n    private static final Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;\n    private String[] fullArray;\n\n    private List<String> fullList;\n\n    @BeforeEach\n    public void setUp() {\n        fullArray = new String[]{a, b, c, d, e};\n        fullList = new ArrayList<>(Arrays.asList(fullArray));\n    }\n\n    @Test\n    public void testDefaultIfNull() {\n        assertTrue(ListUtils.defaultIfNull(null, Collections.emptyList()).isEmpty());\n\n        final List<Long> list = new ArrayList<>();\n        assertSame(list, ListUtils.defaultIfNull(list, Collections.<Long>emptyList()));\n    }\n\n    @Test\n    public void testEmptyIfNull() {\n        assertTrue(ListUtils.emptyIfNull(null).isEmpty());\n\n        final List<Long> list = new ArrayList<>();\n        assertSame(list, ListUtils.emptyIfNull(list));\n    }\n\n    @Test\n    public void testEquals() {\n        final Collection<String> data = Arrays.asList(\"a\", \"b\", \"c\");\n\n        final List<String> list1 = new ArrayList<>( data );\n        final List<String> list2 = new ArrayList<>( data );\n\n        assertEquals(list1, list2);\n        assertTrue(ListUtils.isEqualList(list1, list2));\n        list1.clear();\n        assertFalse(ListUtils.isEqualList(list1, list2));\n        assertFalse(ListUtils.isEqualList(list1, null));\n        assertFalse(ListUtils.isEqualList(null, list2));\n        assertTrue(ListUtils.isEqualList(null, null));\n\n        list2.clear();\n        list1.add(\"a\");\n        list2.add(\"b\");\n        assertFalse(ListUtils.isEqualList(list1, list2));\n\n        list1.add(\"b\");\n        list2.add(\"a\");\n        assertFalse(ListUtils.isEqualList(list1, list2));\n    }\n\n    @Test\n    public void testGetFirst() {\n        assertEquals(a, ListUtils.getFirst(fullList));\n        assertThrows(NullPointerException.class, () -> ListUtils.getFirst(null));\n        assertThrows(IndexOutOfBoundsException.class, () -> ListUtils.getFirst(new ArrayList<>()));\n    }\n\n    @Test\n    public void testGetLast() {\n        assertEquals(e, ListUtils.getLast(fullList));\n        assertThrows(NullPointerException.class, () -> ListUtils.getFirst(null));\n        assertThrows(IndexOutOfBoundsException.class, () -> ListUtils.getFirst(new ArrayList<>()));\n    }\n\n    @Test\n    public void testHashCode() {\n        final Collection<String> data = Arrays.asList(\"a\", \"b\", \"c\");\n\n        final List<String> list1 = new ArrayList<>(data);\n        final List<String> list2 = new ArrayList<>(data);\n\n        assertEquals(list1.hashCode(), list2.hashCode());\n        assertEquals(list1.hashCode(), ListUtils.hashCodeForList(list1));\n        assertEquals(list2.hashCode(), ListUtils.hashCodeForList(list2));\n        assertEquals(ListUtils.hashCodeForList(list1), ListUtils.hashCodeForList(list2));\n        list1.clear();\n        assertNotEquals(ListUtils.hashCodeForList(list1), ListUtils.hashCodeForList(list2));\n        assertEquals(0, ListUtils.hashCodeForList(null));\n\n        list1.add(null);\n        assertEquals(31, ListUtils.hashCodeForList(list1));\n    }\n\n    /**\n     * Tests the {@code indexOf} method in {@code ListUtils} class.\n     */\n    @Test\n    public void testIndexOf() {\n        Predicate<String> testPredicate = EqualPredicate.equalPredicate(\"d\");\n        int index = ListUtils.indexOf(fullList, testPredicate);\n        assertEquals(d, fullList.get(index));\n\n        testPredicate = EqualPredicate.equalPredicate(\"de\");\n        index = ListUtils.indexOf(fullList, testPredicate);\n        assertEquals(index, -1);\n\n        assertEquals(ListUtils.indexOf(null, testPredicate), -1);\n        assertEquals(ListUtils.indexOf(fullList, null), -1);\n    }\n\n    /**\n     * Tests intersecting a non-empty list with an empty list.\n     */\n    @Test\n    public void testIntersectEmptyWithEmptyList() {\n        final List<?> empty = Collections.EMPTY_LIST;\n        assertTrue(ListUtils.intersection(empty, empty).isEmpty(), \"result not empty\");\n    }\n\n    /**\n     * Tests intersecting two lists in different orders.\n     */\n    @Test\n    public void testIntersectionOrderInsensitivity() {\n        final List<String> one = new ArrayList<>();\n        final List<String> two = new ArrayList<>();\n        one.add(\"a\");\n        one.add(\"b\");\n        two.add(\"a\");\n        two.add(\"a\");\n        two.add(\"b\");\n        two.add(\"b\");\n        assertEquals(ListUtils.intersection(one, two), ListUtils.intersection(two, one));\n    }\n\n    /**\n     * Tests intersecting a non-empty list with a subset of itself.\n     */\n    @Test\n    public void testIntersectListWithNoOverlapAndDifferentTypes() {\n        @SuppressWarnings(\"boxing\")\n        final List<Integer> other = Arrays.asList(1, 23);\n        assertTrue(ListUtils.intersection(fullList, other).isEmpty());\n    }\n\n    /**\n     * Tests intersecting a non-empty list with itself.\n     */\n    @Test\n    public void testIntersectListWithSelf() {\n        assertEquals(fullList, ListUtils.intersection(fullList, fullList));\n    }\n\n    /**\n     * Tests intersecting a non-empty list with a subset of itself.\n     */\n    @Test\n    public void testIntersectNonEmptySubset() {\n        // create a copy\n        final List<String> other = new ArrayList<>(fullList);\n\n        // remove a few items\n        assertNotNull(other.remove(0));\n        assertNotNull(other.remove(1));\n\n        // make sure the intersection is equal to the copy\n        assertEquals(other, ListUtils.intersection(fullList, other));\n    }\n\n    /**\n     * Tests intersecting a non-empty list with an empty list.\n     */\n    @Test\n    public void testIntersectNonEmptyWithEmptyList() {\n        final List<String> empty = Collections.<String>emptyList();\n        assertTrue(ListUtils.intersection(empty, fullList).isEmpty(), \"result not empty\");\n    }\n\n    @Test\n    public void testLazyFactoryList() {\n        final List<Integer> list = ListUtils.lazyList(new ArrayList<>(), new Factory<Integer>() {\n\n            private int index;\n\n            @Override\n            public Integer create() {\n                index++;\n                return Integer.valueOf(index);\n            }\n        });\n\n        assertNotNull(list.get(5));\n        assertEquals(6, list.size());\n\n        assertNotNull(list.get(5));\n        assertEquals(6, list.size());\n    }\n\n    @Test\n    public void testLazyTransformerList() {\n        final List<Integer> offsets = Arrays.asList(3, 5, 1, 5, 3, 6);\n        final List<Integer> list = ListUtils.lazyList(new ArrayList<>(), new Transformer<Integer, Integer>() {\n\n            private int index;\n\n            @Override\n            public Integer transform(final Integer input) {\n                return offsets.get(input) + index++;\n            }\n\n        });\n\n        assertNotNull(list.get(5));\n        assertEquals(6, list.size());\n\n        assertNotNull(list.get(5));\n        assertEquals(6, list.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testLongestCommonSubsequence() {\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ListUtils.longestCommonSubsequence((List<?>) null, null),\n                        \"failed to check for null argument\"),\n                () -> assertThrows(NullPointerException.class, () -> ListUtils.longestCommonSubsequence(Arrays.asList('A'), null),\n                        \"failed to check for null argument\"),\n                () -> assertThrows(NullPointerException.class, () -> ListUtils.longestCommonSubsequence(null, Arrays.asList('A')),\n                        \"failed to check for null argument\")\n        );\n\n        @SuppressWarnings(\"unchecked\")\n        List<Character> lcs = ListUtils.longestCommonSubsequence(Collections.EMPTY_LIST, Collections.EMPTY_LIST);\n        assertEquals(0, lcs.size());\n\n        final List<Character> list1 = Arrays.asList('B', 'A', 'N', 'A', 'N', 'A');\n        final List<Character> list2 = Arrays.asList('A', 'N', 'A', 'N', 'A', 'S');\n        lcs = ListUtils.longestCommonSubsequence(list1, list2);\n\n        List<Character> expected = Arrays.asList('A', 'N', 'A', 'N', 'A');\n        assertEquals(expected, lcs);\n\n        final List<Character> list3 = Arrays.asList('A', 'T', 'A', 'N', 'A');\n        lcs = ListUtils.longestCommonSubsequence(list1, list3);\n\n        expected = Arrays.asList('A', 'A', 'N', 'A');\n        assertEquals(expected, lcs);\n\n        final List<Character> listZorro = Arrays.asList('Z', 'O', 'R', 'R', 'O');\n        lcs = ListUtils.longestCommonSubsequence(list1, listZorro);\n\n        assertTrue(lcs.isEmpty());\n    }\n\n    @Test\n    public void testLongestCommonSubsequenceWithString() {\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ListUtils.longestCommonSubsequence((String) null, null),\n                        \"failed to check for null argument\"),\n                () -> assertThrows(NullPointerException.class, () -> ListUtils.longestCommonSubsequence(\"A\", null),\n                        \"failed to check for null argument\"),\n                () -> assertThrows(NullPointerException.class, () -> ListUtils.longestCommonSubsequence(null, \"A\"),\n                        \"failed to check for null argument\")\n        );\n\n        String lcs = ListUtils.longestCommonSubsequence(StringUtils.EMPTY, StringUtils.EMPTY);\n        assertEquals(0, lcs.length());\n\n        final String banana = \"BANANA\";\n        final String ananas = \"ANANAS\";\n        lcs = ListUtils.longestCommonSubsequence(banana, ananas);\n\n        assertEquals(\"ANANA\", lcs);\n\n        final String atana = \"ATANA\";\n        lcs = ListUtils.longestCommonSubsequence(banana, atana);\n\n        assertEquals(\"AANA\", lcs);\n\n        final String zorro = \"ZORRO\";\n        lcs = ListUtils.longestCommonSubsequence(banana, zorro);\n\n        assertEquals(0, lcs.length());\n    }\n\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testPartition() {\n        final List<Integer> strings = new ArrayList<>();\n        for (int i = 0; i <= 6; i++) {\n            strings.add(i);\n        }\n\n        final List<List<Integer>> partition = ListUtils.partition(strings, 3);\n\n        assertNotNull(partition);\n        assertEquals(3, partition.size());\n        assertEquals(1, partition.get(2).size());\n        assertAll(\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> partition.get(-1),\n                        \"Index -1 must not be negative\"),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> partition.get(3),\n                        \"Index \" + 3 + \" must be less than size \" + partition.size())\n        );\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ListUtils.partition(null, 3),\n                        \"failed to check for null argument\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> ListUtils.partition(strings, 0),\n                        \"failed to check for size argument\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> ListUtils.partition(strings, -10),\n                        \"failed to check for size argument\")\n        );\n\n        final List<List<Integer>> partitionMax = ListUtils.partition(strings, Integer.MAX_VALUE);\n        assertEquals(1, partitionMax.size());\n        assertEquals(strings.size(), partitionMax.get(0).size());\n        assertEquals(strings, partitionMax.get(0));\n    }\n\n    @Test\n    public void testPredicatedList() {\n        final Predicate<Object> predicate = String.class::isInstance;\n        final List<Object> list = ListUtils.predicatedList(new ArrayList<>(), predicate);\n        assertInstanceOf(PredicatedList.class, list, \"returned object should be a PredicatedList\");\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ListUtils.predicatedList(new ArrayList<>(), null),\n                        \"Expecting IllegalArgumentException for null predicate.\"),\n                () -> assertThrows(NullPointerException.class, () -> ListUtils.predicatedList(null, predicate),\n                        \"Expecting IllegalArgumentException for null list.\")\n        );\n    }\n\n    @Test\n    public void testRemoveAll() {\n        final List<String> sub = new ArrayList<>();\n        sub.add(a);\n        sub.add(b);\n        sub.add(x);\n\n        final List<String> remainder = ListUtils.removeAll(fullList, sub);\n        assertEquals(3, remainder.size());\n        fullList.removeAll(sub);\n        assertEquals(remainder, fullList);\n\n        assertThrows(NullPointerException.class, () -> ListUtils.removeAll(null, null),\n                \"expecting NullPointerException\");\n\n        assertThrows(NullPointerException.class, () -> ListUtils.removeAll(null, new ArrayList<>()),\n                \"expecting NullPointerException\");\n\n        assertThrows(NullPointerException.class, () -> ListUtils.removeAll(new ArrayList<>(), null),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testRetainAll() {\n        final List<String> sub = new ArrayList<>();\n        sub.add(a);\n        sub.add(b);\n        sub.add(x);\n\n        final List<String> retained = ListUtils.retainAll(fullList, sub);\n        assertEquals(2, retained.size());\n        sub.remove(x);\n        assertEquals(retained, sub);\n        fullList.retainAll(sub);\n        assertEquals(retained, fullList);\n\n        assertThrows(NullPointerException.class, () -> ListUtils.retainAll(null, null),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testSelect() {\n        final List<Integer> list = new ArrayList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        // Ensure that the collection is the input type or a super type\n        final List<Integer> output1 = ListUtils.select(list, EQUALS_TWO);\n        final List<Number> output2 = ListUtils.<Number>select(list, EQUALS_TWO);\n        final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<>());\n        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n        assertEquals(4, list.size());\n        assertEquals(1, output1.size());\n        assertEquals(2, output2.iterator().next());\n    }\n\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testSelectRejected() {\n        final List<Long> list = new ArrayList<>();\n        list.add(1L);\n        list.add(2L);\n        list.add(3L);\n        list.add(4L);\n        final List<Long> output1 = ListUtils.selectRejected(list, EQUALS_TWO);\n        final List<? extends Number> output2 = ListUtils.selectRejected(list, EQUALS_TWO);\n        final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<>());\n        assertTrue(CollectionUtils.isEqualCollection(output1, output2));\n        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n        assertEquals(4, list.size());\n        assertEquals(3, output1.size());\n        assertTrue(output1.contains(1L));\n        assertTrue(output1.contains(3L));\n        assertTrue(output1.contains(4L));\n    }\n\n    @Test\n    public void testSubtract() {\n        final List<String> list = new ArrayList<>();\n        list.add(a);\n        list.add(b);\n        list.add(a);\n        list.add(x);\n\n        final List<String> sub = new ArrayList<>();\n        sub.add(a);\n\n        final List<String> result = ListUtils.subtract(list, sub);\n        assertEquals(3, result.size());\n\n        final List<String> expected = new ArrayList<>();\n        expected.add(b);\n        expected.add(a);\n        expected.add(x);\n\n        assertEquals(expected, result);\n\n        assertThrows(NullPointerException.class, () -> ListUtils.subtract(list, null),\n                \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testSubtractNullElement() {\n        final List<String> list = new ArrayList<>();\n        list.add(a);\n        list.add(null);\n        list.add(null);\n        list.add(x);\n\n        final List<String> sub = new ArrayList<>();\n        sub.add(null);\n\n        final List<String> result = ListUtils.subtract(list, sub);\n        assertEquals(3, result.size());\n\n        final List<String> expected = new ArrayList<>();\n        expected.add(a);\n        expected.add(null);\n        expected.add(x);\n\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSum() {\n        final List<String> list1 = new ArrayList<>();\n        list1.add(a);\n        final List<String> list2 = new ArrayList<>();\n        list2.add(b);\n        final List<String> expected1 = new ArrayList<>();\n        expected1.add(a);\n        expected1.add(b);\n        final List<String> result1 = ListUtils.sum(list1, list2);\n        assertEquals(2, result1.size());\n        assertEquals(expected1, result1);\n    }\n\n    @Test\n    public void testUnion() {\n        final List<String> list1 = new ArrayList<>();\n        list1.add(a);\n        final List<String> list2 = new ArrayList<>();\n        list2.add(b);\n        final List<String> result1 = ListUtils.union(list1, list2);\n        final List<String> expected1 = new ArrayList<>();\n        expected1.add(a);\n        expected1.add(b);\n        assertEquals(2, result1.size());\n        assertEquals(expected1, result1);\n\n        final List<String> list3 = new ArrayList<>();\n        list3.add(a);\n        final List<String> result2 = ListUtils.union(list1, list3);\n        final List<String> expected2 = new ArrayList<>();\n        expected2.add(a);\n        expected2.add(a);\n        assertEquals(2, result1.size());\n        assertEquals(expected2, result2);\n\n        list1.add(null);\n        final List<String> result3 = ListUtils.union(list1, list2);\n        final List<String> expected3 = new ArrayList<>();\n        expected3.add(a);\n        expected3.add(null);\n        expected3.add(b);\n        assertEquals(3, result3.size());\n        assertEquals(expected3, result3);\n\n        list2.add(null);\n        final List<String> result4 = ListUtils.union(list1, list2);\n        final List<String> expected4 = new ArrayList<>();\n        expected4.add(a);\n        expected4.add(null);\n        expected4.add(b);\n        expected4.add(null);\n        assertEquals(4, result4.size());\n        assertEquals(expected4, result4);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String a = \"a\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "a = \"a\"", "syntax_pass": true}, {"attribute_expression": "private static final String b = \"b\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "b = \"b\"", "syntax_pass": true}, {"attribute_expression": "private static final String c = \"c\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "c = \"c\"", "syntax_pass": true}, {"attribute_expression": "private static final String d = \"d\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "d = \"d\"", "syntax_pass": true}, {"attribute_expression": "private static final String e = \"e\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "e = \"e\"", "syntax_pass": true}, {"attribute_expression": "private static final String x = \"x\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "x = \"x\"", "syntax_pass": true}, {"attribute_expression": "private static final Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Predicate<Number>", "name": "EQUALS_TWO = input -> input.intValue() == 2", "syntax_pass": true}, {"attribute_expression": "private String[] fullArray;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String[]", "name": "fullArray", "syntax_pass": true}, {"attribute_expression": "private List<String> fullList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "fullList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/IteratorUtils_findTest.java.IteratorUtils_findTest", "name": "IteratorUtils_findTest", "file_path": "src/test/java/org/apache/commons/collections4/IteratorUtils_findTest.java", "superclasses": "", "methods": ["[void]testFind_ElementFound()", "[void]testFind_ElementNotFound()", "[void]testFind_NullIterator()", "[void]testFind_NullPredicate()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorUtils_findTest {\n\n    @Test\n    public void testFind_ElementFound() {\n        Iterator<Integer> iterator = Arrays.asList(1, 2, 3, 4).iterator();\n        Predicate<Integer> predicate = e -> e == 3;\n\n        Integer result = IteratorUtils.find(iterator, predicate::test);\n\n        assertEquals(3, result);\n    }\n\n    @Test\n    public void testFind_ElementNotFound() {\n        Iterator<Integer> iterator = Arrays.asList(1, 2, 3, 4).iterator();\n        Predicate<Integer> predicate = e -> e == 5;\n\n        Integer result = IteratorUtils.find(iterator, predicate::test);\n\n        assertNull(result);\n    }\n\n    @Test\n    public void testFind_NullIterator() {\n        Predicate<Integer> predicate = e -> e == 3;\n\n        Integer result = IteratorUtils.find(null, predicate::test);\n\n        assertNull(result);\n    }\n\n    @Test\n    public void testFind_NullPredicate() {\n        Iterator<Integer> iterator = Arrays.asList(1, 2, 3, 4).iterator();\n\n        assertThrows(NullPointerException.class, () -> {\n            IteratorUtils.find(iterator, null);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/ComparatorUtils_chainedComparatorTest.java.ComparatorUtils_chainedComparatorTest", "name": "ComparatorUtils_chainedComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/ComparatorUtils_chainedComparatorTest.java", "superclasses": "", "methods": ["[void]testChainedComparatorWithValidComparators()", "[void]testChainedComparatorWithNullComparator()", "[void]testChainedComparatorWithEmptyComparators()", "[void]testChainedComparatorWithSingleComparator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ComparatorUtils_chainedComparatorTest {\n\n    @Test\n    public void testChainedComparatorWithValidComparators() {\n        Comparator<Integer> comparator1 = Comparator.naturalOrder();\n        Comparator<Integer> comparator2 = Comparator.reverseOrder();\n\n        Comparator<Integer> chainedComparator = ComparatorUtils.chainedComparator(comparator1, comparator2);\n\n        assertTrue(chainedComparator instanceof ComparatorChain);\n        assertEquals(-1, chainedComparator.compare(1, 2));\n        assertEquals(1, chainedComparator.compare(2, 1));\n    }\n\n    @Test\n    public void testChainedComparatorWithNullComparator() {\n        Comparator<Integer> comparator1 = Comparator.naturalOrder();\n        Comparator<Integer> nullComparator = null;\n\n        assertThrows(NullPointerException.class, () -> {\n            ComparatorUtils.chainedComparator(comparator1, nullComparator);\n        });\n    }\n\n    @Test\n    public void testChainedComparatorWithEmptyComparators() {\n        Comparator<Integer>[] emptyComparators = new Comparator[0];\n\n        Comparator<Integer> chainedComparator = ComparatorUtils.chainedComparator(emptyComparators);\n\n        assertTrue(chainedComparator instanceof ComparatorChain);\n    }\n\n    @Test\n    public void testChainedComparatorWithSingleComparator() {\n        Comparator<Integer> comparator1 = Comparator.naturalOrder();\n\n        Comparator<Integer> chainedComparator = ComparatorUtils.chainedComparator(comparator1);\n\n        assertTrue(chainedComparator instanceof ComparatorChain);\n        assertEquals(-1, chainedComparator.compare(1, 2));\n        assertEquals(1, chainedComparator.compare(2, 1));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/ArrayStack_searchTest.java.ArrayStack_searchTest", "name": "ArrayStack_searchTest", "file_path": "src/test/java/org/apache/commons/collections4/ArrayStack_searchTest.java", "superclasses": "", "methods": ["[void]testSearchTopItem()", "[void]testSearchMiddleItem()", "[void]testSearchBottomItem()", "[void]testSearchMissingItem()", "[void]testSearchEmptyStack()", "[void]testSearchNullItem()", "[void]testSearchNullInEmptyStack()", "[void]testSearchAfterPop()", "[void]testSearchAfterMultiplePops()", "[void]testSearchAfterPushAndPop()"], "method_uris": ["src/test/java/org/apache/commons/collections4/ArrayStack_searchTest.java.ArrayStack_searchTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ArrayStack_searchTest {\n\n    private ArrayStack<String> stack;\n\n    @BeforeEach\n    public void setUp() {\n        stack = new ArrayStack<>(3);\n    }\n\n    @Test\n    public void testSearchTopItem() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        assertEquals(1, stack.search(\"Second Item\"), \"Top item is 'Second Item'\");\n    }\n\n    @Test\n    public void testSearchMiddleItem() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        stack.push(\"Third Item\");\n        assertEquals(2, stack.search(\"Second Item\"), \"Middle item is 'Second Item'\");\n    }\n\n    @Test\n    public void testSearchBottomItem() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        stack.push(\"Third Item\");\n        assertEquals(3, stack.search(\"First Item\"), \"Bottom item is 'First Item'\");\n    }\n\n    @Test\n    public void testSearchMissingItem() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        assertEquals(-1, stack.search(\"Missing Item\"), \"Cannot find 'Missing Item'\");\n    }\n\n    @Test\n    public void testSearchEmptyStack() {\n        assertEquals(-1, stack.search(\"Any Item\"), \"Stack is empty, cannot find any item\");\n    }\n\n    @Test\n    public void testSearchNullItem() {\n        stack.push(\"First Item\");\n        stack.push(null);\n        assertEquals(1, stack.search(null), \"Top item is null\");\n    }\n\n    @Test\n    public void testSearchNullInEmptyStack() {\n        assertEquals(-1, stack.search(null), \"Stack is empty, cannot find null\");\n    }\n\n    @Test\n    public void testSearchAfterPop() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        stack.pop();\n        assertEquals(1, stack.search(\"First Item\"), \"Top item is 'First Item' after pop\");\n    }\n\n    @Test\n    public void testSearchAfterMultiplePops() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        stack.push(\"Third Item\");\n        stack.pop();\n        stack.pop();\n        assertEquals(1, stack.search(\"First Item\"), \"Top item is 'First Item' after multiple pops\");\n    }\n\n    @Test\n    public void testSearchAfterPushAndPop() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        stack.pop();\n        stack.push(\"Third Item\");\n        assertEquals(2, stack.search(\"First Item\"), \"Middle item is 'First Item' after push and pop\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ArrayStack<String> stack;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayStack<String>", "name": "stack", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/TrieUtilsTest.java.TrieUtilsTest", "name": "TrieUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/TrieUtilsTest.java", "superclasses": "", "methods": ["[void]testUnmodifiableTrie()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests for TrieUtils factory methods.\n", "original_string": "public class TrieUtilsTest {\n\n    @Test\n    public void testUnmodifiableTrie() {\n        final Trie<String, Object> trie = TrieUtils.unmodifiableTrie(new PatriciaTrie<>());\n        assertInstanceOf(UnmodifiableTrie.class, trie, \"Returned object should be an UnmodifiableTrie.\");\n\n        assertThrows(NullPointerException.class, () -> TrieUtils.unmodifiableTrie(null));\n\n        assertSame(trie, TrieUtils.unmodifiableTrie(trie), \"UnmodifiableTrie shall not be decorated\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/ComparatorUtils_minTest.java.ComparatorUtils_minTest", "name": "ComparatorUtils_minTest", "file_path": "src/test/java/org/apache/commons/collections4/ComparatorUtils_minTest.java", "superclasses": "", "methods": ["[void]testMinWithDefaultComparator()", "[void]testMinWithCustomComparator()", "[void]testMinWithEqualObjects()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ComparatorUtils_minTest {\n\n    @Test\n    public void testMinWithDefaultComparator() {\n        Integer o1 = 5;\n        Integer o2 = 10;\n        Integer result = ComparatorUtils.min(o1, o2, null);\n        assertEquals(o1, result);\n    }\n\n    @Test\n    public void testMinWithCustomComparator() {\n        Integer o1 = 5;\n        Integer o2 = 10;\n        Comparator<Integer> customComparator = Comparator.reverseOrder();\n        Integer result = ComparatorUtils.min(o1, o2, customComparator);\n        assertEquals(o2, result);\n    }\n\n    @Test\n    public void testMinWithEqualObjects() {\n        Integer o1 = 5;\n        Integer o2 = 5;\n        Integer result = ComparatorUtils.min(o1, o2, null);\n        assertEquals(o2, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/IterableUtilsTest.java.IterableUtilsTest", "name": "IterableUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/IterableUtilsTest.java", "superclasses": "", "methods": ["[void]testContainsWithEquator()", "[void]testCountMatches()", "[void]testDuplicateListAllSameInList()", "[void]testDuplicateListEmptyDeque()", "[void]testDuplicateListEmptyList()", "[void]testDuplicateListEmptySet()", "[void]testDuplicateListMultipleDuplicatesInDeque()", "[void]testDuplicateListMultipleDuplicatesInDequeReverse()", "[void]testDuplicateListMultipleDuplicatesInList()", "[void]testDuplicateListMultipleDuplicatesInListReverse()", "[void]testDuplicateListNoDuplicates()", "[void]testDuplicateListSingleElement()", "[void]testDuplicateListWithDuplicates()", "[void]testDuplicateSequencedSetMultipleDuplicates()", "[void]testDuplicateSetEmptyDeque()", "[void]testDuplicateSetEmptyList()", "[void]testDuplicateSetEmptySet()", "[void]testDuplicateSetInSet()", "[void]testDuplicateSetMultipleDuplicatesInDeque()", "[void]testDuplicateSetMultipleDuplicatesInList()", "[void]testDuplicateSetNoDuplicates()", "[void]testDuplicateSetSingleElement()", "[void]testDuplicateSetWithDuplicates()", "[void]testDuplicatListAllSameInDeque()", "[void]testDuplicatSetAllSameInDeque()", "[void]testFind()", "[void]testFirstFromIterableIndexOutOfBoundsException()", "[void]testForEach()", "[void]testForEachButLast()", "[void]testForEachFailure()", "[void]testFrequency()", "[void]testFrequencyOfNull()", "[void]testGetFromIterableIndexOutOfBoundsException()", "[void]testIndexOf()", "[void]testMatchesAll()", "[void]testMatchesAny()", "[void]testPartition()", "[void]testPartitionMultiplePredicates()", "[void]testSize()", "[void]testToString()", "[void]testToStringDelimiter()", "[void]testToStringWithNullArguments()"], "method_uris": ["src/test/java/org/apache/commons/collections4/IterableUtilsTest.java.IterableUtilsTest.[void]firstFromIterable()", "src/test/java/org/apache/commons/collections4/IterableUtilsTest.java.IterableUtilsTest.[void]getFromIterable()", "src/test/java/org/apache/commons/collections4/IterableUtilsTest.java.IterableUtilsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for IterableUtils.\n", "original_string": "public class IterableUtilsTest {\n\n    private static final Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;\n\n    private static final Predicate<Number> EVEN = input -> input.intValue() % 2 == 0;\n\n    /**\n     * Iterable of {@link Integer}s\n     */\n    private Iterable<Integer> iterableA;\n\n    /**\n     * Iterable of {@link Long}s\n     */\n    private Iterable<Long> iterableB;\n\n    /**\n     * An empty Iterable.\n     */\n    private Iterable<Integer> emptyIterable;\n\n    public void firstFromIterable() throws Exception {\n        // Collection, entry exists\n        final Bag<String> bag = new HashBag<>();\n        bag.add(\"element\", 1);\n        assertEquals(\"element\", IterableUtils.first(bag));\n    }\n\n    public void getFromIterable() throws Exception {\n        // Collection, entry exists\n        final Bag<String> bag = new HashBag<>();\n        bag.add(\"element\", 1);\n        assertEquals(\"element\", IterableUtils.get(bag, 0));\n    }\n\n    @BeforeEach\n    public void setUp() {\n        final Collection<Integer> collectionA = new ArrayList<>();\n        collectionA.add(1);\n        collectionA.add(2);\n        collectionA.add(2);\n        collectionA.add(3);\n        collectionA.add(3);\n        collectionA.add(3);\n        collectionA.add(4);\n        collectionA.add(4);\n        collectionA.add(4);\n        collectionA.add(4);\n        iterableA = collectionA;\n\n        final Collection<Long> collectionB = new LinkedList<>();\n        collectionB.add(5L);\n        collectionB.add(4L);\n        collectionB.add(4L);\n        collectionB.add(3L);\n        collectionB.add(3L);\n        collectionB.add(3L);\n        collectionB.add(2L);\n        collectionB.add(2L);\n        collectionB.add(2L);\n        collectionB.add(2L);\n        iterableB = collectionB;\n\n        emptyIterable = Collections.emptyList();\n    }\n\n    @Test\n    public void testContainsWithEquator() {\n        final List<String> base = new ArrayList<>();\n        base.add(\"AC\");\n        base.add(\"BB\");\n        base.add(\"CA\");\n\n        final Equator<String> secondLetterEquator = new Equator<String>() {\n\n            @Override\n            public boolean equate(final String o1, final String o2) {\n                return o1.charAt(1) == o2.charAt(1);\n            }\n\n            @Override\n            public int hash(final String o) {\n                return o.charAt(1);\n            }\n\n        };\n\n        assertFalse(base.contains(\"CC\"));\n        assertTrue(IterableUtils.contains(base, \"AC\", secondLetterEquator));\n        assertTrue(IterableUtils.contains(base, \"CC\", secondLetterEquator));\n        assertFalse(IterableUtils.contains(base, \"CX\", secondLetterEquator));\n        assertFalse(IterableUtils.contains(null, null, secondLetterEquator));\n\n        assertThrows(NullPointerException.class, () -> IterableUtils.contains(base, \"AC\", null), \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testCountMatches() {\n        assertEquals(4, IterableUtils.countMatches(iterableB, EQUALS_TWO));\n        assertEquals(0, IterableUtils.countMatches(null, EQUALS_TWO));\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> assertEquals(0, IterableUtils.countMatches(iterableA, null)),\n                        \"predicate must not be null\"),\n                () -> assertThrows(NullPointerException.class, () -> assertEquals(0, IterableUtils.countMatches(null, null)), \"predicate must not be null\"));\n    }\n\n    @Test\n    public void testDuplicateListAllSameInList() {\n        final List<Integer> input = Arrays.asList(5, 5, 5, 5);\n        assertEquals(Arrays.asList(5), IterableUtils.duplicateList(input));\n    }\n\n    @Test\n    public void testDuplicateListEmptyDeque() {\n        assertTrue(IterableUtils.duplicateList(new ArrayDeque<>()).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateListEmptyList() {\n        final List<Integer> input = Arrays.asList();\n        assertTrue(IterableUtils.duplicateList(input).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateListEmptySet() {\n        assertTrue(IterableUtils.duplicateList(new HashSet<>()).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateListMultipleDuplicatesInDeque() {\n        final Deque<Integer> input = new ArrayDeque<>(Arrays.asList(1, 1, 2, 2, 3, 3, 4, 4));\n        final List<Integer> expected = Arrays.asList(1, 2, 3, 4);\n        assertEquals(expected, IterableUtils.duplicateList(input));\n    }\n\n    @Test\n    public void testDuplicateListMultipleDuplicatesInDequeReverse() {\n        // We want to make sure that the actual list is in the expected order\n        final Deque<Integer> input = new ArrayDeque<>(Arrays.asList(4, 4, 3, 3, 2, 2, 1, 1));\n        final List<Integer> expected = Arrays.asList(4, 3, 2, 1);\n        assertEquals(expected, IterableUtils.duplicateList(input));\n    }\n\n    @Test\n    public void testDuplicateListMultipleDuplicatesInList() {\n        final List<Integer> input = Arrays.asList(1, 1, 2, 2, 3, 3, 4, 4);\n        final List<Integer> expected = Arrays.asList(1, 2, 3, 4);\n        assertEquals(expected, IterableUtils.duplicateList(input));\n    }\n\n    @Test\n    public void testDuplicateListMultipleDuplicatesInListReverse() {\n        // We want to make sure that the actual list is in the expected order\n        final List<Integer> input = Arrays.asList(4, 4, 3, 3, 2, 2, 1, 1);\n        final List<Integer> expected = Arrays.asList(4, 3, 2, 1);\n        assertEquals(expected, IterableUtils.duplicateList(input));\n    }\n\n    @Test\n    public void testDuplicateListNoDuplicates() {\n        final List<Integer> input = Arrays.asList(1, 2, 3, 4, 5);\n        assertTrue(IterableUtils.duplicateList(input).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateListSingleElement() {\n        final List<Integer> input = Arrays.asList(1);\n        assertTrue(IterableUtils.duplicateList(input).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateListWithDuplicates() {\n        final List<Integer> input = Arrays.asList(1, 2, 3, 2, 4, 5, 3);\n        final List<Integer> expected = Arrays.asList(2, 3);\n        assertEquals(expected, IterableUtils.duplicateList(input));\n    }\n\n    @Test\n    public void testDuplicateSequencedSetMultipleDuplicates() {\n        final List<Integer> input = Arrays.asList(1, 1, 2, 2, 3, 3, 4, 4);\n        final List<Integer> list = Arrays.asList(1, 2, 3, 4);\n        assertEquals(list, new ArrayList<>(IterableUtils.duplicateSequencedSet(input)));\n        assertEquals(new LinkedHashSet<>(list), IterableUtils.duplicateSequencedSet(input));\n    }\n\n    @Test\n    public void testDuplicateSetEmptyDeque() {\n        assertTrue(IterableUtils.duplicateSet(new ArrayDeque<>()).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateSetEmptyList() {\n        final List<Integer> input = Arrays.asList();\n        assertTrue(IterableUtils.duplicateSet(input).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateSetEmptySet() {\n        assertTrue(IterableUtils.duplicateSet(new HashSet<>()).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateSetInSet() {\n        // Sets don't have duplicates, so the result is always an empty set.\n        final Set<Integer> input = new HashSet<>(Arrays.asList(5));\n        assertTrue(IterableUtils.duplicateSet(input).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateSetMultipleDuplicatesInDeque() {\n        final Deque<Integer> input = new ArrayDeque<>(Arrays.asList(1, 1, 2, 2, 3, 3, 4, 4));\n        final Set<Integer> expected = new HashSet<>(Arrays.asList(1, 2, 3, 4));\n        assertEquals(expected, IterableUtils.duplicateSet(input));\n    }\n\n    @Test\n    public void testDuplicateSetMultipleDuplicatesInList() {\n        final List<Integer> input = Arrays.asList(1, 1, 2, 2, 3, 3, 4, 4);\n        final Set<Integer> expected = new HashSet<>(Arrays.asList(1, 2, 3, 4));\n        assertEquals(expected, IterableUtils.duplicateSet(input));\n    }\n\n    @Test\n    public void testDuplicateSetNoDuplicates() {\n        final List<Integer> input = Arrays.asList(1, 2, 3, 4, 5);\n        assertTrue(IterableUtils.duplicateSet(input).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateSetSingleElement() {\n        final List<Integer> input = Arrays.asList(1);\n        assertTrue(IterableUtils.duplicateSet(input).isEmpty());\n    }\n\n    @Test\n    public void testDuplicateSetWithDuplicates() {\n        final List<Integer> input = Arrays.asList(1, 2, 3, 2, 4, 5, 3);\n        final Set<Integer> expected = new HashSet<>(Arrays.asList(2, 3));\n        assertEquals(expected, IterableUtils.duplicateSet(input));\n    }\n\n    @Test\n    public void testDuplicatListAllSameInDeque() {\n        final Deque<Integer> input = new ArrayDeque<>(Arrays.asList(5, 5, 5, 5));\n        assertEquals(Arrays.asList(5), IterableUtils.duplicateList(input));\n    }\n\n    @Test\n    public void testDuplicatSetAllSameInDeque() {\n        final Deque<Integer> input = new ArrayDeque<>(Arrays.asList(5, 5, 5, 5));\n        assertEquals(new HashSet<>(Arrays.asList(5)), IterableUtils.duplicateSet(input));\n    }\n\n    @Test\n    public void testFind() {\n        Predicate<Number> testPredicate = equalPredicate(4);\n        Integer test = IterableUtils.find(iterableA, testPredicate);\n        assertEquals(4, (int) test);\n        testPredicate = equalPredicate(45);\n        test = IterableUtils.find(iterableA, testPredicate);\n        assertNull(test);\n        assertNull(IterableUtils.find(null, testPredicate));\n\n        assertThrows(NullPointerException.class, () -> IterableUtils.find(iterableA, null), \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testFirstFromIterableIndexOutOfBoundsException() throws Exception {\n        // Collection, entry exists\n        final Bag<String> bag = new HashBag<>();\n        // Collection, non-existent entry\n        assertThrows(IndexOutOfBoundsException.class, () -> IterableUtils.first(bag));\n    }\n\n    @Test\n    public void testForEach() {\n        final List<Integer> listA = new ArrayList<>();\n        listA.add(1);\n\n        final List<Integer> listB = new ArrayList<>();\n        listB.add(2);\n\n        final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<List<Integer>> col = new ArrayList<>();\n        col.add(listA);\n        col.add(listB);\n        IterableUtils.forEach(col, testClosure);\n        assertTrue(listA.isEmpty() && listB.isEmpty());\n\n        assertThrows(NullPointerException.class, () -> IterableUtils.forEach(col, null), \"expecting NullPointerException\");\n\n        IterableUtils.forEach(null, testClosure);\n\n        // null should be OK\n        col.add(null);\n        IterableUtils.forEach(col, testClosure);\n    }\n\n    @Test\n    public void testForEachButLast() {\n        final List<Integer> listA = new ArrayList<>();\n        listA.add(1);\n\n        final List<Integer> listB = new ArrayList<>();\n        listB.add(2);\n\n        final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<List<Integer>> col = new ArrayList<>();\n        col.add(listA);\n        col.add(listB);\n        List<Integer> last = IterableUtils.forEachButLast(col, testClosure);\n        assertTrue(listA.isEmpty() && !listB.isEmpty());\n        assertSame(listB, last);\n\n        assertThrows(NullPointerException.class, () -> IterableUtils.forEachButLast(col, null), \"expecting NullPointerException\");\n\n        IterableUtils.forEachButLast(null, testClosure);\n\n        // null should be OK\n        col.add(null);\n        col.add(null);\n        last = IterableUtils.forEachButLast(col, testClosure);\n        assertNull(last);\n    }\n\n    @Test\n    public void testForEachFailure() {\n        final Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");\n        final Collection<String> col = new ArrayList<>();\n        col.add(\"x\");\n        assertThrows(FunctorException.class, () -> IterableUtils.forEach(col, testClosure));\n    }\n\n    @Test\n    public void testFrequency() {\n        // null iterable test\n        assertEquals(0, IterableUtils.frequency(null, 1));\n\n        assertEquals(1, IterableUtils.frequency(iterableA, 1));\n        assertEquals(2, IterableUtils.frequency(iterableA, 2));\n        assertEquals(3, IterableUtils.frequency(iterableA, 3));\n        assertEquals(4, IterableUtils.frequency(iterableA, 4));\n        assertEquals(0, IterableUtils.frequency(iterableA, 5));\n\n        assertEquals(0, IterableUtils.frequency(iterableB, 1L));\n        assertEquals(4, IterableUtils.frequency(iterableB, 2L));\n        assertEquals(3, IterableUtils.frequency(iterableB, 3L));\n        assertEquals(2, IterableUtils.frequency(iterableB, 4L));\n        assertEquals(1, IterableUtils.frequency(iterableB, 5L));\n\n        // Ensure that generic bounds accept valid parameters, but return\n        // expected results\n        // e.g. no longs in the \"int\" Iterable<Number>, and vice versa.\n        final Iterable<Number> iterableIntAsNumber = Arrays.<Number>asList(1, 2, 3, 4, 5);\n        final Iterable<Number> iterableLongAsNumber = Arrays.<Number>asList(1L, 2L, 3L, 4L, 5L);\n        assertEquals(0, IterableUtils.frequency(iterableIntAsNumber, 2L));\n        assertEquals(0, IterableUtils.frequency(iterableLongAsNumber, 2));\n\n        final Set<String> set = new HashSet<>();\n        set.add(\"A\");\n        set.add(\"C\");\n        set.add(\"E\");\n        set.add(\"E\");\n        assertEquals(1, IterableUtils.frequency(set, \"A\"));\n        assertEquals(0, IterableUtils.frequency(set, \"B\"));\n        assertEquals(1, IterableUtils.frequency(set, \"C\"));\n        assertEquals(0, IterableUtils.frequency(set, \"D\"));\n        assertEquals(1, IterableUtils.frequency(set, \"E\"));\n\n        final Bag<String> bag = new HashBag<>();\n        bag.add(\"A\", 3);\n        bag.add(\"C\");\n        bag.add(\"E\");\n        bag.add(\"E\");\n        assertEquals(3, IterableUtils.frequency(bag, \"A\"));\n        assertEquals(0, IterableUtils.frequency(bag, \"B\"));\n        assertEquals(1, IterableUtils.frequency(bag, \"C\"));\n        assertEquals(0, IterableUtils.frequency(bag, \"D\"));\n        assertEquals(2, IterableUtils.frequency(bag, \"E\"));\n    }\n\n    @Test\n    public void testFrequencyOfNull() {\n        final List<String> list = new ArrayList<>();\n        assertEquals(0, IterableUtils.frequency(list, null));\n        list.add(\"A\");\n        assertEquals(0, IterableUtils.frequency(list, null));\n        list.add(null);\n        assertEquals(1, IterableUtils.frequency(list, null));\n        list.add(\"B\");\n        assertEquals(1, IterableUtils.frequency(list, null));\n        list.add(null);\n        assertEquals(2, IterableUtils.frequency(list, null));\n        list.add(\"B\");\n        assertEquals(2, IterableUtils.frequency(list, null));\n        list.add(null);\n        assertEquals(3, IterableUtils.frequency(list, null));\n    }\n\n    @Test\n    public void testGetFromIterableIndexOutOfBoundsException() throws Exception {\n        // Collection, entry exists\n        final Bag<String> bag = new HashBag<>();\n        bag.add(\"element\", 1);\n        // Collection, non-existent entry\n        assertThrows(IndexOutOfBoundsException.class, () -> IterableUtils.get(bag, 1));\n    }\n\n    @Test\n    public void testIndexOf() {\n        Predicate<Number> testPredicate = equalPredicate((Number) 4);\n        int index = IterableUtils.indexOf(iterableA, testPredicate);\n        assertEquals(6, index);\n        testPredicate = equalPredicate((Number) 45);\n        index = IterableUtils.indexOf(iterableA, testPredicate);\n        assertEquals(-1, index);\n        assertEquals(-1, IterableUtils.indexOf(null, testPredicate));\n\n        assertThrows(NullPointerException.class, () -> IterableUtils.indexOf(iterableA, null), \"expecting NullPointerException\");\n    }\n\n    @Test\n    public void testMatchesAll() {\n        assertThrows(NullPointerException.class, () -> assertFalse(IterableUtils.matchesAll(null, null)), \"predicate must not be null\");\n\n        assertThrows(NullPointerException.class, () -> assertFalse(IterableUtils.matchesAll(iterableA, null)), \"predicate must not be null\");\n\n        final Predicate<Integer> lessThanFive = object -> object < 5;\n        assertTrue(IterableUtils.matchesAll(iterableA, lessThanFive));\n\n        final Predicate<Integer> lessThanFour = object -> object < 4;\n        assertFalse(IterableUtils.matchesAll(iterableA, lessThanFour));\n\n        assertTrue(IterableUtils.matchesAll(null, lessThanFour));\n        assertTrue(IterableUtils.matchesAll(emptyIterable, lessThanFour));\n    }\n\n    @Test\n    public void testMatchesAny() {\n        final List<Integer> list = new ArrayList<>();\n\n        assertThrows(NullPointerException.class, () -> assertFalse(IterableUtils.matchesAny(null, null)), \"predicate must not be null\");\n\n        assertThrows(NullPointerException.class, () -> assertFalse(IterableUtils.matchesAny(list, null)), \"predicate must not be null\");\n\n        assertFalse(IterableUtils.matchesAny(null, EQUALS_TWO));\n        assertFalse(IterableUtils.matchesAny(list, EQUALS_TWO));\n        list.add(1);\n        list.add(3);\n        list.add(4);\n        assertFalse(IterableUtils.matchesAny(list, EQUALS_TWO));\n\n        list.add(2);\n        assertTrue(IterableUtils.matchesAny(list, EQUALS_TWO));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testPartition() {\n        final List<Integer> input = new ArrayList<>();\n        input.add(1);\n        input.add(2);\n        input.add(3);\n        input.add(4);\n        List<List<Integer>> partitions = IterableUtils.partition(input, EQUALS_TWO);\n        assertEquals(2, partitions.size());\n\n        // first partition contains 2\n        Collection<Integer> partition = partitions.get(0);\n        assertEquals(1, partition.size());\n        assertEquals(2, CollectionUtils.extractSingleton(partition).intValue());\n\n        // second partition contains 1, 3, and 4\n        final Integer[] expected = { 1, 3, 4 };\n        partition = partitions.get(1);\n        assertArrayEquals(expected, partition.toArray());\n\n        partitions = IterableUtils.partition((List<Integer>) null, EQUALS_TWO);\n        assertEquals(2, partitions.size());\n        assertTrue(partitions.get(0).isEmpty());\n        assertTrue(partitions.get(1).isEmpty());\n\n        partitions = IterableUtils.partition(input);\n        assertEquals(1, partitions.size());\n        assertEquals(input, partitions.get(0));\n\n        assertThrows(NullPointerException.class, () -> IterableUtils.partition(input, (Predicate<Integer>) null), \"expecting NullPointerException\");\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testPartitionMultiplePredicates() {\n        final List<Integer> input = new ArrayList<>();\n        input.add(1);\n        input.add(2);\n        input.add(3);\n        input.add(4);\n        final List<List<Integer>> partitions = IterableUtils.partition(input, EQUALS_TWO, EVEN);\n\n        // first partition contains 2\n        Collection<Integer> partition = partitions.get(0);\n        assertEquals(1, partition.size());\n        assertEquals(2, partition.iterator().next().intValue());\n\n        // second partition contains 4\n        partition = partitions.get(1);\n        assertEquals(1, partition.size());\n        assertEquals(4, partition.iterator().next().intValue());\n\n        // third partition contains 1 and 3\n        final Integer[] expected = { 1, 3 };\n        partition = partitions.get(2);\n        assertArrayEquals(expected, partition.toArray());\n\n        assertThrows(NullPointerException.class, () -> IterableUtils.partition(input, EQUALS_TWO, null));\n    }\n\n    @Test\n    public void testSize() {\n        assertEquals(0, IterableUtils.size(null));\n    }\n\n    @Test\n    public void testToString() {\n        String result = IterableUtils.toString(iterableA);\n        assertEquals(\"[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\", result);\n\n        result = IterableUtils.toString(new ArrayList<>());\n        assertEquals(\"[]\", result);\n\n        result = IterableUtils.toString(null);\n        assertEquals(\"[]\", result);\n\n        result = IterableUtils.toString(iterableA, input -> Integer.toString(input * 2));\n        assertEquals(\"[2, 4, 4, 6, 6, 6, 8, 8, 8, 8]\", result);\n\n        result = IterableUtils.toString(new ArrayList<>(), input -> {\n            fail(\"not supposed to reach here\");\n            return StringUtils.EMPTY;\n        });\n        assertEquals(\"[]\", result);\n\n        result = IterableUtils.toString(null, input -> {\n            fail(\"not supposed to reach here\");\n            return StringUtils.EMPTY;\n        });\n        assertEquals(\"[]\", result);\n    }\n\n    @Test\n    public void testToStringDelimiter() {\n\n        final Transformer<Integer, String> transformer = input -> Integer.toString(input * 2);\n\n        String result = IterableUtils.toString(iterableA, transformer, StringUtils.EMPTY, StringUtils.EMPTY, StringUtils.EMPTY);\n        assertEquals(\"2446668888\", result);\n\n        result = IterableUtils.toString(iterableA, transformer, \",\", StringUtils.EMPTY, StringUtils.EMPTY);\n        assertEquals(\"2,4,4,6,6,6,8,8,8,8\", result);\n\n        result = IterableUtils.toString(iterableA, transformer, StringUtils.EMPTY, \"[\", \"]\");\n        assertEquals(\"[2446668888]\", result);\n\n        result = IterableUtils.toString(iterableA, transformer, \",\", \"[\", \"]\");\n        assertEquals(\"[2,4,4,6,6,6,8,8,8,8]\", result);\n\n        result = IterableUtils.toString(iterableA, transformer, \",\", \"[[\", \"]]\");\n        assertEquals(\"[[2,4,4,6,6,6,8,8,8,8]]\", result);\n\n        result = IterableUtils.toString(iterableA, transformer, \",,\", \"[\", \"]\");\n        assertEquals(\"[2,,4,,4,,6,,6,,6,,8,,8,,8,,8]\", result);\n\n        result = IterableUtils.toString(iterableA, transformer, \",,\", \"((\", \"))\");\n        assertEquals(\"((2,,4,,4,,6,,6,,6,,8,,8,,8,,8))\", result);\n\n        result = IterableUtils.toString(new ArrayList<>(), transformer, StringUtils.EMPTY, \"(\", \")\");\n        assertEquals(\"()\", result);\n\n        result = IterableUtils.toString(new ArrayList<>(), transformer, StringUtils.EMPTY, StringUtils.EMPTY, StringUtils.EMPTY);\n        assertEquals(StringUtils.EMPTY, result);\n    }\n\n    @Test\n    public void testToStringWithNullArguments() {\n        final String result = IterableUtils.toString(null, input -> {\n            fail(\"not supposed to reach here\");\n            return StringUtils.EMPTY;\n        }, StringUtils.EMPTY, \"(\", \")\");\n        assertEquals(\"()\", result);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> IterableUtils.toString(new ArrayList<>(), null, StringUtils.EMPTY, \"(\", \")\"),\n                        \"expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> IterableUtils.toString(new ArrayList<>(), input -> {\n                    fail(\"not supposed to reach here\");\n                    return StringUtils.EMPTY;\n                }, null, \"(\", \")\"), \"expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> IterableUtils.toString(new ArrayList<>(), input -> {\n                    fail(\"not supposed to reach here\");\n                    return StringUtils.EMPTY;\n                }, StringUtils.EMPTY, null, \")\"), \"expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> IterableUtils.toString(new ArrayList<>(), input -> {\n                    fail(\"not supposed to reach here\");\n                    return StringUtils.EMPTY;\n                }, StringUtils.EMPTY, \"(\", null), \"expecting NullPointerException\"));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Predicate<Number> EQUALS_TWO = input -> input.intValue() == 2;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Predicate<Number>", "name": "EQUALS_TWO = input -> input.intValue() == 2", "syntax_pass": true}, {"attribute_expression": "private static final Predicate<Number> EVEN = input -> input.intValue() % 2 == 0;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Predicate<Number>", "name": "EVEN = input -> input.intValue() % 2 == 0", "syntax_pass": true}, {"attribute_expression": "private Iterable<Integer> iterableA;", "docstring": "\nIterable of {@link Integer}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Integer>", "name": "iterableA", "syntax_pass": true}, {"attribute_expression": "private Iterable<Long> iterableB;", "docstring": "\nIterable of {@link Long}s\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Long>", "name": "iterableB", "syntax_pass": true}, {"attribute_expression": "private Iterable<Integer> emptyIterable;", "docstring": "\nAn empty Iterable.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterable<Integer>", "name": "emptyIterable", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/ArrayStack_popTest.java.ArrayStack_popTest", "name": "ArrayStack_popTest", "file_path": "src/test/java/org/apache/commons/collections4/ArrayStack_popTest.java", "superclasses": "", "methods": ["[void]testPopWithItems()", "[void]testPopOnEmptyStack()", "[void]testPopAfterPeek()", "[void]testPopAndSearch()", "[void]testPopAndEmpty()"], "method_uris": ["src/test/java/org/apache/commons/collections4/ArrayStack_popTest.java.ArrayStack_popTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ArrayStack_popTest {\n\n    private ArrayStack<String> stack;\n\n    @BeforeEach\n    public void setUp() {\n        stack = new ArrayStack<>();\n    }\n\n    @Test\n    public void testPopWithItems() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        assertEquals(\"Second Item\", stack.pop(), \"Top item should be 'Second Item'\");\n        assertEquals(\"First Item\", stack.pop(), \"Next item should be 'First Item'\");\n    }\n\n    @Test\n    public void testPopOnEmptyStack() {\n        assertThrows(EmptyStackException.class, () -> {\n            stack.pop();\n        }, \"Pop on empty stack should throw EmptyStackException\");\n    }\n\n    @Test\n    public void testPopAfterPeek() {\n        stack.push(\"Item\");\n        assertEquals(\"Item\", stack.peek(), \"Peek should return 'Item'\");\n        assertEquals(\"Item\", stack.pop(), \"Pop should return 'Item'\");\n        assertTrue(stack.empty(), \"Stack should be empty after pop\");\n    }\n\n    @Test\n    public void testPopAndSearch() {\n        stack.push(\"First Item\");\n        stack.push(\"Second Item\");\n        assertEquals(1, stack.search(\"Second Item\"), \"Top item is 'Second Item'\");\n        assertEquals(\"Second Item\", stack.pop(), \"Pop should return 'Second Item'\");\n        assertEquals(1, stack.search(\"First Item\"), \"Top item is 'First Item'\");\n    }\n\n    @Test\n    public void testPopAndEmpty() {\n        stack.push(\"Item\");\n        assertFalse(stack.empty(), \"Stack should not be empty after push\");\n        stack.pop();\n        assertTrue(stack.empty(), \"Stack should be empty after pop\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ArrayStack<String> stack;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayStack<String>", "name": "stack", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/FactoryUtilsTest.java.FactoryUtilsTest", "name": "FactoryUtilsTest", "file_path": "src/test/java/org/apache/commons/collections4/FactoryUtilsTest.java", "superclasses": "", "methods": ["[void]testConstantFactoryConstant()", "[void]testConstantFactoryNull()", "[void]testExceptionFactory()", "[void]testInstantiateFactoryComplex()", "[void]testInstantiateFactoryMismatch()", "[void]testInstantiateFactoryNoConstructor()", "[void]testInstantiateFactoryNull()", "[void]testInstantiateFactorySimple()", "[void]testNullFactory()", "[void]testPrototypeFactoryNull()", "[void]testPrototypeFactoryPublicBad()", "[void]testPrototypeFactoryPublicCloneMethod()", "[void]testPrototypeFactoryPublicCopyConstructor()", "[void]testPrototypeFactoryPublicSerialization()", "[void]testPrototypeFactoryPublicSerializationError()", "[void]testSingletonPatternInSerialization()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    public static class Mock1 {\n        private final int iVal;\n        public Mock1(final int val) {\n            iVal = val;\n        }\n        public Mock1(final Mock1 mock) {\n            iVal = mock.iVal;\n        }\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj instanceof Mock1 && iVal == ((Mock1) obj).iVal) {\n                return true;\n            }\n            return false;\n        }\n        @Override\n        public int hashCode() { // please Findbugs\n            return super.hashCode();\n        }\n    }", "definition": "    public static class Mock1", "class_docstring": "", "name": "Mock1", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final int iVal;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "iVal", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Mock1(final int val) {\n            iVal = val;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Mock1", "params": [{"name": "val", "type": "int"}], "body": "                                    {\n            iVal = val;\n        }", "signature": "public Mock1(final int val)"}, {"syntax_pass": true, "original_string": "        public Mock1(final Mock1 mock) {\n            iVal = mock.iVal;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Mock1", "params": [{"name": "mock", "type": "Mock1"}], "body": "                                       {\n            iVal = mock.iVal;\n        }", "signature": "public Mock1(final Mock1 mock)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (obj instanceof Mock1 && iVal == ((Mock1) obj).iVal) {\n                return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (obj instanceof Mock1 && iVal == ((Mock1) obj).iVal) {\n                return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() { // please Findbugs\n            return super.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              { // please Findbugs\n            return super.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    public static class Mock2 implements Serializable {\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = 4899282162482588924L;\n        private final Object iVal;\n        public Mock2(final Object val) {\n            iVal = val;\n        }\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj instanceof Mock2 && iVal == ((Mock2) obj).iVal) {\n                return true;\n            }\n            return false;\n        }\n        @Override\n        public int hashCode() { // please Findbugs\n            return super.hashCode();\n        }\n    }", "definition": "    public static class Mock2 implements Serializable", "class_docstring": "", "name": "Mock2", "super_interfaces": ["Serializable"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4899282162482588924L;", "docstring": "\nGenerated serial version ID.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4899282162482588924L", "syntax_pass": true}, {"attribute_expression": "private final Object iVal;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "iVal", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Mock2(final Object val) {\n            iVal = val;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Mock2", "params": [{"name": "val", "type": "Object"}], "body": "                                       {\n            iVal = val;\n        }", "signature": "public Mock2(final Object val)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (obj instanceof Mock2 && iVal == ((Mock2) obj).iVal) {\n                return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (obj instanceof Mock2 && iVal == ((Mock2) obj).iVal) {\n                return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() { // please Findbugs\n            return super.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              { // please Findbugs\n            return super.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    public static class Mock3 {\n        private static int cCounter;\n        private final int iVal;\n        public Mock3() {\n            iVal = cCounter++;\n        }\n        public int getValue() {\n            return iVal;\n        }\n    }", "definition": "    public static class Mock3", "class_docstring": "", "name": "Mock3", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static int cCounter;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "int", "name": "cCounter", "syntax_pass": true}, {"attribute_expression": "private final int iVal;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "iVal", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Mock3() {\n            iVal = cCounter++;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Mock3", "params": [], "body": "                       {\n            iVal = cCounter++;\n        }", "signature": "public Mock3()"}, {"syntax_pass": true, "original_string": "        public int getValue() {\n            return iVal;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getValue", "params": [], "body": "                              {\n            return iVal;\n        }", "signature": "public int getValue()"}]}], "class_docstring": "\nTests the org.apache.commons.collections.FactoryUtils class.\n", "original_string": "public class FactoryUtilsTest {\n\n    public static class Mock1 {\n        private final int iVal;\n        public Mock1(final int val) {\n            iVal = val;\n        }\n        public Mock1(final Mock1 mock) {\n            iVal = mock.iVal;\n        }\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj instanceof Mock1 && iVal == ((Mock1) obj).iVal) {\n                return true;\n            }\n            return false;\n        }\n        @Override\n        public int hashCode() { // please Findbugs\n            return super.hashCode();\n        }\n    }\n\n    public static class Mock2 implements Serializable {\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = 4899282162482588924L;\n        private final Object iVal;\n        public Mock2(final Object val) {\n            iVal = val;\n        }\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj instanceof Mock2 && iVal == ((Mock2) obj).iVal) {\n                return true;\n            }\n            return false;\n        }\n        @Override\n        public int hashCode() { // please Findbugs\n            return super.hashCode();\n        }\n    }\n\n    public static class Mock3 {\n        private static int cCounter;\n        private final int iVal;\n        public Mock3() {\n            iVal = cCounter++;\n        }\n        public int getValue() {\n            return iVal;\n        }\n    }\n\n    @Test\n    public void testConstantFactoryConstant() {\n        final Integer constant = Integer.valueOf(9);\n        final Factory<Integer> factory = FactoryUtils.constantFactory(constant);\n        assertNotNull(factory);\n        final Integer created = factory.create();\n        assertSame(constant, created);\n    }\n\n    @Test\n    public void testConstantFactoryNull() {\n        final Factory<Object> factory = FactoryUtils.constantFactory(null);\n        assertNotNull(factory);\n        final Object created = factory.create();\n        assertNull(created);\n    }\n\n    @Test\n    public void testExceptionFactory() {\n        assertNotNull(FactoryUtils.exceptionFactory());\n        assertSame(FactoryUtils.exceptionFactory(), FactoryUtils.exceptionFactory());\n\n        assertThrows(FunctorException.class, () -> FactoryUtils.exceptionFactory().create());\n    }\n\n    @Test\n    public void testInstantiateFactoryComplex() {\n        TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n        // 2nd Jan 1970\n        final Factory<Date> factory = FactoryUtils.instantiateFactory(Date.class,\n            new Class[] {Integer.TYPE, Integer.TYPE, Integer.TYPE},\n            new Object[] {Integer.valueOf(70), Integer.valueOf(0), Integer.valueOf(2)});\n        assertNotNull(factory);\n        final Date created = factory.create();\n        // long time of 1 day (== 2nd Jan 1970)\n        assertEquals(new Date(1000 * 60 * 60 * 24), created);\n    }\n\n    @Test\n    public void testInstantiateFactoryMismatch() {\n        assertThrows(IllegalArgumentException.class, () -> FactoryUtils.instantiateFactory(Date.class, null, new Object[] {null}));\n    }\n\n    @Test\n    public void testInstantiateFactoryNoConstructor() {\n        assertThrows(IllegalArgumentException.class, () -> FactoryUtils.instantiateFactory(Date.class, new Class[] {Long.class}, new Object[] {null}));\n    }\n\n    @Test\n    public void testInstantiateFactoryNull() {\n        assertThrows(NullPointerException.class, () -> FactoryUtils.instantiateFactory(null));\n    }\n\n    @Test\n    public void testInstantiateFactorySimple() {\n        final Factory<Mock3> factory = FactoryUtils.instantiateFactory(Mock3.class);\n        assertNotNull(factory);\n        Mock3 created = factory.get();\n        assertEquals(0, created.getValue());\n        created = factory.create();\n        assertEquals(1, created.getValue());\n    }\n\n    @Test\n    public void testNullFactory() {\n        final Factory<Object> factory = FactoryUtils.nullFactory();\n        assertNotNull(factory);\n        final Object created = factory.create();\n        assertNull(created);\n    }\n\n    @Test\n    public void testPrototypeFactoryNull() {\n        assertSame(ConstantFactory.NULL_INSTANCE, FactoryUtils.prototypeFactory(null));\n    }\n\n    @Test\n    public void testPrototypeFactoryPublicBad() {\n        final Object proto = new Object();\n        assertThrows(IllegalArgumentException.class, () -> FactoryUtils.prototypeFactory(proto));\n    }\n\n    @Test\n    public void testPrototypeFactoryPublicCloneMethod() throws Exception {\n        final Date proto = new Date();\n        final Factory<Date> factory = FactoryUtils.prototypeFactory(proto);\n        assertNotNull(factory);\n        final Date created = factory.create();\n        assertNotSame(proto, created);\n        assertEquals(proto, created);\n    }\n\n    @Test\n    public void testPrototypeFactoryPublicCopyConstructor() throws Exception {\n        final Mock1 proto = new Mock1(6);\n        final Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n        assertNotNull(factory);\n        final Object created = factory.create();\n        assertNotSame(proto, created);\n        assertEquals(proto, created);\n    }\n\n    @Test\n    public void testPrototypeFactoryPublicSerialization() throws Exception {\n        final Integer proto = 9;\n        final Factory<Integer> factory = FactoryUtils.prototypeFactory(proto);\n        assertNotNull(factory);\n        final Integer created = factory.create();\n        assertNotSame(proto, created);\n        assertEquals(proto, created);\n    }\n\n    @Test\n    public void testPrototypeFactoryPublicSerializationError() {\n        final Mock2 proto = new Mock2(new Object());\n        final Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n        assertNotNull(factory);\n\n        final FunctorException thrown = assertThrows(FunctorException.class, () -> factory.create());\n        assertTrue(thrown.getCause() instanceof IOException);\n    }\n\n    /**\n     * Test that all Factory singletons hold singleton pattern in\n     * serialization/deserialization process.\n     */\n    @Test\n    public void testSingletonPatternInSerialization() {\n        final Object[] singletons = {\n            ExceptionFactory.INSTANCE,\n        };\n\n        for (final Object original : singletons) {\n            TestUtils.assertSameAfterSerialization(\n                    \"Singleton pattern broken for \" + original.getClass(),\n                    original\n            );\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_peekTest.java.CircularFifoQueue_peekTest", "name": "CircularFifoQueue_peekTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_peekTest.java", "superclasses": "", "methods": ["[void]testPeekWithEmptyQueue()", "[void]testPeekWithNonEmptyQueue()", "[void]testPeekAfterAddingAndRemovingElements()", "[void]testPeekAfterFullQueue()", "[void]testPeekAfterClear()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_peekTest.java.CircularFifoQueue_peekTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CircularFifoQueue_peekTest {\n    private CircularFifoQueue<String> queue;\n\n    @BeforeEach\n    public void setUp() {\n        queue = new CircularFifoQueue<>(3);\n    }\n\n    @Test\n    public void testPeekWithEmptyQueue() {\n        assertNull(queue.peek());\n    }\n\n    @Test\n    public void testPeekWithNonEmptyQueue() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        assertEquals(\"1\", queue.peek());\n    }\n\n    @Test\n    public void testPeekAfterAddingAndRemovingElements() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.remove();\n        assertEquals(\"2\", queue.peek());\n    }\n\n    @Test\n    public void testPeekAfterFullQueue() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.add(\"4\");\n        assertEquals(\"2\", queue.peek());\n    }\n\n    @Test\n    public void testPeekAfterClear() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.clear();\n        assertNull(queue.peek());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CircularFifoQueue<String> queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CircularFifoQueue<String>", "name": "queue", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_equalsTest.java.SynchronizedQueue_equalsTest", "name": "SynchronizedQueue_equalsTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameInstance()", "[void]testEquals_DifferentInstancesWithSameElements()", "[void]testEquals_DifferentInstancesWithDifferentElements()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SynchronizedQueue_equalsTest {\n\n    @Test\n    public void testEquals_SameInstance() {\n        Queue<String> queue = new LinkedList<>();\n        SynchronizedQueue<String> synchronizedQueue = SynchronizedQueue.synchronizedQueue(queue);\n\n        assertTrue(synchronizedQueue.equals(synchronizedQueue));\n    }\n\n    @Test\n    public void testEquals_DifferentInstancesWithSameElements() {\n        Queue<String> queue1 = new LinkedList<>();\n        queue1.offer(\"element1\");\n        queue1.offer(\"element2\");\n        SynchronizedQueue<String> synchronizedQueue1 = SynchronizedQueue.synchronizedQueue(queue1);\n\n        Queue<String> queue2 = new LinkedList<>();\n        queue2.offer(\"element1\");\n        queue2.offer(\"element2\");\n        SynchronizedQueue<String> synchronizedQueue2 = SynchronizedQueue.synchronizedQueue(queue2);\n\n        assertTrue(synchronizedQueue1.decorated().equals(synchronizedQueue2.decorated()));\n    }\n\n    @Test\n    public void testEquals_DifferentInstancesWithDifferentElements() {\n        Queue<String> queue1 = new LinkedList<>();\n        queue1.offer(\"element1\");\n        SynchronizedQueue<String> synchronizedQueue1 = SynchronizedQueue.synchronizedQueue(queue1);\n\n        Queue<String> queue2 = new LinkedList<>();\n        queue2.offer(\"element2\");\n        SynchronizedQueue<String> synchronizedQueue2 = SynchronizedQueue.synchronizedQueue(queue2);\n\n        assertFalse(synchronizedQueue1.decorated().equals(synchronizedQueue2.decorated()));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_addTest.java.CircularFifoQueue_addTest", "name": "CircularFifoQueue_addTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_addTest.java", "superclasses": "", "methods": ["[void]testAddElementSuccess()", "[void]testAddElementNull()", "[void]testAddElementAtFullCapacity()", "[void]testAddElementWrapAround()", "[void]testAddElementAfterClear()", "[void]testAddElementAfterRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_addTest.java.CircularFifoQueue_addTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CircularFifoQueue_addTest {\n\n    private CircularFifoQueue<String> queue;\n\n    @BeforeEach\n    public void setUp() {\n        queue = new CircularFifoQueue<>(3);\n    }\n\n    @Test\n    public void testAddElementSuccess() {\n        assertTrue(queue.add(\"Element1\"));\n        assertEquals(1, queue.size());\n        assertEquals(\"Element1\", queue.peek());\n    }\n\n    @Test\n    public void testAddElementNull() {\n        assertThrows(NullPointerException.class, () -> queue.add(null));\n    }\n\n    @Test\n    public void testAddElementAtFullCapacity() {\n        queue.add(\"Element1\");\n        queue.add(\"Element2\");\n        queue.add(\"Element3\");\n        assertTrue(queue.isAtFullCapacity());\n        assertTrue(queue.add(\"Element4\"));\n        assertEquals(3, queue.size());\n        assertEquals(\"Element2\", queue.peek());\n    }\n\n    @Test\n    public void testAddElementWrapAround() {\n        queue.add(\"Element1\");\n        queue.add(\"Element2\");\n        queue.add(\"Element3\");\n        queue.add(\"Element4\");\n        assertEquals(3, queue.size());\n        assertEquals(\"Element2\", queue.peek());\n        assertEquals(\"Element2\", queue.get(0));\n        assertEquals(\"Element3\", queue.get(1));\n        assertEquals(\"Element4\", queue.get(2));\n    }\n\n    @Test\n    public void testAddElementAfterClear() {\n        queue.add(\"Element1\");\n        queue.add(\"Element2\");\n        queue.clear();\n        assertTrue(queue.add(\"Element3\"));\n        assertEquals(1, queue.size());\n        assertEquals(\"Element3\", queue.peek());\n    }\n\n    @Test\n    public void testAddElementAfterRemove() {\n        queue.add(\"Element1\");\n        queue.add(\"Element2\");\n        queue.remove();\n        assertTrue(queue.add(\"Element3\"));\n        assertEquals(2, queue.size());\n        assertEquals(\"Element2\", queue.peek());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CircularFifoQueue<String> queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CircularFifoQueue<String>", "name": "queue", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_pollTest.java.SynchronizedQueue_pollTest", "name": "SynchronizedQueue_pollTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_pollTest.java", "superclasses": "", "methods": ["[void]testPoll()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SynchronizedQueue_pollTest {\n\n    @Test\n    public void testPoll() {\n        // Given\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(\"element1\");\n        SynchronizedQueue<String> synchronizedQueue = SynchronizedQueue.synchronizedQueue(queue);\n\n        // When\n        String result = synchronizedQueue.poll();\n\n        // Then\n        assertEquals(\"element1\", result);\n        assertNull(synchronizedQueue.peek());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_sizeTest.java.CircularFifoQueue_sizeTest", "name": "CircularFifoQueue_sizeTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_sizeTest.java", "superclasses": "", "methods": ["[void]testSizeWhenQueueIsEmpty()", "[void]testSizeWhenQueueIsFull()", "[void]testSizeWhenQueueHasElementsButNotFull()", "[void]testSizeAfterAddingAndRemovingElements()", "[void]testSizeAfterClearingQueue()", "[void]testSizeWhenEndIsLessThanStart()", "[void]testSizeWhenEndEqualsStartAndQueueIsFull()", "[void]testSizeWhenEndEqualsStartAndQueueIsEmpty()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_sizeTest.java.CircularFifoQueue_sizeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CircularFifoQueue_sizeTest {\n\n    private CircularFifoQueue<Integer> queue;\n\n    @BeforeEach\n    public void setUp() {\n        queue = new CircularFifoQueue<>(3);\n    }\n\n    @Test\n    public void testSizeWhenQueueIsEmpty() {\n        assertEquals(0, queue.size());\n    }\n\n    @Test\n    public void testSizeWhenQueueIsFull() {\n        queue.add(1);\n        queue.add(2);\n        queue.add(3);\n        assertEquals(3, queue.size());\n    }\n\n    @Test\n    public void testSizeWhenQueueHasElementsButNotFull() {\n        queue.add(1);\n        queue.add(2);\n        assertEquals(2, queue.size());\n    }\n\n    @Test\n    public void testSizeAfterAddingAndRemovingElements() {\n        queue.add(1);\n        queue.add(2);\n        queue.add(3);\n        queue.remove();\n        assertEquals(2, queue.size());\n    }\n\n    @Test\n    public void testSizeAfterClearingQueue() {\n        queue.add(1);\n        queue.add(2);\n        queue.clear();\n        assertEquals(0, queue.size());\n    }\n\n    @Test\n    public void testSizeWhenEndIsLessThanStart() {\n        queue.add(1);\n        queue.add(2);\n        queue.add(3);\n        queue.remove();\n        queue.add(4);\n        assertEquals(3, queue.size());\n    }\n\n    @Test\n    public void testSizeWhenEndEqualsStartAndQueueIsFull() {\n        queue.add(1);\n        queue.add(2);\n        queue.add(3);\n        assertEquals(3, queue.size());\n    }\n\n    @Test\n    public void testSizeWhenEndEqualsStartAndQueueIsEmpty() {\n        queue.add(1);\n        queue.remove();\n        assertEquals(0, queue.size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CircularFifoQueue<Integer> queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CircularFifoQueue<Integer>", "name": "queue", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueueTest.java.SynchronizedQueueTest", "name": "SynchronizedQueueTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueueTest.java", "superclasses": "", "methods": ["[void]testCreate()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/SynchronizedQueueTest.java.SynchronizedQueueTest.[]SynchronizedQueueTest()", "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueueTest.java.SynchronizedQueueTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueueTest.java.SynchronizedQueueTest.[Queue<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractQueueTest} for exercising the {@link SynchronizedQueue} implementation.\n", "original_string": "public class SynchronizedQueueTest<T> extends AbstractQueueTest<T> {\n\n    public SynchronizedQueueTest() {\n        super(SynchronizedQueueTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.2\";\n    }\n\n    @Override\n    public Queue<T> makeObject() {\n        return SynchronizedQueue.synchronizedQueue(new LinkedList<>());\n    }\n\n    @Test\n    @Disabled(\"Run once\")\n    public void testCreate() throws Exception {\n        Queue<T> queue = makeObject();\n        writeExternalFormToDisk((java.io.Serializable) queue,\n            BulkTest.TEST_DATA_PATH + \"SynchronizedQueue.emptyCollection.version4.2.obj\");\n        queue = makeFullCollection();\n        writeExternalFormToDisk((java.io.Serializable) queue,\n            BulkTest.TEST_DATA_PATH + \"SynchronizedQueue.fullCollection.version4.2.obj\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_removeTest.java.CircularFifoQueue_removeTest", "name": "CircularFifoQueue_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveSuccess()", "[void]testRemoveFromEmptyQueue()", "[void]testRemoveWithWrapAround()", "[void]testRemoveAllElements()", "[void]testRemoveAfterClear()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_removeTest.java.CircularFifoQueue_removeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CircularFifoQueue_removeTest {\n    private CircularFifoQueue<String> queue;\n\n    @BeforeEach\n    public void setUp() {\n        queue = new CircularFifoQueue<>(5);\n    }\n\n    @Test\n    public void testRemoveSuccess() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        assertEquals(\"1\", queue.remove());\n        assertEquals(2, queue.size());\n    }\n\n    @Test\n    public void testRemoveFromEmptyQueue() {\n        assertThrows(NoSuchElementException.class, () -> queue.remove());\n    }\n\n    @Test\n    public void testRemoveWithWrapAround() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.add(\"4\");\n        queue.add(\"5\");\n        queue.add(\"6\"); // This will wrap around\n        assertEquals(\"2\", queue.remove());\n        assertEquals(4, queue.size());\n    }\n\n    @Test\n    public void testRemoveAllElements() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.remove();\n        queue.remove();\n        queue.remove();\n        assertTrue(queue.isEmpty());\n    }\n\n    @Test\n    public void testRemoveAfterClear() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.clear();\n        assertThrows(NoSuchElementException.class, () -> queue.remove());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CircularFifoQueue<String> queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CircularFifoQueue<String>", "name": "queue", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java.PredicatedQueueTest", "name": "PredicatedQueueTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java", "superclasses": "", "methods": ["[void]testGet()", "[void]testRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java.PredicatedQueueTest.[]PredicatedQueueTest()", "src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java.PredicatedQueueTest.[Queue<E>]decorateCollection(Queue<E>,Predicate<E>)", "src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java.PredicatedQueueTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java.PredicatedQueueTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java.PredicatedQueueTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java.PredicatedQueueTest.[Queue<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java.PredicatedQueueTest.[Queue<E>]makeObject()", "src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java.PredicatedQueueTest.[Queue<E>]makeTestQueue()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link PredicatedCollectionTest} for exercising the\n{@link PredicatedQueue} implementation.\n", "original_string": "public class PredicatedQueueTest<E> extends AbstractQueueTest<E> {\n\n    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n\n    protected Predicate<E> testPredicate = String.class::isInstance;\n\n    public PredicatedQueueTest() {\n        super(PredicatedQueueTest.class.getSimpleName());\n    }\n\n    protected Queue<E> decorateCollection(final Queue<E> queue, final Predicate<E> predicate) {\n        return PredicatedQueue.predicatedQueue(queue, predicate);\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new LinkedList<>();\n    }\n\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        return new LinkedList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    public Queue<E> makeFullCollection() {\n        final Queue<E> queue = new LinkedList<>(Arrays.asList(getFullElements()));\n        return decorateCollection(queue, truePredicate);\n    }\n\n    @Override\n    public Queue<E> makeObject() {\n        return decorateCollection(new LinkedList<>(), truePredicate);\n    }\n\n    public Queue<E> makeTestQueue() {\n        return decorateCollection(new LinkedList<>(), testPredicate);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testGet() {\n        final Queue<E> queue = makeTestQueue();\n\n        assertNull(queue.peek());\n\n        queue.add((E) \"one\");\n        queue.add((E) \"two\");\n        queue.add((E) \"three\");\n        assertEquals(\"one\", queue.peek(), \"Queue get\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemove() {\n        final Queue<E> queue = makeTestQueue();\n        queue.add((E) \"one\");\n        assertEquals(\"one\", queue.poll(), \"Queue get\");\n        assertNull(queue.peek());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedQueue.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedQueue.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "truePredicate = TruePredicate.<E>truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected Predicate<E> testPredicate = String.class::isInstance;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "testPredicate = String.class::isInstance", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_peekTest.java.SynchronizedQueue_peekTest", "name": "SynchronizedQueue_peekTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_peekTest.java", "superclasses": "", "methods": ["[void]testPeek()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SynchronizedQueue_peekTest {\n\n    @Test\n    public void testPeek() {\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(\"element\");\n        SynchronizedQueue<String> synchronizedQueue = SynchronizedQueue.synchronizedQueue(queue);\n\n        String peekedElement = synchronizedQueue.peek();\n\n        assertEquals(\"element\", peekedElement);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_elementTest.java.SynchronizedQueue_elementTest", "name": "SynchronizedQueue_elementTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_elementTest.java", "superclasses": "", "methods": ["[void]testElement()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SynchronizedQueue_elementTest {\n\n    @Test\n    public void testElement() {\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(\"element1\");\n        SynchronizedQueue<String> synchronizedQueue = SynchronizedQueue.synchronizedQueue(queue);\n\n        String result = synchronizedQueue.element();\n\n        assertEquals(\"element1\", result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_hashCodeTest.java.SynchronizedQueue_hashCodeTest", "name": "SynchronizedQueue_hashCodeTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_hashCodeTest.java", "superclasses": "", "methods": ["[void]testHashCode()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SynchronizedQueue_hashCodeTest {\n\n    @Test\n    public void testHashCode() {\n        // Given\n        Queue<String> mockQueue = mock(Queue.class);\n        SynchronizedQueue<String> synchronizedQueue = new SynchronizedQueue<>(mockQueue, new Object());\n\n        // When\n        int result = synchronizedQueue.hashCode();\n\n        // Then\n        assertEquals(mockQueue.hashCode(), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueue_unmodifiableQueueTest.java.UnmodifiableQueue_unmodifiableQueueTest", "name": "UnmodifiableQueue_unmodifiableQueueTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueue_unmodifiableQueueTest.java", "superclasses": "", "methods": ["[void]testUnmodifiableQueueWithModifiableQueue()", "[void]testUnmodifiableQueueWithUnmodifiableQueue()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnmodifiableQueue_unmodifiableQueueTest {\n\n    @Test\n    public void testUnmodifiableQueueWithModifiableQueue() {\n        Queue<String> modifiableQueue = new LinkedList<>();\n        modifiableQueue.add(\"element\");\n\n        Queue<String> unmodifiableQueue = UnmodifiableQueue.unmodifiableQueue(modifiableQueue);\n\n        assertTrue(unmodifiableQueue instanceof UnmodifiableQueue);\n        assertEquals(1, unmodifiableQueue.size());\n    }\n\n    @Test\n    public void testUnmodifiableQueueWithUnmodifiableQueue() {\n        Queue<String> modifiableQueue = new LinkedList<>();\n        modifiableQueue.add(\"element\");\n        Queue<String> alreadyUnmodifiableQueue = UnmodifiableQueue.unmodifiableQueue(modifiableQueue);\n\n        Queue<String> unmodifiableQueue = UnmodifiableQueue.unmodifiableQueue(alreadyUnmodifiableQueue);\n\n        assertSame(alreadyUnmodifiableQueue, unmodifiableQueue);\n        assertEquals(1, unmodifiableQueue.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest", "name": "UnmodifiableQueueTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testOffer()", "[void]testPoll()", "[void]testQueueRemove()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[]UnmodifiableQueueTest()", "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[Queue<E>]getCollection()", "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[boolean]isNullSupported()", "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[Queue<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java.UnmodifiableQueueTest.[Queue<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link UnmodifiableQueue} implementation.\n", "original_string": "public class UnmodifiableQueueTest<E> extends AbstractQueueTest<E> {\n\n    public UnmodifiableQueueTest() {\n        super(UnmodifiableQueueTest.class.getSimpleName());\n    }\n\n    @Override\n    public Queue<E> getCollection() {\n        return super.getCollection();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isNullSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new LinkedList<>();\n    }\n\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        return new LinkedList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    public Queue<E> makeFullCollection() {\n        final Queue<E> queue = new LinkedList<>(Arrays.asList(getFullElements()));\n        return UnmodifiableQueue.unmodifiableQueue(queue);\n    }\n\n    @Override\n    public Queue<E> makeObject() {\n        return UnmodifiableQueue.unmodifiableQueue(new LinkedList<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final Queue<E> queue = makeFullCollection();\n        assertSame(queue, UnmodifiableQueue.unmodifiableQueue(queue));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableQueue.unmodifiableQueue(null));\n    }\n\n    @Test\n    public void testOffer() {\n        final Queue<E> queue = makeFullCollection();\n        final E e = null;\n        assertThrows(UnsupportedOperationException.class, () -> queue.offer(e));\n    }\n\n    @Test\n    public void testPoll() {\n        final Queue<E> queue = makeFullCollection();\n        assertThrows(UnsupportedOperationException.class, () -> queue.poll());\n    }\n\n    @Test\n    @Override\n    public void testQueueRemove() {\n        resetEmpty();\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().remove());\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullCollection() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableQueue.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableQueue.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_getTest.java.CircularFifoQueue_getTest", "name": "CircularFifoQueue_getTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_getTest.java", "superclasses": "", "methods": ["[void]testGetValidIndex()", "[void]testGetInvalidIndex()", "[void]testGetAfterWrapAround()", "[void]testGetEmptyQueue()", "[void]testGetAfterClear()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_getTest.java.CircularFifoQueue_getTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CircularFifoQueue_getTest {\n    private CircularFifoQueue<String> queue;\n\n    @BeforeEach\n    public void setUp() {\n        queue = new CircularFifoQueue<>(5);\n    }\n\n    @Test\n    public void testGetValidIndex() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.add(\"4\");\n        queue.add(\"5\");\n\n        assertEquals(\"1\", queue.get(0));\n        assertEquals(\"3\", queue.get(2));\n        assertEquals(\"5\", queue.get(4));\n    }\n\n    @Test\n    public void testGetInvalidIndex() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n\n        assertThrows(NoSuchElementException.class, () -> queue.get(-1));\n        assertThrows(NoSuchElementException.class, () -> queue.get(3));\n    }\n\n    @Test\n    public void testGetAfterWrapAround() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.add(\"4\");\n        queue.add(\"5\");\n        queue.add(\"6\");\n        queue.add(\"7\");\n\n        assertEquals(\"3\", queue.get(0));\n        assertEquals(\"5\", queue.get(2));\n        assertEquals(\"7\", queue.get(4));\n    }\n\n    @Test\n    public void testGetEmptyQueue() {\n        assertThrows(NoSuchElementException.class, () -> queue.get(0));\n    }\n\n    @Test\n    public void testGetAfterClear() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.clear();\n\n        assertThrows(NoSuchElementException.class, () -> queue.get(0));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CircularFifoQueue<String> queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CircularFifoQueue<String>", "name": "queue", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_pollTest.java.CircularFifoQueue_pollTest", "name": "CircularFifoQueue_pollTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_pollTest.java", "superclasses": "", "methods": ["[void]testPollWhenQueueIsEmpty()", "[void]testPollWhenQueueHasOneElement()", "[void]testPollWhenQueueIsFull()", "[void]testPollAfterAddingAndRemovingMultipleElements()", "[void]testPollAfterClear()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_pollTest.java.CircularFifoQueue_pollTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CircularFifoQueue_pollTest {\n\n    private CircularFifoQueue<String> queue;\n\n    @BeforeEach\n    public void setUp() {\n        queue = new CircularFifoQueue<>(5);\n    }\n\n    @Test\n    public void testPollWhenQueueIsEmpty() {\n        assertNull(queue.poll());\n    }\n\n    @Test\n    public void testPollWhenQueueHasOneElement() {\n        queue.add(\"1\");\n        assertEquals(\"1\", queue.poll());\n        assertTrue(queue.isEmpty());\n    }\n\n    @Test\n    public void testPollWhenQueueIsFull() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.add(\"4\");\n        queue.add(\"5\");\n        assertEquals(\"1\", queue.poll());\n        assertEquals(4, queue.size());\n    }\n\n    @Test\n    public void testPollAfterAddingAndRemovingMultipleElements() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.add(\"4\");\n        queue.add(\"5\");\n        queue.add(\"6\");\n        queue.add(\"7\");\n        assertEquals(\"3\", queue.poll());\n        assertEquals(\"4\", queue.poll());\n        assertEquals(\"5\", queue.poll());\n        assertEquals(\"6\", queue.poll());\n        assertEquals(\"7\", queue.poll());\n        assertTrue(queue.isEmpty());\n    }\n\n    @Test\n    public void testPollAfterClear() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.clear();\n        assertNull(queue.poll());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CircularFifoQueue<String> queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CircularFifoQueue<String>", "name": "queue", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_removeTest.java.SynchronizedQueue_removeTest", "name": "SynchronizedQueue_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_removeTest.java", "superclasses": "", "methods": ["[void]testRemove()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SynchronizedQueue_removeTest {\n\n    @Test\n    public void testRemove() {\n        // Given\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(\"element1\");\n        SynchronizedQueue<String> synchronizedQueue = SynchronizedQueue.synchronizedQueue(queue);\n\n        // When\n        String removedElement = synchronizedQueue.remove();\n\n        // Then\n        assertEquals(\"element1\", removedElement);\n        assertTrue(synchronizedQueue.isEmpty());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest", "name": "CircularFifoQueueTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java", "superclasses": "", "methods": ["[void]testAddNull()", "[void]testCircularFifoQueueCircular()", "[void]testCircularFifoQueueRemove()", "[void]testConstructorException1()", "[void]testConstructorException2()", "[void]testConstructorException3()", "[void]testDefaultSizeAndGetError1()", "[void]testDefaultSizeAndGetError2()", "[void]testGetIndex()", "[void]testRemoveError1()", "[void]testRemoveError2()", "[void]testRemoveError3()", "[void]testRemoveError4()", "[void]testRemoveError5()", "[void]testRemoveError6()", "[void]testRemoveError7()", "[void]testRemoveError8()", "[void]testRemoveError9()", "[void]testRepeatedSerialization()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest.[]CircularFifoQueueTest()", "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest.[CircularFifoQueue<E>]getCollection()", "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest.[boolean]isFailFastSupported()", "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest.[boolean]isNullSupported()", "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest.[Queue<E>]makeObject()", "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java.CircularFifoQueueTest.[void]verify()"], "overrides": null, "attributes": [], "class_docstring": "\nTest cases for CircularFifoQueue.\n", "original_string": "public class CircularFifoQueueTest<E> extends AbstractQueueTest<E> {\n\n    public CircularFifoQueueTest() {\n        super(CircularFifoQueueTest.class.getSimpleName());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public CircularFifoQueue<E> getCollection() {\n        return (CircularFifoQueue<E>) super.getCollection();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * Overridden because CircularFifoQueue isn't fail fast.\n     * @return false\n     */\n    @Override\n    public boolean isFailFastSupported() {\n        return false;\n    }\n\n    /**\n     * Overridden because CircularFifoQueue doesn't allow null elements.\n     * @return false\n     */\n    @Override\n    public boolean isNullSupported() {\n        return false;\n    }\n\n    /**\n     * Returns an empty ArrayList.\n     *\n     * @return an empty ArrayList\n     */\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    /**\n     * Returns a full ArrayList.\n     *\n     * @return a full ArrayList\n     */\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        final Collection<E> c = makeConfirmedCollection();\n        c.addAll(java.util.Arrays.asList(getFullElements()));\n        return c;\n    }\n\n    /**\n     * Returns an empty CircularFifoQueue that won't overflow.\n     *\n     * @return an empty CircularFifoQueue\n     */\n    @Override\n    public Queue<E> makeObject() {\n        return new CircularFifoQueue<>(100);\n    }\n\n    @Test\n    public void testAddNull() {\n        final CircularFifoQueue<E> b = new CircularFifoQueue<>(2);\n        assertThrows(NullPointerException.class, () -> b.add(null));\n    }\n\n    /**\n     * Tests that the removal operation actually removes the first element.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCircularFifoQueueCircular() {\n        final List<E> list = new ArrayList<>();\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        final Queue<E> queue = new CircularFifoQueue<>(list);\n\n        assertTrue(queue.contains(\"A\"));\n        assertTrue(queue.contains(\"B\"));\n        assertTrue(queue.contains(\"C\"));\n\n        queue.add((E) \"D\");\n\n        assertFalse(queue.contains(\"A\"));\n        assertTrue(queue.contains(\"B\"));\n        assertTrue(queue.contains(\"C\"));\n        assertTrue(queue.contains(\"D\"));\n\n        assertEquals(\"B\", queue.peek());\n        assertEquals(\"B\", queue.remove());\n        assertEquals(\"C\", queue.remove());\n        assertEquals(\"D\", queue.remove());\n    }\n\n    /**\n     * Tests that the removal operation actually removes the first element.\n     */\n    @Test\n    public void testCircularFifoQueueRemove() {\n        resetFull();\n        final int size = getConfirmed().size();\n        for (int i = 0; i < size; i++) {\n            final Object o1 = getCollection().remove();\n            final Object o2 = ((List<?>) getConfirmed()).remove(0);\n            assertEquals(o1, o2, \"Removed objects should be equal\");\n            verify();\n        }\n\n        assertThrows(NoSuchElementException.class, () -> getCollection().remove(),\n                \"Empty queue should raise Underflow.\");\n    }\n\n    /**\n     * Tests that the constructor correctly throws an exception.\n     */\n    @Test\n    public void testConstructorException1() {\n        assertThrows(IllegalArgumentException.class, () -> new CircularFifoQueue<E>(0));\n    }\n\n    /**\n     * Tests that the constructor correctly throws an exception.\n     */\n    @Test\n    public void testConstructorException2() {\n        assertThrows(IllegalArgumentException.class, () -> new CircularFifoQueue<E>(-20));\n    }\n\n    /**\n     * Tests that the constructor correctly throws an exception.\n     */\n    @Test\n    public void testConstructorException3() {\n        assertThrows(NullPointerException.class, () -> new CircularFifoQueue<E>(null));\n    }\n\n    @Test\n    public void testDefaultSizeAndGetError1() {\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>();\n        assertEquals(32, fifo.maxSize());\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");\n        assertEquals(5, fifo.size());\n        assertThrows(NoSuchElementException.class, () -> fifo.get(5));\n    }\n\n    @Test\n    public void testDefaultSizeAndGetError2() {\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>();\n        assertEquals(32, fifo.maxSize());\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");\n        assertEquals(5, fifo.size());\n        assertThrows(NoSuchElementException.class, () -> fifo.get(-2));\n    }\n\n    @Test\n    public void testGetIndex() {\n        resetFull();\n\n        final CircularFifoQueue<E> queue = getCollection();\n        final List<E> confirmed = (List<E>) getConfirmed();\n        for (int i = 0; i < confirmed.size(); i++) {\n            assertEquals(confirmed.get(i), queue.get(i));\n        }\n\n        // remove the first two elements and check again\n        queue.remove();\n        queue.remove();\n\n        for (int i = 0; i < queue.size(); i++) {\n            assertEquals(confirmed.get(i + 2), queue.get(i));\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveError1() throws Exception {\n        // based on bug 33071\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");\n\n        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n\n        fifo.remove(\"3\");\n        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n\n        fifo.remove(\"4\");\n        assertEquals(\"[1, 2, 5]\", fifo.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveError2() throws Exception {\n        // based on bug 33071\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");\n        fifo.add((E) \"6\");\n\n        assertEquals(5, fifo.size());\n        assertEquals(\"[2, 3, 4, 5, 6]\", fifo.toString());\n\n        fifo.remove(\"3\");\n        assertEquals(\"[2, 4, 5, 6]\", fifo.toString());\n\n        fifo.remove(\"4\");\n        assertEquals(\"[2, 5, 6]\", fifo.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveError3() throws Exception {\n        // based on bug 33071\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");\n\n        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n\n        fifo.remove(\"3\");\n        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n\n        fifo.add((E) \"6\");\n        fifo.add((E) \"7\");\n        assertEquals(\"[2, 4, 5, 6, 7]\", fifo.toString());\n\n        fifo.remove(\"4\");\n        assertEquals(\"[2, 5, 6, 7]\", fifo.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveError4() throws Exception {\n        // based on bug 33071\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");  // end=0\n        fifo.add((E) \"6\");  // end=1\n        fifo.add((E) \"7\");  // end=2\n\n        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n\n        fifo.remove(\"4\");  // remove element in middle of array, after start\n        assertEquals(\"[3, 5, 6, 7]\", fifo.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveError5() throws Exception {\n        // based on bug 33071\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");  // end=0\n        fifo.add((E) \"6\");  // end=1\n        fifo.add((E) \"7\");  // end=2\n\n        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n\n        fifo.remove(\"5\");  // remove element at last pos in array\n        assertEquals(\"[3, 4, 6, 7]\", fifo.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveError6() throws Exception {\n        // based on bug 33071\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");  // end=0\n        fifo.add((E) \"6\");  // end=1\n        fifo.add((E) \"7\");  // end=2\n\n        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n\n        fifo.remove(\"6\");  // remove element at position zero in array\n        assertEquals(\"[3, 4, 5, 7]\", fifo.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveError7() throws Exception {\n        // based on bug 33071\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");  // end=0\n        fifo.add((E) \"6\");  // end=1\n        fifo.add((E) \"7\");  // end=2\n\n        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n\n        fifo.remove(\"7\");  // remove element at position one in array\n        assertEquals(\"[3, 4, 5, 6]\", fifo.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveError8() throws Exception {\n        // based on bug 33071\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");  // end=0\n        fifo.add((E) \"6\");  // end=1\n        fifo.add((E) \"7\");  // end=2\n        fifo.add((E) \"8\");  // end=3\n\n        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n\n        fifo.remove(\"7\");  // remove element at position one in array, need to shift 8\n        assertEquals(\"[4, 5, 6, 8]\", fifo.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveError9() throws Exception {\n        // based on bug 33071\n        final CircularFifoQueue<E> fifo = new CircularFifoQueue<>(5);\n        fifo.add((E) \"1\");\n        fifo.add((E) \"2\");\n        fifo.add((E) \"3\");\n        fifo.add((E) \"4\");\n        fifo.add((E) \"5\");  // end=0\n        fifo.add((E) \"6\");  // end=1\n        fifo.add((E) \"7\");  // end=2\n        fifo.add((E) \"8\");  // end=3\n\n        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n\n        fifo.remove(\"8\");  // remove element at position two in array\n        assertEquals(\"[4, 5, 6, 7]\", fifo.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRepeatedSerialization() throws Exception {\n        // bug 31433\n        final CircularFifoQueue<E> b = new CircularFifoQueue<>(2);\n        b.add((E) \"a\");\n        assertEquals(1, b.size());\n        assertTrue(b.contains(\"a\"));\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        new ObjectOutputStream(bos).writeObject(b);\n\n        final CircularFifoQueue<E> b2 = (CircularFifoQueue<E>) new ObjectInputStream(\n            new ByteArrayInputStream(bos.toByteArray())).readObject();\n\n        assertEquals(1, b2.size());\n        assertTrue(b2.contains(\"a\"));\n        b2.add((E) \"b\");\n        assertEquals(2, b2.size());\n        assertTrue(b2.contains(\"a\"));\n        assertTrue(b2.contains(\"b\"));\n\n        bos = new ByteArrayOutputStream();\n        new ObjectOutputStream(bos).writeObject(b2);\n\n        final CircularFifoQueue<E> b3 = (CircularFifoQueue<E>) new ObjectInputStream(\n            new ByteArrayInputStream(bos.toByteArray())).readObject();\n\n        assertEquals(2, b3.size());\n        assertTrue(b3.contains(\"a\"));\n        assertTrue(b3.contains(\"b\"));\n        b3.add((E) \"c\");\n        assertEquals(2, b3.size());\n        assertTrue(b3.contains(\"b\"));\n        assertTrue(b3.contains(\"c\"));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CircularFifoQueue.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CircularFifoQueue.fullCollection.version4.obj\");\n//    }\n\n    /**\n     *  Runs through the regular verifications, but also verifies that\n     *  the buffer contains the same elements in the same sequence as the\n     *  list.\n     */\n    @Override\n    public void verify() {\n        super.verify();\n        final Iterator<E> iterator1 = getCollection().iterator();\n        for (final E e : getConfirmed()) {\n            assertTrue(iterator1.hasNext());\n            final Object o1 = iterator1.next();\n            final Object o2 = e;\n            assertEquals(o1, o2);\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java.TransformedQueueTest", "name": "TransformedQueueTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java", "superclasses": "", "methods": ["[void]testTransformedQueue()", "[void]testTransformedQueue_decorateTransform()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java.TransformedQueueTest.[]TransformedQueueTest()", "src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java.TransformedQueueTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java.TransformedQueueTest.[Queue<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java.TransformedQueueTest.[Queue<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java.TransformedQueueTest.[Queue<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java.TransformedQueueTest.[Queue<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link TransformedQueue} implementation.\n", "original_string": "public class TransformedQueueTest<E> extends AbstractQueueTest<E> {\n\n    public TransformedQueueTest() {\n        super(TransformedQueueTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Queue<E> makeConfirmedCollection() {\n        return new LinkedList<>();\n    }\n\n    @Override\n    public Queue<E> makeConfirmedFullCollection() {\n        return new LinkedList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Queue<E> makeFullCollection() {\n        final Queue<E> list = new LinkedList<>(Arrays.asList(getFullElements()));\n        return TransformedQueue.transformingQueue(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Queue<E> makeObject() {\n        return TransformedQueue.transformingQueue(new LinkedList<>(),\n                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Test\n    public void testTransformedQueue() {\n        final Queue<Object> queue = TransformedQueue.transformingQueue(new LinkedList<>(),\n                TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, queue.size());\n        final Object[] elements = { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n        for (int i = 0; i < elements.length; i++) {\n            queue.add(elements[i]);\n            assertEquals(i + 1, queue.size());\n            assertTrue(queue.contains(Integer.valueOf((String) elements[i])));\n            assertFalse(queue.contains(elements[i]));\n        }\n\n        assertFalse(queue.remove(elements[0]));\n        assertTrue(queue.remove(Integer.valueOf((String) elements[0])));\n\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @Test\n    public void testTransformedQueue_decorateTransform() {\n        final Queue originalQueue = new LinkedList();\n        final Object[] elements = {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        Collections.addAll(originalQueue, elements);\n        final Queue<?> queue = TransformedQueue.transformedQueue(originalQueue,\n                TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(elements.length, queue.size());\n        for (final Object el : elements) {\n            assertTrue(queue.contains(Integer.valueOf((String) el)));\n            assertFalse(queue.contains(el));\n        }\n\n        assertFalse(queue.remove(elements[0]));\n        assertTrue(queue.remove(Integer.valueOf((String) elements[0])));\n    }\n\n//  public void testCreate() throws Exception {\n//      resetEmpty();\n//      writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedQueue.emptyCollection.version4.obj\");\n//      resetFull();\n//      writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedQueue.fullCollection.version4.obj\");\n//  }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/TransformedQueue_transformedQueueTest.java.TransformedQueue_transformedQueueTest", "name": "TransformedQueue_transformedQueueTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/TransformedQueue_transformedQueueTest.java", "superclasses": "", "methods": ["[void]testTransformedQueueWithNonEmptyQueue()", "[void]testTransformedQueueWithEmptyQueue()", "[void]testTransformedQueueWithNullQueue()", "[void]testTransformedQueueWithNullTransformer()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedQueue_transformedQueueTest {\n\n    @Test\n    public void testTransformedQueueWithNonEmptyQueue() {\n        // Given\n        Queue<String> queue = new LinkedList<>();\n        queue.add(\"a\");\n        queue.add(\"b\");\n        Transformer<String, String> transformer = s -> s.toUpperCase();\n\n        // When\n        TransformedQueue<String> transformedQueue = TransformedQueue.transformedQueue(queue, transformer);\n\n        // Then\n        assertEquals(2, transformedQueue.size());\n        assertEquals(\"A\", transformedQueue.poll());\n        assertEquals(\"B\", transformedQueue.poll());\n    }\n\n    @Test\n    public void testTransformedQueueWithEmptyQueue() {\n        // Given\n        Queue<String> queue = new LinkedList<>();\n        Transformer<String, String> transformer = s -> s.toUpperCase();\n\n        // When\n        TransformedQueue<String> transformedQueue = TransformedQueue.transformedQueue(queue, transformer);\n\n        // Then\n        assertEquals(0, transformedQueue.size());\n    }\n\n    @Test\n    public void testTransformedQueueWithNullQueue() {\n        // Given\n        Queue<String> queue = null;\n        Transformer<String, String> transformer = s -> s.toUpperCase();\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> TransformedQueue.transformedQueue(queue, transformer));\n    }\n\n    @Test\n    public void testTransformedQueueWithNullTransformer() {\n        // Given\n        Queue<String> queue = new LinkedList<>();\n        queue.add(\"a\");\n        Transformer<String, String> transformer = null;\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> TransformedQueue.transformedQueue(queue, transformer));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_clearTest.java.CircularFifoQueue_clearTest", "name": "CircularFifoQueue_clearTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_clearTest.java", "superclasses": "", "methods": ["[void]testClearWithElements()", "[void]testClearEmptyQueue()", "[void]testClearFullQueue()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_clearTest.java.CircularFifoQueue_clearTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CircularFifoQueue_clearTest {\n\n    private CircularFifoQueue<String> queue;\n\n    @BeforeEach\n    public void setUp() {\n        queue = new CircularFifoQueue<>(5);\n    }\n\n    @Test\n    public void testClearWithElements() {\n        // Given\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        assertFalse(queue.isEmpty());\n\n        // When\n        queue.clear();\n\n        // Then\n        assertTrue(queue.isEmpty());\n        assertEquals(0, queue.size());\n    }\n\n    @Test\n    public void testClearEmptyQueue() {\n        // Given\n        assertTrue(queue.isEmpty());\n\n        // When\n        queue.clear();\n\n        // Then\n        assertTrue(queue.isEmpty());\n        assertEquals(0, queue.size());\n    }\n\n    @Test\n    public void testClearFullQueue() {\n        // Given\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.add(\"4\");\n        queue.add(\"5\");\n        assertTrue(queue.isAtFullCapacity());\n\n        // When\n        queue.clear();\n\n        // Then\n        assertTrue(queue.isEmpty());\n        assertEquals(0, queue.size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CircularFifoQueue<String> queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CircularFifoQueue<String>", "name": "queue", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_elementTest.java.CircularFifoQueue_elementTest", "name": "CircularFifoQueue_elementTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_elementTest.java", "superclasses": "", "methods": ["[void]testElementWhenQueueIsEmpty()", "[void]testElementWhenQueueHasOneElement()", "[void]testElementWhenQueueIsFull()", "[void]testElementAfterRemovingElement()", "[void]testElementAfterAddingAndRemovingElements()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/CircularFifoQueue_elementTest.java.CircularFifoQueue_elementTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CircularFifoQueue_elementTest {\n    private CircularFifoQueue<String> queue;\n\n    @BeforeEach\n    public void setUp() {\n        queue = new CircularFifoQueue<>(5);\n    }\n\n    @Test\n    public void testElementWhenQueueIsEmpty() {\n        assertThrows(NoSuchElementException.class, () -> queue.element());\n    }\n\n    @Test\n    public void testElementWhenQueueHasOneElement() {\n        queue.add(\"1\");\n        assertEquals(\"1\", queue.element());\n    }\n\n    @Test\n    public void testElementWhenQueueIsFull() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.add(\"4\");\n        queue.add(\"5\");\n        assertEquals(\"1\", queue.element());\n    }\n\n    @Test\n    public void testElementAfterRemovingElement() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.remove();\n        assertEquals(\"2\", queue.element());\n    }\n\n    @Test\n    public void testElementAfterAddingAndRemovingElements() {\n        queue.add(\"1\");\n        queue.add(\"2\");\n        queue.add(\"3\");\n        queue.add(\"4\");\n        queue.add(\"5\");\n        queue.remove();\n        queue.remove();\n        queue.add(\"6\");\n        queue.add(\"7\");\n        assertEquals(\"3\", queue.element());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CircularFifoQueue<String> queue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CircularFifoQueue<String>", "name": "queue", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_offerTest.java.SynchronizedQueue_offerTest", "name": "SynchronizedQueue_offerTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/SynchronizedQueue_offerTest.java", "superclasses": "", "methods": ["[void]testOffer()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SynchronizedQueue_offerTest {\n\n    @Test\n    public void testOffer() {\n        // Given\n        Queue<String> mockQueue = mock(Queue.class);\n        SynchronizedQueue<String> synchronizedQueue = SynchronizedQueue.synchronizedQueue(mockQueue);\n        String element = \"testElement\";\n\n        // When\n        when(mockQueue.offer(element)).thenReturn(true);\n        boolean result = synchronizedQueue.offer(element);\n\n        // Then\n        assertTrue(result);\n        verify(mockQueue, times(1)).offer(element);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/CollectionBag_retainAllTest.java.CollectionBag_retainAllTest", "name": "CollectionBag_retainAllTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/CollectionBag_retainAllTest.java", "superclasses": "", "methods": ["[void]testRetainAll_NonEmptyCollection()", "[void]testRetainAll_NullCollection()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/CollectionBag_retainAllTest.java.CollectionBag_retainAllTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CollectionBag_retainAllTest {\n\n    private CollectionBag<String> bag;\n    private Bag<String> decoratedBag;\n\n    @BeforeEach\n    public void setUp() {\n        decoratedBag = Mockito.mock(Bag.class);\n        bag = new CollectionBag<>(decoratedBag);\n    }\n\n    @Test\n    public void testRetainAll_NonEmptyCollection() {\n        // Given\n        Collection<String> coll = Arrays.asList(\"A\", \"B\");\n        Iterator<String> iterator = mock(Iterator.class);\n        when(decoratedBag.iterator()).thenReturn(iterator);\n        when(iterator.hasNext()).thenReturn(true, true, false);\n        when(iterator.next()).thenReturn(\"A\", \"C\");\n        when(decoratedBag.contains(\"A\")).thenReturn(true);\n        when(decoratedBag.contains(\"C\")).thenReturn(false);\n\n        // When\n        boolean result = bag.retainAll(coll);\n\n        // Then\n        assertTrue(result);\n        verify(iterator).remove();\n    }\n\n    @Test\n    public void testRetainAll_NullCollection() {\n        // When\n        boolean result = bag.retainAll(null);\n\n        // Then\n        assertFalse(result);\n        verify(decoratedBag).retainAll(null);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CollectionBag<String> bag;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CollectionBag<String>", "name": "bag", "syntax_pass": true}, {"attribute_expression": "private Bag<String> decoratedBag;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Bag<String>", "name": "decoratedBag", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bag/CollectionBag_removeAllTest.java.CollectionBag_removeAllTest", "name": "CollectionBag_removeAllTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/CollectionBag_removeAllTest.java", "superclasses": "", "methods": ["[void]testRemoveAll_WithNonNullCollection()", "[void]testRemoveAll_WithNullCollection()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/CollectionBag_removeAllTest.java.CollectionBag_removeAllTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CollectionBag_removeAllTest {\n\n    private CollectionBag<String> bag;\n    private Bag<String> decoratedBag;\n\n    @BeforeEach\n    public void setUp() {\n        decoratedBag = Mockito.mock(Bag.class);\n        bag = new CollectionBag<>(decoratedBag);\n    }\n\n    @Test\n    public void testRemoveAll_WithNonNullCollection() {\n        Collection<String> coll = Arrays.asList(\"A\", \"B\", \"C\");\n        when(decoratedBag.remove(\"A\", 1)).thenReturn(true);\n        when(decoratedBag.remove(\"B\", 1)).thenReturn(false);\n        when(decoratedBag.remove(\"C\", 1)).thenReturn(true);\n        when(decoratedBag.getCount(\"A\")).thenReturn(1);\n        when(decoratedBag.getCount(\"B\")).thenReturn(1);\n        when(decoratedBag.getCount(\"C\")).thenReturn(1);\n\n        boolean result = bag.removeAll(coll);\n\n        assertTrue(result);\n        verify(decoratedBag, times(1)).remove(\"A\", 1);\n        verify(decoratedBag, times(1)).remove(\"B\", 1);\n        verify(decoratedBag, times(1)).remove(\"C\", 1);\n    }\n\n    @Test\n    public void testRemoveAll_WithNullCollection() {\n        when(decoratedBag.removeAll(null)).thenReturn(true);\n\n        boolean result = bag.removeAll(null);\n\n        assertTrue(result);\n        verify(decoratedBag, times(1)).removeAll(null);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CollectionBag<String> bag;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CollectionBag<String>", "name": "bag", "syntax_pass": true}, {"attribute_expression": "private Bag<String> decoratedBag;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Bag<String>", "name": "decoratedBag", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bag/CollectionBagTest.java.CollectionBagTest", "name": "CollectionBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/CollectionBagTest.java", "superclasses": "", "methods": ["[void]testEmptyBagCompatibility()", "[void]testFullBagCompatibility()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/CollectionBagTest.java.CollectionBagTest.[]CollectionBagTest()", "src/test/java/org/apache/commons/collections4/bag/CollectionBagTest.java.CollectionBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/CollectionBagTest.java.CollectionBagTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/bag/CollectionBagTest.java.CollectionBagTest.[Collection<T>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/bag/CollectionBagTest.java.CollectionBagTest.[Collection<T>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/bag/CollectionBagTest.java.CollectionBagTest.[Bag<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTest class for {@link CollectionBag}.\n<p>\nNote: This test is mainly for serialization support, the CollectionBag decorator\nis extensively used and tested in AbstractBagTest.\n", "original_string": "public class CollectionBagTest<T> extends AbstractCollectionTest<T> {\n\n    /**\n     * JUnit constructor.\n     */\n    public CollectionBagTest() {\n        super(CollectionBagTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    /**\n     * Returns an empty List for use in modification testing.\n     *\n     * @return a confirmed empty collection\n     */\n    @Override\n    public Collection<T> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    /**\n     * Returns a full Set for use in modification testing.\n     *\n     * @return a confirmed full collection\n     */\n    @Override\n    public Collection<T> makeConfirmedFullCollection() {\n        final Collection<T> set = makeConfirmedCollection();\n        set.addAll(Arrays.asList(getFullElements()));\n        return set;\n    }\n\n    @Override\n    public Bag<T> makeObject() {\n        return CollectionBag.collectionBag(new HashBag<>());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CollectionBag.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CollectionBag.fullCollection.version4.obj\");\n//    }\n\n    /**\n     * Compares the current serialized form of the Bag\n     * against the canonical version in SCM.\n     */\n    @Test\n    public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {\n        // test to make sure the canonical form has been preserved\n        final Bag<T> bag = makeObject();\n        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));\n            assertTrue(bag2.isEmpty(), \"Bag is empty\");\n            assertEquals(bag, bag2);\n        }\n    }\n\n    /**\n     * Compares the current serialized form of the Bag\n     * against the canonical version in SCM.\n     */\n    @Test\n    public void testFullBagCompatibility() throws IOException, ClassNotFoundException {\n        // test to make sure the canonical form has been preserved\n        final Bag<T> bag = (Bag<T>) makeFullCollection();\n        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));\n            assertEquals(bag.size(), bag2.size(), \"Bag is the right size\");\n            assertEquals(bag, bag2);\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java.UnmodifiableSortedBagTest", "name": "UnmodifiableSortedBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java.UnmodifiableSortedBagTest.[]UnmodifiableSortedBagTest()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java.UnmodifiableSortedBagTest.[SortedBag<E>]getCollection()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java.UnmodifiableSortedBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java.UnmodifiableSortedBagTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java.UnmodifiableSortedBagTest.[boolean]isNullSupported()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java.UnmodifiableSortedBagTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java.UnmodifiableSortedBagTest.[SortedBag<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java.UnmodifiableSortedBagTest.[SortedBag<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link UnmodifiableSortedBag} implementation.\n", "original_string": "public class UnmodifiableSortedBagTest<E> extends AbstractSortedBagTest<E> {\n\n    public UnmodifiableSortedBagTest() {\n        super(UnmodifiableSortedBagTest.class.getSimpleName());\n    }\n\n    @Override\n    public SortedBag<E> getCollection() {\n        return super.getCollection();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isNullSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public SortedBag<E> makeFullCollection() {\n        final SortedBag<E> bag = new TreeBag<>();\n        bag.addAll(Arrays.asList(getFullElements()));\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    @Override\n    public SortedBag<E> makeObject() {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final SortedBag<E> queue = makeFullCollection();\n        assertSame(queue, UnmodifiableSortedBag.unmodifiableSortedBag(queue));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableSortedBag.unmodifiableSortedBag(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullCollection() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        SortedBag<E> bag = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/UnmodifiableSortedBag.emptyCollection.version4.obj\");\n//        bag = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/UnmodifiableSortedBag.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java.PredicatedBagTest", "name": "PredicatedBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java", "superclasses": "", "methods": ["[void]testIllegalAdd()", "[void]testIllegalDecorate()", "[void]testLegalAddRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java.PredicatedBagTest.[]PredicatedBagTest()", "src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java.PredicatedBagTest.[Bag<T>]decorateBag(HashBag<T>,Predicate<T>)", "src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java.PredicatedBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java.PredicatedBagTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java.PredicatedBagTest.[Bag<T>]makeObject()", "src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java.PredicatedBagTest.[Bag<T>]makeTestBag()", "src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java.PredicatedBagTest.[Predicate<T>]stringPredicate()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractBagTest} for exercising the {@link PredicatedBag}\nimplementation.\n", "original_string": "public class PredicatedBagTest<T> extends AbstractBagTest<T> {\n\n    protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n\n    public PredicatedBagTest() {\n        super(PredicatedBagTest.class.getSimpleName());\n    }\n\n    protected Bag<T> decorateBag(final HashBag<T> bag, final Predicate<T> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public Bag<T> makeObject() {\n        return decorateBag(new HashBag<>(), truePredicate);\n    }\n\n    protected Bag<T> makeTestBag() {\n        return decorateBag(new HashBag<>(), stringPredicate());\n    }\n\n    protected Predicate<T> stringPredicate() {\n        return String.class::isInstance;\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAdd() {\n        final Bag<T> bag = makeTestBag();\n        final Integer i = 3;\n\n        assertThrows(IllegalArgumentException.class, () -> bag.add((T) i));\n\n        assertFalse(bag.contains(i), \"Collection shouldn't contain illegal element\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalDecorate() {\n        final HashBag<Object> elements = new HashBag<>();\n        elements.add(\"one\");\n        elements.add(\"two\");\n        elements.add(3);\n        elements.add(\"four\");\n\n        assertThrows(IllegalArgumentException.class, () -> decorateBag((HashBag<T>) elements, stringPredicate()));\n\n        assertThrows(NullPointerException.class, () -> decorateBag(new HashBag<>(), null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLegalAddRemove() {\n        final Bag<T> bag = makeTestBag();\n        assertEquals(0, bag.size());\n        final T[] els = (T[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"1\" };\n        for (int i = 0; i < els.length; i++) {\n            bag.add(els[i]);\n            assertEquals(i + 1, bag.size());\n            assertTrue(bag.contains(els[i]));\n        }\n        Set<T> set = bag.uniqueSet();\n        assertTrue(set.contains(els[0]), \"Unique set contains the first element\");\n        assertTrue(bag.remove(els[0]));\n        set = bag.uniqueSet();\n        assertFalse(set.contains(els[0]), \"Unique set now does not contain the first element\");\n    }\n\n//    public void testCreate() throws Exception {\n//        Bag<T> bag = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/PredicatedBag.emptyCollection.version4.obj\");\n//        bag = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/PredicatedBag.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<T>", "name": "truePredicate = TruePredicate.<T>truePredicate()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bag/TransformedBag_uniqueSetTest.java.TransformedBag_uniqueSetTest", "name": "TransformedBag_uniqueSetTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/TransformedBag_uniqueSetTest.java", "superclasses": "", "methods": ["[void]testUniqueSet()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedBag_uniqueSetTest {\n\n    @Test\n    public void testUniqueSet() {\n        // Given\n        Bag<String> mockBag = Mockito.mock(Bag.class);\n        Transformer<String, String> mockTransformer = Mockito.mock(Transformer.class);\n        Set<String> mockUniqueSet = new HashSet<>();\n        mockUniqueSet.add(\"element\");\n\n        when(mockBag.uniqueSet()).thenReturn(mockUniqueSet);\n\n        TransformedBag<String> transformedBag = new TransformedBag<>(mockBag, mockTransformer);\n\n        // When\n        Set<String> resultSet = transformedBag.uniqueSet();\n\n        // Then\n        assertEquals(TransformedSet.class, resultSet.getClass());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/CollectionBag_addAllTest.java.CollectionBag_addAllTest", "name": "CollectionBag_addAllTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/CollectionBag_addAllTest.java", "superclasses": "", "methods": ["[void]testAddAll()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CollectionBag_addAllTest {\n\n    @Test\n    public void testAddAll() {\n        // Given\n        Bag<String> bag = new CollectionBag<>(new HashBag<>());\n        Collection<String> coll = Arrays.asList(\"A\", \"B\", \"C\");\n\n        // When\n        boolean changed = bag.addAll(coll);\n\n        // Then\n        assertTrue(changed);\n        assertTrue(bag.containsAll(coll));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBag_uniqueSetTest.java.UnmodifiableBag_uniqueSetTest", "name": "UnmodifiableBag_uniqueSetTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBag_uniqueSetTest.java", "superclasses": "", "methods": ["[void]testUniqueSet()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnmodifiableBag_uniqueSetTest {\n\n    @Test\n    public void testUniqueSet() {\n        // Given\n        Bag<String> bag = new HashBag<>();\n        bag.add(\"apple\");\n        bag.add(\"banana\");\n        bag.add(\"apple\");\n\n        Bag<String> unmodifiableBag = UnmodifiableBag.unmodifiableBag(bag);\n\n        // When\n        Set<String> uniqueSet = unmodifiableBag.uniqueSet();\n\n        // Then\n        assertTrue(uniqueSet instanceof UnmodifiableSet);\n        assertTrue(uniqueSet.contains(\"apple\"));\n        assertTrue(uniqueSet.contains(\"banana\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest", "name": "UnmodifiableBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest.[]UnmodifiableBagTest()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest.[Bag<E>]getCollection()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest.[boolean]isNullSupported()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest.[Bag<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java.UnmodifiableBagTest.[Bag<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link UnmodifiableBag} implementation.\n", "original_string": "public class UnmodifiableBagTest<E> extends AbstractBagTest<E> {\n\n    public UnmodifiableBagTest() {\n        super(UnmodifiableBagTest.class.getSimpleName());\n    }\n\n    @Override\n    public Bag<E> getCollection() {\n        return super.getCollection();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isNullSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public Bag<E> makeFullCollection() {\n        final Bag<E> bag = new HashBag<>();\n        bag.addAll(Arrays.asList(getFullElements()));\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    @Override\n    public Bag<E> makeObject() {\n        return UnmodifiableBag.unmodifiableBag(new HashBag<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final Bag<E> queue = makeFullCollection();\n        assertSame(queue, UnmodifiableBag.unmodifiableBag(queue));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableBag.unmodifiableBag(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullCollection() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        Bag<E> bag = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/UnmodifiableBag.emptyCollection.version4.obj\");\n//        bag = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/UnmodifiableBag.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java.PredicatedSortedBagTest", "name": "PredicatedSortedBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java", "superclasses": "", "methods": ["[void]testDecorate()", "[void]testSortOrder()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java.PredicatedSortedBagTest.[]PredicatedSortedBagTest()", "src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java.PredicatedSortedBagTest.[SortedBag<T>]decorateBag(SortedBag<T>,Predicate<T>)", "src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java.PredicatedSortedBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java.PredicatedSortedBagTest.[SortedBag<T>]makeObject()", "src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java.PredicatedSortedBagTest.[SortedBag<T>]makeTestBag()", "src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java.PredicatedSortedBagTest.[Predicate<T>]stringPredicate()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSortedBagTest} for exercising the {@link PredicatedSortedBag}\nimplementation.\n", "original_string": "public class PredicatedSortedBagTest<T> extends AbstractSortedBagTest<T> {\n\n    private final SortedBag<T> nullBag = null;\n\n    protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n\n    public PredicatedSortedBagTest() {\n        super(PredicatedSortedBagTest.class.getSimpleName());\n    }\n\n    protected SortedBag<T> decorateBag(final SortedBag<T> bag, final Predicate<T> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public SortedBag<T> makeObject() {\n        return decorateBag(new TreeBag<>(), truePredicate);\n    }\n\n    protected SortedBag<T> makeTestBag() {\n        return decorateBag(new TreeBag<>(), stringPredicate());\n    }\n\n    protected Predicate<T> stringPredicate() {\n        return String.class::isInstance;\n    }\n\n    @Test\n    public void testDecorate() {\n        final SortedBag<T> bag = decorateBag(new TreeBag<>(), stringPredicate());\n        ((PredicatedSortedBag<T>) bag).decorated();\n\n        assertThrows(NullPointerException.class, () -> decorateBag(new TreeBag<>(), null));\n\n        assertThrows(NullPointerException.class, () -> decorateBag(nullBag, stringPredicate()));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSortOrder() {\n        final SortedBag<T> bag = decorateBag(new TreeBag<>(), stringPredicate());\n        final String one = \"one\";\n        final String two = \"two\";\n        final String three = \"three\";\n        bag.add((T) one);\n        bag.add((T) two);\n        bag.add((T) three);\n        assertEquals(bag.first(), one, \"first element\");\n        assertEquals(bag.last(), two, \"last element\");\n        final Comparator<? super T> c = bag.comparator();\n        assertNull(c, \"natural order, so comparator should be null\");\n    }\n\n//    public void testCreate() throws Exception {\n//        Bag<T> bag = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/PredicatedSortedBag.emptyCollection.version4.obj\");\n//        bag = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/PredicatedSortedBag.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final SortedBag<T> nullBag = null;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SortedBag<T>", "name": "nullBag = null", "syntax_pass": true}, {"attribute_expression": "protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<T>", "name": "truePredicate = TruePredicate.<T>truePredicate()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bag/TreeBagTest.java.TreeBagTest", "name": "TreeBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/TreeBagTest.java", "superclasses": "", "methods": ["[void]testCollections265()", "[void]testCollections555()", "[void]testOrdering()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/TreeBagTest.java.TreeBagTest.[]TreeBagTest()", "src/test/java/org/apache/commons/collections4/bag/TreeBagTest.java.TreeBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/TreeBagTest.java.TreeBagTest.[SortedBag<T>]makeObject()", "src/test/java/org/apache/commons/collections4/bag/TreeBagTest.java.TreeBagTest.[SortedBag<T>]setupBag()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractBagTest} for exercising the {@link TreeBag}\nimplementation.\n", "original_string": "public class TreeBagTest<T> extends AbstractSortedBagTest<T> {\n\n    public TreeBagTest() {\n        super(TreeBagTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public SortedBag<T> makeObject() {\n        return new TreeBag<>();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public SortedBag<T> setupBag() {\n        final SortedBag<T> bag = makeObject();\n        bag.add((T) \"C\");\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        bag.add((T) \"D\");\n        return bag;\n    }\n\n    @Test\n    public void testCollections265() {\n        final Bag<Object> bag = new TreeBag<>();\n\n        assertThrows(IllegalArgumentException.class, () -> bag.add(new Object()));\n    }\n\n    @Test\n    public void testCollections555() {\n        final Bag<Object> bag = new TreeBag<>();\n\n        assertThrows(NullPointerException.class, () -> bag.add(null));\n\n        final Bag<String> bag2 = new TreeBag<>(String::compareTo);\n        // jdk bug: adding null to an empty TreeMap works\n        // thus ensure that the bag is not empty before adding null\n        bag2.add(\"a\");\n\n        assertThrows(NullPointerException.class, () -> bag2.add(null));\n    }\n\n    @Test\n    public void testOrdering() {\n        final Bag<T> bag = setupBag();\n        assertEquals(\"A\", bag.toArray()[0], \"Should get elements in correct order\");\n        assertEquals(\"B\", bag.toArray()[1], \"Should get elements in correct order\");\n        assertEquals(\"C\", bag.toArray()[2], \"Should get elements in correct order\");\n        assertEquals(\"A\", ((SortedBag<T>) bag).first(), \"Should get first key\");\n        assertEquals(\"D\", ((SortedBag<T>) bag).last(), \"Should get last key\");\n    }\n\n//    public void testCreate() throws Exception {\n//        Bag<T> bag = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TreeBag.emptyCollection.version4.obj\");\n//        bag = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TreeBag.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/TransformedBag_transformedBagTest.java.TransformedBag_transformedBagTest", "name": "TransformedBag_transformedBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/TransformedBag_transformedBagTest.java", "superclasses": "", "methods": ["[void]testTransformedBagWithNonEmptyBag()", "[void]testTransformedBagWithEmptyBag()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedBag_transformedBagTest {\n\n    @Test\n    public void testTransformedBagWithNonEmptyBag() {\n        // Given\n        Bag<String> mockBag = mock(Bag.class);\n        Transformer<String, String> mockTransformer = mock(Transformer.class);\n        when(mockBag.isEmpty()).thenReturn(false);\n        when(mockBag.toArray()).thenReturn(new String[]{\"a\", \"b\"});\n        when(mockTransformer.apply(\"a\")).thenReturn(\"A\");\n        when(mockTransformer.apply(\"b\")).thenReturn(\"B\");\n\n        // When\n        Bag<String> resultBag = TransformedBag.transformedBag(mockBag, mockTransformer);\n\n        // Then\n        verify(mockBag).clear();\n        verify(mockBag).add(\"A\");\n        verify(mockBag).add(\"B\");\n        assertNotNull(resultBag);\n    }\n\n    @Test\n    public void testTransformedBagWithEmptyBag() {\n        // Given\n        Bag<String> mockBag = mock(Bag.class);\n        Transformer<String, String> mockTransformer = mock(Transformer.class);\n        when(mockBag.isEmpty()).thenReturn(true);\n\n        // When\n        Bag<String> resultBag = TransformedBag.transformedBag(mockBag, mockTransformer);\n\n        // Then\n        verify(mockBag, never()).clear();\n        verify(mockBag, never()).add(anyString());\n        assertNotNull(resultBag);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/CollectionBag_addTest.java.CollectionBag_addTest", "name": "CollectionBag_addTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/CollectionBag_addTest.java", "superclasses": "", "methods": ["[void]testAdd()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/CollectionBag_addTest.java.CollectionBag_addTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CollectionBag_addTest {\n\n    private Bag<String> mockBag;\n    private CollectionBag<String> collectionBag;\n\n    @BeforeEach\n    void setUp() {\n        mockBag = mock(Bag.class);\n        collectionBag = new CollectionBag<>(mockBag);\n    }\n\n    @Test\n    void testAdd() {\n        String object = \"testObject\";\n        int count = 5;\n\n        boolean result = collectionBag.add(object, count);\n\n        verify(mockBag).add(object, count);\n        assertTrue(result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Bag<String> mockBag;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Bag<String>", "name": "mockBag", "syntax_pass": true}, {"attribute_expression": "private CollectionBag<String> collectionBag;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CollectionBag<String>", "name": "collectionBag", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBag_addAllTest.java.CollectionSortedBag_addAllTest", "name": "CollectionSortedBag_addAllTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBag_addAllTest.java", "superclasses": "", "methods": ["[void]testAddAll_WithNonEmptyCollection()", "[void]testAddAll_WithEmptyCollection()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CollectionSortedBag_addAllTest {\n\n    @Test\n    public void testAddAll_WithNonEmptyCollection() {\n        // Given\n        SortedBag<String> mockBag = mock(SortedBag.class);\n        CollectionSortedBag<String> bag = new CollectionSortedBag<>(mockBag);\n        when(mockBag.add(anyString(), eq(1))).thenReturn(true);\n\n        // When\n        boolean result = bag.addAll(Arrays.asList(\"a\", \"b\", \"c\"));\n\n        // Then\n        assertTrue(result);\n        verify(mockBag, times(3)).add(anyString(), eq(1));\n    }\n\n    @Test\n    public void testAddAll_WithEmptyCollection() {\n        // Given\n        SortedBag<String> mockBag = mock(SortedBag.class);\n        CollectionSortedBag<String> bag = new CollectionSortedBag<>(mockBag);\n\n        // When\n        boolean result = bag.addAll(Collections.emptyList());\n\n        // Then\n        assertFalse(result);\n        verify(mockBag, never()).add(anyString(), anyInt());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/TransformedSortedBagTest.java.TransformedSortedBagTest", "name": "TransformedSortedBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/TransformedSortedBagTest.java", "superclasses": "", "methods": ["[void]testTransformedBag()", "[void]testTransformedBag_decorateTransform()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/TransformedSortedBagTest.java.TransformedSortedBagTest.[]TransformedSortedBagTest()", "src/test/java/org/apache/commons/collections4/bag/TransformedSortedBagTest.java.TransformedSortedBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/TransformedSortedBagTest.java.TransformedSortedBagTest.[SortedBag<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSortedBagTest} for exercising the {@link TransformedSortedBag}\nimplementation.\n", "original_string": "public class TransformedSortedBagTest<T> extends AbstractSortedBagTest<T> {\n\n    public TransformedSortedBagTest() {\n        super(TransformedSortedBagTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SortedBag<T> makeObject() {\n        return TransformedSortedBag.transformingSortedBag(new TreeBag<>(), (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testTransformedBag() {\n        final SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<>(), (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, bag.size());\n        final Object[] els = {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        for (int i = 0; i < els.length; i++) {\n            bag.add((T) els[i]);\n            assertEquals(i + 1, bag.size());\n            assertTrue(bag.contains(Integer.valueOf((String) els[i])));\n        }\n\n        assertTrue(bag.remove(Integer.valueOf((String) els[0])));\n\n    }\n\n    @Test\n    public void testTransformedBag_decorateTransform() {\n        final TreeBag<T> originalBag = new TreeBag<>();\n        final Object[] els = {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        for (final Object el : els) {\n            originalBag.add((T) el);\n        }\n        final SortedBag<T> bag = TransformedSortedBag.transformedSortedBag(originalBag, (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(els.length, bag.size());\n        for (final Object el : els) {\n            assertTrue(bag.contains(Integer.valueOf((String) el)));\n        }\n\n        assertTrue(bag.remove(Integer.valueOf((String) els[0])));\n    }\n\n//    public void testCreate() throws Exception {\n//        Bag<T> bag = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TransformedSortedBag.emptyCollection.version4.obj\");\n//        bag = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TransformedSortedBag.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/TransformedBagTest.java.TransformedBagTest", "name": "TransformedBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/TransformedBagTest.java", "superclasses": "", "methods": ["[void]testTransformedBag()", "[void]testTransformedBag_decorateTransform()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/TransformedBagTest.java.TransformedBagTest.[]TransformedBagTest()", "src/test/java/org/apache/commons/collections4/bag/TransformedBagTest.java.TransformedBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/TransformedBagTest.java.TransformedBagTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/bag/TransformedBagTest.java.TransformedBagTest.[Bag<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractBagTest} for exercising the {@link TransformedBag}\nimplementation.\n", "original_string": "public class TransformedBagTest<T> extends AbstractBagTest<T> {\n\n    public TransformedBagTest() {\n        super(TransformedBagTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Bag<T> makeObject() {\n        return TransformedBag.transformingBag(new HashBag<>(),\n                (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testTransformedBag() {\n        //T had better be Object!\n        final Bag<T> bag = TransformedBag.transformingBag(new HashBag<>(),\n                (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertTrue(bag.isEmpty());\n        final Object[] els = {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        for (int i = 0; i < els.length; i++) {\n            bag.add((T) els[i]);\n            assertEquals(i + 1, bag.size());\n            assertTrue(bag.contains(Integer.valueOf((String) els[i])));\n            assertFalse(bag.contains(els[i]));\n        }\n\n        assertFalse(bag.remove(els[0]));\n        assertTrue(bag.remove(Integer.valueOf((String) els[0])));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testTransformedBag_decorateTransform() {\n        final Bag<T> originalBag = new HashBag<>();\n        final Object[] els = {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        for (final Object el : els) {\n            originalBag.add((T) el);\n        }\n        final Bag<T> bag = TransformedBag.transformedBag(originalBag,\n                (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(els.length, bag.size());\n        for (final Object el : els) {\n            assertTrue(bag.contains(Integer.valueOf((String) el)));\n            assertFalse(bag.contains(el));\n        }\n\n        assertFalse(bag.remove(els[0]));\n        assertTrue(bag.remove(Integer.valueOf((String) els[0])));\n    }\n\n//    public void testCreate() throws Exception {\n//        Bag<T> bag = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TransformedBag.emptyCollection.version4.obj\");\n//        bag = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TransformedBag.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBag_addTest.java.CollectionSortedBag_addTest", "name": "CollectionSortedBag_addTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBag_addTest.java", "superclasses": "", "methods": ["[void]testAdd()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/CollectionSortedBag_addTest.java.CollectionSortedBag_addTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CollectionSortedBag_addTest {\n\n    private SortedBag<String> mockSortedBag;\n    private CollectionSortedBag<String> collectionSortedBag;\n\n    @BeforeEach\n    void setUp() {\n        mockSortedBag = mock(SortedBag.class);\n        collectionSortedBag = new CollectionSortedBag<>(mockSortedBag);\n    }\n\n    @Test\n    void testAdd() {\n        String element = \"testElement\";\n        int count = 1;\n\n        boolean result = collectionSortedBag.add(element, count);\n\n        assertTrue(result);\n        verify(mockSortedBag).add(element, count);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private SortedBag<String> mockSortedBag;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SortedBag<String>", "name": "mockSortedBag", "syntax_pass": true}, {"attribute_expression": "private CollectionSortedBag<String> collectionSortedBag;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CollectionSortedBag<String>", "name": "collectionSortedBag", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java.CollectionSortedBagTest", "name": "CollectionSortedBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java", "superclasses": "", "methods": ["[void]testEmptyBagCompatibility()", "[void]testFullBagCompatibility()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java.CollectionSortedBagTest.[]CollectionSortedBagTest()", "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java.CollectionSortedBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java.CollectionSortedBagTest.[T[]]getFullNonNullElements()", "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java.CollectionSortedBagTest.[T[]]getOtherNonNullElements()", "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java.CollectionSortedBagTest.[boolean]isNullSupported()", "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java.CollectionSortedBagTest.[Collection<T>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java.CollectionSortedBagTest.[Collection<T>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/bag/CollectionSortedBagTest.java.CollectionSortedBagTest.[Bag<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTest class for {@link CollectionSortedBag}.\n<p>\nNote: This test is mainly for serialization support, the CollectionSortedBag decorator\nis extensively used and tested in AbstractSortedBagTest.\n", "original_string": "public class CollectionSortedBagTest<T> extends AbstractCollectionTest<T> {\n\n    /**\n     * JUnit constructor.\n     */\n    public CollectionSortedBagTest() {\n        super(CollectionSortedBagTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * Override to return comparable objects.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T[] getFullNonNullElements() {\n        final Object[] elements = new Object[30];\n\n        for (int i = 0; i < 30; i++) {\n            elements[i] = Integer.valueOf(i + i + 1);\n        }\n        return (T[]) elements;\n    }\n\n    /**\n     * Override to return comparable objects.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T[] getOtherNonNullElements() {\n        final Object[] elements = new Object[30];\n        for (int i = 0; i < 30; i++) {\n            elements[i] = Integer.valueOf(i + i + 2);\n        }\n        return (T[]) elements;\n    }\n\n    /**\n     * Overridden because SortedBags don't allow null elements (normally).\n     * @return false\n     */\n    @Override\n    public boolean isNullSupported() {\n        return false;\n    }\n\n    /**\n     * Returns an empty List for use in modification testing.\n     *\n     * @return a confirmed empty collection\n     */\n    @Override\n    public Collection<T> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    /**\n     * Returns a full Set for use in modification testing.\n     *\n     * @return a confirmed full collection\n     */\n    @Override\n    public Collection<T> makeConfirmedFullCollection() {\n        final Collection<T> set = makeConfirmedCollection();\n        set.addAll(Arrays.asList(getFullElements()));\n        return set;\n    }\n\n    @Override\n    public Bag<T> makeObject() {\n        return CollectionSortedBag.collectionSortedBag(new TreeBag<>());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CollectionSortedBag.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CollectionSortedBag.fullCollection.version4.obj\");\n//    }\n\n    /**\n     * Compare the current serialized form of the Bag\n     * against the canonical version in SCM.\n     */\n    @Test\n    public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {\n        // test to make sure the canonical form has been preserved\n        final Bag<T> bag = makeObject();\n        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));\n            assertEquals(0, bag2.size(), \"Bag is empty\");\n            assertEquals(bag, bag2);\n        }\n    }\n\n    /**\n     * Compare the current serialized form of the Bag\n     * against the canonical version in SCM.\n     */\n    @Test\n    public void testFullBagCompatibility() throws IOException, ClassNotFoundException {\n        // test to make sure the canonical form has been preserved\n        final SortedBag<T> bag = (SortedBag<T>) makeFullCollection();\n        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final SortedBag<?> bag2 = (SortedBag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));\n            assertEquals(bag.size(), bag2.size(), \"Bag is the right size\");\n            assertEquals(bag, bag2);\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/TreeBag_addTest.java.TreeBag_addTest", "name": "TreeBag_addTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/TreeBag_addTest.java", "superclasses": "", "methods": ["[void]testAddWithComparableObject()", "[void]testAddWithNonComparableObjectAndNoComparator()", "[void]testAddWithNonComparableObjectAndCustomComparator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class TreeBag_addTest {\n\n    @Test\n    void testAddWithComparableObject() {\n        TreeBag<String> bag = new TreeBag<>();\n        assertTrue(bag.add(\"test\"));\n    }\n\n    @Test\n    void testAddWithNonComparableObjectAndNoComparator() {\n        TreeBag<Object> bag = new TreeBag<>();\n        assertThrows(IllegalArgumentException.class, () -> bag.add(new Object()));\n    }\n\n    @Test\n    void testAddWithNonComparableObjectAndCustomComparator() {\n        Comparator<Object> customComparator = (o1, o2) -> 0;\n        TreeBag<Object> bag = new TreeBag<>(customComparator);\n        assertTrue(bag.add(new Object()));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_addCompositedTest.java.CompositeCollection_addCompositedTest", "name": "CompositeCollection_addCompositedTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_addCompositedTest.java", "superclasses": "", "methods": ["[void]testAddCompositedSingleCollection()", "[void]testAddCompositedNullCollection()", "[void]testAddCompositedMultipleCollections()", "[void]testAddCompositedArrayOfCollections()", "[void]testAddCompositedWithClear()", "[void]testAddCompositedWithRemoveComposited()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_addCompositedTest.java.CompositeCollection_addCompositedTest.[void]setUpTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_addCompositedTest {\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    protected void setUpTest() {\n        c = new CompositeCollection<>();\n        one = new HashSet<>();\n        two = new HashSet<>();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddCompositedSingleCollection() {\n        setUpTest();\n        one.add(\"1\");\n        c.addComposited(one);\n        assertEquals(1, c.size());\n        assertTrue(c.contains(\"1\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddCompositedNullCollection() {\n        setUpTest();\n        c.addComposited((Collection<String>) null);\n        assertEquals(0, c.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddCompositedMultipleCollections() {\n        setUpTest();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(new Collection[]{one, two});\n        assertEquals(2, c.size());\n        assertTrue(c.contains(\"1\"));\n        assertTrue(c.contains(\"2\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddCompositedArrayOfCollections() {\n        setUpTest();\n        one.add(\"1\");\n        two.add(\"2\");\n        Collection<String> three = new HashSet<>();\n        three.add(\"3\");\n        c.addComposited(new Collection[]{one, two, three});\n        assertEquals(3, c.size());\n        assertTrue(c.contains(\"1\"));\n        assertTrue(c.contains(\"2\"));\n        assertTrue(c.contains(\"3\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddCompositedWithClear() {\n        setUpTest();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(new Collection[]{one, two});\n        c.clear();\n        assertTrue(one.isEmpty());\n        assertTrue(two.isEmpty());\n        assertTrue(c.isEmpty());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddCompositedWithRemoveComposited() {\n        setUpTest();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(new Collection[]{one, two});\n        c.removeComposited(one);\n        assertEquals(1, c.size());\n        assertFalse(c.contains(\"1\"));\n        assertTrue(c.contains(\"2\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_containsTest.java.CompositeCollection_containsTest", "name": "CompositeCollection_containsTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_containsTest.java", "superclasses": "", "methods": ["[void]testContainsWithSingleCollection()", "[void]testContainsWithMultipleCollections()", "[void]testContainsAfterAdd()", "[void]testContainsAfterRemove()", "[void]testContainsAfterClear()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_containsTest.java.CompositeCollection_containsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_containsTest {\n\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    public void setUp() {\n        c = new CompositeCollection<>();\n        one = new ArrayList<>();\n        two = new ArrayList<>();\n    }\n\n    @Test\n    public void testContainsWithSingleCollection() {\n        one.add(\"1\");\n        c.addComposited(one);\n        assertTrue(c.contains(\"1\"));\n        assertFalse(c.contains(\"2\"));\n    }\n\n    @Test\n    public void testContainsWithMultipleCollections() {\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        assertTrue(c.contains(\"1\"));\n        assertTrue(c.contains(\"2\"));\n        assertFalse(c.contains(\"3\"));\n    }\n\n    @Test\n    public void testContainsAfterAdd() {\n        one.add(\"1\");\n        c.addComposited(one);\n        c.setMutator(new CollectionMutator<String>() {\n            @Override\n            public boolean add(CompositeCollection<String> composite, List<Collection<String>> collections, String obj) {\n                return one.add(obj);\n            }\n\n            @Override\n            public boolean addAll(CompositeCollection<String> composite, List<Collection<String>> collections, Collection<? extends String> coll) {\n                return one.addAll(coll);\n            }\n\n            @Override\n            public boolean remove(CompositeCollection<String> composite, List<Collection<String>> collections, Object obj) {\n                return one.remove(obj);\n            }\n        });\n        c.add(\"2\");\n        assertTrue(c.contains(\"1\"));\n        assertTrue(c.contains(\"2\"));\n    }\n\n    @Test\n    public void testContainsAfterRemove() {\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        c.setMutator(new CollectionMutator<String>() {\n            @Override\n            public boolean add(CompositeCollection<String> composite, List<Collection<String>> collections, String obj) {\n                return one.add(obj);\n            }\n\n            @Override\n            public boolean addAll(CompositeCollection<String> composite, List<Collection<String>> collections, Collection<? extends String> coll) {\n                return one.addAll(coll);\n            }\n\n            @Override\n            public boolean remove(CompositeCollection<String> composite, List<Collection<String>> collections, Object obj) {\n                return one.remove(obj) || two.remove(obj);\n            }\n        });\n        c.remove(\"1\");\n        assertFalse(c.contains(\"1\"));\n        assertTrue(c.contains(\"2\"));\n    }\n\n    @Test\n    public void testContainsAfterClear() {\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        c.clear();\n        assertFalse(c.contains(\"1\"));\n        assertFalse(c.contains(\"2\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java.UnmodifiableCollectionTest", "name": "UnmodifiableCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java.UnmodifiableCollectionTest.[]UnmodifiableCollectionTest()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java.UnmodifiableCollectionTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java.UnmodifiableCollectionTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java.UnmodifiableCollectionTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java.UnmodifiableCollectionTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java.UnmodifiableCollectionTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java.UnmodifiableCollectionTest.[Collection<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java.UnmodifiableCollectionTest.[Collection<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link UnmodifiableCollection} implementation.\n", "original_string": "public class UnmodifiableCollectionTest<E> extends AbstractCollectionTest<E> {\n\n    public UnmodifiableCollectionTest() {\n        super(UnmodifiableCollectionTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        return new ArrayList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    public Collection<E> makeFullCollection() {\n        final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));\n        return UnmodifiableCollection.unmodifiableCollection(list);\n    }\n\n    @Override\n    public Collection<E> makeObject() {\n        return UnmodifiableCollection.unmodifiableCollection(new ArrayList<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final Collection<E> coll = makeFullCollection();\n        assertSame(coll, UnmodifiableCollection.unmodifiableCollection(coll));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableCollection.unmodifiableCollection(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullCollection() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableCollection.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableCollection.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest", "name": "CompositeCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java", "superclasses": "", "methods": ["[void]testAddAllMutator()", "[void]testAddAllToCollection()", "[void]testAddMutator()", "[void]testAddNullList()", "[void]testAddNullLists2Args()", "[void]testAddNullListsVarArgs()", "[void]testClear()", "[void]testContainsAll()", "[void]testIsEmpty()", "[void]testIterator()", "[void]testMultipleCollectionsSize()", "[void]testRemove()", "[void]testRemoveAll()", "[void]testRemoveComposited()", "[void]testRemoveIf()", "[void]testRetainAll()", "[void]testSize()", "[void]testToCollection()", "[void]testUnsupportedRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[]CompositeCollectionTest()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[E[]]getFullElements()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[Collection<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[Collection<E>]makeObject()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[void]setUpMutatorTest()", "src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java.CompositeCollectionTest.[void]setUpTest()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link CompositeCollection} implementation.\n", "original_string": "public class CompositeCollectionTest<E> extends AbstractCollectionTest<E> {\n\n    protected CompositeCollection<E> c;\n\n    protected Collection<E> one;\n\n    protected Collection<E> two;\n\n    public CompositeCollectionTest() {\n        super(CompositeCollectionTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E[] getFullElements() {\n        return (E[]) new Object[] { \"1\", \"2\", \"3\", \"4\" };\n    }\n\n    /**\n     * Run stock collection tests without Mutator, so turn off add, remove\n     */\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new HashSet<>();\n    }\n\n    /**\n     * Full collection should look like a collection with 4 elements\n     */\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        return new HashSet<>(Arrays.asList(getFullElements()));\n    }\n    /**\n     * Full collection consists of 4 collections, each with one element\n     */\n    @Override\n    public Collection<E> makeFullCollection() {\n        final CompositeCollection<E> compositeCollection = new CompositeCollection<>();\n        final E[] elements = getFullElements();\n        for (final E element : elements) {\n            final Collection<E> summand = new HashSet<>();\n            summand.add(element);\n            compositeCollection.addComposited(summand);\n        }\n        return compositeCollection;\n    }\n    /**\n     * Empty collection is empty composite\n     */\n    @Override\n    public Collection<E> makeObject() {\n        return new CompositeCollection<>();\n    }\n\n    @SuppressWarnings(\"serial\")\n    protected void setUpMutatorTest() {\n        setUpTest();\n        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public boolean add(final CompositeCollection<E> composite, final List<Collection<E>> collections, final E obj) {\n                for (final Collection<E> coll : collections) {\n                    coll.add(obj);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean addAll(final CompositeCollection<E> composite,\n                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n                for (final Collection<E> collection : collections) {\n                    collection.addAll(coll);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean remove(final CompositeCollection<E> composite,\n                    final List<Collection<E>> collections, final Object obj) {\n                for (final Collection<E> collection : collections) {\n                    collection.remove(obj);\n                }\n                return true;\n            }\n        });\n    }\n\n    protected void setUpTest() {\n        c = new CompositeCollection<>();\n        one = new HashSet<>();\n        two = new HashSet<>();\n    }\n\n    @Test\n    @SuppressWarnings({ \"unchecked\", \"serial\" })\n    public void testAddAllMutator() {\n        setUpTest();\n        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public boolean add(final CompositeCollection<E> composite,\n                    final List<Collection<E>> collections, final E obj) {\n                for (final Collection<E> collection : collections) {\n                    collection.add(obj);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean addAll(final CompositeCollection<E> composite,\n                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n                for (final Collection<E> collection : collections) {\n                    collection.addAll(coll);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean remove(final CompositeCollection<E> composite,\n                    final List<Collection<E>> collections, final Object obj) {\n                return false;\n            }\n        });\n\n        c.addComposited(one);\n        two.add((E) \"foo\");\n        c.addAll(two);\n        assertTrue(c.contains(\"foo\"));\n        assertTrue(one.contains(\"foo\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddAllToCollection() {\n        setUpTest();\n        one.add((E) \"1\");\n        two.add((E) \"2\");\n        c.addComposited(one, two);\n        final Collection<E> toCollection = new HashSet<>(c);\n        assertTrue(toCollection.containsAll(c));\n        assertEquals(c.size(), toCollection.size());\n    }\n\n    @Test\n    @SuppressWarnings({ \"unchecked\", \"serial\" })\n    public void testAddMutator() {\n        setUpTest();\n        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public boolean add(final CompositeCollection<E> composite,\n                    final List<Collection<E>> collections, final E obj) {\n                for (final Collection<E> collection : collections) {\n                    collection.add(obj);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean addAll(final CompositeCollection<E> composite,\n                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n                for (final Collection<E> collection : collections) {\n                    collection.addAll(coll);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean remove(final CompositeCollection<E> composite,\n                    final List<Collection<E>> collections, final Object obj) {\n                return false;\n            }\n        });\n\n        c.addComposited(one);\n        c.add((E) \"foo\");\n        assertTrue(c.contains(\"foo\"));\n        assertTrue(one.contains(\"foo\"));\n    }\n\n    @Test\n    public void testAddNullList() {\n        final ArrayList<String> nullList = null;\n        final CompositeCollection<String> cc = new CompositeCollection<>();\n        cc.addComposited(nullList);\n        assertEquals(0, cc.size());\n    }\n\n    @Test\n    public void testAddNullLists2Args() {\n        final ArrayList<String> nullList = null;\n        final CompositeCollection<String> cc = new CompositeCollection<>();\n        cc.addComposited(nullList, nullList);\n        assertEquals(0, cc.size());\n    }\n\n    @Test\n    public void testAddNullListsVarArgs() {\n        final ArrayList<String> nullList = null;\n        final CompositeCollection<String> cc = new CompositeCollection<>();\n        cc.addComposited(nullList, nullList, nullList);\n        assertEquals(0, cc.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testClear() {\n        setUpTest();\n        one.add((E) \"1\");\n        two.add((E) \"2\");\n        c.addComposited(one, two);\n        c.clear();\n        assertTrue(one.isEmpty());\n        assertTrue(two.isEmpty());\n        assertTrue(c.isEmpty());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testContainsAll() {\n        setUpTest();\n        one.add((E) \"1\");\n        two.add((E) \"1\");\n        c.addComposited(one);\n        assertTrue(c.containsAll(two));\n        assertFalse(c.containsAll(null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIsEmpty() {\n        setUpTest();\n        assertTrue(c.isEmpty());\n        final HashSet<E> empty = new HashSet<>();\n        c.addComposited(empty);\n        assertTrue(c.isEmpty());\n        empty.add((E) \"a\");\n        assertFalse(c.isEmpty());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIterator() {\n        setUpTest();\n        one.add((E) \"1\");\n        two.add((E) \"2\");\n        c.addComposited(one);\n        c.addComposited(two);\n        final Iterator<E> i = c.iterator();\n        E next = i.next();\n        assertTrue(c.contains(next));\n        assertTrue(one.contains(next));\n        next = i.next();\n        i.remove();\n        assertFalse(c.contains(next));\n        assertFalse(two.contains(next));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultipleCollectionsSize() {\n        setUpTest();\n        final HashSet<E> set = new HashSet<>();\n        set.add((E) \"a\");\n        set.add((E) \"b\");\n        c.addComposited(set);\n        final HashSet<E> other = new HashSet<>();\n        other.add((E) \"c\");\n        c.addComposited(other);\n        assertEquals(set.size() + other.size(), c.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemove() {\n        setUpMutatorTest();\n        one.add((E) \"1\");\n        two.add((E) \"2\");\n        two.add((E) \"1\");\n        c.addComposited(one, two);\n        c.remove(\"1\");\n        assertFalse(c.contains(\"1\"));\n        assertFalse(one.contains(\"1\"));\n        assertFalse(two.contains(\"1\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveAll() {\n        setUpMutatorTest();\n        one.add((E) \"1\");\n        two.add((E) \"2\");\n        two.add((E) \"1\");\n        // need separate list to remove, as otherwise one clears itself\n        final Collection<E> removing = new ArrayList<>(one);\n        c.addComposited(one, two);\n        c.removeAll(removing);\n        assertFalse(c.contains(\"1\"));\n        assertFalse(one.contains(\"1\"));\n        assertFalse(two.contains(\"1\"));\n        c.removeAll(null);\n        assertFalse(c.contains(\"1\"));\n        assertFalse(one.contains(\"1\"));\n        assertFalse(two.contains(\"1\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveComposited() {\n        setUpMutatorTest();\n        one.add((E) \"1\");\n        two.add((E) \"2\");\n        two.add((E) \"1\");\n        c.addComposited(one, two);\n        c.removeComposited(one);\n        assertTrue(c.contains(\"1\"));\n        assertEquals(2, c.size());\n    }\n\n    /**\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveIf() {\n        setUpMutatorTest();\n        one.add((E) \"1\");\n        two.add((E) \"2\");\n        two.add((E) \"1\");\n        // need separate list to remove, as otherwise one clears itself\n        final Predicate<E> predicate = e -> e == \"1\";\n        c.addComposited(one, two);\n        c.removeIf(predicate);\n        assertFalse(c.contains(\"1\"));\n        assertFalse(one.contains(\"1\"));\n        assertFalse(two.contains(\"1\"));\n        c.removeIf(null);\n        assertFalse(c.contains(\"1\"));\n        assertFalse(one.contains(\"1\"));\n        assertFalse(two.contains(\"1\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRetainAll() {\n        setUpTest();\n        one.add((E) \"1\");\n        one.add((E) \"2\");\n        two.add((E) \"1\");\n        c.addComposited(one);\n        c.retainAll(two);\n        assertFalse(c.contains(\"2\"));\n        assertFalse(one.contains(\"2\"));\n        assertTrue(c.contains(\"1\"));\n        assertTrue(one.contains(\"1\"));\n        c.retainAll(null);\n        assertFalse(c.contains(\"2\"));\n        assertFalse(one.contains(\"2\"));\n        assertTrue(c.contains(\"1\"));\n        assertTrue(one.contains(\"1\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSize() {\n        setUpTest();\n        final HashSet<E> set = new HashSet<>();\n        set.add((E) \"a\");\n        set.add((E) \"b\");\n        c.addComposited(set);\n        assertEquals(set.size(), c.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testToCollection() {\n        setUpTest();\n        one.add((E) \"1\");\n        two.add((E) \"2\");\n        c.addComposited(one, two);\n        final Collection<E> foo = c.toCollection();\n        assertTrue(foo.containsAll(c));\n        assertEquals(c.size(), foo.size());\n        one.add((E) \"3\");\n        assertFalse(foo.containsAll(c));\n    }\n\n    /**\n     * Override testUnsupportedRemove, since the default impl expects removeAll,\n     * retainAll and iterator().remove to throw\n     */\n    @Test\n    @Override\n    public void testUnsupportedRemove() {\n        resetFull();\n\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().remove(null));\n\n        verify();\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CompositeCollection.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CompositeCollection.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected CompositeCollection<E> c;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "CompositeCollection<E>", "name": "c", "syntax_pass": true}, {"attribute_expression": "protected Collection<E> one;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Collection<E>", "name": "one", "syntax_pass": true}, {"attribute_expression": "protected Collection<E> two;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Collection<E>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_removeIfTest.java.CompositeCollection_removeIfTest", "name": "CompositeCollection_removeIfTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_removeIfTest.java", "superclasses": "", "methods": ["[void]testRemoveIf_AllElementsRemoved()", "[void]testRemoveIf_NoElementsRemoved()", "[void]testRemoveIf_SomeElementsRemoved()", "[void]testRemoveIf_NullFilter()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_removeIfTest.java.CompositeCollection_removeIfTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_removeIfTest {\n\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    public void setUp() {\n        c = new CompositeCollection<>();\n        one = new HashSet<>(Arrays.asList(\"a\", \"b\"));\n        two = new HashSet<>(Arrays.asList(\"c\", \"d\"));\n        c.addComposited(one, two);\n    }\n\n    @Test\n    public void testRemoveIf_AllElementsRemoved() {\n        Predicate<String> filter = s -> true;\n        assertTrue(c.removeIf(filter));\n        assertEquals(0, c.size());\n    }\n\n    @Test\n    public void testRemoveIf_NoElementsRemoved() {\n        Predicate<String> filter = s -> false;\n        assertFalse(c.removeIf(filter));\n        assertEquals(4, c.size());\n    }\n\n    @Test\n    public void testRemoveIf_SomeElementsRemoved() {\n        Predicate<String> filter = s -> s.equals(\"a\") || s.equals(\"c\");\n        assertTrue(c.removeIf(filter));\n        assertEquals(2, c.size());\n        assertFalse(c.contains(\"a\"));\n        assertFalse(c.contains(\"c\"));\n    }\n\n    @Test\n    public void testRemoveIf_NullFilter() {\n        assertFalse(c.removeIf(null));\n        assertEquals(4, c.size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_retainAllTest.java.IndexedCollection_retainAllTest", "name": "IndexedCollection_retainAllTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_retainAllTest.java", "superclasses": "", "methods": ["[void]testRetainAllWithMatchingElements()", "[void]testRetainAllWithNoMatchingElements()", "[void]testRetainAllWithAllMatchingElements()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/IndexedCollection_retainAllTest.java.IndexedCollection_retainAllTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_retainAllTest.java.IndexedCollection_retainAllTest.[IndexedCollection<Integer, String>]decorateUniqueCollection(Collection<String>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexedCollection_retainAllTest {\n\n    private IndexedCollection<Integer, String> indexedCollection;\n    private Collection<String> originalCollection;\n\n    @BeforeEach\n    public void setUp() {\n        originalCollection = new ArrayList<>(asList(\"1\", \"2\", \"3\"));\n        indexedCollection = decorateUniqueCollection(originalCollection);\n    }\n\n    @Test\n    public void testRetainAllWithMatchingElements() {\n        Collection<String> retainCollection = asList(\"1\", \"2\");\n        boolean changed = indexedCollection.retainAll(retainCollection);\n\n        assertTrue(changed);\n        assertEquals(2, indexedCollection.size());\n        assertEquals(\"1\", indexedCollection.get(1));\n        assertEquals(\"2\", indexedCollection.get(2));\n        assertNull(indexedCollection.get(3));\n    }\n\n    @Test\n    public void testRetainAllWithNoMatchingElements() {\n        Collection<String> retainCollection = asList(\"4\", \"5\");\n        boolean changed = indexedCollection.retainAll(retainCollection);\n\n        assertTrue(changed);\n        assertEquals(0, indexedCollection.size());\n        assertNull(indexedCollection.get(1));\n        assertNull(indexedCollection.get(2));\n        assertNull(indexedCollection.get(3));\n    }\n\n    @Test\n    public void testRetainAllWithAllMatchingElements() {\n        Collection<String> retainCollection = asList(\"1\", \"2\", \"3\");\n        boolean changed = indexedCollection.retainAll(retainCollection);\n\n        assertFalse(changed);\n        assertEquals(3, indexedCollection.size());\n        assertEquals(\"1\", indexedCollection.get(1));\n        assertEquals(\"2\", indexedCollection.get(2));\n        assertEquals(\"3\", indexedCollection.get(3));\n    }\n\n    private IndexedCollection<Integer, String> decorateUniqueCollection(Collection<String> original) {\n        Transformer<String, Integer> keyTransformer = s -> Integer.valueOf(s);\n        return IndexedCollection.uniqueIndexedCollection(original, keyTransformer);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private IndexedCollection<Integer, String> indexedCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IndexedCollection<Integer, String>", "name": "indexedCollection", "syntax_pass": true}, {"attribute_expression": "private Collection<String> originalCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "originalCollection", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_removeAllTest.java.CompositeCollection_removeAllTest", "name": "CompositeCollection_removeAllTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_removeAllTest.java", "superclasses": "", "methods": ["[void]testRemoveAllWithEmptyCollection()", "[void]testRemoveAllWithNonEmptyCollection()", "[void]testRemoveAllWithPartialMatch()", "[void]testRemoveAllWithNoMatch()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_removeAllTest.java.CompositeCollection_removeAllTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_removeAllTest {\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    public void setUp() {\n        c = new CompositeCollection<>();\n        one = new HashSet<>();\n        two = new HashSet<>();\n    }\n\n    @Test\n    public void testRemoveAllWithEmptyCollection() {\n        setUp();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        assertFalse(c.removeAll(new ArrayList<>()));\n        assertEquals(2, c.size());\n    }\n\n    @Test\n    public void testRemoveAllWithNonEmptyCollection() {\n        setUp();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        assertTrue(c.removeAll(Arrays.asList(\"1\", \"2\")));\n        assertTrue(c.isEmpty());\n    }\n\n    @Test\n    public void testRemoveAllWithPartialMatch() {\n        setUp();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        assertTrue(c.removeAll(Arrays.asList(\"1\")));\n        assertEquals(1, c.size());\n        assertFalse(c.contains(\"1\"));\n        assertTrue(c.contains(\"2\"));\n    }\n\n    @Test\n    public void testRemoveAllWithNoMatch() {\n        setUp();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        assertFalse(c.removeAll(Arrays.asList(\"3\")));\n        assertEquals(2, c.size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java.TransformedCollectionTest", "name": "TransformedCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java", "superclasses": "", "methods": ["[void]testTransformedCollection()", "[void]testTransformedCollection_decorateTransform()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java.TransformedCollectionTest.[]TransformedCollectionTest()", "src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java.TransformedCollectionTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java.TransformedCollectionTest.[Object[]]getFullElements()", "src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java.TransformedCollectionTest.[Object[]]getOtherElements()", "src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java.TransformedCollectionTest.[Collection<Object>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java.TransformedCollectionTest.[Collection<Object>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java.TransformedCollectionTest.[Collection<Object>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java.TransformedCollectionTest.[Collection<Object>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    private static final class StringToInteger implements Transformer<Object, Object> {\n        @Override\n        public Object transform(final Object input) {\n            return Integer.valueOf((String) input);\n        }\n    }", "definition": "    private static final class StringToInteger implements Transformer<Object, Object>", "class_docstring": "", "name": "StringToInteger", "super_interfaces": ["Transformer<Object, Object>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Object transform(final Object input) {\n            return Integer.valueOf((String) input);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "transform", "params": [{"name": "input", "type": "Object"}], "body": "                                                    {\n            return Integer.valueOf((String) input);\n        }", "signature": "@Override\n        public Object transform(final Object input)"}]}, {"original_string": "    private static final class ToLowerCase implements Transformer<Object, Object> {\n        @Override\n        public Object transform(final Object input) {\n            return ((String) input).toLowerCase();\n        }\n    }", "definition": "    private static final class ToLowerCase implements Transformer<Object, Object>", "class_docstring": "", "name": "ToLowerCase", "super_interfaces": ["Transformer<Object, Object>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Object transform(final Object input) {\n            return ((String) input).toLowerCase();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "transform", "params": [{"name": "input", "type": "Object"}], "body": "                                                    {\n            return ((String) input).toLowerCase();\n        }", "signature": "@Override\n        public Object transform(final Object input)"}]}], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the {@link TransformedCollection}\nimplementation.\n", "original_string": "public class TransformedCollectionTest extends AbstractCollectionTest<Object> {\n\n    private static final class StringToInteger implements Transformer<Object, Object> {\n        @Override\n        public Object transform(final Object input) {\n            return Integer.valueOf((String) input);\n        }\n    }\n\n    private static final class ToLowerCase implements Transformer<Object, Object> {\n        @Override\n        public Object transform(final Object input) {\n            return ((String) input).toLowerCase();\n        }\n    }\n\n    public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();\n    public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();\n    public static final Transformer<Object, Object> TO_LOWER_CASE_TRANSFORMER = new ToLowerCase();\n\n    public TransformedCollectionTest() {\n        super(TransformedCollectionTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Object[] getFullElements() {\n        return new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n    }\n\n    @Override\n    public Object[] getOtherElements() {\n        return new Object[] {\"9\", \"88\", \"678\", \"87\", \"98\", \"78\", \"99\"};\n    }\n\n    @Override\n    public Collection<Object> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public Collection<Object> makeConfirmedFullCollection() {\n        return new ArrayList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    public Collection<Object> makeFullCollection() {\n        final List<Object> list = new ArrayList<>(Arrays.asList(getFullElements()));\n        return TransformedCollection.transformingCollection(list, NOOP_TRANSFORMER);\n    }\n\n    @Override\n    public Collection<Object> makeObject() {\n        return TransformedCollection.transformingCollection(new ArrayList<>(), NOOP_TRANSFORMER);\n    }\n\n    @Test\n    public void testTransformedCollection() {\n        final Collection<Object> coll = TransformedCollection.transformingCollection(new ArrayList<>(), STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, coll.size());\n        final Object[] elements = getFullElements();\n        for (int i = 0; i < elements.length; i++) {\n            coll.add(elements[i]);\n            assertEquals(i + 1, coll.size());\n            assertTrue(coll.contains(Integer.valueOf((String) elements[i])));\n            assertFalse(coll.contains(elements[i]));\n        }\n\n        assertTrue(coll.remove(Integer.valueOf((String) elements[0])));\n    }\n\n    @Test\n    public void testTransformedCollection_decorateTransform() {\n        final Collection<Object> originalCollection = new ArrayList<>();\n        final Object[] elements = getFullElements();\n        Collections.addAll(originalCollection, elements);\n        final Collection<Object> collection = TransformedCollection.transformedCollection(originalCollection, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(elements.length, collection.size());\n        for (final Object element : elements) {\n            assertTrue(collection.contains(Integer.valueOf((String) element)));\n            assertFalse(collection.contains(element));\n        }\n\n        assertFalse(collection.remove(elements[0]));\n        assertTrue(collection.remove(Integer.valueOf((String) elements[0])));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedCollection.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedCollection.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Transformer<Object, Object>", "name": "NOOP_TRANSFORMER = TransformerUtils.nopTransformer()", "syntax_pass": true}, {"attribute_expression": "public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Transformer<Object, Object>", "name": "STRING_TO_INTEGER_TRANSFORMER = new StringToInteger()", "syntax_pass": true}, {"attribute_expression": "public static final Transformer<Object, Object> TO_LOWER_CASE_TRANSFORMER = new ToLowerCase();", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Transformer<Object, Object>", "name": "TO_LOWER_CASE_TRANSFORMER = new ToLowerCase()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_uniqueIndexedCollectionTest.java.IndexedCollection_uniqueIndexedCollectionTest", "name": "IndexedCollection_uniqueIndexedCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_uniqueIndexedCollectionTest.java", "superclasses": "", "methods": ["[void]testUniqueIndexedCollectionWithUniqueKeys()", "[void]testUniqueIndexedCollectionWithDuplicateKeys()", "[void]testUniqueIndexedCollectionWithEmptyCollection()", "[void]testUniqueIndexedCollectionWithNullKeyTransformer()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/IndexedCollection_uniqueIndexedCollectionTest.java.IndexedCollection_uniqueIndexedCollectionTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexedCollection_uniqueIndexedCollectionTest {\n\n    private Transformer<String, Integer> keyTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        keyTransformer = new Transformer<String, Integer>() {\n            @Override\n            public Integer transform(String input) {\n                return Integer.parseInt(input);\n            }\n        };\n    }\n\n    @Test\n    public void testUniqueIndexedCollectionWithUniqueKeys() {\n        Collection<String> coll = Arrays.asList(\"1\", \"2\", \"3\");\n        IndexedCollection<Integer, String> indexedCollection = IndexedCollection.uniqueIndexedCollection(coll, keyTransformer);\n\n        assertEquals(\"1\", indexedCollection.get(1));\n        assertEquals(\"2\", indexedCollection.get(2));\n        assertEquals(\"3\", indexedCollection.get(3));\n    }\n\n    @Test\n    public void testUniqueIndexedCollectionWithDuplicateKeys() {\n        Collection<String> coll = Arrays.asList(\"1\", \"2\", \"2\");\n        assertThrows(IllegalArgumentException.class, () -> {\n            IndexedCollection.uniqueIndexedCollection(coll, keyTransformer);\n        });\n    }\n\n    @Test\n    public void testUniqueIndexedCollectionWithEmptyCollection() {\n        Collection<String> coll = Arrays.asList();\n        IndexedCollection<Integer, String> indexedCollection = IndexedCollection.uniqueIndexedCollection(coll, keyTransformer);\n\n        assertNull(indexedCollection.get(1));\n    }\n\n    @Test\n    public void testUniqueIndexedCollectionWithNullKeyTransformer() {\n        Collection<String> coll = Arrays.asList(\"1\", \"2\", \"3\");\n        assertThrows(NullPointerException.class, () -> {\n            IndexedCollection.uniqueIndexedCollection(coll, null);\n        });\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Transformer<String, Integer> keyTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, Integer>", "name": "keyTransformer", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_retainAllTest.java.CompositeCollection_retainAllTest", "name": "CompositeCollection_retainAllTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_retainAllTest.java", "superclasses": "", "methods": ["[void]testRetainAllWithNullCollection()", "[void]testRetainAllWithEmptyCollection()", "[void]testRetainAllWithMatchingElements()", "[void]testRetainAllWithNonMatchingElements()", "[void]testRetainAllWithPartialMatchingElements()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_retainAllTest.java.CompositeCollection_retainAllTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_retainAllTest {\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    public void setUp() {\n        c = new CompositeCollection<>();\n        one = new HashSet<>();\n        two = new HashSet<>();\n    }\n\n    @Test\n    public void testRetainAllWithNullCollection() {\n        setUp();\n        assertFalse(c.retainAll(null));\n    }\n\n    @Test\n    public void testRetainAllWithEmptyCollection() {\n        setUp();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        assertTrue(c.retainAll(new ArrayList<>()));\n    }\n\n    @Test\n    public void testRetainAllWithMatchingElements() {\n        setUp();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        Collection<String> retain = new HashSet<>(Arrays.asList(\"1\", \"2\"));\n        assertFalse(c.retainAll(retain));\n    }\n\n    @Test\n    public void testRetainAllWithNonMatchingElements() {\n        setUp();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        Collection<String> retain = new HashSet<>(Arrays.asList(\"3\", \"4\"));\n        assertTrue(c.retainAll(retain));\n    }\n\n    @Test\n    public void testRetainAllWithPartialMatchingElements() {\n        setUp();\n        one.add(\"1\");\n        two.add(\"2\");\n        c.addComposited(one, two);\n        Collection<String> retain = new HashSet<>(Arrays.asList(\"1\", \"3\"));\n        assertTrue(c.retainAll(retain));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollection_unmodifiableCollectionTest.java.UnmodifiableCollection_unmodifiableCollectionTest", "name": "UnmodifiableCollection_unmodifiableCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollection_unmodifiableCollectionTest.java", "superclasses": "", "methods": ["[void]testUnmodifiableCollectionWithUnmodifiableCollection()", "[void]testUnmodifiableCollectionWithAlreadyUnmodifiableCollection()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnmodifiableCollection_unmodifiableCollectionTest {\n\n    @Test\n    public void testUnmodifiableCollectionWithUnmodifiableCollection() {\n        Collection<String> original = new ArrayList<>();\n        original.add(\"test\");\n        Collection<String> unmodifiable = UnmodifiableCollection.unmodifiableCollection(original);\n\n        // Ensure the returned collection is an instance of UnmodifiableCollection\n        assertTrue(unmodifiable instanceof UnmodifiableCollection);\n\n        // Ensure the original collection is not modified\n        assertSame(original, ((UnmodifiableCollection<String>) unmodifiable).decorated());\n    }\n\n    @Test\n    public void testUnmodifiableCollectionWithAlreadyUnmodifiableCollection() {\n        Collection<String> original = new ArrayList<>();\n        original.add(\"test\");\n        Collection<String> unmodifiable = UnmodifiableCollection.unmodifiableCollection(original);\n        Collection<String> alreadyUnmodifiable = UnmodifiableCollection.unmodifiableCollection(unmodifiable);\n\n        // Ensure the returned collection is the same instance as the input unmodifiable collection\n        assertSame(unmodifiable, alreadyUnmodifiable);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_iteratorTest.java.CompositeCollection_iteratorTest", "name": "CompositeCollection_iteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_iteratorTest.java", "superclasses": "", "methods": ["[void]testIteratorWithEmptyComposite()", "[void]testIteratorWithSingleCollection()", "[void]testIteratorWithMultipleCollections()", "[void]testIteratorAfterClear()", "[void]testIteratorAfterRemoveComposited()", "[void]testIteratorAfterAddElement()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_iteratorTest.java.CompositeCollection_iteratorTest.[void]setUpTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_iteratorTest {\n\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    protected void setUpTest() {\n        c = new CompositeCollection<>();\n        one = new HashSet<>(Arrays.asList(\"a\", \"b\", \"c\"));\n        two = new HashSet<>(Arrays.asList(\"d\", \"e\", \"f\"));\n    }\n\n    @Test\n    public void testIteratorWithEmptyComposite() {\n        Iterator<String> iterator = c.iterator();\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testIteratorWithSingleCollection() {\n        c.addComposited(one);\n        Iterator<String> iterator = c.iterator();\n        List<String> result = new ArrayList<>();\n        iterator.forEachRemaining(result::add);\n        assertEquals(one, new HashSet<>(result));\n    }\n\n    @Test\n    public void testIteratorWithMultipleCollections() {\n        c.addComposited(one, two);\n        Iterator<String> iterator = c.iterator();\n        List<String> result = new ArrayList<>();\n        iterator.forEachRemaining(result::add);\n        assertEquals(new HashSet<>(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")), new HashSet<>(result));\n    }\n\n    @Test\n    public void testIteratorAfterClear() {\n        c.addComposited(one);\n        c.clear();\n        Iterator<String> iterator = c.iterator();\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testIteratorAfterRemoveComposited() {\n        c.addComposited(one, two);\n        c.removeComposited(one);\n        Iterator<String> iterator = c.iterator();\n        List<String> result = new ArrayList<>();\n        iterator.forEachRemaining(result::add);\n        assertEquals(two, new HashSet<>(result));\n    }\n\n    @Test\n    public void testIteratorAfterAddElement() {\n        c.setMutator(new CollectionMutator<String>() {\n            @Override\n            public boolean add(CompositeCollection<String> composite, List<Collection<String>> collections, String obj) {\n                for (Collection<String> collection : collections) {\n                    if (collection.add(obj)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            @Override\n            public boolean addAll(CompositeCollection<String> composite, List<Collection<String>> collections, Collection<? extends String> coll) {\n                boolean changed = false;\n                for (String collItem : coll) {\n                    changed |= add(composite, collections, collItem);\n                }\n                return changed;\n            }\n\n            @Override\n            public boolean remove(CompositeCollection<String> composite, List<Collection<String>> collections, Object obj) {\n                for (Collection<String> collection : collections) {\n                    if (collection.remove(obj)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        });\n        c.addComposited(one);\n        c.add(\"g\");\n        Iterator<String> iterator = c.iterator();\n        List<String> result = new ArrayList<>();\n        iterator.forEachRemaining(result::add);\n        assertTrue(result.contains(\"g\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_containsTest.java.IndexedCollection_containsTest", "name": "IndexedCollection_containsTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_containsTest.java", "superclasses": "", "methods": ["[void]testContainsReturnsTrueForExistingObject()", "[void]testContainsReturnsFalseForNonExistingObject()", "[void]testContainsReturnsTrueAfterAddingObject()", "[void]testContainsReturnsFalseAfterRemovingObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/IndexedCollection_containsTest.java.IndexedCollection_containsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexedCollection_containsTest {\n\n    private IndexedCollection<Integer, String> indexedCollection;\n    private Collection<String> originalCollection;\n    private Transformer<String, Integer> keyTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        originalCollection = new ArrayList<>();\n        keyTransformer = new Transformer<String, Integer>() {\n            @Override\n            public Integer transform(String input) {\n                return Integer.parseInt(input);\n            }\n        };\n        indexedCollection = IndexedCollection.nonUniqueIndexedCollection(originalCollection, keyTransformer);\n    }\n\n    @Test\n    public void testContainsReturnsTrueForExistingObject() {\n        originalCollection.add(\"1\");\n        indexedCollection.reindex();\n        assertTrue(indexedCollection.contains(\"1\"));\n    }\n\n    @Test\n    public void testContainsReturnsFalseForNonExistingObject() {\n        originalCollection.add(\"1\");\n        indexedCollection.reindex();\n        assertFalse(indexedCollection.contains(\"2\"));\n    }\n\n    @Test\n    public void testContainsReturnsTrueAfterAddingObject() {\n        originalCollection.add(\"1\");\n        indexedCollection.reindex();\n        originalCollection.add(\"2\");\n        indexedCollection.reindex();\n        assertTrue(indexedCollection.contains(\"2\"));\n    }\n\n    @Test\n    public void testContainsReturnsFalseAfterRemovingObject() {\n        originalCollection.add(\"1\");\n        indexedCollection.reindex();\n        originalCollection.remove(\"1\");\n        indexedCollection.reindex();\n        assertFalse(indexedCollection.contains(\"1\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private IndexedCollection<Integer, String> indexedCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IndexedCollection<Integer, String>", "name": "indexedCollection", "syntax_pass": true}, {"attribute_expression": "private Collection<String> originalCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "originalCollection", "syntax_pass": true}, {"attribute_expression": "private Transformer<String, Integer> keyTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, Integer>", "name": "keyTransformer", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/PredicatedCollection_addAllTest.java.PredicatedCollection_addAllTest", "name": "PredicatedCollection_addAllTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/PredicatedCollection_addAllTest.java", "superclasses": "", "methods": ["[void]testAddAll_ValidElements()", "[void]testAddAll_InvalidElement()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PredicatedCollection_addAllTest {\n\n    @Test\n    public void testAddAll_ValidElements() {\n        Predicate<String> predicate = NotNullPredicate.notNullPredicate();\n        PredicatedCollection<String> predicatedCollection = new PredicatedCollection<>(new HashSet<>(), predicate);\n        Collection<String> validElements = Arrays.asList(\"item1\", \"item2\");\n\n        boolean result = predicatedCollection.addAll(validElements);\n\n        assertTrue(result);\n        assertEquals(2, predicatedCollection.size());\n    }\n\n    @Test\n    public void testAddAll_InvalidElement() {\n        Predicate<String> predicate = NotNullPredicate.notNullPredicate();\n        PredicatedCollection<String> predicatedCollection = new PredicatedCollection<>(new HashSet<>(), predicate);\n        Collection<String> invalidElements = Arrays.asList(\"item1\", null, \"item2\");\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            predicatedCollection.addAll(invalidElements);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest", "name": "IndexedCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java", "superclasses": "", "methods": ["[void]testAddedObjectsCanBeRetrievedByKey()", "[void]testDecoratedCollectionIsIndexedOnCreation()", "[void]testEnsureDuplicateObjectsCauseException()", "[void]testReindexUpdatesIndexWhenDecoratedCollectionIsModifiedSeparately()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[]IndexedCollectionTest()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[Collection<String>]decorateCollection(Collection<String>)", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[IndexedCollection<Integer, String>]decorateUniqueCollection(Collection<String>)", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[String[]]getFullElements()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[String[]]getOtherElements()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[Collection<String>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[Collection<String>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[Collection<String>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[Collection<String>]makeObject()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[Collection<String>]makeTestCollection()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[Collection<String>]makeUniqueTestCollection()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java.IndexedCollectionTest.[boolean]skipSerializedCanonicalTests()"], "overrides": null, "attributes": [{"original_string": "    private static final class IntegerTransformer implements Transformer<String, Integer>, Serializable {\n        private static final long serialVersionUID = 809439581555072949L;\n\n        @Override\n        public Integer transform(final String input) {\n            return Integer.valueOf(input);\n        }\n    }", "definition": "    private static final class IntegerTransformer implements Transformer<String, Integer>, Serializable", "class_docstring": "", "name": "IntegerTransformer", "super_interfaces": ["Transformer<String, Integer>", "Serializable"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 809439581555072949L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 809439581555072949L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Integer transform(final String input) {\n            return Integer.valueOf(input);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "transform", "params": [{"name": "input", "type": "String"}], "body": "                                                     {\n            return Integer.valueOf(input);\n        }", "signature": "@Override\n        public Integer transform(final String input)"}]}], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link IndexedCollection} implementation.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class IndexedCollectionTest extends AbstractCollectionTest<String> {\n\n    private static final class IntegerTransformer implements Transformer<String, Integer>, Serializable {\n        private static final long serialVersionUID = 809439581555072949L;\n\n        @Override\n        public Integer transform(final String input) {\n            return Integer.valueOf(input);\n        }\n    }\n\n    public IndexedCollectionTest() {\n        super(IndexedCollectionTest.class.getSimpleName());\n    }\n\n    protected Collection<String> decorateCollection(final Collection<String> collection) {\n        return IndexedCollection.nonUniqueIndexedCollection(collection, new IntegerTransformer());\n    }\n\n    protected IndexedCollection<Integer, String> decorateUniqueCollection(final Collection<String> collection) {\n        return IndexedCollection.uniqueIndexedCollection(collection, new IntegerTransformer());\n    }\n\n    @Override\n    public String[] getFullElements() {\n        return new String[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n    }\n\n    @Override\n    public String[] getOtherElements() {\n        return new String[] {\"9\", \"88\", \"678\", \"87\", \"98\", \"78\", \"99\"};\n    }\n\n    @Override\n    public Collection<String> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public Collection<String> makeConfirmedFullCollection() {\n        return new ArrayList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    public Collection<String> makeFullCollection() {\n        return decorateCollection(new ArrayList<>(Arrays.asList(getFullElements())));\n    }\n\n    @Override\n    public Collection<String> makeObject() {\n        return decorateCollection(new ArrayList<>());\n    }\n\n    public Collection<String> makeTestCollection() {\n        return decorateCollection(new ArrayList<>());\n    }\n\n    public Collection<String> makeUniqueTestCollection() {\n        return decorateUniqueCollection(new ArrayList<>());\n    }\n\n    @Override\n    protected boolean skipSerializedCanonicalTests() {\n        // FIXME: support canonical tests\n        return true;\n    }\n\n    @Test\n    public void testAddedObjectsCanBeRetrievedByKey() throws Exception {\n        final Collection<String> coll = makeTestCollection();\n        coll.add(\"12\");\n        coll.add(\"16\");\n        coll.add(\"1\");\n        coll.addAll(asList(\"2\", \"3\", \"4\"));\n\n        @SuppressWarnings(\"unchecked\")\n        final IndexedCollection<Integer, String> indexed = (IndexedCollection<Integer, String>) coll;\n        assertEquals(\"12\", indexed.get(12));\n        assertEquals(\"16\", indexed.get(16));\n        assertEquals(\"1\", indexed.get(1));\n        assertEquals(\"2\", indexed.get(2));\n        assertEquals(\"3\", indexed.get(3));\n        assertEquals(\"4\", indexed.get(4));\n    }\n\n    @Test\n    public void testDecoratedCollectionIsIndexedOnCreation() throws Exception {\n        final Collection<String> original = makeFullCollection();\n        final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);\n\n        assertEquals(\"1\", indexed.get(1));\n        assertEquals(\"2\", indexed.get(2));\n        assertEquals(\"3\", indexed.get(3));\n    }\n\n    @Test\n    public void testEnsureDuplicateObjectsCauseException() throws Exception {\n        final Collection<String> coll = makeUniqueTestCollection();\n\n        coll.add(\"1\");\n\n        assertThrows(IllegalArgumentException.class, () -> coll.add(\"1\"));\n    }\n\n    @Test\n    public void testReindexUpdatesIndexWhenDecoratedCollectionIsModifiedSeparately() throws Exception {\n        final Collection<String> original = new ArrayList<>();\n        final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);\n\n        original.add(\"1\");\n        original.add(\"2\");\n        original.add(\"3\");\n\n        assertNull(indexed.get(1));\n        assertNull(indexed.get(2));\n        assertNull(indexed.get(3));\n\n        indexed.reindex();\n\n        assertEquals(\"1\", indexed.get(1));\n        assertEquals(\"2\", indexed.get(2));\n        assertEquals(\"3\", indexed.get(3));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest", "name": "UnmodifiableBoundedCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest.[]UnmodifiableBoundedCollectionTest()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest.[BoundedCollection<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest.[Collection<E>]makeObject()", "src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java.UnmodifiableBoundedCollectionTest.[boolean]skipSerializedCanonicalTests()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link UnmodifiableBoundedCollection} implementation.\n", "original_string": "public class UnmodifiableBoundedCollectionTest<E> extends AbstractCollectionTest<E> {\n\n    public UnmodifiableBoundedCollectionTest() {\n        super(UnmodifiableBoundedCollectionTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        return new ArrayList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    public BoundedCollection<E> makeFullCollection() {\n        final E[] allElements = getFullElements();\n        final BoundedCollection<E> coll = FixedSizeList.<E>fixedSizeList(new ArrayList<>(Arrays.asList(allElements)));\n        return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n    }\n\n    @Override\n    public Collection<E> makeObject() {\n        final BoundedCollection<E> coll = FixedSizeList.<E>fixedSizeList(new ArrayList<>());\n        return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n    }\n\n    @Override\n    protected boolean skipSerializedCanonicalTests() {\n        return true;\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final BoundedCollection<E> coll = makeFullCollection();\n        assertSame(coll, UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableBoundedCollection.unmodifiableBoundedCollection(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullCollection() instanceof Unmodifiable);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_isEmptyTest.java.CompositeCollection_isEmptyTest", "name": "CompositeCollection_isEmptyTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_isEmptyTest.java", "superclasses": "", "methods": ["[void]testIsEmptyWhenEmpty()", "[void]testIsEmptyWhenNotEmpty()", "[void]testIsEmptyAfterClear()", "[void]testIsEmptyAfterAddAndRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_isEmptyTest.java.CompositeCollection_isEmptyTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_isEmptyTest {\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    public void setUp() {\n        c = new CompositeCollection<>();\n        one = new ArrayList<>();\n        two = new ArrayList<>();\n    }\n\n    @Test\n    public void testIsEmptyWhenEmpty() {\n        assertTrue(c.isEmpty());\n    }\n\n    @Test\n    public void testIsEmptyWhenNotEmpty() {\n        one.add(\"1\");\n        c.addComposited(one);\n        assertFalse(c.isEmpty());\n    }\n\n    @Test\n    public void testIsEmptyAfterClear() {\n        one.add(\"1\");\n        c.addComposited(one);\n        c.clear();\n        assertTrue(c.isEmpty());\n    }\n\n    @Test\n    public void testIsEmptyAfterAddAndRemove() {\n        one.add(\"1\");\n        c.addComposited(one);\n        one.clear(); // Remove the element from the underlying collection instead of using c.remove()\n        assertTrue(c.isEmpty());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_nonUniqueIndexedCollectionTest.java.IndexedCollection_nonUniqueIndexedCollectionTest", "name": "IndexedCollection_nonUniqueIndexedCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_nonUniqueIndexedCollectionTest.java", "superclasses": "", "methods": ["[void]testNonUniqueIndexedCollection()", "[void]testNonUniqueIndexedCollectionWithEmptyCollection()", "[void]testNonUniqueIndexedCollectionWithDuplicateKeys()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/IndexedCollection_nonUniqueIndexedCollectionTest.java.IndexedCollection_nonUniqueIndexedCollectionTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexedCollection_nonUniqueIndexedCollectionTest {\n\n    private Transformer<String, Integer> keyTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        keyTransformer = new Transformer<String, Integer>() {\n            @Override\n            public Integer transform(String input) {\n                return Integer.parseInt(input);\n            }\n        };\n    }\n\n    @Test\n    public void testNonUniqueIndexedCollection() {\n        Collection<String> coll = Arrays.asList(\"1\", \"2\", \"3\");\n        IndexedCollection<Integer, String> indexedCollection = IndexedCollection.nonUniqueIndexedCollection(coll, keyTransformer);\n\n        assertNotNull(indexedCollection);\n        assertEquals(3, indexedCollection.size());\n        assertTrue(indexedCollection.contains(\"1\"));\n        assertTrue(indexedCollection.contains(\"2\"));\n        assertTrue(indexedCollection.contains(\"3\"));\n    }\n\n    @Test\n    public void testNonUniqueIndexedCollectionWithEmptyCollection() {\n        Collection<String> coll = Arrays.asList();\n        IndexedCollection<Integer, String> indexedCollection = IndexedCollection.nonUniqueIndexedCollection(coll, keyTransformer);\n\n        assertNotNull(indexedCollection);\n        assertEquals(0, indexedCollection.size());\n    }\n\n    @Test\n    public void testNonUniqueIndexedCollectionWithDuplicateKeys() {\n        Collection<String> coll = Arrays.asList(\"1\", \"2\", \"2\", \"3\");\n        IndexedCollection<Integer, String> indexedCollection = IndexedCollection.nonUniqueIndexedCollection(coll, keyTransformer);\n\n        assertNotNull(indexedCollection);\n        assertEquals(4, indexedCollection.size());\n        assertTrue(indexedCollection.contains(\"1\"));\n        assertTrue(indexedCollection.contains(\"2\"));\n        assertTrue(indexedCollection.contains(\"3\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Transformer<String, Integer> keyTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, Integer>", "name": "keyTransformer", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_getTest.java.IndexedCollection_getTest", "name": "IndexedCollection_getTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_getTest.java", "superclasses": "", "methods": ["[void]testGetWithExistingKey()", "[void]testGetWithNonExistingKey()", "[void]testGetAfterReindex()", "[void]testGetAfterAddToIndex()", "[void]testGetAfterRemoveFromIndex()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/IndexedCollection_getTest.java.IndexedCollection_getTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexedCollection_getTest {\n\n    private IndexedCollection<Integer, String> indexedCollection;\n    private Transformer<String, Integer> keyTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        keyTransformer = new Transformer<String, Integer>() {\n            @Override\n            public Integer transform(String input) {\n                return Integer.parseInt(input);\n            }\n        };\n        indexedCollection = new IndexedCollection<>(new ArrayList<>(), keyTransformer,\n                MultiValueMap.<Integer, String>multiValueMap(new HashMap<>()), false);\n    }\n\n    @Test\n    public void testGetWithExistingKey() {\n        indexedCollection.add(\"1\");\n        indexedCollection.add(\"2\");\n        indexedCollection.add(\"3\");\n\n        assertEquals(\"1\", indexedCollection.get(1));\n        assertEquals(\"2\", indexedCollection.get(2));\n        assertEquals(\"3\", indexedCollection.get(3));\n    }\n\n    @Test\n    public void testGetWithNonExistingKey() {\n        indexedCollection.add(\"1\");\n        indexedCollection.add(\"2\");\n        indexedCollection.add(\"3\");\n\n        assertNull(indexedCollection.get(4));\n    }\n\n    @Test\n    public void testGetAfterReindex() {\n        Collection<String> original = new ArrayList<>();\n        original.add(\"1\");\n        original.add(\"2\");\n        original.add(\"3\");\n\n        indexedCollection = new IndexedCollection<>(original, keyTransformer,\n                MultiValueMap.<Integer, String>multiValueMap(new HashMap<>()), false);\n\n        indexedCollection.reindex();\n\n        assertEquals(\"1\", indexedCollection.get(1));\n        assertEquals(\"2\", indexedCollection.get(2));\n        assertEquals(\"3\", indexedCollection.get(3));\n    }\n\n    @Test\n    public void testGetAfterAddToIndex() {\n        indexedCollection.add(\"1\");\n        indexedCollection.add(\"2\");\n        indexedCollection.add(\"3\");\n\n        assertEquals(\"1\", indexedCollection.get(1));\n        assertEquals(\"2\", indexedCollection.get(2));\n        assertEquals(\"3\", indexedCollection.get(3));\n\n        indexedCollection.add(\"4\");\n\n        assertEquals(\"4\", indexedCollection.get(4));\n    }\n\n    @Test\n    public void testGetAfterRemoveFromIndex() {\n        indexedCollection.add(\"1\");\n        indexedCollection.add(\"2\");\n        indexedCollection.add(\"3\");\n\n        assertEquals(\"1\", indexedCollection.get(1));\n        assertEquals(\"2\", indexedCollection.get(2));\n        assertEquals(\"3\", indexedCollection.get(3));\n\n        indexedCollection.remove(\"2\");\n\n        assertNull(indexedCollection.get(2));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private IndexedCollection<Integer, String> indexedCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IndexedCollection<Integer, String>", "name": "indexedCollection", "syntax_pass": true}, {"attribute_expression": "private Transformer<String, Integer> keyTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, Integer>", "name": "keyTransformer", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_removeTest.java.CompositeCollection_removeTest", "name": "CompositeCollection_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveMutator()", "[void]testRemoveWithoutMutator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_removeTest.java.CompositeCollection_removeTest.[void]setUpTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_removeTest {\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    protected void setUpTest() {\n        c = new CompositeCollection<>();\n        one = new HashSet<>();\n        two = new HashSet<>();\n    }\n\n    @Test\n    @SuppressWarnings({ \"unchecked\", \"serial\" })\n    public void testRemoveMutator() {\n        setUpTest();\n        c.setMutator(new CompositeCollection.CollectionMutator<String>() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public boolean add(final CompositeCollection<String> composite,\n                    final List<Collection<String>> collections, final String obj) {\n                for (final Collection<String> collection : collections) {\n                    collection.add(obj);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean addAll(final CompositeCollection<String> composite,\n                    final List<Collection<String>> collections, final Collection<? extends String> coll) {\n                for (final Collection<String> collection : collections) {\n                    collection.addAll(coll);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean remove(final CompositeCollection<String> composite,\n                    final List<Collection<String>> collections, final Object obj) {\n                for (final Collection<String> collection : collections) {\n                    collection.remove(obj);\n                }\n                return true;\n            }\n        });\n\n        c.addComposited(one);\n        one.add(\"foo\"); // Directly add to the collection\n        assertTrue(c.contains(\"foo\"));\n        assertTrue(one.contains(\"foo\"));\n\n        assertTrue(c.remove(\"foo\"));\n        assertFalse(c.contains(\"foo\"));\n        assertFalse(one.contains(\"foo\"));\n    }\n\n    @Test\n    public void testRemoveWithoutMutator() {\n        setUpTest();\n        c.addComposited(one);\n        one.add(\"foo\"); // Directly add to the collection\n        assertTrue(c.contains(\"foo\"));\n        assertTrue(one.contains(\"foo\"));\n\n        assertThrows(UnsupportedOperationException.class, () -> c.remove(\"foo\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest", "name": "PredicatedCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java", "superclasses": "", "methods": ["[void]testIllegalAdd()", "[void]testIllegalAddAll()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest.[]PredicatedCollectionTest()", "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest.[Collection<E>]decorateCollection(Collection<E>,Predicate<E>)", "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest.[E[]]getFullElements()", "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest.[Collection<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest.[Collection<E>]makeObject()", "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java.PredicatedCollectionTest.[Collection<E>]makeTestCollection()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link PredicatedCollection} implementation.\n", "original_string": "public class PredicatedCollectionTest<E> extends AbstractCollectionTest<E> {\n\n    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n\n    protected Predicate<E> testPredicate =\n        String.class::isInstance;\n\n    public PredicatedCollectionTest() {\n        super(PredicatedCollectionTest.class.getSimpleName());\n    }\n\n    protected Collection<E> decorateCollection(\n                final Collection<E> collection, final Predicate<E> predicate) {\n        return PredicatedCollection.predicatedCollection(collection, predicate);\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E[] getFullElements() {\n        return (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n    }\n\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        return new ArrayList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    public Collection<E> makeFullCollection() {\n        final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));\n        return decorateCollection(list, truePredicate);\n    }\n\n    @Override\n    public Collection<E> makeObject() {\n        return decorateCollection(new ArrayList<>(), truePredicate);\n    }\n\n    public Collection<E> makeTestCollection() {\n        return decorateCollection(new ArrayList<>(), testPredicate);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAdd() {\n        final Collection<E> c = makeTestCollection();\n        final Integer i = 3;\n\n        assertThrows(IllegalArgumentException.class, () -> c.add((E) i), \"Integer should fail string predicate.\");\n\n        assertFalse(c.contains(i), \"Collection shouldn't contain illegal element\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAddAll() {\n        final Collection<E> c = makeTestCollection();\n        final List<E> elements = new ArrayList<>();\n        elements.add((E) \"one\");\n        elements.add((E) \"two\");\n        elements.add((E) Integer.valueOf(3));\n        elements.add((E) \"four\");\n\n        assertThrows(IllegalArgumentException.class, () -> c.addAll(elements), \"Integer should fail string predicate.\");\n\n        assertFalse(c.contains(\"one\"), \"Collection shouldn't contain illegal element\");\n        assertFalse(c.contains(\"two\"), \"Collection shouldn't contain illegal element\");\n        assertFalse(c.contains(3), \"Collection shouldn't contain illegal element\");\n        assertFalse(c.contains(\"four\"), \"Collection shouldn't contain illegal element\");\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedCollection.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedCollection.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "truePredicate = TruePredicate.<E>truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected Predicate<E> testPredicate =\n        String.class::isInstance;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "testPredicate =\n        String.class::isInstance", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_addAllTest.java.CompositeCollection_addAllTest", "name": "CompositeCollection_addAllTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_addAllTest.java", "superclasses": "", "methods": ["[void]testAddAllWithMutator()", "[void]testAddAllWithoutMutator()", "[void]testAddAllWithEmptyCollection()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_addAllTest.java.CompositeCollection_addAllTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_addAllTest {\n\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    public void setUp() {\n        c = new CompositeCollection<>();\n        one = new ArrayList<>(Arrays.asList(\"1\", \"2\"));\n        two = new HashSet<>(Arrays.asList(\"3\", \"4\"));\n    }\n\n    @Test\n    public void testAddAllWithMutator() {\n        CompositeCollection.CollectionMutator<String> mutator = new CompositeCollection.CollectionMutator<String>() {\n            @Override\n            public boolean add(CompositeCollection<String> composite, List<Collection<String>> collections, String obj) {\n                for (Collection<String> coll : collections) {\n                    coll.add(obj);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean addAll(CompositeCollection<String> composite, List<Collection<String>> collections, Collection<? extends String> coll) {\n                for (Collection<String> collection : collections) {\n                    collection.addAll(coll);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean remove(CompositeCollection<String> composite, List<Collection<String>> collections, Object obj) {\n                for (Collection<String> coll : collections) {\n                    coll.remove(obj);\n                }\n                return true;\n            }\n        };\n\n        c.setMutator(mutator);\n        c.addComposited(one, two);\n\n        Collection<String> newElements = Arrays.asList(\"5\", \"6\");\n        assertTrue(c.addAll(newElements));\n        assertTrue(one.containsAll(newElements));\n        assertTrue(two.containsAll(newElements));\n    }\n\n    @Test\n    public void testAddAllWithoutMutator() {\n        assertThrows(UnsupportedOperationException.class, () -> {\n            c.addAll(Arrays.asList(\"5\", \"6\"));\n        });\n    }\n\n    @Test\n    public void testAddAllWithEmptyCollection() {\n        CompositeCollection.CollectionMutator<String> mutator = new CompositeCollection.CollectionMutator<String>() {\n            @Override\n            public boolean add(CompositeCollection<String> composite, List<Collection<String>> collections, String obj) {\n                for (Collection<String> coll : collections) {\n                    coll.add(obj);\n                }\n                return true;\n            }\n\n            @Override\n            public boolean addAll(CompositeCollection<String> composite, List<Collection<String>> collections, Collection<? extends String> coll) {\n                for (Collection<String> collection : collections) {\n                    collection.addAll(coll);\n                }\n                return !coll.isEmpty();\n            }\n\n            @Override\n            public boolean remove(CompositeCollection<String> composite, List<Collection<String>> collections, Object obj) {\n                for (Collection<String> coll : collections) {\n                    coll.remove(obj);\n                }\n                return true;\n            }\n        };\n\n        c.setMutator(mutator);\n        c.addComposited(one, two);\n\n        Collection<String> emptyCollection = new ArrayList<>();\n        assertFalse(c.addAll(emptyCollection));\n        assertEquals(4, c.size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_containsAllTest.java.CompositeCollection_containsAllTest", "name": "CompositeCollection_containsAllTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_containsAllTest.java", "superclasses": "", "methods": ["[void]testContainsAllWithNullCollection()", "[void]testContainsAllWithEmptyCollection()", "[void]testContainsAllWithAllElementsPresent()", "[void]testContainsAllWithSomeElementsMissing()", "[void]testContainsAllAfterAddingElements()", "[void]testContainsAllAfterClearingCollection()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_containsAllTest.java.CompositeCollection_containsAllTest.[void]setUpTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_containsAllTest {\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    protected void setUpTest() {\n        c = new CompositeCollection<>();\n        one = new HashSet<>(Arrays.asList(\"a\", \"b\", \"c\"));\n        two = new HashSet<>(Arrays.asList(\"d\", \"e\", \"f\"));\n        c.addComposited(one, two);\n    }\n\n    @Test\n    public void testContainsAllWithNullCollection() {\n        assertFalse(c.containsAll(null));\n    }\n\n    @Test\n    public void testContainsAllWithEmptyCollection() {\n        assertTrue(c.containsAll(new ArrayList<>()));\n    }\n\n    @Test\n    public void testContainsAllWithAllElementsPresent() {\n        Collection<String> testCollection = Arrays.asList(\"a\", \"d\");\n        assertTrue(c.containsAll(testCollection));\n    }\n\n    @Test\n    public void testContainsAllWithSomeElementsMissing() {\n        Collection<String> testCollection = Arrays.asList(\"a\", \"x\");\n        assertFalse(c.containsAll(testCollection));\n    }\n\n    @Test\n    public void testContainsAllAfterAddingElements() {\n        Collection<String> newCollection = new HashSet<>(Arrays.asList(\"g\"));\n        c.addComposited(newCollection);\n        Collection<String> testCollection = Arrays.asList(\"a\", \"g\");\n        assertTrue(c.containsAll(testCollection));\n    }\n\n    @Test\n    public void testContainsAllAfterClearingCollection() {\n        c.clear();\n        Collection<String> testCollection = Arrays.asList(\"a\", \"d\");\n        assertFalse(c.containsAll(testCollection));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeIfTest.java.IndexedCollection_removeIfTest", "name": "IndexedCollection_removeIfTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeIfTest.java", "superclasses": "", "methods": ["[void]testRemoveIfWithNullFilter()", "[void]testRemoveIfWithNoMatches()", "[void]testRemoveIfWithMatches()", "[void]testRemoveIfWithAllMatches()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeIfTest.java.IndexedCollection_removeIfTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeIfTest.java.IndexedCollection_removeIfTest.[IndexedCollection<Integer, String>]decorateUniqueCollection(Collection<String>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexedCollection_removeIfTest {\n\n    private IndexedCollection<Integer, String> indexedCollection;\n    private Collection<String> originalCollection;\n\n    @BeforeEach\n    public void setUp() {\n        originalCollection = new ArrayList<>(asList(\"1\", \"2\", \"3\"));\n        indexedCollection = decorateUniqueCollection(originalCollection);\n    }\n\n    @Test\n    public void testRemoveIfWithNullFilter() {\n        assertFalse(indexedCollection.removeIf(null));\n    }\n\n    @Test\n    public void testRemoveIfWithNoMatches() {\n        Predicate<String> filter = s -> s.equals(\"4\");\n        assertFalse(indexedCollection.removeIf(filter));\n    }\n\n    @Test\n    public void testRemoveIfWithMatches() {\n        Predicate<String> filter = s -> s.equals(\"2\");\n        assertTrue(indexedCollection.removeIf(filter));\n        assertFalse(originalCollection.contains(\"2\"));\n        indexedCollection.reindex();\n        assertNull(indexedCollection.get(2));\n    }\n\n    @Test\n    public void testRemoveIfWithAllMatches() {\n        Predicate<String> filter = s -> true;\n        assertTrue(indexedCollection.removeIf(filter));\n        assertTrue(originalCollection.isEmpty());\n        indexedCollection.reindex();\n        assertNull(indexedCollection.get(1));\n        assertNull(indexedCollection.get(2));\n        assertNull(indexedCollection.get(3));\n    }\n\n    private IndexedCollection<Integer, String> decorateUniqueCollection(Collection<String> original) {\n        Transformer<String, Integer> keyTransformer = s -> Integer.valueOf(s);\n        return IndexedCollection.uniqueIndexedCollection(original, keyTransformer);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private IndexedCollection<Integer, String> indexedCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IndexedCollection<Integer, String>", "name": "indexedCollection", "syntax_pass": true}, {"attribute_expression": "private Collection<String> originalCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "originalCollection", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeAllTest.java.IndexedCollection_removeAllTest", "name": "IndexedCollection_removeAllTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeAllTest.java", "superclasses": "", "methods": ["[void]testRemoveAllRemovesAllElements()", "[void]testRemoveAllReturnsFalseIfNoElementsRemoved()", "[void]testRemoveAllReindexesAfterRemoval()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeAllTest.java.IndexedCollection_removeAllTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeAllTest.java.IndexedCollection_removeAllTest.[IndexedCollection<Integer, String>]decorateUniqueCollection(Collection<String>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexedCollection_removeAllTest {\n\n    private IndexedCollection<Integer, String> indexedCollection;\n    private Collection<String> originalCollection;\n\n    @BeforeEach\n    public void setUp() {\n        originalCollection = new ArrayList<>(asList(\"1\", \"2\", \"3\"));\n        indexedCollection = decorateUniqueCollection(originalCollection);\n    }\n\n    @Test\n    public void testRemoveAllRemovesAllElements() {\n        Collection<String> toRemove = asList(\"1\", \"2\");\n        assertTrue(indexedCollection.removeAll(toRemove));\n        assertFalse(indexedCollection.contains(\"1\"));\n        assertFalse(indexedCollection.contains(\"2\"));\n        assertTrue(indexedCollection.contains(\"3\"));\n    }\n\n    @Test\n    public void testRemoveAllReturnsFalseIfNoElementsRemoved() {\n        Collection<String> toRemove = asList(\"4\", \"5\");\n        assertFalse(indexedCollection.removeAll(toRemove));\n        assertTrue(indexedCollection.contains(\"1\"));\n        assertTrue(indexedCollection.contains(\"2\"));\n        assertTrue(indexedCollection.contains(\"3\"));\n    }\n\n    @Test\n    public void testRemoveAllReindexesAfterRemoval() {\n        Collection<String> toRemove = asList(\"1\", \"2\");\n        indexedCollection.removeAll(toRemove);\n        assertEquals(\"3\", indexedCollection.get(3));\n        assertNull(indexedCollection.get(1));\n        assertNull(indexedCollection.get(2));\n    }\n\n    private IndexedCollection<Integer, String> decorateUniqueCollection(Collection<String> original) {\n        Transformer<String, Integer> keyTransformer = s -> Integer.valueOf(s);\n        return IndexedCollection.uniqueIndexedCollection(original, keyTransformer);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private IndexedCollection<Integer, String> indexedCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IndexedCollection<Integer, String>", "name": "indexedCollection", "syntax_pass": true}, {"attribute_expression": "private Collection<String> originalCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "originalCollection", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/TransformedCollection_transformedCollectionTest.java.TransformedCollection_transformedCollectionTest", "name": "TransformedCollection_transformedCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/TransformedCollection_transformedCollectionTest.java", "superclasses": "", "methods": ["[void]testTransformedCollectionWithNonEmptyCollection()", "[void]testTransformedCollectionWithEmptyCollection()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedCollection_transformedCollectionTest {\n\n    @Test\n    public void testTransformedCollectionWithNonEmptyCollection() {\n        // Given\n        Collection<String> originalCollection = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\n        Transformer<String, String> transformer = s -> s.toUpperCase();\n\n        // When\n        TransformedCollection<String> transformedCollection = TransformedCollection.transformedCollection(originalCollection, transformer);\n\n        // Then\n        assertEquals(3, transformedCollection.size());\n        assertTrue(transformedCollection.contains(\"A\"));\n        assertTrue(transformedCollection.contains(\"B\"));\n        assertTrue(transformedCollection.contains(\"C\"));\n    }\n\n    @Test\n    public void testTransformedCollectionWithEmptyCollection() {\n        // Given\n        Collection<String> originalCollection = Collections.emptyList();\n        Transformer<String, String> transformer = s -> s.toUpperCase();\n\n        // When\n        TransformedCollection<String> transformedCollection = TransformedCollection.transformedCollection(originalCollection, transformer);\n\n        // Then\n        assertTrue(transformedCollection.isEmpty());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/PredicatedCollection_addTest.java.PredicatedCollection_addTest", "name": "PredicatedCollection_addTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/PredicatedCollection_addTest.java", "superclasses": "", "methods": ["[void]testAddValidElement()", "[void]testAddInvalidElement()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PredicatedCollection_addTest {\n\n    @Test\n    public void testAddValidElement() {\n        Predicate<String> predicate = NotNullPredicate.notNullPredicate();\n        PredicatedCollection<String> predicatedCollection = new PredicatedCollection<>(new ArrayList<>(), predicate);\n\n        boolean result = predicatedCollection.add(\"validElement\");\n\n        assertTrue(result);\n        assertEquals(1, predicatedCollection.size());\n    }\n\n    @Test\n    public void testAddInvalidElement() {\n        Predicate<String> predicate = NotNullPredicate.notNullPredicate();\n        PredicatedCollection<String> predicatedCollection = new PredicatedCollection<>(new ArrayList<>(), predicate);\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            predicatedCollection.add(null);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_clearTest.java.CompositeCollection_clearTest", "name": "CompositeCollection_clearTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_clearTest.java", "superclasses": "", "methods": ["[void]testClear()", "[void]testClearWithEmptyComposite()", "[void]testClearWithSingleCollection()", "[void]testClearWithMultipleCollections()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_clearTest.java.CompositeCollection_clearTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_clearTest {\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    public void setUp() {\n        c = new CompositeCollection<>();\n        one = new HashSet<>();\n        two = new HashSet<>();\n        one.add(\"element1\");\n        one.add(\"element2\");\n        two.add(\"element3\");\n        c.addComposited(one, two);\n    }\n\n    @Test\n    public void testClear() {\n        // Given\n        assertEquals(3, c.size());\n        assertFalse(c.isEmpty());\n\n        // When\n        c.clear();\n\n        // Then\n        assertEquals(0, c.size());\n        assertTrue(c.isEmpty());\n    }\n\n    @Test\n    public void testClearWithEmptyComposite() {\n        // Given\n        CompositeCollection<String> emptyComposite = new CompositeCollection<>();\n\n        // When\n        emptyComposite.clear();\n\n        // Then\n        assertEquals(0, emptyComposite.size());\n        assertTrue(emptyComposite.isEmpty());\n    }\n\n    @Test\n    public void testClearWithSingleCollection() {\n        // Given\n        CompositeCollection<String> singleComposite = new CompositeCollection<>(one);\n        assertEquals(2, singleComposite.size());\n        assertFalse(singleComposite.isEmpty());\n\n        // When\n        singleComposite.clear();\n\n        // Then\n        assertEquals(0, singleComposite.size());\n        assertTrue(singleComposite.isEmpty());\n    }\n\n    @Test\n    public void testClearWithMultipleCollections() {\n        // Given\n        Collection<String> three = new HashSet<>();\n        three.add(\"element4\");\n        c.addComposited(three);\n        assertEquals(4, c.size());\n        assertFalse(c.isEmpty());\n\n        // When\n        c.clear();\n\n        // Then\n        assertEquals(0, c.size());\n        assertTrue(c.isEmpty());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeTest.java.IndexedCollection_removeTest", "name": "IndexedCollection_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveElementFromCollection()", "[void]testRemoveNonExistentElementFromCollection()", "[void]testRemoveElementAndReindex()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeTest.java.IndexedCollection_removeTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/collection/IndexedCollection_removeTest.java.IndexedCollection_removeTest.[IndexedCollection<Integer, String>]decorateUniqueCollection(Collection<String>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexedCollection_removeTest {\n\n    private IndexedCollection<Integer, String> indexedCollection;\n    private Collection<String> originalCollection;\n\n    @BeforeEach\n    public void setUp() {\n        originalCollection = new ArrayList<>();\n        indexedCollection = decorateUniqueCollection(originalCollection);\n    }\n\n    @Test\n    public void testRemoveElementFromCollection() {\n        originalCollection.add(\"1\");\n        originalCollection.add(\"2\");\n        originalCollection.add(\"3\");\n\n        indexedCollection.reindex();\n\n        assertTrue(indexedCollection.remove(\"2\"));\n        assertFalse(indexedCollection.contains(\"2\"));\n        assertEquals(2, indexedCollection.size());\n    }\n\n    @Test\n    public void testRemoveNonExistentElementFromCollection() {\n        originalCollection.add(\"1\");\n        originalCollection.add(\"2\");\n        originalCollection.add(\"3\");\n\n        indexedCollection.reindex();\n\n        assertFalse(indexedCollection.remove(\"4\"));\n        assertEquals(3, indexedCollection.size());\n    }\n\n    @Test\n    public void testRemoveElementAndReindex() {\n        originalCollection.add(\"1\");\n        originalCollection.add(\"2\");\n        originalCollection.add(\"3\");\n\n        indexedCollection.reindex();\n\n        assertTrue(indexedCollection.remove(\"2\"));\n        indexedCollection.reindex();\n\n        assertFalse(indexedCollection.contains(\"2\"));\n        assertEquals(2, indexedCollection.size());\n    }\n\n    private IndexedCollection<Integer, String> decorateUniqueCollection(Collection<String> original) {\n        Transformer<String, Integer> keyTransformer = s -> Integer.valueOf(s);\n        return IndexedCollection.uniqueIndexedCollection(original, keyTransformer);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private IndexedCollection<Integer, String> indexedCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IndexedCollection<Integer, String>", "name": "indexedCollection", "syntax_pass": true}, {"attribute_expression": "private Collection<String> originalCollection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "originalCollection", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_sizeTest.java.CompositeCollection_sizeTest", "name": "CompositeCollection_sizeTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/CompositeCollection_sizeTest.java", "superclasses": "", "methods": ["[void]testSizeWithEmptyComposite()", "[void]testSizeWithSingleCollection()", "[void]testSizeWithMultipleCollections()", "[void]testSizeAfterAddingElement()", "[void]testSizeAfterRemovingElement()", "[void]testSizeAfterRemovingCollection()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/CompositeCollection_sizeTest.java.CompositeCollection_sizeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeCollection_sizeTest {\n\n    private CompositeCollection<String> c;\n    private Collection<String> one;\n    private Collection<String> two;\n\n    @BeforeEach\n    public void setUp() {\n        c = new CompositeCollection<>();\n        one = new ArrayList<>(Arrays.asList(\"1\", \"2\"));\n        two = new HashSet<>(Arrays.asList(\"3\", \"4\"));\n    }\n\n    @Test\n    public void testSizeWithEmptyComposite() {\n        assertEquals(0, c.size());\n    }\n\n    @Test\n    public void testSizeWithSingleCollection() {\n        c.addComposited(one);\n        assertEquals(2, c.size());\n    }\n\n    @Test\n    public void testSizeWithMultipleCollections() {\n        c.addComposited(one, two);\n        assertEquals(4, c.size());\n    }\n\n    @Test\n    public void testSizeAfterAddingElement() {\n        c.addComposited(one);\n        Collection<String> temp = new ArrayList<>(one);\n        temp.add(\"5\");\n        c.removeComposited(one);\n        c.addComposited(temp);\n        assertEquals(3, c.size());\n    }\n\n    @Test\n    public void testSizeAfterRemovingElement() {\n        c.addComposited(one);\n        Collection<String> temp = new ArrayList<>(one);\n        temp.remove(\"1\");\n        c.removeComposited(one);\n        c.addComposited(temp);\n        assertEquals(1, c.size());\n    }\n\n    @Test\n    public void testSizeAfterRemovingCollection() {\n        c.addComposited(one, two);\n        c.removeComposited(one);\n        assertEquals(2, c.size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeCollection<String> c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeCollection<String>", "name": "c", "syntax_pass": true}, {"attribute_expression": "private Collection<String> one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "one", "syntax_pass": true}, {"attribute_expression": "private Collection<String> two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "two", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionBuilderTest.java.PredicatedCollectionBuilderTest", "name": "PredicatedCollectionBuilderTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionBuilderTest.java", "superclasses": "", "methods": ["[void]testAddAllPass()", "[void]testAddFail()", "[void]testAddPass()", "[void]testCreatePredicatedCollectionWithNotNullPredicate()", "[void]testCreatePredicatedCollectionWithPredicate()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionBuilderTest.java.PredicatedCollectionBuilderTest.[void]checkPredicatedCollection1(Collection<String>)", "src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionBuilderTest.java.PredicatedCollectionBuilderTest.[void]checkPredicatedCollection2(Collection<Integer>)"], "overrides": null, "attributes": [{"original_string": "    private static final class OddPredicate implements Predicate<Integer> {\n        @Override\n        public boolean evaluate(final Integer value) {\n            return value % 2 == 1;\n        }\n    }", "definition": "    private static final class OddPredicate implements Predicate<Integer>", "class_docstring": "", "name": "OddPredicate", "super_interfaces": ["Predicate<Integer>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean evaluate(final Integer value) {\n            return value % 2 == 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "evaluate", "params": [{"name": "value", "type": "Integer"}], "body": "                                                     {\n            return value % 2 == 1;\n        }", "signature": "@Override\n        public boolean evaluate(final Integer value)"}]}], "class_docstring": "\nTests the PredicatedCollection.Builder class.\n", "original_string": "public class PredicatedCollectionBuilderTest {\n\n    private static final class OddPredicate implements Predicate<Integer> {\n        @Override\n        public boolean evaluate(final Integer value) {\n            return value % 2 == 1;\n        }\n    }\n\n    private void checkPredicatedCollection1(final Collection<String> collection) {\n        assertEquals(1, collection.size());\n\n        collection.add(\"test2\");\n        assertEquals(2, collection.size());\n\n        assertThrows(IllegalArgumentException.class, () -> collection.add(null), \"Expecting IllegalArgumentException for failing predicate!\");\n\n    }\n\n    private void checkPredicatedCollection2(final Collection<Integer> collection) {\n        assertEquals(2, collection.size());\n        assertThrows(IllegalArgumentException.class, () -> collection.add(4), \"Expecting IllegalArgumentException for failing predicate!\");\n        assertEquals(2, collection.size());\n\n        collection.add(5);\n        assertEquals(3, collection.size());\n    }\n\n    /**\n     * Verify that only items that pass the Predicate end up in the buffer.\n     */\n    @Test\n    public void testAddAllPass() {\n        final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();\n        builder.addAll(Arrays.asList(\"test1\", null, \"test2\"));\n        assertEquals(builder.createPredicatedList().size(), 2);\n    }\n\n    /**\n     * Verify that failing the Predicate means NOT ending up in the buffer.\n     */\n    @Test\n    public void testAddFail() {\n        final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();\n        builder.add((String) null);\n        assertTrue(builder.createPredicatedList().isEmpty());\n\n        assertEquals(1, builder.rejectedElements().size());\n    }\n\n    /**\n     * Verify that passing the Predicate means ending up in the buffer.\n     */\n    @Test\n    public void testAddPass() {\n        final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();\n        builder.add(\"test\");\n        assertEquals(builder.createPredicatedList().size(), 1);\n    }\n\n    @Test\n    public void testCreatePredicatedCollectionWithNotNullPredicate() {\n        final PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();\n        builder.add(\"test1\");\n        builder.add((String) null);\n\n        final List<String> predicatedList = builder.createPredicatedList();\n        checkPredicatedCollection1(predicatedList);\n\n        final Set<String> predicatedSet = builder.createPredicatedSet();\n        checkPredicatedCollection1(predicatedSet);\n\n        final Bag<String> predicatedBag = builder.createPredicatedBag();\n        checkPredicatedCollection1(predicatedBag);\n\n        final Queue<String> predicatedQueue = builder.createPredicatedQueue();\n        checkPredicatedCollection1(predicatedQueue);\n    }\n\n    @Test\n    public void testCreatePredicatedCollectionWithPredicate() {\n        final OddPredicate p = new OddPredicate();\n        final PredicatedCollection.Builder<Integer> builder = PredicatedCollection.builder(p);\n\n        builder.add(1);\n        builder.add(2);\n        builder.add(3);\n\n        final List<Integer> predicatedList = builder.createPredicatedList();\n        checkPredicatedCollection2(predicatedList);\n\n        final Set<Integer> predicatedSet = builder.createPredicatedSet();\n        checkPredicatedCollection2(predicatedSet);\n\n        final Bag<Integer> predicatedBag = builder.createPredicatedBag();\n        checkPredicatedCollection2(predicatedBag);\n\n        final Queue<Integer> predicatedQueue = builder.createPredicatedQueue();\n        checkPredicatedCollection2(predicatedQueue);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_previousKeyTest.java.ListOrderedMap_previousKeyTest", "name": "ListOrderedMap_previousKeyTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_previousKeyTest.java", "superclasses": "", "methods": ["[void]testPreviousKey_existingKey()", "[void]testPreviousKey_firstKey()", "[void]testPreviousKey_nonExistingKey()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/ListOrderedMap_previousKeyTest.java.ListOrderedMap_previousKeyTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ListOrderedMap_previousKeyTest {\n\n    private ListOrderedMap<String, String> map;\n\n    @BeforeEach\n    void setUp() {\n        map = new ListOrderedMap<>();\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.put(\"key3\", \"value3\");\n    }\n\n    @Test\n    void testPreviousKey_existingKey() {\n        assertEquals(\"key2\", map.previousKey(\"key3\"));\n    }\n\n    @Test\n    void testPreviousKey_firstKey() {\n        assertNull(map.previousKey(\"key1\"));\n    }\n\n    @Test\n    void testPreviousKey_nonExistingKey() {\n        assertNull(map.previousKey(\"nonExistingKey\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ListOrderedMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListOrderedMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/TransformedMapTest.java.TransformedMapTest", "name": "TransformedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/TransformedMapTest.java", "superclasses": "", "methods": ["[void]testFactory_Decorate()", "[void]testFactory_decorateTransform()", "[void]testTransformedMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/TransformedMapTest.java.TransformedMapTest.[]TransformedMapTest()", "src/test/java/org/apache/commons/collections4/map/TransformedMapTest.java.TransformedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/TransformedMapTest.java.TransformedMapTest.[IterableMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMapTest} for exercising the {@link TransformedMap}\nimplementation.\n", "original_string": "public class TransformedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    public TransformedMapTest() {\n        super(TransformedMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public IterableMap<K, V> makeObject() {\n        return TransformedMap.transformingMap(new HashMap<>(), TransformerUtils.<K>nopTransformer(),\n                TransformerUtils.<V>nopTransformer());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFactory_Decorate() {\n        final Map<K, V> base = new HashMap<>();\n        base.put((K) \"A\", (V) \"1\");\n        base.put((K) \"B\", (V) \"2\");\n        base.put((K) \"C\", (V) \"3\");\n\n        final Map<K, V> trans = TransformedMap\n                .transformingMap(\n                        base,\n                        null,\n                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(3, trans.size());\n        assertEquals(\"1\", trans.get(\"A\"));\n        assertEquals(\"2\", trans.get(\"B\"));\n        assertEquals(\"3\", trans.get(\"C\"));\n        trans.put((K) \"D\", (V) \"4\");\n        assertEquals(Integer.valueOf(4), trans.get(\"D\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFactory_decorateTransform() {\n        final Map<K, V> base = new HashMap<>();\n        base.put((K) \"A\", (V) \"1\");\n        base.put((K) \"B\", (V) \"2\");\n        base.put((K) \"C\", (V) \"3\");\n\n        final Map<K, V> trans = TransformedMap\n                .transformedMap(\n                        base,\n                        (Transformer<? super K, ? extends K>) TransformedCollectionTest.TO_LOWER_CASE_TRANSFORMER,\n                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(3, trans.size());\n        assertEquals(Integer.valueOf(1), trans.get(\"a\"));\n        assertEquals(Integer.valueOf(2), trans.get(\"b\"));\n        assertEquals(Integer.valueOf(3), trans.get(\"c\"));\n        trans.put((K) \"D\", (V) \"4\");\n        assertEquals(Integer.valueOf(4), trans.get(\"d\"));\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @Test\n    public void testTransformedMap() {\n        final Object[] els = { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n\n        Map<K, V> map = TransformedMap\n                .transformingMap(\n                        new HashMap<>(),\n                        (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n                        null);\n        assertEquals(0, map.size());\n        for (int i = 0; i < els.length; i++) {\n            map.put((K) els[i], (V) els[i]);\n            assertEquals(i + 1, map.size());\n            assertTrue(map.containsKey(Integer.valueOf((String) els[i])));\n            assertFalse(map.containsKey(els[i]));\n            assertTrue(map.containsValue(els[i]));\n            assertEquals(els[i], map.get(Integer.valueOf((String) els[i])));\n        }\n\n        assertNull(map.remove(els[0]));\n        assertEquals(els[0], map.remove(Integer.valueOf((String) els[0])));\n\n        map = TransformedMap.transformingMap(new HashMap(), null,\n                                             // cast needed for eclipse compiler\n                                             (Transformer) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, map.size());\n        for (int i = 0; i < els.length; i++) {\n            map.put((K) els[i], (V) els[i]);\n            assertEquals(i + 1, map.size());\n            assertTrue(map.containsValue(Integer.valueOf((String) els[i])));\n            assertFalse(map.containsValue(els[i]));\n            assertTrue(map.containsKey(els[i]));\n            assertEquals(Integer.valueOf((String) els[i]), map.get(els[i]));\n        }\n\n        assertEquals(Integer.valueOf((String) els[0]), map.remove(els[0]));\n\n        final Set<Map.Entry<K, V>> entrySet = map.entrySet();\n        final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n        array[0].setValue((V) \"66\");\n        assertEquals(Integer.valueOf(66), array[0].getValue());\n        assertEquals(Integer.valueOf(66), map.get(array[0].getKey()));\n\n        final Map.Entry<K, V> entry = entrySet.iterator().next();\n        entry.setValue((V) \"88\");\n        assertEquals(Integer.valueOf(88), entry.getValue());\n        assertEquals(Integer.valueOf(88), map.get(entry.getKey()));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/TransformedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/TransformedMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/HashedMapTest.java.HashedMapTest", "name": "HashedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/HashedMapTest.java", "superclasses": "", "methods": ["[void]testClone()", "[void]testInitialCapacityZero()", "[void]testInternalState()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/HashedMapTest.java.HashedMapTest.[]HashedMapTest()", "src/test/java/org/apache/commons/collections4/map/HashedMapTest.java.HashedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/HashedMapTest.java.HashedMapTest.[HashedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class HashedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    public HashedMapTest() {\n        super(HashedMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public HashedMap<K, V> makeObject() {\n        return new HashedMap<>();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testClone() {\n        final HashedMap<K, V> map = new HashedMap<>(10);\n        map.put((K) \"1\", (V) \"1\");\n        final HashedMap<K, V> cloned = map.clone();\n        assertEquals(map.size(), cloned.size());\n        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n    }\n\n    /**\n     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n     */\n    @Test\n    public void testInitialCapacityZero() {\n        final HashedMap<String, String> map = new HashedMap<>(0);\n        assertEquals(1, map.data.length);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/HashedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/HashedMap.fullCollection.version4.obj\");\n//    }\n\n    @Test\n    public void testInternalState() {\n        final HashedMap<Integer, Integer> map = new HashedMap<>(42, 0.75f);\n        assertEquals(0.75f, map.loadFactor, 0.1f);\n        assertEquals(0, map.size);\n        assertEquals(64, map.data.length);\n        assertEquals(48, map.threshold);\n        assertEquals(0, map.modCount);\n\n        // contract: the capacity is ensured when too many elements are added\n        final HashedMap<Integer, Integer> tmpMap = new HashedMap<>();\n        // we need to put at least the \"threshold\" number of elements\n        // in order to double the capacity\n        for (int i = 1; i <= map.threshold; i++) {\n            tmpMap.put(i, i);\n        }\n        map.putAll(tmpMap);\n        // the threshold has changed due to calling ensureCapacity\n        assertEquals(96, map.threshold);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_getTest.java.MultiKeyMap_getTest", "name": "MultiKeyMap_getTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_getTest.java", "superclasses": "", "methods": ["[void]testGetExistingKey()", "[void]testGetNonExistingKey()", "[void]testGetAfterRemove()", "[void]testGetWithNullKeys()", "[void]testGetWithMixedKeys()", "[void]testGetWithMultipleEntries()", "[void]testGetWithOverwrittenEntry()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiKeyMap_getTest.java.MultiKeyMap_getTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiKeyMap_getTest {\n\n    private MultiKeyMap<Integer, String> multiKeyMap;\n\n    @BeforeEach\n    public void setUp() {\n        multiKeyMap = new MultiKeyMap<>();\n    }\n\n    @Test\n    public void testGetExistingKey() {\n        multiKeyMap.put(1, 2, \"1-2\");\n        assertEquals(\"1-2\", multiKeyMap.get(1, 2));\n    }\n\n    @Test\n    public void testGetNonExistingKey() {\n        assertNull(multiKeyMap.get(1, 2));\n    }\n\n    @Test\n    public void testGetAfterRemove() {\n        multiKeyMap.put(1, 2, \"1-2\");\n        multiKeyMap.removeMultiKey(1, 2);\n        assertNull(multiKeyMap.get(1, 2));\n    }\n\n    @Test\n    public void testGetWithNullKeys() {\n        multiKeyMap.put(null, null, \"null-null\");\n        assertEquals(\"null-null\", multiKeyMap.get(null, null));\n    }\n\n    @Test\n    public void testGetWithMixedKeys() {\n        multiKeyMap.put(1, null, \"1-null\");\n        multiKeyMap.put(null, 2, \"null-2\");\n        assertEquals(\"1-null\", multiKeyMap.get(1, null));\n        assertEquals(\"null-2\", multiKeyMap.get(null, 2));\n    }\n\n    @Test\n    public void testGetWithMultipleEntries() {\n        multiKeyMap.put(1, 2, \"1-2\");\n        multiKeyMap.put(1, 3, \"1-3\");\n        multiKeyMap.put(2, 2, \"2-2\");\n        assertEquals(\"1-2\", multiKeyMap.get(1, 2));\n        assertEquals(\"1-3\", multiKeyMap.get(1, 3));\n        assertEquals(\"2-2\", multiKeyMap.get(2, 2));\n    }\n\n    @Test\n    public void testGetWithOverwrittenEntry() {\n        multiKeyMap.put(1, 2, \"1-2\");\n        multiKeyMap.put(1, 2, \"new-1-2\");\n        assertEquals(\"new-1-2\", multiKeyMap.get(1, 2));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private MultiKeyMap<Integer, String> multiKeyMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MultiKeyMap<Integer, String>", "name": "multiKeyMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java.LazySortedMapTest", "name": "LazySortedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java", "superclasses": "", "methods": ["[void]testMapGet()", "[void]testReverseSortOrder()", "[void]testSortOrder()", "[void]testTransformerDecorate()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java.LazySortedMapTest.[]LazySortedMapTest()", "src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java.LazySortedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java.LazySortedMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java.LazySortedMapTest.[SortedMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    private static final class ReverseStringComparator implements Comparator<String> {\n\n        @Override\n        public int compare(final String arg0, final String arg1) {\n            return arg1.compareTo(arg0);\n        }\n\n    }", "definition": "    private static final class ReverseStringComparator implements Comparator<String>", "class_docstring": "", "name": "ReverseStringComparator", "super_interfaces": ["Comparator<String>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public int compare(final String arg0, final String arg1) {\n            return arg1.compareTo(arg0);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "arg0", "type": "String"}, {"name": "arg1", "type": "String"}], "body": "                                                                 {\n            return arg1.compareTo(arg0);\n        }", "signature": "@Override\n        public int compare(final String arg0, final String arg1)"}]}], "class_docstring": "\nExtension of {@link LazyMapTest} for exercising the\n{@link LazySortedMap} implementation.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class LazySortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n\n    private static final class ReverseStringComparator implements Comparator<String> {\n\n        @Override\n        public int compare(final String arg0, final String arg1) {\n            return arg1.compareTo(arg0);\n        }\n\n    }\n\n    private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n\n    protected final Comparator<String> reverseStringComparator = new ReverseStringComparator();\n\n    public LazySortedMapTest() {\n        super(LazySortedMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public SortedMap<K, V> makeObject() {\n        return lazySortedMap(new TreeMap<>(), FactoryUtils.<V>nullFactory());\n    }\n\n    @Override\n    @Test\n    public void testMapGet() {\n        Map<Integer, Number> map = lazySortedMap(new TreeMap<>(), oneFactory);\n        assertEquals(0, map.size());\n        final Number i1 = map.get(5);\n        assertEquals(1, i1);\n        assertEquals(1, map.size());\n\n        map = lazySortedMap(new TreeMap<>(), FactoryUtils.<Number>nullFactory());\n        final Number o = map.get(5);\n        assertNull(o);\n        assertEquals(1, map.size());\n\n    }\n\n    @Test\n    public void testReverseSortOrder() {\n        final SortedMap<String, Number> map = lazySortedMap(new ConcurrentSkipListMap<>(reverseStringComparator), oneFactory);\n        map.put(\"A\", 5);\n        map.get(\"B\"); // Entry with value \"One\" created\n        map.put(\"C\", 8);\n        assertEquals(\"A\", map.lastKey(), \"Last key should be A\");\n        assertEquals(\"C\", map.firstKey(), \"First key should be C\");\n        assertEquals(\"B\", map.tailMap(\"B\").firstKey(),\n                \"First key in tail map should be B\");\n        assertEquals(\"B\", map.headMap(\"A\").lastKey(),\n                \"Last key in head map should be B\");\n        assertEquals(\"B\", map.subMap(\"C\", \"A\").lastKey(),\n                \"Last key in submap should be B\");\n\n        final Comparator<?> c = map.comparator();\n        assertSame(c, reverseStringComparator, \"natural order, so comparator should be null\");\n    }\n\n    @Test\n    public void testSortOrder() {\n        final SortedMap<String, Number> map = lazySortedMap(new TreeMap<>(), oneFactory);\n        map.put(\"A\",  5);\n        map.get(\"B\"); // Entry with value \"One\" created\n        map.put(\"C\", 8);\n        assertEquals(\"A\", map.firstKey(), \"First key should be A\");\n        assertEquals(\"C\", map.lastKey(), \"Last key should be C\");\n        assertEquals(\"B\", map.tailMap(\"B\").firstKey(),\n                \"First key in tail map should be B\");\n        assertEquals(\"B\", map.headMap(\"C\").lastKey(),\n                \"Last key in head map should be B\");\n        assertEquals(\"B\", map.subMap(\"A\", \"C\").lastKey(),\n                \"Last key in submap should be B\");\n\n        final Comparator<?> c = map.comparator();\n        assertNull(c, \"natural order, so comparator should be null\");\n    }\n\n    @Test\n    public void testTransformerDecorate() {\n        final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);\n        final SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<>(), transformer);\n        assertInstanceOf(LazySortedMap.class, map);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> lazySortedMap(new TreeMap<>(), (Transformer<Integer, Number>) null),\n                        \"Expecting NullPointerException for null transformer\"),\n                () -> assertThrows(NullPointerException.class, () -> lazySortedMap((SortedMap<Integer, Number>) null, transformer),\n                        \"Expecting NullPointerException for null map\")\n        );\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/LazySortedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/LazySortedMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Factory<Integer>", "name": "oneFactory = FactoryUtils.constantFactory(1)", "syntax_pass": true}, {"attribute_expression": "protected final Comparator<String> reverseStringComparator = new ReverseStringComparator();", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Comparator<String>", "name": "reverseStringComparator = new ReverseStringComparator()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/UnmodifiableMap_entrySetTest.java.UnmodifiableMap_entrySetTest", "name": "UnmodifiableMap_entrySetTest", "file_path": "src/test/java/org/apache/commons/collections4/map/UnmodifiableMap_entrySetTest.java", "superclasses": "", "methods": ["[void]testEntrySet()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnmodifiableMap_entrySetTest {\n\n    @Test\n    public void testEntrySet() {\n        // Given\n        Map<String, String> originalMap = new HashMap<>();\n        originalMap.put(\"key1\", \"value1\");\n        originalMap.put(\"key2\", \"value2\");\n        Map<String, String> unmodifiableMap = UnmodifiableMap.unmodifiableMap(originalMap);\n\n        // When\n        Set<Map.Entry<String, String>> entrySet = unmodifiableMap.entrySet();\n\n        // Then\n        assertEquals(2, entrySet.size());\n        assertTrue(entrySet.containsAll(originalMap.entrySet()));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/LazySortedMap_headMapTest.java.LazySortedMap_headMapTest", "name": "LazySortedMap_headMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LazySortedMap_headMapTest.java", "superclasses": "", "methods": ["[void]testHeadMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LazySortedMap_headMapTest {\n\n    @Test\n    public void testHeadMap() {\n        // Given\n        SortedMap<Integer, String> originalMap = new TreeMap<>();\n        originalMap.put(1, \"One\");\n        originalMap.put(2, \"Two\");\n        originalMap.put(3, \"Three\");\n\n        Factory<String> factory = () -> \"Default\";\n        LazySortedMap<Integer, String> lazySortedMap = LazySortedMap.lazySortedMap(originalMap, factory);\n\n        // When\n        SortedMap<Integer, String> headMap = lazySortedMap.headMap(3);\n\n        // Then\n        assertEquals(2, headMap.size());\n        assertTrue(headMap.containsKey(1));\n        assertTrue(headMap.containsKey(2));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_removeTest.java.StaticBucketMap_removeTest", "name": "StaticBucketMap_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveExistingKey()", "[void]testRemoveNonExistingKey()", "[void]testRemoveNullKey()", "[void]testRemoveFromEmptyMap()", "[void]testRemoveWithMultipleEntriesInBucket()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/StaticBucketMap_removeTest.java.StaticBucketMap_removeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StaticBucketMap_removeTest {\n\n    private StaticBucketMap<String, String> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new StaticBucketMap<>(17);\n    }\n\n    @Test\n    public void testRemoveExistingKey() {\n        map.put(\"key1\", \"value1\");\n        assertTrue(map.containsKey(\"key1\"));\n        assertEquals(\"value1\", map.remove(\"key1\"));\n        assertFalse(map.containsKey(\"key1\"));\n    }\n\n    @Test\n    public void testRemoveNonExistingKey() {\n        assertFalse(map.containsKey(\"key2\"));\n        assertNull(map.remove(\"key2\"));\n    }\n\n    @Test\n    public void testRemoveNullKey() {\n        map.put(null, \"nullValue\");\n        assertTrue(map.containsKey(null));\n        assertEquals(\"nullValue\", map.remove(null));\n        assertFalse(map.containsKey(null));\n    }\n\n    @Test\n    public void testRemoveFromEmptyMap() {\n        assertFalse(map.containsKey(\"key3\"));\n        assertNull(map.remove(\"key3\"));\n    }\n\n    @Test\n    public void testRemoveWithMultipleEntriesInBucket() {\n        map.put(\"key4\", \"value4\");\n        map.put(\"key5\", \"value5\");\n        assertTrue(map.containsKey(\"key4\"));\n        assertTrue(map.containsKey(\"key5\"));\n        assertEquals(\"value4\", map.remove(\"key4\"));\n        assertFalse(map.containsKey(\"key4\"));\n        assertTrue(map.containsKey(\"key5\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private StaticBucketMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StaticBucketMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_putAllTest.java.ListOrderedMap_putAllTest", "name": "ListOrderedMap_putAllTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_putAllTest.java", "superclasses": "", "methods": ["[void]testPutAll_IndexOutOfBounds()", "[void]testPutAll_AddNewEntries()", "[void]testPutAll_ReplaceExistingEntries()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/ListOrderedMap_putAllTest.java.ListOrderedMap_putAllTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ListOrderedMap_putAllTest {\n\n    private ListOrderedMap<Integer, String> map;\n\n    @BeforeEach\n    void setUp() {\n        map = new ListOrderedMap<>();\n    }\n\n    @Test\n    void testPutAll_IndexOutOfBounds() {\n        Map<Integer, String> inputMap = new HashMap<>();\n        inputMap.put(1, \"one\");\n        inputMap.put(2, \"two\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> map.putAll(-1, inputMap));\n        assertThrows(IndexOutOfBoundsException.class, () -> map.putAll(1, inputMap));\n    }\n\n    @Test\n    void testPutAll_AddNewEntries() {\n        Map<Integer, String> inputMap = new HashMap<>();\n        inputMap.put(1, \"one\");\n        inputMap.put(2, \"two\");\n\n        map.putAll(0, inputMap);\n\n        assertEquals(2, map.size());\n        assertEquals(\"one\", map.getValue(0));\n        assertEquals(\"two\", map.getValue(1));\n    }\n\n    @Test\n    void testPutAll_ReplaceExistingEntries() {\n        map.put(1, \"oldOne\");\n        map.put(2, \"oldTwo\");\n\n        Map<Integer, String> inputMap = new HashMap<>();\n        inputMap.put(1, \"newOne\");\n        inputMap.put(2, \"newTwo\");\n\n        map.putAll(0, inputMap);\n\n        assertEquals(2, map.size());\n        assertEquals(\"newOne\", map.getValue(0));\n        assertEquals(\"newTwo\", map.getValue(1));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ListOrderedMap<Integer, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListOrderedMap<Integer, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_sizeTest.java.StaticBucketMap_sizeTest", "name": "StaticBucketMap_sizeTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_sizeTest.java", "superclasses": "", "methods": ["[void]testSize()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class StaticBucketMap_sizeTest {\n\n    @Test\n    void testSize() {\n        StaticBucketMap<Integer, String> map = new StaticBucketMap<>(1);\n\n        // Given: Map with one entry\n        map.put(1, \"one\");\n\n        // When: Calculating size\n        int size = map.size();\n\n        // Then: Size should be 1\n        assertEquals(1, size);\n\n        // Given: Map with one entry removed\n        map.remove(1);\n\n        // When: Calculating size\n        size = map.size();\n\n        // Then: Size should be 0\n        assertEquals(0, size);\n\n        // Given: Map with all entries cleared\n        map.put(2, \"two\");\n        map.clear();\n\n        // When: Calculating size\n        size = map.size();\n\n        // Then: Size should be 0\n        assertEquals(0, size);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_containsKeyTest.java.StaticBucketMap_containsKeyTest", "name": "StaticBucketMap_containsKeyTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_containsKeyTest.java", "superclasses": "", "methods": ["[void]testContainsKey_KeyExists()", "[void]testContainsKey_KeyDoesNotExist()", "[void]testContainsKey_KeyRemoved()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/StaticBucketMap_containsKeyTest.java.StaticBucketMap_containsKeyTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class StaticBucketMap_containsKeyTest {\n\n    private StaticBucketMap<String, String> map;\n\n    @BeforeEach\n    void setUp() {\n        map = new StaticBucketMap<>(1); // Using 1 bucket for simplicity\n    }\n\n    @Test\n    void testContainsKey_KeyExists() {\n        map.put(\"key1\", \"value1\");\n        assertTrue(map.containsKey(\"key1\"));\n    }\n\n    @Test\n    void testContainsKey_KeyDoesNotExist() {\n        assertFalse(map.containsKey(\"key2\"));\n    }\n\n    @Test\n    void testContainsKey_KeyRemoved() {\n        map.put(\"key3\", \"value3\");\n        map.remove(\"key3\");\n        assertFalse(map.containsKey(\"key3\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private StaticBucketMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StaticBucketMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/LazySortedMap_subMapTest.java.LazySortedMap_subMapTest", "name": "LazySortedMap_subMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LazySortedMap_subMapTest.java", "superclasses": "", "methods": ["[void]testSubMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LazySortedMap_subMapTest {\n\n    @Test\n    public void testSubMap() {\n        // Given\n        SortedMap<Integer, String> originalMap = new TreeMap<>();\n        originalMap.put(1, \"One\");\n        originalMap.put(2, \"Two\");\n        originalMap.put(3, \"Three\");\n        originalMap.put(4, \"Four\");\n        originalMap.put(5, \"Five\");\n\n        Factory<String> factory = () -> \"Default\";\n        LazySortedMap<Integer, String> lazySortedMap = new LazySortedMap<>(originalMap, factory);\n\n        // When\n        SortedMap<Integer, String> subMap = lazySortedMap.subMap(2, 4);\n\n        // Then\n        assertNotNull(subMap);\n        assertEquals(2, subMap.size());\n        assertEquals(\"Two\", subMap.get(2));\n        assertEquals(\"Three\", subMap.get(3));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap_valuesTest.java.UnmodifiableOrderedMap_valuesTest", "name": "UnmodifiableOrderedMap_valuesTest", "file_path": "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap_valuesTest.java", "superclasses": "", "methods": ["[void]testValues()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnmodifiableOrderedMap_valuesTest {\n\n    @Test\n    public void testValues() {\n        // Given\n        Map<String, String> originalMap = new HashMap<>();\n        originalMap.put(\"key1\", \"value1\");\n        originalMap.put(\"key2\", \"value2\");\n        OrderedMap<String, String> orderedMap = UnmodifiableOrderedMap.unmodifiableOrderedMap(new LinkedMap<>(originalMap));\n\n        // When\n        Collection<String> values = orderedMap.values();\n\n        // Then\n        assertTrue(values instanceof UnmodifiableCollection);\n        assertTrue(values.contains(\"value1\"));\n        assertTrue(values.contains(\"value2\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_lastKeyTest.java.ListOrderedMap_lastKeyTest", "name": "ListOrderedMap_lastKeyTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_lastKeyTest.java", "superclasses": "", "methods": ["[void]testLastKey_EmptyMap()", "[void]testLastKey_NonEmptyMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ListOrderedMap_lastKeyTest {\n\n    @Test\n    void testLastKey_EmptyMap() {\n        ListOrderedMap<String, String> map = new ListOrderedMap<>();\n        assertThrows(NoSuchElementException.class, map::lastKey);\n    }\n\n    @Test\n    void testLastKey_NonEmptyMap() {\n        ListOrderedMap<String, String> map = new ListOrderedMap<>();\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        assertEquals(\"key2\", map.lastKey());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/UnmodifiableMap_keySetTest.java.UnmodifiableMap_keySetTest", "name": "UnmodifiableMap_keySetTest", "file_path": "src/test/java/org/apache/commons/collections4/map/UnmodifiableMap_keySetTest.java", "superclasses": "", "methods": ["[void]testKeySet()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnmodifiableMap_keySetTest {\n\n    @Test\n    public void testKeySet() {\n        // Given\n        Map<String, String> originalMap = new HashMap<>();\n        originalMap.put(\"key1\", \"value1\");\n        originalMap.put(\"key2\", \"value2\");\n        Map<String, String> unmodifiableMap = UnmodifiableMap.unmodifiableMap(originalMap);\n\n        // When\n        Set<String> keySet = unmodifiableMap.keySet();\n\n        // Then\n        assertTrue(keySet instanceof UnmodifiableSet);\n        assertTrue(keySet.contains(\"key1\"));\n        assertTrue(keySet.contains(\"key2\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_removeTest.java.CompositeMap_removeTest", "name": "CompositeMap_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveExistingKey()", "[void]testRemoveNonExistingKey()", "[void]testRemoveFromSecondMap()", "[void]testRemoveAfterAddComposited()", "[void]testRemoveAfterPut()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_removeTest.java.CompositeMap_removeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_removeTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> map1;\n    private Map<String, String> map2;\n\n    @BeforeEach\n    public void setUp() {\n        map1 = new HashMap<>();\n        map1.put(\"1\", \"one\");\n        map1.put(\"2\", \"two\");\n\n        map2 = new HashMap<>();\n        map2.put(\"3\", \"three\");\n        map2.put(\"4\", \"four\");\n\n        compositeMap = new CompositeMap<>(map1, map2, new MapMutator<String, String>() {\n            @Override\n            public void resolveCollision(CompositeMap<String, String> composite, Map<String, String> existing, Map<String, String> added, java.util.Collection<String> intersect) {\n                // No-op\n            }\n\n            @Override\n            public String put(CompositeMap<String, String> map, Map<String, String>[] composited, String key, String value) {\n                return map1.put(key, value);\n            }\n\n            @Override\n            public void putAll(CompositeMap<String, String> map, Map<String, String>[] composited, Map<? extends String, ? extends String> t) {\n                map1.putAll(t);\n            }\n        });\n    }\n\n    @Test\n    public void testRemoveExistingKey() {\n        assertTrue(compositeMap.containsKey(\"1\"));\n        assertEquals(\"one\", compositeMap.remove(\"1\"));\n        assertFalse(compositeMap.containsKey(\"1\"));\n    }\n\n    @Test\n    public void testRemoveNonExistingKey() {\n        assertFalse(compositeMap.containsKey(\"5\"));\n        assertNull(compositeMap.remove(\"5\"));\n    }\n\n    @Test\n    public void testRemoveFromSecondMap() {\n        assertTrue(compositeMap.containsKey(\"3\"));\n        assertEquals(\"three\", compositeMap.remove(\"3\"));\n        assertFalse(compositeMap.containsKey(\"3\"));\n    }\n\n    @Test\n    public void testRemoveAfterAddComposited() {\n        Map<String, String> map3 = new HashMap<>();\n        map3.put(\"5\", \"five\");\n        compositeMap.addComposited(map3);\n\n        assertTrue(compositeMap.containsKey(\"5\"));\n        assertEquals(\"five\", compositeMap.remove(\"5\"));\n        assertFalse(compositeMap.containsKey(\"5\"));\n    }\n\n    @Test\n    public void testRemoveAfterPut() {\n        compositeMap.put(\"6\", \"six\");\n        assertTrue(compositeMap.containsKey(\"6\"));\n        assertEquals(\"six\", compositeMap.remove(\"6\"));\n        assertFalse(compositeMap.containsKey(\"6\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map1", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_putAllTest.java.MultiKeyMap_putAllTest", "name": "MultiKeyMap_putAllTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_putAllTest.java", "superclasses": "", "methods": ["[void]testPutAll_WithValidKeys()", "[void]testPutAll_WithNullKey()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiKeyMap_putAllTest {\n\n    @Test\n    public void testPutAll_WithValidKeys() {\n        // Given\n        MultiKeyMap<String, String> multiKeyMap = new MultiKeyMap<>();\n        Map<MultiKey<? extends String>, String> mapToCopy = new HashMap<>();\n        mapToCopy.put(new MultiKey<>(\"key1\", \"key2\"), \"value1\");\n        mapToCopy.put(new MultiKey<>(\"key3\", \"key4\"), \"value2\");\n\n        // When\n        multiKeyMap.putAll(mapToCopy);\n\n        // Then\n        // Assertions are implicit as the method does not return a value\n    }\n\n    @Test\n    public void testPutAll_WithNullKey() {\n        // Given\n        MultiKeyMap<String, String> multiKeyMap = new MultiKeyMap<>();\n        Map<MultiKey<? extends String>, String> mapToCopy = new HashMap<>();\n        mapToCopy.put(null, \"value1\");\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> multiKeyMap.putAll(mapToCopy));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest", "name": "MultiKeyMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java", "superclasses": "", "methods": ["[void]testClone()", "[void]testLRUMultiKeyMap()", "[void]testMultiKeyContainsKey()", "[void]testMultiKeyGet()", "[void]testMultiKeyPut()", "[void]testMultiKeyPutWithNullKey()", "[void]testMultiKeyRemove()", "[void]testMultiKeyRemoveAll1()", "[void]testMultiKeyRemoveAll2()", "[void]testMultiKeyRemoveAll3()", "[void]testMultiKeyRemoveAll4()", "[void]testNullHandling()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[]MultiKeyMapTest()", "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[MultiKeyMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[MultiKey<K>[]]getMultiKeyKeys()", "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[V[]]getNewSampleValues()", "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[MultiKey<K>[]]getOtherKeys()", "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[MultiKey<K>[]]getSampleKeys()", "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[V[]]getSampleValues()", "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java.MultiKeyMapTest.[MultiKeyMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class MultiKeyMapTest<K, V> extends AbstractIterableMapTest<MultiKey<? extends K>, V> {\n\n    static final Integer I1 = Integer.valueOf(1);\n    static final Integer I2 = Integer.valueOf(2);\n    static final Integer I3 = Integer.valueOf(3);\n    static final Integer I4 = Integer.valueOf(4);\n    static final Integer I5 = Integer.valueOf(5);\n    static final Integer I6 = Integer.valueOf(6);\n    static final Integer I7 = Integer.valueOf(7);\n    static final Integer I8 = Integer.valueOf(8);\n\n    public MultiKeyMapTest() {\n        super(MultiKeyMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MultiKeyMap<K, V> getMap() {\n        return (MultiKeyMap<K, V>) super.getMap();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private MultiKey<K>[] getMultiKeyKeys() {\n        return new MultiKey[] {\n            new MultiKey<>(I1, I2),\n            new MultiKey<>(I2, I3),\n            new MultiKey<>(I3, I4),\n            new MultiKey<>(I1, I1, I2),\n            new MultiKey<>(I2, I3, I4),\n            new MultiKey<>(I3, I7, I6),\n            new MultiKey<>(I1, I1, I2, I3),\n            new MultiKey<>(I2, I4, I5, I6),\n            new MultiKey<>(I3, I6, I7, I8),\n            new MultiKey<>(I1, I1, I2, I3, I4),\n            new MultiKey<>(I2, I3, I4, I5, I6),\n            new MultiKey<>(I3, I5, I6, I7, I8),\n        };\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public V[] getNewSampleValues() {\n        return (V[]) new Object[] {\n            \"1a\", \"1b\", \"1c\",\n            \"2d\", \"2e\", \"2f\",\n            \"3g\", \"3h\", \"3i\",\n            \"4j\", \"4k\", \"4l\",\n        };\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public MultiKey<K>[] getOtherKeys() {\n        return new MultiKey[] {\n            new MultiKey<>(I1, I7),\n            new MultiKey<>(I1, I8),\n            new MultiKey<>(I2, I4),\n            new MultiKey<>(I2, I5),\n        };\n    }\n\n    @Override\n    public MultiKey<K>[] getSampleKeys() {\n        return getMultiKeyKeys();\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public V[] getSampleValues() {\n        return (V[]) new Object[] {\n            \"2A\", \"2B\", \"2C\",\n            \"3D\", \"3E\", \"3F\",\n            \"4G\", \"4H\", \"4I\",\n            \"5J\", \"5K\", \"5L\",\n        };\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public MultiKeyMap<K, V> makeObject() {\n        return new MultiKeyMap<>();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testClone() {\n        final MultiKeyMap<K, V> map = new MultiKeyMap<>();\n        map.put(new MultiKey<>((K) I1, (K) I2), (V) \"1-2\");\n        final Map<MultiKey<? extends K>, V> cloned = map.clone();\n        assertEquals(map.size(), cloned.size());\n        assertSame(map.get(new MultiKey<>((K) I1, (K) I2)), cloned.get(new MultiKey<>((K) I1, (K) I2)));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLRUMultiKeyMap() {\n        final MultiKeyMap<K, V> map = MultiKeyMap.multiKeyMap(new LRUMap<>(2));\n        map.put((K) I1, (K) I2, (V) \"1-2\");\n        map.put((K) I1, (K) I3, (V) \"1-1\");\n        assertEquals(2, map.size());\n        map.put((K) I1, (K) I4, (V) \"1-4\");\n        assertEquals(2, map.size());\n        assertTrue(map.containsKey(I1, I3));\n        assertTrue(map.containsKey(I1, I4));\n        assertFalse(map.containsKey(I1, I2));\n\n        final MultiKeyMap<K, V> cloned = map.clone();\n        assertEquals(2, map.size());\n        assertTrue(cloned.containsKey(I1, I3));\n        assertTrue(cloned.containsKey(I1, I4));\n        assertFalse(cloned.containsKey(I1, I2));\n        cloned.put((K) I1, (K) I5, (V) \"1-5\");\n        assertEquals(2, cloned.size());\n        assertTrue(cloned.containsKey(I1, I4));\n        assertTrue(cloned.containsKey(I1, I5));\n    }\n\n    @Test\n    public void testMultiKeyContainsKey() {\n        resetFull();\n        final MultiKeyMap<K, V> multimap = getMap();\n        final MultiKey<K>[] keys = getMultiKeyKeys();\n\n        for (final MultiKey<K> key : keys) {\n            switch (key.size()) {\n            case 2:\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1)));\n                assertFalse(multimap.containsKey(null, key.getKey(1)));\n                assertFalse(multimap.containsKey(key.getKey(0), null));\n                assertFalse(multimap.containsKey(null, null));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), null));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), null, null));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), null, null, null));\n                break;\n            case 3:\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n                assertFalse(multimap.containsKey(null, key.getKey(1), key.getKey(2)));\n                assertFalse(multimap.containsKey(key.getKey(0), null, key.getKey(2)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), null));\n                assertFalse(multimap.containsKey(null, null, null));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n                break;\n            case 4:\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertFalse(multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertFalse(multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n                assertFalse(multimap.containsKey(null, null, null, null));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n                break;\n            case 5:\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertFalse(multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertFalse(multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n                assertFalse(multimap.containsKey(null, null, null, null, null));\n                break;\n            default:\n                fail(\"Invalid key size\");\n            }\n        }\n    }\n\n    @Test\n    public void testMultiKeyGet() {\n        resetFull();\n        final MultiKeyMap<K, V> multimap = getMap();\n        final MultiKey<K>[] keys = getMultiKeyKeys();\n        final V[] values = getSampleValues();\n\n        for (int i = 0; i < keys.length; i++) {\n            final MultiKey<K> key = keys[i];\n            final V value = values[i];\n\n            switch (key.size()) {\n            case 2:\n                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n                assertNull(multimap.get(null, key.getKey(1)));\n                assertNull(multimap.get(key.getKey(0), null));\n                assertNull(multimap.get(null, null));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), null));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), null, null));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), null, null, null));\n                break;\n            case 3:\n                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n                assertNull(multimap.get(null, key.getKey(1), key.getKey(2)));\n                assertNull(multimap.get(key.getKey(0), null, key.getKey(2)));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), null));\n                assertNull(multimap.get(null, null, null));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n                break;\n            case 4:\n                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertNull(multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertNull(multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n                assertNull(multimap.get(null, null, null, null));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n                break;\n            case 5:\n                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertNull(multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertNull(multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n                assertNull(multimap.get(null, null, null, null, null));\n                break;\n            default:\n                fail(\"Invalid key size\");\n            }\n        }\n    }\n\n    @Test\n    public void testMultiKeyPut() {\n        final MultiKey<K>[] keys = getMultiKeyKeys();\n        final V[] values = getSampleValues();\n\n        for (int i = 0; i < keys.length; i++) {\n            final MultiKeyMap<K, V> multimap = new MultiKeyMap<>();\n\n            final MultiKey<K> key = keys[i];\n            final V value = values[i];\n\n            switch (key.size()) {\n            case 2:\n                assertNull(multimap.put(key.getKey(0), key.getKey(1), value));\n                assertEquals(1, multimap.size());\n                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1)));\n                assertTrue(multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1))));\n                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), null));\n                assertEquals(1, multimap.size());\n                assertNull(multimap.get(key.getKey(0), key.getKey(1)));\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1)));\n                break;\n            case 3:\n                assertNull(multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), value));\n                assertEquals(1, multimap.size());\n                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n                assertTrue(multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1), key.getKey(2))));\n                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), null));\n                assertEquals(1, multimap.size());\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n                break;\n            case 4:\n                assertNull(multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), value));\n                assertEquals(1, multimap.size());\n                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertTrue(multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3))));\n                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n                assertEquals(1, multimap.size());\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                break;\n            case 5:\n                assertNull(multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), value));\n                assertEquals(1, multimap.size());\n                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertTrue(multimap.containsKey(new MultiKey<>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4))));\n                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), null));\n                assertEquals(1, multimap.size());\n                assertNull(multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                break;\n            default:\n                fail(\"Invalid key size\");\n            }\n        }\n    }\n\n    @Test\n    public void testMultiKeyPutWithNullKey() {\n        final MultiKeyMap<String, String> map = new MultiKeyMap<>();\n        map.put(\"a\", null, \"value1\");\n        map.put(\"b\", null, \"value2\");\n        map.put(\"c\", null, \"value3\");\n        map.put(\"a\", \"z\",  \"value4\");\n        map.put(\"a\", null, \"value5\");\n        map.put(null, \"a\", \"value6\");\n        map.put(null, null, \"value7\");\n\n        assertEquals(6, map.size());\n        assertEquals(\"value5\", map.get(\"a\", null));\n        assertEquals(\"value4\", map.get(\"a\", \"z\"));\n        assertEquals(\"value6\", map.get(null, \"a\"));\n    }\n\n    @Test\n    public void testMultiKeyRemove() {\n        final MultiKey<K>[] keys = getMultiKeyKeys();\n        final V[] values = getSampleValues();\n\n        for (int i = 0; i < keys.length; i++) {\n            resetFull();\n            final MultiKeyMap<K, V> multimap = getMap();\n            final int size = multimap.size();\n\n            final MultiKey<K> key = keys[i];\n            final V value = values[i];\n\n            switch (key.size()) {\n            case 2:\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1)));\n                assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1)));\n                assertEquals(size - 1, multimap.size());\n                assertNull(multimap.removeMultiKey(key.getKey(0), key.getKey(1)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1)));\n                break;\n            case 3:\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n                assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n                assertEquals(size - 1, multimap.size());\n                assertNull(multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n                break;\n            case 4:\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertEquals(size - 1, multimap.size());\n                assertNull(multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n                break;\n            case 5:\n                assertTrue(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertEquals(value, multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertEquals(size - 1, multimap.size());\n                assertNull(multimap.removeMultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                assertFalse(multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n                break;\n            default:\n                fail(\"Invalid key size\");\n            }\n        }\n    }\n\n    @Test\n    public void testMultiKeyRemoveAll1() {\n        resetFull();\n        final MultiKeyMap<K, V> multimap = getMap();\n        assertEquals(12, multimap.size());\n\n        multimap.removeAll(I1);\n        assertEquals(8, multimap.size());\n        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n            final MultiKey<? extends K> key = it.next();\n            assertFalse(I1.equals(key.getKey(0)));\n        }\n    }\n\n    @Test\n    public void testMultiKeyRemoveAll2() {\n        resetFull();\n        final MultiKeyMap<K, V> multimap = getMap();\n        assertEquals(12, multimap.size());\n\n        multimap.removeAll(I2, I3);\n        assertEquals(9, multimap.size());\n        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n            final MultiKey<? extends K> key = it.next();\n            assertFalse(I2.equals(key.getKey(0)) && I3.equals(key.getKey(1)));\n        }\n    }\n\n    @Test\n    public void testMultiKeyRemoveAll3() {\n        resetFull();\n        final MultiKeyMap<K, V> multimap = getMap();\n        assertEquals(12, multimap.size());\n\n        multimap.removeAll(I1, I1, I2);\n        assertEquals(9, multimap.size());\n        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n            final MultiKey<? extends K> key = it.next();\n            assertFalse(I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)));\n        }\n    }\n\n    @Test\n    public void testMultiKeyRemoveAll4() {\n        resetFull();\n        final MultiKeyMap<K, V> multimap = getMap();\n        assertEquals(12, multimap.size());\n\n        multimap.removeAll(I1, I1, I2, I3);\n        assertEquals(10, multimap.size());\n        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n            final MultiKey<? extends K> key = it.next();\n            assertFalse(I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)) && key.size() >= 4 && I3.equals(key.getKey(3)));\n        }\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/MultiKeyMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/MultiKeyMap.fullCollection.version4.obj\");\n//    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testNullHandling() {\n        resetFull();\n        assertNull(map.get(null));\n        assertFalse(map.containsKey(null));\n        assertFalse(map.containsValue(null));\n        assertNull(map.remove(null));\n        assertFalse(map.entrySet().contains(null));\n        assertFalse(map.containsKey(null));\n        assertFalse(map.containsValue(null));\n\n        assertThrows(NullPointerException.class, () -> map.put(null, null));\n\n        assertNull(map.put(new MultiKey<>(null, null), null));\n\n        assertThrows(NullPointerException.class, () -> map.put(null, (V) new Object()));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final Integer I1 = Integer.valueOf(1);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Integer", "name": "I1 = Integer.valueOf(1)", "syntax_pass": true}, {"attribute_expression": "static final Integer I2 = Integer.valueOf(2);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Integer", "name": "I2 = Integer.valueOf(2)", "syntax_pass": true}, {"attribute_expression": "static final Integer I3 = Integer.valueOf(3);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Integer", "name": "I3 = Integer.valueOf(3)", "syntax_pass": true}, {"attribute_expression": "static final Integer I4 = Integer.valueOf(4);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Integer", "name": "I4 = Integer.valueOf(4)", "syntax_pass": true}, {"attribute_expression": "static final Integer I5 = Integer.valueOf(5);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Integer", "name": "I5 = Integer.valueOf(5)", "syntax_pass": true}, {"attribute_expression": "static final Integer I6 = Integer.valueOf(6);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Integer", "name": "I6 = Integer.valueOf(6)", "syntax_pass": true}, {"attribute_expression": "static final Integer I7 = Integer.valueOf(7);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Integer", "name": "I7 = Integer.valueOf(7)", "syntax_pass": true}, {"attribute_expression": "static final Integer I8 = Integer.valueOf(8);", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Integer", "name": "I8 = Integer.valueOf(8)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/SingletonMap_hashCodeTest.java.SingletonMap_hashCodeTest", "name": "SingletonMap_hashCodeTest", "file_path": "src/test/java/org/apache/commons/collections4/map/SingletonMap_hashCodeTest.java", "superclasses": "", "methods": ["[void]testHashCodeWithNonNullKeyAndValue()", "[void]testHashCodeWithNullKey()", "[void]testHashCodeWithNullValue()", "[void]testHashCodeWithNullKeyAndValue()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/SingletonMap_hashCodeTest.java.SingletonMap_hashCodeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonMap_hashCodeTest {\n    private SingletonMap<String, String> singletonMap;\n\n    @BeforeEach\n    public void setUp() {\n        singletonMap = new SingletonMap<>(\"key\", \"value\");\n    }\n\n    @Test\n    public void testHashCodeWithNonNullKeyAndValue() {\n        assertEquals(\"key\".hashCode() ^ \"value\".hashCode(), singletonMap.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNullKey() {\n        singletonMap = new SingletonMap<>(null, \"value\");\n        assertEquals(0 ^ \"value\".hashCode(), singletonMap.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNullValue() {\n        singletonMap = new SingletonMap<>(\"key\", null);\n        assertEquals(\"key\".hashCode() ^ 0, singletonMap.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNullKeyAndValue() {\n        singletonMap = new SingletonMap<>(null, null);\n        assertEquals(0 ^ 0, singletonMap.hashCode());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private SingletonMap<String, String> singletonMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SingletonMap<String, String>", "name": "singletonMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_containsValueTest.java.MultiValueMap_containsValueTest", "name": "MultiValueMap_containsValueTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_containsValueTest.java", "superclasses": "", "methods": ["[void]testContainsValue_ValuePresent()", "[void]testContainsValue_ValueNotPresent()", "[void]testContainsValue_EmptyMap()", "[void]testContainsValue_AfterRemove()", "[void]testContainsValue_AfterClear()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiValueMap_containsValueTest.java.MultiValueMap_containsValueTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiValueMap_containsValueTest {\n\n    private MultiValueMap<String, String> multiValueMap;\n\n    @BeforeEach\n    public void setUp() {\n        multiValueMap = new MultiValueMap<>();\n    }\n\n    @Test\n    public void testContainsValue_ValuePresent() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key1\", \"value2\");\n        multiValueMap.put(\"key2\", \"value3\");\n\n        assertTrue(multiValueMap.containsValue(\"value1\"));\n        assertTrue(multiValueMap.containsValue(\"value2\"));\n        assertTrue(multiValueMap.containsValue(\"value3\"));\n    }\n\n    @Test\n    public void testContainsValue_ValueNotPresent() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key1\", \"value2\");\n        multiValueMap.put(\"key2\", \"value3\");\n\n        assertFalse(multiValueMap.containsValue(\"value4\"));\n        assertFalse(multiValueMap.containsValue(\"value5\"));\n    }\n\n    @Test\n    public void testContainsValue_EmptyMap() {\n        assertFalse(multiValueMap.containsValue(\"value1\"));\n    }\n\n    @Test\n    public void testContainsValue_AfterRemove() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key1\", \"value2\");\n        multiValueMap.put(\"key2\", \"value3\");\n\n        multiValueMap.removeMapping(\"key1\", \"value1\");\n        assertFalse(multiValueMap.containsValue(\"value1\"));\n        assertTrue(multiValueMap.containsValue(\"value2\"));\n        assertTrue(multiValueMap.containsValue(\"value3\"));\n    }\n\n    @Test\n    public void testContainsValue_AfterClear() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key1\", \"value2\");\n        multiValueMap.put(\"key2\", \"value3\");\n\n        multiValueMap.clear();\n        assertFalse(multiValueMap.containsValue(\"value1\"));\n        assertFalse(multiValueMap.containsValue(\"value2\"));\n        assertFalse(multiValueMap.containsValue(\"value3\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private MultiValueMap<String, String> multiValueMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MultiValueMap<String, String>", "name": "multiValueMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_containsKeyTest.java.PassiveExpiringMap_containsKeyTest", "name": "PassiveExpiringMap_containsKeyTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_containsKeyTest.java", "superclasses": "", "methods": ["[void]testContainsKey_KeyExistsAndNotExpired()", "[void]testContainsKey_KeyExistsButExpired()", "[void]testContainsKey_KeyDoesNotExist()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_containsKeyTest.java.PassiveExpiringMap_containsKeyTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PassiveExpiringMap_containsKeyTest {\n\n    private PassiveExpiringMap<String, String> map;\n\n    @BeforeEach\n    void setUp() {\n        map = new PassiveExpiringMap<>(new PassiveExpiringMap.ConstantTimeToLiveExpirationPolicy<>(1000L), new HashMap<>());\n    }\n\n    @Test\n    void testContainsKey_KeyExistsAndNotExpired() {\n        map.put(\"key1\", \"value1\");\n        assertTrue(map.containsKey(\"key1\"));\n    }\n\n    @Test\n    void testContainsKey_KeyExistsButExpired() throws InterruptedException {\n        map.put(\"key2\", \"value2\");\n        Thread.sleep(1001); // Wait for the entry to expire\n        assertFalse(map.containsKey(\"key2\"));\n    }\n\n    @Test\n    void testContainsKey_KeyDoesNotExist() {\n        assertFalse(map.containsKey(\"key3\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private PassiveExpiringMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PassiveExpiringMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_removeMappingTest.java.MultiValueMap_removeMappingTest", "name": "MultiValueMap_removeMappingTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_removeMappingTest.java", "superclasses": "", "methods": ["[void]testRemoveMappingSuccess()", "[void]testRemoveMappingNonExistentValue()", "[void]testRemoveMappingNonExistentKey()", "[void]testRemoveMappingLastValue()", "[void]testRemoveMappingAndClear()", "[void]testRemoveMappingAndIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiValueMap_removeMappingTest.java.MultiValueMap_removeMappingTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiValueMap_removeMappingTest {\n\n    private MultiValueMap<String, String> multiValueMap;\n\n    @BeforeEach\n    public void setUp() {\n        multiValueMap = new MultiValueMap<>();\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key1\", \"value2\");\n        multiValueMap.put(\"key2\", \"value3\");\n    }\n\n    @Test\n    public void testRemoveMappingSuccess() {\n        assertTrue(multiValueMap.removeMapping(\"key1\", \"value1\"));\n        assertFalse(multiValueMap.containsValue(\"key1\", \"value1\"));\n        assertEquals(2, multiValueMap.totalSize());\n    }\n\n    @Test\n    public void testRemoveMappingNonExistentValue() {\n        assertFalse(multiValueMap.removeMapping(\"key1\", \"nonExistentValue\"));\n        assertEquals(3, multiValueMap.totalSize());\n    }\n\n    @Test\n    public void testRemoveMappingNonExistentKey() {\n        assertFalse(multiValueMap.removeMapping(\"nonExistentKey\", \"value1\"));\n        assertEquals(3, multiValueMap.totalSize());\n    }\n\n    @Test\n    public void testRemoveMappingLastValue() {\n        assertTrue(multiValueMap.removeMapping(\"key2\", \"value3\"));\n        assertFalse(multiValueMap.containsKey(\"key2\"));\n        assertEquals(2, multiValueMap.totalSize());\n    }\n\n    @Test\n    public void testRemoveMappingAndClear() {\n        multiValueMap.clear();\n        assertFalse(multiValueMap.removeMapping(\"key1\", \"value1\"));\n        assertEquals(0, multiValueMap.totalSize());\n    }\n\n    @Test\n    public void testRemoveMappingAndIterator() {\n        Iterator<String> iterator = multiValueMap.iterator(\"key1\");\n        while (iterator.hasNext()) {\n            String value = iterator.next();\n            if (\"value1\".equals(value)) {\n                iterator.remove();\n            }\n        }\n        assertFalse(multiValueMap.containsValue(\"key1\", \"value1\"));\n        assertEquals(2, multiValueMap.totalSize());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private MultiValueMap<String, String> multiValueMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MultiValueMap<String, String>", "name": "multiValueMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/SingletonMap_equalsTest.java.SingletonMap_equalsTest", "name": "SingletonMap_equalsTest", "file_path": "src/test/java/org/apache/commons/collections4/map/SingletonMap_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameInstance()", "[void]testEquals_DifferentType()", "[void]testEquals_DifferentSizeMap()", "[void]testEquals_SameKeyDifferentValue()", "[void]testEquals_DifferentKeySameValue()", "[void]testEquals_SameKeySameValue()", "[void]testEquals_NullKey()", "[void]testEquals_NullValue()", "[void]testEquals_NullKeyAndValue()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/SingletonMap_equalsTest.java.SingletonMap_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonMap_equalsTest {\n\n    private SingletonMap<String, String> singletonMap;\n\n    @BeforeEach\n    public void setUp() {\n        singletonMap = new SingletonMap<>(\"key\", \"value\");\n    }\n\n    @Test\n    public void testEquals_SameInstance() {\n        assertTrue(singletonMap.equals(singletonMap));\n    }\n\n    @Test\n    public void testEquals_DifferentType() {\n        assertFalse(singletonMap.equals(\"not a map\"));\n    }\n\n    @Test\n    public void testEquals_DifferentSizeMap() {\n        Map<String, String> differentSizeMap = new HashMap<>();\n        differentSizeMap.put(\"key1\", \"value1\");\n        differentSizeMap.put(\"key2\", \"value2\");\n        assertFalse(singletonMap.equals(differentSizeMap));\n    }\n\n    @Test\n    public void testEquals_SameKeyDifferentValue() {\n        Map<String, String> sameKeyDifferentValueMap = new HashMap<>();\n        sameKeyDifferentValueMap.put(\"key\", \"differentValue\");\n        assertFalse(singletonMap.equals(sameKeyDifferentValueMap));\n    }\n\n    @Test\n    public void testEquals_DifferentKeySameValue() {\n        Map<String, String> differentKeySameValueMap = new HashMap<>();\n        differentKeySameValueMap.put(\"differentKey\", \"value\");\n        assertFalse(singletonMap.equals(differentKeySameValueMap));\n    }\n\n    @Test\n    public void testEquals_SameKeySameValue() {\n        Map<String, String> sameKeySameValueMap = new HashMap<>();\n        sameKeySameValueMap.put(\"key\", \"value\");\n        assertTrue(singletonMap.equals(sameKeySameValueMap));\n    }\n\n    @Test\n    public void testEquals_NullKey() {\n        SingletonMap<String, String> nullKeyMap = new SingletonMap<>(null, \"value\");\n        Map<String, String> nullKeyHashMap = new HashMap<>();\n        nullKeyHashMap.put(null, \"value\");\n        assertTrue(nullKeyMap.equals(nullKeyHashMap));\n    }\n\n    @Test\n    public void testEquals_NullValue() {\n        SingletonMap<String, String> nullValueMap = new SingletonMap<>(\"key\", null);\n        Map<String, String> nullValueHashMap = new HashMap<>();\n        nullValueHashMap.put(\"key\", null);\n        assertTrue(nullValueMap.equals(nullValueHashMap));\n    }\n\n    @Test\n    public void testEquals_NullKeyAndValue() {\n        SingletonMap<String, String> nullKeyAndValueMap = new SingletonMap<>(null, null);\n        Map<String, String> nullKeyAndValueHashMap = new HashMap<>();\n        nullKeyAndValueHashMap.put(null, null);\n        assertTrue(nullKeyAndValueMap.equals(nullKeyAndValueHashMap));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private SingletonMap<String, String> singletonMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SingletonMap<String, String>", "name": "singletonMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java.UnmodifiableSortedMapTest", "name": "UnmodifiableSortedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testHeadMap()", "[void]testSubMap()", "[void]testTailMap()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java.UnmodifiableSortedMapTest.[]UnmodifiableSortedMapTest()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java.UnmodifiableSortedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java.UnmodifiableSortedMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java.UnmodifiableSortedMapTest.[boolean]isPutChangeSupported()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java.UnmodifiableSortedMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java.UnmodifiableSortedMapTest.[SortedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java.UnmodifiableSortedMapTest.[SortedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSortedMapTest} for exercising the\n{@link UnmodifiableSortedMap} implementation.\n", "original_string": "public class UnmodifiableSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n\n    public UnmodifiableSortedMapTest() {\n        super(UnmodifiableSortedMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isPutChangeSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public SortedMap<K, V> makeFullMap() {\n        final SortedMap<K, V> m = new TreeMap<>();\n        addSampleMappings(m);\n        return UnmodifiableSortedMap.unmodifiableSortedMap(m);\n    }\n\n    @Override\n    public SortedMap<K, V> makeObject() {\n        return UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final SortedMap<K, V> map = makeFullMap();\n        assertSame(map, UnmodifiableSortedMap.unmodifiableSortedMap(map));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableSortedMap.unmodifiableSortedMap(null));\n    }\n\n    @Test\n    public void testHeadMap() {\n        final SortedMap<K, V> map = makeFullMap();\n        final SortedMap<K, V> m = new TreeMap<>();\n        // \"again\" is the first key of the map\n        assertSame(m.isEmpty(), map.headMap((K) \"again\").isEmpty());\n        assertSame(18, map.size());\n        // \"you\" is the last key of the map\n        assertSame(17, map.headMap((K) \"you\").size());\n        // \"we'll\" is the before key of \"you\"\n        assertSame(16, map.headMap((K) \"we'll\").size());\n    }\n\n    @Test\n    public void testSubMap() {\n        final SortedMap<K, V> map = makeFullMap();\n\n        assertSame(18, map.size());\n        // get the sub map from again to you(exclusive)\n        assertSame(17, map.subMap((K) \"again\", (K) \"you\").size());\n        // get the sub map from again to we'll(exclusive)\n        assertSame(16, map.subMap((K) \"again\", (K) \"we'll\").size());\n        // \"again\" is the first key of the map\n        assertSame(0, map.subMap((K) \"again\", (K) \"again\").size());\n\n        assertSame(map.headMap((K) \"you\").size(), map.subMap((K) \"again\", (K) \"you\").size());\n    }\n\n    @Test\n    public void testTailMap() {\n        final SortedMap<K, V> map = makeFullMap();\n\n        assertSame(18, map.size());\n        // \"you\" is the last key of the map\n        assertSame(1, map.tailMap((K) \"you\").size());\n        // \"we'll\" is the before key of \"you\"\n        assertSame(2, map.tailMap((K) \"we'll\").size());\n        // \"again\" is the first key of the map\n        assertSame(18, map.tailMap((K) \"again\").size());\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullMap() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/UnmodifiableSortedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/UnmodifiableSortedMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_entrySetTest.java.CompositeMap_entrySetTest", "name": "CompositeMap_entrySetTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_entrySetTest.java", "superclasses": "", "methods": ["[void]testEntrySet()", "[void]testEntrySetAfterAddComposited()", "[void]testEntrySetAfterRemoveComposited()", "[void]testEntrySetAfterClear()", "[void]testEntrySetAfterPut()", "[void]testEntrySetAfterRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_entrySetTest.java.CompositeMap_entrySetTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_entrySetTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> map1;\n    private Map<String, String> map2;\n\n    @BeforeEach\n    public void setUp() {\n        map1 = new HashMap<>();\n        map1.put(\"1\", \"one\");\n        map1.put(\"2\", \"two\");\n\n        map2 = new HashMap<>();\n        map2.put(\"3\", \"three\");\n        map2.put(\"4\", \"four\");\n\n        compositeMap = new CompositeMap<>(map1, map2);\n    }\n\n    @Test\n    public void testEntrySet() {\n        Set<Map.Entry<String, String>> entrySet = compositeMap.entrySet();\n        assertEquals(4, entrySet.size());\n        assertTrue(entrySet.containsAll(map1.entrySet()));\n        assertTrue(entrySet.containsAll(map2.entrySet()));\n    }\n\n    @Test\n    public void testEntrySetAfterAddComposited() {\n        Map<String, String> map3 = new HashMap<>();\n        map3.put(\"5\", \"five\");\n        compositeMap.addComposited(map3);\n\n        Set<Map.Entry<String, String>> entrySet = compositeMap.entrySet();\n        assertEquals(5, entrySet.size());\n        assertTrue(entrySet.containsAll(map1.entrySet()));\n        assertTrue(entrySet.containsAll(map2.entrySet()));\n        assertTrue(entrySet.containsAll(map3.entrySet()));\n    }\n\n    @Test\n    public void testEntrySetAfterRemoveComposited() {\n        compositeMap.removeComposited(map2);\n\n        Set<Map.Entry<String, String>> entrySet = compositeMap.entrySet();\n        assertEquals(2, entrySet.size());\n        assertTrue(entrySet.containsAll(map1.entrySet()));\n        assertFalse(entrySet.containsAll(map2.entrySet()));\n    }\n\n    @Test\n    public void testEntrySetAfterClear() {\n        compositeMap.clear();\n\n        Set<Map.Entry<String, String>> entrySet = compositeMap.entrySet();\n        assertEquals(0, entrySet.size());\n    }\n\n    @Test\n    public void testEntrySetAfterPut() {\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"6\", \"six\");\n        compositeMap.addComposited(newMap);\n\n        Set<Map.Entry<String, String>> entrySet = compositeMap.entrySet();\n        assertEquals(5, entrySet.size());\n        assertTrue(entrySet.contains(new AbstractMap.SimpleEntry<>(\"6\", \"six\")));\n    }\n\n    @Test\n    public void testEntrySetAfterRemove() {\n        compositeMap.remove(\"3\");\n\n        Set<Map.Entry<String, String>> entrySet = compositeMap.entrySet();\n        assertEquals(3, entrySet.size());\n        assertFalse(entrySet.contains(new AbstractMap.SimpleEntry<>(\"3\", \"three\")));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map1", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_containsValueTest.java.PassiveExpiringMap_containsValueTest", "name": "PassiveExpiringMap_containsValueTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_containsValueTest.java", "superclasses": "", "methods": ["[void]testContainsValue_ValuePresent()", "[void]testContainsValue_ValueNotPresent()", "[void]testContainsValue_ExpiredValue()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PassiveExpiringMap_containsValueTest {\n\n    @Test\n    public void testContainsValue_ValuePresent() {\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(new ConstantTimeToLiveExpirationPolicy<>(-1L), new HashMap<>());\n        map.put(\"key1\", \"value1\");\n        assertTrue(map.containsValue(\"value1\"));\n    }\n\n    @Test\n    public void testContainsValue_ValueNotPresent() {\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(new ConstantTimeToLiveExpirationPolicy<>(-1L), new HashMap<>());\n        map.put(\"key1\", \"value1\");\n        assertFalse(map.containsValue(\"value2\"));\n    }\n\n    @Test\n    public void testContainsValue_ExpiredValue() {\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(new ConstantTimeToLiveExpirationPolicy<>(0L), new HashMap<>());\n        map.put(\"key1\", \"value1\");\n        assertFalse(map.containsValue(\"value1\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_cloneTest.java.MultiKeyMap_cloneTest", "name": "MultiKeyMap_cloneTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_cloneTest.java", "superclasses": "", "methods": ["[void]testClone()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MultiKeyMap_cloneTest {\n\n    @Test\n    void testClone() {\n        MultiKeyMap<String, String> originalMap = new MultiKeyMap<>();\n        originalMap.put(\"key1\", \"key2\", \"value1\");\n\n        MultiKeyMap<String, String> clonedMap = originalMap.clone();\n\n        assertEquals(originalMap.get(\"key1\", \"key2\"), clonedMap.get(\"key1\", \"key2\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMapTest.java.StaticBucketMapTest", "name": "StaticBucketMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMapTest.java", "superclasses": "", "methods": ["[void]test_containsKey_nullMatchesIncorrectly()", "[void]test_containsValue_nullMatchesIncorrectly()", "[void]test_get_nullMatchesIncorrectly()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/StaticBucketMapTest.java.StaticBucketMapTest.[]StaticBucketMapTest()", "src/test/java/org/apache/commons/collections4/map/StaticBucketMapTest.java.StaticBucketMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/map/StaticBucketMapTest.java.StaticBucketMapTest.[boolean]isFailFastExpected()", "src/test/java/org/apache/commons/collections4/map/StaticBucketMapTest.java.StaticBucketMapTest.[StaticBucketMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nUnit tests.\n{@link StaticBucketMap}.\n", "original_string": "public class StaticBucketMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    public StaticBucketMapTest() {\n        super(StaticBucketMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String[] ignoredTests() {\n        final String pre = \"StaticBucketMapTest.bulkTestMap\";\n        final String post = \".testCollectionIteratorFailFast\";\n        return new String[] {\n            pre + \"EntrySet\" + post,\n            pre + \"KeySet\" + post,\n            pre + \"Values\" + post\n        };\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isFailFastExpected() {\n        return false;\n    }\n\n    @Override\n    public StaticBucketMap<K, V> makeObject() {\n        return new StaticBucketMap<>(30);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void test_containsKey_nullMatchesIncorrectly() {\n        final StaticBucketMap<K, V> map = new StaticBucketMap<>(17);\n        map.put(null, (V) \"A\");\n        assertTrue(map.containsKey(null));\n        // loop so we find a string that is in the same bucket as the null\n        for (int i = 'A'; i <= 'Z'; i++) {\n            final String str = String.valueOf((char) i);\n            assertFalse(map.containsKey(str), \"String: \" + str);\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void test_containsValue_nullMatchesIncorrectly() {\n        final StaticBucketMap<K, V> map = new StaticBucketMap<>(17);\n        map.put((K) \"A\", null);\n        assertTrue(map.containsValue(null));\n        // loop so we find a string that is in the same bucket as the null\n        for (int i = 'A'; i <= 'Z'; i++) {\n            final String str = String.valueOf((char) i);\n            assertFalse(map.containsValue(str), \"String: \" + str);\n        }\n    }\n\n    // Bugzilla 37567\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void test_get_nullMatchesIncorrectly() {\n        final StaticBucketMap<K, V> map = new StaticBucketMap<>(17);\n        map.put(null, (V) \"A\");\n        assertEquals(\"A\", map.get(null));\n        // loop so we find a string that is in the same bucket as the null\n        for (int i = 'A'; i <= 'Z'; i++) {\n            final String str = String.valueOf((char) i);\n            assertNull(map.get(str), \"String: \" + str);\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/TransformedMap_putTest.java.TransformedMap_putTest", "name": "TransformedMap_putTest", "file_path": "src/test/java/org/apache/commons/collections4/map/TransformedMap_putTest.java", "superclasses": "", "methods": ["[void]testPutWithTransformers()", "[void]testPutWithoutTransformers()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedMap_putTest {\n\n    @Test\n    public void testPutWithTransformers() {\n        // Given\n        Transformer<String, String> keyTransformer = mock(Transformer.class);\n        Transformer<String, String> valueTransformer = mock(Transformer.class);\n        Map<String, String> originalMap = new HashMap<>();\n        TransformedMap<String, String> transformedMap = new TransformedMap<>(originalMap, keyTransformer, valueTransformer);\n\n        String originalKey = \"key\";\n        String originalValue = \"value\";\n        String transformedKey = \"transformedKey\";\n        String transformedValue = \"transformedValue\";\n\n        when(keyTransformer.apply(originalKey)).thenReturn(transformedKey);\n        when(valueTransformer.apply(originalValue)).thenReturn(transformedValue);\n\n        // When\n        transformedMap.put(originalKey, originalValue);\n\n        // Then\n        assertEquals(transformedValue, originalMap.get(transformedKey));\n        verify(keyTransformer).apply(originalKey);\n        verify(valueTransformer).apply(originalValue);\n    }\n\n    @Test\n    public void testPutWithoutTransformers() {\n        // Given\n        Map<String, String> originalMap = new HashMap<>();\n        TransformedMap<String, String> transformedMap = new TransformedMap<>(originalMap, null, null);\n\n        String originalKey = \"key\";\n        String originalValue = \"value\";\n\n        // When\n        transformedMap.put(originalKey, originalValue);\n\n        // Then\n        assertEquals(originalValue, originalMap.get(originalKey));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/SingletonMap_setValueTest.java.SingletonMap_setValueTest", "name": "SingletonMap_setValueTest", "file_path": "src/test/java/org/apache/commons/collections4/map/SingletonMap_setValueTest.java", "superclasses": "", "methods": ["[void]testSetValue()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonMap_setValueTest {\n\n    @Test\n    public void testSetValue() {\n        SingletonMap<String, String> map = new SingletonMap<>(\"key\", \"oldValue\");\n        String oldValue = map.setValue(\"newValue\");\n        assertEquals(\"oldValue\", oldValue);\n        assertEquals(\"newValue\", map.getValue());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_toStringTest.java.ListOrderedMap_toStringTest", "name": "ListOrderedMap_toStringTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringEmptyMap()", "[void]testToStringNonEmptyMap()", "[void]testToStringWithSelfReference()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ListOrderedMap_toStringTest {\n\n    @Test\n    public void testToStringEmptyMap() {\n        ListOrderedMap<String, String> map = new ListOrderedMap<>(new HashMap<>());\n        assertEquals(\"{}\", map.toString());\n    }\n\n    @Test\n    public void testToStringNonEmptyMap() {\n        ListOrderedMap<String, String> map = new ListOrderedMap<>(new HashMap<>());\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        assertEquals(\"{key1=value1, key2=value2}\", map.toString());\n    }\n\n    @Test\n    public void testToStringWithSelfReference() {\n        ListOrderedMap<String, Object> map = new ListOrderedMap<>(new HashMap<>());\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", map);\n        assertEquals(\"{key1=value1, key2=(this Map)}\", map.toString());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/LRUMapTest.java.LRUMapTest", "name": "LRUMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LRUMapTest.java", "superclasses": "", "methods": ["[void]testAccessOrder()", "[void]testAccessOrder2()", "[void]testClone()", "[void]testCtors()", "[void]testInternalState_Buckets()", "[void]testInternalState_getEntry_int()", "[void]testLRU()", "[void]testRemoveLRU()", "[void]testRemoveLRUBlocksRemove()", "[void]testRemoveLRUBlocksRemoveScan()", "[void]testRemoveLRUFirstBlocksRemove()", "[void]testReset()", "[void]testSynchronizedRemoveFromEntrySet()", "[void]testSynchronizedRemoveFromKeySet()", "[void]testSynchronizedRemoveFromMapIterator()", "[void]testSynchronizedRemoveFromValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/LRUMapTest.java.LRUMapTest.[]LRUMapTest()", "src/test/java/org/apache/commons/collections4/map/LRUMapTest.java.LRUMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/LRUMapTest.java.LRUMapTest.[LRUMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/map/LRUMapTest.java.LRUMapTest.[boolean]isGetStructuralModify()", "src/test/java/org/apache/commons/collections4/map/LRUMapTest.java.LRUMapTest.[LRUMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/LRUMapTest.java.LRUMapTest.[LRUMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    static class MockLRUMapSubclass<K, V> extends LRUMap<K, V> {\n\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = -2126883654452042477L;\n        LinkEntry<K, V> entry;\n        K key;\n        V value;\n\n        MockLRUMapSubclass(final int size) {\n            super(size);\n        }\n\n        @Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n            this.entry = entry;\n            this.key = entry.getKey();\n            this.value = entry.getValue();\n            return true;\n        }\n\n    }", "definition": "    static class MockLRUMapSubclass<K, V> extends LRUMap<K, V>", "class_docstring": "", "name": "MockLRUMapSubclass", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2126883654452042477L;", "docstring": "\nGenerated serial version ID.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2126883654452042477L", "syntax_pass": true}, {"attribute_expression": "LinkEntry<K, V> entry;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "LinkEntry<K, V>", "name": "entry", "syntax_pass": true}, {"attribute_expression": "K key;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "K", "name": "key", "syntax_pass": true}, {"attribute_expression": "V value;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "V", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MockLRUMapSubclass(final int size) {\n            super(size);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MockLRUMapSubclass", "params": [{"name": "size", "type": "int"}], "body": "                                           {\n            super(size);\n        }", "signature": "MockLRUMapSubclass(final int size)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n            this.entry = entry;\n            this.key = entry.getKey();\n            this.value = entry.getValue();\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "removeLRU", "params": [{"name": "entry", "type": "LinkEntry<K, V>"}], "body": "                                                                 {\n            this.entry = entry;\n            this.key = entry.getKey();\n            this.value = entry.getValue();\n            return true;\n        }", "signature": "@Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry)"}]}, {"original_string": "    static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V> {\n\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = 6278917461128992945L;\n\n        MockLRUMapSubclassBlocksRemove(final int size, final boolean scanUntilRemove) {\n            super(size, scanUntilRemove);\n        }\n\n        @Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n            return false;\n        }\n\n    }", "definition": "    static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V>", "class_docstring": "", "name": "MockLRUMapSubclassBlocksRemove", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 6278917461128992945L;", "docstring": "\nGenerated serial version ID.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 6278917461128992945L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MockLRUMapSubclassBlocksRemove(final int size, final boolean scanUntilRemove) {\n            super(size, scanUntilRemove);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MockLRUMapSubclassBlocksRemove", "params": [{"name": "size", "type": "int"}, {"name": "scanUntilRemove", "type": "boolean"}], "body": "                                                                                      {\n            super(size, scanUntilRemove);\n        }", "signature": "MockLRUMapSubclassBlocksRemove(final int size, final boolean scanUntilRemove)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "removeLRU", "params": [{"name": "entry", "type": "LinkEntry<K, V>"}], "body": "                                                                 {\n            return false;\n        }", "signature": "@Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry)"}]}, {"original_string": "    static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V> {\n\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = -6939790801702973428L;\n\n        MockLRUMapSubclassFirstBlocksRemove(final int size) {\n            super(size, true);\n        }\n\n        @Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n            if (\"a\".equals(entry.getValue())) {\n                return false;\n            }\n            return true;\n        }\n\n    }", "definition": "    static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V>", "class_docstring": "", "name": "MockLRUMapSubclassFirstBlocksRemove", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -6939790801702973428L;", "docstring": "\nGenerated serial version ID.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -6939790801702973428L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MockLRUMapSubclassFirstBlocksRemove(final int size) {\n            super(size, true);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MockLRUMapSubclassFirstBlocksRemove", "params": [{"name": "size", "type": "int"}], "body": "                                                            {\n            super(size, true);\n        }", "signature": "MockLRUMapSubclassFirstBlocksRemove(final int size)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n            if (\"a\".equals(entry.getValue())) {\n                return false;\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "removeLRU", "params": [{"name": "entry", "type": "LinkEntry<K, V>"}], "body": "                                                                 {\n            if (\"a\".equals(entry.getValue())) {\n                return false;\n            }\n            return true;\n        }", "signature": "@Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry)"}]}, {"original_string": "    static class SingleHashCode {\n\n        private final String code;\n\n        SingleHashCode(final String code) {\n            this.code = code;\n        }\n\n        @Override\n        public int hashCode() {\n            // always return the same hash code\n            // that way, it will end up in the same bucket\n            return 12;\n        }\n\n        @Override\n        public String toString() {\n            return \"SingleHashCode:\" + code;\n        }\n\n    }", "definition": "    static class SingleHashCode", "class_docstring": "", "name": "SingleHashCode", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final String code;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "code", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SingleHashCode(final String code) {\n            this.code = code;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SingleHashCode", "params": [{"name": "code", "type": "String"}], "body": "                                          {\n            this.code = code;\n        }", "signature": "SingleHashCode(final String code)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            // always return the same hash code\n            // that way, it will end up in the same bucket\n            return 12;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            // always return the same hash code\n            // that way, it will end up in the same bucket\n            return 12;\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \"SingleHashCode:\" + code;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \"SingleHashCode:\" + code;\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nJUnit tests.\n", "original_string": "public class LRUMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n\n    static class MockLRUMapSubclass<K, V> extends LRUMap<K, V> {\n\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = -2126883654452042477L;\n        LinkEntry<K, V> entry;\n        K key;\n        V value;\n\n        MockLRUMapSubclass(final int size) {\n            super(size);\n        }\n\n        @Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n            this.entry = entry;\n            this.key = entry.getKey();\n            this.value = entry.getValue();\n            return true;\n        }\n\n    }\n    static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V> {\n\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = 6278917461128992945L;\n\n        MockLRUMapSubclassBlocksRemove(final int size, final boolean scanUntilRemove) {\n            super(size, scanUntilRemove);\n        }\n\n        @Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n            return false;\n        }\n\n    }\n\n    static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V> {\n\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = -6939790801702973428L;\n\n        MockLRUMapSubclassFirstBlocksRemove(final int size) {\n            super(size, true);\n        }\n\n        @Override\n        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n            if (\"a\".equals(entry.getValue())) {\n                return false;\n            }\n            return true;\n        }\n\n    }\n\n    static class SingleHashCode {\n\n        private final String code;\n\n        SingleHashCode(final String code) {\n            this.code = code;\n        }\n\n        @Override\n        public int hashCode() {\n            // always return the same hash code\n            // that way, it will end up in the same bucket\n            return 12;\n        }\n\n        @Override\n        public String toString() {\n            return \"SingleHashCode:\" + code;\n        }\n\n    }\n\n    public LRUMapTest() {\n        super(LRUMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public LRUMap<K, V> getMap() {\n        return (LRUMap<K, V>) super.getMap();\n    }\n\n    @Override\n    public boolean isGetStructuralModify() {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public LRUMap<K, V> makeFullMap() {\n        return (LRUMap<K, V>) super.makeFullMap();\n    }\n\n    @Override\n    public LRUMap<K, V> makeObject() {\n        return new LRUMap<>();\n    }\n\n    @Test\n    public void testAccessOrder() {\n        if (!isPutAddSupported() || !isPutChangeSupported()) {\n            return;\n        }\n        final K[] keys = getSampleKeys();\n        final V[] values = getSampleValues();\n        Iterator<K> kit;\n        Iterator<V> vit;\n\n        resetEmpty();\n        map.put(keys[0], values[0]);\n        map.put(keys[1], values[1]);\n        kit = map.keySet().iterator();\n        assertSame(keys[0], kit.next());\n        assertSame(keys[1], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[0], vit.next());\n        assertSame(values[1], vit.next());\n\n        // no change to order\n        map.put(keys[1], values[1]);\n        kit = map.keySet().iterator();\n        assertSame(keys[0], kit.next());\n        assertSame(keys[1], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[0], vit.next());\n        assertSame(values[1], vit.next());\n\n        // no change to order\n        map.put(keys[1], values[2]);\n        kit = map.keySet().iterator();\n        assertSame(keys[0], kit.next());\n        assertSame(keys[1], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[0], vit.next());\n        assertSame(values[2], vit.next());\n\n        // change to order\n        map.put(keys[0], values[3]);\n        kit = map.keySet().iterator();\n        assertSame(keys[1], kit.next());\n        assertSame(keys[0], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[2], vit.next());\n        assertSame(values[3], vit.next());\n\n        // change to order\n        map.get(keys[1]);\n        kit = map.keySet().iterator();\n        assertSame(keys[0], kit.next());\n        assertSame(keys[1], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[3], vit.next());\n        assertSame(values[2], vit.next());\n\n        // change to order\n        map.get(keys[0]);\n        kit = map.keySet().iterator();\n        assertSame(keys[1], kit.next());\n        assertSame(keys[0], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[2], vit.next());\n        assertSame(values[3], vit.next());\n\n        // no change to order\n        map.get(keys[0]);\n        kit = map.keySet().iterator();\n        assertSame(keys[1], kit.next());\n        assertSame(keys[0], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[2], vit.next());\n        assertSame(values[3], vit.next());\n    }\n\n    @Test\n    public void testAccessOrder2() {\n        if (!isPutAddSupported() || !isPutChangeSupported()) {\n            return;\n        }\n        final K[] keys = getSampleKeys();\n        final V[] values = getSampleValues();\n        Iterator<K> kit;\n        Iterator<V> vit;\n\n        resetEmpty();\n        final LRUMap<K, V> lruMap = (LRUMap<K, V>) map;\n\n        lruMap.put(keys[0], values[0]);\n        lruMap.put(keys[1], values[1]);\n        kit = lruMap.keySet().iterator();\n        assertSame(keys[0], kit.next());\n        assertSame(keys[1], kit.next());\n        vit = lruMap.values().iterator();\n        assertSame(values[0], vit.next());\n        assertSame(values[1], vit.next());\n\n        // no change to order\n        lruMap.put(keys[1], values[1]);\n        kit = lruMap.keySet().iterator();\n        assertSame(keys[0], kit.next());\n        assertSame(keys[1], kit.next());\n        vit = lruMap.values().iterator();\n        assertSame(values[0], vit.next());\n        assertSame(values[1], vit.next());\n\n        // no change to order\n        lruMap.get(keys[1], false);\n        kit = lruMap.keySet().iterator();\n        assertSame(keys[0], kit.next());\n        assertSame(keys[1], kit.next());\n        vit = lruMap.values().iterator();\n        assertSame(values[0], vit.next());\n        assertSame(values[1], vit.next());\n\n        // change to order\n        lruMap.get(keys[0], true);\n        kit = lruMap.keySet().iterator();\n        assertSame(keys[1], kit.next());\n        assertSame(keys[0], kit.next());\n        vit = lruMap.values().iterator();\n        assertSame(values[1], vit.next());\n        assertSame(values[0], vit.next());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testClone() {\n        final LRUMap<K, V> map = new LRUMap<>(10);\n        map.put((K) \"1\", (V) \"1\");\n        final Map<K, V> cloned = map.clone();\n        assertEquals(map.size(), cloned.size());\n        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n    }\n\n    @Test\n    public void testCtors() {\n        assertAll(\n                () -> assertThrows(IllegalArgumentException.class, () -> new LRUMap<K, V>(0),\n                        \"maxSize must be positive\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> new LRUMap<K, V>(-1, 12, 0.75f, false),\n                        \"maxSize must be positive\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> new LRUMap<K, V>(10, -1),\n                        \"initialSize must not be negative\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> new LRUMap<K, V>(10, 12),\n                        \"initialSize must not be larger than maxSize\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> new LRUMap<K, V>(10, -1, 0.75f, false),\n                        \"initialSize must not be negative\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> new LRUMap<K, V>(10, 12, 0.75f, false),\n                        \"initialSize must not be larger than maxSize\")\n        );\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_Buckets() {\n        if (!isPutAddSupported() || !isPutChangeSupported()) {\n            return;\n        }\n        final SingleHashCode one = new SingleHashCode(\"1\");\n        final SingleHashCode two = new SingleHashCode(\"2\");\n        final SingleHashCode three = new SingleHashCode(\"3\");\n        final SingleHashCode four = new SingleHashCode(\"4\");\n        final SingleHashCode five = new SingleHashCode(\"5\");\n        final SingleHashCode six = new SingleHashCode(\"6\");\n\n        final LRUMap<K, V> map = new LRUMap<>(3, 1.0f);\n        final int hashIndex = map.hashIndex(map.hash(one), 4);\n        map.put((K) one, (V) \"A\");\n        map.put((K) two, (V) \"B\");\n        map.put((K) three, (V) \"C\");\n\n        assertEquals(4, map.data.length);\n        assertEquals(3, map.size);\n        assertNull(map.header.next);\n        assertEquals(one, map.header.after.key);  // LRU\n        assertEquals(two, map.header.after.after.key);\n        assertEquals(three, map.header.after.after.after.key);  // MRU\n        assertEquals(three, map.data[hashIndex].key);\n        assertEquals(two, map.data[hashIndex].next.key);\n        assertEquals(one, map.data[hashIndex].next.next.key);\n\n        map.put((K) four, (V) \"D\");  // reuses last in next list\n\n        assertEquals(4, map.data.length);\n        assertEquals(3, map.size);\n        assertNull(map.header.next);\n        assertEquals(two, map.header.after.key);  // LRU\n        assertEquals(three, map.header.after.after.key);\n        assertEquals(four, map.header.after.after.after.key);  // MRU\n        assertEquals(four, map.data[hashIndex].key);\n        assertEquals(three, map.data[hashIndex].next.key);\n        assertEquals(two, map.data[hashIndex].next.next.key);\n\n        map.get(three);\n\n        assertEquals(4, map.data.length);\n        assertEquals(3, map.size);\n        assertNull(map.header.next);\n        assertEquals(two, map.header.after.key);  // LRU\n        assertEquals(four, map.header.after.after.key);\n        assertEquals(three, map.header.after.after.after.key);  // MRU\n        assertEquals(four, map.data[hashIndex].key);\n        assertEquals(three, map.data[hashIndex].next.key);\n        assertEquals(two, map.data[hashIndex].next.next.key);\n\n        map.put((K) five, (V) \"E\");  // reuses last in next list\n\n        assertEquals(4, map.data.length);\n        assertEquals(3, map.size);\n        assertNull(map.header.next);\n        assertEquals(four, map.header.after.key);  // LRU\n        assertEquals(three, map.header.after.after.key);\n        assertEquals(five, map.header.after.after.after.key);  // MRU\n        assertEquals(five, map.data[hashIndex].key);\n        assertEquals(four, map.data[hashIndex].next.key);\n        assertEquals(three, map.data[hashIndex].next.next.key);\n\n        map.get(three);\n        map.get(five);\n\n        assertEquals(4, map.data.length);\n        assertEquals(3, map.size);\n        assertNull(map.header.next);\n        assertEquals(four, map.header.after.key);  // LRU\n        assertEquals(three, map.header.after.after.key);\n        assertEquals(five, map.header.after.after.after.key);  // MRU\n        assertEquals(five, map.data[hashIndex].key);\n        assertEquals(four, map.data[hashIndex].next.key);\n        assertEquals(three, map.data[hashIndex].next.next.key);\n\n        map.put((K) six, (V) \"F\");  // reuses middle in next list\n\n        assertEquals(4, map.data.length);\n        assertEquals(3, map.size);\n        assertNull(map.header.next);\n        assertEquals(three, map.header.after.key);  // LRU\n        assertEquals(five, map.header.after.after.key);\n        assertEquals(six, map.header.after.after.after.key);  // MRU\n        assertEquals(six, map.data[hashIndex].key);\n        assertEquals(five, map.data[hashIndex].next.key);\n        assertEquals(three, map.data[hashIndex].next.next.key);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_getEntry_int() {\n        if (!isPutAddSupported() || !isPutChangeSupported()) {\n            return;\n        }\n        final SingleHashCode one = new SingleHashCode(\"1\");\n        final SingleHashCode two = new SingleHashCode(\"2\");\n        final SingleHashCode three = new SingleHashCode(\"3\");\n\n        final LRUMap<K, V> map = new LRUMap<>(3, 1.0f);\n        map.put((K) one, (V) \"A\");\n        map.put((K) two, (V) \"B\");\n        map.put((K) three, (V) \"C\");\n\n        assertEquals(one, map.getEntry(0).key);\n        assertEquals(two, map.getEntry(1).key);\n        assertEquals(three, map.getEntry(2).key);\n        assertAll(\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> map.getEntry(-1)),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> map.getEntry(3))\n        );\n    }\n\n    @Test\n    public void testLRU() {\n        if (!isPutAddSupported() || !isPutChangeSupported()) {\n            return;\n        }\n        final K[] keys = getSampleKeys();\n        final V[] values = getSampleValues();\n        Iterator<K> kit;\n        Iterator<V> vit;\n\n        final LRUMap<K, V> map = new LRUMap<>(2);\n        assertEquals(0, map.size());\n        assertFalse(map.isFull());\n        assertEquals(2, map.maxSize());\n\n        map.put(keys[0], values[0]);\n        assertEquals(1, map.size());\n        assertFalse(map.isFull());\n        assertEquals(2, map.maxSize());\n\n        map.put(keys[1], values[1]);\n        assertEquals(2, map.size());\n        assertTrue(map.isFull());\n        assertEquals(2, map.maxSize());\n        kit = map.keySet().iterator();\n        assertSame(keys[0], kit.next());\n        assertSame(keys[1], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[0], vit.next());\n        assertSame(values[1], vit.next());\n\n        map.put(keys[2], values[2]);\n        assertEquals(2, map.size());\n        assertTrue(map.isFull());\n        assertEquals(2, map.maxSize());\n        kit = map.keySet().iterator();\n        assertSame(keys[1], kit.next());\n        assertSame(keys[2], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[1], vit.next());\n        assertSame(values[2], vit.next());\n\n        map.put(keys[2], values[0]);\n        assertEquals(2, map.size());\n        assertTrue(map.isFull());\n        assertEquals(2, map.maxSize());\n        kit = map.keySet().iterator();\n        assertSame(keys[1], kit.next());\n        assertSame(keys[2], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[1], vit.next());\n        assertSame(values[0], vit.next());\n\n        map.put(keys[1], values[3]);\n        assertEquals(2, map.size());\n        assertTrue(map.isFull());\n        assertEquals(2, map.maxSize());\n        kit = map.keySet().iterator();\n        assertSame(keys[2], kit.next());\n        assertSame(keys[1], kit.next());\n        vit = map.values().iterator();\n        assertSame(values[0], vit.next());\n        assertSame(values[3], vit.next());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveLRU() {\n        final MockLRUMapSubclass<K, String> map = new MockLRUMapSubclass<>(2);\n        assertNull(map.entry);\n        map.put((K) \"A\", \"a\");\n        assertNull(map.entry);\n        map.put((K) \"B\", \"b\");\n        assertNull(map.entry);\n        map.put((K) \"C\", \"c\");  // removes oldest, which is A=a\n        assertNotNull(map.entry);\n        assertEquals(\"A\", map.key);\n        assertEquals(\"a\", map.value);\n        assertEquals(\"C\", map.entry.getKey());  // entry is reused\n        assertEquals(\"c\", map.entry.getValue());  // entry is reused\n        assertFalse(map.containsKey(\"A\"));\n        assertTrue(map.containsKey(\"B\"));\n        assertTrue(map.containsKey(\"C\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveLRUBlocksRemove() {\n        final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<>(2, false);\n        assertEquals(0, map.size());\n        map.put((K) \"A\", (V) \"a\");\n        assertEquals(1, map.size());\n        map.put((K) \"B\", (V) \"b\");\n        assertEquals(2, map.size());\n        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n        assertEquals(3, map.size());\n        assertEquals(2, map.maxSize());\n        assertTrue(map.containsKey(\"A\"));\n        assertTrue(map.containsKey(\"B\"));\n        assertTrue(map.containsKey(\"C\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveLRUBlocksRemoveScan() {\n        final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<>(2, true);\n        assertEquals(0, map.size());\n        map.put((K) \"A\", (V) \"a\");\n        assertEquals(1, map.size());\n        map.put((K) \"B\", (V) \"b\");\n        assertEquals(2, map.size());\n        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n        assertEquals(3, map.size());\n        assertEquals(2, map.maxSize());\n        assertTrue(map.containsKey(\"A\"));\n        assertTrue(map.containsKey(\"B\"));\n        assertTrue(map.containsKey(\"C\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveLRUFirstBlocksRemove() {\n        final MockLRUMapSubclassFirstBlocksRemove<K, V> map = new MockLRUMapSubclassFirstBlocksRemove<>(2);\n        assertEquals(0, map.size());\n        map.put((K) \"A\", (V) \"a\");\n        assertEquals(1, map.size());\n        map.put((K) \"B\", (V) \"b\");\n        assertEquals(2, map.size());\n        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a  but this is blocked - so advance to B=b\n        assertEquals(2, map.size());\n        assertEquals(2, map.maxSize());\n        assertTrue(map.containsKey(\"A\"));\n        assertFalse(map.containsKey(\"B\"));\n        assertTrue(map.containsKey(\"C\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testReset() {\n        resetEmpty();\n        OrderedMap<K, V> ordered = getMap();\n        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n\n        resetFull();\n        ordered = getMap();\n        final List<K> list = new ArrayList<>(ordered.keySet());\n        final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n        assertSame(list.get(0), it.next());\n        assertSame(list.get(1), it.next());\n        it.reset();\n        assertSame(list.get(0), it.next());\n    }\n\n    @Test\n    public void testSynchronizedRemoveFromEntrySet() throws InterruptedException {\n\n        final Map<Object, Thread> map = new LRUMap<>(10000);\n\n        final Map<Throwable, String> exceptions = new HashMap<>();\n        final ThreadGroup tg = new ThreadGroup(getName()) {\n            @Override\n            public void uncaughtException(final Thread t, final Throwable e) {\n                exceptions.put(e, t.getName());\n                super.uncaughtException(t, e);\n            }\n        };\n\n        final int[] counter = new int[1];\n        counter[0] = 0;\n        final Thread[] threads = new Thread[50];\n        for (int i = 0; i < threads.length; ++i) {\n            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n\n                @Override\n                public void run() {\n                    int i = 0;\n                    try {\n                        synchronized (this) {\n                            notifyAll();\n                            wait();\n                        }\n                        final Thread thread = Thread.currentThread();\n                        while (i < 1000  && !interrupted()) {\n                            synchronized (map) {\n                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n                            }\n                        }\n                        synchronized (map) {\n                            map.entrySet().removeIf(entry -> entry.getValue() == this);\n                        }\n                    } catch (final InterruptedException e) {\n                        fail(\"Unexpected InterruptedException\");\n                    }\n                    if (i > 0) {\n                        synchronized (counter) {\n                            counter[0]++;\n                        }\n                    }\n                }\n\n            };\n        }\n\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.start();\n                thread.wait();\n            }\n        }\n\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.notifyAll();\n            }\n        }\n\n        Thread.sleep(1000);\n\n        for (final Thread thread : threads) {\n            thread.interrupt();\n        }\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.join();\n            }\n        }\n\n        assertEquals(0, exceptions.size(), \"Exceptions have been thrown: \" + exceptions);\n        assertTrue(counter[0] >= threads.length,\n                \"Each thread should have put at least 1 element into the map, but only \" + counter[0] + \" did succeed\");\n    }\n\n    @Test\n    public void testSynchronizedRemoveFromKeySet() throws InterruptedException {\n\n        final Map<Object, Thread> map = new LRUMap<>(10000);\n\n        final Map<Throwable, String> exceptions = new HashMap<>();\n        final ThreadGroup tg = new ThreadGroup(getName()) {\n            @Override\n            public void uncaughtException(final Thread t, final Throwable e) {\n                exceptions.put(e, t.getName());\n                super.uncaughtException(t, e);\n            }\n        };\n\n        final int[] counter = new int[1];\n        counter[0] = 0;\n        final Thread[] threads = new Thread[50];\n        for (int i = 0; i < threads.length; ++i) {\n            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n\n                @Override\n                public void run() {\n                    int i = 0;\n                    try {\n                        synchronized (this) {\n                            notifyAll();\n                            wait();\n                        }\n                        final Thread thread = Thread.currentThread();\n                        while (i < 1000  && !interrupted()) {\n                            synchronized (map) {\n                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n                            }\n                        }\n                        synchronized (map) {\n                            for (final Iterator<Object> iter = map.keySet().iterator(); iter.hasNext();) {\n                                final String name = (String) iter.next();\n                                if (name.substring(0, name.indexOf('[')).equals(getName())) {\n                                    iter.remove();\n                                }\n                            }\n                        }\n                    } catch (final InterruptedException e) {\n                        fail(\"Unexpected InterruptedException\");\n                    }\n                    if (i > 0) {\n                        synchronized (counter) {\n                            counter[0]++;\n                        }\n                    }\n                }\n\n            };\n        }\n\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.start();\n                thread.wait();\n            }\n        }\n\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.notifyAll();\n            }\n        }\n\n        Thread.sleep(1000);\n\n        for (final Thread thread : threads) {\n            thread.interrupt();\n        }\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.join();\n            }\n        }\n\n        assertEquals(0, exceptions.size(), \"Exceptions have been thrown: \" + exceptions);\n        assertTrue(counter[0] >= threads.length,\n                \"Each thread should have put at least 1 element into the map, but only \" + counter[0] + \" did succeed\");\n    }\n\n    @Test\n    public void testSynchronizedRemoveFromMapIterator() throws InterruptedException {\n\n        final LRUMap<Object, Thread> map = new LRUMap<>(10000);\n\n        final Map<Throwable, String> exceptions = new HashMap<>();\n        final ThreadGroup tg = new ThreadGroup(getName()) {\n            @Override\n            public void uncaughtException(final Thread t, final Throwable e) {\n                exceptions.put(e, t.getName());\n                super.uncaughtException(t, e);\n            }\n        };\n\n        final int[] counter = new int[1];\n        counter[0] = 0;\n        final Thread[] threads = new Thread[50];\n        for (int i = 0; i < threads.length; ++i) {\n            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n\n                @Override\n                public void run() {\n                    int i = 0;\n                    try {\n                        synchronized (this) {\n                            notifyAll();\n                            wait();\n                        }\n                        final Thread thread = Thread.currentThread();\n                        while (i < 1000  && !interrupted()) {\n                            synchronized (map) {\n                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n                            }\n                        }\n                        synchronized (map) {\n                            for (final MapIterator<Object, Thread> iter = map.mapIterator(); iter.hasNext();) {\n                                iter.next();\n                                if (iter.getValue() == this) {\n                                    iter.remove();\n                                }\n                            }\n                        }\n                    } catch (final InterruptedException e) {\n                        fail(\"Unexpected InterruptedException\");\n                    }\n                    if (i > 0) {\n                        synchronized (counter) {\n                            counter[0]++;\n                        }\n                    }\n                }\n\n            };\n        }\n\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.start();\n                thread.wait();\n            }\n        }\n\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.notifyAll();\n            }\n        }\n\n        Thread.sleep(1000);\n\n        for (final Thread thread : threads) {\n            thread.interrupt();\n        }\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.join();\n            }\n        }\n\n        assertEquals(0, exceptions.size(), \"Exceptions have been thrown: \" + exceptions);\n        assertTrue(counter[0] >= threads.length,\n                \"Each thread should have put at least 1 element into the map, but only \" + counter[0] + \" did succeed\");\n    }\n\n    @Test\n    public void testSynchronizedRemoveFromValues() throws InterruptedException {\n\n        final Map<Object, Thread> map = new LRUMap<>(10000);\n\n        final Map<Throwable, String> exceptions = new HashMap<>();\n        final ThreadGroup tg = new ThreadGroup(getName()) {\n            @Override\n            public void uncaughtException(final Thread t, final Throwable e) {\n                exceptions.put(e, t.getName());\n                super.uncaughtException(t, e);\n            }\n        };\n\n        final int[] counter = new int[1];\n        counter[0] = 0;\n        final Thread[] threads = new Thread[50];\n        for (int i = 0; i < threads.length; ++i) {\n            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n\n                @Override\n                public void run() {\n                    int i = 0;\n                    try {\n                        synchronized (this) {\n                            notifyAll();\n                            wait();\n                        }\n                        final Thread thread = Thread.currentThread();\n                        while (i < 1000  && !interrupted()) {\n                            synchronized (map) {\n                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n                            }\n                        }\n                        synchronized (map) {\n                            map.values().removeIf(thread1 -> thread1 == this);\n                        }\n                    } catch (final InterruptedException e) {\n                        fail(\"Unexpected InterruptedException\");\n                    }\n                    if (i > 0) {\n                        synchronized (counter) {\n                            counter[0]++;\n                        }\n                    }\n                }\n\n            };\n        }\n\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.start();\n                thread.wait();\n            }\n        }\n\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.notifyAll();\n            }\n        }\n\n        Thread.sleep(1000);\n\n        for (final Thread thread : threads) {\n            thread.interrupt();\n        }\n        for (final Thread thread : threads) {\n            synchronized (thread) {\n                thread.join();\n            }\n        }\n\n        assertEquals(0, exceptions.size(), \"Exceptions have been thrown: \" + exceptions);\n        assertTrue(counter[0] >= threads.length,\n                \"Each thread should have put at least 1 element into the map, but only \" + counter[0] + \" did succeed\");\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/LRUMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/LRUMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/LinkedMapTest.java.LinkedMapTest", "name": "LinkedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LinkedMapTest.java", "superclasses": "", "methods": ["[void]testClone()", "[void]testGetByIndex()", "[void]testGetValueByIndex()", "[void]testIndexOf()", "[void]testInitialCapacityZero()", "[void]testInsertionOrder()", "[void]testRemoveByIndex()", "[void]testReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/LinkedMapTest.java.LinkedMapTest.[]LinkedMapTest()", "src/test/java/org/apache/commons/collections4/map/LinkedMapTest.java.LinkedMapTest.[BulkTest]bulkTestListView()", "src/test/java/org/apache/commons/collections4/map/LinkedMapTest.java.LinkedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/LinkedMapTest.java.LinkedMapTest.[LinkedMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/map/LinkedMapTest.java.LinkedMapTest.[LinkedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/LinkedMapTest.java.LinkedMapTest.[LinkedMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    public class TestListView extends AbstractListTest<K> {\n\n        TestListView() {\n            super(\"TestListView\");\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<K> makeFullCollection() {\n            return LinkedMapTest.this.makeFullMap().asList();\n        }\n\n        @Override\n        public List<K> makeObject() {\n            return LinkedMapTest.this.makeObject().asList();\n        }\n    }", "definition": "    public class TestListView extends AbstractListTest<K>", "class_docstring": "", "name": "TestListView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TestListView() {\n            super(\"TestListView\");\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestListView", "params": [], "body": "                       {\n            super(\"TestListView\");\n        }", "signature": "TestListView()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return getSampleKeys();\n        }", "signature": "@Override\n        public K[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return false;\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isSetSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isSetSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isSetSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<K> makeFullCollection() {\n            return LinkedMapTest.this.makeFullMap().asList();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<K>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                            {\n            return LinkedMapTest.this.makeFullMap().asList();\n        }", "signature": "@Override\n        public List<K> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<K> makeObject() {\n            return LinkedMapTest.this.makeObject().asList();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<K>", "classes": []}, "name": "makeObject", "params": [], "body": "                                    {\n            return LinkedMapTest.this.makeObject().asList();\n        }", "signature": "@Override\n        public List<K> makeObject()"}]}], "class_docstring": "\nJUnit tests.\n", "original_string": "public class LinkedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n\n    public class TestListView extends AbstractListTest<K> {\n\n        TestListView() {\n            super(\"TestListView\");\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<K> makeFullCollection() {\n            return LinkedMapTest.this.makeFullMap().asList();\n        }\n\n        @Override\n        public List<K> makeObject() {\n            return LinkedMapTest.this.makeObject().asList();\n        }\n    }\n\n    public LinkedMapTest() {\n        super(LinkedMapTest.class.getSimpleName());\n    }\n\n    public BulkTest bulkTestListView() {\n        return new TestListView();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public LinkedMap<K, V> getMap() {\n        return (LinkedMap<K, V>) super.getMap();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public LinkedMap<K, V> makeFullMap() {\n        return (LinkedMap<K, V>) super.makeFullMap();\n    }\n\n    @Override\n    public LinkedMap<K, V> makeObject() {\n        return new LinkedMap<>();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testClone() {\n        final LinkedMap<K, V> map = new LinkedMap<>(10);\n        map.put((K) \"1\", (V) \"1\");\n        final Map<K, V> cloned = map.clone();\n        assertEquals(map.size(), cloned.size());\n        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n    }\n\n    @Test\n    public void testGetByIndex() {\n        resetEmpty();\n        LinkedMap<K, V> lm = getMap();\n        try {\n            lm.get(0);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lm.get(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lm = getMap();\n        try {\n            lm.get(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lm.get(lm.size());\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        int i = 0;\n        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n            assertSame(it.next(), lm.get(i));\n        }\n    }\n\n    @Test\n    public void testGetValueByIndex() {\n        resetEmpty();\n        LinkedMap<K, V> lm = getMap();\n        try {\n            lm.getValue(0);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lm.getValue(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lm = getMap();\n        try {\n            lm.getValue(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lm.getValue(lm.size());\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        int i = 0;\n        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n            it.next();\n            assertSame(it.getValue(), lm.getValue(i));\n        }\n    }\n\n    @Test\n    public void testIndexOf() {\n        resetEmpty();\n        LinkedMap<K, V> lm = getMap();\n        assertEquals(-1, lm.indexOf(getOtherKeys()));\n\n        resetFull();\n        lm = getMap();\n        final List<K> list = new ArrayList<>();\n        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n            list.add(it.next());\n        }\n        for (int i = 0; i < list.size(); i++) {\n            assertEquals(i, lm.indexOf(list.get(i)));\n        }\n    }\n\n    /**\n     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n     */\n    @Test\n    public void testInitialCapacityZero() {\n        final LinkedMap<String, String> map = new LinkedMap<>(0);\n        assertEquals(1, map.data.length);\n    }\n\n    @Test\n    public void testInsertionOrder() {\n        if (!isPutAddSupported() || !isPutChangeSupported()) {\n            return;\n        }\n        final K[] keys = getSampleKeys();\n        final V[] values = getSampleValues();\n        Iterator<K> keyIter;\n        Iterator<V> valueIter;\n\n        resetEmpty();\n        map.put(keys[0], values[0]);\n        map.put(keys[1], values[1]);\n        keyIter = map.keySet().iterator();\n        assertSame(keys[0], keyIter.next());\n        assertSame(keys[1], keyIter.next());\n        valueIter = map.values().iterator();\n        assertSame(values[0], valueIter.next());\n        assertSame(values[1], valueIter.next());\n\n        // no change to order\n        map.put(keys[1], values[1]);\n        keyIter = map.keySet().iterator();\n        assertSame(keys[0], keyIter.next());\n        assertSame(keys[1], keyIter.next());\n        valueIter = map.values().iterator();\n        assertSame(values[0], valueIter.next());\n        assertSame(values[1], valueIter.next());\n\n        // no change to order\n        map.put(keys[1], values[2]);\n        keyIter = map.keySet().iterator();\n        assertSame(keys[0], keyIter.next());\n        assertSame(keys[1], keyIter.next());\n        valueIter = map.values().iterator();\n        assertSame(values[0], valueIter.next());\n        assertSame(values[2], valueIter.next());\n\n        // no change to order\n        map.put(keys[0], values[3]);\n        keyIter = map.keySet().iterator();\n        assertSame(keys[0], keyIter.next());\n        assertSame(keys[1], keyIter.next());\n        valueIter = map.values().iterator();\n        assertSame(values[3], valueIter.next());\n        assertSame(values[2], valueIter.next());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/LinkedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/LinkedMap.fullCollection.version4.obj\");\n//    }\n\n    @Test\n    public void testRemoveByIndex() {\n        resetEmpty();\n        LinkedMap<K, V> lm = getMap();\n        try {\n            lm.remove(0);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lm.remove(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lm = getMap();\n        try {\n            lm.remove(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lm.remove(lm.size());\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        final List<K> list = new ArrayList<>();\n        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n            list.add(it.next());\n        }\n        for (int i = 0; i < list.size(); i++) {\n            final Object key = list.get(i);\n            final Object value = lm.get(key);\n            assertEquals(value, lm.remove(i));\n            list.remove(i);\n            assertFalse(lm.containsKey(key));\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testReset() {\n        resetEmpty();\n        OrderedMap<K, V> ordered = getMap();\n        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n\n        resetFull();\n        ordered = getMap();\n        final List<K> list = new ArrayList<>(ordered.keySet());\n        final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n        assertSame(list.get(0), it.next());\n        assertSame(list.get(1), it.next());\n        it.reset();\n        assertSame(list.get(0), it.next());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java.UnmodifiableOrderedMapTest", "name": "UnmodifiableOrderedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java.UnmodifiableOrderedMapTest.[]UnmodifiableOrderedMapTest()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java.UnmodifiableOrderedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java.UnmodifiableOrderedMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java.UnmodifiableOrderedMapTest.[boolean]isPutChangeSupported()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java.UnmodifiableOrderedMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java.UnmodifiableOrderedMapTest.[OrderedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java.UnmodifiableOrderedMapTest.[OrderedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractOrderedMapTest} for exercising the\n{@link UnmodifiableOrderedMap} implementation.\n", "original_string": "public class UnmodifiableOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n\n    public UnmodifiableOrderedMapTest() {\n        super(UnmodifiableOrderedMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isPutChangeSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public OrderedMap<K, V> makeFullMap() {\n        final OrderedMap<K, V> m = ListOrderedMap.listOrderedMap(new HashMap<>());\n        addSampleMappings(m);\n        return UnmodifiableOrderedMap.unmodifiableOrderedMap(m);\n    }\n\n    @Override\n    public OrderedMap<K, V> makeObject() {\n        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<>()));\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final OrderedMap<K, V> map = makeFullMap();\n        assertSame(map, UnmodifiableOrderedMap.unmodifiableOrderedMap(map));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableOrderedMap.unmodifiableOrderedMap(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullMap() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/UnmodifiableOrderedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/UnmodifiableOrderedMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_iteratorTest.java.MultiValueMap_iteratorTest", "name": "MultiValueMap_iteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_iteratorTest.java", "superclasses": "", "methods": ["[void]testIteratorWithSingleEntry()", "[void]testIteratorWithMultipleEntries()", "[void]testIteratorWithEmptyMap()", "[void]testIteratorAfterRemove()", "[void]testIteratorAfterClear()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiValueMap_iteratorTest.java.MultiValueMap_iteratorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiValueMap_iteratorTest {\n\n    private MultiValueMap<String, String> multiValueMap;\n\n    @BeforeEach\n    public void setUp() {\n        multiValueMap = new MultiValueMap<>();\n    }\n\n    @Test\n    public void testIteratorWithSingleEntry() {\n        multiValueMap.put(\"key1\", \"value1\");\n\n        Iterator<Map.Entry<String, String>> iterator = multiValueMap.iterator();\n        assertTrue(iterator.hasNext());\n        Map.Entry<String, String> entry = iterator.next();\n        assertEquals(\"key1\", entry.getKey());\n        assertEquals(\"value1\", entry.getValue());\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testIteratorWithMultipleEntries() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key1\", \"value2\");\n        multiValueMap.put(\"key2\", \"value3\");\n\n        Iterator<Map.Entry<String, String>> iterator = multiValueMap.iterator();\n        assertTrue(iterator.hasNext());\n        Map.Entry<String, String> entry1 = iterator.next();\n        assertEquals(\"key1\", entry1.getKey());\n        assertEquals(\"value1\", entry1.getValue());\n\n        assertTrue(iterator.hasNext());\n        Map.Entry<String, String> entry2 = iterator.next();\n        assertEquals(\"key1\", entry2.getKey());\n        assertEquals(\"value2\", entry2.getValue());\n\n        assertTrue(iterator.hasNext());\n        Map.Entry<String, String> entry3 = iterator.next();\n        assertEquals(\"key2\", entry3.getKey());\n        assertEquals(\"value3\", entry3.getValue());\n\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testIteratorWithEmptyMap() {\n        Iterator<Map.Entry<String, String>> iterator = multiValueMap.iterator();\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testIteratorAfterRemove() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key1\", \"value2\");\n        multiValueMap.put(\"key2\", \"value3\");\n\n        multiValueMap.removeMapping(\"key1\", \"value1\");\n\n        Iterator<Map.Entry<String, String>> iterator = multiValueMap.iterator();\n        assertTrue(iterator.hasNext());\n        Map.Entry<String, String> entry1 = iterator.next();\n        assertEquals(\"key1\", entry1.getKey());\n        assertEquals(\"value2\", entry1.getValue());\n\n        assertTrue(iterator.hasNext());\n        Map.Entry<String, String> entry2 = iterator.next();\n        assertEquals(\"key2\", entry2.getKey());\n        assertEquals(\"value3\", entry2.getValue());\n\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testIteratorAfterClear() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key1\", \"value2\");\n        multiValueMap.put(\"key2\", \"value3\");\n\n        multiValueMap.clear();\n\n        Iterator<Map.Entry<String, String>> iterator = multiValueMap.iterator();\n        assertFalse(iterator.hasNext());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private MultiValueMap<String, String> multiValueMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MultiValueMap<String, String>", "name": "multiValueMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_containsValueTest.java.CompositeMap_containsValueTest", "name": "CompositeMap_containsValueTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_containsValueTest.java", "superclasses": "", "methods": ["[void]testContainsValue_ValuePresentInFirstMap()", "[void]testContainsValue_ValuePresentInSecondMap()", "[void]testContainsValue_ValueNotPresent()", "[void]testContainsValue_AfterAddingNewMap()", "[void]testContainsValue_AfterRemovingValue()", "[void]testContainsValue_AfterPuttingNewValue()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_containsValueTest.java.CompositeMap_containsValueTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_containsValueTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> mapOne;\n    private Map<String, String> mapTwo;\n\n    @BeforeEach\n    public void setUp() {\n        mapOne = new HashMap<>();\n        mapOne.put(\"1\", \"one\");\n        mapOne.put(\"2\", \"two\");\n\n        mapTwo = new HashMap<>();\n        mapTwo.put(\"3\", \"three\");\n        mapTwo.put(\"4\", \"four\");\n\n        compositeMap = new CompositeMap<>(mapOne, mapTwo);\n    }\n\n    @Test\n    public void testContainsValue_ValuePresentInFirstMap() {\n        assertTrue(compositeMap.containsValue(\"one\"));\n    }\n\n    @Test\n    public void testContainsValue_ValuePresentInSecondMap() {\n        assertTrue(compositeMap.containsValue(\"three\"));\n    }\n\n    @Test\n    public void testContainsValue_ValueNotPresent() {\n        assertFalse(compositeMap.containsValue(\"five\"));\n    }\n\n    @Test\n    public void testContainsValue_AfterAddingNewMap() {\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"5\", \"five\");\n        compositeMap.addComposited(newMap);\n        assertTrue(compositeMap.containsValue(\"five\"));\n    }\n\n    @Test\n    public void testContainsValue_AfterRemovingValue() {\n        compositeMap.remove(\"1\");\n        assertFalse(compositeMap.containsValue(\"one\"));\n    }\n\n    @Test\n    public void testContainsValue_AfterPuttingNewValue() {\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"6\", \"six\");\n        compositeMap.addComposited(newMap);\n        assertTrue(compositeMap.containsValue(\"six\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapOne;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapOne", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapTwo;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapTwo", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/LinkedMap_indexOfTest.java.LinkedMap_indexOfTest", "name": "LinkedMap_indexOfTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LinkedMap_indexOfTest.java", "superclasses": "", "methods": ["[void]testIndexOfKeyExists()", "[void]testIndexOfKeyNotExists()", "[void]testIndexOfAfterRemove()", "[void]testIndexOfAfterAdd()", "[void]testIndexOfEmptyMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/LinkedMap_indexOfTest.java.LinkedMap_indexOfTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LinkedMap_indexOfTest {\n\n    private LinkedMap<String, String> linkedMap;\n\n    @BeforeEach\n    public void setUp() {\n        linkedMap = new LinkedMap<>();\n    }\n\n    @Test\n    public void testIndexOfKeyExists() {\n        linkedMap.put(\"key1\", \"value1\");\n        linkedMap.put(\"key2\", \"value2\");\n        linkedMap.put(\"key3\", \"value3\");\n\n        assertEquals(1, linkedMap.indexOf(\"key2\"));\n    }\n\n    @Test\n    public void testIndexOfKeyNotExists() {\n        linkedMap.put(\"key1\", \"value1\");\n        linkedMap.put(\"key2\", \"value2\");\n\n        assertEquals(CollectionUtils.INDEX_NOT_FOUND, linkedMap.indexOf(\"key4\"));\n    }\n\n    @Test\n    public void testIndexOfAfterRemove() {\n        linkedMap.put(\"key1\", \"value1\");\n        linkedMap.put(\"key2\", \"value2\");\n        linkedMap.put(\"key3\", \"value3\");\n\n        linkedMap.remove(1);\n\n        assertEquals(CollectionUtils.INDEX_NOT_FOUND, linkedMap.indexOf(\"key2\"));\n        assertEquals(1, linkedMap.indexOf(\"key3\"));\n    }\n\n    @Test\n    public void testIndexOfAfterAdd() {\n        linkedMap.put(\"key1\", \"value1\");\n        linkedMap.put(\"key2\", \"value2\");\n\n        linkedMap.put(\"key3\", \"value3\");\n\n        assertEquals(2, linkedMap.indexOf(\"key3\"));\n    }\n\n    @Test\n    public void testIndexOfEmptyMap() {\n        assertEquals(CollectionUtils.INDEX_NOT_FOUND, linkedMap.indexOf(\"key1\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private LinkedMap<String, String> linkedMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "LinkedMap<String, String>", "name": "linkedMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/SingletonMap_putTest.java.SingletonMap_putTest", "name": "SingletonMap_putTest", "file_path": "src/test/java/org/apache/commons/collections4/map/SingletonMap_putTest.java", "superclasses": "", "methods": ["[void]testPutWithMatchingKey()", "[void]testPutWithNonMatchingKey()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonMap_putTest {\n\n    @Test\n    public void testPutWithMatchingKey() {\n        SingletonMap<String, String> map = new SingletonMap<>(\"key\", \"oldValue\");\n        String oldValue = map.put(\"key\", \"newValue\");\n        assertEquals(\"oldValue\", oldValue);\n        assertEquals(\"newValue\", map.get(\"key\"));\n    }\n\n    @Test\n    public void testPutWithNonMatchingKey() {\n        SingletonMap<String, String> map = new SingletonMap<>(\"key\", \"value\");\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            map.put(\"newKey\", \"newValue\");\n        });\n        assertEquals(\"Cannot put new key/value pair - Map is fixed size singleton\", exception.getMessage());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_sizeTest.java.MultiValueMap_sizeTest", "name": "MultiValueMap_sizeTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_sizeTest.java", "superclasses": "", "methods": ["[void]testSizeWithExistingKey()", "[void]testSizeWithNonExistingKey()", "[void]testSizeAfterRemoveMapping()", "[void]testSizeAfterClear()", "[void]testSizeWithMultipleKeys()", "[void]testSizeWithEmptyCollection()", "[void]testSizeWithNullKey()", "[void]testSizeWithDifferentCollectionTypes()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiValueMap_sizeTest.java.MultiValueMap_sizeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiValueMap_sizeTest {\n\n    private MultiValueMap<String, String> multiValueMap;\n\n    @BeforeEach\n    public void setUp() {\n        multiValueMap = new MultiValueMap<>();\n    }\n\n    @Test\n    public void testSizeWithExistingKey() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key1\", \"value2\");\n        assertEquals(2, multiValueMap.size(\"key1\"));\n    }\n\n    @Test\n    public void testSizeWithNonExistingKey() {\n        assertEquals(0, multiValueMap.size(\"key2\"));\n    }\n\n    @Test\n    public void testSizeAfterRemoveMapping() {\n        multiValueMap.put(\"key3\", \"value3\");\n        multiValueMap.put(\"key3\", \"value4\");\n        multiValueMap.removeMapping(\"key3\", \"value3\");\n        assertEquals(1, multiValueMap.size(\"key3\"));\n    }\n\n    @Test\n    public void testSizeAfterClear() {\n        multiValueMap.put(\"key4\", \"value5\");\n        multiValueMap.put(\"key4\", \"value6\");\n        multiValueMap.clear();\n        assertEquals(0, multiValueMap.size(\"key4\"));\n    }\n\n    @Test\n    public void testSizeWithMultipleKeys() {\n        multiValueMap.put(\"key5\", \"value7\");\n        multiValueMap.put(\"key6\", \"value8\");\n        multiValueMap.put(\"key6\", \"value9\");\n        assertEquals(1, multiValueMap.size(\"key5\"));\n        assertEquals(2, multiValueMap.size(\"key6\"));\n    }\n\n    @Test\n    public void testSizeWithEmptyCollection() {\n        multiValueMap.put(\"key7\", \"value10\");\n        multiValueMap.removeMapping(\"key7\", \"value10\");\n        assertEquals(0, multiValueMap.size(\"key7\"));\n    }\n\n    @Test\n    public void testSizeWithNullKey() {\n        multiValueMap.put(null, \"value11\");\n        multiValueMap.put(null, \"value12\");\n        assertEquals(2, multiValueMap.size(null));\n    }\n\n    @Test\n    public void testSizeWithDifferentCollectionTypes() {\n        MultiValueMap<String, String> mapWithArrayList = MultiValueMap.multiValueMap(new HashMap<>(), ArrayList.class);\n        mapWithArrayList.put(\"key8\", \"value13\");\n        mapWithArrayList.put(\"key8\", \"value14\");\n        assertEquals(2, mapWithArrayList.size(\"key8\"));\n\n        MultiValueMap<String, String> mapWithHashSet = MultiValueMap.multiValueMap(new HashMap<>(), HashSet.class);\n        mapWithHashSet.put(\"key9\", \"value15\");\n        mapWithHashSet.put(\"key9\", \"value16\");\n        assertEquals(2, mapWithHashSet.size(\"key9\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private MultiValueMap<String, String> multiValueMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MultiValueMap<String, String>", "name": "multiValueMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_addCompositedTest.java.CompositeMap_addCompositedTest", "name": "CompositeMap_addCompositedTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_addCompositedTest.java", "superclasses": "", "methods": ["[void]testAddCompositedSuccess()", "[void]testAddCompositedKeyCollisionWithoutMutator()", "[void]testAddCompositedKeyCollisionWithMutator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_addCompositedTest.java.CompositeMap_addCompositedTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_addCompositedTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> map1;\n    private Map<String, String> map2;\n    private Map<String, String> map3;\n\n    @BeforeEach\n    public void setUp() {\n        map1 = new HashMap<>();\n        map1.put(\"key1\", \"value1\");\n        map1.put(\"key2\", \"value2\");\n\n        map2 = new HashMap<>();\n        map2.put(\"key3\", \"value3\");\n        map2.put(\"key4\", \"value4\");\n\n        map3 = new HashMap<>();\n        map3.put(\"key5\", \"value5\"); // No key collision\n\n        compositeMap = new CompositeMap<>(map1, map2);\n    }\n\n    @Test\n    public void testAddCompositedSuccess() {\n        compositeMap.addComposited(map3);\n        assertEquals(5, compositeMap.size());\n    }\n\n    @Test\n    public void testAddCompositedKeyCollisionWithoutMutator() {\n        Map<String, String> mapWithCollision = new HashMap<>();\n        mapWithCollision.put(\"key2\", \"value5\"); // Key collision with map1\n        assertThrows(IllegalArgumentException.class, () -> {\n            compositeMap.addComposited(mapWithCollision);\n        });\n    }\n\n    @Test\n    public void testAddCompositedKeyCollisionWithMutator() {\n        compositeMap.setMutator(new CompositeMap.MapMutator<String, String>() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public String put(CompositeMap<String, String> map, Map<String, String>[] composited, String key, String value) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public void putAll(CompositeMap<String, String> map, Map<String, String>[] composited, Map<? extends String, ? extends String> t) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public void resolveCollision(CompositeMap<String, String> composite, Map<String, String> existing, Map<String, String> added, Collection<String> intersect) {\n                // Handle collision\n            }\n        });\n\n        Map<String, String> mapWithCollision = new HashMap<>();\n        mapWithCollision.put(\"key2\", \"value5\"); // Key collision with map1\n        compositeMap.addComposited(mapWithCollision);\n        assertEquals(5, compositeMap.size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map1", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map2", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map3;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map3", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/LazySortedMap_tailMapTest.java.LazySortedMap_tailMapTest", "name": "LazySortedMap_tailMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LazySortedMap_tailMapTest.java", "superclasses": "", "methods": ["[void]testTailMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LazySortedMap_tailMapTest {\n\n    @Test\n    public void testTailMap() {\n        // Given\n        SortedMap<Integer, String> originalMap = new TreeMap<>();\n        originalMap.put(1, \"one\");\n        originalMap.put(2, \"two\");\n        originalMap.put(3, \"three\");\n        Factory<String> factory = () -> \"default\";\n        LazySortedMap<Integer, String> lazySortedMap = LazySortedMap.lazySortedMap(originalMap, factory);\n\n        // When\n        SortedMap<Integer, String> resultMap = lazySortedMap.tailMap(2);\n\n        // Then\n        assertNotNull(resultMap);\n        assertEquals(2, resultMap.size());\n        assertEquals(\"two\", resultMap.get(2));\n        assertEquals(\"three\", resultMap.get(3));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java.PassiveExpiringMapTest", "name": "PassiveExpiringMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java", "superclasses": "", "methods": ["[void]testConstructors()", "[void]testContainsKey()", "[void]testContainsValue()", "[void]testDecoratedMap()", "[void]testEntrySet()", "[void]testExpiration()", "[void]testGet()", "[void]testIsEmpty()", "[void]testKeySet()", "[void]testPut()", "[void]testSize()", "[void]testValues()", "[void]testZeroTimeToLive()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java.PassiveExpiringMapTest.[]PassiveExpiringMapTest()", "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java.PassiveExpiringMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java.PassiveExpiringMapTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java.PassiveExpiringMapTest.[Map<Integer, String>]makeDecoratedTestMap()", "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java.PassiveExpiringMapTest.[Map<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java.PassiveExpiringMapTest.[Map<Integer, String>]makeTestMap()", "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java.PassiveExpiringMapTest.[void]validateExpiration(Map<String, String>,long)"], "overrides": null, "attributes": [{"original_string": "    private static final class TestExpirationPolicy\n        implements ExpirationPolicy<Integer, String> {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public long expirationTime(final Integer key, final String value) {\n            // odd keys expire immediately, even keys never expire\n            if (key == null) {\n                return 0;\n            }\n\n            if (key.intValue() % 2 == 0) {\n                return -1;\n            }\n\n            return 0;\n        }\n    }", "definition": "    private static final class TestExpirationPolicy\n        implements ExpirationPolicy<Integer, String>", "class_docstring": "", "name": "TestExpirationPolicy", "super_interfaces": ["ExpirationPolicy<Integer, String>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public long expirationTime(final Integer key, final String value) {\n            // odd keys expire immediately, even keys never expire\n            if (key == null) {\n                return 0;\n            }\n\n            if (key.intValue() % 2 == 0) {\n                return -1;\n            }\n\n            return 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "expirationTime", "params": [{"name": "key", "type": "Integer"}, {"name": "value", "type": "String"}], "body": "                                                                          {\n            // odd keys expire immediately, even keys never expire\n            if (key == null) {\n                return 0;\n            }\n\n            if (key.intValue() % 2 == 0) {\n                return -1;\n            }\n\n            return 0;\n        }", "signature": "@Override\n        public long expirationTime(final Integer key, final String value)"}]}], "class_docstring": "\nJUnit tests.\n", "original_string": "public class PassiveExpiringMapTest<K, V> extends AbstractMapTest<K, V> {\n\n    private static final class TestExpirationPolicy\n        implements ExpirationPolicy<Integer, String> {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public long expirationTime(final Integer key, final String value) {\n            // odd keys expire immediately, even keys never expire\n            if (key == null) {\n                return 0;\n            }\n\n            if (key.intValue() % 2 == 0) {\n                return -1;\n            }\n\n            return 0;\n        }\n    }\n\n    public PassiveExpiringMapTest() {\n        super(PassiveExpiringMapTest.class.getSimpleName());\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n//                \"src/test/resources/data/test/PassiveExpiringMap.emptyCollection.version4.obj\");\n//\n//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n//                \"src/test/resources/data/test/PassiveExpiringMap.fullCollection.version4.obj\");\n//    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return AbstractCollectionTest.UNORDERED;\n    }\n\n    private Map<Integer, String> makeDecoratedTestMap() {\n        final Map<Integer, String> m = new HashMap<>();\n        m.put(Integer.valueOf(1), \"one\");\n        m.put(Integer.valueOf(2), \"two\");\n        m.put(Integer.valueOf(3), \"three\");\n        m.put(Integer.valueOf(4), \"four\");\n        m.put(Integer.valueOf(5), \"five\");\n        m.put(Integer.valueOf(6), \"six\");\n        return new PassiveExpiringMap<>(new TestExpirationPolicy(), m);\n    }\n\n    @Override\n    public Map<K, V> makeObject() {\n        return new PassiveExpiringMap<>();\n    }\n\n    private Map<Integer, String> makeTestMap() {\n        final Map<Integer, String> m =\n                new PassiveExpiringMap<>(new TestExpirationPolicy());\n        m.put(Integer.valueOf(1), \"one\");\n        m.put(Integer.valueOf(2), \"two\");\n        m.put(Integer.valueOf(3), \"three\");\n        m.put(Integer.valueOf(4), \"four\");\n        m.put(Integer.valueOf(5), \"five\");\n        m.put(Integer.valueOf(6), \"six\");\n        return m;\n    }\n\n    @Test\n    public void testConstructors() {\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> {\n                    final Map<String, String> map = null;\n                    new PassiveExpiringMap<>(map);\n                },\n                        \"constructor - exception should have been thrown.\"),\n                () -> assertThrows(NullPointerException.class, () -> {\n                    final ExpirationPolicy<String, String> policy = null;\n                    new PassiveExpiringMap<>(policy);\n                },\n                        \"constructor - exception should have been thrown.\"),\n                () -> assertThrows(NullPointerException.class, () -> {\n                    final TimeUnit unit = null;\n                    new PassiveExpiringMap<String, String>(10L, unit);\n                },\n                        \"constructor - exception should have been thrown.\")\n        );\n    }\n\n    @Test\n    public void testContainsKey() {\n        final Map<Integer, String> m = makeTestMap();\n        assertFalse(m.containsKey(Integer.valueOf(1)));\n        assertFalse(m.containsKey(Integer.valueOf(3)));\n        assertFalse(m.containsKey(Integer.valueOf(5)));\n        assertTrue(m.containsKey(Integer.valueOf(2)));\n        assertTrue(m.containsKey(Integer.valueOf(4)));\n        assertTrue(m.containsKey(Integer.valueOf(6)));\n    }\n\n    @Test\n    public void testContainsValue() {\n        final Map<Integer, String> m = makeTestMap();\n        assertFalse(m.containsValue(\"one\"));\n        assertFalse(m.containsValue(\"three\"));\n        assertFalse(m.containsValue(\"five\"));\n        assertTrue(m.containsValue(\"two\"));\n        assertTrue(m.containsValue(\"four\"));\n        assertTrue(m.containsValue(\"six\"));\n    }\n\n    @Test\n    public void testDecoratedMap() {\n        // entries shouldn't expire\n        final Map<Integer, String> m = makeDecoratedTestMap();\n        assertEquals(6, m.size());\n        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n\n        // removing a single item shouldn't affect any other items\n        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n        m.remove(Integer.valueOf(2));\n        assertEquals(5, m.size());\n        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n        assertNull(m.get(Integer.valueOf(2)));\n\n        // adding a single, even item shouldn't affect any other items\n        assertNull(m.get(Integer.valueOf(2)));\n        m.put(Integer.valueOf(2), \"two\");\n        assertEquals(6, m.size());\n        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n\n        // adding a single, odd item (one that expires) shouldn't affect any\n        // other items\n        // put the entry expires immediately\n        m.put(Integer.valueOf(1), \"one-one\");\n        assertEquals(5, m.size());\n        assertNull(m.get(Integer.valueOf(1)));\n        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n    }\n\n    @Test\n    public void testEntrySet() {\n        final Map<Integer, String> m = makeTestMap();\n        assertEquals(3, m.entrySet().size());\n    }\n\n    @Test\n    public void testExpiration() {\n        validateExpiration(new PassiveExpiringMap<>(500), 500);\n        validateExpiration(new PassiveExpiringMap<>(1000), 1000);\n        validateExpiration(new PassiveExpiringMap<>(\n                new PassiveExpiringMap.ConstantTimeToLiveExpirationPolicy<>(500)), 500);\n        validateExpiration(new PassiveExpiringMap<>(\n                new PassiveExpiringMap.ConstantTimeToLiveExpirationPolicy<>(1, TimeUnit.SECONDS)), 1000);\n    }\n\n    @Test\n    public void testGet() {\n        final Map<Integer, String> m = makeTestMap();\n        assertNull(m.get(Integer.valueOf(1)));\n        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n        assertNull(m.get(Integer.valueOf(3)));\n        assertEquals(\"four\", m.get(Integer.valueOf(4)));\n        assertNull(m.get(Integer.valueOf(5)));\n        assertEquals(\"six\", m.get(Integer.valueOf(6)));\n    }\n\n    @Test\n    public void testIsEmpty() {\n        Map<Integer, String> m = makeTestMap();\n        assertFalse(m.isEmpty());\n\n        // remove just evens\n        m = makeTestMap();\n        m.remove(Integer.valueOf(2));\n        m.remove(Integer.valueOf(4));\n        m.remove(Integer.valueOf(6));\n        assertTrue(m.isEmpty());\n    }\n\n    @Test\n    public void testKeySet() {\n        final Map<Integer, String> m = makeTestMap();\n        assertEquals(3, m.size());\n    }\n\n    @Test\n    public void testPut() {\n        final Map<Integer, String> m = makeTestMap();\n        assertNull(m.put(Integer.valueOf(1), \"ONE\"));\n        assertEquals(\"two\", m.put(Integer.valueOf(2), \"TWO\"));\n        assertNull(m.put(Integer.valueOf(3), \"THREE\"));\n        assertEquals(\"four\", m.put(Integer.valueOf(4), \"FOUR\"));\n        assertNull(m.put(Integer.valueOf(5), \"FIVE\"));\n        assertEquals(\"six\", m.put(Integer.valueOf(6), \"SIX\"));\n    }\n\n    @Test\n    public void testSize() {\n        final Map<Integer, String> m = makeTestMap();\n        assertEquals(3, m.size());\n    }\n\n    @Test\n    public void testValues() {\n        final Map<Integer, String> m = makeTestMap();\n        assertEquals(3, m.size());\n    }\n\n    @Test\n    public void testZeroTimeToLive() {\n        // item should not be available\n        final PassiveExpiringMap<String, String> m = new PassiveExpiringMap<>(0L);\n        m.put(\"a\", \"b\");\n        assertNull(m.get(\"a\"));\n    }\n\n    private void validateExpiration(final Map<String, String> map, final long timeout) {\n        map.put(\"a\", \"b\");\n\n        assertNotNull(map.get(\"a\"));\n\n        try {\n            Thread.sleep(2 * timeout);\n        } catch (final InterruptedException e) {\n            fail();\n        }\n\n        assertNull(map.get(\"a\"));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_nextKeyTest.java.ListOrderedMap_nextKeyTest", "name": "ListOrderedMap_nextKeyTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_nextKeyTest.java", "superclasses": "", "methods": ["[void]testNextKey_ValidKey()", "[void]testNextKey_LastKey()", "[void]testNextKey_NonExistentKey()", "[void]testNextKey_EmptyMap()", "[void]testNextKey_AfterRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/ListOrderedMap_nextKeyTest.java.ListOrderedMap_nextKeyTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ListOrderedMap_nextKeyTest {\n    private ListOrderedMap<String, String> listOrderedMap;\n\n    @BeforeEach\n    public void setUp() {\n        listOrderedMap = new ListOrderedMap<>();\n    }\n\n    @Test\n    public void testNextKey_ValidKey() {\n        listOrderedMap.put(\"key1\", \"value1\");\n        listOrderedMap.put(\"key2\", \"value2\");\n        listOrderedMap.put(\"key3\", \"value3\");\n\n        assertEquals(\"key2\", listOrderedMap.nextKey(\"key1\"));\n        assertEquals(\"key3\", listOrderedMap.nextKey(\"key2\"));\n    }\n\n    @Test\n    public void testNextKey_LastKey() {\n        listOrderedMap.put(\"key1\", \"value1\");\n        listOrderedMap.put(\"key2\", \"value2\");\n\n        assertNull(listOrderedMap.nextKey(\"key2\"));\n    }\n\n    @Test\n    public void testNextKey_NonExistentKey() {\n        listOrderedMap.put(\"key1\", \"value1\");\n        listOrderedMap.put(\"key2\", \"value2\");\n\n        assertNull(listOrderedMap.nextKey(\"key3\"));\n    }\n\n    @Test\n    public void testNextKey_EmptyMap() {\n        assertNull(listOrderedMap.nextKey(\"key1\"));\n    }\n\n    @Test\n    public void testNextKey_AfterRemove() {\n        listOrderedMap.put(\"key1\", \"value1\");\n        listOrderedMap.put(\"key2\", \"value2\");\n        listOrderedMap.put(\"key3\", \"value3\");\n\n        listOrderedMap.remove(\"key2\");\n\n        assertEquals(\"key3\", listOrderedMap.nextKey(\"key1\"));\n        assertNull(listOrderedMap.nextKey(\"key3\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ListOrderedMap<String, String> listOrderedMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListOrderedMap<String, String>", "name": "listOrderedMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/TransformedMap_putAllTest.java.TransformedMap_putAllTest", "name": "TransformedMap_putAllTest", "file_path": "src/test/java/org/apache/commons/collections4/map/TransformedMap_putAllTest.java", "superclasses": "", "methods": ["[void]testPutAll()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedMap_putAllTest {\n\n    @Test\n    public void testPutAll() {\n        // Given\n        Map<String, String> originalMap = new HashMap<>();\n        originalMap.put(\"key1\", \"value1\");\n        originalMap.put(\"key2\", \"value2\");\n\n        Transformer<String, String> keyTransformer = mock(Transformer.class);\n        Transformer<String, String> valueTransformer = mock(Transformer.class);\n\n        when(keyTransformer.apply(\"key1\")).thenReturn(\"transformedKey1\");\n        when(keyTransformer.apply(\"key2\")).thenReturn(\"transformedKey2\");\n        when(valueTransformer.apply(\"value1\")).thenReturn(\"transformedValue1\");\n        when(valueTransformer.apply(\"value2\")).thenReturn(\"transformedValue2\");\n\n        TransformedMap<String, String> transformedMap = new TransformedMap<>(new HashMap<>(), keyTransformer, valueTransformer);\n\n        // When\n        transformedMap.putAll(originalMap);\n\n        // Then\n        Map<String, String> expectedMap = new HashMap<>();\n        expectedMap.put(\"transformedKey1\", \"transformedValue1\");\n        expectedMap.put(\"transformedKey2\", \"transformedValue2\");\n\n        assertEquals(expectedMap, transformedMap.decorated());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_containsKeyTest.java.CompositeMap_containsKeyTest", "name": "CompositeMap_containsKeyTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_containsKeyTest.java", "superclasses": "", "methods": ["[void]testContainsKey_KeyInFirstMap()", "[void]testContainsKey_KeyInSecondMap()", "[void]testContainsKey_KeyNotPresent()", "[void]testContainsKey_AfterAddingNewMap()", "[void]testContainsKey_AfterRemovingKey()", "[void]testContainsKey_AfterRemovingCompositedMap()", "[void]testContainsKey_NullKey()", "[void]testContainsKey_EmptyCompositeMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_containsKeyTest.java.CompositeMap_containsKeyTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_containsKeyTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> mapOne;\n    private Map<String, String> mapTwo;\n\n    @BeforeEach\n    public void setUp() {\n        mapOne = new HashMap<>();\n        mapOne.put(\"1\", \"one\");\n        mapOne.put(\"2\", \"two\");\n\n        mapTwo = new HashMap<>();\n        mapTwo.put(\"3\", \"three\");\n        mapTwo.put(\"4\", \"four\");\n\n        compositeMap = new CompositeMap<>(mapOne, mapTwo);\n    }\n\n    @Test\n    public void testContainsKey_KeyInFirstMap() {\n        assertTrue(compositeMap.containsKey(\"1\"));\n    }\n\n    @Test\n    public void testContainsKey_KeyInSecondMap() {\n        assertTrue(compositeMap.containsKey(\"3\"));\n    }\n\n    @Test\n    public void testContainsKey_KeyNotPresent() {\n        assertFalse(compositeMap.containsKey(\"5\"));\n    }\n\n    @Test\n    public void testContainsKey_AfterAddingNewMap() {\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"5\", \"five\");\n        compositeMap.addComposited(newMap);\n        assertTrue(compositeMap.containsKey(\"5\"));\n    }\n\n    @Test\n    public void testContainsKey_AfterRemovingKey() {\n        compositeMap.remove(\"1\");\n        assertFalse(compositeMap.containsKey(\"1\"));\n    }\n\n    @Test\n    public void testContainsKey_AfterRemovingCompositedMap() {\n        compositeMap.removeComposited(mapOne);\n        assertFalse(compositeMap.containsKey(\"1\"));\n    }\n\n    @Test\n    public void testContainsKey_NullKey() {\n        assertFalse(compositeMap.containsKey(null));\n    }\n\n    @Test\n    public void testContainsKey_EmptyCompositeMap() {\n        compositeMap = new CompositeMap<>();\n        assertFalse(compositeMap.containsKey(\"1\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapOne;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapOne", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapTwo;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapTwo", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_putTest.java.PassiveExpiringMap_putTest", "name": "PassiveExpiringMap_putTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_putTest.java", "superclasses": "", "methods": ["[void]testPut_EntryNeverExpires()", "[void]testPut_EntryAlwaysExpires()", "[void]testPut_EntryExpiresAfterTime()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PassiveExpiringMap_putTest {\n\n    @Test\n    public void testPut_EntryNeverExpires() {\n        // Given\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(-1L);\n        String key = \"key\";\n        String value = \"value\";\n\n        // When\n        String result = map.put(key, value);\n\n        // Then\n        assertNull(result);\n        assertEquals(value, map.get(key));\n    }\n\n    @Test\n    public void testPut_EntryAlwaysExpires() {\n        // Given\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(0L);\n        String key = \"key\";\n        String value = \"value\";\n\n        // When\n        String result = map.put(key, value);\n\n        // Then\n        assertNull(result);\n        assertNull(map.get(key));\n    }\n\n    @Test\n    public void testPut_EntryExpiresAfterTime() throws InterruptedException {\n        // Given\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(1, TimeUnit.SECONDS);\n        String key = \"key\";\n        String value = \"value\";\n\n        // When\n        String result = map.put(key, value);\n\n        // Then\n        assertNull(result);\n        assertEquals(value, map.get(key));\n\n        // Wait for the entry to expire\n        Thread.sleep(1100);\n        assertNull(map.get(key));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMap_unmodifiableSortedMapTest.java.UnmodifiableSortedMap_unmodifiableSortedMapTest", "name": "UnmodifiableSortedMap_unmodifiableSortedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMap_unmodifiableSortedMapTest.java", "superclasses": "", "methods": ["[void]testUnmodifiableSortedMap_WithUnmodifiableMap()", "[void]testUnmodifiableSortedMap_WithModifiableMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnmodifiableSortedMap_unmodifiableSortedMapTest {\n\n    @Test\n    public void testUnmodifiableSortedMap_WithUnmodifiableMap() {\n        // Given\n        SortedMap<String, String> originalMap = new TreeMap<>();\n        originalMap.put(\"key1\", \"value1\");\n        SortedMap<String, String> unmodifiableMap = UnmodifiableSortedMap.unmodifiableSortedMap(originalMap);\n\n        // When\n        SortedMap<String, String> result = UnmodifiableSortedMap.unmodifiableSortedMap(unmodifiableMap);\n\n        // Then\n        assertSame(unmodifiableMap, result);\n    }\n\n    @Test\n    public void testUnmodifiableSortedMap_WithModifiableMap() {\n        // Given\n        SortedMap<String, String> originalMap = new TreeMap<>();\n        originalMap.put(\"key1\", \"value1\");\n\n        // When\n        SortedMap<String, String> result = UnmodifiableSortedMap.unmodifiableSortedMap(originalMap);\n\n        // Then\n        assertTrue(result instanceof UnmodifiableSortedMap);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_getTest.java.PassiveExpiringMap_getTest", "name": "PassiveExpiringMap_getTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_getTest.java", "superclasses": "", "methods": ["[void]testGet_EntryExistsAndNotExpired()", "[void]testGet_EntryExistsButExpired()", "[void]testGet_EntryDoesNotExist()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PassiveExpiringMap_getTest {\n\n    @Test\n    public void testGet_EntryExistsAndNotExpired() {\n        // Given\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(new ConstantTimeToLiveExpirationPolicy<>(1000L), new HashMap<>());\n        map.put(\"key1\", \"value1\");\n\n        // When\n        String result = map.get(\"key1\");\n\n        // Then\n        assertEquals(\"value1\", result);\n    }\n\n    @Test\n    public void testGet_EntryExistsButExpired() {\n        // Given\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(new ConstantTimeToLiveExpirationPolicy<>(0L), new HashMap<>());\n        map.put(\"key1\", \"value1\");\n\n        // When\n        String result = map.get(\"key1\");\n\n        // Then\n        assertNull(result);\n    }\n\n    @Test\n    public void testGet_EntryDoesNotExist() {\n        // Given\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(new ConstantTimeToLiveExpirationPolicy<>(1000L), new HashMap<>());\n\n        // When\n        String result = map.get(\"key1\");\n\n        // Then\n        assertNull(result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_entrySetTest.java.PassiveExpiringMap_entrySetTest", "name": "PassiveExpiringMap_entrySetTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_entrySetTest.java", "superclasses": "", "methods": ["[void]testEntrySet()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PassiveExpiringMap_entrySetTest {\n\n    @Test\n    public void testEntrySet() {\n        // Given\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(new ConstantTimeToLiveExpirationPolicy<>(1000L), new HashMap<>());\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n\n        // When\n        Set<Map.Entry<String, String>> entrySet = map.entrySet();\n\n        // Then\n        assertEquals(2, entrySet.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_valuesTest.java.MultiValueMap_valuesTest", "name": "MultiValueMap_valuesTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_valuesTest.java", "superclasses": "", "methods": ["[void]testValuesWithEmptyMap()", "[void]testValuesWithSingleEntry()", "[void]testValuesWithMultipleEntries()", "[void]testValuesAfterClear()", "[void]testValuesAfterRemove()", "[void]testValuesWithCustomCollection()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiValueMap_valuesTest.java.MultiValueMap_valuesTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiValueMap_valuesTest {\n\n    private MultiValueMap<String, String> multiValueMap;\n\n    @BeforeEach\n    public void setUp() {\n        multiValueMap = new MultiValueMap<>();\n    }\n\n    @Test\n    public void testValuesWithEmptyMap() {\n        Collection<Object> values = multiValueMap.values();\n        assertTrue(values.isEmpty());\n    }\n\n    @Test\n    public void testValuesWithSingleEntry() {\n        multiValueMap.put(\"key1\", \"value1\");\n        Collection<Object> values = multiValueMap.values();\n        assertEquals(1, values.size());\n        assertTrue(values.contains(\"value1\"));\n    }\n\n    @Test\n    public void testValuesWithMultipleEntries() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key2\", \"value2\");\n        multiValueMap.put(\"key1\", \"value3\");\n        Collection<Object> values = multiValueMap.values();\n        assertEquals(3, values.size());\n        assertTrue(values.contains(\"value1\"));\n        assertTrue(values.contains(\"value2\"));\n        assertTrue(values.contains(\"value3\"));\n    }\n\n    @Test\n    public void testValuesAfterClear() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key2\", \"value2\");\n        multiValueMap.clear();\n        Collection<Object> values = multiValueMap.values();\n        assertTrue(values.isEmpty());\n    }\n\n    @Test\n    public void testValuesAfterRemove() {\n        multiValueMap.put(\"key1\", \"value1\");\n        multiValueMap.put(\"key2\", \"value2\");\n        multiValueMap.remove(\"key1\");\n        Collection<Object> values = multiValueMap.values();\n        assertEquals(1, values.size());\n        assertTrue(values.contains(\"value2\"));\n    }\n\n    @Test\n    public void testValuesWithCustomCollection() {\n        Map<String, Collection<String>> map = new HashMap<>();\n        map.put(\"key1\", new ArrayList<>(java.util.Arrays.asList(\"value1\", \"value2\")));\n        MultiValueMap<String, String> customMap = MultiValueMap.multiValueMap(map, ArrayList::new);\n        Collection<Object> values = customMap.values();\n        assertEquals(2, values.size());\n        assertTrue(values.contains(\"value1\"));\n        assertTrue(values.contains(\"value2\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private MultiValueMap<String, String> multiValueMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MultiValueMap<String, String>", "name": "multiValueMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/CaseInsensitiveMapTest.java.CaseInsensitiveMapTest", "name": "CaseInsensitiveMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CaseInsensitiveMapTest.java", "superclasses": "", "methods": ["[void]testCaseInsensitive()", "[void]testClone()", "[void]testInitialCapacityZero()", "[void]testLocaleIndependence()", "[void]testNullHandling()", "[void]testPutAll()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CaseInsensitiveMapTest.java.CaseInsensitiveMapTest.[]CaseInsensitiveMapTest()", "src/test/java/org/apache/commons/collections4/map/CaseInsensitiveMapTest.java.CaseInsensitiveMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/CaseInsensitiveMapTest.java.CaseInsensitiveMapTest.[CaseInsensitiveMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for the {@link CaseInsensitiveMap} implementation.\n", "original_string": "public class CaseInsensitiveMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    public CaseInsensitiveMapTest() {\n        super(CaseInsensitiveMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public CaseInsensitiveMap<K, V> makeObject() {\n        return new CaseInsensitiveMap<>();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCaseInsensitive() {\n        final Map<K, V> map = makeObject();\n        map.put((K) \"One\", (V) \"One\");\n        map.put((K) \"Two\", (V) \"Two\");\n        assertEquals(\"One\", map.get(\"one\"));\n        assertEquals(\"One\", map.get(\"oNe\"));\n        map.put((K) \"two\", (V) \"Three\");\n        assertEquals(\"Three\", map.get(\"Two\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testClone() {\n        final CaseInsensitiveMap<K, V> map = new CaseInsensitiveMap<>(10);\n        map.put((K) \"1\", (V) \"1\");\n        final CaseInsensitiveMap<K, V> cloned = map.clone();\n        assertEquals(map.size(), cloned.size());\n        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n    }\n\n    /**\n     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n     */\n    @Test\n    public void testInitialCapacityZero() {\n        final CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<>(0);\n        assertEquals(1, map.data.length);\n    }\n\n    // COLLECTIONS-294\n    @Test\n    public void testLocaleIndependence() {\n        final Locale orig = Locale.getDefault();\n\n        final Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\", StringUtils.EMPTY, StringUtils.EMPTY), Locale.getDefault() };\n\n        final String[][] data = {\n            { \"i\", \"I\" },\n            { \"\\u03C2\", \"\\u03C3\" },\n            { \"\\u03A3\", \"\\u03C2\" },\n            { \"\\u03A3\", \"\\u03C3\" },\n        };\n\n        try {\n            for (final Locale locale : locales) {\n                Locale.setDefault(locale);\n                for (int j = 0; j < data.length; j++) {\n                    assertTrue(data[j][0].equalsIgnoreCase(data[j][1]), \"Test data corrupt: \" + j);\n                    final CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<>();\n                    map.put(data[j][0], \"value\");\n                    assertEquals(\"value\", map.get(data[j][1]), Locale.getDefault() + \": \" + j);\n                }\n            }\n        } finally {\n            Locale.setDefault(orig);\n        }\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/CaseInsensitiveMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/CaseInsensitiveMap.fullCollection.version4.obj\");\n//    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testNullHandling() {\n        final Map<K, V> map = makeObject();\n        map.put((K) \"One\", (V) \"One\");\n        map.put((K) \"Two\", (V) \"Two\");\n        map.put(null, (V) \"Three\");\n        assertEquals(\"Three\", map.get(null));\n        map.put(null, (V) \"Four\");\n        assertEquals(\"Four\", map.get(null));\n        final Set<K> keys = map.keySet();\n        assertTrue(keys.contains(\"one\"));\n        assertTrue(keys.contains(\"two\"));\n        assertTrue(keys.contains(null));\n        assertEquals(3, keys.size());\n    }\n\n    @Test\n    public void testPutAll() {\n        final Map<Object, String> map = new HashMap<>();\n        map.put(\"One\", \"One\");\n        map.put(\"Two\", \"Two\");\n        map.put(\"one\", \"Three\");\n        map.put(null, \"Four\");\n        map.put(Integer.valueOf(20), \"Five\");\n        final Map<Object, String> caseInsensitiveMap = new CaseInsensitiveMap<>(map);\n        assertEquals(4, caseInsensitiveMap.size()); // ones collapsed\n        final Set<Object> keys = caseInsensitiveMap.keySet();\n        assertTrue(keys.contains(\"one\"));\n        assertTrue(keys.contains(\"two\"));\n        assertTrue(keys.contains(null));\n        assertTrue(keys.contains(Integer.toString(20)));\n        assertEquals(4, keys.size());\n        assertTrue(!caseInsensitiveMap.containsValue(\"One\")\n            || !caseInsensitiveMap.containsValue(\"Three\")); // ones collapsed\n        assertEquals(\"Four\", caseInsensitiveMap.get(null));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_equalsTest.java.CompositeMap_equalsTest", "name": "CompositeMap_equalsTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_equalsTest.java", "superclasses": "", "methods": ["[void]testEqualsWithEqualMaps()", "[void]testEqualsWithDifferentMaps()", "[void]testEqualsWithNonMapObject()", "[void]testEqualsAfterModification()", "[void]testEqualsAfterRemoval()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_equalsTest.java.CompositeMap_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_equalsTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> map1;\n    private Map<String, String> map2;\n\n    @BeforeEach\n    public void setUp() {\n        map1 = new HashMap<>();\n        map1.put(\"key1\", \"value1\");\n        map1.put(\"key2\", \"value2\");\n\n        map2 = new HashMap<>();\n        map2.put(\"key3\", \"value3\");\n        map2.put(\"key4\", \"value4\");\n\n        compositeMap = new CompositeMap<>(map1, map2);\n    }\n\n    @Test\n    public void testEqualsWithEqualMaps() {\n        CompositeMap<String, String> otherCompositeMap = new CompositeMap<>(map1, map2);\n        assertTrue(compositeMap.equals(otherCompositeMap));\n    }\n\n    @Test\n    public void testEqualsWithDifferentMaps() {\n        Map<String, String> differentMap1 = new HashMap<>();\n        differentMap1.put(\"key1\", \"value1\");\n        differentMap1.put(\"key2\", \"value2\");\n\n        Map<String, String> differentMap2 = new HashMap<>();\n        differentMap2.put(\"key3\", \"value3\");\n        differentMap2.put(\"key4\", \"value4\");\n        differentMap2.put(\"key5\", \"value5\");\n\n        CompositeMap<String, String> otherCompositeMap = new CompositeMap<>(differentMap1, differentMap2);\n        assertFalse(compositeMap.equals(otherCompositeMap));\n    }\n\n    @Test\n    public void testEqualsWithNonMapObject() {\n        assertFalse(compositeMap.equals(\"Not a map\"));\n    }\n\n    @Test\n    public void testEqualsAfterModification() {\n        Map<String, String> modifiedMap1 = new HashMap<>(map1);\n        modifiedMap1.put(\"key5\", \"value5\");\n        CompositeMap<String, String> otherCompositeMap = new CompositeMap<>(modifiedMap1, map2);\n        assertFalse(compositeMap.equals(otherCompositeMap));\n    }\n\n    @Test\n    public void testEqualsAfterRemoval() {\n        compositeMap.remove(\"key1\");\n        Map<String, String> modifiedMap1 = new HashMap<>(map1);\n        modifiedMap1.remove(\"key1\");\n        CompositeMap<String, String> otherCompositeMap = new CompositeMap<>(modifiedMap1, map2);\n        assertTrue(compositeMap.equals(otherCompositeMap));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map1", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_clearTest.java.PassiveExpiringMap_clearTest", "name": "PassiveExpiringMap_clearTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_clearTest.java", "superclasses": "", "methods": ["[void]testClear()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PassiveExpiringMap_clearTest {\n\n    @Test\n    public void testClear() {\n        // Given\n        Map<String, String> map = new HashMap<>();\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        PassiveExpiringMap<String, String> expiringMap = new PassiveExpiringMap<>(map);\n\n        // When\n        expiringMap.clear();\n\n        // Then\n        assertEquals(0, expiringMap.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_transformedSortedMapTest.java.TransformedSortedMap_transformedSortedMapTest", "name": "TransformedSortedMap_transformedSortedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_transformedSortedMapTest.java", "superclasses": "", "methods": ["[void]testTransformedSortedMapWithNonEmptyMap()", "[void]testTransformedSortedMapWithEmptyMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedSortedMap_transformedSortedMapTest {\n\n    @Test\n    public void testTransformedSortedMapWithNonEmptyMap() {\n        // Given\n        SortedMap<String, Integer> originalMap = new TreeMap<>();\n        originalMap.put(\"one\", 1);\n        originalMap.put(\"two\", 2);\n\n        Transformer<String, String> keyTransformer = input -> input.toUpperCase();\n        Transformer<Integer, Integer> valueTransformer = input -> input * 2;\n\n        // When\n        TransformedSortedMap<String, Integer> transformedMap = TransformedSortedMap.transformedSortedMap(originalMap, keyTransformer, valueTransformer);\n\n        // Then\n        assertEquals(2, transformedMap.size());\n        assertEquals(2, transformedMap.get(\"ONE\"));\n        assertEquals(4, transformedMap.get(\"TWO\"));\n    }\n\n    @Test\n    public void testTransformedSortedMapWithEmptyMap() {\n        // Given\n        SortedMap<String, Integer> originalMap = new TreeMap<>();\n\n        Transformer<String, String> keyTransformer = input -> input.toUpperCase();\n        Transformer<Integer, Integer> valueTransformer = input -> input * 2;\n\n        // When\n        TransformedSortedMap<String, Integer> transformedMap = TransformedSortedMap.transformedSortedMap(originalMap, keyTransformer, valueTransformer);\n\n        // Then\n        assertTrue(transformedMap.isEmpty());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap2Test.java.ListOrderedMap2Test", "name": "ListOrderedMap2Test", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap2Test.java", "superclasses": "", "methods": ["[void]testGetByIndex()", "[void]testGetValueByIndex()", "[void]testIndexOf()", "[void]testRemoveByIndex()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/ListOrderedMap2Test.java.ListOrderedMap2Test.[]ListOrderedMap2Test()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMap2Test.java.ListOrderedMap2Test.[BulkTest]bulkTestListView()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMap2Test.java.ListOrderedMap2Test.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMap2Test.java.ListOrderedMap2Test.[ListOrderedMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMap2Test.java.ListOrderedMap2Test.[ListOrderedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMap2Test.java.ListOrderedMap2Test.[ListOrderedMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    public class TestListView extends AbstractListTest<K> {\n\n        TestListView() {\n            super(\"TestListView\");\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<K> makeFullCollection() {\n            return ListOrderedMap2Test.this.makeFullMap().asList();\n        }\n\n        @Override\n        public List<K> makeObject() {\n            return ListOrderedMap2Test.this.makeObject().asList();\n        }\n    }", "definition": "    public class TestListView extends AbstractListTest<K>", "class_docstring": "", "name": "TestListView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TestListView() {\n            super(\"TestListView\");\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestListView", "params": [], "body": "                       {\n            super(\"TestListView\");\n        }", "signature": "TestListView()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return getSampleKeys();\n        }", "signature": "@Override\n        public K[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return false;\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isSetSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isSetSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isSetSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<K> makeFullCollection() {\n            return ListOrderedMap2Test.this.makeFullMap().asList();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<K>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                            {\n            return ListOrderedMap2Test.this.makeFullMap().asList();\n        }", "signature": "@Override\n        public List<K> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<K> makeObject() {\n            return ListOrderedMap2Test.this.makeObject().asList();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<K>", "classes": []}, "name": "makeObject", "params": [], "body": "                                    {\n            return ListOrderedMap2Test.this.makeObject().asList();\n        }", "signature": "@Override\n        public List<K> makeObject()"}]}], "class_docstring": "\nExtension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap} implementation.\n", "original_string": "public class ListOrderedMap2Test<K, V> extends AbstractOrderedMapTest<K, V> {\n\n    public class TestListView extends AbstractListTest<K> {\n\n        TestListView() {\n            super(\"TestListView\");\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<K> makeFullCollection() {\n            return ListOrderedMap2Test.this.makeFullMap().asList();\n        }\n\n        @Override\n        public List<K> makeObject() {\n            return ListOrderedMap2Test.this.makeObject().asList();\n        }\n    }\n\n    public ListOrderedMap2Test() {\n        super(ListOrderedMap2Test.class.getSimpleName());\n    }\n\n    public BulkTest bulkTestListView() {\n        return new TestListView();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListOrderedMap<K, V> getMap() {\n        return (ListOrderedMap<K, V>) super.getMap();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListOrderedMap<K, V> makeFullMap() {\n        return (ListOrderedMap<K, V>) super.makeFullMap();\n    }\n\n    @Override\n    public ListOrderedMap<K, V> makeObject() {\n        return new ListOrderedMap<>();\n    }\n\n    @Test\n    public void testGetByIndex() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n        try {\n            lom.get(0);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.get(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lom = getMap();\n        try {\n            lom.get(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.get(lom.size());\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        int i = 0;\n        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n            assertSame(it.next(), lom.get(i));\n        }\n    }\n\n    @Test\n    public void testGetValueByIndex() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n        try {\n            lom.getValue(0);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.getValue(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lom = getMap();\n        try {\n            lom.getValue(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.getValue(lom.size());\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        int i = 0;\n        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n            it.next();\n            assertSame(it.getValue(), lom.getValue(i));\n        }\n    }\n\n    @Test\n    public void testIndexOf() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n        assertEquals(-1, lom.indexOf(getOtherKeys()));\n\n        resetFull();\n        lom = getMap();\n        final List<K> list = new ArrayList<>();\n        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n            list.add(it.next());\n        }\n        for (int i = 0; i < list.size(); i++) {\n            assertEquals(i, lom.indexOf(list.get(i)));\n        }\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"D:/dev/collections/data/test/ListOrderedMap.emptyCollection.version3.1.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj\");\n//    }\n\n    @Test\n    public void testRemoveByIndex() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n        try {\n            lom.remove(0);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.remove(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lom = getMap();\n        try {\n            lom.remove(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.remove(lom.size());\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        final List<K> list = new ArrayList<>();\n        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n            list.add(it.next());\n        }\n        for (int i = 0; i < list.size(); i++) {\n            final Object key = list.get(i);\n            final Object value = lom.get(key);\n            assertEquals(value, lom.remove(i));\n            list.remove(i);\n            assertFalse(lom.containsKey(key));\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMap_subMapTest.java.PredicatedSortedMap_subMapTest", "name": "PredicatedSortedMap_subMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMap_subMapTest.java", "superclasses": "", "methods": ["[void]testSubMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PredicatedSortedMap_subMapTest {\n\n    @Test\n    public void testSubMap() {\n        // Given\n        SortedMap<Integer, String> originalMap = new TreeMap<>();\n        originalMap.put(1, \"One\");\n        originalMap.put(2, \"Two\");\n        originalMap.put(3, \"Three\");\n        Predicate<Integer> keyPredicate = key -> key > 0;\n        Predicate<String> valuePredicate = value -> value.length() > 2;\n        PredicatedSortedMap<Integer, String> predicatedMap = PredicatedSortedMap.predicatedSortedMap(originalMap, keyPredicate, valuePredicate);\n\n        // When\n        SortedMap<Integer, String> subMap = predicatedMap.subMap(2, 4);\n\n        // Then\n        assertNotNull(subMap);\n        assertEquals(2, subMap.size());\n        assertEquals(\"Two\", subMap.get(2));\n        assertEquals(\"Three\", subMap.get(3));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_clearTest.java.ListOrderedMap_clearTest", "name": "ListOrderedMap_clearTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_clearTest.java", "superclasses": "", "methods": ["[void]testClear()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ListOrderedMap_clearTest {\n\n    @Test\n    void testClear() {\n        // Given\n        ListOrderedMap<String, String> map = new ListOrderedMap<>(new HashMap<>());\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n\n        // When\n        map.clear();\n\n        // Then\n        assertTrue(map.isEmpty());\n        assertEquals(0, map.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java.TransformedSortedMapTest", "name": "TransformedSortedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java", "superclasses": "", "methods": ["[void]testFactory_Decorate()", "[void]testFactory_decorateTransform()", "[void]testTransformedMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java.TransformedSortedMapTest.[]TransformedSortedMapTest()", "src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java.TransformedSortedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java.TransformedSortedMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java.TransformedSortedMapTest.[boolean]isSubMapViewsSerializable()", "src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java.TransformedSortedMapTest.[SortedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSortedMapTest} for exercising the {@link TransformedSortedMap}\nimplementation.\n", "original_string": "public class TransformedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n\n    public TransformedSortedMapTest() {\n        super(TransformedSortedMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public String[] ignoredTests() {\n        return null;\n    }\n\n    @Override\n    public boolean isSubMapViewsSerializable() {\n        // TreeMap sub map views have a bug in deserialization.\n        return false;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SortedMap<K, V> makeObject() {\n        return TransformedSortedMap.transformingSortedMap(new TreeMap<>(),\n                (Transformer<? super K, ? extends K>) TransformerUtils.nopTransformer(),\n                (Transformer<? super V, ? extends V>) TransformerUtils.nopTransformer());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFactory_Decorate() {\n        final SortedMap<K, V> base = new TreeMap<>();\n        base.put((K) \"A\", (V) \"1\");\n        base.put((K) \"B\", (V) \"2\");\n        base.put((K) \"C\", (V) \"3\");\n\n        final SortedMap<K, V> trans = TransformedSortedMap\n                .transformingSortedMap(\n                        base,\n                        null,\n                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(3, trans.size());\n        assertEquals(\"1\", trans.get(\"A\"));\n        assertEquals(\"2\", trans.get(\"B\"));\n        assertEquals(\"3\", trans.get(\"C\"));\n        trans.put((K) \"D\", (V) \"4\");\n        assertEquals(Integer.valueOf(4), trans.get(\"D\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFactory_decorateTransform() {\n        final SortedMap<K, V> base = new TreeMap<>();\n        base.put((K) \"A\", (V) \"1\");\n        base.put((K) \"B\", (V) \"2\");\n        base.put((K) \"C\", (V) \"3\");\n\n        final SortedMap<K, V> trans = TransformedSortedMap\n                .transformedSortedMap(\n                        base,\n                        null,\n                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(3, trans.size());\n        assertEquals(Integer.valueOf(1), trans.get(\"A\"));\n        assertEquals(Integer.valueOf(2), trans.get(\"B\"));\n        assertEquals(Integer.valueOf(3), trans.get(\"C\"));\n        trans.put((K) \"D\", (V) \"4\");\n        assertEquals(Integer.valueOf(4), trans.get(\"D\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testTransformedMap() {\n        final Object[] els = { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n\n        SortedMap<K, V> map = TransformedSortedMap\n                .transformingSortedMap(\n                        new TreeMap<>(),\n                        (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n                        null);\n        assertEquals(0, map.size());\n        for (int i = 0; i < els.length; i++) {\n            map.put((K) els[i], (V) els[i]);\n            assertEquals(i + 1, map.size());\n            assertTrue(map.containsKey(Integer.valueOf((String) els[i])));\n            final SortedMap<K, V> finalMap1 = map;\n            final int finalI = i;\n            assertThrows(ClassCastException.class, () -> finalMap1.containsKey(els[finalI]));\n            assertTrue(map.containsValue(els[i]));\n            assertEquals(els[i], map.get(Integer.valueOf((String) els[i])));\n        }\n\n        final SortedMap<K, V> finalMap = map;\n        assertThrows(ClassCastException.class, () -> finalMap.remove(els[0]));\n        assertEquals(els[0], map.remove(Integer.valueOf((String) els[0])));\n\n        map = TransformedSortedMap\n                .transformingSortedMap(\n                        new TreeMap<>(),\n                        null,\n                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, map.size());\n        for (int i = 0; i < els.length; i++) {\n            map.put((K) els[i], (V) els[i]);\n            assertEquals(i + 1, map.size());\n            assertTrue(map.containsValue(Integer.valueOf((String) els[i])));\n            assertFalse(map.containsValue(els[i]));\n            assertTrue(map.containsKey(els[i]));\n            assertEquals(Integer.valueOf((String) els[i]), map.get(els[i]));\n        }\n\n        assertEquals(Integer.valueOf((String) els[0]), map.remove(els[0]));\n\n        final Set<Map.Entry<K, V>> entrySet = map.entrySet();\n        final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n        array[0].setValue((V) \"66\");\n        assertEquals(Integer.valueOf(66), array[0].getValue());\n        assertEquals(Integer.valueOf(66), map.get(array[0].getKey()));\n\n        final Map.Entry<K, V> entry = entrySet.iterator().next();\n        entry.setValue((V) \"88\");\n        assertEquals(Integer.valueOf(88), entry.getValue());\n        assertEquals(Integer.valueOf(88), map.get(entry.getKey()));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/TransformedSortedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/TransformedSortedMap.fullCollection.version4.obj\");\n//    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_clearTest.java.CompositeMap_clearTest", "name": "CompositeMap_clearTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_clearTest.java", "superclasses": "", "methods": ["[void]testClear()", "[void]testClearWithEmptyCompositeMap()", "[void]testClearWithSingleMap()", "[void]testClearWithMultipleMaps()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_clearTest.java.CompositeMap_clearTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_clearTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> map1;\n    private Map<String, String> map2;\n\n    @BeforeEach\n    public void setUp() {\n        map1 = new HashMap<>();\n        map1.put(\"key1\", \"value1\");\n        map1.put(\"key2\", \"value2\");\n\n        map2 = new HashMap<>();\n        map2.put(\"key3\", \"value3\");\n        map2.put(\"key4\", \"value4\");\n\n        compositeMap = new CompositeMap<>(map1, map2);\n    }\n\n    @Test\n    public void testClear() {\n        compositeMap.clear();\n        assertTrue(map1.isEmpty());\n        assertTrue(map2.isEmpty());\n    }\n\n    @Test\n    public void testClearWithEmptyCompositeMap() {\n        CompositeMap<String, String> emptyCompositeMap = new CompositeMap<>();\n        emptyCompositeMap.clear();\n        assertTrue(emptyCompositeMap.isEmpty());\n    }\n\n    @Test\n    public void testClearWithSingleMap() {\n        CompositeMap<String, String> singleMapComposite = new CompositeMap<>(map1);\n        singleMapComposite.clear();\n        assertTrue(map1.isEmpty());\n    }\n\n    @Test\n    public void testClearWithMultipleMaps() {\n        Map<String, String> map3 = new HashMap<>();\n        map3.put(\"key5\", \"value5\");\n        map3.put(\"key6\", \"value6\");\n\n        compositeMap.addComposited(map3);\n        compositeMap.clear();\n\n        assertTrue(map1.isEmpty());\n        assertTrue(map2.isEmpty());\n        assertTrue(map3.isEmpty());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map1", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/UnmodifiableMap_valuesTest.java.UnmodifiableMap_valuesTest", "name": "UnmodifiableMap_valuesTest", "file_path": "src/test/java/org/apache/commons/collections4/map/UnmodifiableMap_valuesTest.java", "superclasses": "", "methods": ["[void]testValuesReturnsUnmodifiableCollection()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnmodifiableMap_valuesTest {\n\n    @Test\n    public void testValuesReturnsUnmodifiableCollection() {\n        // Given\n        Map<String, String> originalMap = new HashMap<>();\n        originalMap.put(\"key1\", \"value1\");\n        originalMap.put(\"key2\", \"value2\");\n        Map<String, String> unmodifiableMap = UnmodifiableMap.unmodifiableMap(originalMap);\n\n        // When\n        Collection<String> values = unmodifiableMap.values();\n\n        // Then\n        assertTrue(values instanceof UnmodifiableCollection);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_valuesTest.java.PassiveExpiringMap_valuesTest", "name": "PassiveExpiringMap_valuesTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_valuesTest.java", "superclasses": "", "methods": ["[void]testValuesWithExpiredEntries()", "[void]testValuesWithoutExpiredEntries()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PassiveExpiringMap_valuesTest {\n\n    @Test\n    public void testValuesWithExpiredEntries() {\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(1, TimeUnit.MILLISECONDS);\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n\n        // Wait for entries to expire\n        try {\n            Thread.sleep(2);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n\n        Collection<String> values = map.values();\n        assertEquals(0, values.size());\n    }\n\n    @Test\n    public void testValuesWithoutExpiredEntries() {\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(1000, TimeUnit.MILLISECONDS);\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n\n        Collection<String> values = map.values();\n        assertEquals(2, values.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java.PredicatedSortedMapTest", "name": "PredicatedSortedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java", "superclasses": "", "methods": ["[void]testEntrySet()", "[void]testPut()", "[void]testReverseSortOrder()", "[void]testSortOrder()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java.PredicatedSortedMapTest.[]PredicatedSortedMapTest()", "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java.PredicatedSortedMapTest.[SortedMap<K, V>]decorateMap(SortedMap<K, V>,Predicate<? super K>,Predicate<? super V>)", "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java.PredicatedSortedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java.PredicatedSortedMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java.PredicatedSortedMapTest.[boolean]isSubMapViewsSerializable()", "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java.PredicatedSortedMapTest.[SortedMap<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java.PredicatedSortedMapTest.[SortedMap<K, V>]makeTestMap()", "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java.PredicatedSortedMapTest.[SortedMap<K, V>]makeTestMapWithComparator()"], "overrides": null, "attributes": [{"original_string": "    private final class ReverseStringComparator implements Comparator<K> {\n        @Override\n        public int compare(final K arg0, final K arg1) {\n            return ((String) arg1).compareTo((String) arg0);\n        }\n    }", "definition": "    private final class ReverseStringComparator implements Comparator<K>", "class_docstring": "", "name": "ReverseStringComparator", "super_interfaces": ["Comparator<K>"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public int compare(final K arg0, final K arg1) {\n            return ((String) arg1).compareTo((String) arg0);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "arg0", "type": "K"}, {"name": "arg1", "type": "K"}], "body": "                                                       {\n            return ((String) arg1).compareTo((String) arg0);\n        }", "signature": "@Override\n        public int compare(final K arg0, final K arg1)"}]}], "class_docstring": "\nExtension of {@link PredicatedMapTest} for exercising the\n{@link PredicatedSortedMap} implementation.\n", "original_string": "public class PredicatedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n\n    private final class ReverseStringComparator implements Comparator<K> {\n        @Override\n        public int compare(final K arg0, final K arg1) {\n            return ((String) arg1).compareTo((String) arg0);\n        }\n    }\n\n    protected static final Predicate<Object> truePredicate = TruePredicate.truePredicate();\n\n    protected static final Predicate<Object> testPredicate = String.class::isInstance;\n\n    protected final Comparator<K> reverseStringComparator = new ReverseStringComparator();\n\n    public PredicatedSortedMapTest() {\n        super(PredicatedSortedMapTest.class.getSimpleName());\n    }\n\n    protected SortedMap<K, V> decorateMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,\n        final Predicate<? super V> valuePredicate) {\n        return PredicatedSortedMap.predicatedSortedMap(map, keyPredicate, valuePredicate);\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public boolean isSubMapViewsSerializable() {\n        // TreeMap sub map views have a bug in deserialization.\n        return false;\n    }\n\n    @Override\n    public SortedMap<K, V> makeObject() {\n        return decorateMap(new TreeMap<>(), truePredicate, truePredicate);\n    }\n\n    public SortedMap<K, V> makeTestMap() {\n        return decorateMap(new TreeMap<>(), testPredicate, testPredicate);\n    }\n\n    public SortedMap<K, V> makeTestMapWithComparator() {\n        return decorateMap(new ConcurrentSkipListMap<>(reverseStringComparator), testPredicate, testPredicate);\n    }\n\n    // from TestPredicatedMap\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEntrySet() {\n        SortedMap<K, V> map = makeTestMap();\n        assertNotNull(map.entrySet(), \"returned entryset should not be null\");\n        map = decorateMap(new TreeMap<>(), null, null);\n        map.put((K) \"oneKey\", (V) \"oneValue\");\n        assertEquals(1, map.entrySet().size(), \"returned entryset should contain one entry\");\n        map = decorateMap(map, null, null);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPut() {\n        final Map<K, V> map = makeTestMap();\n        assertThrows(IllegalArgumentException.class, () -> map.put((K) \"Hi\", (V) Integer.valueOf(3)),\n                \"Illegal value should raise IllegalArgument\");\n\n        assertThrows(IllegalArgumentException.class, () -> map.put((K) Integer.valueOf(3), (V) \"Hi\"),\n                \"Illegal key should raise IllegalArgument\");\n\n        assertFalse(map.containsKey(Integer.valueOf(3)));\n        assertFalse(map.containsValue(Integer.valueOf(3)));\n\n        final Map<K, V> map2 = new HashMap<>();\n        map2.put((K) \"A\", (V) \"a\");\n        map2.put((K) \"B\", (V) \"b\");\n        map2.put((K) \"C\", (V) \"c\");\n        map2.put((K) \"c\", (V) Integer.valueOf(3));\n\n        assertThrows(IllegalArgumentException.class, () -> map.putAll(map2),\n                \"Illegal value should raise IllegalArgument\");\n\n        map.put((K) \"E\", (V) \"e\");\n        Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n        Map.Entry<K, V> entry = iterator.next();\n        final Map.Entry<K, V> finalEntry = entry;\n        assertThrows(IllegalArgumentException.class, () -> finalEntry.setValue((V) Integer.valueOf(3)),\n                \"Illegal value should raise IllegalArgument\");\n\n        map.put((K) \"F\", (V) \"f\");\n        iterator = map.entrySet().iterator();\n        entry = iterator.next();\n        entry.setValue((V) \"x\");\n\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testReverseSortOrder() {\n        final SortedMap<K, V> map = makeTestMapWithComparator();\n        map.put((K) \"A\",  (V) \"a\");\n        map.put((K) \"B\", (V) \"b\");\n        assertThrows(IllegalArgumentException.class, () -> map.put(null, (V) \"c\"),\n                \"Null key should raise IllegalArgument\");\n        map.put((K) \"C\", (V) \"c\");\n        assertThrows(IllegalArgumentException.class, () -> map.put((K) \"D\", null),\n                \"Null value should raise IllegalArgument\");\n        assertEquals(\"A\", map.lastKey(), \"Last key should be A\");\n        assertEquals(\"C\", map.firstKey(), \"First key should be C\");\n        assertEquals(\"B\", map.tailMap((K) \"B\").firstKey(),\n                \"First key in tail map should be B\");\n        assertEquals(\"B\", map.headMap((K) \"A\").lastKey(),\n                \"Last key in head map should be B\");\n        assertEquals(\"B\", map.subMap((K) \"C\", (K) \"A\").lastKey(),\n                \"Last key in submap should be B\");\n\n        final Comparator<? super K> c = map.comparator();\n        assertSame(c, reverseStringComparator, \"reverse order, so comparator should be reverseStringComparator\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSortOrder() {\n        final SortedMap<K, V> map = makeTestMap();\n        map.put((K) \"A\", (V) \"a\");\n        map.put((K) \"B\", (V) \"b\");\n        assertThrows(IllegalArgumentException.class, () -> map.put(null, (V) \"c\"),\n                \"Null key should raise IllegalArgument\");\n        map.put((K) \"C\", (V) \"c\");\n        assertThrows(IllegalArgumentException.class, () -> map.put((K) \"D\", null),\n                \"Null value should raise IllegalArgument\");\n        assertEquals(\"A\", map.firstKey(), \"First key should be A\");\n        assertEquals(\"C\", map.lastKey(), \"Last key should be C\");\n        assertEquals(\"B\", map.tailMap((K) \"B\").firstKey(),\n                \"First key in tail map should be B\");\n        assertEquals(\"B\", map.headMap((K) \"C\").lastKey(),\n                \"Last key in head map should be B\");\n        assertEquals(\"B\", map.subMap((K) \"A\", (K) \"C\").lastKey(),\n                \"Last key in submap should be B\");\n\n        final Comparator<? super K> c = map.comparator();\n        assertNull(c, \"natural order, so comparator should be null\");\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/PredicatedSortedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/PredicatedSortedMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final Predicate<Object> truePredicate = TruePredicate.truePredicate();", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "Predicate<Object>", "name": "truePredicate = TruePredicate.truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected static final Predicate<Object> testPredicate = String.class::isInstance;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "Predicate<Object>", "name": "testPredicate = String.class::isInstance", "syntax_pass": true}, {"attribute_expression": "protected final Comparator<K> reverseStringComparator = new ReverseStringComparator();", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Comparator<K>", "name": "reverseStringComparator = new ReverseStringComparator()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/LRUMap_getTest.java.LRUMap_getTest", "name": "LRUMap_getTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LRUMap_getTest.java", "superclasses": "", "methods": ["[void]testGetExistingKeyWithUpdateToMRU()", "[void]testGetExistingKeyWithoutUpdateToMRU()", "[void]testGetNonExistingKey()", "[void]testGetWithEmptyMap()", "[void]testGetWithFullMapAndUpdateToMRU()", "[void]testGetWithFullMapWithoutUpdateToMRU()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/LRUMap_getTest.java.LRUMap_getTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LRUMap_getTest {\n\n    private LRUMap<String, String> lruMap;\n\n    @BeforeEach\n    public void setUp() {\n        lruMap = new LRUMap<>(2);\n    }\n\n    @Test\n    public void testGetExistingKeyWithUpdateToMRU() {\n        lruMap.put(\"key1\", \"value1\");\n        lruMap.put(\"key2\", \"value2\");\n\n        assertEquals(\"value1\", lruMap.get(\"key1\", true));\n        assertEquals(\"value2\", lruMap.get(\"key2\", true));\n\n        // Ensure \"key1\" is now the most recently used\n        lruMap.put(\"key3\", \"value3\");\n        assertNull(lruMap.get(\"key1\"));\n        assertEquals(\"value2\", lruMap.get(\"key2\"));\n        assertEquals(\"value3\", lruMap.get(\"key3\"));\n    }\n\n    @Test\n    public void testGetExistingKeyWithoutUpdateToMRU() {\n        lruMap.put(\"key1\", \"value1\");\n        lruMap.put(\"key2\", \"value2\");\n\n        assertEquals(\"value1\", lruMap.get(\"key1\", false));\n        assertEquals(\"value2\", lruMap.get(\"key2\", false));\n\n        // Ensure the order remains the same\n        lruMap.put(\"key3\", \"value3\");\n        assertNull(lruMap.get(\"key1\"));\n        assertEquals(\"value2\", lruMap.get(\"key2\"));\n        assertEquals(\"value3\", lruMap.get(\"key3\"));\n    }\n\n    @Test\n    public void testGetNonExistingKey() {\n        lruMap.put(\"key1\", \"value1\");\n        lruMap.put(\"key2\", \"value2\");\n\n        assertNull(lruMap.get(\"key3\", true));\n        assertNull(lruMap.get(\"key3\", false));\n    }\n\n    @Test\n    public void testGetWithEmptyMap() {\n        assertNull(lruMap.get(\"key1\", true));\n        assertNull(lruMap.get(\"key1\", false));\n    }\n\n    @Test\n    public void testGetWithFullMapAndUpdateToMRU() {\n        lruMap.put(\"key1\", \"value1\");\n        lruMap.put(\"key2\", \"value2\");\n\n        assertEquals(\"value1\", lruMap.get(\"key1\", true));\n        assertEquals(\"value2\", lruMap.get(\"key2\", true));\n\n        // Ensure \"key1\" is now the most recently used\n        lruMap.put(\"key3\", \"value3\");\n        assertNull(lruMap.get(\"key1\"));\n        assertEquals(\"value2\", lruMap.get(\"key2\"));\n        assertEquals(\"value3\", lruMap.get(\"key3\"));\n    }\n\n    @Test\n    public void testGetWithFullMapWithoutUpdateToMRU() {\n        lruMap.put(\"key1\", \"value1\");\n        lruMap.put(\"key2\", \"value2\");\n\n        assertEquals(\"value1\", lruMap.get(\"key1\", false));\n        assertEquals(\"value2\", lruMap.get(\"key2\", false));\n\n        // Ensure the order remains the same\n        lruMap.put(\"key3\", \"value3\");\n        assertNull(lruMap.get(\"key1\"));\n        assertEquals(\"value2\", lruMap.get(\"key2\"));\n        assertEquals(\"value3\", lruMap.get(\"key3\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private LRUMap<String, String> lruMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "LRUMap<String, String>", "name": "lruMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_putTest.java.StaticBucketMap_putTest", "name": "StaticBucketMap_putTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_putTest.java", "superclasses": "", "methods": ["[void]testPutNewKey()", "[void]testPutExistingKey()", "[void]testPutNullKey()", "[void]testPutNullValue()", "[void]testPutRemoveKey()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/StaticBucketMap_putTest.java.StaticBucketMap_putTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StaticBucketMap_putTest {\n\n    private StaticBucketMap<String, String> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new StaticBucketMap<>(17);\n    }\n\n    @Test\n    public void testPutNewKey() {\n        String key = \"key1\";\n        String value = \"value1\";\n        assertNull(map.put(key, value));\n        assertTrue(map.containsKey(key));\n        assertEquals(value, map.get(key));\n    }\n\n    @Test\n    public void testPutExistingKey() {\n        String key = \"key1\";\n        String value1 = \"value1\";\n        String value2 = \"value2\";\n        assertNull(map.put(key, value1));\n        assertEquals(value1, map.put(key, value2));\n        assertEquals(value2, map.get(key));\n    }\n\n    @Test\n    public void testPutNullKey() {\n        String value = \"value1\";\n        assertNull(map.put(null, value));\n        assertTrue(map.containsKey(null));\n        assertEquals(value, map.get(null));\n    }\n\n    @Test\n    public void testPutNullValue() {\n        String key = \"key1\";\n        assertNull(map.put(key, null));\n        assertTrue(map.containsKey(key));\n        assertNull(map.get(key));\n    }\n\n    @Test\n    public void testPutRemoveKey() {\n        String key = \"key1\";\n        String value = \"value1\";\n        assertNull(map.put(key, value));\n        assertEquals(value, map.remove(key));\n        assertFalse(map.containsKey(key));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private StaticBucketMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StaticBucketMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_containsValueTest.java.StaticBucketMap_containsValueTest", "name": "StaticBucketMap_containsValueTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_containsValueTest.java", "superclasses": "", "methods": ["[void]testContainsValue_ValuePresent()", "[void]testContainsValue_ValueNotPresent()", "[void]testContainsValue_EmptyMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/StaticBucketMap_containsValueTest.java.StaticBucketMap_containsValueTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class StaticBucketMap_containsValueTest {\n\n    private StaticBucketMap<String, String> map;\n\n    @BeforeEach\n    void setUp() {\n        map = new StaticBucketMap<>(1); // Using 1 bucket for simplicity\n    }\n\n    @Test\n    void testContainsValue_ValuePresent() {\n        // Given\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n\n        // When\n        boolean result = map.containsValue(\"value1\");\n\n        // Then\n        assertTrue(result);\n    }\n\n    @Test\n    void testContainsValue_ValueNotPresent() {\n        // Given\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n\n        // When\n        boolean result = map.containsValue(\"value3\");\n\n        // Then\n        assertFalse(result);\n    }\n\n    @Test\n    void testContainsValue_EmptyMap() {\n        // Given\n        // Map is empty\n\n        // When\n        boolean result = map.containsValue(\"value1\");\n\n        // Then\n        assertFalse(result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private StaticBucketMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StaticBucketMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/TransformedMap_transformedMapTest.java.TransformedMap_transformedMapTest", "name": "TransformedMap_transformedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/TransformedMap_transformedMapTest.java", "superclasses": "", "methods": ["[void]testTransformedMapWithNonEmptyMap()", "[void]testTransformedMapWithEmptyMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedMap_transformedMapTest {\n\n    @Test\n    public void testTransformedMapWithNonEmptyMap() {\n        // Given\n        Map<String, Integer> originalMap = new HashMap<>();\n        originalMap.put(\"key1\", 1);\n        originalMap.put(\"key2\", 2);\n\n        Transformer<String, String> keyTransformer = input -> \"transformed_\" + input;\n        Transformer<Integer, Integer> valueTransformer = input -> input * 2;\n\n        // When\n        TransformedMap<String, Integer> transformedMap = TransformedMap.transformedMap(originalMap, keyTransformer, valueTransformer);\n\n        // Then\n        assertEquals(2, transformedMap.size());\n        assertTrue(transformedMap.containsKey(\"transformed_key1\"));\n        assertTrue(transformedMap.containsKey(\"transformed_key2\"));\n        assertEquals(2, transformedMap.get(\"transformed_key1\"));\n        assertEquals(4, transformedMap.get(\"transformed_key2\"));\n    }\n\n    @Test\n    public void testTransformedMapWithEmptyMap() {\n        // Given\n        Map<String, Integer> originalMap = new HashMap<>();\n\n        Transformer<String, String> keyTransformer = input -> \"transformed_\" + input;\n        Transformer<Integer, Integer> valueTransformer = input -> input * 2;\n\n        // When\n        TransformedMap<String, Integer> transformedMap = TransformedMap.transformedMap(originalMap, keyTransformer, valueTransformer);\n\n        // Then\n        assertTrue(transformedMap.isEmpty());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_getTest.java.StaticBucketMap_getTest", "name": "StaticBucketMap_getTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_getTest.java", "superclasses": "", "methods": ["[void]testGetExistingKey()", "[void]testGetNonExistingKey()", "[void]testGetNullKey()", "[void]testGetAfterRemove()", "[void]testGetWithMultipleEntries()", "[void]testGetWithSameHashDifferentKey()", "[void]testGetWithCollision()", "[void]testGetWithNullValue()", "[void]testGetWithNullKeyAndNullValue()", "[void]testGetWithEmptyMap()", "[void]testGetWithConcurrentModification()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/StaticBucketMap_getTest.java.StaticBucketMap_getTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StaticBucketMap_getTest {\n\n    private StaticBucketMap<String, String> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new StaticBucketMap<>(17);\n    }\n\n    @Test\n    public void testGetExistingKey() {\n        map.put(\"key1\", \"value1\");\n        assertEquals(\"value1\", map.get(\"key1\"));\n    }\n\n    @Test\n    public void testGetNonExistingKey() {\n        assertNull(map.get(\"key2\"));\n    }\n\n    @Test\n    public void testGetNullKey() {\n        map.put(null, \"nullValue\");\n        assertEquals(\"nullValue\", map.get(null));\n    }\n\n    @Test\n    public void testGetAfterRemove() {\n        map.put(\"key3\", \"value3\");\n        map.remove(\"key3\");\n        assertNull(map.get(\"key3\"));\n    }\n\n    @Test\n    public void testGetWithMultipleEntries() {\n        map.put(\"key4\", \"value4\");\n        map.put(\"key5\", \"value5\");\n        assertEquals(\"value4\", map.get(\"key4\"));\n        assertEquals(\"value5\", map.get(\"key5\"));\n    }\n\n    @Test\n    public void testGetWithSameHashDifferentKey() {\n        // Assuming \"A\" and \"B\" hash to the same bucket\n        map.put(\"A\", \"valueA\");\n        map.put(\"B\", \"valueB\");\n        assertEquals(\"valueA\", map.get(\"A\"));\n        assertEquals(\"valueB\", map.get(\"B\"));\n    }\n\n    @Test\n    public void testGetWithCollision() {\n        // Assuming \"C\" and \"D\" hash to the same bucket\n        map.put(\"C\", \"valueC\");\n        map.put(\"D\", \"valueD\");\n        assertEquals(\"valueC\", map.get(\"C\"));\n        assertEquals(\"valueD\", map.get(\"D\"));\n    }\n\n    @Test\n    public void testGetWithNullValue() {\n        map.put(\"key6\", null);\n        assertNull(map.get(\"key6\"));\n    }\n\n    @Test\n    public void testGetWithNullKeyAndNullValue() {\n        map.put(null, null);\n        assertNull(map.get(null));\n    }\n\n    @Test\n    public void testGetWithEmptyMap() {\n        assertNull(map.get(\"nonExistentKey\"));\n    }\n\n    @Test\n    public void testGetWithConcurrentModification() {\n        map.put(\"key7\", \"value7\");\n        map.put(\"key8\", \"value8\");\n        map.remove(\"key7\");\n        assertNull(map.get(\"key7\"));\n        assertEquals(\"value8\", map.get(\"key8\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private StaticBucketMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StaticBucketMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/Flat3MapTest.java.Flat3MapTest", "name": "Flat3MapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/Flat3MapTest.java", "superclasses": "", "methods": ["[void]testClone2()", "[void]testClone4()", "[void]testCollections261()", "[void]testContainsKey1()", "[void]testContainsKey2()", "[void]testContainsKey3()", "[void]testContainsValue1()", "[void]testContainsValue2()", "[void]testContainsValue3()", "[void]testEntryIteratorSetValue1()", "[void]testEntryIteratorSetValue2()", "[void]testEntryIteratorSetValue3()", "[void]testEntrySet()", "[void]testEquals1()", "[void]testEquals2()", "[void]testGet1()", "[void]testGet2()", "[void]testGet3()", "[void]testMapIteratorSetValue1()", "[void]testMapIteratorSetValue2()", "[void]testMapIteratorSetValue3()", "[void]testNewInstance1()", "[void]testPut1()", "[void]testPut2()", "[void]testPut3()", "[void]testPut4()", "[void]testPut5()", "[void]testPut6()", "[void]testRemove1()", "[void]testRemove10()", "[void]testRemove11()", "[void]testRemove12()", "[void]testRemove13()", "[void]testRemove2()", "[void]testRemove3()", "[void]testRemove4()", "[void]testRemove5()", "[void]testRemove6()", "[void]testRemove7()", "[void]testRemove8()", "[void]testRemove9()", "[void]testSerialisation0()", "[void]testSerialisation2()", "[void]testSerialisation4()", "[void]testToString()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/Flat3MapTest.java.Flat3MapTest.[]Flat3MapTest()", "src/test/java/org/apache/commons/collections4/map/Flat3MapTest.java.Flat3MapTest.[BulkTest]bulkTestMapIterator()", "src/test/java/org/apache/commons/collections4/map/Flat3MapTest.java.Flat3MapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/Flat3MapTest.java.Flat3MapTest.[Flat3Map<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/map/Flat3MapTest.java.Flat3MapTest.[void]putAndRemove(Map<K, V>)"], "overrides": null, "attributes": [{"original_string": "    public class TestFlatMapIterator extends AbstractMapIteratorTest<K, V> {\n        public TestFlatMapIterator() {\n            super(\"TestFlatMapIterator\");\n        }\n\n        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }\n\n        @Override\n        public IterableMap<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return Flat3MapTest.this.getMap();\n        }\n\n        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return Flat3MapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return Flat3MapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            Flat3MapTest.this.verify();\n        }\n    }", "definition": "    public class TestFlatMapIterator extends AbstractMapIteratorTest<K, V>", "class_docstring": "", "name": "TestFlatMapIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestFlatMapIterator() {\n            super(\"TestFlatMapIterator\");\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestFlatMapIterator", "params": [], "body": "                                     {\n            super(\"TestFlatMapIterator\");\n        }", "signature": "public TestFlatMapIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "addSetValues", "params": [], "body": "                                  {\n            return getNewSampleValues();\n        }", "signature": "@Override\n        public V[] addSetValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "getConfirmedMap", "params": [], "body": "                                           {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }", "signature": "@Override\n        public Map<K, V> getConfirmedMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public IterableMap<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return Flat3MapTest.this.getMap();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "IterableMap<K, V>", "classes": []}, "name": "getMap", "params": [], "body": "                                          {\n            // assumes makeFullMapIterator() called first\n            return Flat3MapTest.this.getMap();\n        }", "signature": "@Override\n        public IterableMap<K, V> getMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return Flat3MapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MapIterator<K, V>", "classes": []}, "name": "makeEmptyIterator", "params": [], "body": "                                                     {\n            resetEmpty();\n            return Flat3MapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public MapIterator<K, V> makeEmptyIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return Flat3MapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MapIterator<K, V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                              {\n            resetFull();\n            return Flat3MapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public MapIterator<K, V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsRemove", "params": [], "body": "                                        {\n            return isRemoveSupported();\n        }", "signature": "@Override\n        public boolean supportsRemove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsSetValue", "params": [], "body": "                                          {\n            return isSetValueSupported();\n        }", "signature": "@Override\n        public boolean supportsSetValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n            Flat3MapTest.this.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n            Flat3MapTest.this.verify();\n        }", "signature": "@Override\n        public void verify()"}]}], "class_docstring": "\nJUnit tests.\n", "original_string": "public class Flat3MapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    public class TestFlatMapIterator extends AbstractMapIteratorTest<K, V> {\n        public TestFlatMapIterator() {\n            super(\"TestFlatMapIterator\");\n        }\n\n        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }\n\n        @Override\n        public IterableMap<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return Flat3MapTest.this.getMap();\n        }\n\n        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return Flat3MapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return Flat3MapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            Flat3MapTest.this.verify();\n        }\n    }\n    private static final Integer ONE = Integer.valueOf(1);\n    private static final Integer TWO = Integer.valueOf(2);\n    private static final Integer THREE = Integer.valueOf(3);\n    private static final String TEN = \"10\";\n    private static final String TWENTY = \"20\";\n\n    private static final String THIRTY = \"30\";\n\n    public Flat3MapTest() {\n        super(Flat3MapTest.class.getSimpleName());\n    }\n\n    @Override\n    public BulkTest bulkTestMapIterator() {\n        return new TestFlatMapIterator();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Flat3Map<K, V> makeObject() {\n        return new Flat3Map<>();\n    }\n\n    private void putAndRemove(final Map<K, V> map) {\n        map.put((K) \"A\", (V) \"one\");\n        map.put((K) \"B\", (V) \"two\");\n        map.put((K) \"C\", (V) \"three\");\n        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n\n        final Map.Entry<K, V> mapEntry1 = it.next();\n        final Map.Entry<K, V> mapEntry2 = it.next();\n        final Map.Entry<K, V> mapEntry3 = it.next();\n        it.remove();\n        assertEquals(2, map.size());\n        assertEquals(\"one\", map.get(\"A\"));\n        assertEquals(\"two\", map.get(\"B\"));\n        assertNull(map.get(\"C\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testClone2() {\n        final Flat3Map<K, V> map = makeObject();\n        assertEquals(0, map.size());\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n        assertEquals(2, map.size());\n        assertTrue(map.containsKey(ONE));\n        assertTrue(map.containsKey(TWO));\n        assertSame(TEN, map.get(ONE));\n        assertSame(TWENTY, map.get(TWO));\n\n        // clone works (size = 2)\n        final Flat3Map<K, V> cloned = map.clone();\n        assertEquals(2, cloned.size());\n        assertTrue(cloned.containsKey(ONE));\n        assertTrue(cloned.containsKey(TWO));\n        assertSame(TEN, cloned.get(ONE));\n        assertSame(TWENTY, cloned.get(TWO));\n\n        // change original doesn't change clone\n        map.put((K) TEN, (V) ONE);\n        map.put((K) TWENTY, (V) TWO);\n        assertEquals(4, map.size());\n        assertEquals(2, cloned.size());\n        assertTrue(cloned.containsKey(ONE));\n        assertTrue(cloned.containsKey(TWO));\n        assertSame(TEN, cloned.get(ONE));\n        assertSame(TWENTY, cloned.get(TWO));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testClone4() {\n        final Flat3Map<K, V> map = makeObject();\n        assertEquals(0, map.size());\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n        map.put((K) TEN, (V) ONE);\n        map.put((K) TWENTY, (V) TWO);\n\n        // clone works (size = 4)\n        final Flat3Map<K, V> cloned = map.clone();\n        assertEquals(4, map.size());\n        assertEquals(4, cloned.size());\n        assertTrue(cloned.containsKey(ONE));\n        assertTrue(cloned.containsKey(TWO));\n        assertTrue(cloned.containsKey(TEN));\n        assertTrue(cloned.containsKey(TWENTY));\n        assertSame(TEN, cloned.get(ONE));\n        assertSame(TWENTY, cloned.get(TWO));\n        assertSame(ONE, cloned.get(TEN));\n        assertSame(TWO, cloned.get(TWENTY));\n\n        // change original doesn't change clone\n        map.clear();\n        assertEquals(0, map.size());\n        assertEquals(4, cloned.size());\n        assertTrue(cloned.containsKey(ONE));\n        assertTrue(cloned.containsKey(TWO));\n        assertTrue(cloned.containsKey(TEN));\n        assertTrue(cloned.containsKey(TWENTY));\n        assertSame(TEN, cloned.get(ONE));\n        assertSame(TWENTY, cloned.get(TWO));\n        assertSame(ONE, cloned.get(TEN));\n        assertSame(TWO, cloned.get(TWENTY));\n    }\n\n    @Test\n    public void testCollections261() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        m.put( Integer.valueOf(1), Integer.valueOf(1) );\n        m.put( Integer.valueOf(0), Integer.valueOf(0) );\n        assertEquals( Integer.valueOf(1), m.remove( Integer.valueOf(1) ) );\n        assertEquals( Integer.valueOf(0), m.remove( Integer.valueOf(0) ) );\n\n        m.put( Integer.valueOf(2), Integer.valueOf(2) );\n        m.put( Integer.valueOf(1), Integer.valueOf(1) );\n        m.put( Integer.valueOf(0), Integer.valueOf(0) );\n        assertEquals( Integer.valueOf(2), m.remove( Integer.valueOf(2) ) );\n        assertEquals( Integer.valueOf(1), m.remove( Integer.valueOf(1) ) );\n        assertEquals( Integer.valueOf(0), m.remove( Integer.valueOf(0) ) );\n    }\n\n    @Test\n    public void testContainsKey1() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(null, THREE);\n        final boolean contains = m.containsKey(null);\n        assertTrue(contains);\n    }\n\n    @Test\n    public void testContainsKey2() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, ONE);\n        m.put(null, TWO);\n        final boolean contains = m.containsKey(null);\n        assertTrue(contains);\n    }\n\n    @Test\n    public void testContainsKey3() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(null, ONE);\n        final boolean contains = m.containsKey(null);\n        assertTrue(contains);\n    }\n\n    @Test\n    public void testContainsValue1() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(THREE, null);\n        final boolean contains = m.containsValue(null);\n        assertTrue(contains);\n    }\n\n    @Test\n    public void testContainsValue2() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, ONE);\n        m.put(TWO, null);\n        final boolean contains = m.containsValue(null);\n        assertTrue(contains);\n    }\n\n    @Test\n    public void testContainsValue3() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, null);\n        final boolean contains = m.containsValue(null);\n        assertTrue(contains);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEntryIteratorSetValue1() throws Exception {\n        final Flat3Map<K, V> map = makeObject();\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n        map.put((K) THREE, (V) THIRTY);\n\n        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n        final Map.Entry<K, V> entry = it.next();\n        entry.setValue((V) \"NewValue\");\n        assertEquals(3, map.size());\n        assertTrue(map.containsKey(ONE));\n        assertTrue(map.containsKey(TWO));\n        assertTrue(map.containsKey(THREE));\n        assertEquals(\"NewValue\", map.get(ONE));\n        assertEquals(TWENTY, map.get(TWO));\n        assertEquals(THIRTY, map.get(THREE));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEntryIteratorSetValue2() throws Exception {\n        final Flat3Map<K, V> map = makeObject();\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n        map.put((K) THREE, (V) THIRTY);\n\n        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n        it.next();\n        final Map.Entry<K, V> entry = it.next();\n        entry.setValue((V) \"NewValue\");\n        assertEquals(3, map.size());\n        assertTrue(map.containsKey(ONE));\n        assertTrue(map.containsKey(TWO));\n        assertTrue(map.containsKey(THREE));\n        assertEquals(TEN, map.get(ONE));\n        assertEquals(\"NewValue\", map.get(TWO));\n        assertEquals(THIRTY, map.get(THREE));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEntryIteratorSetValue3() throws Exception {\n        final Flat3Map<K, V> map = makeObject();\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n        map.put((K) THREE, (V) THIRTY);\n\n        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n        it.next();\n        it.next();\n        final Map.Entry<K, V> entry = it.next();\n        entry.setValue((V) \"NewValue\");\n        assertEquals(3, map.size());\n        assertTrue(map.containsKey(ONE));\n        assertTrue(map.containsKey(TWO));\n        assertTrue(map.containsKey(THREE));\n        assertEquals(TEN, map.get(ONE));\n        assertEquals(TWENTY, map.get(TWO));\n        assertEquals(\"NewValue\", map.get(THREE));\n    }\n\n    @Test\n    public void testEntrySet() {\n        // Sanity check\n        putAndRemove(new LinkedHashMap<>());\n        // Actual test\n        putAndRemove(new Flat3Map<>());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEquals1() {\n        final Flat3Map<K, V> map1 = makeObject();\n        map1.put((K) \"a\", (V) \"testA\");\n        map1.put((K) \"b\", (V) \"testB\");\n        final Flat3Map<K, V> map2 = makeObject();\n        map2.put((K) \"a\", (V) \"testB\");\n        map2.put((K) \"b\", (V) \"testA\");\n        assertFalse(map1.equals(map2));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/Flat3Map.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/Flat3Map.fullCollection.version4.obj\");\n//    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEquals2() {\n        final Flat3Map<K, V> map1 = makeObject();\n        map1.put((K) \"a\", (V) \"testA\");\n        map1.put((K) \"b\", (V) \"testB\");\n        final Flat3Map<K, V> map2 = makeObject();\n        map2.put((K) \"a\", (V) \"testB\");\n        map2.put((K) \"c\", (V) \"testA\");\n        assertFalse(map1.equals(map2));\n    }\n\n    @Test\n    public void testGet1() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        final Object obj;\n\n        m.put(null, ONE);\n        obj = m.get(null);\n        assertSame(ONE, obj);\n    }\n\n    @Test\n    public void testGet2() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        final Object obj;\n\n        m.put(ONE, ONE);\n        m.put(null, TWO);\n        obj = m.get(null);\n        assertSame(TWO, obj);\n    }\n\n    @Test\n    public void testGet3() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        final Object obj;\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(null, THREE);\n        obj = m.get(null);\n        assertSame(THREE, obj);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMapIteratorSetValue1() throws Exception {\n        final Flat3Map<K, V> map = makeObject();\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n        map.put((K) THREE, (V) THIRTY);\n\n        final MapIterator<K, V> it = map.mapIterator();\n        it.next();\n        it.setValue((V) \"NewValue\");\n        assertEquals(3, map.size());\n        assertTrue(map.containsKey(ONE));\n        assertTrue(map.containsKey(TWO));\n        assertTrue(map.containsKey(THREE));\n        assertEquals(\"NewValue\", map.get(ONE));\n        assertEquals(TWENTY, map.get(TWO));\n        assertEquals(THIRTY, map.get(THREE));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMapIteratorSetValue2() throws Exception {\n        final Flat3Map<K, V> map = makeObject();\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n        map.put((K) THREE, (V) THIRTY);\n\n        final MapIterator<K, V> it = map.mapIterator();\n        it.next();\n        it.next();\n        it.setValue((V) \"NewValue\");\n        assertEquals(3, map.size());\n        assertTrue(map.containsKey(ONE));\n        assertTrue(map.containsKey(TWO));\n        assertTrue(map.containsKey(THREE));\n        assertEquals(TEN, map.get(ONE));\n        assertEquals(\"NewValue\", map.get(TWO));\n        assertEquals(THIRTY, map.get(THREE));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMapIteratorSetValue3() throws Exception {\n        final Flat3Map<K, V> map = makeObject();\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n        map.put((K) THREE, (V) THIRTY);\n\n        final MapIterator<K, V> it = map.mapIterator();\n        it.next();\n        it.next();\n        it.next();\n        it.setValue((V) \"NewValue\");\n        assertEquals(3, map.size());\n        assertTrue(map.containsKey(ONE));\n        assertTrue(map.containsKey(TWO));\n        assertTrue(map.containsKey(THREE));\n        assertEquals(TEN, map.get(ONE));\n        assertEquals(TWENTY, map.get(TWO));\n        assertEquals(\"NewValue\", map.get(THREE));\n    }\n\n    @Test\n    public void testNewInstance1() {\n        final Map<Integer, Integer> orig = new HashMap<>();\n        orig.put(ONE, ONE);\n        orig.put(TWO, TWO);\n\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>(orig);\n\n        assertEquals(orig, m);\n        assertEquals(2, m.size());\n    }\n\n    @Test\n    public void testPut1() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(null, THREE);\n        final Object old = m.put(null, ONE);\n        assertEquals(THREE, old);\n        assertEquals(ONE, m.get(null));\n    }\n\n    @Test\n    public void testPut2() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, ONE);\n        m.put(null, THREE);\n        final Object old = m.put(null, ONE);\n        assertEquals(THREE, old);\n        assertEquals(ONE, m.get(null));\n    }\n\n    @Test\n    public void testPut3() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(null, THREE);\n        final Object old = m.put(null, ONE);\n        assertEquals(THREE, old);\n        assertNull(m.get(ONE));\n    }\n\n    @Test\n    public void testPut4() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(THREE, THREE);\n        final Object old = m.put(THREE, ONE);\n        assertEquals(THREE, old);\n        assertEquals(ONE, m.get(THREE));\n    }\n\n    @Test\n    public void testPut5() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, ONE);\n        m.put(TWO, THREE);\n        final Object old = m.put(TWO, ONE);\n        assertEquals(THREE, old);\n        assertEquals(ONE, m.get(TWO));\n    }\n\n    @Test\n    public void testPut6() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        m.put(ONE, THREE);\n        final Object old = m.put(ONE, ONE);\n        assertEquals(THREE, old);\n        assertEquals(ONE, m.get(ONE));\n    }\n\n    @Test\n    public void testRemove1() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n\n        // object is not existing\n        Object obj = m.remove(44);\n        assertNull(obj);\n\n        m.put(ONE, ONE);\n        obj = m.remove(ONE);\n        assertSame(ONE, obj);\n        assertEquals(0, m.size());\n\n        // after removal, be no longer there\n        obj = m.get(ONE);\n        assertNull(obj);\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(THREE, THREE);\n\n        obj = m.remove(ONE);\n        assertSame(ONE, obj);\n\n        obj = m.get(ONE);\n        assertNull(obj);\n        obj = m.get(TWO);\n        assertSame(TWO, obj);\n    }\n\n    @Test\n    public void testRemove10() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        final Object obj;\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n\n        obj = m.remove(null);\n        assertNull(obj);\n    }\n\n    @Test\n    public void testRemove11() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        final Object obj;\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(THREE, THREE);\n\n        obj = m.remove(null);\n        assertNull(obj);\n    }\n\n    @Test\n    public void testRemove12() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        final Object obj;\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(THREE, THREE);\n\n        obj = m.remove(42);\n        assertNull(obj);\n    }\n\n    @Test\n    public void testRemove13() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        final Object obj;\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n\n        obj = m.remove(42);\n        assertNull(obj);\n    }\n\n    @Test\n    public void testRemove2() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        Object obj;\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(THREE, THREE);\n\n        obj = m.remove(ONE);\n        assertSame(ONE, obj);\n\n        obj = m.get(ONE);\n        assertNull(obj);\n        obj = m.get(TWO);\n        assertSame(TWO, obj);\n        obj = m.get(THREE);\n        assertSame(THREE, obj);\n    }\n\n    @Test\n    public void testRemove3() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        Object obj;\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(THREE, THREE);\n\n        obj = m.remove(TWO);\n        assertSame(TWO, obj);\n\n        obj = m.get(ONE);\n        assertSame(ONE, obj);\n        obj = m.get(TWO);\n        assertNull(obj);\n        obj = m.get(THREE);\n        assertSame(THREE, obj);\n    }\n\n    @Test\n    public void testRemove4() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        Object obj;\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(THREE, THREE);\n\n        obj = m.remove(THREE);\n        assertSame(THREE, obj);\n\n        obj = m.get(ONE);\n        assertSame(ONE, obj);\n        obj = m.get(TWO);\n        assertSame(TWO, obj);\n        obj = m.get(THREE);\n        assertNull(obj);\n    }\n\n    @Test\n    public void testRemove5() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        Object obj;\n\n        m.put(null, ONE);\n\n        obj = m.remove(null);\n        assertSame(ONE, obj);\n\n        obj = m.get(null);\n        assertNull(obj);\n    }\n\n    @Test\n    public void testRemove6() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        Object obj;\n\n        m.put(ONE, ONE);\n        m.put(null, TWO);\n\n        obj = m.remove(null);\n        assertSame(TWO, obj);\n\n        obj = m.get(ONE);\n        assertSame(ONE, obj);\n        obj = m.get(null);\n        assertNull(obj);\n    }\n\n    @Test\n    public void testRemove7() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        Object obj;\n\n        m.put(null, ONE);\n        m.put(TWO, TWO);\n\n        obj = m.remove(null);\n        assertSame(ONE, obj);\n\n        obj = m.get(null);\n        assertNull(obj);\n        obj = m.get(TWO);\n        assertSame(TWO, obj);\n    }\n\n    @Test\n    public void testRemove8() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        Object obj;\n\n        m.put(ONE, ONE);\n        m.put(TWO, TWO);\n        m.put(null, THREE);\n\n        obj = m.remove(null);\n        assertSame(THREE, obj);\n\n        obj = m.get(ONE);\n        assertSame(ONE, obj);\n        obj = m.get(TWO);\n        assertSame(TWO, obj);\n        obj = m.get(null);\n        assertNull(obj);\n    }\n\n    @Test\n    public void testRemove9() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        final Object obj;\n\n        m.put(ONE, ONE);\n\n        obj = m.remove(null);\n        assertNull(obj);\n    }\n\n    @Test\n    public void testSerialisation0() throws Exception {\n        final Flat3Map<K, V> map = makeObject();\n        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(bout);\n        out.writeObject(map);\n        final byte[] bytes = bout.toByteArray();\n        out.close();\n        final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n        final ObjectInputStream in = new ObjectInputStream(bin);\n        final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n        in.close();\n        assertEquals(0, map.size());\n        assertEquals(0, ser.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSerialisation2() throws Exception {\n        final Flat3Map<K, V> map = makeObject();\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n\n        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(bout);\n        out.writeObject(map);\n        final byte[] bytes = bout.toByteArray();\n        out.close();\n        final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n        final ObjectInputStream in = new ObjectInputStream(bin);\n        final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n        in.close();\n        assertEquals(2, map.size());\n        assertEquals(2, ser.size());\n        assertTrue(ser.containsKey(ONE));\n        assertTrue(ser.containsKey(TWO));\n        assertEquals(TEN, ser.get(ONE));\n        assertEquals(TWENTY, ser.get(TWO));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSerialisation4() throws Exception {\n        final Flat3Map<K, V> map = makeObject();\n        map.put((K) ONE, (V) TEN);\n        map.put((K) TWO, (V) TWENTY);\n        map.put((K) TEN, (V) ONE);\n        map.put((K) TWENTY, (V) TWO);\n\n        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(bout);\n        out.writeObject(map);\n        final byte[] bytes = bout.toByteArray();\n        out.close();\n        final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n        final ObjectInputStream in = new ObjectInputStream(bin);\n        final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n        in.close();\n        assertEquals(4, map.size());\n        assertEquals(4, ser.size());\n        assertTrue(ser.containsKey(ONE));\n        assertTrue(ser.containsKey(TWO));\n        assertTrue(ser.containsKey(TEN));\n        assertTrue(ser.containsKey(TWENTY));\n        assertEquals(TEN, ser.get(ONE));\n        assertEquals(TWENTY, ser.get(TWO));\n        assertEquals(ONE, ser.get(TEN));\n        assertEquals(TWO, ser.get(TWENTY));\n    }\n\n    @Test\n    public void testToString() {\n        final Flat3Map<Integer, Integer> m = new Flat3Map<>();\n        final String string0 = m.toString();\n        assertNotNull(string0);\n        m.put( Integer.valueOf(1), Integer.valueOf(1) );\n        final String string1 = m.toString();\n        assertNotNull(string1);\n        assertNotSame(string0, string1);\n        m.put( Integer.valueOf(0), Integer.valueOf(0) );\n        final String string2 = m.toString();\n        assertNotNull(string2);\n        assertNotSame(string0, string2);\n        assertNotSame(string1, string2);\n        m.put( Integer.valueOf(2), Integer.valueOf(2) );\n        final String string3 = m.toString();\n        assertNotNull(string3);\n        assertNotSame(string0, string3);\n        assertNotSame(string1, string3);\n        assertNotSame(string2, string3);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Integer ONE = Integer.valueOf(1);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "ONE = Integer.valueOf(1)", "syntax_pass": true}, {"attribute_expression": "private static final Integer TWO = Integer.valueOf(2);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "TWO = Integer.valueOf(2)", "syntax_pass": true}, {"attribute_expression": "private static final Integer THREE = Integer.valueOf(3);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "THREE = Integer.valueOf(3)", "syntax_pass": true}, {"attribute_expression": "private static final String TEN = \"10\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "TEN = \"10\"", "syntax_pass": true}, {"attribute_expression": "private static final String TWENTY = \"20\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "TWENTY = \"20\"", "syntax_pass": true}, {"attribute_expression": "private static final String THIRTY = \"30\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "THIRTY = \"30\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap_entrySetTest.java.UnmodifiableOrderedMap_entrySetTest", "name": "UnmodifiableOrderedMap_entrySetTest", "file_path": "src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap_entrySetTest.java", "superclasses": "", "methods": ["[void]testEntrySet()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnmodifiableOrderedMap_entrySetTest {\n\n    @Test\n    public void testEntrySet() {\n        // Given\n        Map<String, String> originalMap = new HashMap<>();\n        originalMap.put(\"key1\", \"value1\");\n        originalMap.put(\"key2\", \"value2\");\n        OrderedMap<String, String> orderedMap = UnmodifiableOrderedMap.unmodifiableOrderedMap(new LinkedMap<>(originalMap));\n\n        // When\n        Set<Map.Entry<String, String>> entrySet = orderedMap.entrySet();\n\n        // Then\n        assertEquals(2, entrySet.size());\n        assertTrue(entrySet.containsAll(originalMap.entrySet()));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_hashCodeTest.java.CompositeMap_hashCodeTest", "name": "CompositeMap_hashCodeTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_hashCodeTest.java", "superclasses": "", "methods": ["[void]testHashCodeWithEmptyMap()", "[void]testHashCodeWithNonEmptyMap()", "[void]testHashCodeAfterAddingMap()", "[void]testHashCodeAfterRemovingMap()", "[void]testHashCodeAfterModifyingMap()", "[void]testHashCodeConsistency()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_hashCodeTest.java.CompositeMap_hashCodeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_hashCodeTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> map1;\n    private Map<String, String> map2;\n\n    @BeforeEach\n    public void setUp() {\n        map1 = new HashMap<>();\n        map1.put(\"key1\", \"value1\");\n        map1.put(\"key2\", \"value2\");\n\n        map2 = new HashMap<>();\n        map2.put(\"key3\", \"value3\");\n        map2.put(\"key4\", \"value4\");\n\n        compositeMap = new CompositeMap<>(map1, map2);\n    }\n\n    @Test\n    public void testHashCodeWithEmptyMap() {\n        CompositeMap<String, String> emptyMap = new CompositeMap<>();\n        assertEquals(0, emptyMap.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNonEmptyMap() {\n        int expectedHashCode = map1.hashCode() + map2.hashCode();\n        assertEquals(expectedHashCode, compositeMap.hashCode());\n    }\n\n    @Test\n    public void testHashCodeAfterAddingMap() {\n        Map<String, String> map3 = new HashMap<>();\n        map3.put(\"key5\", \"value5\");\n        compositeMap.addComposited(map3);\n\n        int expectedHashCode = map1.hashCode() + map2.hashCode() + map3.hashCode();\n        assertEquals(expectedHashCode, compositeMap.hashCode());\n    }\n\n    @Test\n    public void testHashCodeAfterRemovingMap() {\n        compositeMap.removeComposited(map2);\n        int expectedHashCode = map1.hashCode();\n        assertEquals(expectedHashCode, compositeMap.hashCode());\n    }\n\n    @Test\n    public void testHashCodeAfterModifyingMap() {\n        map1.put(\"key6\", \"value6\");\n        int expectedHashCode = map1.hashCode() + map2.hashCode();\n        assertEquals(expectedHashCode, compositeMap.hashCode());\n    }\n\n    @Test\n    public void testHashCodeConsistency() {\n        int initialHashCode = compositeMap.hashCode();\n        map1.put(\"key7\", \"value7\");\n        int modifiedHashCode = compositeMap.hashCode();\n        assertNotEquals(initialHashCode, modifiedHashCode);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map1", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_sizeTest.java.CompositeMap_sizeTest", "name": "CompositeMap_sizeTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_sizeTest.java", "superclasses": "", "methods": ["[void]testSizeWithInitialMaps()", "[void]testSizeAfterAddingMap()", "[void]testSizeAfterRemovingMap()", "[void]testSizeAfterAddingKeyValue()", "[void]testSizeAfterRemovingKeyValue()", "[void]testSizeAfterClearingMaps()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_sizeTest.java.CompositeMap_sizeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_sizeTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> mapOne;\n    private Map<String, String> mapTwo;\n\n    @BeforeEach\n    public void setUp() {\n        mapOne = new HashMap<>();\n        mapOne.put(\"1\", \"one\");\n        mapOne.put(\"2\", \"two\");\n\n        mapTwo = new HashMap<>();\n        mapTwo.put(\"3\", \"three\");\n        mapTwo.put(\"4\", \"four\");\n\n        compositeMap = new CompositeMap<>(mapOne, mapTwo, null);\n    }\n\n    @Test\n    public void testSizeWithInitialMaps() {\n        assertEquals(4, compositeMap.size());\n    }\n\n    @Test\n    public void testSizeAfterAddingMap() {\n        Map<String, String> mapThree = new HashMap<>();\n        mapThree.put(\"5\", \"five\");\n        mapThree.put(\"6\", \"six\");\n\n        compositeMap.addComposited(mapThree);\n        assertEquals(6, compositeMap.size());\n    }\n\n    @Test\n    public void testSizeAfterRemovingMap() {\n        compositeMap.removeComposited(mapTwo);\n        assertEquals(2, compositeMap.size());\n    }\n\n    @Test\n    public void testSizeAfterAddingKeyValue() {\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"5\", \"five\");\n        compositeMap.addComposited(newMap);\n        assertEquals(5, compositeMap.size());\n    }\n\n    @Test\n    public void testSizeAfterRemovingKeyValue() {\n        compositeMap.remove(\"3\");\n        assertEquals(3, compositeMap.size());\n    }\n\n    @Test\n    public void testSizeAfterClearingMaps() {\n        compositeMap.clear();\n        assertEquals(0, compositeMap.size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapOne;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapOne", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapTwo;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapTwo", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/PredicatedMapTest.java.PredicatedMapTest", "name": "PredicatedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PredicatedMapTest.java", "superclasses": "", "methods": ["[void]testEntrySet()", "[void]testPut()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/PredicatedMapTest.java.PredicatedMapTest.[]PredicatedMapTest()", "src/test/java/org/apache/commons/collections4/map/PredicatedMapTest.java.PredicatedMapTest.[IterableMap<K, V>]decorateMap(Map<K, V>,Predicate<? super K>,Predicate<? super V>)", "src/test/java/org/apache/commons/collections4/map/PredicatedMapTest.java.PredicatedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/PredicatedMapTest.java.PredicatedMapTest.[IterableMap<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/map/PredicatedMapTest.java.PredicatedMapTest.[IterableMap<K, V>]makeTestMap()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMapTest} for exercising the\n{@link PredicatedMap} implementation.\n", "original_string": "public class PredicatedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    protected static final Predicate<Object> truePredicate = TruePredicate.<Object>truePredicate();\n\n    protected static final Predicate<Object> testPredicate = String.class::isInstance;\n\n    public PredicatedMapTest() {\n        super(PredicatedMapTest.class.getSimpleName());\n    }\n\n    protected IterableMap<K, V> decorateMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,\n        final Predicate<? super V> valuePredicate) {\n        return PredicatedMap.predicatedMap(map, keyPredicate, valuePredicate);\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public IterableMap<K, V> makeObject() {\n        return decorateMap(new HashMap<>(), truePredicate, truePredicate);\n    }\n\n    public IterableMap<K, V> makeTestMap() {\n        return decorateMap(new HashMap<>(), testPredicate, testPredicate);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEntrySet() {\n        Map<K, V> map = makeTestMap();\n        assertNotNull(map.entrySet(), \"returned entryset should not be null\");\n        map = decorateMap(new HashMap<>(), null, null);\n        map.put((K) \"oneKey\", (V) \"oneValue\");\n        assertEquals(1, map.entrySet().size(), \"returned entryset should contain one entry\");\n        map = decorateMap(map, null, null);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPut() {\n        final Map<K, V> map = makeTestMap();\n        assertThrows(IllegalArgumentException.class, () -> map.put((K) \"Hi\", (V) Integer.valueOf(3)),\n                \"Illegal value should raise IllegalArgument\");\n\n        assertThrows(IllegalArgumentException.class, () -> map.put((K) Integer.valueOf(3), (V) \"Hi\"),\n                \"Illegal key should raise IllegalArgument\");\n\n        assertFalse(map.containsKey(Integer.valueOf(3)));\n        assertFalse(map.containsValue(Integer.valueOf(3)));\n\n        final Map<K, V> map2 = new HashMap<>();\n        map2.put((K) \"A\", (V) \"a\");\n        map2.put((K) \"B\", (V) \"b\");\n        map2.put((K) \"C\", (V) \"c\");\n        map2.put((K) \"c\", (V) Integer.valueOf(3));\n\n        assertThrows(IllegalArgumentException.class, () -> map.putAll(map2),\n                \"Illegal value should raise IllegalArgument\");\n\n        map.put((K) \"E\", (V) \"e\");\n        Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n        Map.Entry<K, V> entry = iterator.next();\n        final Map.Entry<K, V> finalEntry = entry;\n        assertThrows(IllegalArgumentException.class, () -> finalEntry.setValue((V) Integer.valueOf(3)),\n                \"Illegal value should raise IllegalArgument\");\n\n        map.put((K) \"F\", (V) \"f\");\n        iterator = map.entrySet().iterator();\n        entry = iterator.next();\n        entry.setValue((V) \"x\");\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/PredicatedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/PredicatedMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final Predicate<Object> truePredicate = TruePredicate.<Object>truePredicate();", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "Predicate<Object>", "name": "truePredicate = TruePredicate.<Object>truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected static final Predicate<Object> testPredicate = String.class::isInstance;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "Predicate<Object>", "name": "testPredicate = String.class::isInstance", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java.MultiValueMapTest", "name": "MultiValueMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java", "superclasses": "AbstractObjectTest", "methods": ["[void]testContainsValue()", "[void]testContainsValue_Key()", "[void]testEmptyMapCompatibility()", "[void]testFullMapCompatibility()", "[void]testGetCollection()", "[void]testIterator()", "[void]testIterator_Key()", "[void]testKeyContainsValue()", "[void]testKeyedIterator()", "[void]testMapEquals()", "[void]testMultipleValues()", "[void]testNoMappingReturnsNull()", "[void]testPutAll_KeyCollection()", "[void]testPutAll_Map1()", "[void]testPutAll_Map2()", "[void]testPutWithList()", "[void]testPutWithSet()", "[void]testRemove_KeyItem()", "[void]testRemoveAllViaEntryIterator()", "[void]testRemoveAllViaIterator()", "[void]testRemoveAllViaKeyedIterator()", "[void]testSize()", "[void]testSize_Key()", "[void]testTotalSize()", "[void]testTotalSizeA()", "[void]testUnsafeDeSerialization()", "[void]testValueCollectionType()", "[void]testValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java.MultiValueMapTest.[]MultiValueMapTest()", "src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java.MultiValueMapTest.[MultiValueMap<K, V>]createTestMap()", "src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java.MultiValueMapTest.[MultiValueMap<K, V>]createTestMap(Class<C>)", "src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java.MultiValueMapTest.[Object]deserialize(byte[])", "src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java.MultiValueMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java.MultiValueMapTest.[Map]makeEmptyMap()", "src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java.MultiValueMapTest.[Object]makeObject()", "src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java.MultiValueMapTest.[byte[]]serialize(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nTestMultiValueMap.\n", "original_string": "@Deprecated\npublic class MultiValueMapTest<K, V> extends AbstractObjectTest {\n\n    public MultiValueMapTest() {\n        super(MultiValueMapTest.class.getSimpleName());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private MultiValueMap<K, V> createTestMap() {\n        return createTestMap(ArrayList.class);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(final Class<C> collectionClass) {\n        final MultiValueMap<K, V> map = MultiValueMap.multiValueMap(new HashMap<>(), collectionClass);\n        map.put((K) \"one\", (V) \"uno\");\n        map.put((K) \"one\", (V) \"un\");\n        map.put((K) \"two\", (V) \"dos\");\n        map.put((K) \"two\", (V) \"deux\");\n        map.put((K) \"three\", (V) \"tres\");\n        map.put((K) \"three\", (V) \"trois\");\n        return map;\n    }\n\n    private Object deserialize(final byte[] data) throws IOException, ClassNotFoundException {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(data);\n        final ObjectInputStream iis = new ObjectInputStream(bais);\n\n        return iis.readObject();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    private Map makeEmptyMap() {\n        return new MultiValueMap();\n    }\n\n    @Override\n    public Object makeObject() {\n        @SuppressWarnings(\"unchecked\")\n        final Map<String, String> m = makeEmptyMap();\n        m.put(\"a\", \"1\");\n        m.put(\"a\", \"1b\");\n        m.put(\"b\", \"2\");\n        m.put(\"c\", \"3\");\n        m.put(\"c\", \"3b\");\n        m.put(\"d\", \"4\");\n        return m;\n    }\n\n    private byte[] serialize(final Object object) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(baos);\n\n        oos.writeObject(object);\n        oos.close();\n\n        return baos.toByteArray();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testContainsValue() {\n        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n        assertTrue(map.containsValue(\"uno\"));\n        assertTrue(map.containsValue(\"un\"));\n        assertTrue(map.containsValue(\"dos\"));\n        assertTrue(map.containsValue(\"deux\"));\n        assertTrue(map.containsValue(\"tres\"));\n        assertTrue(map.containsValue(\"trois\"));\n        assertFalse(map.containsValue(\"quatro\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testContainsValue_Key() {\n        final MultiValueMap<K, V> map = new MultiValueMap<>();\n        assertFalse(map.containsValue(\"A\", \"AA\"));\n        assertFalse(map.containsValue(\"B\", \"BB\"));\n        map.put((K) \"A\", \"AA\");\n        assertTrue(map.containsValue(\"A\", \"AA\"));\n        assertFalse(map.containsValue(\"A\", \"AB\"));\n    }\n\n    @Test\n    public void testEmptyMapCompatibility() throws Exception {\n        final Map<?, ?> map = makeEmptyMap();\n        final Map<?, ?> map2 = (Map<?, ?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n        assertEquals(0, map2.size(), \"Map is empty\");\n    }\n\n    @Test\n    public void testFullMapCompatibility() throws Exception {\n        final Map<?, ?> map = (Map<?, ?>) makeObject();\n        final Map<?, ?> map2 = (Map<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n        assertEquals(map.size(), map2.size(), \"Map is the right size\");\n        for (final Object key : map.keySet()) {\n            assertEquals(map.get(key), map2.get(key), \"Map had unequal elements\");\n            map2.remove(key);\n        }\n        assertEquals(0, map2.size(), \"Map had extra values\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testGetCollection() {\n        final MultiValueMap<K, V> map = new MultiValueMap<>();\n        map.put((K) \"A\", \"AA\");\n        assertSame(map.get(\"A\"), map.getCollection(\"A\"));\n    }\n\n    @Test\n    public void testIterator() {\n        final MultiValueMap<K, V> map = createTestMap();\n        @SuppressWarnings(\"unchecked\")\n        final Collection<V> values = new ArrayList<>((Collection<V>) map.values());\n        final Iterator<Map.Entry<K, V>> iterator = map.iterator();\n        while (iterator.hasNext()) {\n            final Map.Entry<K, V> entry = iterator.next();\n            assertTrue(map.containsValue(entry.getKey(), entry.getValue()));\n            assertTrue(values.contains(entry.getValue()));\n            assertTrue(values.remove(entry.getValue()));\n        }\n        assertTrue(values.isEmpty());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIterator_Key() {\n        final MultiValueMap<K, V> map = new MultiValueMap<>();\n        assertFalse(map.iterator(\"A\").hasNext());\n        map.put((K) \"A\", \"AA\");\n        final Iterator<?> it = map.iterator(\"A\");\n        assertTrue(it.hasNext());\n        it.next();\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testKeyContainsValue() {\n        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n        assertTrue(map.containsValue(\"one\", \"uno\"));\n        assertTrue(map.containsValue(\"one\", \"un\"));\n        assertTrue(map.containsValue(\"two\", \"dos\"));\n        assertTrue(map.containsValue(\"two\", \"deux\"));\n        assertTrue(map.containsValue(\"three\", \"tres\"));\n        assertTrue(map.containsValue(\"three\", \"trois\"));\n        assertFalse(map.containsValue(\"four\", \"quatro\"));\n    }\n\n    @Test\n    public void testKeyedIterator() {\n        final MultiValueMap<K, V> map = createTestMap();\n        final ArrayList<Object> actual = new ArrayList<>(IteratorUtils.toList(map.iterator(\"one\")));\n        final ArrayList<Object> expected = new ArrayList<>(Arrays.asList(\"uno\", \"un\"));\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMapEquals() {\n        final MultiValueMap<K, V> one = new MultiValueMap<>();\n        final Integer value = Integer.valueOf(1);\n        one.put((K) \"One\", value);\n        one.removeMapping(\"One\", value);\n\n        final MultiValueMap<K, V> two = new MultiValueMap<>();\n        assertEquals(two, one);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultipleValues() {\n        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n        final HashSet<V> expected = new HashSet<>();\n        expected.add((V) \"uno\");\n        expected.add((V) \"un\");\n        assertEquals(expected, map.get(\"one\"));\n    }\n\n    @Test\n    public void testNoMappingReturnsNull() {\n        final MultiValueMap<K, V> map = createTestMap();\n        assertNull(map.get(\"whatever\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPutAll_KeyCollection() {\n        final MultiValueMap<K, V> map = new MultiValueMap<>();\n        Collection<V> coll = (Collection<V>) Arrays.asList(\"X\", \"Y\", \"Z\");\n\n        assertTrue(map.putAll((K) \"A\", coll));\n        assertEquals(3, map.size(\"A\"));\n        assertTrue(map.containsValue(\"A\", \"X\"));\n        assertTrue(map.containsValue(\"A\", \"Y\"));\n        assertTrue(map.containsValue(\"A\", \"Z\"));\n\n        assertFalse(map.putAll((K) \"A\", null));\n        assertEquals(3, map.size(\"A\"));\n        assertTrue(map.containsValue(\"A\", \"X\"));\n        assertTrue(map.containsValue(\"A\", \"Y\"));\n        assertTrue(map.containsValue(\"A\", \"Z\"));\n\n        assertFalse(map.putAll((K) \"A\", new ArrayList<>()));\n        assertEquals(3, map.size(\"A\"));\n        assertTrue(map.containsValue(\"A\", \"X\"));\n        assertTrue(map.containsValue(\"A\", \"Y\"));\n        assertTrue(map.containsValue(\"A\", \"Z\"));\n\n        coll = (Collection<V>) Arrays.asList(\"M\");\n        assertTrue(map.putAll((K) \"A\", coll));\n        assertEquals(4, map.size(\"A\"));\n        assertTrue(map.containsValue(\"A\", \"X\"));\n        assertTrue(map.containsValue(\"A\", \"Y\"));\n        assertTrue(map.containsValue(\"A\", \"Z\"));\n        assertTrue(map.containsValue(\"A\", \"M\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPutAll_Map1() {\n        final MultiMap<K, V> original = new MultiValueMap<>();\n        original.put((K) \"key\", \"object1\");\n        original.put((K) \"key\", \"object2\");\n\n        final MultiValueMap<K, V> test = new MultiValueMap<>();\n        test.put((K) \"keyA\", \"objectA\");\n        test.put((K) \"key\", \"object0\");\n        test.putAll(original);\n\n        assertEquals(2, test.size());\n        assertEquals(4, test.totalSize());\n        assertEquals(1, test.getCollection(\"keyA\").size());\n        assertEquals(3, test.getCollection(\"key\").size());\n        assertTrue(test.containsValue(\"objectA\"));\n        assertTrue(test.containsValue(\"object0\"));\n        assertTrue(test.containsValue(\"object1\"));\n        assertTrue(test.containsValue(\"object2\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPutAll_Map2() {\n        final Map<K, V> original = new HashMap<>();\n        original.put((K) \"keyX\", (V) \"object1\");\n        original.put((K) \"keyY\", (V) \"object2\");\n\n        final MultiValueMap<K, V> test = new MultiValueMap<>();\n        test.put((K) \"keyA\", \"objectA\");\n        test.put((K) \"keyX\", \"object0\");\n        test.putAll(original);\n\n        assertEquals(3, test.size());\n        assertEquals(4, test.totalSize());\n        assertEquals(1, test.getCollection(\"keyA\").size());\n        assertEquals(2, test.getCollection(\"keyX\").size());\n        assertEquals(1, test.getCollection(\"keyY\").size());\n        assertTrue(test.containsValue(\"objectA\"));\n        assertTrue(test.containsValue(\"object0\"));\n        assertTrue(test.containsValue(\"object1\"));\n        assertTrue(test.containsValue(\"object2\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPutWithList() {\n        @SuppressWarnings(\"rawtypes\")\n        final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<>(), ArrayList.class);\n        assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n        assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n        assertEquals(1, test.size());\n        assertEquals(2, test.size(\"A\"));\n        assertEquals(2, test.totalSize());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPutWithSet() {\n        @SuppressWarnings(\"rawtypes\")\n        final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<>(), HashSet.class);\n        assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n        assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n        assertNull(test.put((K) \"A\", \"a\"));\n        assertEquals(1, test.size());\n        assertEquals(2, test.size(\"A\"));\n        assertEquals(2, test.totalSize());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemove_KeyItem() {\n        final MultiValueMap<K, V> map = new MultiValueMap<>();\n        map.put((K) \"A\", \"AA\");\n        map.put((K) \"A\", \"AB\");\n        map.put((K) \"A\", \"AC\");\n        assertFalse(map.removeMapping(\"C\", \"CA\"));\n        assertFalse(map.removeMapping(\"A\", \"AD\"));\n        assertTrue(map.removeMapping(\"A\", \"AC\"));\n        assertTrue(map.removeMapping(\"A\", \"AB\"));\n        assertTrue(map.removeMapping(\"A\", \"AA\"));\n        assertEquals(new MultiValueMap<>(), map);\n    }\n\n    @Test\n    public void testRemoveAllViaEntryIterator() {\n        final MultiValueMap<K, V> map = createTestMap();\n        for (final Iterator<?> i = map.iterator(); i.hasNext();) {\n            i.next();\n            i.remove();\n        }\n        assertNull(map.get(\"one\"));\n        assertEquals(0, map.totalSize());\n    }\n\n    @Test\n    public void testRemoveAllViaIterator() {\n        final MultiValueMap<K, V> map = createTestMap();\n        for (final Iterator<?> i = map.values().iterator(); i.hasNext();) {\n            i.next();\n            i.remove();\n        }\n        assertNull(map.get(\"one\"));\n        assertTrue(map.isEmpty());\n    }\n\n    @Test\n    public void testRemoveAllViaKeyedIterator() {\n        final MultiValueMap<K, V> map = createTestMap();\n        for (final Iterator<?> i = map.iterator(\"one\"); i.hasNext();) {\n            i.next();\n            i.remove();\n        }\n        assertNull(map.get(\"one\"));\n        assertEquals(4, map.totalSize());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSize() {\n        final MultiValueMap<K, V> map = new MultiValueMap<>();\n        assertEquals(0, map.size());\n        map.put((K) \"A\", \"AA\");\n        assertEquals(1, map.size());\n        map.put((K) \"B\", \"BA\");\n        assertEquals(2, map.size());\n        map.put((K) \"B\", \"BB\");\n        assertEquals(2, map.size());\n        map.put((K) \"B\", \"BC\");\n        assertEquals(2, map.size());\n        map.remove(\"A\");\n        assertEquals(1, map.size());\n        map.removeMapping(\"B\", \"BC\");\n        assertEquals(1, map.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSize_Key() {\n        final MultiValueMap<K, V> map = new MultiValueMap<>();\n        assertEquals(0, map.size(\"A\"));\n        assertEquals(0, map.size(\"B\"));\n        map.put((K) \"A\", \"AA\");\n        assertEquals(1, map.size(\"A\"));\n        assertEquals(0, map.size(\"B\"));\n        map.put((K) \"B\", \"BA\");\n        assertEquals(1, map.size(\"A\"));\n        assertEquals(1, map.size(\"B\"));\n        map.put((K) \"B\", \"BB\");\n        assertEquals(1, map.size(\"A\"));\n        assertEquals(2, map.size(\"B\"));\n        map.put((K) \"B\", \"BC\");\n        assertEquals(1, map.size(\"A\"));\n        assertEquals(3, map.size(\"B\"));\n        map.remove(\"A\");\n        assertEquals(0, map.size(\"A\"));\n        assertEquals(3, map.size(\"B\"));\n        map.removeMapping(\"B\", \"BC\");\n        assertEquals(0, map.size(\"A\"));\n        assertEquals(2, map.size(\"B\"));\n    }\n\n    // Manual serialization testing as this class cannot easily\n    // extend the AbstractTestMap\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testTotalSize() {\n        final MultiValueMap<K, V> map = new MultiValueMap<>();\n        assertEquals(0, map.totalSize());\n        map.put((K) \"A\", \"AA\");\n        assertEquals(1, map.totalSize());\n        map.put((K) \"B\", \"BA\");\n        assertEquals(2, map.totalSize());\n        map.put((K) \"B\", \"BB\");\n        assertEquals(3, map.totalSize());\n        map.put((K) \"B\", \"BC\");\n        assertEquals(4, map.totalSize());\n        map.remove(\"A\");\n        assertEquals(3, map.totalSize());\n        map.removeMapping(\"B\", \"BC\");\n        assertEquals(2, map.totalSize());\n    }\n\n    @Test\n    public void testTotalSizeA() {\n        assertEquals(6, createTestMap().totalSize());\n    }\n\n    @Test\n    public void testUnsafeDeSerialization() throws Exception {\n        final MultiValueMap map1 = MultiValueMap.multiValueMap(new HashMap(), ArrayList.class);\n        byte[] bytes = serialize(map1);\n        final Object result = deserialize(bytes);\n        assertEquals(map1, result);\n\n        final MultiValueMap map2 = MultiValueMap.multiValueMap(new HashMap(), (Class) String.class);\n        bytes = serialize(map2);\n\n        final byte[] finalBytes = bytes;\n        assertThrows(UnsupportedOperationException.class, () -> deserialize(finalBytes));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testValueCollectionType() {\n        final MultiValueMap<K, V> map = createTestMap(LinkedList.class);\n        assertTrue(map.get(\"one\") instanceof LinkedList);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testValues() {\n        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n        final HashSet<V> expected = new HashSet<>();\n        expected.add((V) \"uno\");\n        expected.add((V) \"dos\");\n        expected.add((V) \"tres\");\n        expected.add((V) \"un\");\n        expected.add((V) \"deux\");\n        expected.add((V) \"trois\");\n        final Collection<Object> c = map.values();\n        assertEquals(6, c.size());\n        assertEquals(expected, new HashSet<>(c));\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) makeEmptyMap(),\n//            \"src/test/resources/data/test/MultiValueMap.emptyCollection.version4.obj\");\n//\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) makeObject(),\n//            \"src/test/resources/data/test/MultiValueMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_tailMapTest.java.TransformedSortedMap_tailMapTest", "name": "TransformedSortedMap_tailMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_tailMapTest.java", "superclasses": "", "methods": ["[void]testTailMap()", "[void]testTailMapWithNonExistentKey()", "[void]testTailMapWithNullKey()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_tailMapTest.java.TransformedSortedMap_tailMapTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedSortedMap_tailMapTest {\n\n    private SortedMap<String, String> baseMap;\n    private Transformer<String, String> keyTransformer;\n    private Transformer<String, String> valueTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        baseMap = new TreeMap<>();\n        baseMap.put(\"A\", \"1\");\n        baseMap.put(\"B\", \"2\");\n        baseMap.put(\"C\", \"3\");\n\n        keyTransformer = TransformerUtils.nopTransformer();\n        valueTransformer = TransformerUtils.nopTransformer();\n    }\n\n    @Test\n    public void testTailMap() {\n        SortedMap<String, String> transformedMap = TransformedSortedMap.transformingSortedMap(baseMap, keyTransformer, valueTransformer);\n        SortedMap<String, String> tailMap = transformedMap.tailMap(\"B\");\n\n        assertEquals(2, tailMap.size());\n        assertEquals(\"2\", tailMap.get(\"B\"));\n        assertEquals(\"3\", tailMap.get(\"C\"));\n    }\n\n    @Test\n    public void testTailMapWithNonExistentKey() {\n        SortedMap<String, String> transformedMap = TransformedSortedMap.transformingSortedMap(baseMap, keyTransformer, valueTransformer);\n        SortedMap<String, String> tailMap = transformedMap.tailMap(\"D\");\n\n        assertEquals(0, tailMap.size());\n    }\n\n    @Test\n    public void testTailMapWithNullKey() {\n        SortedMap<String, String> transformedMap = TransformedSortedMap.transformingSortedMap(baseMap, keyTransformer, valueTransformer);\n        assertThrows(NullPointerException.class, () -> {\n            transformedMap.tailMap(null);\n        });\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private SortedMap<String, String> baseMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SortedMap<String, String>", "name": "baseMap", "syntax_pass": true}, {"attribute_expression": "private Transformer<String, String> keyTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, String>", "name": "keyTransformer", "syntax_pass": true}, {"attribute_expression": "private Transformer<String, String> valueTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, String>", "name": "valueTransformer", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_clearTest.java.StaticBucketMap_clearTest", "name": "StaticBucketMap_clearTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_clearTest.java", "superclasses": "", "methods": ["[void]testClear()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class StaticBucketMap_clearTest {\n\n    @Test\n    void testClear() {\n        // Given\n        StaticBucketMap<Integer, String> map = new StaticBucketMap<>(1);\n        map.put(1, \"one\");\n        map.put(2, \"two\");\n\n        // When\n        map.clear();\n\n        // Then\n        assertEquals(0, map.size());\n        assertNull(map.get(1));\n        assertNull(map.get(2));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/DefaultedMap_getTest.java.DefaultedMap_getTest", "name": "DefaultedMap_getTest", "file_path": "src/test/java/org/apache/commons/collections4/map/DefaultedMap_getTest.java", "superclasses": "", "methods": ["[void]testGet_KeyExistsInMap()", "[void]testGet_KeyNotInMapButExistsInMapAsNull()", "[void]testGet_KeyNotInMapAndTransformerReturnsValue()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DefaultedMap_getTest {\n\n    @Test\n    public void testGet_KeyExistsInMap() {\n        // Given\n        Map<String, String> map = new HashMap<>();\n        map.put(\"key1\", \"value1\");\n        DefaultedMap<String, String> defaultedMap = new DefaultedMap<>(map, mock(Transformer.class));\n\n        // When\n        String result = defaultedMap.get(\"key1\");\n\n        // Then\n        assertEquals(\"value1\", result);\n    }\n\n    @Test\n    public void testGet_KeyNotInMapButExistsInMapAsNull() {\n        // Given\n        Map<String, String> map = new HashMap<>();\n        map.put(\"key1\", null);\n        DefaultedMap<String, String> defaultedMap = new DefaultedMap<>(map, mock(Transformer.class));\n\n        // When\n        String result = defaultedMap.get(\"key1\");\n\n        // Then\n        assertEquals(null, result);\n    }\n\n    @Test\n    public void testGet_KeyNotInMapAndTransformerReturnsValue() {\n        // Given\n        Map<String, String> map = new HashMap<>();\n        Transformer<String, String> transformer = mock(Transformer.class);\n        when(transformer.apply(\"key1\")).thenReturn(\"default\");\n        DefaultedMap<String, String> defaultedMap = new DefaultedMap<>(map, transformer);\n\n        // When\n        String result = defaultedMap.get(\"key1\");\n\n        // Then\n        assertEquals(\"default\", result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java.CompositeMapTest", "name": "CompositeMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java", "superclasses": "", "methods": ["[void]testAddComposited()", "[void]testGet()", "[void]testPut()", "[void]testPutAll()", "[void]testRemoveComposited()", "[void]testRemoveFromComposited()", "[void]testRemoveFromUnderlying()", "[void]testResolveCollision()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java.CompositeMapTest.[]CompositeMapTest()", "src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java.CompositeMapTest.[Map<K, V>]buildOne()", "src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java.CompositeMapTest.[Map<K, V>]buildTwo()", "src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java.CompositeMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java.CompositeMapTest.[CompositeMap<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java.CompositeMapTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMapTest} for exercising the\n{@link CompositeMap} implementation.\n", "original_string": "public class CompositeMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    /** Used as a flag in MapMutator tests */\n    private boolean pass;\n\n    public CompositeMapTest() {\n        super(CompositeMapTest.class.getSimpleName());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Map<K, V> buildOne() {\n        final HashMap<K, V> map = new HashMap<>();\n        map.put((K) \"1\", (V) \"one\");\n        map.put((K) \"2\", (V) \"two\");\n        return map;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Map<K, V> buildTwo() {\n        final HashMap<K, V> map = new HashMap<>();\n        map.put((K) \"3\", (V) \"three\");\n        map.put((K) \"4\", (V) \"four\");\n        return map;\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public CompositeMap<K, V> makeObject() {\n        final CompositeMap<K, V> map = new CompositeMap<>();\n        map.addComposited(new HashMap<>());\n        map.setMutator( new EmptyMapMutator<>() );\n        return map;\n    }\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        pass = false;\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddComposited() {\n        final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());\n        final HashMap<K, V> three = new HashMap<>();\n        three.put((K) \"5\", (V) \"five\");\n        map.addComposited(null);\n        map.addComposited(three);\n        assertTrue(map.containsKey(\"5\"));\n\n        assertThrows(IllegalArgumentException.class, () -> map.addComposited(three));\n    }\n\n    @Test\n    public void testGet() {\n        final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());\n        assertEquals(\"one\", map.get(\"1\"));\n        assertEquals(\"four\", map.get(\"4\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPut() {\n        final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo(),\n            new CompositeMap.MapMutator<K, V>() {\n                private static final long serialVersionUID = 1L;\n                @Override\n                public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,\n                    final V value) {\n                    pass = true;\n                    return (V) \"foo\";\n                }\n\n                @Override\n                public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public void resolveCollision(final CompositeMap<K, V> composite,\n                    final Map<K, V> existing,\n                    final Map<K, V> added,\n                    final Collection<K> intersect) {\n                    throw new UnsupportedOperationException();\n                }\n            });\n\n        map.put((K) \"willy\", (V) \"wonka\");\n        assertTrue(pass);\n    }\n\n    @Test\n    public void testPutAll() {\n        final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo(),\n            new CompositeMap.MapMutator<K, V>() {\n                private static final long serialVersionUID = 1L;\n                @Override\n                public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,\n                    final V value) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n                    pass = true;\n                }\n\n                @Override\n                public void resolveCollision(final CompositeMap<K, V> composite,\n                    final Map<K, V> existing,\n                    final Map<K, V> added,\n                    final Collection<K> intersect) {\n                    throw new UnsupportedOperationException();\n                }\n            });\n\n        map.putAll(null);\n        assertTrue(pass);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveComposited() {\n        final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());\n        final HashMap<K, V> three = new HashMap<>();\n        three.put((K) \"5\", (V) \"five\");\n        map.addComposited(null);\n        map.addComposited(three);\n        assertTrue(map.containsKey(\"5\"));\n\n        map.removeComposited(three);\n        assertFalse(map.containsKey(\"5\"));\n\n        map.removeComposited(buildOne());\n        assertFalse(map.containsKey(\"2\"));\n\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveFromComposited() {\n        final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());\n        final HashMap<K, V> three = new HashMap<>();\n        three.put((K) \"5\", (V) \"five\");\n        map.addComposited(null);\n        map.addComposited(three);\n        assertTrue(map.containsKey(\"5\"));\n\n        //Now remove \"5\"\n        map.remove(\"5\");\n        assertFalse(three.containsKey(\"5\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveFromUnderlying() {\n        final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo());\n        final HashMap<K, V> three = new HashMap<>();\n        three.put((K) \"5\", (V) \"five\");\n        map.addComposited(null);\n        map.addComposited(three);\n        assertTrue(map.containsKey(\"5\"));\n\n        //Now remove \"5\"\n        three.remove(\"5\");\n        assertFalse(map.containsKey(\"5\"));\n    }\n\n    @Test\n    public void testResolveCollision() {\n        final CompositeMap<K, V> map = new CompositeMap<>(buildOne(), buildTwo(),\n            new CompositeMap.MapMutator<K, V>() {\n                private static final long serialVersionUID = 1L;\n\n                @Override\n                public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,\n                    final V value) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n                    throw new UnsupportedOperationException();\n                }\n\n                @Override\n                public void resolveCollision(final CompositeMap<K, V> composite,\n                    final Map<K, V> existing,\n                    final Map<K, V> added,\n                    final Collection<K> intersect) {\n                    pass = true;\n                }\n            });\n\n        map.addComposited(buildOne());\n        assertTrue(pass);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/CompositeMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/CompositeMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private boolean pass;", "docstring": " Used as a flag in MapMutator tests", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "pass", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_removeAllTest.java.MultiKeyMap_removeAllTest", "name": "MultiKeyMap_removeAllTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_removeAllTest.java", "superclasses": "", "methods": ["[void]testRemoveAllWithExistingKey()", "[void]testRemoveAllWithNonExistingKey()", "[void]testRemoveAllWithNullKey()", "[void]testRemoveAllWithEmptyMap()", "[void]testRemoveAllWithMultipleKeys()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiKeyMap_removeAllTest.java.MultiKeyMap_removeAllTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiKeyMap_removeAllTest {\n\n    private static final Integer I1 = 1;\n    private static final Integer I2 = 2;\n    private static final Integer I3 = 3;\n    private static final Integer I4 = 4;\n    private static final Integer I5 = 5;\n\n    private MultiKeyMap<Integer, String> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new MultiKeyMap<>();\n    }\n\n    @Test\n    public void testRemoveAllWithExistingKey() {\n        map.put(I1, I2, \"1-2\");\n        map.put(I1, I3, \"1-3\");\n        map.put(I2, I3, \"2-3\");\n\n        assertTrue(map.removeAll(I1));\n        assertEquals(1, map.size());\n        assertFalse(map.containsKey(I1, I2));\n        assertFalse(map.containsKey(I1, I3));\n        assertTrue(map.containsKey(I2, I3));\n    }\n\n    @Test\n    public void testRemoveAllWithNonExistingKey() {\n        map.put(I1, I2, \"1-2\");\n        map.put(I1, I3, \"1-3\");\n\n        assertFalse(map.removeAll(I4));\n        assertEquals(2, map.size());\n        assertTrue(map.containsKey(I1, I2));\n        assertTrue(map.containsKey(I1, I3));\n    }\n\n    @Test\n    public void testRemoveAllWithNullKey() {\n        map.put(null, I2, \"null-2\");\n        map.put(I1, I3, \"1-3\");\n\n        assertTrue(map.removeAll(null));\n        assertEquals(1, map.size());\n        assertFalse(map.containsKey(null, I2));\n        assertTrue(map.containsKey(I1, I3));\n    }\n\n    @Test\n    public void testRemoveAllWithEmptyMap() {\n        assertFalse(map.removeAll(I1));\n        assertEquals(0, map.size());\n    }\n\n    @Test\n    public void testRemoveAllWithMultipleKeys() {\n        map.put(I1, I2, \"1-2\");\n        map.put(I1, I3, \"1-3\");\n        map.put(I2, I3, \"2-3\");\n        map.put(I2, I4, \"2-4\");\n\n        assertTrue(map.removeAll(I1));\n        assertEquals(2, map.size());\n        assertFalse(map.containsKey(I1, I2));\n        assertFalse(map.containsKey(I1, I3));\n        assertTrue(map.containsKey(I2, I3));\n        assertTrue(map.containsKey(I2, I4));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Integer I1 = 1;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "I1 = 1", "syntax_pass": true}, {"attribute_expression": "private static final Integer I2 = 2;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "I2 = 2", "syntax_pass": true}, {"attribute_expression": "private static final Integer I3 = 3;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "I3 = 3", "syntax_pass": true}, {"attribute_expression": "private static final Integer I4 = 4;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "I4 = 4", "syntax_pass": true}, {"attribute_expression": "private static final Integer I5 = 5;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "I5 = 5", "syntax_pass": true}, {"attribute_expression": "private MultiKeyMap<Integer, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MultiKeyMap<Integer, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest", "name": "SingletonMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java", "superclasses": "", "methods": ["[void]testBoundedMap()", "[void]testClone()", "[void]testKeyValue()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[]SingletonMapTest()", "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[V[]]getNewSampleValues()", "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[K[]]getSampleKeys()", "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[V[]]getSampleValues()", "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[SingletonMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java.SingletonMapTest.[OrderedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class SingletonMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n\n    private static final Integer ONE = Integer.valueOf(1);\n    private static final Integer TWO = Integer.valueOf(2);\n    private static final String TEN = \"10\";\n\n    public SingletonMapTest() {\n        super(SingletonMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public V[] getNewSampleValues() {\n        return (V[]) new Object[] { TEN };\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public K[] getSampleKeys() {\n        return (K[]) new Object[] { ONE };\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public V[] getSampleValues() {\n        return (V[]) new Object[] { TWO };\n    }\n\n    @Override\n    public String[] ignoredTests() {\n        // the ridiculous map above still doesn't pass these tests\n        // but it's not relevant, so we ignore them\n        return new String[] {\n            \"SingletonMapTest.bulkTestMapIterator.testEmptyMapIterator\",\n            \"SingletonMapTest.bulkTestOrderedMapIterator.testEmptyMapIterator\",\n        };\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SingletonMap<K, V> makeFullMap() {\n        return new SingletonMap<>((K) ONE, (V) TWO);\n    }\n\n    @Override\n    public OrderedMap<K, V> makeObject() {\n        // need an empty singleton map, but that's not possible\n        // use a ridiculous fake instead to make the tests pass\n        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<>()));\n    }\n\n    @Test\n    public void testBoundedMap() {\n        final SingletonMap<K, V> map = makeFullMap();\n        assertEquals(1, map.size());\n        assertTrue(map.isFull());\n        assertEquals(1, map.maxSize());\n        assertInstanceOf(BoundedMap.class, map);\n    }\n\n    @Test\n    public void testClone() {\n        final SingletonMap<K, V> map = makeFullMap();\n        assertEquals(1, map.size());\n        final SingletonMap<K, V> cloned = map.clone();\n        assertEquals(1, cloned.size());\n        assertTrue(cloned.containsKey(ONE));\n        assertTrue(cloned.containsValue(TWO));\n    }\n\n//    public BulkTest bulkTestMapIterator() {\n//        return new TestFlatMapIterator();\n//    }\n//\n//    public class TestFlatMapIterator extends AbstractTestOrderedMapIterator {\n//        public TestFlatMapIterator() {\n//            super(\"TestFlatMapIterator\");\n//        }\n//\n//        public Object[] addSetValues() {\n//            return TestSingletonMap.this.getNewSampleValues();\n//        }\n//\n//        public boolean supportsRemove() {\n//            return TestSingletonMap.this.isRemoveSupported();\n//        }\n//\n//        public boolean supportsSetValue() {\n//            return TestSingletonMap.this.isSetValueSupported();\n//        }\n//\n//        public MapIterator makeEmptyMapIterator() {\n//            resetEmpty();\n//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n//        }\n//\n//        public MapIterator makeFullMapIterator() {\n//            resetFull();\n//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n//        }\n//\n//        public Map getMap() {\n//            // assumes makeFullMapIterator() called first\n//            return TestSingletonMap.this.map;\n//        }\n//\n//        public Map getConfirmedMap() {\n//            // assumes makeFullMapIterator() called first\n//            return TestSingletonMap.this.confirmed;\n//        }\n//\n//        public void verify() {\n//            super.verify();\n//            TestSingletonMap.this.verify();\n//        }\n//    }\n\n    @Test\n    public void testKeyValue() {\n        final SingletonMap<K, V> map = makeFullMap();\n        assertEquals(1, map.size());\n        assertEquals(ONE, map.getKey());\n        assertEquals(TWO, map.getValue());\n        assertInstanceOf(KeyValue.class, map);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/SingletonMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/SingletonMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Integer ONE = Integer.valueOf(1);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "ONE = Integer.valueOf(1)", "syntax_pass": true}, {"attribute_expression": "private static final Integer TWO = Integer.valueOf(2);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "TWO = Integer.valueOf(2)", "syntax_pass": true}, {"attribute_expression": "private static final String TEN = \"10\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "TEN = \"10\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java.ReferenceIdentityMapTest", "name": "ReferenceIdentityMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java", "superclasses": "", "methods": ["[void]testBasics()", "[void]testHashEntry()", "[void]testNullHandling()", "[void]testPurgeValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java.ReferenceIdentityMapTest.[void]gc()", "src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java.ReferenceIdentityMapTest.[]ReferenceIdentityMapTest()", "src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java.ReferenceIdentityMapTest.[Map<K, V>]buildRefMap()", "src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java.ReferenceIdentityMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java.ReferenceIdentityMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java.ReferenceIdentityMapTest.[boolean]isAllowNullValue()", "src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java.ReferenceIdentityMapTest.[Map<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java.ReferenceIdentityMapTest.[ReferenceIdentityMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for ReferenceIdentityMap.\n", "original_string": "public class ReferenceIdentityMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    private static final Integer I1A = new Integer(1); // Cannot use valueOf here\n    private static final Integer I1B = new Integer(1);\n    private static final Integer I2A = new Integer(2);\n    private static final Integer I2B = new Integer(2);\n\n    @SuppressWarnings(\"unused\")\n    private static void gc() {\n        try {\n            // trigger GC\n            final byte[][] tooLarge = new byte[1000000000][1000000000];\n            fail(\"you have too much RAM\");\n        } catch (final OutOfMemoryError ex) {\n            System.gc(); // ignore\n        }\n    }\n\n    WeakReference<K> keyReference;\n\n    WeakReference<V> valueReference;\n\n    public ReferenceIdentityMapTest() {\n        super(ReferenceIdentityMapTest.class.getSimpleName());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private Map<K, V> buildRefMap() {\n        final K key = (K) new Object();\n        final V value = (V) new Object();\n\n        keyReference = new WeakReference<>(key);\n        valueReference = new WeakReference<>(value);\n\n        final Map<K, V> testMap = new ReferenceIdentityMap<>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n        testMap.put(key, value);\n\n        assertEquals(value, testMap.get(key), \"In map\");\n        assertNotNull(keyReference.get(), \"Weak reference released early (1)\");\n        assertNotNull(valueReference.get(), \"Weak reference released early (2)\");\n        return testMap;\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/ReferenceIdentityMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/ReferenceIdentityMap.fullCollection.version4.obj\");\n//    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public boolean isAllowNullValue() {\n        return false;\n    }\n\n    @Override\n    public Map<K, V> makeConfirmedMap() {\n        // Testing against another [collections] class generally isn't a good idea,\n        // but the closest alternative is IdentityHashMap, which propagates reference-equality down to keySet and values.\n        // arguably ReferenceIdentityMap should do the same but that's a later discussion.\n        return new IdentityMap<>();\n    }\n\n/*\n    // Tests often fail because gc is uncontrollable\n\n    @Test\n    public void testPurge() {\n        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n        Object[] hard = new Object[10];\n        for (int i = 0; i < hard.length; i++) {\n            hard[i] = new Object();\n            map.put(hard[i], new Object());\n        }\n        gc();\n        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n\n        for (int i = 0; i < hard.length; i++) {\n            map.put(new Object(), hard[i]);\n        }\n        gc();\n        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n\n        for (int i = 0; i < hard.length; i++) {\n            map.put(new Object(), hard[i]);\n            map.put(hard[i], new Object());\n        }\n\n        gc();\n        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n    }\n\n    @Test\n    public void testGetAfterGC() {\n        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n        for (int i = 0; i < 10; i++) {\n            map.put(Integer.valueOf(i), Integer.valueOf(i));\n        }\n\n        gc();\n        for (int i = 0; i < 10; i++) {\n            Integer I = Integer.valueOf(i);\n            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n        }\n    }\n\n    @Test\n    public void testEntrySetIteratorAfterGC() {\n        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n        Object[] hard = new Object[10];\n        for (int i = 0; i < 10; i++) {\n            hard[i] = Integer.valueOf(10 + i);\n            map.put(Integer.valueOf(i), Integer.valueOf(i));\n            map.put(hard[i], hard[i]);\n        }\n\n        gc();\n        Iterator iterator = map.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry entry = (Map.Entry)iterator.next();\n            Integer key = (Integer)entry.getKey();\n            Integer value = (Integer)entry.getValue();\n            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n        }\n\n    }\n\n    @Test\n    public void testMapIteratorAfterGC() {\n        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n        Object[] hard = new Object[10];\n        for (int i = 0; i < 10; i++) {\n            hard[i] = Integer.valueOf(10 + i);\n            map.put(Integer.valueOf(i), Integer.valueOf(i));\n            map.put(hard[i], hard[i]);\n        }\n\n        gc();\n        MapIterator iterator = map.mapIterator();\n        while (iterator.hasNext()) {\n            Object key1 = iterator.next();\n            Integer key = (Integer) iterator.getKey();\n            Integer value = (Integer) iterator.getValue();\n            assertTrue(\"iterator keys should match\", key == key1);\n            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n        }\n\n    }\n\n    @Test\n    public void testMapIteratorAfterGC2() {\n        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n        Object[] hard = new Object[10];\n        for (int i = 0; i < 10; i++) {\n            hard[i] = Integer.valueOf(10 + i);\n            map.put(Integer.valueOf(i), Integer.valueOf(i));\n            map.put(hard[i], hard[i]);\n        }\n\n        MapIterator iterator = map.mapIterator();\n        while (iterator.hasNext()) {\n            Object key1 = iterator.next();\n            gc();\n            Integer key = (Integer) iterator.getKey();\n            Integer value = (Integer) iterator.getValue();\n            assertTrue(\"iterator keys should match\", key == key1);\n            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n        }\n\n    }\n*/\n\n    @Override\n    public ReferenceIdentityMap<K, V> makeObject() {\n        return new ReferenceIdentityMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBasics() {\n        final IterableMap<K, V> map = new ReferenceIdentityMap<>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n        assertEquals(0, map.size());\n\n        map.put((K) I1A, (V) I2A);\n        assertEquals(1, map.size());\n        assertSame(I2A, map.get(I1A));\n        assertSame(null, map.get(I1B));\n        assertTrue(map.containsKey(I1A));\n        assertFalse(map.containsKey(I1B));\n        assertTrue(map.containsValue(I2A));\n        assertFalse(map.containsValue(I2B));\n\n        map.put((K) I1A, (V) I2B);\n        assertEquals(1, map.size());\n        assertSame(I2B, map.get(I1A));\n        assertSame(null, map.get(I1B));\n        assertTrue(map.containsKey(I1A));\n        assertFalse(map.containsKey(I1B));\n        assertFalse(map.containsValue(I2A));\n        assertTrue(map.containsValue(I2B));\n\n        map.put((K) I1B, (V) I2B);\n        assertEquals(2, map.size());\n        assertSame(I2B, map.get(I1A));\n        assertSame(I2B, map.get(I1B));\n        assertTrue(map.containsKey(I1A));\n        assertTrue(map.containsKey(I1B));\n        assertFalse(map.containsValue(I2A));\n        assertTrue(map.containsValue(I2B));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testHashEntry() {\n        final IterableMap<K, V> map = new ReferenceIdentityMap<>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n\n        map.put((K) I1A, (V) I2A);\n        map.put((K) I1B, (V) I2A);\n\n        final Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n        final Map.Entry<K, V> entry2 = it.next();\n        final Map.Entry<K, V> entry3 = it.next();\n\n        assertTrue(entry1.equals(entry2));\n        assertTrue(entry2.equals(entry1));\n        assertFalse(entry1.equals(entry3));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testNullHandling() {\n        resetFull();\n        assertNull(getMap().get(null));\n        assertFalse(getMap().containsKey(null));\n        assertFalse(getMap().containsValue(null));\n        assertNull(getMap().remove(null));\n        assertFalse(getMap().entrySet().contains(null));\n        assertFalse(getMap().containsKey(null));\n        assertFalse(getMap().containsValue(null));\n        assertThrows(NullPointerException.class, () -> getMap().put(null, null));\n        assertThrows(NullPointerException.class, () -> getMap().put((K) new Object(), null));\n        assertThrows(NullPointerException.class, () -> getMap().put(null, (V) new Object()));\n    }\n\n    /** Tests whether purge values setting works */\n    @Test\n    public void testPurgeValues() throws Exception {\n        // many thanks to Juozas Baliuka for suggesting this method\n        final Map<K, V> testMap = buildRefMap();\n\n        int iterations = 0;\n        int bytz = 2;\n        while (true) {\n            System.gc();\n            if (iterations++ > 50) {\n                fail(\"Max iterations reached before resource released.\");\n            }\n            testMap.isEmpty();\n            if (\n                keyReference.get() == null &&\n                valueReference.get() == null) {\n                break;\n\n            }\n            // create garbage:\n            @SuppressWarnings(\"unused\")\n            final byte[] b =  new byte[bytz];\n            bytz *= 2;\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Integer I1A = new Integer(1);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "I1A = new Integer(1)", "syntax_pass": true}, {"attribute_expression": "private static final Integer I1B = new Integer(1);", "docstring": " Cannot use valueOf here", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "I1B = new Integer(1)", "syntax_pass": true}, {"attribute_expression": "private static final Integer I2A = new Integer(2);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "I2A = new Integer(2)", "syntax_pass": true}, {"attribute_expression": "private static final Integer I2B = new Integer(2);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "I2B = new Integer(2)", "syntax_pass": true}, {"attribute_expression": "WeakReference<K> keyReference;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "WeakReference<K>", "name": "keyReference", "syntax_pass": true}, {"attribute_expression": "WeakReference<V> valueReference;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "WeakReference<V>", "name": "valueReference", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_putAllTest.java.StaticBucketMap_putAllTest", "name": "StaticBucketMap_putAllTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_putAllTest.java", "superclasses": "", "methods": ["[void]testPutAll()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StaticBucketMap_putAllTest {\n\n    @Test\n    public void testPutAll() {\n        // Given\n        StaticBucketMap<Integer, String> map = new StaticBucketMap<>(10);\n        Map<Integer, String> inputMap = new HashMap<>();\n        inputMap.put(1, \"One\");\n        inputMap.put(2, \"Two\");\n        inputMap.put(3, \"Three\");\n\n        // When\n        map.putAll(inputMap);\n\n        // Then\n        assertEquals(3, map.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java.UnmodifiableMapTest", "name": "UnmodifiableMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java.UnmodifiableMapTest.[]UnmodifiableMapTest()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java.UnmodifiableMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java.UnmodifiableMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java.UnmodifiableMapTest.[boolean]isPutChangeSupported()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java.UnmodifiableMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java.UnmodifiableMapTest.[IterableMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java.UnmodifiableMapTest.[IterableMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMapTest} for exercising the\n{@link UnmodifiableMap} implementation.\n", "original_string": "public class UnmodifiableMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    public UnmodifiableMapTest() {\n        super(UnmodifiableMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isPutChangeSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public IterableMap<K, V> makeFullMap() {\n        final Map<K, V> m = new HashMap<>();\n        addSampleMappings(m);\n        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(m);\n    }\n\n    @Override\n    public IterableMap<K, V> makeObject() {\n        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(new HashMap<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final Map<K, V> map = makeFullMap();\n        assertSame(map, UnmodifiableMap.unmodifiableMap(map));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableMap.unmodifiableMap(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullMap() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/UnmodifiableMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/UnmodifiableMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_subMapTest.java.TransformedSortedMap_subMapTest", "name": "TransformedSortedMap_subMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_subMapTest.java", "superclasses": "", "methods": ["[void]testSubMap()", "[void]testSubMapWithTransformers()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_subMapTest.java.TransformedSortedMap_subMapTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedSortedMap_subMapTest {\n\n    private SortedMap<String, String> baseMap;\n    private Transformer<String, String> keyTransformer;\n    private Transformer<String, String> valueTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        baseMap = new TreeMap<>();\n        baseMap.put(\"A\", \"1\");\n        baseMap.put(\"B\", \"2\");\n        baseMap.put(\"C\", \"3\");\n\n        keyTransformer = TransformerUtils.nopTransformer();\n        valueTransformer = TransformerUtils.nopTransformer();\n    }\n\n    @Test\n    public void testSubMap() {\n        TransformedSortedMap<String, String> transformedMap = TransformedSortedMap.transformingSortedMap(baseMap, keyTransformer, valueTransformer);\n\n        SortedMap<String, String> subMap = transformedMap.subMap(\"A\", \"C\");\n\n        assertEquals(2, subMap.size());\n        assertEquals(\"1\", subMap.get(\"A\"));\n        assertEquals(\"2\", subMap.get(\"B\"));\n    }\n\n    @Test\n    public void testSubMapWithTransformers() {\n        Transformer<String, String> keyTransformer = TransformerUtils.stringValueTransformer();\n        Transformer<String, String> valueTransformer = TransformerUtils.stringValueTransformer();\n\n        TransformedSortedMap<String, String> transformedMap = TransformedSortedMap.transformingSortedMap(baseMap, keyTransformer, valueTransformer);\n\n        SortedMap<String, String> subMap = transformedMap.subMap(\"A\", \"C\");\n\n        assertEquals(2, subMap.size());\n        assertEquals(\"1\", subMap.get(\"A\"));\n        assertEquals(\"2\", subMap.get(\"B\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private SortedMap<String, String> baseMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SortedMap<String, String>", "name": "baseMap", "syntax_pass": true}, {"attribute_expression": "private Transformer<String, String> keyTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, String>", "name": "keyTransformer", "syntax_pass": true}, {"attribute_expression": "private Transformer<String, String> valueTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, String>", "name": "valueTransformer", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_putAllTest.java.CompositeMap_putAllTest", "name": "CompositeMap_putAllTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_putAllTest.java", "superclasses": "", "methods": ["[void]testPutAllWithMutator()", "[void]testPutAllWithoutMutator()", "[void]testPutAllWithClear()", "[void]testPutAllWithRemoveComposited()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_putAllTest.java.CompositeMap_putAllTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_putAllTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> mapOne;\n    private Map<String, String> mapTwo;\n\n    @BeforeEach\n    public void setUp() {\n        mapOne = new HashMap<>();\n        mapOne.put(\"1\", \"one\");\n        mapOne.put(\"2\", \"two\");\n\n        mapTwo = new HashMap<>();\n        mapTwo.put(\"3\", \"three\");\n        mapTwo.put(\"4\", \"four\");\n\n        compositeMap = new CompositeMap<>(mapOne, mapTwo);\n    }\n\n    @Test\n    public void testPutAllWithMutator() {\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"5\", \"five\");\n        newMap.put(\"6\", \"six\");\n\n        compositeMap.setMutator(new CompositeMap.MapMutator<String, String>() {\n            @Override\n            public void putAll(CompositeMap<String, String> map, Map<String, String>[] composited, Map<? extends String, ? extends String> mapToAdd) {\n                for (Map<String, String> m : composited) {\n                    m.putAll(mapToAdd);\n                }\n            }\n\n            @Override\n            public String put(CompositeMap<String, String> map, Map<String, String>[] composited, String key, String value) {\n                return null;\n            }\n\n            @Override\n            public void resolveCollision(CompositeMap<String, String> composite, Map<String, String> existing, Map<String, String> added, Collection<String> intersect) {\n            }\n        });\n\n        compositeMap.putAll(newMap);\n\n        assertTrue(compositeMap.containsKey(\"5\"));\n        assertTrue(compositeMap.containsKey(\"6\"));\n        assertEquals(\"five\", compositeMap.get(\"5\"));\n        assertEquals(\"six\", compositeMap.get(\"6\"));\n    }\n\n    @Test\n    public void testPutAllWithoutMutator() {\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"5\", \"five\");\n        newMap.put(\"6\", \"six\");\n\n        assertThrows(UnsupportedOperationException.class, () -> compositeMap.putAll(newMap));\n    }\n\n    @Test\n    public void testPutAllWithClear() {\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"5\", \"five\");\n        newMap.put(\"6\", \"six\");\n\n        compositeMap.clear();\n\n        compositeMap.setMutator(new CompositeMap.MapMutator<String, String>() {\n            @Override\n            public void putAll(CompositeMap<String, String> map, Map<String, String>[] composited, Map<? extends String, ? extends String> mapToAdd) {\n                for (Map<String, String> m : composited) {\n                    m.putAll(mapToAdd);\n                }\n            }\n\n            @Override\n            public String put(CompositeMap<String, String> map, Map<String, String>[] composited, String key, String value) {\n                return null;\n            }\n\n            @Override\n            public void resolveCollision(CompositeMap<String, String> composite, Map<String, String> existing, Map<String, String> added, Collection<String> intersect) {\n            }\n        });\n\n        compositeMap.putAll(newMap);\n\n        assertTrue(compositeMap.containsKey(\"5\"));\n        assertTrue(compositeMap.containsKey(\"6\"));\n        assertEquals(\"five\", compositeMap.get(\"5\"));\n        assertEquals(\"six\", compositeMap.get(\"6\"));\n    }\n\n    @Test\n    public void testPutAllWithRemoveComposited() {\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"5\", \"five\");\n        newMap.put(\"6\", \"six\");\n\n        compositeMap.removeComposited(mapOne);\n\n        compositeMap.setMutator(new CompositeMap.MapMutator<String, String>() {\n            @Override\n            public void putAll(CompositeMap<String, String> map, Map<String, String>[] composited, Map<? extends String, ? extends String> mapToAdd) {\n                for (Map<String, String> m : composited) {\n                    m.putAll(mapToAdd);\n                }\n            }\n\n            @Override\n            public String put(CompositeMap<String, String> map, Map<String, String>[] composited, String key, String value) {\n                return null;\n            }\n\n            @Override\n            public void resolveCollision(CompositeMap<String, String> composite, Map<String, String> existing, Map<String, String> added, Collection<String> intersect) {\n            }\n        });\n\n        compositeMap.putAll(newMap);\n\n        assertTrue(compositeMap.containsKey(\"5\"));\n        assertTrue(compositeMap.containsKey(\"6\"));\n        assertEquals(\"five\", compositeMap.get(\"5\"));\n        assertEquals(\"six\", compositeMap.get(\"6\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapOne;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapOne", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapTwo;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapTwo", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_keySetTest.java.PassiveExpiringMap_keySetTest", "name": "PassiveExpiringMap_keySetTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_keySetTest.java", "superclasses": "", "methods": ["[void]testKeySetWithExpiredEntries()", "[void]testKeySetWithoutExpiredEntries()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_keySetTest.java.PassiveExpiringMap_keySetTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PassiveExpiringMap_keySetTest {\n\n    private PassiveExpiringMap<String, String> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new PassiveExpiringMap<>(1, TimeUnit.SECONDS);\n    }\n\n    @Test\n    public void testKeySetWithExpiredEntries() throws InterruptedException {\n        // Given\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        Thread.sleep(1500); // Ensure entries expire\n\n        // When\n        Set<String> keySet = map.keySet();\n\n        // Then\n        assertTrue(keySet.isEmpty());\n    }\n\n    @Test\n    public void testKeySetWithoutExpiredEntries() {\n        // Given\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n\n        // When\n        Set<String> keySet = map.keySet();\n\n        // Then\n        assertEquals(2, keySet.size());\n        assertTrue(keySet.contains(\"key1\"));\n        assertTrue(keySet.contains(\"key2\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private PassiveExpiringMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PassiveExpiringMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_putAllTest.java.MultiValueMap_putAllTest", "name": "MultiValueMap_putAllTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiValueMap_putAllTest.java", "superclasses": "", "methods": ["[void]testPutAll_NewKey()", "[void]testPutAll_ExistingKey()", "[void]testPutAll_NullValues()", "[void]testPutAll_EmptyValues()", "[void]testPutAll_AfterRemoveMapping()", "[void]testPutAll_WithPut()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/MultiValueMap_putAllTest.java.MultiValueMap_putAllTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiValueMap_putAllTest {\n\n    private MultiValueMap<String, String> multiValueMap;\n\n    @BeforeEach\n    public void setUp() {\n        multiValueMap = new MultiValueMap<>();\n    }\n\n    @Test\n    public void testPutAll_NewKey() {\n        Collection<String> values = new ArrayList<>(Arrays.asList(\"A\", \"B\", \"C\"));\n        assertTrue(multiValueMap.putAll(\"key1\", values));\n        assertEquals(3, multiValueMap.size(\"key1\"));\n    }\n\n    @Test\n    public void testPutAll_ExistingKey() {\n        Collection<String> initialValues = new ArrayList<>(Arrays.asList(\"A\", \"B\"));\n        multiValueMap.putAll(\"key1\", initialValues);\n        Collection<String> additionalValues = new ArrayList<>(Arrays.asList(\"C\", \"D\"));\n        assertTrue(multiValueMap.putAll(\"key1\", additionalValues));\n        assertEquals(4, multiValueMap.size(\"key1\"));\n    }\n\n    @Test\n    public void testPutAll_NullValues() {\n        assertFalse(multiValueMap.putAll(\"key1\", null));\n        assertNull(multiValueMap.getCollection(\"key1\"));\n    }\n\n    @Test\n    public void testPutAll_EmptyValues() {\n        Collection<String> values = new ArrayList<>();\n        assertFalse(multiValueMap.putAll(\"key1\", values));\n        assertNull(multiValueMap.getCollection(\"key1\"));\n    }\n\n    @Test\n    public void testPutAll_AfterRemoveMapping() {\n        Collection<String> initialValues = new ArrayList<>(Arrays.asList(\"A\", \"B\"));\n        multiValueMap.putAll(\"key1\", initialValues);\n        assertTrue(multiValueMap.removeMapping(\"key1\", \"A\"));\n        Collection<String> additionalValues = new ArrayList<>(Arrays.asList(\"C\", \"D\"));\n        assertTrue(multiValueMap.putAll(\"key1\", additionalValues));\n        assertEquals(3, multiValueMap.size(\"key1\"));\n    }\n\n    @Test\n    public void testPutAll_WithPut() {\n        multiValueMap.put(\"key1\", \"A\");\n        Collection<String> additionalValues = new ArrayList<>(Arrays.asList(\"B\", \"C\"));\n        assertTrue(multiValueMap.putAll(\"key1\", additionalValues));\n        assertEquals(3, multiValueMap.size(\"key1\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private MultiValueMap<String, String> multiValueMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MultiValueMap<String, String>", "name": "multiValueMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/LazyMapTest.java.LazyMapTest", "name": "LazyMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LazyMapTest.java", "superclasses": "", "methods": ["[void]testMapGet()", "[void]testMapGetWithFactory()", "[void]testMapGetWithTransformer()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/LazyMapTest.java.LazyMapTest.[]LazyMapTest()", "src/test/java/org/apache/commons/collections4/map/LazyMapTest.java.LazyMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/LazyMapTest.java.LazyMapTest.[LazyMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMapTest} for exercising the\n{@link LazyMap} implementation.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class LazyMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n\n    public LazyMapTest() {\n        super(LazyMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public LazyMap<K, V> makeObject() {\n        return lazyMap(new HashMap<>(), FactoryUtils.<V>nullFactory());\n    }\n\n    @Test\n    @Override\n    public void testMapGet() {\n        //TODO eliminate need for this via superclass - see svn history.\n    }\n\n    @Test\n    public void testMapGetWithFactory() {\n        Map<Integer, Number> map = lazyMap(new HashMap<>(), oneFactory);\n        assertEquals(0, map.size());\n        final Number i1 = map.get(\"Five\");\n        assertEquals(1, i1);\n        assertEquals(1, map.size());\n        final Number i2 = map.get(new String(new char[] {'F', 'i', 'v', 'e'}));\n        assertEquals(1, i2);\n        assertEquals(1, map.size());\n        assertSame(i1, i2);\n\n        map = lazyMap(new HashMap<>(), FactoryUtils.<Long>nullFactory());\n        final Object o = map.get(\"Five\");\n        assertNull(o);\n        assertEquals(1, map.size());\n    }\n\n    @Test\n    public void testMapGetWithTransformer() {\n        final Transformer<Number, Integer> intConverter = Number::intValue;\n        final Map<Long, Number> map = lazyMap(new HashMap<>(), intConverter);\n        assertEquals(0, map.size());\n        final Number i1 = map.get(123L);\n        assertEquals(123, i1);\n        assertEquals(1, map.size());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/LazyMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/LazyMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Factory<Integer>", "name": "oneFactory = FactoryUtils.constantFactory(1)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java.ReferenceMapTest", "name": "ReferenceMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java", "superclasses": "", "methods": ["[void]testCustomPurge()", "[void]testDataSizeAfterSerialization()", "[void]testIteratorLastEntryCanBeRemovedAfterHasNext()", "[void]testNullHandling()", "[void]testPurgeValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java.ReferenceMapTest.[void]gc()", "src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java.ReferenceMapTest.[]ReferenceMapTest()", "src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java.ReferenceMapTest.[Map<K, V>]buildRefMap()", "src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java.ReferenceMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java.ReferenceMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java.ReferenceMapTest.[boolean]isAllowNullValue()", "src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java.ReferenceMapTest.[ReferenceMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    private static final class AccessibleEntry<K, V> extends ReferenceEntry<K, V> {\n        final AbstractReferenceMap<K, V> parent;\n        final Consumer<V> consumer;\n\n        AccessibleEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next, final int hashCode, final K key, final V value, final Consumer<V> consumer) {\n            super(parent, next, hashCode, key, value);\n            this.parent = parent;\n            this.consumer = consumer;\n        }\n\n        @Override\n        protected void onPurge() {\n            if (parent.isValueType(ReferenceStrength.HARD)) {\n                consumer.accept(getValue());\n            }\n        }\n    }", "definition": "    private static final class AccessibleEntry<K, V> extends ReferenceEntry<K, V>", "class_docstring": "", "name": "AccessibleEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "final AbstractReferenceMap<K, V> parent;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "AbstractReferenceMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "final Consumer<V> consumer;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Consumer<V>", "name": "consumer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        AccessibleEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next, final int hashCode, final K key, final V value, final Consumer<V> consumer) {\n            super(parent, next, hashCode, key, value);\n            this.parent = parent;\n            this.consumer = consumer;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AccessibleEntry", "params": [{"name": "parent", "type": "AbstractReferenceMap<K, V>"}, {"name": "next", "type": "HashEntry<K, V>"}, {"name": "hashCode", "type": "int"}, {"name": "key", "type": "K"}, {"name": "value", "type": "V"}, {"name": "consumer", "type": "Consumer<V>"}], "body": "                                                                                                                                                                         {\n            super(parent, next, hashCode, key, value);\n            this.parent = parent;\n            this.consumer = consumer;\n        }", "signature": "AccessibleEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next, final int hashCode, final K key, final V value, final Consumer<V> consumer)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected void onPurge() {\n            if (parent.isValueType(ReferenceStrength.HARD)) {\n                consumer.accept(getValue());\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "onPurge", "params": [], "body": "                                 {\n            if (parent.isValueType(ReferenceStrength.HARD)) {\n                consumer.accept(getValue());\n            }\n        }", "signature": "@Override\n        protected void onPurge()"}]}], "class_docstring": "\nTests for ReferenceMap.\n", "original_string": "public class ReferenceMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    private static final class AccessibleEntry<K, V> extends ReferenceEntry<K, V> {\n        final AbstractReferenceMap<K, V> parent;\n        final Consumer<V> consumer;\n\n        AccessibleEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next, final int hashCode, final K key, final V value, final Consumer<V> consumer) {\n            super(parent, next, hashCode, key, value);\n            this.parent = parent;\n            this.consumer = consumer;\n        }\n\n        @Override\n        protected void onPurge() {\n            if (parent.isValueType(ReferenceStrength.HARD)) {\n                consumer.accept(getValue());\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static void gc() {\n        try {\n            // trigger GC\n            final byte[][] tooLarge = new byte[1000000000][1000000000];\n            fail(\"you have too much RAM\");\n        } catch (final OutOfMemoryError ex) {\n            System.gc(); // ignore\n        }\n    }\n\n    WeakReference<K> keyReference;\n\n    WeakReference<V> valueReference;\n\n    public ReferenceMapTest() {\n        super(ReferenceMapTest.class.getSimpleName());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/ReferenceMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/ReferenceMap.fullCollection.version4.obj\");\n//    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Map<K, V> buildRefMap() {\n        final K key = (K) new Object();\n        final V value = (V) new Object();\n\n        keyReference = new WeakReference<>(key);\n        valueReference = new WeakReference<>(value);\n\n        final Map<K, V> testMap = new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n        testMap.put(key, value);\n\n        assertEquals(value, testMap.get(key), \"In map\");\n        assertNotNull(keyReference.get(), \"Weak reference released early (1)\");\n        assertNotNull(valueReference.get(), \"Weak reference released early (2)\");\n        return testMap;\n    }\n\n/*\n    // Tests often fail because gc is uncontrollable\n\n    @Test\n    public void testPurge() {\n        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n        Object[] hard = new Object[10];\n        for (int i = 0; i < hard.length; i++) {\n            hard[i] = new Object();\n            map.put(hard[i], new Object());\n        }\n        gc();\n        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n\n        for (int i = 0; i < hard.length; i++) {\n            map.put(new Object(), hard[i]);\n        }\n        gc();\n        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n\n        for (int i = 0; i < hard.length; i++) {\n            map.put(new Object(), hard[i]);\n            map.put(hard[i], new Object());\n        }\n\n        gc();\n        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n    }\n\n    @Test\n    public void testGetAfterGC() {\n        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n        for (int i = 0; i < 10; i++) {\n            map.put(Integer.valueOf(i), Integer.valueOf(i));\n        }\n\n        gc();\n        for (int i = 0; i < 10; i++) {\n            Integer I = Integer.valueOf(i);\n            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n        }\n    }\n\n    @Test\n    public void testEntrySetIteratorAfterGC() {\n        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n        Object[] hard = new Object[10];\n        for (int i = 0; i < 10; i++) {\n            hard[i] = Integer.valueOf(10 + i);\n            map.put(Integer.valueOf(i), Integer.valueOf(i));\n            map.put(hard[i], hard[i]);\n        }\n\n        gc();\n        Iterator iterator = map.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry entry = (Map.Entry)iterator.next();\n            Integer key = (Integer)entry.getKey();\n            Integer value = (Integer)entry.getValue();\n            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n        }\n\n    }\n\n    @Test\n    public void testMapIteratorAfterGC() {\n        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n        Object[] hard = new Object[10];\n        for (int i = 0; i < 10; i++) {\n            hard[i] = Integer.valueOf(10 + i);\n            map.put(Integer.valueOf(i), Integer.valueOf(i));\n            map.put(hard[i], hard[i]);\n        }\n\n        gc();\n        MapIterator iterator = map.mapIterator();\n        while (iterator.hasNext()) {\n            Object key1 = iterator.next();\n            Integer key = (Integer) iterator.getKey();\n            Integer value = (Integer) iterator.getValue();\n            assertTrue(\"iterator keys should match\", key == key1);\n            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n        }\n\n    }\n\n    @Test\n    public void testMapIteratorAfterGC2() {\n        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n        Object[] hard = new Object[10];\n        for (int i = 0; i < 10; i++) {\n            hard[i] = Integer.valueOf(10 + i);\n            map.put(Integer.valueOf(i), Integer.valueOf(i));\n            map.put(hard[i], hard[i]);\n        }\n\n        MapIterator iterator = map.mapIterator();\n        while (iterator.hasNext()) {\n            Object key1 = iterator.next();\n            gc();\n            Integer key = (Integer) iterator.getKey();\n            Integer value = (Integer) iterator.getValue();\n            assertTrue(\"iterator keys should match\", key == key1);\n            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n        }\n\n    }\n*/\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public boolean isAllowNullValue() {\n        return false;\n    }\n\n    @Override\n    public ReferenceMap<K, V> makeObject() {\n        return new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n    }\n\n    @Test\n    public void testCustomPurge() {\n        final List<Integer> expiredValues = new ArrayList<>();\n        @SuppressWarnings(\"unchecked\")\n        final Consumer<Integer> consumer = (Consumer<Integer> & Serializable) expiredValues::add;\n        final Map<Integer, Integer> map = new ReferenceMap<Integer, Integer>(ReferenceStrength.WEAK, ReferenceStrength.HARD, false) {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            protected ReferenceEntry<Integer, Integer> createEntry(final HashEntry<Integer, Integer> next, final int hashCode, final Integer key, final Integer value) {\n                return new AccessibleEntry<>(this, next, hashCode, key, value, consumer);\n            }\n        };\n        for (int i = 100000; i < 100010; i++) {\n            map.put(Integer.valueOf(i), Integer.valueOf(i));\n        }\n        int iterations = 0;\n        int bytz = 2;\n        while (true) {\n            System.gc();\n            if (iterations++ > 50 || bytz < 0) {\n                fail(\"Max iterations reached before resource released.\");\n            }\n            map.isEmpty();\n            if (!expiredValues.isEmpty()) {\n                break;\n            }\n            // create garbage:\n            @SuppressWarnings(\"unused\")\n            final byte[] b = new byte[bytz];\n            bytz *= 2;\n        }\n        assertFalse(expiredValues.isEmpty(), \"Value should be stored\");\n    }\n\n    /**\n     * Test whether after serialization the \"data\" HashEntry array is the same size as the original.<p>\n     *\n     * See <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-599\">COLLECTIONS-599: HashEntry array object naming data initialized with double the size during deserialization</a>\n     */\n    @Test\n    public void testDataSizeAfterSerialization() throws IOException, ClassNotFoundException {\n\n        final ReferenceMap<String, String> serializeMap = new ReferenceMap<>(ReferenceStrength.WEAK, ReferenceStrength.WEAK, true);\n        serializeMap.put(\"KEY\", \"VALUE\");\n\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (ObjectOutputStream out = new ObjectOutputStream(baos)) {\n            out.writeObject(serializeMap);\n        }\n\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        try (ObjectInputStream in = new ObjectInputStream(bais)) {\n            @SuppressWarnings(\"unchecked\")\n            final ReferenceMap<String, String> deserializedMap = (ReferenceMap<String, String>) in.readObject();\n            assertEquals(1, deserializedMap.size());\n            assertEquals(serializeMap.data.length, deserializedMap.data.length);\n        }\n\n    }\n\n    /**\n     * Test whether remove is not removing last entry after calling hasNext.\n     * <p>\n     * See <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-802\">COLLECTIONS-802: ReferenceMap iterator remove violates contract</a>\n     */\n    @Test\n    public void testIteratorLastEntryCanBeRemovedAfterHasNext() {\n        final ReferenceMap<Integer, Integer> map = new ReferenceMap<>();\n        map.put(1, 2);\n        final Iterator<Map.Entry<Integer, Integer>> iter = map.entrySet().iterator();\n        assertTrue(iter.hasNext());\n        iter.next();\n        // below line should not affect remove\n        assertFalse(iter.hasNext());\n        iter.remove();\n        assertTrue(map.isEmpty(), \"Expect empty but have entry: \" + map);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testNullHandling() {\n        resetFull();\n        assertNull(map.get(null));\n        assertFalse(map.containsKey(null));\n        assertFalse(map.containsValue(null));\n        assertNull(map.remove(null));\n        assertFalse(map.entrySet().contains(null));\n        assertFalse(map.containsKey(null));\n        assertFalse(map.containsValue(null));\n        assertThrows(NullPointerException.class, () -> map.put(null, null));\n        assertThrows(NullPointerException.class, () -> map.put((K) new Object(), null));\n        assertThrows(NullPointerException.class, () -> map.put(null, (V) new Object()));\n    }\n\n    /** Tests whether purge values setting works */\n    @Test\n    public void testPurgeValues() throws Exception {\n        // many thanks to Juozas Baliuka for suggesting this method\n        final Map<K, V> testMap = buildRefMap();\n\n        int iterations = 0;\n        int bytz = 2;\n        while (true) {\n            System.gc();\n            if (iterations++ > 50) {\n                fail(\"Max iterations reached before resource released.\");\n            }\n            testMap.isEmpty();\n            if (keyReference.get() == null && valueReference.get() == null) {\n                break;\n\n            }\n            // create garbage:\n            @SuppressWarnings(\"unused\")\n            final byte[] b = new byte[bytz];\n            bytz *= 2;\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "WeakReference<K> keyReference;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "WeakReference<K>", "name": "keyReference", "syntax_pass": true}, {"attribute_expression": "WeakReference<V> valueReference;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "WeakReference<V>", "name": "valueReference", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/SingletonMap_entrySetTest.java.SingletonMap_entrySetTest", "name": "SingletonMap_entrySetTest", "file_path": "src/test/java/org/apache/commons/collections4/map/SingletonMap_entrySetTest.java", "superclasses": "", "methods": ["[void]testEntrySet()", "[void]testEntrySetAfterPut()", "[void]testEntrySetWithNullKey()", "[void]testEntrySetWithNullValue()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/SingletonMap_entrySetTest.java.SingletonMap_entrySetTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonMap_entrySetTest {\n\n    private SingletonMap<String, String> singletonMap;\n\n    @BeforeEach\n    public void setUp() {\n        singletonMap = new SingletonMap<>(\"key\", \"value\");\n    }\n\n    @Test\n    public void testEntrySet() {\n        Set<Map.Entry<String, String>> entrySet = singletonMap.entrySet();\n        assertEquals(1, entrySet.size());\n        Map.Entry<String, String> entry = entrySet.iterator().next();\n        assertInstanceOf(TiedMapEntry.class, entry);\n        assertEquals(\"key\", entry.getKey());\n        assertEquals(\"value\", entry.getValue());\n    }\n\n    @Test\n    public void testEntrySetAfterPut() {\n        singletonMap.put(\"key\", \"newValue\");\n        Set<Map.Entry<String, String>> entrySet = singletonMap.entrySet();\n        assertEquals(1, entrySet.size());\n        Map.Entry<String, String> entry = entrySet.iterator().next();\n        assertInstanceOf(TiedMapEntry.class, entry);\n        assertEquals(\"key\", entry.getKey());\n        assertEquals(\"newValue\", entry.getValue());\n    }\n\n    @Test\n    public void testEntrySetWithNullKey() {\n        SingletonMap<String, String> nullKeyMap = new SingletonMap<>(null, \"value\");\n        Set<Map.Entry<String, String>> entrySet = nullKeyMap.entrySet();\n        assertEquals(1, entrySet.size());\n        Map.Entry<String, String> entry = entrySet.iterator().next();\n        assertInstanceOf(TiedMapEntry.class, entry);\n        assertEquals(null, entry.getKey());\n        assertEquals(\"value\", entry.getValue());\n    }\n\n    @Test\n    public void testEntrySetWithNullValue() {\n        SingletonMap<String, String> nullValueMap = new SingletonMap<>(\"key\", null);\n        Set<Map.Entry<String, String>> entrySet = nullValueMap.entrySet();\n        assertEquals(1, entrySet.size());\n        Map.Entry<String, String> entry = entrySet.iterator().next();\n        assertInstanceOf(TiedMapEntry.class, entry);\n        assertEquals(\"key\", entry.getKey());\n        assertEquals(null, entry.getValue());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private SingletonMap<String, String> singletonMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SingletonMap<String, String>", "name": "singletonMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/SingletonMap_putAllTest.java.SingletonMap_putAllTest", "name": "SingletonMap_putAllTest", "file_path": "src/test/java/org/apache/commons/collections4/map/SingletonMap_putAllTest.java", "superclasses": "", "methods": ["[void]testPutAllWithEmptyMap()", "[void]testPutAllWithSingleEntryMap()", "[void]testPutAllWithMultipleEntriesMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonMap_putAllTest {\n\n    @Test\n    public void testPutAllWithEmptyMap() {\n        SingletonMap<String, String> singletonMap = new SingletonMap<>(\"key\", \"value\");\n        Map<String, String> emptyMap = new HashMap<>();\n        singletonMap.putAll(emptyMap);\n        assertEquals(\"value\", singletonMap.getValue());\n    }\n\n    @Test\n    public void testPutAllWithSingleEntryMap() {\n        SingletonMap<String, String> singletonMap = new SingletonMap<>(\"key\", \"value\");\n        Map<String, String> singleEntryMap = new HashMap<>();\n        singleEntryMap.put(\"key\", \"newValue\");\n        singletonMap.putAll(singleEntryMap);\n        assertEquals(\"newValue\", singletonMap.getValue());\n    }\n\n    @Test\n    public void testPutAllWithMultipleEntriesMap() {\n        SingletonMap<String, String> singletonMap = new SingletonMap<>(\"key\", \"value\");\n        Map<String, String> multipleEntriesMap = new HashMap<>();\n        multipleEntriesMap.put(\"key1\", \"value1\");\n        multipleEntriesMap.put(\"key2\", \"value2\");\n        assertThrows(IllegalArgumentException.class, () -> singletonMap.putAll(multipleEntriesMap));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_headMapTest.java.TransformedSortedMap_headMapTest", "name": "TransformedSortedMap_headMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_headMapTest.java", "superclasses": "", "methods": ["[void]testHeadMap()", "[void]testHeadMapWithEmptyMap()", "[void]testHeadMapWithNullKey()", "[void]testHeadMapWithNonExistentKey()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/TransformedSortedMap_headMapTest.java.TransformedSortedMap_headMapTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedSortedMap_headMapTest {\n\n    private SortedMap<String, String> baseMap;\n    private Transformer<String, String> keyTransformer;\n    private Transformer<String, String> valueTransformer;\n\n    @BeforeEach\n    public void setUp() {\n        baseMap = new TreeMap<>();\n        baseMap.put(\"A\", \"1\");\n        baseMap.put(\"B\", \"2\");\n        baseMap.put(\"C\", \"3\");\n\n        keyTransformer = TransformerUtils.nopTransformer();\n        valueTransformer = TransformerUtils.nopTransformer();\n    }\n\n    @Test\n    public void testHeadMap() {\n        TransformedSortedMap<String, String> transformedMap = new TransformedSortedMap<>(baseMap, keyTransformer, valueTransformer);\n        SortedMap<String, String> headMap = transformedMap.headMap(\"B\");\n\n        assertEquals(1, headMap.size());\n        assertEquals(\"1\", headMap.get(\"A\"));\n    }\n\n    @Test\n    public void testHeadMapWithEmptyMap() {\n        baseMap.clear();\n        TransformedSortedMap<String, String> transformedMap = new TransformedSortedMap<>(baseMap, keyTransformer, valueTransformer);\n        SortedMap<String, String> headMap = transformedMap.headMap(\"B\");\n\n        assertEquals(0, headMap.size());\n    }\n\n    @Test\n    public void testHeadMapWithNullKey() {\n        TransformedSortedMap<String, String> transformedMap = new TransformedSortedMap<>(baseMap, keyTransformer, valueTransformer);\n        assertThrows(NullPointerException.class, () -> {\n            transformedMap.headMap(null);\n        });\n    }\n\n    @Test\n    public void testHeadMapWithNonExistentKey() {\n        TransformedSortedMap<String, String> transformedMap = new TransformedSortedMap<>(baseMap, keyTransformer, valueTransformer);\n        SortedMap<String, String> headMap = transformedMap.headMap(\"Z\");\n\n        assertEquals(3, headMap.size());\n        assertEquals(\"1\", headMap.get(\"A\"));\n        assertEquals(\"2\", headMap.get(\"B\"));\n        assertEquals(\"3\", headMap.get(\"C\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private SortedMap<String, String> baseMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SortedMap<String, String>", "name": "baseMap", "syntax_pass": true}, {"attribute_expression": "private Transformer<String, String> keyTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, String>", "name": "keyTransformer", "syntax_pass": true}, {"attribute_expression": "private Transformer<String, String> valueTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, String>", "name": "valueTransformer", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/LazyMap_getTest.java.LazyMap_getTest", "name": "LazyMap_getTest", "file_path": "src/test/java/org/apache/commons/collections4/map/LazyMap_getTest.java", "superclasses": "", "methods": ["[void]testGet_KeyNotInMap()", "[void]testGet_KeyInMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/LazyMap_getTest.java.LazyMap_getTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LazyMap_getTest {\n\n    private Map<String, String> map;\n    private Factory<String> factory;\n    private LazyMap<String, String> lazyMap;\n\n    @BeforeEach\n    public void setUp() {\n        map = new HashMap<>();\n        factory = mock(Factory.class);\n        lazyMap = LazyMap.lazyMap(map, key -> factory.create());\n    }\n\n    @Test\n    public void testGet_KeyNotInMap() {\n        // Given\n        String key = \"newKey\";\n        String value = \"newValue\";\n        when(factory.create()).thenReturn(value);\n\n        // When\n        String result = lazyMap.get(key);\n\n        // Then\n        assertEquals(value, result);\n        verify(factory, times(1)).create();\n        assertEquals(value, map.get(key));\n    }\n\n    @Test\n    public void testGet_KeyInMap() {\n        // Given\n        String key = \"existingKey\";\n        String value = \"existingValue\";\n        map.put(key, value);\n\n        // When\n        String result = lazyMap.get(key);\n\n        // Then\n        assertEquals(value, result);\n        verify(factory, never()).create();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Map<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map", "syntax_pass": true}, {"attribute_expression": "private Factory<String> factory;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Factory<String>", "name": "factory", "syntax_pass": true}, {"attribute_expression": "private LazyMap<String, String> lazyMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "LazyMap<String, String>", "name": "lazyMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_equalsTest.java.StaticBucketMap_equalsTest", "name": "StaticBucketMap_equalsTest", "file_path": "src/test/java/org/apache/commons/collections4/map/StaticBucketMap_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameInstance()", "[void]testEquals_DifferentType()", "[void]testEquals_EmptyMaps()", "[void]testEquals_NonEmptyMapsEqual()", "[void]testEquals_NonEmptyMapsNotEqual()", "[void]testEquals_DifferentSizeMaps()", "[void]testEquals_NullKey()", "[void]testEquals_NullValue()", "[void]testEquals_NullKeyAndValue()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/StaticBucketMap_equalsTest.java.StaticBucketMap_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class StaticBucketMap_equalsTest {\n    private StaticBucketMap<String, String> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new StaticBucketMap<>(17);\n    }\n\n    @Test\n    public void testEquals_SameInstance() {\n        assertTrue(map.equals(map));\n    }\n\n    @Test\n    public void testEquals_DifferentType() {\n        assertFalse(map.equals(\"not a map\"));\n    }\n\n    @Test\n    public void testEquals_EmptyMaps() {\n        StaticBucketMap<String, String> otherMap = new StaticBucketMap<>(17);\n        assertTrue(map.equals(otherMap));\n    }\n\n    @Test\n    public void testEquals_NonEmptyMapsEqual() {\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n\n        StaticBucketMap<String, String> otherMap = new StaticBucketMap<>(17);\n        otherMap.put(\"key1\", \"value1\");\n        otherMap.put(\"key2\", \"value2\");\n\n        assertTrue(map.equals(otherMap));\n    }\n\n    @Test\n    public void testEquals_NonEmptyMapsNotEqual() {\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n\n        StaticBucketMap<String, String> otherMap = new StaticBucketMap<>(17);\n        otherMap.put(\"key1\", \"value1\");\n        otherMap.put(\"key2\", \"differentValue\");\n\n        assertFalse(map.equals(otherMap));\n    }\n\n    @Test\n    public void testEquals_DifferentSizeMaps() {\n        map.put(\"key1\", \"value1\");\n\n        StaticBucketMap<String, String> otherMap = new StaticBucketMap<>(17);\n        otherMap.put(\"key1\", \"value1\");\n        otherMap.put(\"key2\", \"value2\");\n\n        assertFalse(map.equals(otherMap));\n    }\n\n    @Test\n    public void testEquals_NullKey() {\n        map.put(null, \"value1\");\n\n        StaticBucketMap<String, String> otherMap = new StaticBucketMap<>(17);\n        otherMap.put(null, \"value1\");\n\n        assertTrue(map.equals(otherMap));\n    }\n\n    @Test\n    public void testEquals_NullValue() {\n        map.put(\"key1\", null);\n\n        StaticBucketMap<String, String> otherMap = new StaticBucketMap<>(17);\n        otherMap.put(\"key1\", null);\n\n        assertTrue(map.equals(otherMap));\n    }\n\n    @Test\n    public void testEquals_NullKeyAndValue() {\n        map.put(null, null);\n\n        StaticBucketMap<String, String> otherMap = new StaticBucketMap<>(17);\n        otherMap.put(null, null);\n\n        assertTrue(map.equals(otherMap));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private StaticBucketMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StaticBucketMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMap_tailMapTest.java.PredicatedSortedMap_tailMapTest", "name": "PredicatedSortedMap_tailMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PredicatedSortedMap_tailMapTest.java", "superclasses": "", "methods": ["[void]testTailMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PredicatedSortedMap_tailMapTest {\n\n    @Test\n    public void testTailMap() {\n        // Given\n        SortedMap<Integer, String> originalMap = new TreeMap<>();\n        originalMap.put(1, \"One\");\n        originalMap.put(2, \"Two\");\n        originalMap.put(3, \"Three\");\n\n        Predicate<Integer> keyPredicate = key -> key > 0;\n        Predicate<String> valuePredicate = value -> value.length() > 0;\n\n        PredicatedSortedMap<Integer, String> predicatedMap = PredicatedSortedMap.predicatedSortedMap(originalMap, keyPredicate, valuePredicate);\n\n        // When\n        SortedMap<Integer, String> tailMap = predicatedMap.tailMap(2);\n\n        // Then\n        assertEquals(2, tailMap.size());\n        assertTrue(tailMap.containsKey(2));\n        assertTrue(tailMap.containsKey(3));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_putTest.java.CompositeMap_putTest", "name": "CompositeMap_putTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_putTest.java", "superclasses": "", "methods": ["[void]testPutWithMutator()", "[void]testPutWithoutMutator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_putTest.java.CompositeMap_putTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_putTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> mapOne;\n    private Map<String, String> mapTwo;\n\n    @BeforeEach\n    public void setUp() {\n        mapOne = new HashMap<>();\n        mapOne.put(\"1\", \"one\");\n        mapOne.put(\"2\", \"two\");\n\n        mapTwo = new HashMap<>();\n        mapTwo.put(\"3\", \"three\");\n        mapTwo.put(\"4\", \"four\");\n\n        compositeMap = new CompositeMap<>(mapOne, mapTwo);\n    }\n\n    @Test\n    public void testPutWithMutator() {\n        CompositeMap.MapMutator<String, String> mutator = new CompositeMap.MapMutator<String, String>() {\n            @Override\n            public String put(CompositeMap<String, String> map, Map<String, String>[] composited, String key, String value) {\n                for (Map<String, String> m : composited) {\n                    if (m.containsKey(key)) {\n                        return m.put(key, value);\n                    }\n                }\n                return composited[0].put(key, value);\n            }\n\n            @Override\n            public void putAll(CompositeMap<String, String> map, Map<String, String>[] composited, Map<? extends String, ? extends String> mapToAdd) {\n                for (Map.Entry<? extends String, ? extends String> entry : mapToAdd.entrySet()) {\n                    put(map, composited, entry.getKey(), entry.getValue());\n                }\n            }\n\n            @Override\n            public void resolveCollision(CompositeMap<String, String> composite, Map<String, String> existing, Map<String, String> added, Collection<String> intersect) {\n                // No-op for this test\n            }\n        };\n\n        compositeMap.setMutator(mutator);\n\n        // Test adding a new key-value pair\n        assertEquals(null, compositeMap.put(\"5\", \"five\"));\n        assertTrue(compositeMap.containsKey(\"5\"));\n\n        // Test updating an existing key-value pair\n        assertEquals(\"two\", compositeMap.put(\"2\", \"newTwo\"));\n        assertEquals(\"newTwo\", compositeMap.get(\"2\"));\n    }\n\n    @Test\n    public void testPutWithoutMutator() {\n        assertThrows(UnsupportedOperationException.class, () -> compositeMap.put(\"5\", \"five\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapOne;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapOne", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> mapTwo;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "mapTwo", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_removeTest.java.ListOrderedMap_removeTest", "name": "ListOrderedMap_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveExistingKey()", "[void]testRemoveNonExistingKey()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/ListOrderedMap_removeTest.java.ListOrderedMap_removeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ListOrderedMap_removeTest {\n\n    private ListOrderedMap<String, String> map;\n\n    @BeforeEach\n    void setUp() {\n        map = new ListOrderedMap<>(new HashMap<>());\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n    }\n\n    @Test\n    void testRemoveExistingKey() {\n        // Given\n        assertTrue(map.containsKey(\"key1\"));\n\n        // When\n        String result = map.remove(\"key1\");\n\n        // Then\n        assertEquals(\"value1\", result);\n        assertFalse(map.containsKey(\"key1\"));\n    }\n\n    @Test\n    void testRemoveNonExistingKey() {\n        // Given\n        assertFalse(map.containsKey(\"key3\"));\n\n        // When\n        String result = map.remove(\"key3\");\n\n        // Then\n        assertNull(result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ListOrderedMap<String, String> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListOrderedMap<String, String>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/SingletonMap_cloneTest.java.SingletonMap_cloneTest", "name": "SingletonMap_cloneTest", "file_path": "src/test/java/org/apache/commons/collections4/map/SingletonMap_cloneTest.java", "superclasses": "", "methods": ["[void]testClone()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SingletonMap_cloneTest {\n\n    @Test\n    void testClone() {\n        SingletonMap<String, String> original = new SingletonMap<>(\"key\", \"value\");\n        SingletonMap<String, String> cloned = original.clone();\n\n        assertNotSame(original, cloned);\n        assertEquals(original.getKey(), cloned.getKey());\n        assertEquals(original.getValue(), cloned.getValue());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/SingletonMap_getTest.java.SingletonMap_getTest", "name": "SingletonMap_getTest", "file_path": "src/test/java/org/apache/commons/collections4/map/SingletonMap_getTest.java", "superclasses": "", "methods": ["[void]testGet_KeyExists()", "[void]testGet_KeyDoesNotExist()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonMap_getTest {\n\n    @Test\n    public void testGet_KeyExists() {\n        SingletonMap<String, String> map = new SingletonMap<>(\"key\", \"value\");\n        assertEquals(\"value\", map.get(\"key\"));\n    }\n\n    @Test\n    public void testGet_KeyDoesNotExist() {\n        SingletonMap<String, String> map = new SingletonMap<>(\"key\", \"value\");\n        assertNull(map.get(\"nonexistentKey\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_getTest.java.CompositeMap_getTest", "name": "CompositeMap_getTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_getTest.java", "superclasses": "", "methods": ["[void]testGetExistingKey()", "[void]testGetNonExistingKey()", "[void]testGetAfterAddComposited()", "[void]testGetAfterPut()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_getTest.java.CompositeMap_getTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_getTest {\n\n    private CompositeMap<String, String> compositeMap;\n    private Map<String, String> map1;\n    private Map<String, String> map2;\n\n    @BeforeEach\n    public void setUp() {\n        map1 = new HashMap<>();\n        map2 = new HashMap<>();\n        compositeMap = new CompositeMap<>(map1, map2);\n    }\n\n    @Test\n    public void testGetExistingKey() {\n        map1.put(\"key1\", \"value1\");\n        map2.put(\"key2\", \"value2\");\n        assertEquals(\"value1\", compositeMap.get(\"key1\"));\n        assertEquals(\"value2\", compositeMap.get(\"key2\"));\n    }\n\n    @Test\n    public void testGetNonExistingKey() {\n        map1.put(\"key1\", \"value1\");\n        assertNull(compositeMap.get(\"key3\"));\n    }\n\n    @Test\n    public void testGetAfterAddComposited() {\n        map1.put(\"key1\", \"value1\");\n        Map<String, String> newMap = new HashMap<>();\n        newMap.put(\"key3\", \"value3\");\n        compositeMap.addComposited(newMap);\n        assertEquals(\"value3\", compositeMap.get(\"key3\"));\n    }\n\n    @Test\n    public void testGetAfterPut() {\n        map1.put(\"key1\", \"value1\");\n        map1.put(\"key2\", \"value2\");\n        assertEquals(\"value2\", compositeMap.get(\"key2\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map1", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> map2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "map2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_firstKeyTest.java.ListOrderedMap_firstKeyTest", "name": "ListOrderedMap_firstKeyTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMap_firstKeyTest.java", "superclasses": "", "methods": ["[void]testFirstKey_MapNotEmpty()", "[void]testFirstKey_MapEmpty()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ListOrderedMap_firstKeyTest {\n\n    @Test\n    void testFirstKey_MapNotEmpty() {\n        ListOrderedMap<String, String> map = new ListOrderedMap<>();\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        assertEquals(\"key1\", map.firstKey());\n    }\n\n    @Test\n    void testFirstKey_MapEmpty() {\n        ListOrderedMap<String, String> map = new ListOrderedMap<>();\n        assertThrows(NoSuchElementException.class, map::firstKey);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java.ListOrderedMapTest", "name": "ListOrderedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java", "superclasses": "", "methods": ["[void]testCOLLECTIONS_474_nonNullValues()", "[void]testCOLLECTIONS_474_nullValues()", "[void]testGetByIndex()", "[void]testGetValueByIndex()", "[void]testIndexOf()", "[void]testPut_intObjectObject()", "[void]testPutAllWithIndex()", "[void]testPutAllWithIndexBug441()", "[void]testRemoveByIndex()", "[void]testSetValueByIndex()", "[void]testValueList_getByIndex()", "[void]testValueList_removeByIndex()", "[void]testValueList_setByIndex()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java.ListOrderedMapTest.[]ListOrderedMapTest()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java.ListOrderedMapTest.[BulkTest]bulkTestKeyListView()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java.ListOrderedMapTest.[BulkTest]bulkTestValueListView()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java.ListOrderedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java.ListOrderedMapTest.[ListOrderedMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java.ListOrderedMapTest.[ListOrderedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java.ListOrderedMapTest.[ListOrderedMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    public class TestKeyListView extends AbstractListTest<K> {\n\n        TestKeyListView() {\n            super(\"TestKeyListView\");\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<K> makeFullCollection() {\n            return ListOrderedMapTest.this.makeFullMap().keyList();\n        }\n\n        @Override\n        public List<K> makeObject() {\n            return ListOrderedMapTest.this.makeObject().keyList();\n        }\n\n    }", "definition": "    public class TestKeyListView extends AbstractListTest<K>", "class_docstring": "", "name": "TestKeyListView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TestKeyListView() {\n            super(\"TestKeyListView\");\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestKeyListView", "params": [], "body": "                          {\n            super(\"TestKeyListView\");\n        }", "signature": "TestKeyListView()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return getSampleKeys();\n        }", "signature": "@Override\n        public K[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return false;\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isSetSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isSetSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isSetSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<K> makeFullCollection() {\n            return ListOrderedMapTest.this.makeFullMap().keyList();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<K>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                            {\n            return ListOrderedMapTest.this.makeFullMap().keyList();\n        }", "signature": "@Override\n        public List<K> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<K> makeObject() {\n            return ListOrderedMapTest.this.makeObject().keyList();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<K>", "classes": []}, "name": "makeObject", "params": [], "body": "                                    {\n            return ListOrderedMapTest.this.makeObject().keyList();\n        }", "signature": "@Override\n        public List<K> makeObject()"}]}, {"original_string": "    public class TestValueListView extends AbstractListTest<V> {\n\n        TestValueListView() {\n            super(\"TestValueListView\");\n        }\n\n        @Override\n        public V[] getFullElements() {\n            return getSampleValues();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return true;\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return true;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<V> makeFullCollection() {\n            return ListOrderedMapTest.this.makeFullMap().valueList();\n        }\n\n        @Override\n        public List<V> makeObject() {\n            return ListOrderedMapTest.this.makeObject().valueList();\n        }\n\n    }", "definition": "    public class TestValueListView extends AbstractListTest<V>", "class_docstring": "", "name": "TestValueListView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TestValueListView() {\n            super(\"TestValueListView\");\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestValueListView", "params": [], "body": "                            {\n            super(\"TestValueListView\");\n        }", "signature": "TestValueListView()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V[] getFullElements() {\n            return getSampleValues();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return getSampleValues();\n        }", "signature": "@Override\n        public V[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return true;\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isSetSupported() {\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isSetSupported", "params": [], "body": "                                        {\n            return true;\n        }", "signature": "@Override\n        public boolean isSetSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<V> makeFullCollection() {\n            return ListOrderedMapTest.this.makeFullMap().valueList();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<V>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                            {\n            return ListOrderedMapTest.this.makeFullMap().valueList();\n        }", "signature": "@Override\n        public List<V> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<V> makeObject() {\n            return ListOrderedMapTest.this.makeObject().valueList();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                    {\n            return ListOrderedMapTest.this.makeObject().valueList();\n        }", "signature": "@Override\n        public List<V> makeObject()"}]}], "class_docstring": "\nExtension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap} implementation.\n", "original_string": "public class ListOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n\n    public class TestKeyListView extends AbstractListTest<K> {\n\n        TestKeyListView() {\n            super(\"TestKeyListView\");\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<K> makeFullCollection() {\n            return ListOrderedMapTest.this.makeFullMap().keyList();\n        }\n\n        @Override\n        public List<K> makeObject() {\n            return ListOrderedMapTest.this.makeObject().keyList();\n        }\n\n    }\n\n    public class TestValueListView extends AbstractListTest<V> {\n\n        TestValueListView() {\n            super(\"TestValueListView\");\n        }\n\n        @Override\n        public V[] getFullElements() {\n            return getSampleValues();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return true;\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return true;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<V> makeFullCollection() {\n            return ListOrderedMapTest.this.makeFullMap().valueList();\n        }\n\n        @Override\n        public List<V> makeObject() {\n            return ListOrderedMapTest.this.makeObject().valueList();\n        }\n\n    }\n\n    public ListOrderedMapTest() {\n        super(ListOrderedMapTest.class.getSimpleName());\n    }\n\n    public BulkTest bulkTestKeyListView() {\n        return new TestKeyListView();\n    }\n\n    public BulkTest bulkTestValueListView() {\n        return new TestValueListView();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListOrderedMap<K, V> getMap() {\n        return (ListOrderedMap<K, V>) super.getMap();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ListOrderedMap<K, V> makeFullMap() {\n        return (ListOrderedMap<K, V>) super.makeFullMap();\n    }\n\n    @Override\n    public ListOrderedMap<K, V> makeObject() {\n        return ListOrderedMap.listOrderedMap(new HashMap<>());\n    }\n\n    @Test\n    public void testCOLLECTIONS_474_nonNullValues() {\n        final Object key1 = new Object();\n        final Object key2 = new Object();\n        final HashMap<Object, Object> hmap = new HashMap<>();\n        hmap.put(key1, \"1\");\n        hmap.put(key2, \"2\");\n        assertEquals(2, hmap.size(), \"Should have two elements\");\n        final ListOrderedMap<Object, Object> listMap = new ListOrderedMap<>();\n        listMap.put(key1, \"3\");\n        listMap.put(key2, \"4\");\n        assertEquals(2, listMap.size(), \"Should have two elements\");\n        listMap.putAll(2, hmap);\n    }\n\n    @Test\n    public void testCOLLECTIONS_474_nullValues() {\n        final Object key1 = new Object();\n        final Object key2 = new Object();\n        final HashMap<Object, Object> hmap = new HashMap<>();\n        hmap.put(key1, null);\n        hmap.put(key2, null);\n        assertEquals(2, hmap.size(), \"Should have two elements\");\n        final ListOrderedMap<Object, Object> listMap = new ListOrderedMap<>();\n        listMap.put(key1, null);\n        listMap.put(key2, null);\n        assertEquals(2, listMap.size(), \"Should have two elements\");\n        listMap.putAll(2, hmap);\n    }\n\n    @Test\n    public void testGetByIndex() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n        try {\n            lom.get(0);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.get(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lom = getMap();\n        try {\n            lom.get(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.get(lom.size());\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        int i = 0;\n        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n            assertSame(it.next(), lom.get(i));\n        }\n    }\n\n    @Test\n    public void testGetValueByIndex() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n        try {\n            lom.getValue(0);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.getValue(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lom = getMap();\n        try {\n            lom.getValue(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.getValue(lom.size());\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        int i = 0;\n        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n            it.next();\n            assertSame(it.getValue(), lom.getValue(i));\n        }\n    }\n\n    @Test\n    public void testIndexOf() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n        assertEquals(-1, lom.indexOf(getOtherKeys()));\n\n        resetFull();\n        lom = getMap();\n        final List<K> list = new ArrayList<>();\n        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n            list.add(it.next());\n        }\n        for (int i = 0; i < list.size(); i++) {\n            assertEquals(i, lom.indexOf(list.get(i)));\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPut_intObjectObject() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n\n        final ListOrderedMap<K, V> finalLom = lom;\n        assertAll(\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> finalLom.put(1, (K) \"testInsert1\", (V) \"testInsert1v\"),\n                        \"should not be able to insert at pos 1 in empty Map\"),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> finalLom.put(-1, (K) \"testInsert-1\", (V) \"testInsert-1v\"),\n                        \"should not be able to insert at pos -1 in empty Map\"));\n\n        // put where key doesn't exist\n        lom.put(0, (K) \"testInsert1\", (V) \"testInsert1v\");\n        assertEquals(\"testInsert1v\", lom.getValue(0));\n\n        lom.put((K) \"testInsertPut\", (V) \"testInsertPutv\");\n        assertEquals(\"testInsert1v\", lom.getValue(0));\n        assertEquals(\"testInsertPutv\", lom.getValue(1));\n\n        lom.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n        assertEquals(\"testInsert0v\", lom.getValue(0));\n        assertEquals(\"testInsert1v\", lom.getValue(1));\n        assertEquals(\"testInsertPutv\", lom.getValue(2));\n\n        lom.put(3, (K) \"testInsert3\", (V) \"testInsert3v\");\n        assertEquals(\"testInsert0v\", lom.getValue(0));\n        assertEquals(\"testInsert1v\", lom.getValue(1));\n        assertEquals(\"testInsertPutv\", lom.getValue(2));\n        assertEquals(\"testInsert3v\", lom.getValue(3));\n\n        // put in a full map\n        resetFull();\n        lom = getMap();\n        final ListOrderedMap<K, V> lom2 = new ListOrderedMap<>();\n        lom2.putAll(lom);\n\n        lom2.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n        assertEquals(\"testInsert0v\", lom2.getValue(0));\n        for (int i = 0; i < lom.size(); i++) {\n            assertEquals(lom2.getValue(i + 1), lom.getValue(i));\n        }\n\n        // put where key does exist\n        final Integer i1 = Integer.valueOf(1);\n        final Integer i1b = Integer.valueOf(1);\n        final Integer i2 = Integer.valueOf(2);\n        final Integer i3 = Integer.valueOf(3);\n\n        resetEmpty();\n        lom = getMap();\n        lom.put((K) i1, (V) \"1\");\n        lom.put((K) i2, (V) \"2\");\n        lom.put((K) i3, (V) \"3\");\n        lom.put(0, (K) i1, (V) \"One\");\n        assertEquals(3, lom.size());\n        assertEquals(3, lom.map.size());\n        assertEquals(3, lom.keyList().size());\n        assertEquals(\"One\", lom.getValue(0));\n        assertSame(i1, lom.get(0));\n\n        resetEmpty();\n        lom = getMap();\n        lom.put((K) i1, (V) \"1\");\n        lom.put((K) i2, (V) \"2\");\n        lom.put((K) i3, (V) \"3\");\n        lom.put(0, (K) i1b, (V) \"One\");\n        assertEquals(3, lom.size());\n        assertEquals(3, lom.map.size());\n        assertEquals(3, lom.keyList().size());\n        assertEquals(\"One\", lom.getValue(0));\n        assertEquals(\"2\", lom.getValue(1));\n        assertEquals(\"3\", lom.getValue(2));\n        assertSame(i1b, lom.get(0));\n\n        resetEmpty();\n        lom = getMap();\n        lom.put((K) i1, (V) \"1\");\n        lom.put((K) i2, (V) \"2\");\n        lom.put((K) i3, (V) \"3\");\n        lom.put(1, (K) i1b, (V) \"One\");\n        assertEquals(3, lom.size());\n        assertEquals(3, lom.map.size());\n        assertEquals(3, lom.keyList().size());\n        assertEquals(\"One\", lom.getValue(0));\n        assertEquals(\"2\", lom.getValue(1));\n        assertEquals(\"3\", lom.getValue(2));\n\n        resetEmpty();\n        lom = getMap();\n        lom.put((K) i1, (V) \"1\");\n        lom.put((K) i2, (V) \"2\");\n        lom.put((K) i3, (V) \"3\");\n        lom.put(2, (K) i1b, (V) \"One\");\n        assertEquals(3, lom.size());\n        assertEquals(3, lom.map.size());\n        assertEquals(3, lom.keyList().size());\n        assertEquals(\"2\", lom.getValue(0));\n        assertEquals(\"One\", lom.getValue(1));\n        assertEquals(\"3\", lom.getValue(2));\n\n        resetEmpty();\n        lom = getMap();\n        lom.put((K) i1, (V) \"1\");\n        lom.put((K) i2, (V) \"2\");\n        lom.put((K) i3, (V) \"3\");\n        lom.put(3, (K) i1b, (V) \"One\");\n        assertEquals(3, lom.size());\n        assertEquals(3, lom.map.size());\n        assertEquals(3, lom.keyList().size());\n        assertEquals(\"2\", lom.getValue(0));\n        assertEquals(\"3\", lom.getValue(1));\n        assertEquals(\"One\", lom.getValue(2));\n    }\n\n    @Test\n    public void testPutAllWithIndex() {\n        resetEmpty();\n        @SuppressWarnings(\"unchecked\")\n        final ListOrderedMap<String, String> lom = (ListOrderedMap<String, String>) map;\n\n        // Create Initial Data\n        lom.put(\"testInsert0\", \"testInsert0v\");\n        lom.put(\"testInsert1\", \"testInsert1v\");\n        lom.put(\"testInsert2\", \"testInsert2v\");\n        assertEquals(\"testInsert0v\", lom.getValue(0));\n        assertEquals(\"testInsert1v\", lom.getValue(1));\n        assertEquals(\"testInsert2v\", lom.getValue(2));\n\n        // Create New Test Map and Add using putAll(int, Object, Object)\n        final Map<String, String> values = new ListOrderedMap<>();\n        values.put(\"NewInsert0\", \"NewInsert0v\");\n        values.put(\"NewInsert1\", \"NewInsert1v\");\n        lom.putAll(1, values);\n\n        // Perform Asserts\n        assertEquals(\"testInsert0v\", lom.getValue(0));\n        assertEquals(\"NewInsert0v\", lom.getValue(1));\n        assertEquals(\"NewInsert1v\", lom.getValue(2));\n        assertEquals(\"testInsert1v\", lom.getValue(3));\n        assertEquals(\"testInsert2v\", lom.getValue(4));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPutAllWithIndexBug441() {\n        // see COLLECTIONS-441\n        resetEmpty();\n        final ListOrderedMap<K, V> lom = getMap();\n\n        final int size = 5;\n        for (int i = 0; i < size; i++) {\n            lom.put((K) Integer.valueOf(i), (V) Boolean.TRUE);\n        }\n\n        final Map<K, V> map = new TreeMap<>();\n        for (int i = 0; i < size; i++) {\n            map.put((K) Integer.valueOf(i), (V) Boolean.FALSE);\n        }\n\n        lom.putAll(3, map);\n\n        final List<K> orderedList = lom.asList();\n        for (int i = 0; i < size; i++) {\n            assertEquals(Integer.valueOf(i), orderedList.get(i));\n        }\n    }\n\n    @Test\n    public void testRemoveByIndex() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n        try {\n            lom.remove(0);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.remove(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lom = getMap();\n        try {\n            lom.remove(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.remove(lom.size());\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        final List<K> list = new ArrayList<>();\n        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n            list.add(it.next());\n        }\n        for (int i = 0; i < list.size(); i++) {\n            final Object key = list.get(i);\n            final Object value = lom.get(key);\n            assertEquals(value, lom.remove(i));\n            list.remove(i);\n            assertFalse(lom.containsKey(key));\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetValueByIndex() {\n        resetEmpty();\n        ListOrderedMap<K, V> lom = getMap();\n        try {\n            lom.setValue(0, (V) StringUtils.EMPTY);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.setValue(-1, (V) StringUtils.EMPTY);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        resetFull();\n        lom = getMap();\n        try {\n            lom.setValue(-1, (V) StringUtils.EMPTY);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        try {\n            lom.setValue(lom.size(), (V) StringUtils.EMPTY);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n\n        for (int i = 0; i < lom.size(); i++) {\n            final V value = lom.getValue(i);\n            final Object input = Integer.valueOf(i);\n            assertEquals(value, lom.setValue(i, (V) input));\n            assertEquals(input, lom.getValue(i));\n        }\n    }\n\n    @Test\n    public void testValueList_getByIndex() {\n        resetFull();\n        final ListOrderedMap<K, V> lom = getMap();\n        for (int i = 0; i < lom.size(); i++) {\n            final V expected = lom.getValue(i);\n            assertEquals(expected, lom.valueList().get(i));\n        }\n    }\n\n    @Test\n    public void testValueList_removeByIndex() {\n        resetFull();\n        final ListOrderedMap<K, V> lom = getMap();\n        while (lom.size() > 1) {\n            final V expected = lom.getValue(1);\n            assertEquals(expected, lom.valueList().remove(1));\n        }\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/ListOrderedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/ListOrderedMap.fullCollection.version4.obj\");\n//    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testValueList_setByIndex() {\n        resetFull();\n        final ListOrderedMap<K, V> lom = getMap();\n        for (int i = 0; i < lom.size(); i++) {\n            final Object input = Integer.valueOf(i);\n            final V expected = lom.getValue(i);\n            assertEquals(expected, lom.valueList().set(i, (V) input));\n            assertEquals(input, lom.getValue(i));\n            assertEquals(input, lom.valueList().get(i));\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/CompositeMap_isEmptyTest.java.CompositeMap_isEmptyTest", "name": "CompositeMap_isEmptyTest", "file_path": "src/test/java/org/apache/commons/collections4/map/CompositeMap_isEmptyTest.java", "superclasses": "", "methods": ["[void]testIsEmptyWhenAllMapsAreEmpty()", "[void]testIsEmptyWhenOneMapIsNotEmpty()", "[void]testIsEmptyAfterClear()", "[void]testIsEmptyAfterAddingAndRemovingMap()", "[void]testIsEmptyWithMultipleMaps()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/CompositeMap_isEmptyTest.java.CompositeMap_isEmptyTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeMap_isEmptyTest {\n\n    private CompositeMap<String, String> compositeMap;\n\n    @BeforeEach\n    public void setUp() {\n        compositeMap = new CompositeMap<>();\n    }\n\n    @Test\n    public void testIsEmptyWhenAllMapsAreEmpty() {\n        assertTrue(compositeMap.isEmpty());\n    }\n\n    @Test\n    public void testIsEmptyWhenOneMapIsNotEmpty() {\n        Map<String, String> map1 = new HashMap<>();\n        map1.put(\"key1\", \"value1\");\n        compositeMap.addComposited(map1);\n        assertFalse(compositeMap.isEmpty());\n    }\n\n    @Test\n    public void testIsEmptyAfterClear() {\n        Map<String, String> map1 = new HashMap<>();\n        map1.put(\"key1\", \"value1\");\n        compositeMap.addComposited(map1);\n        compositeMap.clear();\n        assertTrue(compositeMap.isEmpty());\n    }\n\n    @Test\n    public void testIsEmptyAfterAddingAndRemovingMap() {\n        Map<String, String> map1 = new HashMap<>();\n        map1.put(\"key1\", \"value1\");\n        compositeMap.addComposited(map1);\n        compositeMap.removeComposited(map1);\n        assertTrue(compositeMap.isEmpty());\n    }\n\n    @Test\n    public void testIsEmptyWithMultipleMaps() {\n        Map<String, String> map1 = new HashMap<>();\n        Map<String, String> map2 = new HashMap<>();\n        map1.put(\"key1\", \"value1\");\n        map2.put(\"key2\", \"value2\");\n        compositeMap.addComposited(map1);\n        compositeMap.addComposited(map2);\n        assertFalse(compositeMap.isEmpty());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CompositeMap<String, String> compositeMap;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CompositeMap<String, String>", "name": "compositeMap", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_putAllTest.java.PassiveExpiringMap_putAllTest", "name": "PassiveExpiringMap_putAllTest", "file_path": "src/test/java/org/apache/commons/collections4/map/PassiveExpiringMap_putAllTest.java", "superclasses": "", "methods": ["[void]testPutAll()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PassiveExpiringMap_putAllTest {\n\n    @Test\n    public void testPutAll() {\n        // Given\n        PassiveExpiringMap<String, String> map = new PassiveExpiringMap<>(new PassiveExpiringMap.ConstantTimeToLiveExpirationPolicy<>(-1L));\n        Map<String, String> mapToCopy = new HashMap<>();\n        mapToCopy.put(\"key1\", \"value1\");\n        mapToCopy.put(\"key2\", \"value2\");\n\n        // When\n        map.putAll(mapToCopy);\n\n        // Then\n        assertEquals(2, map.size());\n        assertEquals(\"value1\", map.get(\"key1\"));\n        assertEquals(\"value2\", map.get(\"key2\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/DefaultedMapTest.java.DefaultedMapTest", "name": "DefaultedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/DefaultedMapTest.java", "superclasses": "", "methods": ["[void]testFactoryMethods()", "[void]testMapGet()", "[void]testMapGet2()", "[void]testMapGet3()", "[void]testMapGet4()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/DefaultedMapTest.java.DefaultedMapTest.[]DefaultedMapTest()", "src/test/java/org/apache/commons/collections4/map/DefaultedMapTest.java.DefaultedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/DefaultedMapTest.java.DefaultedMapTest.[IterableMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMapTest} for exercising the\n{@link DefaultedMap} implementation.\n", "original_string": "public class DefaultedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    protected final Factory<V> nullFactory = FactoryUtils.<V>nullFactory();\n    protected final Transformer<K, V> nullTransformer = TransformerUtils.<K, V>nullTransformer();\n\n    public DefaultedMapTest() {\n        super(DefaultedMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public IterableMap<K, V> makeObject() {\n        return DefaultedMap.defaultedMap(new HashMap<K, V>(), nullFactory);\n    }\n\n    @Test\n    public void testFactoryMethods() {\n        final HashMap<K, V> base = new HashMap<>();\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> DefaultedMap.defaultedMap(null, (V) \"DEFAULT_VALUE\"),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> DefaultedMap.defaultedMap((Map<K, V>) null, nullFactory),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> DefaultedMap.defaultedMap(base, (Factory<V>) null),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> DefaultedMap.defaultedMap((Map<K, V>) null, nullTransformer),\n                        \"Expecting NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> DefaultedMap.defaultedMap(base, (Transformer<K, V>) null),\n                        \"Expecting NullPointerException\")\n        );\n    }\n\n    @Test\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void testMapGet() {\n        final Map<K, V> map = new DefaultedMap<>((V) \"NULL\");\n\n        assertEquals(0, map.size());\n        assertFalse(map.containsKey(\"NotInMap\"));\n        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n\n        map.put((K) \"Key\", (V) \"Value\");\n        assertEquals(1, map.size());\n        assertTrue(map.containsKey(\"Key\"));\n        assertEquals(\"Value\", map.get(\"Key\"));\n        assertFalse(map.containsKey(\"NotInMap\"));\n        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMapGet2() {\n        final HashMap<K, V> base = new HashMap<>();\n        final Map<K, V> map = DefaultedMap.defaultedMap(base, (V) \"NULL\");\n\n        assertEquals(0, map.size());\n        assertEquals(0, base.size());\n        assertFalse(map.containsKey(\"NotInMap\"));\n        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n\n        map.put((K) \"Key\", (V) \"Value\");\n        assertEquals(1, map.size());\n        assertEquals(1, base.size());\n        assertTrue(map.containsKey(\"Key\"));\n        assertEquals(\"Value\", map.get(\"Key\"));\n        assertFalse(map.containsKey(\"NotInMap\"));\n        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMapGet3() {\n        final HashMap<K, V> base = new HashMap<>();\n        final Map<K, V> map = DefaultedMap.defaultedMap(base, ConstantFactory.constantFactory((V) \"NULL\"));\n\n        assertEquals(0, map.size());\n        assertEquals(0, base.size());\n        assertFalse(map.containsKey(\"NotInMap\"));\n        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n\n        map.put((K) \"Key\", (V) \"Value\");\n        assertEquals(1, map.size());\n        assertEquals(1, base.size());\n        assertTrue(map.containsKey(\"Key\"));\n        assertEquals(\"Value\", map.get(\"Key\"));\n        assertFalse(map.containsKey(\"NotInMap\"));\n        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMapGet4() {\n        final HashMap<K, V> base = new HashMap<>();\n        final Map<K, V> map = DefaultedMap.defaultedMap(base, (Transformer<K, V>) input -> {\n            if (input instanceof String) {\n                return (V) \"NULL\";\n            }\n            return (V) \"NULL_OBJECT\";\n        });\n\n        assertEquals(0, map.size());\n        assertEquals(0, base.size());\n        assertFalse(map.containsKey(\"NotInMap\"));\n        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n        assertEquals(\"NULL_OBJECT\", map.get(Integer.valueOf(0)));\n\n        map.put((K) \"Key\", (V) \"Value\");\n        assertEquals(1, map.size());\n        assertEquals(1, base.size());\n        assertTrue(map.containsKey(\"Key\"));\n        assertEquals(\"Value\", map.get(\"Key\"));\n        assertFalse(map.containsKey(\"NotInMap\"));\n        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n        assertEquals(\"NULL_OBJECT\", map.get(Integer.valueOf(0)));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/DefaultedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/DefaultedMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected final Factory<V> nullFactory = FactoryUtils.<V>nullFactory();", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Factory<V>", "name": "nullFactory = FactoryUtils.<V>nullFactory()", "syntax_pass": true}, {"attribute_expression": "protected final Transformer<K, V> nullTransformer = TransformerUtils.<K, V>nullTransformer();", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Transformer<K, V>", "name": "nullTransformer = TransformerUtils.<K, V>nullTransformer()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_putTest.java.MultiKeyMap_putTest", "name": "MultiKeyMap_putTest", "file_path": "src/test/java/org/apache/commons/collections4/map/MultiKeyMap_putTest.java", "superclasses": "", "methods": ["[void]testPutNewEntry()", "[void]testPutExistingEntry()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MultiKeyMap_putTest {\n\n    @Test\n    public void testPutNewEntry() {\n        MultiKeyMap<String, String> map = new MultiKeyMap<>();\n        String key1 = \"key1\";\n        String key2 = \"key2\";\n        String key3 = \"key3\";\n        String key4 = \"key4\";\n        String key5 = \"key5\";\n        String value = \"value\";\n\n        String result = map.put(key1, key2, key3, key4, key5, value);\n\n        assertNull(result);\n        assertEquals(value, map.get(key1, key2, key3, key4, key5));\n    }\n\n    @Test\n    public void testPutExistingEntry() {\n        MultiKeyMap<String, String> map = new MultiKeyMap<>();\n        String key1 = \"key1\";\n        String key2 = \"key2\";\n        String key3 = \"key3\";\n        String key4 = \"key4\";\n        String key5 = \"key5\";\n        String value1 = \"value1\";\n        String value2 = \"value2\";\n\n        map.put(key1, key2, key3, key4, key5, value1);\n        String result = map.put(key1, key2, key3, key4, key5, value2);\n\n        assertEquals(value1, result);\n        assertEquals(value2, map.get(key1, key2, key3, key4, key5));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/sequence/SequencesComparatorTest.java.SequencesComparatorTest", "name": "SequencesComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/sequence/SequencesComparatorTest.java", "superclasses": "", "methods": ["[void]testExecution()", "[void]testLength()", "[void]testMinimal()", "[void]testShadok()"], "method_uris": ["src/test/java/org/apache/commons/collections4/sequence/SequencesComparatorTest.java.SequencesComparatorTest.[List<Character>]sequence(String)", "src/test/java/org/apache/commons/collections4/sequence/SequencesComparatorTest.java.SequencesComparatorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/sequence/SequencesComparatorTest.java.SequencesComparatorTest.[void]tearDown()"], "overrides": null, "attributes": [{"original_string": "    private static final class ExecutionVisitor<T> implements CommandVisitor<T> {\n\n        private List<T> v;\n        private int index;\n\n        public String getString() {\n            final StringBuilder buffer = new StringBuilder();\n            for (final T c : v) {\n                buffer.append(c);\n            }\n            return buffer.toString();\n        }\n\n        public void setList(final List<T> array) {\n            v = new ArrayList<>(array);\n            index = 0;\n        }\n\n        @Override\n        public void visitDeleteCommand(final T object) {\n            v.remove(index);\n        }\n\n        @Override\n        public void visitInsertCommand(final T object) {\n            v.add(index++, object);\n        }\n\n        @Override\n        public void visitKeepCommand(final T object) {\n            ++index;\n        }\n\n    }", "definition": "    private static final class ExecutionVisitor<T> implements CommandVisitor<T>", "class_docstring": "", "name": "ExecutionVisitor", "super_interfaces": ["CommandVisitor<T>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private List<T> v;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<T>", "name": "v", "syntax_pass": true}, {"attribute_expression": "private int index;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "index", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getString() {\n            final StringBuilder buffer = new StringBuilder();\n            for (final T c : v) {\n                buffer.append(c);\n            }\n            return buffer.toString();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getString", "params": [], "body": "                                  {\n            final StringBuilder buffer = new StringBuilder();\n            for (final T c : v) {\n                buffer.append(c);\n            }\n            return buffer.toString();\n        }", "signature": "public String getString()"}, {"syntax_pass": true, "original_string": "        public void setList(final List<T> array) {\n            v = new ArrayList<>(array);\n            index = 0;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setList", "params": [{"name": "array", "type": "List<T>"}], "body": "                                                 {\n            v = new ArrayList<>(array);\n            index = 0;\n        }", "signature": "public void setList(final List<T> array)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void visitDeleteCommand(final T object) {\n            v.remove(index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visitDeleteCommand", "params": [{"name": "object", "type": "T"}], "body": "                                                       {\n            v.remove(index);\n        }", "signature": "@Override\n        public void visitDeleteCommand(final T object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void visitInsertCommand(final T object) {\n            v.add(index++, object);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visitInsertCommand", "params": [{"name": "object", "type": "T"}], "body": "                                                       {\n            v.add(index++, object);\n        }", "signature": "@Override\n        public void visitInsertCommand(final T object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void visitKeepCommand(final T object) {\n            ++index;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visitKeepCommand", "params": [{"name": "object", "type": "T"}], "body": "                                                     {\n            ++index;\n        }", "signature": "@Override\n        public void visitKeepCommand(final T object)"}]}], "class_docstring": "", "original_string": "public class SequencesComparatorTest {\n\n    private static final class ExecutionVisitor<T> implements CommandVisitor<T> {\n\n        private List<T> v;\n        private int index;\n\n        public String getString() {\n            final StringBuilder buffer = new StringBuilder();\n            for (final T c : v) {\n                buffer.append(c);\n            }\n            return buffer.toString();\n        }\n\n        public void setList(final List<T> array) {\n            v = new ArrayList<>(array);\n            index = 0;\n        }\n\n        @Override\n        public void visitDeleteCommand(final T object) {\n            v.remove(index);\n        }\n\n        @Override\n        public void visitInsertCommand(final T object) {\n            v.add(index++, object);\n        }\n\n        @Override\n        public void visitKeepCommand(final T object) {\n            ++index;\n        }\n\n    }\n    private List<String> before;\n    private List<String> after;\n\n    private int[]        length;\n\n    private List<Character> sequence(final String string) {\n        final List<Character> list = new ArrayList<>();\n        for (int i = 0; i < string.length(); ++i) {\n            list.add(Character.valueOf(string.charAt(i)));\n        }\n        return list;\n    }\n\n    @BeforeEach\n    public void setUp() {\n\n        before = Arrays.asList(\n            \"bottle\",\n            \"nematode knowledge\",\n            StringUtils.EMPTY,\n            \"aa\",\n            \"prefixed string\",\n            \"ABCABBA\",\n            \"glop glop\",\n            \"coq\",\n            \"spider-man\");\n\n        after = Arrays.asList(\n            \"noodle\",\n            \"empty bottle\",\n            StringUtils.EMPTY,\n            \"C\",\n            \"prefix\",\n            \"CBABAC\",\n            \"pas glop pas glop\",\n            \"ane\",\n            \"klingon\");\n\n        length = new int[] {\n            6,\n            16,\n            0,\n            3,\n            9,\n            5,\n            8,\n            6,\n            13\n        };\n\n    }\n\n    @AfterEach\n    public void tearDown() {\n        before = null;\n        after  = null;\n        length = null;\n    }\n\n    @Test\n    public void testExecution() {\n        final ExecutionVisitor<Character> ev = new ExecutionVisitor<>();\n        for (int i = 0; i < before.size(); ++i) {\n            ev.setList(sequence(before.get(i)));\n            new SequencesComparator<>(sequence(before.get(i)),\n                    sequence(after.get(i))).getScript().visit(ev);\n            assertEquals(after.get(i), ev.getString());\n        }\n    }\n\n    @Test\n    public void testLength() {\n        for (int i = 0; i < before.size(); ++i) {\n            final SequencesComparator<Character> comparator =\n                    new SequencesComparator<>(sequence(before.get(i)),\n                            sequence(after.get(i)));\n            assertEquals(length[i], comparator.getScript().getModifications());\n        }\n    }\n\n    @Test\n    public void testMinimal() {\n        final String[] shadokAlph = {\n            \"GA\",\n            \"BU\",\n            \"ZO\",\n            \"MEU\"\n        };\n        final List<String> sentenceBefore = new ArrayList<>();\n        final List<String> sentenceAfter  = new ArrayList<>();\n        sentenceBefore.add(shadokAlph[0]);\n        sentenceBefore.add(shadokAlph[2]);\n        sentenceBefore.add(shadokAlph[3]);\n        sentenceBefore.add(shadokAlph[1]);\n        sentenceBefore.add(shadokAlph[0]);\n        sentenceBefore.add(shadokAlph[0]);\n        sentenceBefore.add(shadokAlph[2]);\n        sentenceBefore.add(shadokAlph[1]);\n        sentenceBefore.add(shadokAlph[3]);\n        sentenceBefore.add(shadokAlph[0]);\n        sentenceBefore.add(shadokAlph[2]);\n        sentenceBefore.add(shadokAlph[1]);\n        sentenceBefore.add(shadokAlph[3]);\n        sentenceBefore.add(shadokAlph[2]);\n        sentenceBefore.add(shadokAlph[2]);\n        sentenceBefore.add(shadokAlph[0]);\n        sentenceBefore.add(shadokAlph[1]);\n        sentenceBefore.add(shadokAlph[3]);\n        sentenceBefore.add(shadokAlph[0]);\n        sentenceBefore.add(shadokAlph[3]);\n\n        final Random random = new Random(4564634237452342L);\n\n        for (int nbCom = 0; nbCom <= 40; nbCom += 5) {\n            sentenceAfter.clear();\n            sentenceAfter.addAll(sentenceBefore);\n            for (int i = 0; i < nbCom; i++) {\n                if (random.nextInt(2) == 0) {\n                    sentenceAfter.add(random.nextInt(sentenceAfter.size() + 1), shadokAlph[random.nextInt(4)]);\n                } else {\n                    sentenceAfter.remove(random.nextInt(sentenceAfter.size()));\n                }\n            }\n\n            final SequencesComparator<String> comparator = new SequencesComparator<>(sentenceBefore, sentenceAfter);\n            assertTrue(comparator.getScript().getModifications() <= nbCom);\n        }\n    }\n\n    @Test\n    public void testShadok() {\n        final int lgMax = 5;\n        final String[] shadokAlph = {\n            \"GA\",\n            \"BU\",\n            \"ZO\",\n            \"MEU\"\n        };\n        List<List<String>> shadokSentences = new ArrayList<>();\n        for (int lg = 0; lg < lgMax; ++lg) {\n            final List<List<String>> newTab = new ArrayList<>();\n            newTab.add(new ArrayList<>());\n            for (final String element : shadokAlph) {\n                for (final List<String> sentence : shadokSentences) {\n                    final List<String> newSentence = new ArrayList<>(sentence);\n                    newSentence.add(element);\n                    newTab.add(newSentence);\n                }\n            }\n            shadokSentences = newTab;\n        }\n\n        final ExecutionVisitor<String> ev = new ExecutionVisitor<>();\n\n        for (final List<String> element : shadokSentences) {\n            for (final List<String> shadokSentence : shadokSentences) {\n                ev.setList(element);\n                new SequencesComparator<>(element,\n                        shadokSentence).getScript().visit(ev);\n\n                final StringBuilder concat = new StringBuilder();\n                for (final String s : shadokSentence) {\n                    concat.append(s);\n                }\n                assertEquals(concat.toString(), ev.getString());\n            }\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<String> before;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "before", "syntax_pass": true}, {"attribute_expression": "private List<String> after;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "after", "syntax_pass": true}, {"attribute_expression": "private int[]        length;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int[]", "name": "length", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/sequence/SequencesComparator_getScriptTest.java.SequencesComparator_getScriptTest", "name": "SequencesComparator_getScriptTest", "file_path": "src/test/java/org/apache/commons/collections4/sequence/SequencesComparator_getScriptTest.java", "superclasses": "", "methods": ["[void]testGetScript()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SequencesComparator_getScriptTest {\n\n    @Test\n    public void testGetScript() {\n        List<String> sequence1 = Arrays.asList(\"A\", \"B\", \"C\");\n        List<String> sequence2 = Arrays.asList(\"A\", \"C\", \"D\");\n\n        SequencesComparator<String> comparator = new SequencesComparator<>(sequence1, sequence2);\n        EditScript<String> script = comparator.getScript();\n\n        assertEquals(2, script.getModifications());\n        assertEquals(2, script.getLCSLength()); // Corrected assertion\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/AllPredicate_allPredicateTest.java.AllPredicate_allPredicateTest", "name": "AllPredicate_allPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/AllPredicate_allPredicateTest.java", "superclasses": "", "methods": ["[void]testAllPredicate_EmptyCollection()", "[void]testAllPredicate_SinglePredicate()", "[void]testAllPredicate_MultiplePredicates()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class AllPredicate_allPredicateTest {\n\n    @Test\n    public void testAllPredicate_EmptyCollection() {\n        Collection<Predicate<Object>> predicates = Arrays.asList();\n        Predicate<Object> result = AllPredicate.allPredicate(predicates);\n        assertTrue(result.test(new Object()));\n    }\n\n    @Test\n    public void testAllPredicate_SinglePredicate() {\n        Predicate<Object> mockPredicate = mock(Predicate.class);\n        Object testObject = new Object();\n        when(mockPredicate.test(testObject)).thenReturn(true);\n\n        Collection<Predicate<Object>> predicates = Arrays.asList(mockPredicate);\n        Predicate<Object> result = AllPredicate.allPredicate(predicates);\n        assertTrue(result.test(testObject));\n    }\n\n    @Test\n    public void testAllPredicate_MultiplePredicates() {\n        Predicate<Object> mockPredicate1 = mock(Predicate.class);\n        Predicate<Object> mockPredicate2 = mock(Predicate.class);\n        Object testObject = new Object();\n        when(mockPredicate1.test(testObject)).thenReturn(true);\n        when(mockPredicate2.test(testObject)).thenReturn(true);\n\n        Collection<Predicate<Object>> predicates = Arrays.asList(mockPredicate1, mockPredicate2);\n        Predicate<Object> result = AllPredicate.allPredicate(predicates);\n        assertTrue(result.test(testObject));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/AllPredicate_testTest.java.AllPredicate_testTest", "name": "AllPredicate_testTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/AllPredicate_testTest.java", "superclasses": "", "methods": ["[void]testAllPredicatesTrue()", "[void]testOnePredicateFalse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class AllPredicate_testTest {\n\n    @Test\n    public void testAllPredicatesTrue() {\n        Predicate<String> predicate1 = mock(Predicate.class);\n        Predicate<String> predicate2 = mock(Predicate.class);\n\n        when(predicate1.test(\"testObject\")).thenReturn(true);\n        when(predicate2.test(\"testObject\")).thenReturn(true);\n\n        AllPredicate<String> allPredicate = new AllPredicate<>(predicate1, predicate2);\n        assertTrue(allPredicate.test(\"testObject\"));\n    }\n\n    @Test\n    public void testOnePredicateFalse() {\n        Predicate<String> predicate1 = mock(Predicate.class);\n        Predicate<String> predicate2 = mock(Predicate.class);\n\n        when(predicate1.test(\"testObject\")).thenReturn(true);\n        when(predicate2.test(\"testObject\")).thenReturn(false);\n\n        AllPredicate<String> allPredicate = new AllPredicate<>(predicate1, predicate2);\n        assertFalse(allPredicate.test(\"testObject\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/ComparatorPredicate_comparatorPredicateTest.java.ComparatorPredicate_comparatorPredicateTest", "name": "ComparatorPredicate_comparatorPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/ComparatorPredicate_comparatorPredicateTest.java", "superclasses": "", "methods": ["[void]testComparatorPredicate_WithNonNullComparatorAndCriterion()", "[void]testComparatorPredicate_WithNullComparator()", "[void]testComparatorPredicate_WithNullCriterion()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ComparatorPredicate_comparatorPredicateTest {\n\n    @Test\n    public void testComparatorPredicate_WithNonNullComparatorAndCriterion() {\n        // Given\n        Integer object = 10;\n        Comparator<Integer> comparator = Integer::compareTo;\n        ComparatorPredicate.Criterion criterion = ComparatorPredicate.Criterion.EQUAL;\n\n        // When\n        Predicate<Integer> predicate = ComparatorPredicate.comparatorPredicate(object, comparator, criterion);\n\n        // Then\n        assertTrue(predicate.test(10));\n    }\n\n    @Test\n    public void testComparatorPredicate_WithNullComparator() {\n        // Given\n        Integer object = 10;\n        Comparator<Integer> comparator = null;\n        ComparatorPredicate.Criterion criterion = ComparatorPredicate.Criterion.EQUAL;\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> {\n            ComparatorPredicate.comparatorPredicate(object, comparator, criterion);\n        });\n    }\n\n    @Test\n    public void testComparatorPredicate_WithNullCriterion() {\n        // Given\n        Integer object = 10;\n        Comparator<Integer> comparator = Integer::compareTo;\n        ComparatorPredicate.Criterion criterion = null;\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> {\n            ComparatorPredicate.comparatorPredicate(object, comparator, criterion);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/EqualPredicate_equalPredicateTest.java.EqualPredicate_equalPredicateTest", "name": "EqualPredicate_equalPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/EqualPredicate_equalPredicateTest.java", "superclasses": "", "methods": ["[void]testEqualPredicateWithNonNullObject()", "[void]testEqualPredicateWithNullObject()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class EqualPredicate_equalPredicateTest {\n\n    @Test\n    void testEqualPredicateWithNonNullObject() {\n        String input = \"test\";\n        Predicate<String> predicate = EqualPredicate.equalPredicate(input);\n        assertNotNull(predicate);\n        assertTrue(predicate.test(input));\n        assertFalse(predicate.test(\"other\"));\n    }\n\n    @Test\n    void testEqualPredicateWithNullObject() {\n        Predicate<String> predicate = EqualPredicate.equalPredicate(null);\n        assertNotNull(predicate);\n        assertTrue(predicate.test(null));\n        assertFalse(predicate.test(\"nonNull\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/NullPredicateTest.java.NullPredicateTest", "name": "NullPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/NullPredicateTest.java", "superclasses": "AbstractPredicateTest", "methods": ["[void]testEnsurePredicateCanBeTypedWithoutWarning()", "[void]testNullPredicate()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/NullPredicateTest.java.NullPredicateTest.[Predicate<?>]generatePredicate()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class NullPredicateTest extends AbstractPredicateTest {\n    @Override\n    protected Predicate<?> generatePredicate() {\n        return nullPredicate();\n    }\n\n    @Test\n    public void testEnsurePredicateCanBeTypedWithoutWarning() throws Exception {\n        final Predicate<String> predicate = NullPredicate.nullPredicate();\n        assertPredicateFalse(predicate, cString);\n    }\n\n    @Test\n    public void testNullPredicate() {\n        assertSame(NullPredicate.nullPredicate(), NullPredicate.nullPredicate());\n        assertPredicateTrue(nullPredicate(), null);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/EqualPredicate_testTest.java.EqualPredicate_testTest", "name": "EqualPredicate_testTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/EqualPredicate_testTest.java", "superclasses": "", "methods": ["[void]testWithEquator()", "[void]testWithoutEquator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class EqualPredicate_testTest {\n\n    @Test\n    public void testWithEquator() {\n        // Given\n        String value = \"test\";\n        Equator<String> equator = mock(Equator.class);\n        when(equator.equate(value, value)).thenReturn(true);\n        Predicate<String> predicate = EqualPredicate.equalPredicate(value, equator);\n\n        // When\n        boolean result = predicate.test(value);\n\n        // Then\n        assertTrue(result);\n        verify(equator).equate(value, value);\n    }\n\n    @Test\n    public void testWithoutEquator() {\n        // Given\n        String value = \"test\";\n        Predicate<String> predicate = EqualPredicate.equalPredicate(value);\n\n        // When\n        boolean result = predicate.test(value);\n\n        // Then\n        assertTrue(result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/EqualPredicateTest.java.EqualPredicateTest", "name": "EqualPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/EqualPredicateTest.java", "superclasses": "AbstractPredicateTest", "methods": ["[void]testNullArgumentEqualsNullPredicate()", "[void]testObjectFactoryUsesEqualsForTest()", "[void]testPredicateTypeCanBeSuperClassOfObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/EqualPredicateTest.java.EqualPredicateTest.[Predicate<Object>]generatePredicate()"], "overrides": null, "attributes": [{"original_string": "    public static class EqualsTestObject {\n        private final boolean b;\n\n        public EqualsTestObject(final boolean b) {\n            this.b = b;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            return b;\n        }\n    }", "definition": "    public static class EqualsTestObject", "class_docstring": "", "name": "EqualsTestObject", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final boolean b;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "b", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public EqualsTestObject(final boolean b) {\n            this.b = b;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "EqualsTestObject", "params": [{"name": "b", "type": "boolean"}], "body": "                                                 {\n            this.b = b;\n        }", "signature": "public EqualsTestObject(final boolean b)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            return b;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            return b;\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}]}], "class_docstring": "", "original_string": "public class EqualPredicateTest extends AbstractPredicateTest {\n    public static class EqualsTestObject {\n        private final boolean b;\n\n        public EqualsTestObject(final boolean b) {\n            this.b = b;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            return b;\n        }\n    }\n    private static final EqualsTestObject FALSE_OBJECT = new EqualsTestObject(false);\n\n    private static final EqualsTestObject TRUE_OBJECT = new EqualsTestObject(true);\n\n    @Override\n    protected Predicate<Object> generatePredicate() {\n        return equalPredicate(null);\n    }\n\n    @Test\n    public void testNullArgumentEqualsNullPredicate() throws Exception {\n        assertSame(nullPredicate(), equalPredicate(null));\n    }\n\n    @Test\n    public void testObjectFactoryUsesEqualsForTest() throws Exception {\n        final Predicate<EqualsTestObject> predicate = equalPredicate(FALSE_OBJECT);\n        assertPredicateFalse(predicate, FALSE_OBJECT);\n        assertPredicateTrue(equalPredicate(TRUE_OBJECT), TRUE_OBJECT);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    @Test\n    public void testPredicateTypeCanBeSuperClassOfObject() throws Exception {\n        final Predicate<Number> predicate = equalPredicate((Number) 4);\n        assertPredicateTrue(predicate, 4);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final EqualsTestObject FALSE_OBJECT = new EqualsTestObject(false);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "EqualsTestObject", "name": "FALSE_OBJECT = new EqualsTestObject(false)", "syntax_pass": true}, {"attribute_expression": "private static final EqualsTestObject TRUE_OBJECT = new EqualsTestObject(true);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "EqualsTestObject", "name": "TRUE_OBJECT = new EqualsTestObject(true)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/functors/AllPredicateTest.java.AllPredicateTest", "name": "AllPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/AllPredicateTest.java", "superclasses": "", "methods": ["[void]testAllTrue()", "[void]testEmptyArrayToGetInstance()", "[void]testEmptyCollectionToGetInstance()", "[void]testOneFalsePredicate()", "[void]testOneTruePredicate()", "[void]testTrueAndFalseCombined()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/AllPredicateTest.java.AllPredicateTest.[]AllPredicateTest()", "src/test/java/org/apache/commons/collections4/functors/AllPredicateTest.java.AllPredicateTest.[Predicate<Integer>]getPredicateInstance(Collection<Predicate<Integer>>)", "src/test/java/org/apache/commons/collections4/functors/AllPredicateTest.java.AllPredicateTest.[Predicate<Integer>]getPredicateInstance()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the org.apache.commons.collections.functors.AllPredicate class.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class AllPredicateTest extends AbstractAnyAllOnePredicateTest<Integer> {\n\n    /**\n     * Creates a new {@code TestAllPredicate}.\n     */\n    public AllPredicateTest() {\n        super(42);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected final Predicate<Integer> getPredicateInstance(final Collection<Predicate<Integer>> predicates) {\n        return AllPredicate.allPredicate(predicates);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected final Predicate<Integer> getPredicateInstance(final Predicate<? super Integer>... predicates) {\n        return AllPredicate.allPredicate(predicates);\n    }\n\n    /**\n     * Tests whether multiple true predicates evaluates to true.\n     */\n    @Test\n    public void testAllTrue() {\n        assertTrue(getPredicateInstance(true, true).evaluate(getTestValue()),\n                \"multiple true predicates evaluated to false\");\n        assertTrue(getPredicateInstance(true, true, true).evaluate(getTestValue()),\n                \"multiple true predicates evaluated to false\");\n    }\n\n    /**\n     * Verifies that providing an empty predicate array evaluates to true.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    @Test\n    public void testEmptyArrayToGetInstance() {\n        assertTrue(getPredicateInstance(new Predicate[] {}).evaluate(null), \"empty array not true\");\n    }\n\n    /**\n     * Verifies that providing an empty predicate collection evaluates to true.\n     */\n    @Test\n    public void testEmptyCollectionToGetInstance() {\n        final Predicate<Integer> allPredicate = getPredicateInstance(Collections.<Predicate<Integer>>emptyList());\n        assertTrue(allPredicate.evaluate(getTestValue()), \"empty collection not true\");\n    }\n\n    /**\n     * Tests whether a single false predicate evaluates to true.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testOneFalsePredicate() {\n        // use the constructor directly, as getInstance() returns the original predicate when passed\n        // an array of size one.\n        final Predicate<Integer> predicate = createMockPredicate(false);\n        assertFalse(allPredicate(predicate).test(getTestValue()), \"single false predicate evaluated to true\");\n    }\n\n    /**\n     * Tests whether a single true predicate evaluates to true.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testOneTruePredicate() {\n        // use the constructor directly, as getInstance() returns the original predicate when passed\n        // an array of size one.\n        final Predicate<Integer> predicate = createMockPredicate(true);\n        assertTrue(allPredicate(predicate).test(getTestValue()), \"single true predicate evaluated to false\");\n    }\n\n    /**\n     * Tests whether combining some true and one false evaluates to false.  Also verifies that only the first\n     * false predicate is actually evaluated\n     */\n    @Test\n    public void testTrueAndFalseCombined() {\n        assertFalse(getPredicateInstance(false, null).evaluate(getTestValue()),\n                \"false predicate evaluated to true\");\n        assertFalse(getPredicateInstance(false, null, null).evaluate(getTestValue()),\n                \"false predicate evaluated to true\");\n        assertFalse(getPredicateInstance(true, false, null).evaluate(getTestValue()),\n                \"false predicate evaluated to true\");\n        assertFalse(getPredicateInstance(true, true, false).evaluate(getTestValue()),\n                \"false predicate evaluated to true\");\n        assertFalse(getPredicateInstance(true, true, false, null).evaluate(getTestValue()),\n                \"false predicate evaluated to true\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/ComparatorPredicateTest.java.ComparatorPredicateTest", "name": "ComparatorPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/ComparatorPredicateTest.java", "superclasses": "AbstractPredicateTest", "methods": ["[void]testCompareEquals()", "[void]testCompareGreater()", "[void]testCompareGreaterOrEqual()", "[void]testCompareLess()", "[void]testCompareLessOrEqual()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/ComparatorPredicateTest.java.ComparatorPredicateTest.[Predicate<?>]generatePredicate()"], "overrides": null, "attributes": [{"original_string": "    private static final class TestComparator<T extends Comparable<T>> implements Comparator<T> {\n        @Override\n        public int compare(final T first, final T second) {\n            return first.compareTo(second);\n        }\n    }", "definition": "    private static final class TestComparator<T extends Comparable<T>> implements Comparator<T>", "class_docstring": "", "name": "TestComparator", "super_interfaces": ["Comparator<T>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public int compare(final T first, final T second) {\n            return first.compareTo(second);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "first", "type": "T"}, {"name": "second", "type": "T"}], "body": "                                                          {\n            return first.compareTo(second);\n        }", "signature": "@Override\n        public int compare(final T first, final T second)"}]}], "class_docstring": "", "original_string": "public class ComparatorPredicateTest extends AbstractPredicateTest {\n    private static final class TestComparator<T extends Comparable<T>> implements Comparator<T> {\n        @Override\n        public int compare(final T first, final T second) {\n            return first.compareTo(second);\n        }\n    }\n\n    @Override\n    protected Predicate<?> generatePredicate() {\n        return comparatorPredicate(Integer.valueOf(10), new TestComparator<>());\n    }\n\n    @Test\n    public void testCompareEquals() {\n        final Integer value = Integer.valueOf(10);\n        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<>());\n        assertPredicateFalse(p, Integer.valueOf(value.intValue() - 1));\n        assertPredicateTrue(p, Integer.valueOf(value.intValue()));\n        assertPredicateFalse(p, Integer.valueOf(value.intValue() + 1));\n    }\n\n    @Test\n    public void testCompareGreater() {\n        final Integer value = Integer.valueOf(10);\n        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<>(), Criterion.GREATER);\n        assertPredicateTrue(p, Integer.valueOf(value.intValue() - 1));\n        assertPredicateFalse(p, Integer.valueOf(value.intValue()));\n        assertPredicateFalse(p, Integer.valueOf(value.intValue() + 1));\n    }\n\n    @Test\n    public void testCompareGreaterOrEqual() {\n        final Integer value = Integer.valueOf(10);\n        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<>(), Criterion.GREATER_OR_EQUAL);\n        assertPredicateTrue(p, Integer.valueOf(value.intValue() - 1));\n        assertPredicateTrue(p, Integer.valueOf(value.intValue()));\n        assertPredicateFalse(p, Integer.valueOf(value.intValue() + 1));\n    }\n\n    @Test\n    public void testCompareLess() {\n        final Integer value = Integer.valueOf(10);\n        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<>(), Criterion.LESS);\n        assertPredicateFalse(p, Integer.valueOf(value.intValue() - 1));\n        assertPredicateFalse(p, Integer.valueOf(value.intValue()));\n        assertPredicateTrue(p, Integer.valueOf(value.intValue() + 1));\n    }\n\n    @Test\n    public void testCompareLessOrEqual() {\n        final Integer value = Integer.valueOf(10);\n        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<>(), Criterion.LESS_OR_EQUAL);\n        assertPredicateFalse(p, Integer.valueOf(value.intValue() - 1));\n        assertPredicateTrue(p, Integer.valueOf(value.intValue()));\n        assertPredicateTrue(p, Integer.valueOf(value.intValue() + 1));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/ComparatorChain_setComparatorTest.java.ComparatorChain_setComparatorTest", "name": "ComparatorChain_setComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/ComparatorChain_setComparatorTest.java", "superclasses": "", "methods": ["[void]testSetComparator_ForwardSort()", "[void]testSetComparator_ReverseSort()", "[void]testSetComparator_LockedChain()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ComparatorChain_setComparatorTest {\n\n    @Test\n    void testSetComparator_ForwardSort() {\n        // Given\n        ComparatorChain<String> chain = new ComparatorChain<>();\n        Comparator<String> comparator = Comparator.naturalOrder();\n        chain.addComparator(comparator);\n\n        // When\n        chain.setComparator(0, comparator, false);\n\n        // Then\n        assertFalse(chain.isLocked());\n    }\n\n    @Test\n    void testSetComparator_ReverseSort() {\n        // Given\n        ComparatorChain<String> chain = new ComparatorChain<>();\n        Comparator<String> comparator = Comparator.naturalOrder();\n        chain.addComparator(comparator);\n\n        // When\n        chain.setComparator(0, comparator, true);\n\n        // Then\n        assertFalse(chain.isLocked());\n    }\n\n    @Test\n    void testSetComparator_LockedChain() {\n        // Given\n        ComparatorChain<String> chain = new ComparatorChain<>();\n        Comparator<String> comparator = Comparator.naturalOrder();\n        chain.addComparator(comparator);\n        chain.compare(\"a\", \"b\"); // This will lock the chain\n\n        // When & Then\n        assertThrows(UnsupportedOperationException.class, () -> {\n            chain.setComparator(0, comparator, false);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/TransformingComparatorTest.java.TransformingComparatorTest", "name": "TransformingComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/TransformingComparatorTest.java", "superclasses": "", "methods": ["[void]testEquals()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/TransformingComparatorTest.java.TransformingComparatorTest.[]TransformingComparatorTest()", "src/test/java/org/apache/commons/collections4/comparators/TransformingComparatorTest.java.TransformingComparatorTest.[List<Integer>]getComparableObjectsOrdered()", "src/test/java/org/apache/commons/collections4/comparators/TransformingComparatorTest.java.TransformingComparatorTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/comparators/TransformingComparatorTest.java.TransformingComparatorTest.[Comparator<Integer>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTest class for TransformingComparator.\n", "original_string": "public class TransformingComparatorTest extends AbstractComparatorTest<Integer> {\n\n    //\n    // Initialization and busywork\n    //\n\n    public TransformingComparatorTest() {\n        super(TransformingComparatorTest.class.getSimpleName());\n    }\n\n    //\n    // Set up and tear down\n    //\n\n    @Override\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public List<Integer> getComparableObjectsOrdered() {\n        final List<Integer> list = new LinkedList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        list.add(5);\n        return list;\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Comparator<Integer> makeObject() {\n        final Comparator<String> decorated = new ComparableComparator<>();\n        return ComparatorUtils.transformedComparator(decorated, TransformerUtils.<Integer>stringValueTransformer());\n    }\n\n    @Test\n    public void testEquals() {\n        final Transformer<String, String> t1 = TransformerUtils.nopTransformer();\n        final TransformingComparator<String, String> comp1 = new TransformingComparator<>(t1);\n        final TransformingComparator<String, String> comp2 = new TransformingComparator<>(t1, comp1);\n\n        // Checks the contract: equals-hashCode on comp1 and comp2\n        assertTrue(comp1.equals(comp2) ? comp1.hashCode() == comp2.hashCode() : true,\n                \"Contract failed: equals-hashCode\");\n\n        // Checks the contract: equals-hashCode on comp1 and comp2\n        assertTrue(comp2.equals(comp1) ? comp2.hashCode() == comp1.hashCode() : true,\n                \"Contract failed: equals-hashCode\");\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/TransformingComparator.version4.obj\");\n//    }\n\n    //\n    // The tests\n    //\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_addTest.java.FixedOrderComparator_addTest", "name": "FixedOrderComparator_addTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_addTest.java", "superclasses": "", "methods": ["[void]testAddNewObject()", "[void]testAddWhenLocked()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_addTest.java.FixedOrderComparator_addTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FixedOrderComparator_addTest {\n\n    private FixedOrderComparator<String> comparator;\n\n    @BeforeEach\n    void setUp() {\n        comparator = new FixedOrderComparator<>();\n    }\n\n    @Test\n    void testAddNewObject() {\n        assertFalse(comparator.isLocked());\n        assertTrue(comparator.add(\"newObject\"));\n        assertFalse(comparator.add(\"newObject\"));\n    }\n\n    @Test\n    void testAddWhenLocked() {\n        comparator.add(\"obj1\"); // Add the object to avoid IllegalArgumentException\n        comparator.add(\"obj2\"); // Add the object to avoid IllegalArgumentException\n        comparator.compare(\"obj1\", \"obj2\"); // Lock the comparator\n        assertThrows(UnsupportedOperationException.class, () -> comparator.add(\"newObject\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private FixedOrderComparator<String> comparator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FixedOrderComparator<String>", "name": "comparator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_equalsTest.java.FixedOrderComparator_equalsTest", "name": "FixedOrderComparator_equalsTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_equalsTest.java", "superclasses": "", "methods": ["[void]testEqualsSameInstance()", "[void]testEqualsNull()", "[void]testEqualsDifferentClass()", "[void]testEqualsDifferentCounter()", "[void]testEqualsDifferentIsLocked()", "[void]testEqualsDifferentMap()", "[void]testEqualsDifferentUnknownObjectBehavior()", "[void]testEqualsIdentical()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_equalsTest.java.FixedOrderComparator_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FixedOrderComparator_equalsTest {\n\n    private FixedOrderComparator<String> comparator;\n\n    @BeforeEach\n    public void setUp() {\n        comparator = new FixedOrderComparator<>();\n    }\n\n    @Test\n    public void testEqualsSameInstance() {\n        assertTrue(comparator.equals(comparator));\n    }\n\n    @Test\n    public void testEqualsNull() {\n        assertFalse(comparator.equals(null));\n    }\n\n    @Test\n    public void testEqualsDifferentClass() {\n        assertFalse(comparator.equals(new Object()));\n    }\n\n    @Test\n    public void testEqualsDifferentCounter() {\n        FixedOrderComparator<String> other = new FixedOrderComparator<>();\n        comparator.add(\"A\");\n        assertFalse(comparator.equals(other));\n    }\n\n    @Test\n    public void testEqualsDifferentIsLocked() {\n        FixedOrderComparator<String> other = new FixedOrderComparator<>();\n        comparator.add(\"A\");\n        comparator.compare(\"A\", \"A\");\n        assertFalse(comparator.equals(other));\n    }\n\n    @Test\n    public void testEqualsDifferentMap() {\n        FixedOrderComparator<String> other = new FixedOrderComparator<>();\n        comparator.add(\"A\");\n        other.add(\"B\");\n        assertFalse(comparator.equals(other));\n    }\n\n    @Test\n    public void testEqualsDifferentUnknownObjectBehavior() {\n        FixedOrderComparator<String> other = new FixedOrderComparator<>();\n        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n        assertFalse(comparator.equals(other));\n    }\n\n    @Test\n    public void testEqualsIdentical() {\n        FixedOrderComparator<String> other = new FixedOrderComparator<>();\n        comparator.add(\"A\");\n        other.add(\"A\");\n        assertTrue(comparator.equals(other));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private FixedOrderComparator<String> comparator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FixedOrderComparator<String>", "name": "comparator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/TransformingComparator_equalsTest.java.TransformingComparator_equalsTest", "name": "TransformingComparator_equalsTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/TransformingComparator_equalsTest.java", "superclasses": "", "methods": ["[void]testEqualsSameObject()", "[void]testEqualsNullObject()", "[void]testEqualsDifferentClass()", "[void]testEqualsSameAttributes()", "[void]testEqualsDifferentTransformer()", "[void]testEqualsDifferentDecorated()", "[void]testEqualsHashCodeConsistency()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/TransformingComparator_equalsTest.java.TransformingComparator_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformingComparator_equalsTest {\n\n    private Transformer<String, String> transformer;\n    private TransformingComparator<String, String> comparator1;\n    private TransformingComparator<String, String> comparator2;\n\n    @BeforeEach\n    public void setUp() {\n        transformer = TransformerUtils.nopTransformer();\n        comparator1 = new TransformingComparator<>(transformer);\n        comparator2 = new TransformingComparator<>(transformer);\n    }\n\n    @Test\n    public void testEqualsSameObject() {\n        assertTrue(comparator1.equals(comparator1));\n    }\n\n    @Test\n    public void testEqualsNullObject() {\n        assertFalse(comparator1.equals(null));\n    }\n\n    @Test\n    public void testEqualsDifferentClass() {\n        assertFalse(comparator1.equals(\"Not a TransformingComparator\"));\n    }\n\n    @Test\n    public void testEqualsSameAttributes() {\n        assertTrue(comparator1.equals(comparator2));\n    }\n\n    @Test\n    public void testEqualsDifferentTransformer() {\n        TransformingComparator<String, String> comparator3 = new TransformingComparator<>(TransformerUtils.constantTransformer(\"Different\"));\n        assertFalse(comparator1.equals(comparator3));\n    }\n\n    @Test\n    public void testEqualsDifferentDecorated() {\n        TransformingComparator<String, String> comparator4 = new TransformingComparator<>(transformer, (o1, o2) -> o1.compareTo(o2));\n        assertFalse(comparator1.equals(comparator4));\n    }\n\n    @Test\n    public void testEqualsHashCodeConsistency() {\n        assertTrue(comparator1.equals(comparator2) ? comparator1.hashCode() == comparator2.hashCode() : true);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Transformer<String, String> transformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, String>", "name": "transformer", "syntax_pass": true}, {"attribute_expression": "private TransformingComparator<String, String> comparator1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransformingComparator<String, String>", "name": "comparator1", "syntax_pass": true}, {"attribute_expression": "private TransformingComparator<String, String> comparator2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransformingComparator<String, String>", "name": "comparator2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/ComparatorChain_addComparatorTest.java.ComparatorChain_addComparatorTest", "name": "ComparatorChain_addComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/ComparatorChain_addComparatorTest.java", "superclasses": "", "methods": ["[void]testAddComparator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ComparatorChain_addComparatorTest {\n\n    @Test\n    void testAddComparator() {\n        // Given\n        ComparatorChain<String> chain = new ComparatorChain<>();\n        Comparator<String> comparator = Comparator.naturalOrder();\n\n        // When\n        chain.addComparator(comparator, false);\n\n        // Then\n        assertEquals(1, chain.size());\n\n        // Given\n        chain = new ComparatorChain<>();\n\n        // When\n        chain.addComparator(comparator, true);\n\n        // Then\n        assertEquals(1, chain.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java.ComparatorChainTest", "name": "ComparatorChainTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java", "superclasses": "", "methods": ["[void]testBadListComparatorChain()", "[void]testBadNoopComparatorChain()", "[void]testComparatorChainOnMinValuedComparator()", "[void]testListComparatorChain()", "[void]testNoopComparatorChain()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java.ComparatorChainTest.[]ComparatorChainTest()", "src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java.ComparatorChainTest.[List<PseudoRow>]getComparableObjectsOrdered()", "src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java.ComparatorChainTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java.ComparatorChainTest.[Comparator<PseudoRow>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    public static class ColumnComparator implements Comparator<PseudoRow>, Serializable {\n        private static final long serialVersionUID = -2284880866328872105L;\n\n        protected int colIndex;\n\n        public ColumnComparator(final int colIndex) {\n            this.colIndex = colIndex;\n        }\n\n        @Override\n        public int compare(final PseudoRow o1, final PseudoRow o2) {\n            return Integer.compare(o1.getColumn(colIndex), o2.getColumn(colIndex));\n        }\n\n        @Override\n        public boolean equals(final Object that) {\n            return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;\n        }\n\n        @Override\n        public int hashCode() {\n            return colIndex;\n        }\n    }", "definition": "    public static class ColumnComparator implements Comparator<PseudoRow>, Serializable", "class_docstring": "", "name": "ColumnComparator", "super_interfaces": ["Comparator<PseudoRow>", "Serializable"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2284880866328872105L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2284880866328872105L", "syntax_pass": true}, {"attribute_expression": "protected int colIndex;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "colIndex", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ColumnComparator(final int colIndex) {\n            this.colIndex = colIndex;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ColumnComparator", "params": [{"name": "colIndex", "type": "int"}], "body": "                                                    {\n            this.colIndex = colIndex;\n        }", "signature": "public ColumnComparator(final int colIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int compare(final PseudoRow o1, final PseudoRow o2) {\n            return Integer.compare(o1.getColumn(colIndex), o2.getColumn(colIndex));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "o1", "type": "PseudoRow"}, {"name": "o2", "type": "PseudoRow"}], "body": "                                                                   {\n            return Integer.compare(o1.getColumn(colIndex), o2.getColumn(colIndex));\n        }", "signature": "@Override\n        public int compare(final PseudoRow o1, final PseudoRow o2)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object that) {\n            return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "that", "type": "Object"}], "body": "                                                 {\n            return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;\n        }", "signature": "@Override\n        public boolean equals(final Object that)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return colIndex;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return colIndex;\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    public static class PseudoRow implements Serializable {\n\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = 8085570439751032499L;\n        public int[] cols = new int[3];\n\n        public PseudoRow(final int col1, final int col2, final int col3) {\n            cols[0] = col1;\n            cols[1] = col2;\n            cols[2] = col3;\n        }\n\n        @Override\n        public boolean equals(final Object o) {\n            if (!(o instanceof PseudoRow)) {\n                return false;\n            }\n\n            final PseudoRow row = (PseudoRow) o;\n\n            return getColumn(0) == row.getColumn(0) && getColumn(1) == row.getColumn(1) && getColumn(2) == row.getColumn(2);\n        }\n\n        public int getColumn(final int colIndex) {\n            return cols[colIndex];\n        }\n\n        @Override\n        public String toString() {\n            return \"[\" + cols[0] + \",\" + cols[1] + \",\" + cols[2] + \"]\";\n        }\n    }", "definition": "    public static class PseudoRow implements Serializable", "class_docstring": "", "name": "PseudoRow", "super_interfaces": ["Serializable"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 8085570439751032499L;", "docstring": "\nGenerated serial version ID.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 8085570439751032499L", "syntax_pass": true}, {"attribute_expression": "public int[] cols = new int[3];", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int[]", "name": "cols = new int[3]", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public PseudoRow(final int col1, final int col2, final int col3) {\n            cols[0] = col1;\n            cols[1] = col2;\n            cols[2] = col3;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "PseudoRow", "params": [{"name": "col1", "type": "int"}, {"name": "col2", "type": "int"}, {"name": "col3", "type": "int"}], "body": "                                                                         {\n            cols[0] = col1;\n            cols[1] = col2;\n            cols[2] = col3;\n        }", "signature": "public PseudoRow(final int col1, final int col2, final int col3)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object o) {\n            if (!(o instanceof PseudoRow)) {\n                return false;\n            }\n\n            final PseudoRow row = (PseudoRow) o;\n\n            return getColumn(0) == row.getColumn(0) && getColumn(1) == row.getColumn(1) && getColumn(2) == row.getColumn(2);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n            if (!(o instanceof PseudoRow)) {\n                return false;\n            }\n\n            final PseudoRow row = (PseudoRow) o;\n\n            return getColumn(0) == row.getColumn(0) && getColumn(1) == row.getColumn(1) && getColumn(2) == row.getColumn(2);\n        }", "signature": "@Override\n        public boolean equals(final Object o)"}, {"syntax_pass": true, "original_string": "        public int getColumn(final int colIndex) {\n            return cols[colIndex];\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getColumn", "params": [{"name": "colIndex", "type": "int"}], "body": "                                                 {\n            return cols[colIndex];\n        }", "signature": "public int getColumn(final int colIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return \"[\" + cols[0] + \",\" + cols[1] + \",\" + cols[2] + \"]\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return \"[\" + cols[0] + \",\" + cols[1] + \",\" + cols[2] + \"]\";\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nTests for ComparatorChain.\n", "original_string": "public class ComparatorChainTest extends AbstractComparatorTest<ComparatorChainTest.PseudoRow> {\n\n    public static class ColumnComparator implements Comparator<PseudoRow>, Serializable {\n        private static final long serialVersionUID = -2284880866328872105L;\n\n        protected int colIndex;\n\n        public ColumnComparator(final int colIndex) {\n            this.colIndex = colIndex;\n        }\n\n        @Override\n        public int compare(final PseudoRow o1, final PseudoRow o2) {\n            return Integer.compare(o1.getColumn(colIndex), o2.getColumn(colIndex));\n        }\n\n        @Override\n        public boolean equals(final Object that) {\n            return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;\n        }\n\n        @Override\n        public int hashCode() {\n            return colIndex;\n        }\n    }\n\n    public static class PseudoRow implements Serializable {\n\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = 8085570439751032499L;\n        public int[] cols = new int[3];\n\n        public PseudoRow(final int col1, final int col2, final int col3) {\n            cols[0] = col1;\n            cols[1] = col2;\n            cols[2] = col3;\n        }\n\n        @Override\n        public boolean equals(final Object o) {\n            if (!(o instanceof PseudoRow)) {\n                return false;\n            }\n\n            final PseudoRow row = (PseudoRow) o;\n\n            return getColumn(0) == row.getColumn(0) && getColumn(1) == row.getColumn(1) && getColumn(2) == row.getColumn(2);\n        }\n\n        public int getColumn(final int colIndex) {\n            return cols[colIndex];\n        }\n\n        @Override\n        public String toString() {\n            return \"[\" + cols[0] + \",\" + cols[1] + \",\" + cols[2] + \"]\";\n        }\n    }\n\n    public ComparatorChainTest() {\n        super(ComparatorChainTest.class.getSimpleName());\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/ComparatorChain.version4.obj\");\n//    }\n\n    @Override\n    public List<PseudoRow> getComparableObjectsOrdered() {\n        // this is the correct order assuming a\n        // \"0th forward, 1st reverse, 2nd forward\" sort\n        return new LinkedList<>(Arrays.asList(new PseudoRow(1, 2, 3), new PseudoRow(2, 3, 5),\n                new PseudoRow(2, 2, 4), new PseudoRow(2, 2, 8), new PseudoRow(3, 1, 0),\n                new PseudoRow(4, 4, 4), new PseudoRow(4, 4, 7)));\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Comparator<PseudoRow> makeObject() {\n        final ComparatorChain<PseudoRow> chain = new ComparatorChain<>(new ColumnComparator(0));\n        chain.addComparator(new ColumnComparator(1), true); // reverse the second column\n        chain.addComparator(new ColumnComparator(2), false);\n        return chain;\n    }\n\n    @Test\n    public void testBadListComparatorChain() {\n        final List<Comparator<Integer>> list = new LinkedList<>();\n        final ComparatorChain<Integer> chain = new ComparatorChain<>(list);\n        final Integer i1 = 4;\n        final Integer i2 = 6;\n\n        assertThrows(UnsupportedOperationException.class, () -> chain.compare(i1, i2));\n    }\n\n    @Test\n    public void testBadNoopComparatorChain() {\n        final ComparatorChain<Integer> chain = new ComparatorChain<>();\n        final Integer i1 = 4;\n        final Integer i2 = 6;\n\n        assertThrows(UnsupportedOperationException.class, () -> chain.compare(i1, i2), \"An exception should be thrown when a chain contains zero comparators.\");\n    }\n\n    @Test\n    public void testComparatorChainOnMinValuedComparator() {\n        // -1 * Integer.MIN_VALUE is less than 0,\n        // test that ComparatorChain handles this edge case correctly\n        final ComparatorChain<Integer> chain = new ComparatorChain<>();\n        chain.addComparator((a, b) -> {\n            final int result = a.compareTo(b);\n            if (result < 0) {\n                return Integer.MIN_VALUE;\n            }\n            if (result > 0) {\n                return Integer.MAX_VALUE;\n            }\n            return 0;\n        }, true);\n\n        assertTrue(chain.compare(4, 5) > 0);\n        assertTrue(chain.compare(5, 4) < 0);\n        assertEquals(0, chain.compare(4, 4));\n    }\n\n    @Test\n    public void testListComparatorChain() {\n        final List<Comparator<Integer>> list = new LinkedList<>();\n        list.add(new ComparableComparator<>());\n        final ComparatorChain<Integer> chain = new ComparatorChain<>(list);\n        final Integer i1 = 4;\n        final Integer i2 = 6;\n\n        final int correctValue = i1.compareTo(i2);\n        assertEquals(chain.compare(i1, i2), correctValue, \"Comparison returns the right order\");\n    }\n\n    @Test\n    public void testNoopComparatorChain() {\n        final ComparatorChain<Integer> chain = new ComparatorChain<>();\n        final Integer i1 = 4;\n        final Integer i2 = 6;\n        chain.addComparator(new ComparableComparator<>());\n\n        final int correctValue = i1.compareTo(i2);\n        assertEquals(chain.compare(i1, i2), correctValue, \"Comparison returns the right order\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java.FixedOrderComparatorTest", "name": "FixedOrderComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java", "superclasses": "", "methods": ["[void]testAddAsEqual()", "[void]testArrayConstructor()", "[void]testConstructorPlusAdd()", "[void]testListConstructor()", "[void]testLock()", "[void]testUnknownObjectBehavior()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java.FixedOrderComparatorTest.[]FixedOrderComparatorTest()", "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java.FixedOrderComparatorTest.[void]assertComparatorYieldsOrder(String[],Comparator<String>)", "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java.FixedOrderComparatorTest.[List<String>]getComparableObjectsOrdered()", "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java.FixedOrderComparatorTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java.FixedOrderComparatorTest.[Comparator<String>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    @Nested\n    class Equals {\n\n        @Test\n        void expectFalseWhenBothComparatorsWithDifferentItems() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(2, 3, 4);\n            assertFalse(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectFalseWhenBothComparatorsWithDifferentUnknownObjectBehavior() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>();\n            comparator1.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>();\n            comparator2.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n            assertFalse(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectFalseWhenFixedOrderComparatorIsComparedWithNull() {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertFalse(comparator.equals(null));\n        }\n\n\n        @Test\n        void expectFalseWhenFixedOrderComparatorIsComparedWithOtherObject() {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertFalse(comparator.equals(new Object()));\n        }\n\n        @Test\n        void expectFalseWhenOneComparatorIsLocked() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3);\n            comparator2.compare(1, 2);\n            assertFalse(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectFalseWhenOneComparatorsWithDuplicateItems() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3, 3);\n            assertFalse(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectTrueWhenBothComparatorsAreLocked() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3);\n            comparator1.compare(1, 2);\n            comparator2.compare(1, 2);\n            assertTrue(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectTrueWhenBothComparatorsWithoutAnyItems() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>();\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>();\n            assertTrue(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectTrueWhenBothObjectsAreSame() {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertTrue(comparator.equals(comparator));\n        }\n    }", "definition": "    @Nested\n    class Equals", "class_docstring": "", "name": "Equals", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@Nested", "marker_annotations": ["@Nested"], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Test\n        void expectFalseWhenBothComparatorsWithDifferentItems() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(2, 3, 4);\n            assertFalse(comparator1.equals(comparator2));\n        }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "expectFalseWhenBothComparatorsWithDifferentItems", "params": [], "body": "                                                                {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(2, 3, 4);\n            assertFalse(comparator1.equals(comparator2));\n        }", "signature": "@Test\n        void expectFalseWhenBothComparatorsWithDifferentItems()"}, {"syntax_pass": true, "original_string": "        @Test\n        void expectFalseWhenBothComparatorsWithDifferentUnknownObjectBehavior() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>();\n            comparator1.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>();\n            comparator2.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n            assertFalse(comparator1.equals(comparator2));\n        }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "expectFalseWhenBothComparatorsWithDifferentUnknownObjectBehavior", "params": [], "body": "                                                                                {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>();\n            comparator1.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>();\n            comparator2.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n            assertFalse(comparator1.equals(comparator2));\n        }", "signature": "@Test\n        void expectFalseWhenBothComparatorsWithDifferentUnknownObjectBehavior()"}, {"syntax_pass": true, "original_string": "        @Test\n        void expectFalseWhenFixedOrderComparatorIsComparedWithNull() {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertFalse(comparator.equals(null));\n        }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "expectFalseWhenFixedOrderComparatorIsComparedWithNull", "params": [], "body": "                                                                     {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertFalse(comparator.equals(null));\n        }", "signature": "@Test\n        void expectFalseWhenFixedOrderComparatorIsComparedWithNull()"}, {"syntax_pass": true, "original_string": "        @Test\n        void expectFalseWhenFixedOrderComparatorIsComparedWithOtherObject() {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertFalse(comparator.equals(new Object()));\n        }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "expectFalseWhenFixedOrderComparatorIsComparedWithOtherObject", "params": [], "body": "                                                                            {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertFalse(comparator.equals(new Object()));\n        }", "signature": "@Test\n        void expectFalseWhenFixedOrderComparatorIsComparedWithOtherObject()"}, {"syntax_pass": true, "original_string": "        @Test\n        void expectFalseWhenOneComparatorIsLocked() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3);\n            comparator2.compare(1, 2);\n            assertFalse(comparator1.equals(comparator2));\n        }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "expectFalseWhenOneComparatorIsLocked", "params": [], "body": "                                                    {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3);\n            comparator2.compare(1, 2);\n            assertFalse(comparator1.equals(comparator2));\n        }", "signature": "@Test\n        void expectFalseWhenOneComparatorIsLocked()"}, {"syntax_pass": true, "original_string": "        @Test\n        void expectFalseWhenOneComparatorsWithDuplicateItems() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3, 3);\n            assertFalse(comparator1.equals(comparator2));\n        }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "expectFalseWhenOneComparatorsWithDuplicateItems", "params": [], "body": "                                                               {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3, 3);\n            assertFalse(comparator1.equals(comparator2));\n        }", "signature": "@Test\n        void expectFalseWhenOneComparatorsWithDuplicateItems()"}, {"syntax_pass": true, "original_string": "        @Test\n        void expectTrueWhenBothComparatorsAreLocked() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3);\n            comparator1.compare(1, 2);\n            comparator2.compare(1, 2);\n            assertTrue(comparator1.equals(comparator2));\n        }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "expectTrueWhenBothComparatorsAreLocked", "params": [], "body": "                                                      {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3);\n            comparator1.compare(1, 2);\n            comparator2.compare(1, 2);\n            assertTrue(comparator1.equals(comparator2));\n        }", "signature": "@Test\n        void expectTrueWhenBothComparatorsAreLocked()"}, {"syntax_pass": true, "original_string": "        @Test\n        void expectTrueWhenBothComparatorsWithoutAnyItems() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>();\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>();\n            assertTrue(comparator1.equals(comparator2));\n        }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "expectTrueWhenBothComparatorsWithoutAnyItems", "params": [], "body": "                                                            {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>();\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>();\n            assertTrue(comparator1.equals(comparator2));\n        }", "signature": "@Test\n        void expectTrueWhenBothComparatorsWithoutAnyItems()"}, {"syntax_pass": true, "original_string": "        @Test\n        void expectTrueWhenBothObjectsAreSame() {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertTrue(comparator.equals(comparator));\n        }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "expectTrueWhenBothObjectsAreSame", "params": [], "body": "                                                {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertTrue(comparator.equals(comparator));\n        }", "signature": "@Test\n        void expectTrueWhenBothObjectsAreSame()"}]}], "class_docstring": "\nTest class for FixedOrderComparator.\n", "original_string": "public class FixedOrderComparatorTest extends AbstractComparatorTest<String> {\n\n    @Nested\n    class Equals {\n\n        @Test\n        void expectFalseWhenBothComparatorsWithDifferentItems() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(2, 3, 4);\n            assertFalse(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectFalseWhenBothComparatorsWithDifferentUnknownObjectBehavior() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>();\n            comparator1.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>();\n            comparator2.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n            assertFalse(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectFalseWhenFixedOrderComparatorIsComparedWithNull() {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertFalse(comparator.equals(null));\n        }\n\n\n        @Test\n        void expectFalseWhenFixedOrderComparatorIsComparedWithOtherObject() {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertFalse(comparator.equals(new Object()));\n        }\n\n        @Test\n        void expectFalseWhenOneComparatorIsLocked() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3);\n            comparator2.compare(1, 2);\n            assertFalse(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectFalseWhenOneComparatorsWithDuplicateItems() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3, 3);\n            assertFalse(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectTrueWhenBothComparatorsAreLocked() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>(1, 2, 3);\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>(1, 2, 3);\n            comparator1.compare(1, 2);\n            comparator2.compare(1, 2);\n            assertTrue(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectTrueWhenBothComparatorsWithoutAnyItems() {\n            final FixedOrderComparator<Integer> comparator1 = new FixedOrderComparator<>();\n            final FixedOrderComparator<Integer> comparator2 = new FixedOrderComparator<>();\n            assertTrue(comparator1.equals(comparator2));\n        }\n\n        @Test\n        void expectTrueWhenBothObjectsAreSame() {\n            final FixedOrderComparator<Integer> comparator = new FixedOrderComparator<>();\n            assertTrue(comparator.equals(comparator));\n        }\n    }\n\n    //\n    // Initialization and busywork\n    //\n\n    /**\n     * Top cities of the world, by population including metro areas.\n     */\n    private static final String[] topCities = {\n        \"Tokyo\",\n        \"Mexico City\",\n        \"Mumbai\",\n        \"Sao Paulo\",\n        \"New York\",\n        \"Shanghai\",\n        \"Lagos\",\n        \"Los Angeles\",\n        \"Calcutta\",\n        \"Buenos Aires\"\n    };\n\n    //\n    // Set up and tear down\n    //\n\n    public FixedOrderComparatorTest() {\n        super(FixedOrderComparatorTest.class.getSimpleName());\n    }\n\n    /** Shuffles the keys and asserts that the comparator sorts them back to\n     * their original order.\n     */\n    private void assertComparatorYieldsOrder(final String[] orderedObjects, final Comparator<String> comparator) {\n        final String[] keys = orderedObjects.clone();\n\n        // shuffle until the order changes. It's extremely rare that\n        // this requires more than one shuffle.\n\n        boolean isInNewOrder = false;\n        final Random rand = new Random();\n        while (keys.length > 1 && !isInNewOrder) {\n            // shuffle:\n            for (int i = keys.length - 1; i > 0; i--) {\n                final String swap = keys[i];\n                final int j = rand.nextInt(i + 1);\n                keys[i] = keys[j];\n                keys[j] = swap;\n            }\n\n            // testShuffle\n            for (int i = 0; i < keys.length; i++) {\n                if (!orderedObjects[i].equals(keys[i])) {\n                    isInNewOrder = true;\n                    break;\n                }\n            }\n        }\n\n        // The real test: sort and make sure they come out right.\n\n        Arrays.sort(keys, comparator);\n\n        for (int i = 0; i < orderedObjects.length; i++) {\n            assertEquals(orderedObjects[i], keys[i]);\n        }\n    }\n\n    @Override\n    public List<String> getComparableObjectsOrdered() {\n        return Arrays.asList(topCities);\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/FixedOrderComparator.version4.obj\");\n//    }\n\n    //\n    // The tests\n    //\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Comparator<String> makeObject() {\n        return new FixedOrderComparator<>(topCities);\n    }\n\n    /**\n     * Tests addAsEqual method.\n     */\n    @Test\n    public void testAddAsEqual() {\n        final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCities);\n        comparator.addAsEqual(\"New York\", \"Minneapolis\");\n        assertEquals(0, comparator.compare(\"New York\", \"Minneapolis\"));\n        assertEquals(-1, comparator.compare(\"Tokyo\", \"Minneapolis\"));\n        assertEquals(1, comparator.compare(\"Shanghai\", \"Minneapolis\"));\n    }\n\n    /**\n     * Tests that the array constructor compares items properly.\n     */\n    @Test\n    public void testArrayConstructor() {\n        final String[] keys = topCities.clone();\n        final String[] topCitiesForTest = topCities.clone();\n        final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCitiesForTest);\n        assertComparatorYieldsOrder(keys, comparator);\n        // test that changing input after constructor has no effect\n        topCitiesForTest[0] = \"Brighton\";\n        assertComparatorYieldsOrder(keys, comparator);\n    }\n\n    /**\n     * Tests that the constructor plus add method compares items properly.\n     */\n    @Test\n    public void testConstructorPlusAdd() {\n        final FixedOrderComparator<String> comparator = new FixedOrderComparator<>();\n        for (final String topCity : topCities) {\n            comparator.add(topCity);\n        }\n        final String[] keys = topCities.clone();\n        assertComparatorYieldsOrder(keys, comparator);\n    }\n\n    /**\n     * Tests the list constructor.\n     */\n    @Test\n    public void testListConstructor() {\n        final String[] keys = topCities.clone();\n        final List<String> topCitiesForTest = new LinkedList<>(Arrays.asList(topCities));\n        final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCitiesForTest);\n        assertComparatorYieldsOrder(keys, comparator);\n        // test that changing input after constructor has no effect\n        topCitiesForTest.set(0, \"Brighton\");\n        assertComparatorYieldsOrder(keys, comparator);\n    }\n\n    //\n    // Helper methods\n    //\n\n    /**\n     * Tests whether or not updates are disabled after a comparison is made.\n     */\n    @Test\n    public void testLock() {\n        final FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCities);\n        assertFalse(comparator.isLocked());\n        comparator.compare(\"New York\", \"Tokyo\");\n        assertTrue(comparator.isLocked());\n\n        assertThrows(UnsupportedOperationException.class, () -> comparator.add(\"Minneapolis\"),\n                \"Should have thrown an UnsupportedOperationException\");\n\n        assertThrows(UnsupportedOperationException.class, () -> comparator.addAsEqual(\"New York\", \"Minneapolis\"),\n                \"Should have thrown an UnsupportedOperationException\");\n    }\n\n    @Test\n    public void testUnknownObjectBehavior() {\n        FixedOrderComparator<String> comparator = new FixedOrderComparator<>(topCities);\n\n        final FixedOrderComparator<String> finalComparator = comparator;\n        assertThrows(IllegalArgumentException.class, () -> finalComparator.compare(\"New York\", \"Minneapolis\"),\n                \"Should have thrown a IllegalArgumentException\");\n\n        assertThrows(IllegalArgumentException.class, () -> finalComparator.compare(\"Minneapolis\", \"New York\"),\n                \"Should have thrown a IllegalArgumentException\");\n\n        assertEquals(FixedOrderComparator.UnknownObjectBehavior.EXCEPTION, comparator.getUnknownObjectBehavior());\n\n        comparator = new FixedOrderComparator<>(topCities);\n        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n        assertEquals(FixedOrderComparator.UnknownObjectBehavior.BEFORE, comparator.getUnknownObjectBehavior());\n        LinkedList<String> keys = new LinkedList<>(Arrays.asList(topCities));\n        keys.addFirst(\"Minneapolis\");\n        assertComparatorYieldsOrder(keys.toArray(ArrayUtils.EMPTY_STRING_ARRAY), comparator);\n\n        assertEquals(-1, comparator.compare(\"Minneapolis\", \"New York\"));\n        assertEquals( 1, comparator.compare(\"New York\", \"Minneapolis\"));\n        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n\n        comparator = new FixedOrderComparator<>(topCities);\n        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n        keys = new LinkedList<>(Arrays.asList(topCities));\n        keys.add(\"Minneapolis\");\n        assertComparatorYieldsOrder(keys.toArray(ArrayUtils.EMPTY_STRING_ARRAY), comparator);\n\n        assertEquals( 1, comparator.compare(\"Minneapolis\", \"New York\"));\n        assertEquals(-1, comparator.compare(\"New York\", \"Minneapolis\"));\n        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String[] topCities = {\n        \"Tokyo\",\n        \"Mexico City\",\n        \"Mumbai\",\n        \"Sao Paulo\",\n        \"New York\",\n        \"Shanghai\",\n        \"Lagos\",\n        \"Los Angeles\",\n        \"Calcutta\",\n        \"Buenos Aires\"\n    };", "docstring": "\nTop cities of the world, by population including metro areas.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "topCities = {\n        \"Tokyo\",\n        \"Mexico City\",\n        \"Mumbai\",\n        \"Sao Paulo\",\n        \"New York\",\n        \"Shanghai\",\n        \"Lagos\",\n        \"Los Angeles\",\n        \"Calcutta\",\n        \"Buenos Aires\"\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/TransformingComparator_compareTest.java.TransformingComparator_compareTest", "name": "TransformingComparator_compareTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/TransformingComparator_compareTest.java", "superclasses": "", "methods": ["[void]testCompare()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformingComparator_compareTest {\n\n    @Test\n    public void testCompare() {\n        // Given\n        Transformer<Integer, String> transformer = mock(Transformer.class);\n        Comparator<String> decorated = mock(Comparator.class);\n        TransformingComparator<Integer, String> comparator = new TransformingComparator<>(transformer, decorated);\n\n        Integer obj1 = 1;\n        Integer obj2 = 2;\n        String transformedValue1 = \"1\";\n        String transformedValue2 = \"2\";\n\n        when(transformer.apply(obj1)).thenReturn(transformedValue1);\n        when(transformer.apply(obj2)).thenReturn(transformedValue2);\n        when(decorated.compare(transformedValue1, transformedValue2)).thenReturn(-1);\n\n        // When\n        int result = comparator.compare(obj1, obj2);\n\n        // Then\n        assertEquals(-1, result);\n        verify(transformer, times(1)).apply(obj1);\n        verify(transformer, times(1)).apply(obj2);\n        verify(decorated, times(1)).compare(transformedValue1, transformedValue2);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/BooleanComparator_hashCodeTest.java.BooleanComparator_hashCodeTest", "name": "BooleanComparator_hashCodeTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/BooleanComparator_hashCodeTest.java", "superclasses": "", "methods": ["[void]testHashCodeTrueFirst()", "[void]testHashCodeFalseFirst()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BooleanComparator_hashCodeTest {\n\n    @Test\n    public void testHashCodeTrueFirst() {\n        BooleanComparator comparator = new BooleanComparator(true);\n        int expectedHash = -1 * \"BooleanComparator\".hashCode();\n        assertEquals(expectedHash, comparator.hashCode());\n    }\n\n    @Test\n    public void testHashCodeFalseFirst() {\n        BooleanComparator comparator = new BooleanComparator(false);\n        int expectedHash = \"BooleanComparator\".hashCode();\n        assertEquals(expectedHash, comparator.hashCode());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_compareTest.java.FixedOrderComparator_compareTest", "name": "FixedOrderComparator_compareTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_compareTest.java", "superclasses": "", "methods": ["[void]testCompareKnownObjects()", "[void]testCompareUnknownObjectBehaviorException()", "[void]testCompareUnknownObjectBehaviorBefore()", "[void]testCompareUnknownObjectBehaviorAfter()", "[void]testAddAndCompare()", "[void]testAddAsEqualAndCompare()", "[void]testIsLocked()", "[void]testSetUnknownObjectBehaviorLocked()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_compareTest.java.FixedOrderComparator_compareTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FixedOrderComparator_compareTest {\n\n    private FixedOrderComparator<String> comparator;\n    private String[] topCities = {\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\", \"Phoenix\"};\n\n    @BeforeEach\n    public void setUp() {\n        comparator = new FixedOrderComparator<>(topCities);\n    }\n\n    @Test\n    public void testCompareKnownObjects() {\n        assertEquals(-1, comparator.compare(\"New York\", \"Los Angeles\"));\n        assertEquals(1, comparator.compare(\"Los Angeles\", \"New York\"));\n        assertEquals(0, comparator.compare(\"New York\", \"New York\"));\n    }\n\n    @Test\n    public void testCompareUnknownObjectBehaviorException() {\n        assertThrows(IllegalArgumentException.class, () -> comparator.compare(\"Minneapolis\", \"New York\"));\n        assertThrows(IllegalArgumentException.class, () -> comparator.compare(\"New York\", \"Minneapolis\"));\n    }\n\n    @Test\n    public void testCompareUnknownObjectBehaviorBefore() {\n        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n        assertEquals(-1, comparator.compare(\"Minneapolis\", \"New York\"));\n        assertEquals(1, comparator.compare(\"New York\", \"Minneapolis\"));\n        assertEquals(0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n    }\n\n    @Test\n    public void testCompareUnknownObjectBehaviorAfter() {\n        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n        assertEquals(1, comparator.compare(\"Minneapolis\", \"New York\"));\n        assertEquals(-1, comparator.compare(\"New York\", \"Minneapolis\"));\n        assertEquals(0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n    }\n\n    @Test\n    public void testAddAndCompare() {\n        comparator.add(\"Minneapolis\");\n        assertEquals(1, comparator.compare(\"Minneapolis\", \"New York\"));\n        assertEquals(-1, comparator.compare(\"New York\", \"Minneapolis\"));\n    }\n\n    @Test\n    public void testAddAsEqualAndCompare() {\n        comparator.addAsEqual(\"New York\", \"Minneapolis\");\n        assertEquals(0, comparator.compare(\"Minneapolis\", \"New York\"));\n        assertEquals(0, comparator.compare(\"New York\", \"Minneapolis\"));\n    }\n\n    @Test\n    public void testIsLocked() {\n        assertFalse(comparator.isLocked());\n        comparator.compare(\"New York\", \"Los Angeles\");\n        assertTrue(comparator.isLocked());\n    }\n\n    @Test\n    public void testSetUnknownObjectBehaviorLocked() {\n        comparator.compare(\"New York\", \"Los Angeles\");\n        assertThrows(UnsupportedOperationException.class, () -> comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private FixedOrderComparator<String> comparator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FixedOrderComparator<String>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private String[] topCities = {\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\", \"Phoenix\"};", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String[]", "name": "topCities = {\"New York\", \"Los Angeles\", \"Chicago\", \"Houston\", \"Phoenix\"}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/TransformingComparator_hashCodeTest.java.TransformingComparator_hashCodeTest", "name": "TransformingComparator_hashCodeTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/TransformingComparator_hashCodeTest.java", "superclasses": "", "methods": ["[void]testHashCodeWithNonNullDecoratedAndTransformer()", "[void]testHashCodeWithNullDecorated()", "[void]testHashCodeWithNullTransformer()", "[void]testHashCodeWithNullDecoratedAndTransformer()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/TransformingComparator_hashCodeTest.java.TransformingComparator_hashCodeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformingComparator_hashCodeTest {\n\n    private Transformer<String, String> transformer;\n    private TransformingComparator<String, String> comparator;\n\n    @BeforeEach\n    public void setUp() {\n        transformer = TransformerUtils.nopTransformer();\n        comparator = new TransformingComparator<>(transformer);\n    }\n\n    @Test\n    public void testHashCodeWithNonNullDecoratedAndTransformer() {\n        TransformingComparator<String, String> comparatorWithDecorated = new TransformingComparator<>(transformer, comparator);\n        int expectedHashCode = 17 * 37 + comparator.hashCode();\n        expectedHashCode = expectedHashCode * 37 + transformer.hashCode();\n        assertEquals(expectedHashCode, comparatorWithDecorated.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNullDecorated() {\n        TransformingComparator<String, String> comparatorWithNullDecorated = new TransformingComparator<>(transformer, null);\n        int expectedHashCode = 17 * 37 + 0;\n        expectedHashCode = expectedHashCode * 37 + transformer.hashCode();\n        assertEquals(expectedHashCode, comparatorWithNullDecorated.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNullTransformer() {\n        TransformingComparator<String, String> comparatorWithNullTransformer = new TransformingComparator<>(null, comparator);\n        int expectedHashCode = 17 * 37 + comparator.hashCode();\n        expectedHashCode = expectedHashCode * 37 + 0;\n        assertEquals(expectedHashCode, comparatorWithNullTransformer.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNullDecoratedAndTransformer() {\n        TransformingComparator<String, String> comparatorWithNulls = new TransformingComparator<>(null, null);\n        int expectedHashCode = 17 * 37 + 0;\n        expectedHashCode = expectedHashCode * 37 + 0;\n        assertEquals(expectedHashCode, comparatorWithNulls.hashCode());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Transformer<String, String> transformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<String, String>", "name": "transformer", "syntax_pass": true}, {"attribute_expression": "private TransformingComparator<String, String> comparator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransformingComparator<String, String>", "name": "comparator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/BooleanComparator_equalsTest.java.BooleanComparator_equalsTest", "name": "BooleanComparator_equalsTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/BooleanComparator_equalsTest.java", "superclasses": "", "methods": ["[void]testEqualsWithSameInstance()", "[void]testEqualsWithDifferentInstanceSameOrder()", "[void]testEqualsWithDifferentInstanceDifferentOrder()", "[void]testEqualsWithNonBooleanComparatorInstance()", "[void]testEqualsWithNull()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BooleanComparator_equalsTest {\n\n    @Test\n    public void testEqualsWithSameInstance() {\n        BooleanComparator comparator = BooleanComparator.getTrueFirstComparator();\n        assertTrue(comparator.equals(comparator));\n    }\n\n    @Test\n    public void testEqualsWithDifferentInstanceSameOrder() {\n        BooleanComparator trueFirst1 = BooleanComparator.getTrueFirstComparator();\n        BooleanComparator trueFirst2 = BooleanComparator.booleanComparator(true);\n        assertTrue(trueFirst1.equals(trueFirst2));\n    }\n\n    @Test\n    public void testEqualsWithDifferentInstanceDifferentOrder() {\n        BooleanComparator trueFirst = BooleanComparator.getTrueFirstComparator();\n        BooleanComparator falseFirst = BooleanComparator.getFalseFirstComparator();\n        assertFalse(trueFirst.equals(falseFirst));\n    }\n\n    @Test\n    public void testEqualsWithNonBooleanComparatorInstance() {\n        BooleanComparator trueFirst = BooleanComparator.getTrueFirstComparator();\n        Object nonComparator = new Object();\n        assertFalse(trueFirst.equals(nonComparator));\n    }\n\n    @Test\n    public void testEqualsWithNull() {\n        BooleanComparator trueFirst = BooleanComparator.getTrueFirstComparator();\n        assertFalse(trueFirst.equals(null));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest", "name": "BooleanComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java", "superclasses": "", "methods": ["[void]testConstructors()", "[void]testEqualsCompatibleInstance()", "[void]testStaticFactoryMethods()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest.[]BooleanComparatorTest()", "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest.[void]allTests(boolean,BooleanComparator)", "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest.[void]falseFirstTests(BooleanComparator)", "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest.[List<Boolean>]getComparableObjectsOrdered()", "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest.[Comparator<Boolean>]makeObject()", "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest.[void]nullArgumentTests(BooleanComparator)", "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest.[void]orderIndependentTests(BooleanComparator)", "src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java.BooleanComparatorTest.[void]trueFirstTests(BooleanComparator)"], "overrides": null, "attributes": [], "class_docstring": "\nTests for {@link BooleanComparator}.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class BooleanComparatorTest extends AbstractComparatorTest<Boolean> {\n\n    public BooleanComparatorTest() {\n        super(BooleanComparatorTest.class.getSimpleName());\n    }\n\n    protected void allTests(final boolean trueFirst, final BooleanComparator comp) {\n        orderIndependentTests(comp);\n        if (trueFirst) {\n            trueFirstTests(comp);\n        } else {\n            falseFirstTests(comp);\n        }\n    }\n\n    protected void falseFirstTests(final BooleanComparator comp) {\n        assertNotNull(comp);\n        assertEquals(0, comp.compare(true, true));\n        assertEquals(0, comp.compare(false, false));\n        assertTrue(comp.compare(false, true) < 0);\n        assertTrue(comp.compare(true, false) > 0);\n    }\n\n    @Override\n    public List<Boolean> getComparableObjectsOrdered() {\n        return new ArrayList<>(Arrays.asList(Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, Boolean.TRUE, Boolean.TRUE,\n                true));\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/BooleanComparator.version4.obj\");\n//    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Comparator<Boolean> makeObject() {\n        return new BooleanComparator();\n    }\n\n    protected void nullArgumentTests(final BooleanComparator comp) {\n        assertNotNull(comp);\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> comp.compare(null, null), \"Expected NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> comp.compare(Boolean.TRUE, null), \"Expected NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> comp.compare(Boolean.FALSE, null), \"Expected NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> comp.compare(null, Boolean.TRUE), \"Expected NullPointerException\"),\n                () -> assertThrows(NullPointerException.class, () -> comp.compare(null, Boolean.FALSE), \"Expected NullPointerException\")\n        );\n    }\n\n    protected void orderIndependentTests(final BooleanComparator comp) {\n        nullArgumentTests(comp);\n    }\n\n    @Test\n    public void testConstructors() {\n        allTests(false, new BooleanComparator());\n        allTests(false, new BooleanComparator(false));\n        allTests(true, new BooleanComparator(true));\n    }\n\n    @Test\n    public void testEqualsCompatibleInstance() {\n        assertEquals(new BooleanComparator(), new BooleanComparator(false));\n        assertEquals(new BooleanComparator(false), new BooleanComparator(false));\n        assertEquals(new BooleanComparator(false), BooleanComparator.getFalseFirstComparator());\n        assertSame(BooleanComparator.getFalseFirstComparator(), BooleanComparator.booleanComparator(false));\n\n        assertEquals(new BooleanComparator(true), new BooleanComparator(true));\n        assertEquals(new BooleanComparator(true), BooleanComparator.getTrueFirstComparator());\n        assertSame(BooleanComparator.getTrueFirstComparator(), BooleanComparator.booleanComparator(true));\n\n        assertNotEquals(new BooleanComparator(), new BooleanComparator(true));\n        assertNotEquals(new BooleanComparator(true), new BooleanComparator(false));\n    }\n\n    @Test\n    public void testStaticFactoryMethods() {\n        allTests(false, BooleanComparator.getFalseFirstComparator());\n        allTests(false, BooleanComparator.booleanComparator(false));\n        allTests(true, BooleanComparator.getTrueFirstComparator());\n        allTests(true, BooleanComparator.booleanComparator(true));\n    }\n\n    protected void trueFirstTests(final BooleanComparator comp) {\n        assertNotNull(comp);\n        assertEquals(0, comp.compare(true, true));\n        assertEquals(0, comp.compare(false, false));\n        assertTrue(comp.compare(false, true) > 0);\n        assertTrue(comp.compare(true, false) < 0);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/BooleanComparator_compareTest.java.BooleanComparator_compareTest", "name": "BooleanComparator_compareTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/BooleanComparator_compareTest.java", "superclasses": "", "methods": ["[void]testCompareTrueFirst()", "[void]testCompareFalseFirst()", "[void]testCompareNullArguments()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BooleanComparator_compareTest {\n\n    @Test\n    public void testCompareTrueFirst() {\n        BooleanComparator comparator = BooleanComparator.getTrueFirstComparator();\n\n        assertEquals(-1, comparator.compare(Boolean.TRUE, Boolean.FALSE));\n        assertEquals(1, comparator.compare(Boolean.FALSE, Boolean.TRUE));\n        assertEquals(0, comparator.compare(Boolean.TRUE, Boolean.TRUE));\n        assertEquals(0, comparator.compare(Boolean.FALSE, Boolean.FALSE));\n    }\n\n    @Test\n    public void testCompareFalseFirst() {\n        BooleanComparator comparator = BooleanComparator.getFalseFirstComparator();\n\n        assertEquals(1, comparator.compare(Boolean.TRUE, Boolean.FALSE));\n        assertEquals(-1, comparator.compare(Boolean.FALSE, Boolean.TRUE));\n        assertEquals(0, comparator.compare(Boolean.TRUE, Boolean.TRUE));\n        assertEquals(0, comparator.compare(Boolean.FALSE, Boolean.FALSE));\n    }\n\n    @Test\n    public void testCompareNullArguments() {\n        BooleanComparator comparator = BooleanComparator.getTrueFirstComparator();\n\n        assertThrows(NullPointerException.class, () -> comparator.compare(null, Boolean.TRUE));\n        assertThrows(NullPointerException.class, () -> comparator.compare(Boolean.TRUE, null));\n        assertThrows(NullPointerException.class, () -> comparator.compare(null, null));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java.ReverseComparatorTest", "name": "ReverseComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java", "superclasses": "", "methods": ["[void]testSerializeDeserializeThenCompare()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java.ReverseComparatorTest.[]ReverseComparatorTest()", "src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java.ReverseComparatorTest.[List<Integer>]getComparableObjectsOrdered()", "src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java.ReverseComparatorTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java.ReverseComparatorTest.[Comparator<Integer>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for ReverseComparator.\n", "original_string": "public class ReverseComparatorTest extends AbstractComparatorTest<Integer> {\n\n    public ReverseComparatorTest() {\n        super(ReverseComparatorTest.class.getSimpleName());\n    }\n\n    @Override\n    public List<Integer> getComparableObjectsOrdered() {\n        final List<Integer> list = new LinkedList<>();\n        list.add(Integer.valueOf(1));\n        list.add(Integer.valueOf(2));\n        list.add(Integer.valueOf(3));\n        list.add(Integer.valueOf(4));\n        list.add(Integer.valueOf(5));\n        return list;\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/ReverseComparator.version4.obj\");\n//    }\n\n    /**\n     * For the purposes of this test, return a\n     * ReverseComparator that wraps the java.util.Collections.reverseOrder()\n     * Comparator.  The resulting comparator should\n     * sort according to natural Order.  (Note: we wrap\n     * a Comparator taken from the JDK so that we can\n     * save a \"canonical\" form in SCM).\n     *\n     * @return Comparator that returns \"natural\" order\n     */\n    @Override\n    public Comparator<Integer> makeObject() {\n        return new ReverseComparator<>(Collections.<Integer>reverseOrder());\n    }\n\n    /**\n     * Override this inherited test since Collections.reverseOrder\n     * doesn't adhere to the \"soft\" Comparator contract, and we've\n     * already \"canonized\" the comparator returned by makeComparator.\n     */\n    @Test\n    @Override\n    public void testSerializeDeserializeThenCompare() throws Exception {\n        final Comparator<?> comp = new ReverseComparator<>(new ComparableComparator<>());\n\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n        out.writeObject(comp);\n        out.close();\n\n        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n        final Object dest = in.readObject();\n        in.close();\n        assertEquals(comp, dest, \"obj != deserialize(serialize(obj))\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/ReverseComparator_equalsTest.java.ReverseComparator_equalsTest", "name": "ReverseComparator_equalsTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/ReverseComparator_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ReverseComparator_equalsTest {\n\n    @Test\n    void testEquals() {\n        Comparator<Integer> naturalOrder = Comparator.naturalOrder();\n        ReverseComparator<Integer> rc1 = new ReverseComparator<>(naturalOrder);\n        ReverseComparator<Integer> rc2 = new ReverseComparator<>(naturalOrder);\n        ReverseComparator<Integer> rc3 = new ReverseComparator<>(Comparator.reverseOrder());\n\n        // Test same instance\n        assertTrue(rc1.equals(rc1));\n\n        // Test null\n        assertFalse(rc1.equals(null));\n\n        // Test different class\n        assertFalse(rc1.equals(\"Not a ReverseComparator\"));\n\n        // Test same class, same comparator\n        assertTrue(rc1.equals(rc2));\n\n        // Test same class, different comparator\n        assertFalse(rc1.equals(rc3));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_addAsEqualTest.java.FixedOrderComparator_addAsEqualTest", "name": "FixedOrderComparator_addAsEqualTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_addAsEqualTest.java", "superclasses": "", "methods": ["[void]testAddAsEqual_NewObjectAdded()", "[void]testAddAsEqual_ExistingObjectNotKnown()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparator_addAsEqualTest.java.FixedOrderComparator_addAsEqualTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FixedOrderComparator_addAsEqualTest {\n\n    private FixedOrderComparator<String> comparator;\n\n    @BeforeEach\n    void setUp() {\n        comparator = new FixedOrderComparator<>(Arrays.asList(\"existingObj\"));\n    }\n\n    @Test\n    void testAddAsEqual_NewObjectAdded() {\n        // Given\n        String existingObj = \"existingObj\";\n        String newObj = \"newObj\";\n\n        // When\n        boolean result = comparator.addAsEqual(existingObj, newObj);\n\n        // Then\n        assertTrue(result);\n    }\n\n    @Test\n    void testAddAsEqual_ExistingObjectNotKnown() {\n        // Given\n        String existingObj = \"unknownObj\";\n        String newObj = \"newObj\";\n\n        // When / Then\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            comparator.addAsEqual(existingObj, newObj);\n        });\n        assertEquals(\"unknownObj not known to \" + comparator, exception.getMessage());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private FixedOrderComparator<String> comparator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FixedOrderComparator<String>", "name": "comparator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/ComparatorChain_compareTest.java.ComparatorChain_compareTest", "name": "ComparatorChain_compareTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/ComparatorChain_compareTest.java", "superclasses": "", "methods": ["[void]testCompare_SingleComparator_ForwardOrder()", "[void]testCompare_SingleComparator_ReverseOrder()", "[void]testCompare_MultipleComparators_MixedOrder()", "[void]testCompare_NoComparators_ThrowsException()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/ComparatorChain_compareTest.java.ComparatorChain_compareTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ComparatorChain_compareTest {\n\n    private ComparatorChain<String> comparatorChain;\n\n    @BeforeEach\n    void setUp() {\n        comparatorChain = new ComparatorChain<>();\n    }\n\n    @Test\n    void testCompare_SingleComparator_ForwardOrder() {\n        comparatorChain.addComparator(Comparator.naturalOrder());\n        assertEquals(1, comparatorChain.compare(\"b\", \"a\"));\n    }\n\n    @Test\n    void testCompare_SingleComparator_ReverseOrder() {\n        comparatorChain.addComparator(Comparator.naturalOrder(), true);\n        assertEquals(-1, comparatorChain.compare(\"b\", \"a\"));\n    }\n\n    @Test\n    void testCompare_MultipleComparators_MixedOrder() {\n        comparatorChain.addComparator(Comparator.naturalOrder());\n        comparatorChain.addComparator(Comparator.reverseOrder(), true);\n        assertEquals(-1, comparatorChain.compare(\"a\", \"b\"));\n    }\n\n    @Test\n    void testCompare_NoComparators_ThrowsException() {\n        assertThrows(UnsupportedOperationException.class, () -> comparatorChain.compare(\"a\", \"b\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ComparatorChain<String> comparatorChain;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ComparatorChain<String>", "name": "comparatorChain", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java.UnmodifiableTrieTest", "name": "UnmodifiableTrieTest", "file_path": "src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java.UnmodifiableTrieTest.[]UnmodifiableTrieTest()", "src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java.UnmodifiableTrieTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java.UnmodifiableTrieTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java.UnmodifiableTrieTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java.UnmodifiableTrieTest.[boolean]isPutChangeSupported()", "src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java.UnmodifiableTrieTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java.UnmodifiableTrieTest.[Trie<String, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java.UnmodifiableTrieTest.[Trie<String, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSortedMapTest} for exercising the\n{@link UnmodifiableTrie} implementation.\n", "original_string": "public class UnmodifiableTrieTest<V> extends AbstractSortedMapTest<String, V> {\n\n    public UnmodifiableTrieTest() {\n        super(UnmodifiableTrieTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * Override to prevent infinite recursion of tests.\n     */\n    @Override\n    public String[] ignoredTests() {\n        return null;\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isPutChangeSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public Trie<String, V> makeFullMap() {\n        final Trie<String, V> m = new PatriciaTrie<>();\n        addSampleMappings(m);\n        return UnmodifiableTrie.unmodifiableTrie(m);\n    }\n\n    @Override\n    public Trie<String, V> makeObject() {\n        return UnmodifiableTrie.unmodifiableTrie(new PatriciaTrie<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final Trie<String, V> trie = makeFullMap();\n        assertSame(trie, UnmodifiableTrie.unmodifiableTrie(trie));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableTrie.unmodifiableTrie(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullMap() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/UnmodifiableTrie.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/UnmodifiableTrie.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java.PatriciaTrieTest", "name": "PatriciaTrieTest", "file_path": "src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java", "superclasses": "", "methods": ["[void]testPrefixMap()", "[void]testPrefixMapClear()", "[void]testPrefixMapClearNothing()", "[void]testPrefixMapClearUsingRemove()", "[void]testPrefixMapRemoval()", "[void]testPrefixMapSizes()", "[void]testPrefixMapSizes2()"], "method_uris": ["src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java.PatriciaTrieTest.[]PatriciaTrieTest()", "src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java.PatriciaTrieTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java.PatriciaTrieTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java.PatriciaTrieTest.[SortedMap<String, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests for the PatriciaTrie.\n", "original_string": "public class PatriciaTrieTest<V> extends AbstractSortedMapTest<String, V> {\n\n    public PatriciaTrieTest() {\n        super(PatriciaTrieTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public SortedMap<String, V> makeObject() {\n        return new PatriciaTrie<>();\n    }\n\n    @Test\n    public void testPrefixMap() {\n        final PatriciaTrie<String> trie = new PatriciaTrie<>();\n\n        final String[] keys = {\n            StringUtils.EMPTY,\n            \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n            \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n            \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n            \"Amma\"\n        };\n\n        for (final String key : keys) {\n            trie.put(key, key);\n        }\n\n        SortedMap<String, String> map;\n        Iterator<String> iterator;\n        Iterator<Map.Entry<String, String>> entryIterator;\n        Map.Entry<String, String> entry;\n\n        map = trie.prefixMap(\"Al\");\n        assertEquals(8, map.size());\n        assertEquals(\"Alabama\", map.firstKey());\n        assertEquals(\"Alliese\", map.lastKey());\n        assertEquals(\"Albertoo\", map.get(\"Albertoo\"));\n        assertNotNull(trie.get(\"Xavier\"));\n        assertNull(map.get(\"Xavier\"));\n        assertNull(trie.get(\"Alice\"));\n        assertNull(map.get(\"Alice\"));\n        iterator = map.values().iterator();\n        assertEquals(\"Alabama\", iterator.next());\n        assertEquals(\"Albert\", iterator.next());\n        assertEquals(\"Alberto\", iterator.next());\n        assertEquals(\"Albertoo\", iterator.next());\n        assertEquals(\"Alberts\", iterator.next());\n        assertEquals(\"Alien\", iterator.next());\n        assertEquals(\"Allie\", iterator.next());\n        assertEquals(\"Alliese\", iterator.next());\n        assertFalse(iterator.hasNext());\n\n        map = trie.prefixMap(\"Albert\");\n        iterator = map.keySet().iterator();\n        assertEquals(\"Albert\", iterator.next());\n        assertEquals(\"Alberto\", iterator.next());\n        assertEquals(\"Albertoo\", iterator.next());\n        assertEquals(\"Alberts\", iterator.next());\n        assertFalse(iterator.hasNext());\n        assertEquals(4, map.size());\n        assertEquals(\"Albert\", map.firstKey());\n        assertEquals(\"Alberts\", map.lastKey());\n        assertNull(trie.get(\"Albertz\"));\n        map.put(\"Albertz\", \"Albertz\");\n        assertEquals(\"Albertz\", trie.get(\"Albertz\"));\n        assertEquals(5, map.size());\n        assertEquals(\"Albertz\", map.lastKey());\n        iterator = map.keySet().iterator();\n        assertEquals(\"Albert\", iterator.next());\n        assertEquals(\"Alberto\", iterator.next());\n        assertEquals(\"Albertoo\", iterator.next());\n        assertEquals(\"Alberts\", iterator.next());\n        assertEquals(\"Albertz\", iterator.next());\n        assertFalse(iterator.hasNext());\n        assertEquals(\"Albertz\", map.remove(\"Albertz\"));\n\n        map = trie.prefixMap(\"Alberto\");\n        assertEquals(2, map.size());\n        assertEquals(\"Alberto\", map.firstKey());\n        assertEquals(\"Albertoo\", map.lastKey());\n        entryIterator = map.entrySet().iterator();\n        entry = entryIterator.next();\n        assertEquals(\"Alberto\", entry.getKey());\n        assertEquals(\"Alberto\", entry.getValue());\n        entry = entryIterator.next();\n        assertEquals(\"Albertoo\", entry.getKey());\n        assertEquals(\"Albertoo\", entry.getValue());\n        assertFalse(entryIterator.hasNext());\n        trie.put(\"Albertoad\", \"Albertoad\");\n        assertEquals(3, map.size());\n        assertEquals(\"Alberto\", map.firstKey());\n        assertEquals(\"Albertoo\", map.lastKey());\n        entryIterator = map.entrySet().iterator();\n        entry = entryIterator.next();\n        assertEquals(\"Alberto\", entry.getKey());\n        assertEquals(\"Alberto\", entry.getValue());\n        entry = entryIterator.next();\n        assertEquals(\"Albertoad\", entry.getKey());\n        assertEquals(\"Albertoad\", entry.getValue());\n        entry = entryIterator.next();\n        assertEquals(\"Albertoo\", entry.getKey());\n        assertEquals(\"Albertoo\", entry.getValue());\n        assertFalse(entryIterator.hasNext());\n        assertEquals(\"Albertoo\", trie.remove(\"Albertoo\"));\n        assertEquals(\"Alberto\", map.firstKey());\n        assertEquals(\"Albertoad\", map.lastKey());\n        assertEquals(2, map.size());\n        entryIterator = map.entrySet().iterator();\n        entry = entryIterator.next();\n        assertEquals(\"Alberto\", entry.getKey());\n        assertEquals(\"Alberto\", entry.getValue());\n        entry = entryIterator.next();\n        assertEquals(\"Albertoad\", entry.getKey());\n        assertEquals(\"Albertoad\", entry.getValue());\n        assertFalse(entryIterator.hasNext());\n        assertEquals(\"Albertoad\", trie.remove(\"Albertoad\"));\n        trie.put(\"Albertoo\", \"Albertoo\");\n\n        map = trie.prefixMap(\"X\");\n        assertEquals(2, map.size());\n        assertFalse(map.containsKey(\"Albert\"));\n        assertTrue(map.containsKey(\"Xavier\"));\n        assertFalse(map.containsKey(\"Xalan\"));\n        iterator = map.values().iterator();\n        assertEquals(\"Xavier\", iterator.next());\n        assertEquals(\"XyZ\", iterator.next());\n        assertFalse(iterator.hasNext());\n\n        map = trie.prefixMap(\"An\");\n        assertEquals(1, map.size());\n        assertEquals(\"Anna\", map.firstKey());\n        assertEquals(\"Anna\", map.lastKey());\n        iterator = map.keySet().iterator();\n        assertEquals(\"Anna\", iterator.next());\n        assertFalse(iterator.hasNext());\n\n        map = trie.prefixMap(\"Ban\");\n        assertEquals(1, map.size());\n        assertEquals(\"Banane\", map.firstKey());\n        assertEquals(\"Banane\", map.lastKey());\n        iterator = map.keySet().iterator();\n        assertEquals(\"Banane\", iterator.next());\n        assertFalse(iterator.hasNext());\n\n        map = trie.prefixMap(\"Am\");\n        assertFalse(map.isEmpty());\n        assertEquals(3, map.size());\n        assertEquals(\"Amber\", trie.remove(\"Amber\"));\n        iterator = map.keySet().iterator();\n        assertEquals(\"Amma\", iterator.next());\n        assertEquals(\"Ammun\", iterator.next());\n        assertFalse(iterator.hasNext());\n        iterator = map.keySet().iterator();\n        map.put(\"Amber\", \"Amber\");\n        assertEquals(3, map.size());\n\n        final Iterator<String> iterator1 = iterator;\n        assertThrows(ConcurrentModificationException.class, () -> iterator1.next());\n\n        assertEquals(\"Amber\", map.firstKey());\n        assertEquals(\"Ammun\", map.lastKey());\n\n        map = trie.prefixMap(\"Ak\\0\");\n        assertTrue(map.isEmpty());\n\n        map = trie.prefixMap(\"Ak\");\n        assertEquals(2, map.size());\n        assertEquals(\"Akka\", map.firstKey());\n        assertEquals(\"Akko\", map.lastKey());\n        map.put(\"Ak\", \"Ak\");\n        assertEquals(\"Ak\", map.firstKey());\n        assertEquals(\"Akko\", map.lastKey());\n        assertEquals(3, map.size());\n        trie.put(\"Al\", \"Al\");\n        assertEquals(3, map.size());\n        assertEquals(\"Ak\", map.remove(\"Ak\"));\n        assertEquals(\"Akka\", map.firstKey());\n        assertEquals(\"Akko\", map.lastKey());\n        assertEquals(2, map.size());\n        iterator = map.keySet().iterator();\n        assertEquals(\"Akka\", iterator.next());\n        assertEquals(\"Akko\", iterator.next());\n        assertFalse(iterator.hasNext());\n        assertEquals(\"Al\", trie.remove(\"Al\"));\n\n        map = trie.prefixMap(\"Akka\");\n        assertEquals(1, map.size());\n        assertEquals(\"Akka\", map.firstKey());\n        assertEquals(\"Akka\", map.lastKey());\n        iterator = map.keySet().iterator();\n        assertEquals(\"Akka\", iterator.next());\n        assertFalse(iterator.hasNext());\n\n        map = trie.prefixMap(\"Ab\");\n        assertTrue(map.isEmpty());\n        assertEquals(0, map.size());\n\n        final SortedMap<String, String> map1 = map;\n        assertThrows(NoSuchElementException.class, () -> map1.firstKey());\n\n        final SortedMap<String, String> map2 = map;\n        assertThrows(NoSuchElementException.class, () -> map2.lastKey());\n\n        iterator = map.values().iterator();\n        assertFalse(iterator.hasNext());\n\n        map = trie.prefixMap(\"Albertooo\");\n        assertTrue(map.isEmpty());\n        assertEquals(0, map.size());\n\n        final SortedMap<String, String> map3 = map;\n        assertThrows(NoSuchElementException.class, () -> map3.firstKey(),\n                () -> \"got a first key: \" + map3.firstKey());\n\n        final SortedMap<String, String> map4 = map;\n        assertThrows(NoSuchElementException.class, () -> map4.lastKey(),\n                () -> \"got a last key: \" + map4.lastKey());\n\n        iterator = map.values().iterator();\n        assertFalse(iterator.hasNext());\n\n        map = trie.prefixMap(StringUtils.EMPTY);\n        assertSame(trie, map); // stricter than necessary, but a good check\n\n        map = trie.prefixMap(\"\\0\");\n        assertTrue(map.isEmpty());\n        assertEquals(0, map.size());\n\n        final SortedMap<String, String> map5 = map;\n        assertThrows(NoSuchElementException.class, () -> map5.firstKey(),\n                () -> \"got a first key: \" + map5.firstKey());\n\n        final SortedMap<String, String> map6 = map;\n        assertThrows(NoSuchElementException.class, () -> map6.lastKey(),\n                () -> \"got a last key: \" + map6.lastKey());\n\n        iterator = map.values().iterator();\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testPrefixMapClear() {\n        final Trie<String, Integer> trie = new PatriciaTrie<>();\n        trie.put(\"Anna\", 1);\n        trie.put(\"Anael\", 2);\n        trie.put(\"Analu\", 3);\n        trie.put(\"Andreas\", 4);\n        trie.put(\"Andrea\", 5);\n        trie.put(\"Andres\", 6);\n        trie.put(\"Anatole\", 7);\n        final SortedMap<String, Integer> prefixMap = trie.prefixMap(\"And\");\n        assertEquals(new HashSet<>(Arrays.asList(\"Andrea\", \"Andreas\", \"Andres\")), prefixMap.keySet());\n        assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));\n\n        prefixMap.clear();\n        assertTrue(prefixMap.isEmpty());\n        assertTrue(prefixMap.isEmpty());\n        assertTrue(prefixMap.isEmpty());\n        assertEquals(new HashSet<>(Arrays.asList(\"Anael\", \"Analu\", \"Anatole\", \"Anna\")), trie.keySet());\n        assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));\n    }\n\n    @Test\n    public void testPrefixMapClearNothing() {\n        final Trie<String, Integer> trie = new PatriciaTrie<>();\n        final SortedMap<String, Integer> prefixMap = trie.prefixMap(\"And\");\n        assertEquals(new HashSet<>(), prefixMap.keySet());\n        assertEquals(new ArrayList<>(0), new ArrayList<>(prefixMap.values()));\n\n        prefixMap.clear();\n        assertTrue(prefixMap.isEmpty());\n        assertTrue(prefixMap.isEmpty());\n        assertTrue(prefixMap.isEmpty());\n        assertEquals(new HashSet<>(), trie.keySet());\n        assertEquals(new ArrayList<>(0), new ArrayList<>(trie.values()));\n    }\n\n    @Test\n    public void testPrefixMapClearUsingRemove() {\n        final Trie<String, Integer> trie = new PatriciaTrie<>();\n        trie.put(\"Anna\", 1);\n        trie.put(\"Anael\", 2);\n        trie.put(\"Analu\", 3);\n        trie.put(\"Andreas\", 4);\n        trie.put(\"Andrea\", 5);\n        trie.put(\"Andres\", 6);\n        trie.put(\"Anatole\", 7);\n        final SortedMap<String, Integer> prefixMap = trie.prefixMap(\"And\");\n        assertEquals(new HashSet<>(Arrays.asList(\"Andrea\", \"Andreas\", \"Andres\")), prefixMap.keySet());\n        assertEquals(Arrays.asList(5, 4, 6), new ArrayList<>(prefixMap.values()));\n\n        final Set<String> keys = new HashSet<>(prefixMap.keySet());\n        for (final String key : keys) {\n            prefixMap.remove(key);\n        }\n        assertTrue(prefixMap.isEmpty());\n        assertTrue(prefixMap.isEmpty());\n        assertEquals(new HashSet<>(Arrays.asList(\"Anael\", \"Analu\", \"Anatole\", \"Anna\")), trie.keySet());\n        assertEquals(Arrays.asList(2, 3, 7, 1), new ArrayList<>(trie.values()));\n    }\n\n    @Test\n    public void testPrefixMapRemoval() {\n        final PatriciaTrie<String> trie = new PatriciaTrie<>();\n\n        final String[] keys = {\n            \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n            \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n            \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n            \"Amma\"\n        };\n\n        for (final String key : keys) {\n            trie.put(key, key);\n        }\n\n        SortedMap<String, String> map = trie.prefixMap(\"Al\");\n        assertEquals(8, map.size());\n        Iterator<String> iter = map.keySet().iterator();\n        assertEquals(\"Alabama\", iter.next());\n        assertEquals(\"Albert\", iter.next());\n        assertEquals(\"Alberto\", iter.next());\n        assertEquals(\"Albertoo\", iter.next());\n        assertEquals(\"Alberts\", iter.next());\n        assertEquals(\"Alien\", iter.next());\n        iter.remove();\n        assertEquals(7, map.size());\n        assertEquals(\"Allie\", iter.next());\n        assertEquals(\"Alliese\", iter.next());\n        assertFalse(iter.hasNext());\n\n        map = trie.prefixMap(\"Ak\");\n        assertEquals(2, map.size());\n        iter = map.keySet().iterator();\n        assertEquals(\"Akka\", iter.next());\n        iter.remove();\n        assertEquals(1, map.size());\n        assertEquals(\"Akko\", iter.next());\n\n        final Iterator<String> iter1 = iter;\n        assertFalse(iter.hasNext(), () -> \"shouldn't have next (but was: \" + iter1.next() + \")\");\n\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testPrefixMapSizes() {\n        // COLLECTIONS-525\n        final PatriciaTrie<String> aTree = new PatriciaTrie<>();\n        aTree.put(\"\u70b9\u8bc4\", \"\u6d4b\u8bd5\");\n        aTree.put(\"\u4e66\u8bc4\", \"\u6d4b\u8bd5\");\n        assertTrue(aTree.prefixMap(\"\u70b9\").containsKey(\"\u70b9\u8bc4\"));\n        assertEquals(\"\u6d4b\u8bd5\", aTree.prefixMap(\"\u70b9\").get(\"\u70b9\u8bc4\"));\n        assertFalse(aTree.prefixMap(\"\u70b9\").isEmpty());\n        assertEquals(1, aTree.prefixMap(\"\u70b9\").size());\n        assertEquals(1, aTree.prefixMap(\"\u70b9\").size());\n        assertEquals(1, aTree.prefixMap(\"\u70b9\").entrySet().size());\n        assertEquals(1, aTree.prefixMap(\"\u70b9\u8bc4\").size());\n\n        aTree.clear();\n        aTree.put(\"\u70b9\u8bc4\", \"\u8054\u76df\");\n        aTree.put(\"\u70b9\u7248\", \"\u5b9a\u5411\");\n        assertEquals(2, aTree.prefixMap(\"\u70b9\").size());\n        assertEquals(2, aTree.prefixMap(\"\u70b9\").size());\n    }\n\n    @Test\n    public void testPrefixMapSizes2() {\n        final char u8000 = Character.toChars(32768)[0]; // U+8000 (1000000000000000)\n        final char char_b = 'b'; // 1100010\n\n        final PatriciaTrie<String> trie = new PatriciaTrie<>();\n        final String prefixString = StringUtils.EMPTY + char_b;\n        final String longerString = prefixString + u8000;\n\n        assertEquals(1, prefixString.length());\n        assertEquals(2, longerString.length());\n\n        assertTrue(longerString.startsWith(prefixString));\n\n        trie.put(prefixString, \"prefixString\");\n        trie.put(longerString, \"longerString\");\n\n        assertEquals(2, trie.prefixMap(prefixString).size());\n        assertTrue(trie.prefixMap(prefixString).containsKey(longerString));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/PatriciaTrie.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/PatriciaTrie.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/splitmap/TransformedSplitMapTest.java.TransformedSplitMapTest", "name": "TransformedSplitMapTest", "file_path": "src/test/java/org/apache/commons/collections4/splitmap/TransformedSplitMapTest.java", "superclasses": "BulkTest", "methods": ["[void]testEmptyMap()", "[void]testFullMap()", "[void]testMapIterator()", "[void]testTransformedMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/splitmap/TransformedSplitMapTest.java.TransformedSplitMapTest.[]TransformedSplitMapTest()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for {@link TransformedSplitMap}\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class TransformedSplitMapTest extends BulkTest {\n\n    private final Transformer<Integer, String> intToString = String::valueOf;\n\n    private final Transformer<Object, Class<?>> objectToClass = input -> input == null ? null : input.getClass();\n\n    private final Transformer<String, Integer> stringToInt = Integer::valueOf;\n\n    public TransformedSplitMapTest() {\n        super(TransformedSplitMapTest.class.getSimpleName());\n    }\n\n    @Test\n    public void testEmptyMap() throws IOException, ClassNotFoundException {\n        final TransformedSplitMap<String, String, String, String> map =\n                TransformedSplitMap.transformingMap(new HashMap<>(),\n                                                    NOPTransformer.<String>nopTransformer(),\n                                                    NOPTransformer.<String>nopTransformer() );\n\n        final ObjectInputStream in = new ObjectInputStream(new FileInputStream(TEST_DATA_PATH + \"/TransformedSplitMap.emptyCollection.version4.obj\"));\n        final Object readObject = in.readObject();\n        in.close();\n\n        final TransformedSplitMap<?, ?, ?, ?> readMap = (TransformedSplitMap<?, ?, ?, ?>) readObject;\n        assertTrue(readMap.isEmpty(), \"Map should be empty\");\n        assertEquals(map.entrySet(), readMap.entrySet());\n    }\n\n    @Test\n    public void testFullMap() throws IOException, ClassNotFoundException {\n        final TransformedSplitMap<String, String, String, String> map = TransformedSplitMap.transformingMap(\n                new HashMap<>(),\n                NOPTransformer.<String>nopTransformer(),\n                NOPTransformer.<String>nopTransformer() );\n        map.put( \"a\", \"b\" );\n        map.put( \"c\", \"d\" );\n        map.put( \"e\", \"f\" );\n        map.put( \"g\", \"h\" );\n\n        final ObjectInputStream in = new ObjectInputStream(new FileInputStream(TEST_DATA_PATH + \"TransformedSplitMap.fullCollection.version4.obj\"));\n        final Object readObject = in.readObject();\n        in.close();\n\n        final TransformedSplitMap<?, ?, ?, ?> readMap = (TransformedSplitMap<?, ?, ?, ?>) readObject;\n        assertFalse(readMap.isEmpty(), \"Map should not be empty\");\n        assertEquals(map.entrySet(), readMap.entrySet());\n    }\n\n    @Test\n    public void testMapIterator() {\n        final TransformedSplitMap<String, String, String, Integer> map =\n                TransformedSplitMap.transformingMap(new HashMap<>(),\n                                                    NOPTransformer.<String>nopTransformer(), stringToInt);\n        assertEquals(0, map.size());\n        for (int i = 0; i < 6; i++) {\n            map.put(String.valueOf(i), String.valueOf(i));\n        }\n\n        for (final MapIterator<String, Integer> it = map.mapIterator(); it.hasNext();) {\n            final String k = it.next();\n            assertEquals(k, it.getKey());\n            assertEquals(map.get(k), it.getValue());\n        }\n    }\n\n    @Test\n    public void testTransformedMap() {\n        final TransformedSplitMap<Integer, String, Object, Class<?>> map = TransformedSplitMap.transformingMap(\n                new HashMap<>(), intToString, objectToClass);\n\n        final Integer[] k = { 0, 1, 2, 3, 4, 5, 6 };\n        final Object[] v = { StringUtils.EMPTY, new Object(), new HashMap<>(), 0, BigInteger.TEN, null,\n            new Object[0] };\n\n        assertEquals(0, map.size());\n        for (int i = 0; i < k.length; i++) {\n            map.put(k[i], v[i]);\n            assertEquals(i + 1, map.size());\n            assertTrue(map.containsKey(intToString.transform(k[i])));\n            assertFalse(map.containsKey(k[i]));\n            assertTrue(map.containsValue(objectToClass.transform(v[i])));\n            assertTrue(objectToClass.transform(v[i]) != v[i] ^ map.containsValue(v[i]));\n            assertEquals(objectToClass.transform(v[i]), map.get(intToString.transform(k[i])));\n        }\n\n        int sz = map.size();\n        assertNull(map.remove(k[0]));\n        assertEquals(sz, map.size());\n        assertEquals(objectToClass.transform(v[0]), map.remove(intToString.transform(k[0])));\n        assertEquals(--sz, map.size());\n\n        final TransformedSplitMap<String, String, String, Integer> map2 = TransformedSplitMap.transformingMap(\n                new HashMap<>(), NOPTransformer.<String>nopTransformer(), stringToInt);\n        assertEquals(0, map2.size());\n        for (int i = 0; i < 6; i++) {\n            map2.put(String.valueOf(i), String.valueOf(i));\n            assertEquals(i + 1, map2.size());\n            assertTrue(map2.containsValue(i));\n            assertFalse(map2.containsValue(String.valueOf(i)));\n            assertTrue(map2.containsKey(String.valueOf(i)));\n            assertEquals(i, map2.get(String.valueOf(i)).intValue());\n        }\n\n        int sz2 = map2.size();\n        assertEquals(Integer.valueOf(0), map2.remove(\"0\"));\n        assertEquals(--sz2, map2.size());\n    }\n\n//    public void testCreate() throws IOException {\n//        TransformedSplitMap<String, String, String, String> map = TransformedSplitMap.transformingMap(\n//                new HashMap<String, String>(),\n//                NOPTransformer.<String>nopTransformer(),\n//                NOPTransformer.<String>nopTransformer() );\n//\n//        ObjectOutputStream out = new ObjectOutputStream(\n//                new FileOutputStream( \"src/test/resources/data/test/TransformedSplitMap.emptyCollection.version4.obj\" ) );\n//        out.writeObject( map );\n//\n//        map.put( \"a\", \"b\" );\n//        map.put( \"c\", \"d\" );\n//        map.put( \"e\", \"f\" );\n//        map.put( \"g\", \"h\" );\n//\n//        out = new ObjectOutputStream(\n//                new FileOutputStream( \"src/test/resources/data/test/TransformedSplitMap.fullCollection.version4.obj\" ) );\n//        out.writeObject( map );\n//    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Transformer<Integer, String> intToString = String::valueOf;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<Integer, String>", "name": "intToString = String::valueOf", "syntax_pass": true}, {"attribute_expression": "private final Transformer<Object, Class<?>> objectToClass = input -> input == null ? null : input.getClass();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<Object, Class<?>>", "name": "objectToClass = input -> input == null ? null : input.getClass()", "syntax_pass": true}, {"attribute_expression": "private final Transformer<String, Integer> stringToInt = Integer::valueOf;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<String, Integer>", "name": "stringToInt = Integer::valueOf", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/splitmap/TransformedSplitMap_transformingMapTest.java.TransformedSplitMap_transformingMapTest", "name": "TransformedSplitMap_transformingMapTest", "file_path": "src/test/java/org/apache/commons/collections4/splitmap/TransformedSplitMap_transformingMapTest.java", "superclasses": "", "methods": ["[void]testTransformingMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TransformedSplitMap_transformingMapTest {\n\n    @Test\n    public void testTransformingMap() {\n        // Given\n        Map<String, Integer> map = new LinkedMap<>();\n        Transformer<String, String> keyTransformer = input -> input;\n        Transformer<Integer, Integer> valueTransformer = input -> input;\n\n        // When\n        TransformedSplitMap<String, String, Integer, Integer> transformedMap = TransformedSplitMap.transformingMap(map, keyTransformer, valueTransformer);\n\n        // Then\n        assertNotNull(transformedMap);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/IteratorEnumerationTest.java.IteratorEnumerationTest", "name": "IteratorEnumerationTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/IteratorEnumerationTest.java", "superclasses": "", "methods": ["[void]testEnumeration()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests the IteratorEnumeration.\n", "original_string": "public class IteratorEnumerationTest {\n\n    @Test\n    public void testEnumeration() {\n        final Iterator<String> iterator = Arrays.asList(\"a\", \"b\", \"c\").iterator();\n        final IteratorEnumeration<String> enumeration = new IteratorEnumeration<>(iterator);\n\n        assertEquals(iterator, enumeration.getIterator());\n\n        assertTrue(enumeration.hasMoreElements());\n        assertEquals(\"a\", enumeration.nextElement());\n        assertEquals(\"b\", enumeration.nextElement());\n        assertEquals(\"c\", enumeration.nextElement());\n        assertFalse(enumeration.hasMoreElements());\n\n        assertThrows(NoSuchElementException.class, () -> enumeration.nextElement());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SingletonIteratorTest.java.SingletonIteratorTest", "name": "SingletonIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SingletonIteratorTest.java", "superclasses": "", "methods": ["[void]testIterator()", "[void]testReset()", "[void]testSingletonIteratorRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SingletonIteratorTest.java.SingletonIteratorTest.[]SingletonIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/SingletonIteratorTest.java.SingletonIteratorTest.[SingletonIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/SingletonIteratorTest.java.SingletonIteratorTest.[SingletonIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/SingletonIteratorTest.java.SingletonIteratorTest.[boolean]supportsEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/SingletonIteratorTest.java.SingletonIteratorTest.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the SingletonIterator to ensure that the next() method will actually\nperform the iteration rather than the hasNext() method.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class SingletonIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    private static final Object testValue = \"foo\";\n\n    public SingletonIteratorTest() {\n        super(SingletonIteratorTest.class.getSimpleName());\n    }\n\n    /**\n     * Returns a SingletonIterator from which\n     * the element has already been removed.\n     */\n    @Override\n    public SingletonIterator<E> makeEmptyIterator() {\n        final SingletonIterator<E> iter = makeObject();\n        iter.next();\n        iter.remove();\n        iter.reset();\n        return iter;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SingletonIterator<E> makeObject() {\n        return new SingletonIterator<>((E) testValue);\n    }\n\n    @Override\n    public boolean supportsEmptyIterator() {\n        return true;\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return true;\n    }\n\n    @Test\n    public void testIterator() {\n        final Iterator<E> iter = makeObject();\n        assertTrue(iter.hasNext(), \"Iterator has a first item\");\n\n        final E iterValue = iter.next();\n        assertEquals(testValue, iterValue, \"Iteration value is correct\");\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n    }\n\n    @Test\n    public void testReset() {\n        final ResettableIterator<E> it = makeObject();\n\n        assertTrue(it.hasNext());\n        assertEquals(testValue, it.next());\n        assertFalse(it.hasNext());\n\n        it.reset();\n\n        assertTrue(it.hasNext());\n        assertEquals(testValue, it.next());\n        assertFalse(it.hasNext());\n\n        it.reset();\n        it.reset();\n\n        assertTrue(it.hasNext());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSingletonIteratorRemove() {\n        final ResettableIterator<E> iter = new SingletonIterator<>((E) \"xyzzy\");\n        assertTrue(iter.hasNext());\n        assertEquals(\"xyzzy\", iter.next());\n        iter.remove();\n        iter.reset();\n        assertFalse(iter.hasNext());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object testValue = \"foo\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "testValue = \"foo\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/LoopingListIterator_nextIndexTest.java.LoopingListIterator_nextIndexTest", "name": "LoopingListIterator_nextIndexTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/LoopingListIterator_nextIndexTest.java", "superclasses": "", "methods": ["[void]testNextIndexWithElements()", "[void]testNextIndexWithEmptyList()", "[void]testNextIndexAfterReset()", "[void]testNextIndexAfterFullIteration()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/LoopingListIterator_nextIndexTest.java.LoopingListIterator_nextIndexTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LoopingListIterator_nextIndexTest {\n\n    private LoopingListIterator<String> loopingListIterator;\n    private List<String> list;\n\n    @BeforeEach\n    public void setUp() {\n        list = Arrays.asList(\"a\", \"b\", \"c\");\n        loopingListIterator = new LoopingListIterator<>(list);\n    }\n\n    @Test\n    public void testNextIndexWithElements() {\n        assertEquals(0, loopingListIterator.nextIndex());\n        loopingListIterator.next();\n        assertEquals(1, loopingListIterator.nextIndex());\n        loopingListIterator.next();\n        assertEquals(2, loopingListIterator.nextIndex());\n        loopingListIterator.next();\n        assertEquals(0, loopingListIterator.nextIndex());\n    }\n\n    @Test\n    public void testNextIndexWithEmptyList() {\n        list = Arrays.asList();\n        loopingListIterator = new LoopingListIterator<>(list);\n        assertThrows(NoSuchElementException.class, () -> {\n            loopingListIterator.nextIndex();\n        });\n    }\n\n    @Test\n    public void testNextIndexAfterReset() {\n        loopingListIterator.reset();\n        assertEquals(0, loopingListIterator.nextIndex());\n    }\n\n    @Test\n    public void testNextIndexAfterFullIteration() {\n        loopingListIterator.next();\n        loopingListIterator.next();\n        loopingListIterator.next();\n        assertEquals(0, loopingListIterator.nextIndex());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private LoopingListIterator<String> loopingListIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "LoopingListIterator<String>", "name": "loopingListIterator", "syntax_pass": true}, {"attribute_expression": "private List<String> list;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "list", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java.ObjectArrayIteratorTest", "name": "ObjectArrayIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java", "superclasses": "", "methods": ["[void]testIterator()", "[void]testNullArray()", "[void]testReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java.ObjectArrayIteratorTest.[]ObjectArrayIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java.ObjectArrayIteratorTest.[ObjectArrayIterator<E>]makeArrayIterator()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java.ObjectArrayIteratorTest.[ObjectArrayIterator<E>]makeArrayIterator(E[])", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java.ObjectArrayIteratorTest.[ObjectArrayIterator<E>]makeArrayIterator(E[],int)", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java.ObjectArrayIteratorTest.[ObjectArrayIterator<E>]makeArrayIterator(E[],int,int)", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java.ObjectArrayIteratorTest.[ObjectArrayIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java.ObjectArrayIteratorTest.[ObjectArrayIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java.ObjectArrayIteratorTest.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the ObjectArrayIterator.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ObjectArrayIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n\n    public ObjectArrayIteratorTest() {\n        super(ObjectArrayIteratorTest.class.getSimpleName());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public ObjectArrayIterator<E> makeArrayIterator() {\n        return new ObjectArrayIterator<>();\n    }\n\n    public ObjectArrayIterator<E> makeArrayIterator(final E[] array) {\n        return new ObjectArrayIterator<>(array);\n    }\n\n    public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int index) {\n        return new ObjectArrayIterator<>(array, index);\n    }\n\n    public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int start, final int end) {\n        return new ObjectArrayIterator<>(array, start, end);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ObjectArrayIterator<E> makeEmptyIterator() {\n        return new ObjectArrayIterator<>((E[]) new Object[0]);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ObjectArrayIterator<E> makeObject() {\n        return new ObjectArrayIterator<>((E[]) testArray);\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Test\n    public void testIterator() {\n        final Iterator<E> iter = makeObject();\n        for (final String testValue : testArray) {\n            final E iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n    }\n\n    @Test\n    public void testNullArray() {\n        assertThrows(NullPointerException.class, () -> makeArrayIterator(null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testReset() {\n        final ObjectArrayIterator<E> it = makeArrayIterator((E[]) testArray);\n        it.next();\n        it.reset();\n        assertEquals(\"One\", it.next());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = { \"One\", \"Two\", \"Three\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = { \"One\", \"Two\", \"Three\" }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest", "name": "FilterIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java", "superclasses": "", "methods": ["[void]testRepeatedHasNext()", "[void]testRepeatedNext()", "[void]testReturnValues()", "[void]testSetIterator()", "[void]testSetPredicate()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[]FilterIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[void]initIterator()", "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[FilterIterator<E>]makeBlockAllFilter(Iterator<E>)", "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[FilterIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[FilterIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[FilterIterator<E>]makePassThroughFilter(Iterator<E>)", "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[void]tearDown()", "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[void]verifyElementsInPredicate(String[])", "src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java.FilterIteratorTest.[void]verifyNoMoreElements()"], "overrides": null, "attributes": [], "class_docstring": "\nTest the filter iterator.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class FilterIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    private String[] array;\n\n    private List<E> list;\n    private FilterIterator<E> iterator;\n    /** Creates new TestFilterIterator */\n    public FilterIteratorTest() {\n        super(FilterIteratorTest.class.getSimpleName());\n    }\n\n    private void initIterator() {\n        iterator = makeObject();\n    }\n\n    /**\n     * Returns a FilterIterator that blocks\n     * all of its elements\n     *\n     * @param i      the Iterator to \"filter\"\n     * @return \"filtered\" iterator\n     */\n    protected FilterIterator<E> makeBlockAllFilter(final Iterator<E> i) {\n        final Predicate<E> pred = x -> false;\n        return new FilterIterator<>(i, pred);\n    }\n\n    /**\n     * Returns a full iterator wrapped in a\n     * FilterIterator that blocks all the elements\n     *\n     * @return \"empty\" FilterIterator\n     */\n    @Override\n    public FilterIterator<E> makeEmptyIterator() {\n        return makeBlockAllFilter(new ArrayIterator<>(array));\n    }\n\n    /**\n     * Returns an array with elements wrapped in a pass-through\n     * FilterIterator\n     *\n     * @return a filtered iterator\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public FilterIterator<E> makeObject() {\n        list = new ArrayList<>(Arrays.asList((E[]) array));\n        return makePassThroughFilter(list.iterator());\n    }\n\n    /**\n     * Returns a FilterIterator that does not filter\n     * any of its elements\n     *\n     * @param i      the Iterator to \"filter\"\n     * @return \"filtered\" iterator\n     */\n    protected FilterIterator<E> makePassThroughFilter(final Iterator<E> i) {\n        final Predicate<E> pred = x -> true;\n        return new FilterIterator<>(i, pred);\n    }\n\n    /**\n     * Sets up instance variables required by this test case.\n     */\n    @BeforeEach\n    public void setUp() {\n        array = new String[] { \"a\", \"b\", \"c\" };\n        initIterator();\n    }\n\n    /**\n     * Tear down instance variables required by this test case.\n     */\n    @AfterEach\n    public void tearDown() throws Exception {\n        iterator = null;\n    }\n\n    @Test\n    public void testRepeatedHasNext() {\n        for (int i = 0; i <= array.length; i++) {\n            assertTrue(iterator.hasNext());\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unused\")\n    public void testRepeatedNext() {\n        for (final String element : array) {\n            iterator.next();\n        }\n        verifyNoMoreElements();\n    }\n\n    @Test\n    public void testReturnValues() {\n        verifyElementsInPredicate(ArrayUtils.EMPTY_STRING_ARRAY);\n        verifyElementsInPredicate(new String[] { \"a\" });\n        verifyElementsInPredicate(new String[] { \"b\" });\n        verifyElementsInPredicate(new String[] { \"c\" });\n        verifyElementsInPredicate(new String[] { \"a\", \"b\" });\n        verifyElementsInPredicate(new String[] { \"a\", \"c\" });\n        verifyElementsInPredicate(new String[] { \"b\", \"c\" });\n        verifyElementsInPredicate(new String[] { \"a\", \"b\", \"c\" });\n    }\n\n    /**\n     * Test that when the iterator is changed, the hasNext method returns the\n     * correct response for the new iterator.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetIterator() {\n        final Iterator<E> iter1 = Collections.singleton((E) new Object()).iterator();\n        final Iterator<E> iter2 = Collections.<E>emptyList().iterator();\n\n        final FilterIterator<E> filterIterator = new FilterIterator<>(iter1);\n        filterIterator.setPredicate(truePredicate());\n        // this iterator has elements\n        assertTrue(filterIterator.hasNext());\n\n        // this iterator has no elements\n        filterIterator.setIterator(iter2);\n        assertFalse(filterIterator.hasNext());\n    }\n\n    /**\n     * Test that when the predicate is changed, the hasNext method returns the\n     * correct response for the new predicate.\n     */\n    @Test\n    public void testSetPredicate() {\n        final Iterator<E> iter = Collections.singleton((E) null).iterator();\n\n        final FilterIterator<E> filterIterator = new FilterIterator<>(iter);\n        filterIterator.setPredicate(truePredicate());\n        // this predicate matches\n        assertTrue(filterIterator.hasNext());\n\n        // this predicate doesn't match\n        filterIterator.setPredicate(NotNullPredicate.notNullPredicate());\n        assertFalse(filterIterator.hasNext());\n    }\n\n    private void verifyElementsInPredicate(final String[] elements) {\n        final Predicate<E> pred = x -> {\n            for (final String element : elements) {\n                if (element.equals(x)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        initIterator();\n        iterator.setPredicate(pred);\n        for (int i = 0; i < elements.length; i++) {\n            final String s = (String) iterator.next();\n            assertEquals(elements[i], s);\n            assertTrue(i == elements.length - 1 ? !iterator.hasNext() : iterator.hasNext());\n        }\n        verifyNoMoreElements();\n\n        // test removal\n        initIterator();\n        iterator.setPredicate(pred);\n        if (iterator.hasNext()) {\n            final Object last = iterator.next();\n            iterator.remove();\n            assertFalse(list.contains(last), \"Base of FilterIterator still contains removed element.\");\n        }\n    }\n\n    private void verifyNoMoreElements() {\n        assertFalse(iterator.hasNext());\n        assertThrows(NoSuchElementException.class, () -> iterator.next());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private String[] array;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String[]", "name": "array", "syntax_pass": true}, {"attribute_expression": "private List<E> list;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<E>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private FilterIterator<E> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FilterIterator<E>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ArrayIteratorTest.java.ArrayIteratorTest", "name": "ArrayIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ArrayIteratorTest.java", "superclasses": "", "methods": ["[void]testIterator()", "[void]testNullArray()", "[void]testReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ArrayIteratorTest.java.ArrayIteratorTest.[]ArrayIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/ArrayIteratorTest.java.ArrayIteratorTest.[ArrayIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ArrayIteratorTest.java.ArrayIteratorTest.[ArrayIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/ArrayIteratorTest.java.ArrayIteratorTest.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the ArrayIterator to ensure that the next() method will actually\nperform the iteration rather than the hasNext() method.\nThe code of this test was supplied by Mauricio S. Moura.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ArrayIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n\n    public ArrayIteratorTest() {\n        super(ArrayIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public ArrayIterator<E> makeEmptyIterator() {\n        return new ArrayIterator<>(new Object[0]);\n    }\n\n    @Override\n    public ArrayIterator<E> makeObject() {\n        return new ArrayIterator<>(testArray);\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Test\n    public void testIterator() {\n        final Iterator<E> iter = makeObject();\n        for (final String testValue : testArray) {\n            final E iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        assertThrows(NoSuchElementException.class, iter::next, \"NoSuchElementException must be thrown\");\n    }\n\n    @Test\n    public void testNullArray() {\n        assertThrows(NullPointerException.class, () -> new ArrayIterator<>(null));\n    }\n\n    @Test\n    public void testReset() {\n        final ArrayIterator<E> it = makeObject();\n        it.next();\n        it.reset();\n        assertEquals(\"One\", it.next());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = { \"One\", \"Two\", \"Three\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = { \"One\", \"Two\", \"Three\" }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java.UnmodifiableOrderedMapIteratorTest", "name": "UnmodifiableOrderedMapIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testOrderedMapIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java.UnmodifiableOrderedMapIteratorTest.[]UnmodifiableOrderedMapIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java.UnmodifiableOrderedMapIteratorTest.[Map<K, V>]getConfirmedMap()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java.UnmodifiableOrderedMapIteratorTest.[OrderedMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java.UnmodifiableOrderedMapIteratorTest.[OrderedMapIterator<K, V>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java.UnmodifiableOrderedMapIteratorTest.[OrderedMapIterator<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java.UnmodifiableOrderedMapIteratorTest.[boolean]supportsRemove()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java.UnmodifiableOrderedMapIteratorTest.[boolean]supportsSetValue()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the UnmodifiableOrderedMapIterator.\n\n@param <K> the type of the keys in the maps tested.\n@param <V> the type of the values in the maps tested.\n", "original_string": "public class UnmodifiableOrderedMapIteratorTest<K, V> extends AbstractOrderedMapIteratorTest<K, V> {\n\n    public UnmodifiableOrderedMapIteratorTest() {\n        super(UnmodifiableOrderedMapIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<K, V> getConfirmedMap() {\n        final Map<K, V> testMap = new TreeMap<>();\n        testMap.put((K) \"A\", (V) \"a\");\n        testMap.put((K) \"B\", (V) \"b\");\n        testMap.put((K) \"C\", (V) \"c\");\n        return testMap;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public OrderedMap<K, V> getMap() {\n        final OrderedMap<K, V> testMap = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n        testMap.put((K) \"A\", (V) \"a\");\n        testMap.put((K) \"B\", (V) \"b\");\n        testMap.put((K) \"C\", (V) \"c\");\n        return testMap;\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> makeEmptyIterator() {\n        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(\n                ListOrderedMap.listOrderedMap(new HashMap<K, V>()).mapIterator());\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> makeObject() {\n        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(getMap().mapIterator());\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Override\n    public boolean supportsSetValue() {\n        return false;\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        OrderedMapIterator<K, V> it = makeObject();\n        assertSame(it, UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));\n\n        it = getMap().mapIterator();\n        assertNotSame(it, UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(null));\n    }\n\n    @Test\n    public void testOrderedMapIterator() {\n        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PushbackIterator_pushbackIteratorTest.java.PushbackIterator_pushbackIteratorTest", "name": "PushbackIterator_pushbackIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PushbackIterator_pushbackIteratorTest.java", "superclasses": "", "methods": ["[void]testPushbackIteratorWithNonNullIterator()", "[void]testPushbackIteratorWithPushbackIteratorInstance()", "[void]testPushbackIteratorWithNullIterator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PushbackIterator_pushbackIteratorTest {\n\n    @Test\n    void testPushbackIteratorWithNonNullIterator() {\n        // Given\n        Iterator<String> mockIterator = mock(Iterator.class);\n\n        // When\n        PushbackIterator<String> result = PushbackIterator.pushbackIterator(mockIterator);\n\n        // Then\n        assertNotNull(result);\n        assertNotSame(mockIterator, result);\n    }\n\n    @Test\n    void testPushbackIteratorWithPushbackIteratorInstance() {\n        // Given\n        PushbackIterator<String> mockPushbackIterator = mock(PushbackIterator.class);\n\n        // When\n        PushbackIterator<String> result = PushbackIterator.pushbackIterator(mockPushbackIterator);\n\n        // Then\n        assertSame(mockPushbackIterator, result);\n    }\n\n    @Test\n    void testPushbackIteratorWithNullIterator() {\n        // Given\n        Iterator<String> nullIterator = null;\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> {\n            PushbackIterator.pushbackIterator(nullIterator);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java.IteratorChainTest", "name": "IteratorChainTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java", "superclasses": "", "methods": ["[void]testEmptyChain()", "[void]testFirstIteratorIsEmptyBug()", "[void]testIterator()", "[void]testRemove()", "[void]testRemoveFromFilteredIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java.IteratorChainTest.[]IteratorChainTest()", "src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java.IteratorChainTest.[IteratorChain<String>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java.IteratorChainTest.[IteratorChain<String>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java.IteratorChainTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the IteratorChain class.\n", "original_string": "public class IteratorChainTest extends AbstractIteratorTest<String> {\n\n    protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };\n\n    protected List<String> list1;\n    protected List<String> list2;\n    protected List<String> list3;\n\n    public IteratorChainTest() {\n        super(IteratorChainTest.class.getSimpleName());\n    }\n\n    @Override\n    public IteratorChain<String> makeEmptyIterator() {\n        final ArrayList<String> list = new ArrayList<>();\n        return new IteratorChain<>(list.iterator());\n    }\n\n    @Override\n    public IteratorChain<String> makeObject() {\n        final IteratorChain<String> chain = new IteratorChain<>();\n\n        chain.addIterator(list1.iterator());\n        chain.addIterator(list2.iterator());\n        chain.addIterator(list3.iterator());\n        return chain;\n    }\n\n    @BeforeEach\n    public void setUp() {\n        list1 = new ArrayList<>();\n        list1.add(\"One\");\n        list1.add(\"Two\");\n        list1.add(\"Three\");\n        list2 = new ArrayList<>();\n        list2.add(\"Four\");\n        list3 = new ArrayList<>();\n        list3.add(\"Five\");\n        list3.add(\"Six\");\n    }\n\n    @Test\n    public void testEmptyChain() {\n        final IteratorChain<Object> chain = new IteratorChain<>();\n        assertFalse(chain.hasNext());\n        assertAll(\n                () -> assertThrows(NoSuchElementException.class, () -> chain.next()),\n                () -> assertThrows(IllegalStateException.class, () -> chain.remove())\n        );\n    }\n\n    @Test\n    public void testFirstIteratorIsEmptyBug() {\n        final List<String> empty = new ArrayList<>();\n        final List<String> notEmpty = new ArrayList<>();\n        notEmpty.add(\"A\");\n        notEmpty.add(\"B\");\n        notEmpty.add(\"C\");\n        final IteratorChain<String> chain = new IteratorChain<>();\n        chain.addIterator(empty.iterator());\n        chain.addIterator(notEmpty.iterator());\n        assertTrue(chain.hasNext(), \"should have next\");\n        assertEquals(\"A\", chain.next());\n        assertTrue(chain.hasNext(), \"should have next\");\n        assertEquals(\"B\", chain.next());\n        assertTrue(chain.hasNext(), \"should have next\");\n        assertEquals(\"C\", chain.next());\n        assertFalse(chain.hasNext(), \"should not have next\");\n    }\n\n    @Test\n    public void testIterator() {\n        final Iterator<String> iter = makeObject();\n        for (final String testValue : testArray) {\n            final Object iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n    }\n\n    @Test\n    @Override\n    public void testRemove() {\n        final Iterator<String> iter = makeObject();\n\n        assertThrows(IllegalStateException.class, () -> iter.remove(),\n                \"Calling remove before the first call to next() should throw an exception\");\n\n        for (final String testValue : testArray) {\n            final String iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n\n            if (!iterValue.equals(\"Four\")) {\n                iter.remove();\n            }\n        }\n\n        assertTrue(list1.isEmpty(), \"List is empty\");\n        assertEquals(1, list2.size(), \"List is empty\");\n        assertTrue(list3.isEmpty(), \"List is empty\");\n    }\n\n    @Test\n    public void testRemoveFromFilteredIterator() {\n\n        final Predicate<Integer> myPredicate = i -> i.compareTo(Integer.valueOf(4)) < 0;\n\n        final List<Integer> list1 = new ArrayList<>();\n        final List<Integer> list2 = new ArrayList<>();\n\n        list1.add(Integer.valueOf(1));\n        list1.add(Integer.valueOf(2));\n        list2.add(Integer.valueOf(3));\n        list2.add(Integer.valueOf(4)); // will be ignored by the predicate\n\n        final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);\n        final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);\n\n        final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);\n        while (it.hasNext()) {\n            it.next();\n            it.remove();\n        }\n        assertEquals(0, list1.size());\n        assertEquals(1, list2.size());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    }", "syntax_pass": true}, {"attribute_expression": "protected List<String> list1;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<String>", "name": "list1", "syntax_pass": true}, {"attribute_expression": "protected List<String> list2;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<String>", "name": "list2", "syntax_pass": true}, {"attribute_expression": "protected List<String> list3;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<String>", "name": "list3", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SkippingIteratorTest.java.SkippingIteratorTest", "name": "SkippingIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SkippingIteratorTest.java", "superclasses": "", "methods": ["[void]testNegativeOffset()", "[void]testOffsetGreaterThanSize()", "[void]testRemoveCalledTwice()", "[void]testRemoveFirst()", "[void]testRemoveLast()", "[void]testRemoveMiddle()", "[void]testRemoveUnsupported()", "[void]testRemoveWithoutCallingNext()", "[void]testSameAsDecorated()", "[void]testSkipping()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SkippingIteratorTest.java.SkippingIteratorTest.[]SkippingIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/SkippingIteratorTest.java.SkippingIteratorTest.[Iterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/SkippingIteratorTest.java.SkippingIteratorTest.[Iterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/SkippingIteratorTest.java.SkippingIteratorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nA unit test to test the basic functions of {@link SkippingIterator}.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class SkippingIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    /** Test array of size 7 */\n    private final String[] testArray = {\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\n    };\n\n    private List<E> testList;\n\n    public SkippingIteratorTest() {\n        super(SkippingIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public Iterator<E> makeEmptyIterator() {\n        return new SkippingIterator<>(Collections.<E>emptyList().iterator(), 0);\n    }\n\n    @Override\n    public Iterator<E> makeObject() {\n        return new SkippingIterator<>(new ArrayList<>(testList).iterator(), 1);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    public void setUp()\n        throws Exception {\n        testList = Arrays.asList((E[]) testArray);\n    }\n\n    /**\n     * Test the case if a negative {@code offset} is passed to the\n     * constructor. {@link IllegalArgumentException} is expected.\n     */\n    @Test\n    public void testNegativeOffset() {\n        assertThrows(IllegalArgumentException.class, () -> new SkippingIterator<>(testList.iterator(), -1),\n                \"Expected IllegalArgumentException.\");\n    }\n\n    /**\n     * Test the case if the {@code offset} passed to the constructor is\n     * greater than the decorated iterator's size. The SkippingIterator should\n     * behave as if there are no more elements to return.\n     */\n    @Test\n    public void testOffsetGreaterThanSize() {\n        final Iterator<E> iter = new SkippingIterator<>(testList.iterator(), 10);\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next(),\n                \"Expected NoSuchElementException.\");\n    }\n\n    /**\n     * Test the {@code remove()} method being called twice without calling\n     * {@code next()} in between.\n     */\n    @Test\n    public void testRemoveCalledTwice() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 1);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n        iter.remove();\n\n        assertThrows(IllegalStateException.class, () -> iter.remove(),\n                \"Expected IllegalStateException.\");\n    }\n\n    /**\n     * Test removing the first element. Verify that the element is removed from\n     * the underlying collection.\n     */\n    @Test\n    public void testRemoveFirst() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 4);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n\n        iter.remove();\n        assertFalse(testListCopy.contains(\"e\"));\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"g\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next(),\n                \"Expected NoSuchElementException.\");\n    }\n\n    /**\n     * Test removing the last element. Verify that the element is removed from\n     * the underlying collection.\n     */\n    @Test\n    public void testRemoveLast() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 5);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"g\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next(),\n                \"Expected NoSuchElementException.\");\n\n        iter.remove();\n        assertFalse(testListCopy.contains(\"g\"));\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next(),\n                \"Expected NoSuchElementException.\");\n    }\n\n    /**\n     * Test removing an element in the middle of the iterator. Verify that the\n     * element is removed from the underlying collection.\n     */\n    @Test\n    public void testRemoveMiddle() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 3);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"d\", iter.next());\n\n        iter.remove();\n        assertFalse(testListCopy.contains(\"d\"));\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"g\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next(),\n                \"Expected NoSuchElementException.\");\n    }\n\n    /**\n     * Test the case if the decorated iterator does not support the\n     * {@code remove()} method and throws an {@link UnsupportedOperationException}.\n     */\n    @Test\n    public void testRemoveUnsupported() {\n        final Iterator<E> mockIterator = new AbstractIteratorDecorator<E>(testList.iterator()) {\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n\n        final Iterator<E> iter = new SkippingIterator<>(mockIterator, 1);\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n\n        assertThrows(UnsupportedOperationException.class, () -> iter.remove(),\n                \"Expected UnsupportedOperationException.\");\n    }\n\n    /**\n     * Test the {@code remove()} method being called without\n     * {@code next()} being called first.\n     */\n    @Test\n    public void testRemoveWithoutCallingNext() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new SkippingIterator<>(testListCopy.iterator(), 1);\n\n        assertThrows(IllegalStateException.class, () -> iter.remove(),\n                \"Expected IllegalStateException.\");\n    }\n\n    /**\n     * Test a decorated iterator bounded such that the {@code offset} is\n     * zero, in that the SkippingIterator should return all the same elements\n     * as its decorated iterator.\n     */\n    @Test\n    public void testSameAsDecorated() {\n        final Iterator<E> iter = new SkippingIterator<>(testList.iterator(), 0);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"a\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"c\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"d\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"g\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next(),\n                \"Expected NoSuchElementException.\");\n    }\n\n    /**\n     * Test a decorated iterator bounded such that the first element returned is\n     * at an index greater its first element, and the last element returned is\n     * at an index less than its last element.\n     */\n    @Test\n    public void testSkipping() {\n        final Iterator<E> iter = new SkippingIterator<>(testList.iterator(), 2);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"c\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"d\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"g\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next(),\n                \"Expected NoSuchElementException.\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final String[] testArray = {\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\n    };", "docstring": " Test array of size 7", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "testArray = {\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\n    }", "syntax_pass": true}, {"attribute_expression": "private List<E> testList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<E>", "name": "testList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_setTest.java.SingletonListIterator_setTest", "name": "SingletonListIterator_setTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_setTest.java", "superclasses": "", "methods": ["[void]testSetSuccess()", "[void]testSetWithoutNextCall()", "[void]testSetAfterRemove()", "[void]testSetAfterReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_setTest.java.SingletonListIterator_setTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonListIterator_setTest {\n\n    private static final Object testValue = new Object();\n    private SingletonListIterator<Object> iterator;\n\n    @BeforeEach\n    public void setUp() {\n        iterator = new SingletonListIterator<>(testValue);\n    }\n\n    @Test\n    public void testSetSuccess() {\n        iterator.next();\n        Object newValue = new Object();\n        iterator.set(newValue);\n        iterator.reset(); // Reset the iterator to its initial state\n        assertEquals(newValue, iterator.next());\n    }\n\n    @Test\n    public void testSetWithoutNextCall() {\n        assertThrows(IllegalStateException.class, () -> {\n            iterator.set(new Object());\n        });\n    }\n\n    @Test\n    public void testSetAfterRemove() {\n        iterator.next();\n        iterator.remove();\n        assertThrows(IllegalStateException.class, () -> {\n            iterator.set(new Object());\n        });\n    }\n\n    @Test\n    public void testSetAfterReset() {\n        iterator.next();\n        iterator.reset();\n        assertThrows(IllegalStateException.class, () -> {\n            iterator.set(new Object());\n        });\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object testValue = new Object();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "testValue = new Object()", "syntax_pass": true}, {"attribute_expression": "private SingletonListIterator<Object> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SingletonListIterator<Object>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIteratorTest.java.ObjectArrayListIteratorTest", "name": "ObjectArrayListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIteratorTest.java", "superclasses": "", "methods": ["[void]testListIterator()", "[void]testListIteratorSet()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIteratorTest.java.ObjectArrayListIteratorTest.[]ObjectArrayListIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIteratorTest.java.ObjectArrayListIteratorTest.[ObjectArrayListIterator<E>]makeArrayListIterator(E[])", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIteratorTest.java.ObjectArrayListIteratorTest.[ObjectArrayListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIteratorTest.java.ObjectArrayListIteratorTest.[ObjectArrayListIterator<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the ObjectArrayListIterator class.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ObjectArrayListIteratorTest<E> extends ObjectArrayIteratorTest<E> {\n\n    public ObjectArrayListIteratorTest() {\n    }\n\n    public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {\n        return new ObjectArrayListIterator<>(array);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ObjectArrayListIterator<E> makeEmptyIterator() {\n        return new ObjectArrayListIterator<>((E[]) new Object[0]);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ObjectArrayListIterator<E> makeObject() {\n        return new ObjectArrayListIterator<>((E[]) testArray);\n    }\n\n    /**\n     * Test the basic ListIterator functionality - going backwards using\n     * {@code previous()}.\n     */\n    @Test\n    public void testListIterator() {\n        final ListIterator<E> iter = makeObject();\n\n        // TestArrayIterator#testIterator() has already tested the iterator forward,\n        //  now we need to test it in reverse\n\n        // fast-forward the iterator to the end...\n        while (iter.hasNext()) {\n            iter.next();\n        }\n\n        for (int x = testArray.length - 1; x >= 0; x--) {\n            final Object testValue = testArray[x];\n            final Object iterValue = iter.previous();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasPrevious(), \"Iterator should now be empty\");\n\n        try {\n            iter.previous();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n\n    }\n\n    /**\n     * Tests the {@link java.util.ListIterator#set} operation.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListIteratorSet() {\n        final String[] testData = { \"a\", \"b\", \"c\" };\n\n        final String[] result = { \"0\", \"1\", \"2\" };\n\n        ListIterator<E> iter = makeArrayListIterator((E[]) testData);\n        int x = 0;\n\n        while (iter.hasNext()) {\n            iter.next();\n            iter.set((E) Integer.toString(x));\n            x++;\n        }\n\n        assertArrayEquals(testData, result, \"The two arrays should have the same value, i.e. {0,1,2}\");\n\n        // a call to set() before a call to next() or previous() should throw an IllegalStateException\n        iter = makeArrayListIterator((E[]) testArray);\n\n        final ListIterator<E> finalIter = iter;\n        assertThrows(IllegalStateException.class, () -> finalIter.set((E) \"should fail\"), \"ListIterator#set should fail if next() or previous() have not yet been called.\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIteratorTest.java.ObjectGraphIteratorTest", "name": "ObjectGraphIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIteratorTest.java", "superclasses": "", "methods": ["[void]testIteration_IteratorOfIterators()", "[void]testIteration_IteratorOfIteratorsWithEmptyIterators()", "[void]testIteration_RootNoTransformer()", "[void]testIteration_RootNull()", "[void]testIteration_Transformed1()", "[void]testIteration_Transformed2()", "[void]testIteration_Transformed3()", "[void]testIteratorConstructor_null_next()", "[void]testIteratorConstructor_null_remove()", "[void]testIteratorConstructor_null1()", "[void]testIteratorConstructorIteration_Empty()", "[void]testIteratorConstructorIteration_Simple()", "[void]testIteratorConstructorIteration_SimpleNoHasNext()", "[void]testIteratorConstructorIteration_WithEmptyIterators()", "[void]testIteratorConstructorRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIteratorTest.java.ObjectGraphIteratorTest.[]ObjectGraphIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIteratorTest.java.ObjectGraphIteratorTest.[ObjectGraphIterator<Object>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIteratorTest.java.ObjectGraphIteratorTest.[ObjectGraphIterator<Object>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIteratorTest.java.ObjectGraphIteratorTest.[void]setUp()"], "overrides": null, "attributes": [{"original_string": "    static class Branch {\n\n        List<Leaf> leaves = new ArrayList<>();\n\n        Leaf addLeaf() {\n            leaves.add(new Leaf());\n            return getLeaf(leaves.size() - 1);\n        }\n\n        Leaf getLeaf(final int index) {\n            return leaves.get(index);\n        }\n\n        Iterator<Leaf> leafIterator() {\n            return leaves.iterator();\n        }\n\n    }", "definition": "    static class Branch", "class_docstring": "", "name": "Branch", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "List<Leaf> leaves = new ArrayList<>();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "List<Leaf>", "name": "leaves = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Leaf addLeaf() {\n            leaves.add(new Leaf());\n            return getLeaf(leaves.size() - 1);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Leaf", "classes": []}, "name": "addLeaf", "params": [], "body": "                       {\n            leaves.add(new Leaf());\n            return getLeaf(leaves.size() - 1);\n        }", "signature": "Leaf addLeaf()"}, {"syntax_pass": true, "original_string": "        Leaf getLeaf(final int index) {\n            return leaves.get(index);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Leaf", "classes": []}, "name": "getLeaf", "params": [{"name": "index", "type": "int"}], "body": "                                      {\n            return leaves.get(index);\n        }", "signature": "Leaf getLeaf(final int index)"}, {"syntax_pass": true, "original_string": "        Iterator<Leaf> leafIterator() {\n            return leaves.iterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Iterator<Leaf>", "classes": []}, "name": "leafIterator", "params": [], "body": "                                      {\n            return leaves.iterator();\n        }", "signature": "Iterator<Leaf> leafIterator()"}]}, {"original_string": "    static class Forest {\n\n        List<Tree> trees = new ArrayList<>();\n\n        Tree addTree() {\n            trees.add(new Tree());\n            return getTree(trees.size() - 1);\n        }\n\n        Tree getTree(final int index) {\n            return trees.get(index);\n        }\n\n        Iterator<Tree> treeIterator() {\n            return trees.iterator();\n        }\n\n    }", "definition": "    static class Forest", "class_docstring": "", "name": "Forest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "List<Tree> trees = new ArrayList<>();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "List<Tree>", "name": "trees = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Tree addTree() {\n            trees.add(new Tree());\n            return getTree(trees.size() - 1);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Tree", "classes": []}, "name": "addTree", "params": [], "body": "                       {\n            trees.add(new Tree());\n            return getTree(trees.size() - 1);\n        }", "signature": "Tree addTree()"}, {"syntax_pass": true, "original_string": "        Tree getTree(final int index) {\n            return trees.get(index);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Tree", "classes": []}, "name": "getTree", "params": [{"name": "index", "type": "int"}], "body": "                                      {\n            return trees.get(index);\n        }", "signature": "Tree getTree(final int index)"}, {"syntax_pass": true, "original_string": "        Iterator<Tree> treeIterator() {\n            return trees.iterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Iterator<Tree>", "classes": []}, "name": "treeIterator", "params": [], "body": "                                      {\n            return trees.iterator();\n        }", "signature": "Iterator<Tree> treeIterator()"}]}, {"original_string": "    static class Leaf {\n\n        String color;\n\n        String getColor() {\n            return color;\n        }\n\n        void setColor(final String color) {\n            this.color = color;\n        }\n\n    }", "definition": "    static class Leaf", "class_docstring": "", "name": "Leaf", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "String color;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "String", "name": "color", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        String getColor() {\n            return color;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "getColor", "params": [], "body": "                          {\n            return color;\n        }", "signature": "String getColor()"}, {"syntax_pass": true, "original_string": "        void setColor(final String color) {\n            this.color = color;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "setColor", "params": [{"name": "color", "type": "String"}], "body": "                                          {\n            this.color = color;\n        }", "signature": "void setColor(final String color)"}]}, {"original_string": "    static class LeafFinder implements Transformer<Object, Object> {\n\n        @Override\n        public Object transform(final Object input) {\n            if (input instanceof Forest) {\n                return ((Forest) input).treeIterator();\n            }\n            if (input instanceof Tree) {\n                return ((Tree) input).branchIterator();\n            }\n            if (input instanceof Branch) {\n                return ((Branch) input).leafIterator();\n            }\n            if (input instanceof Leaf) {\n                return input;\n            }\n            throw new ClassCastException();\n        }\n\n    }", "definition": "    static class LeafFinder implements Transformer<Object, Object>", "class_docstring": "", "name": "LeafFinder", "super_interfaces": ["Transformer<Object, Object>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Object transform(final Object input) {\n            if (input instanceof Forest) {\n                return ((Forest) input).treeIterator();\n            }\n            if (input instanceof Tree) {\n                return ((Tree) input).branchIterator();\n            }\n            if (input instanceof Branch) {\n                return ((Branch) input).leafIterator();\n            }\n            if (input instanceof Leaf) {\n                return input;\n            }\n            throw new ClassCastException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "transform", "params": [{"name": "input", "type": "Object"}], "body": "                                                    {\n            if (input instanceof Forest) {\n                return ((Forest) input).treeIterator();\n            }\n            if (input instanceof Tree) {\n                return ((Tree) input).branchIterator();\n            }\n            if (input instanceof Branch) {\n                return ((Branch) input).leafIterator();\n            }\n            if (input instanceof Leaf) {\n                return input;\n            }\n            throw new ClassCastException();\n        }", "signature": "@Override\n        public Object transform(final Object input)"}]}, {"original_string": "    static class Tree {\n\n        List<Branch> branches = new ArrayList<>();\n\n        Branch addBranch() {\n            branches.add(new Branch());\n            return getBranch(branches.size() - 1);\n        }\n\n        Iterator<Branch> branchIterator() {\n            return branches.iterator();\n        }\n\n        Branch getBranch(final int index) {\n            return branches.get(index);\n        }\n\n    }", "definition": "    static class Tree", "class_docstring": "", "name": "Tree", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "List<Branch> branches = new ArrayList<>();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "List<Branch>", "name": "branches = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Branch addBranch() {\n            branches.add(new Branch());\n            return getBranch(branches.size() - 1);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Branch", "classes": []}, "name": "addBranch", "params": [], "body": "                           {\n            branches.add(new Branch());\n            return getBranch(branches.size() - 1);\n        }", "signature": "Branch addBranch()"}, {"syntax_pass": true, "original_string": "        Iterator<Branch> branchIterator() {\n            return branches.iterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Iterator<Branch>", "classes": []}, "name": "branchIterator", "params": [], "body": "                                          {\n            return branches.iterator();\n        }", "signature": "Iterator<Branch> branchIterator()"}, {"syntax_pass": true, "original_string": "        Branch getBranch(final int index) {\n            return branches.get(index);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Branch", "classes": []}, "name": "getBranch", "params": [{"name": "index", "type": "int"}], "body": "                                          {\n            return branches.get(index);\n        }", "signature": "Branch getBranch(final int index)"}]}], "class_docstring": "\nTestcase.\n", "original_string": "public class ObjectGraphIteratorTest extends AbstractIteratorTest<Object> {\n\n    static class Branch {\n\n        List<Leaf> leaves = new ArrayList<>();\n\n        Leaf addLeaf() {\n            leaves.add(new Leaf());\n            return getLeaf(leaves.size() - 1);\n        }\n\n        Leaf getLeaf(final int index) {\n            return leaves.get(index);\n        }\n\n        Iterator<Leaf> leafIterator() {\n            return leaves.iterator();\n        }\n\n    }\n\n    static class Forest {\n\n        List<Tree> trees = new ArrayList<>();\n\n        Tree addTree() {\n            trees.add(new Tree());\n            return getTree(trees.size() - 1);\n        }\n\n        Tree getTree(final int index) {\n            return trees.get(index);\n        }\n\n        Iterator<Tree> treeIterator() {\n            return trees.iterator();\n        }\n\n    }\n    static class Leaf {\n\n        String color;\n\n        String getColor() {\n            return color;\n        }\n\n        void setColor(final String color) {\n            this.color = color;\n        }\n\n    }\n    static class LeafFinder implements Transformer<Object, Object> {\n\n        @Override\n        public Object transform(final Object input) {\n            if (input instanceof Forest) {\n                return ((Forest) input).treeIterator();\n            }\n            if (input instanceof Tree) {\n                return ((Tree) input).branchIterator();\n            }\n            if (input instanceof Branch) {\n                return ((Branch) input).leafIterator();\n            }\n            if (input instanceof Leaf) {\n                return input;\n            }\n            throw new ClassCastException();\n        }\n\n    }\n    static class Tree {\n\n        List<Branch> branches = new ArrayList<>();\n\n        Branch addBranch() {\n            branches.add(new Branch());\n            return getBranch(branches.size() - 1);\n        }\n\n        Iterator<Branch> branchIterator() {\n            return branches.iterator();\n        }\n\n        Branch getBranch(final int index) {\n            return branches.get(index);\n        }\n\n    }\n\n    protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\" };\n\n    protected List<String> list1;\n\n    protected List<String> list2;\n\n    protected List<String> list3;\n\n    protected List<Iterator<String>> iteratorList;\n\n    public ObjectGraphIteratorTest() {\n        super(ObjectGraphIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public ObjectGraphIterator<Object> makeEmptyIterator() {\n        final ArrayList<Object> list = new ArrayList<>();\n        return new ObjectGraphIterator<>(list.iterator());\n    }\n\n    @Override\n    public ObjectGraphIterator<Object> makeObject() {\n        return new ObjectGraphIterator<>(iteratorList.iterator());\n    }\n\n    @BeforeEach\n    public void setUp() {\n        list1 = new ArrayList<>();\n        list1.add(\"One\");\n        list1.add(\"Two\");\n        list1.add(\"Three\");\n        list2 = new ArrayList<>();\n        list2.add(\"Four\");\n        list3 = new ArrayList<>();\n        list3.add(\"Five\");\n        list3.add(\"Six\");\n        iteratorList = new ArrayList<>();\n        iteratorList.add(list1.iterator());\n        iteratorList.add(list2.iterator());\n        iteratorList.add(list3.iterator());\n    }\n\n    @Test\n    public void testIteration_IteratorOfIterators() {\n        final List<Iterator<String>> iteratorList = new ArrayList<>();\n        iteratorList.add(list1.iterator());\n        iteratorList.add(list2.iterator());\n        iteratorList.add(list3.iterator());\n        final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator(), null);\n\n        for (int i = 0; i < 6; i++) {\n            assertTrue(it.hasNext());\n            assertEquals(testArray[i], it.next());\n        }\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    public void testIteration_IteratorOfIteratorsWithEmptyIterators() {\n        final List<Iterator<String>> iteratorList = new ArrayList<>();\n        iteratorList.add(IteratorUtils.<String>emptyIterator());\n        iteratorList.add(list1.iterator());\n        iteratorList.add(IteratorUtils.<String>emptyIterator());\n        iteratorList.add(list2.iterator());\n        iteratorList.add(IteratorUtils.<String>emptyIterator());\n        iteratorList.add(list3.iterator());\n        iteratorList.add(IteratorUtils.<String>emptyIterator());\n        final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator(), null);\n\n        for (int i = 0; i < 6; i++) {\n            assertTrue(it.hasNext());\n            assertEquals(testArray[i], it.next());\n        }\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    public void testIteration_RootNoTransformer() {\n        final Forest forest = new Forest();\n        final Iterator<Object> it = new ObjectGraphIterator<>(forest, null);\n\n        assertTrue(it.hasNext());\n        assertSame(forest, it.next());\n        assertFalse(it.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    public void testIteration_RootNull() {\n        final Iterator<Object> it = new ObjectGraphIterator<>(null, null);\n\n        assertFalse(it.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n\n        assertThrows(IllegalStateException.class, () -> it.remove());\n    }\n\n    @Test\n    public void testIteration_Transformed1() {\n        final Forest forest = new Forest();\n        final Leaf l1 = forest.addTree().addBranch().addLeaf();\n        final Iterator<Object> it = new ObjectGraphIterator<>(forest, new LeafFinder());\n\n        assertTrue(it.hasNext());\n        assertSame(l1, it.next());\n        assertFalse(it.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    public void testIteration_Transformed2() {\n        final Forest forest = new Forest();\n        forest.addTree();\n        forest.addTree();\n        forest.addTree();\n        final Branch b1 = forest.getTree(0).addBranch();\n        final Branch b2 = forest.getTree(0).addBranch();\n        final Branch b3 = forest.getTree(2).addBranch();\n        /* Branch b4 = */ forest.getTree(2).addBranch();\n        final Branch b5 = forest.getTree(2).addBranch();\n        final Leaf l1 = b1.addLeaf();\n        final Leaf l2 = b1.addLeaf();\n        final Leaf l3 = b2.addLeaf();\n        final Leaf l4 = b3.addLeaf();\n        final Leaf l5 = b5.addLeaf();\n\n        final Iterator<Object> it = new ObjectGraphIterator<>(forest, new LeafFinder());\n\n        assertTrue(it.hasNext());\n        assertSame(l1, it.next());\n        assertTrue(it.hasNext());\n        assertSame(l2, it.next());\n        assertTrue(it.hasNext());\n        assertSame(l3, it.next());\n        assertTrue(it.hasNext());\n        assertSame(l4, it.next());\n        assertTrue(it.hasNext());\n        assertSame(l5, it.next());\n        assertFalse(it.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    public void testIteration_Transformed3() {\n        final Forest forest = new Forest();\n        forest.addTree();\n        forest.addTree();\n        forest.addTree();\n        final Branch b1 = forest.getTree(1).addBranch();\n        final Branch b2 = forest.getTree(1).addBranch();\n        final Branch b3 = forest.getTree(2).addBranch();\n        final Branch b4 = forest.getTree(2).addBranch();\n        /* Branch b5 = */ forest.getTree(2).addBranch();\n        final Leaf l1 = b1.addLeaf();\n        final Leaf l2 = b1.addLeaf();\n        final Leaf l3 = b2.addLeaf();\n        final Leaf l4 = b3.addLeaf();\n        final Leaf l5 = b4.addLeaf();\n\n        final Iterator<Object> it = new ObjectGraphIterator<>(forest, new LeafFinder());\n\n        assertTrue(it.hasNext());\n        assertSame(l1, it.next());\n        assertTrue(it.hasNext());\n        assertSame(l2, it.next());\n        assertTrue(it.hasNext());\n        assertSame(l3, it.next());\n        assertTrue(it.hasNext());\n        assertSame(l4, it.next());\n        assertTrue(it.hasNext());\n        assertSame(l5, it.next());\n        assertFalse(it.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    public void testIteratorConstructor_null_next() {\n        final Iterator<Object> it = new ObjectGraphIterator<>(null);\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    public void testIteratorConstructor_null_remove() {\n        final Iterator<Object> it = new ObjectGraphIterator<>(null);\n        assertThrows(IllegalStateException.class, () -> it.remove());\n    }\n\n    @Test\n    public void testIteratorConstructor_null1() {\n        final Iterator<Object> it = new ObjectGraphIterator<>(null);\n\n        assertFalse(it.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n\n        assertThrows(IllegalStateException.class, () -> it.remove());\n    }\n\n    @Test\n    public void testIteratorConstructorIteration_Empty() {\n        final List<Iterator<Object>> iteratorList = new ArrayList<>();\n        final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());\n\n        assertFalse(it.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n\n        assertThrows(IllegalStateException.class, () -> it.remove());\n    }\n\n    @Test\n    public void testIteratorConstructorIteration_Simple() {\n        final List<Iterator<String>> iteratorList = new ArrayList<>();\n        iteratorList.add(list1.iterator());\n        iteratorList.add(list2.iterator());\n        iteratorList.add(list3.iterator());\n        final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());\n\n        for (int i = 0; i < 6; i++) {\n            assertTrue(it.hasNext());\n            assertEquals(testArray[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    public void testIteratorConstructorIteration_SimpleNoHasNext() {\n        final List<Iterator<String>> iteratorList = new ArrayList<>();\n        iteratorList.add(list1.iterator());\n        iteratorList.add(list2.iterator());\n        iteratorList.add(list3.iterator());\n        final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());\n\n        for (int i = 0; i < 6; i++) {\n            assertEquals(testArray[i], it.next());\n        }\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    public void testIteratorConstructorIteration_WithEmptyIterators() {\n        final List<Iterator<String>> iteratorList = new ArrayList<>();\n        iteratorList.add(IteratorUtils.<String>emptyIterator());\n        iteratorList.add(list1.iterator());\n        iteratorList.add(IteratorUtils.<String>emptyIterator());\n        iteratorList.add(list2.iterator());\n        iteratorList.add(IteratorUtils.<String>emptyIterator());\n        iteratorList.add(list3.iterator());\n        iteratorList.add(IteratorUtils.<String>emptyIterator());\n        final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());\n\n        for (int i = 0; i < 6; i++) {\n            assertTrue(it.hasNext());\n            assertEquals(testArray[i], it.next());\n        }\n        assertFalse(it.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    public void testIteratorConstructorRemove() {\n        final List<Iterator<String>> iteratorList = new ArrayList<>();\n        iteratorList.add(list1.iterator());\n        iteratorList.add(list2.iterator());\n        iteratorList.add(list3.iterator());\n        final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator());\n\n        for (int i = 0; i < 6; i++) {\n            assertEquals(testArray[i], it.next());\n            it.remove();\n        }\n        assertFalse(it.hasNext());\n        assertEquals(0, list1.size());\n        assertEquals(0, list2.size());\n        assertEquals(0, list3.size());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = { \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\" }", "syntax_pass": true}, {"attribute_expression": "protected List<String> list1;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<String>", "name": "list1", "syntax_pass": true}, {"attribute_expression": "protected List<String> list2;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<String>", "name": "list2", "syntax_pass": true}, {"attribute_expression": "protected List<String> list3;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<String>", "name": "list3", "syntax_pass": true}, {"attribute_expression": "protected List<Iterator<String>> iteratorList;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<Iterator<String>>", "name": "iteratorList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_previousTest.java.SingletonListIterator_previousTest", "name": "SingletonListIterator_previousTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_previousTest.java", "superclasses": "", "methods": ["[void]testPreviousSuccess()", "[void]testPreviousBeforeFirst()", "[void]testPreviousAfterRemove()", "[void]testPreviousAfterReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_previousTest.java.SingletonListIterator_previousTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonListIterator_previousTest {\n\n    private static final Object testValue = new Object();\n    private SingletonListIterator<Object> iterator;\n\n    @BeforeEach\n    public void setUp() {\n        iterator = new SingletonListIterator<>(testValue);\n    }\n\n    @Test\n    public void testPreviousSuccess() {\n        iterator.next(); // Move to the object\n        Object previousValue = iterator.previous();\n        assertEquals(testValue, previousValue, \"Previous value should be the same as the initial object\");\n    }\n\n    @Test\n    public void testPreviousBeforeFirst() {\n        assertThrows(NoSuchElementException.class, () -> {\n            iterator.previous();\n        }, \"Calling previous before first should throw NoSuchElementException\");\n    }\n\n    @Test\n    public void testPreviousAfterRemove() {\n        iterator.next(); // Move to the object\n        iterator.remove(); // Remove the object\n        assertThrows(NoSuchElementException.class, () -> {\n            iterator.previous();\n        }, \"Calling previous after remove should throw NoSuchElementException\");\n    }\n\n    @Test\n    public void testPreviousAfterReset() {\n        iterator.next(); // Move to the object\n        iterator.reset(); // Reset the iterator\n        assertThrows(NoSuchElementException.class, () -> {\n            iterator.previous();\n        }, \"Calling previous after reset should throw NoSuchElementException\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object testValue = new Object();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "testValue = new Object()", "syntax_pass": true}, {"attribute_expression": "private SingletonListIterator<Object> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SingletonListIterator<Object>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java.NodeListIteratorTest", "name": "NodeListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java", "superclasses": "", "methods": ["[void]testEmptyIteratorWithNodeConstructor()", "[void]testFullIteratorWithNodeConstructor()", "[void]testNullConstructor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java.NodeListIteratorTest.[]NodeListIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java.NodeListIteratorTest.[Iterator<Node>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java.NodeListIteratorTest.[Iterator<Node>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java.NodeListIteratorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java.NodeListIteratorTest.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the NodeListIterator.\n", "original_string": "public class NodeListIteratorTest extends AbstractIteratorTest<Node> {\n\n    // Node array to be filled with mocked Node instances\n    private Node[] nodes;\n\n    // NodeListIterator supports two constructors. This flag allows to\n    // control, which constructor to use in makeObject() and makeEmptyIterator\n    private boolean createIteratorWithStandardConstr = true;\n\n    /**\n     * Junit Constructor\n     */\n    public NodeListIteratorTest() {\n        super(NodeListIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public Iterator<Node> makeEmptyIterator() {\n        final NodeList emptyNodeList = new NodeList() {\n            @Override\n            public int getLength() {\n                return 0;\n            }\n\n            @Override\n            public Node item(final int index) {\n                throw new IndexOutOfBoundsException();\n            }\n        };\n\n        if (createIteratorWithStandardConstr) {\n            return new NodeListIterator(emptyNodeList);\n        }\n        final Node parentNode = createMock(Node.class);\n        expect(parentNode.getChildNodes()).andStubReturn(emptyNodeList);\n        replay(parentNode);\n\n        return new NodeListIterator(parentNode);\n    }\n\n    @Override\n    public Iterator<Node> makeObject() {\n        final NodeList nodeList = new NodeList() {\n            @Override\n            public int getLength() {\n                return nodes.length;\n            }\n\n            @Override\n            public Node item(final int index) {\n                return nodes[index];\n            }\n        };\n\n        return new NodeListIterator(nodeList);\n    }\n\n    @BeforeEach\n    protected void setUp() throws Exception {\n\n        // Default: use standard constr.\n        createIteratorWithStandardConstr = true;\n\n        // create mocked Node Instances and fill Node[] to be used by test cases\n        final Node node1 = createMock(Element.class);\n        final Node node2 = createMock(Element.class);\n        final Node node3 = createMock(Text.class);\n        final Node node4 = createMock(Element.class);\n        nodes = new Node[] { node1, node2, node3, node4 };\n\n        replay(node1);\n        replay(node2);\n        replay(node3);\n        replay(node4);\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    /**\n     * tests the convenience Constructor with parameter type org.w3c.Node\n     */\n    @Test\n    public void testEmptyIteratorWithNodeConstructor() {\n        createIteratorWithStandardConstr = false;\n        testEmptyIterator();\n    }\n\n    /**\n     * tests the convenience Constructor with parameter type org.w3c.Node\n     */\n    @Test\n    public void testFullIteratorWithNodeConstructor() {\n        createIteratorWithStandardConstr = false;\n        testFullIterator();\n    }\n\n    @Test\n    public void testNullConstructor() {\n        assertThrows(NullPointerException.class, () -> new NodeListIterator((Node) null));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Node[] nodes;", "docstring": " Node array to be filled with mocked Node instances", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Node[]", "name": "nodes", "syntax_pass": true}, {"attribute_expression": "private boolean createIteratorWithStandardConstr = true;", "docstring": " control, which constructor to use in makeObject() and makeEmptyIterator", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "createIteratorWithStandardConstr = true", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PushbackIteratorTest.java.PushbackIteratorTest", "name": "PushbackIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PushbackIteratorTest.java", "superclasses": "", "methods": ["[void]testDelayedPushback()", "[void]testImmediatePushback()", "[void]testMultiplePushback()", "[void]testNormalIteration()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/PushbackIteratorTest.java.PushbackIteratorTest.[]PushbackIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/PushbackIteratorTest.java.PushbackIteratorTest.[Iterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/PushbackIteratorTest.java.PushbackIteratorTest.[PushbackIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/PushbackIteratorTest.java.PushbackIteratorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/PushbackIteratorTest.java.PushbackIteratorTest.[boolean]supportsRemove()", "src/test/java/org/apache/commons/collections4/iterators/PushbackIteratorTest.java.PushbackIteratorTest.[void]validate(Iterator<E>)"], "overrides": null, "attributes": [], "class_docstring": "\nTests the PushbackIterator.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class PushbackIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    private final String[] testArray = { \"a\", \"b\", \"c\" };\n\n    private List<E> testList;\n\n    public PushbackIteratorTest() {\n        super(PushbackIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public Iterator<E> makeEmptyIterator() {\n        return PushbackIterator.pushbackIterator(Collections.<E>emptyList().iterator());\n    }\n\n    @Override\n    public PushbackIterator<E> makeObject() {\n        return PushbackIterator.pushbackIterator(testList.iterator());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    protected void setUp() throws Exception {\n        testList = new ArrayList<>(Arrays.asList((E[]) testArray));\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testDelayedPushback() {\n        final PushbackIterator<E> iter = makeObject();\n        assertEquals(\"a\", iter.next());\n        iter.pushback((E) \"x\");\n        assertEquals(\"x\", iter.next());\n        assertEquals(\"b\", iter.next());\n        validate(iter, \"c\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testImmediatePushback() {\n        final PushbackIterator<E> iter = makeObject();\n        iter.pushback((E) \"x\");\n        assertEquals(\"x\", iter.next());\n        assertEquals(\"a\", iter.next());\n        validate(iter, \"b\", \"c\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiplePushback() {\n        final PushbackIterator<E> iter = makeObject();\n        assertEquals(\"a\", iter.next());\n        iter.pushback((E) \"x\");\n        iter.pushback((E) \"y\");\n        assertEquals(\"y\", iter.next());\n        assertEquals(\"x\", iter.next());\n        assertEquals(\"b\", iter.next());\n        validate(iter, \"c\");\n    }\n\n    @Test\n    public void testNormalIteration() {\n        final PushbackIterator<E> iter = makeObject();\n        assertEquals(\"a\", iter.next());\n        assertEquals(\"b\", iter.next());\n        assertEquals(\"c\", iter.next());\n        assertFalse(iter.hasNext());\n    }\n\n    private void validate(final Iterator<E> iter, final Object... items) {\n        for (final Object x : items) {\n            assertTrue(iter.hasNext());\n            assertEquals(x, iter.next());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final String[] testArray = { \"a\", \"b\", \"c\" };", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "testArray = { \"a\", \"b\", \"c\" }", "syntax_pass": true}, {"attribute_expression": "private List<E> testList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<E>", "name": "testList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java.SingletonListIteratorTest", "name": "SingletonListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java", "superclasses": "", "methods": ["[void]testIterator()", "[void]testReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java.SingletonListIteratorTest.[]SingletonListIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java.SingletonListIteratorTest.[SingletonListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java.SingletonListIteratorTest.[SingletonListIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java.SingletonListIteratorTest.[boolean]supportsAdd()", "src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java.SingletonListIteratorTest.[boolean]supportsEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java.SingletonListIteratorTest.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the SingletonListIterator.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class SingletonListIteratorTest<E> extends AbstractListIteratorTest<E> {\n\n    private static final Object testValue = \"foo\";\n\n    public SingletonListIteratorTest() {\n        super(SingletonListIteratorTest.class.getSimpleName());\n    }\n\n    /**\n     * Returns a SingletonListIterator from which\n     * the element has already been removed.\n     */\n    @Override\n    public SingletonListIterator<E> makeEmptyIterator() {\n        final SingletonListIterator<E> iter = makeObject();\n        iter.next();\n        iter.remove();\n        iter.reset();\n        return iter;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SingletonListIterator<E> makeObject() {\n        return new SingletonListIterator<>((E) testValue);\n    }\n\n    @Override\n    public boolean supportsAdd() {\n        return false;\n    }\n\n    @Override\n    public boolean supportsEmptyIterator() {\n        return true;\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return true;\n    }\n\n    @Test\n    public void testIterator() {\n        final ListIterator<E> iter = makeObject();\n        assertTrue(iter.hasNext(), \"Iterator should have next item\");\n        assertFalse(iter.hasPrevious(), \"Iterator should have no previous item\");\n        assertEquals(0, iter.nextIndex(), \"Iteration next index\");\n        assertEquals(-1, iter.previousIndex(), \"Iteration previous index\");\n\n        Object iterValue = iter.next();\n        assertEquals(testValue, iterValue, \"Iteration value is correct\");\n\n        assertFalse(iter.hasNext(), \"Iterator should have no next item\");\n        assertTrue(iter.hasPrevious(), \"Iterator should have previous item\");\n        assertEquals(1, iter.nextIndex(), \"Iteration next index\");\n        assertEquals(0, iter.previousIndex(), \"Iteration previous index\");\n\n        iterValue = iter.previous();\n        assertEquals(testValue, iterValue, \"Iteration value is correct\");\n\n        assertTrue(iter.hasNext(), \"Iterator should have next item\");\n        assertFalse(iter.hasPrevious(), \"Iterator should have no previous item\");\n        assertEquals(0, iter.nextIndex(), \"Iteration next index\");\n        assertEquals(-1, iter.previousIndex(), \"Iteration previous index\");\n\n        iterValue = iter.next();\n        assertEquals(testValue, iterValue, \"Iteration value is correct\");\n\n        assertFalse(iter.hasNext(), \"Iterator should have no next item\");\n        assertTrue(iter.hasPrevious(), \"Iterator should have previous item\");\n        assertEquals(1, iter.nextIndex(), \"Iteration next index\");\n        assertEquals(0, iter.previousIndex(), \"Iteration previous index\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n        iter.previous();\n        try {\n            iter.previous();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n    }\n\n    @Test\n    public void testReset() {\n        final ResettableListIterator<E> it = makeObject();\n\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        assertEquals(testValue, it.next());\n        assertFalse(it.hasNext());\n        assertTrue(it.hasPrevious());\n\n        it.reset();\n\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        assertEquals(testValue, it.next());\n        assertFalse(it.hasNext());\n        assertTrue(it.hasPrevious());\n\n        it.reset();\n        it.reset();\n\n        assertTrue(it.hasNext());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object testValue = \"foo\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "testValue = \"foo\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIterator_nextTest.java.ObjectArrayIterator_nextTest", "name": "ObjectArrayIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNextWithElements()", "[void]testNextWithoutElements()", "[void]testNextAfterReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIterator_nextTest.java.ObjectArrayIterator_nextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ObjectArrayIterator_nextTest {\n\n    private String[] testArray;\n    private ObjectArrayIterator<String> iterator;\n\n    @BeforeEach\n    public void setUp() {\n        testArray = new String[] {\"One\", \"Two\", \"Three\"};\n        iterator = new ObjectArrayIterator<>(testArray);\n    }\n\n    @Test\n    public void testNextWithElements() {\n        assertEquals(\"One\", iterator.next());\n        assertEquals(\"Two\", iterator.next());\n        assertEquals(\"Three\", iterator.next());\n    }\n\n    @Test\n    public void testNextWithoutElements() {\n        iterator.next();\n        iterator.next();\n        iterator.next();\n        assertThrows(NoSuchElementException.class, () -> {\n            iterator.next();\n        });\n    }\n\n    @Test\n    public void testNextAfterReset() {\n        assertEquals(\"One\", iterator.next());\n        iterator.reset();\n        assertEquals(\"One\", iterator.next());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private String[] testArray;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String[]", "name": "testArray", "syntax_pass": true}, {"attribute_expression": "private ObjectArrayIterator<String> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ObjectArrayIterator<String>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/LazyIteratorChainTest.java.LazyIteratorChainTest", "name": "LazyIteratorChainTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/LazyIteratorChainTest.java", "superclasses": "", "methods": ["[void]testEmptyChain()", "[void]testFirstIteratorIsEmptyBug()", "[void]testIterator()", "[void]testRemove()", "[void]testRemoveFromFilteredIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/LazyIteratorChainTest.java.LazyIteratorChainTest.[]LazyIteratorChainTest()", "src/test/java/org/apache/commons/collections4/iterators/LazyIteratorChainTest.java.LazyIteratorChainTest.[LazyIteratorChain<String>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/LazyIteratorChainTest.java.LazyIteratorChainTest.[LazyIteratorChain<String>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/LazyIteratorChainTest.java.LazyIteratorChainTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the LazyIteratorChain class.\n", "original_string": "public class LazyIteratorChainTest extends AbstractIteratorTest<String> {\n\n    protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };\n\n    protected List<String> list1;\n    protected List<String> list2;\n    protected List<String> list3;\n\n    public LazyIteratorChainTest() {\n        super(LazyIteratorChainTest.class.getSimpleName());\n    }\n\n    @Override\n    public LazyIteratorChain<String> makeEmptyIterator() {\n        return new LazyIteratorChain<String>() {\n            @Override\n            protected Iterator<String> nextIterator(final int count) {\n                return null;\n            }\n        };\n    }\n\n    @Override\n    public LazyIteratorChain<String> makeObject() {\n        return new LazyIteratorChain<String>() {\n            @Override\n            protected Iterator<String> nextIterator(final int count) {\n                switch (count) {\n                case 1:\n                    return list1.iterator();\n                case 2:\n                    return list2.iterator();\n                case 3:\n                    return list3.iterator();\n                }\n                return null;\n            }\n        };\n    }\n\n    @BeforeEach\n    public void setUp() {\n        list1 = new ArrayList<>();\n        list1.add(\"One\");\n        list1.add(\"Two\");\n        list1.add(\"Three\");\n        list2 = new ArrayList<>();\n        list2.add(\"Four\");\n        list3 = new ArrayList<>();\n        list3.add(\"Five\");\n        list3.add(\"Six\");\n    }\n\n    @Test\n    public void testEmptyChain() {\n        final LazyIteratorChain<String> chain = makeEmptyIterator();\n        assertFalse(chain.hasNext());\n        assertAll(\n                () -> assertThrows(NoSuchElementException.class, () -> chain.next()),\n                () -> assertThrows(IllegalStateException.class, () -> chain.remove())\n        );\n    }\n\n    @Test\n    public void testFirstIteratorIsEmptyBug() {\n        final List<String> empty = new ArrayList<>();\n        final List<String> notEmpty = new ArrayList<>();\n        notEmpty.add(\"A\");\n        notEmpty.add(\"B\");\n        notEmpty.add(\"C\");\n        final LazyIteratorChain<String> chain = new LazyIteratorChain<String>() {\n            @Override\n            protected Iterator<String> nextIterator(final int count) {\n                switch (count) {\n                case 1:\n                    return empty.iterator();\n                case 2:\n                    return notEmpty.iterator();\n                }\n                return null;\n            }\n        };\n        assertTrue(chain.hasNext(), \"should have next\");\n        assertEquals(\"A\", chain.next());\n        assertTrue(chain.hasNext(), \"should have next\");\n        assertEquals(\"B\", chain.next());\n        assertTrue(chain.hasNext(), \"should have next\");\n        assertEquals(\"C\", chain.next());\n        assertFalse(chain.hasNext(), \"should not have next\");\n    }\n\n    @Test\n    public void testIterator() {\n        final Iterator<String> iter = makeObject();\n        for (final String testValue : testArray) {\n            final Object iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n    }\n\n    @Test\n    @Override\n    public void testRemove() {\n        final Iterator<String> iter = makeObject();\n\n        assertThrows(IllegalStateException.class, () -> iter.remove(),\n                \"Calling remove before the first call to next() should throw an exception\");\n\n        for (final String testValue : testArray) {\n            final String iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n\n            if (!iterValue.equals(\"Four\")) {\n                iter.remove();\n            }\n        }\n\n        assertTrue(list1.isEmpty(), \"List is empty\");\n        assertEquals(1, list2.size(), \"List is empty\");\n        assertTrue(list3.isEmpty(), \"List is empty\");\n    }\n\n    @Test\n    public void testRemoveFromFilteredIterator() {\n\n        final Predicate<Integer> myPredicate = i -> i.compareTo(Integer.valueOf(4)) < 0;\n\n        final List<Integer> list1 = new ArrayList<>();\n        final List<Integer> list2 = new ArrayList<>();\n\n        list1.add(Integer.valueOf(1));\n        list1.add(Integer.valueOf(2));\n        list2.add(Integer.valueOf(3));\n        list2.add(Integer.valueOf(4)); // will be ignored by the predicate\n\n        final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);\n        final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);\n\n        final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);\n        while (it.hasNext()) {\n            it.next();\n            it.remove();\n        }\n        assertEquals(0, list1.size());\n        assertEquals(1, list2.size());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    }", "syntax_pass": true}, {"attribute_expression": "protected List<String> list1;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<String>", "name": "list1", "syntax_pass": true}, {"attribute_expression": "protected List<String> list2;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<String>", "name": "list2", "syntax_pass": true}, {"attribute_expression": "protected List<String> list3;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<String>", "name": "list3", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SingletonIterator2Test.java.SingletonIterator2Test", "name": "SingletonIterator2Test", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SingletonIterator2Test.java", "superclasses": "", "methods": ["[void]testIterator()", "[void]testReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SingletonIterator2Test.java.SingletonIterator2Test.[]SingletonIterator2Test()", "src/test/java/org/apache/commons/collections4/iterators/SingletonIterator2Test.java.SingletonIterator2Test.[SingletonIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/SingletonIterator2Test.java.SingletonIterator2Test.[SingletonIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/SingletonIterator2Test.java.SingletonIterator2Test.[boolean]supportsEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/SingletonIterator2Test.java.SingletonIterator2Test.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the SingletonIterator to ensure that the next() method will actually\nperform the iteration rather than the hasNext() method.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class SingletonIterator2Test<E> extends AbstractIteratorTest<E> {\n\n    private static final Object testValue = \"foo\";\n\n    public SingletonIterator2Test() {\n        super(SingletonIterator2Test.class.getSimpleName());\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SingletonIterator<E> makeEmptyIterator() {\n        final SingletonIterator<E> iter = new SingletonIterator<>((E) testValue);\n        iter.next();\n        iter.remove();\n        iter.reset();\n        return iter;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SingletonIterator<E> makeObject() {\n        return new SingletonIterator<>((E) testValue, false);\n    }\n\n    @Override\n    public boolean supportsEmptyIterator() {\n        return false;\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Test\n    public void testIterator() {\n        final Iterator<E> iter = makeObject();\n        assertTrue(iter.hasNext(), \"Iterator has a first item\");\n\n        final E iterValue = iter.next();\n        assertEquals(testValue, iterValue, \"Iteration value is correct\");\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n    }\n\n    @Test\n    public void testReset() {\n        final ResettableIterator<E> it = makeObject();\n\n        assertTrue(it.hasNext());\n        assertEquals(testValue, it.next());\n        assertFalse(it.hasNext());\n\n        it.reset();\n\n        assertTrue(it.hasNext());\n        assertEquals(testValue, it.next());\n        assertFalse(it.hasNext());\n\n        it.reset();\n        it.reset();\n\n        assertTrue(it.hasNext());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object testValue = \"foo\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "testValue = \"foo\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java.FilterListIteratorTest", "name": "FilterListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java", "superclasses": "", "methods": ["[void]testCollections360()", "[void]testEvens()", "[void]testFailingHasNextBug()", "[void]testFalsePredicate()", "[void]testFours()", "[void]testManual()", "[void]testNestedSixes()", "[void]testNestedSixes2()", "[void]testNestedSixes3()", "[void]testNextChangesPrevious()", "[void]testOdds()", "[void]testPreviousChangesNext()", "[void]testThrees()", "[void]testTruePredicate()", "[void]testWalkLists()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java.FilterListIteratorTest.[void]nextNextPrevious(ListIterator<?>,ListIterator<?>)", "src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java.FilterListIteratorTest.[void]previousPreviousNext(ListIterator<?>,ListIterator<?>)", "src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java.FilterListIteratorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java.FilterListIteratorTest.[void]tearDown()", "src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java.FilterListIteratorTest.[void]walkBackward(ListIterator<?>,ListIterator<?>)", "src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java.FilterListIteratorTest.[void]walkForward(ListIterator<?>,ListIterator<?>)", "src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java.FilterListIteratorTest.[void]walkLists(List<E>,ListIterator<E>)"], "overrides": null, "attributes": [], "class_docstring": "\nTests the FilterListIterator class.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class FilterListIteratorTest {\n\n    private ArrayList<Integer> list;\n    private ArrayList<Integer> odds;\n    private ArrayList<Integer> evens;\n    private ArrayList<Integer> threes;\n    private ArrayList<Integer> fours;\n    private ArrayList<Integer> sixes;\n    private Predicate<Integer> truePred;\n    private Predicate<Integer> falsePred;\n    private Predicate<Integer> evenPred;\n    private Predicate<Integer> oddPred;\n    private Predicate<Integer> threePred;\n    private Predicate<Integer> fourPred;\n    private final Random random = new Random();\n\n    private void nextNextPrevious(final ListIterator<?> expected, final ListIterator<?> testing) {\n        // calls to next() should change the value returned by previous()\n        // even after previous() has been set by a call to hasPrevious()\n        assertEquals(expected.next(), testing.next());\n        assertEquals(expected.hasPrevious(), testing.hasPrevious());\n        final Object expecteda = expected.next();\n        final Object testinga = testing.next();\n        assertEquals(expecteda, testinga);\n        final Object expectedb = expected.previous();\n        final Object testingb = testing.previous();\n        assertEquals(expecteda, expectedb);\n        assertEquals(testinga, testingb);\n    }\n\n    private void previousPreviousNext(final ListIterator<?> expected, final ListIterator<?> testing) {\n        // calls to previous() should change the value returned by next()\n        // even after next() has been set by a call to hasNext()\n        assertEquals(expected.previous(), testing.previous());\n        assertEquals(expected.hasNext(), testing.hasNext());\n        final Object expecteda = expected.previous();\n        final Object testinga = testing.previous();\n        assertEquals(expecteda, testinga);\n        final Object expectedb = expected.next();\n        final Object testingb = testing.next();\n        assertEquals(expecteda, testingb);\n        assertEquals(expecteda, expectedb);\n        assertEquals(testinga, testingb);\n    }\n\n    @BeforeEach\n    public void setUp() {\n        list = new ArrayList<>();\n        odds = new ArrayList<>();\n        evens = new ArrayList<>();\n        threes = new ArrayList<>();\n        fours = new ArrayList<>();\n        sixes = new ArrayList<>();\n        for (int i = 0; i < 20; i++) {\n            list.add(Integer.valueOf(i));\n            if (i % 2 == 0) {\n                evens.add(Integer.valueOf(i));\n            }\n            if (i % 2 != 0) {\n                odds.add(Integer.valueOf(i));\n            }\n            if (i % 3 == 0) {\n                threes.add(Integer.valueOf(i));\n            }\n            if (i % 4 == 0) {\n                fours.add(Integer.valueOf(i));\n            }\n            if (i % 6 == 0) {\n                sixes.add(Integer.valueOf(i));\n            }\n        }\n\n        truePred = x -> true;\n\n        falsePred = x -> true;\n\n        evenPred = x -> x % 2 == 0;\n\n        oddPred = x -> x % 2 != 0;\n\n        threePred = x -> x % 3 == 0;\n\n        fourPred = x -> x % 4 == 0;\n\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception {\n        list = null;\n        odds = null;\n        evens = null;\n        threes = null;\n        fours = null;\n        sixes = null;\n        truePred = null;\n        falsePred = null;\n        evenPred = null;\n        oddPred = null;\n        threePred = null;\n        fourPred = null;\n    }\n\n    /**\n     * Test for {@link \"https://issues.apache.org/jira/browse/COLLECTIONS-360 COLLECTIONS-360\"}\n     */\n    @Test\n    public void testCollections360() throws Throwable {\n        final Collection<Predicate<Object>> var7 = new GrowthList<>();\n        final Predicate<Object> var9 = PredicateUtils.anyPredicate(var7);\n        final FilterListIterator<Object> var13 = new FilterListIterator<>(var9);\n        assertFalse(var13.hasNext());\n        final FilterListIterator<Object> var14 = new FilterListIterator<>(var9);\n        assertFalse(var14.hasPrevious());\n    }\n\n    @Test\n    public void testEvens() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), evenPred);\n        walkLists(evens, filtered);\n    }\n\n    @Test\n    public void testFailingHasNextBug() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), fourPred);\n        final ListIterator<Integer> expected = fours.listIterator();\n        while (expected.hasNext()) {\n            expected.next();\n            filtered.next();\n        }\n        assertTrue(filtered.hasPrevious());\n        assertFalse(filtered.hasNext());\n        assertEquals(expected.previous(), filtered.previous());\n    }\n\n    @Test\n    public void testFalsePredicate() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), falsePred);\n        walkLists(new ArrayList<>(), filtered);\n    }\n\n    @Test\n    public void testFours() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), fourPred);\n        walkLists(fours, filtered);\n    }\n\n    @Test\n    public void testManual() {\n        // do this one \"by hand\" as a sanity check\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);\n\n        assertEquals(Integer.valueOf(0), filtered.next());\n        assertEquals(Integer.valueOf(3), filtered.next());\n        assertEquals(Integer.valueOf(6), filtered.next());\n        assertEquals(Integer.valueOf(9), filtered.next());\n        assertEquals(Integer.valueOf(12), filtered.next());\n        assertEquals(Integer.valueOf(15), filtered.next());\n        assertEquals(Integer.valueOf(18), filtered.next());\n\n        assertEquals(Integer.valueOf(18), filtered.previous());\n        assertEquals(Integer.valueOf(15), filtered.previous());\n        assertEquals(Integer.valueOf(12), filtered.previous());\n        assertEquals(Integer.valueOf(9), filtered.previous());\n        assertEquals(Integer.valueOf(6), filtered.previous());\n        assertEquals(Integer.valueOf(3), filtered.previous());\n        assertEquals(Integer.valueOf(0), filtered.previous());\n\n        assertFalse(filtered.hasPrevious());\n\n        assertEquals(Integer.valueOf(0), filtered.next());\n        assertEquals(Integer.valueOf(3), filtered.next());\n        assertEquals(Integer.valueOf(6), filtered.next());\n        assertEquals(Integer.valueOf(9), filtered.next());\n        assertEquals(Integer.valueOf(12), filtered.next());\n        assertEquals(Integer.valueOf(15), filtered.next());\n        assertEquals(Integer.valueOf(18), filtered.next());\n\n        assertFalse(filtered.hasNext());\n\n        assertEquals(Integer.valueOf(18), filtered.previous());\n        assertEquals(Integer.valueOf(15), filtered.previous());\n        assertEquals(Integer.valueOf(12), filtered.previous());\n        assertEquals(Integer.valueOf(9), filtered.previous());\n        assertEquals(Integer.valueOf(6), filtered.previous());\n        assertEquals(Integer.valueOf(3), filtered.previous());\n        assertEquals(Integer.valueOf(0), filtered.previous());\n\n        assertEquals(Integer.valueOf(0), filtered.next());\n        assertEquals(Integer.valueOf(0), filtered.previous());\n        assertEquals(Integer.valueOf(0), filtered.next());\n\n        assertEquals(Integer.valueOf(3), filtered.next());\n        assertEquals(Integer.valueOf(6), filtered.next());\n        assertEquals(Integer.valueOf(6), filtered.previous());\n        assertEquals(Integer.valueOf(3), filtered.previous());\n        assertEquals(Integer.valueOf(3), filtered.next());\n        assertEquals(Integer.valueOf(6), filtered.next());\n\n        assertEquals(Integer.valueOf(9), filtered.next());\n        assertEquals(Integer.valueOf(12), filtered.next());\n        assertEquals(Integer.valueOf(15), filtered.next());\n        assertEquals(Integer.valueOf(15), filtered.previous());\n        assertEquals(Integer.valueOf(12), filtered.previous());\n        assertEquals(Integer.valueOf(9), filtered.previous());\n    }\n\n    @Test\n    public void testNestedSixes() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(\n                                        new FilterListIterator<>(list.listIterator(), threePred),\n                                        evenPred\n                                      );\n        walkLists(sixes, filtered);\n    }\n\n    @Test\n    public void testNestedSixes2() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(\n                                        new FilterListIterator<>(list.listIterator(), evenPred),\n                                        threePred\n                                      );\n        walkLists(sixes, filtered);\n    }\n\n    @Test\n    public void testNestedSixes3() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(\n                                        new FilterListIterator<>(list.listIterator(), threePred),\n                                        evenPred\n                                      );\n        walkLists(sixes, new FilterListIterator<>(filtered, truePred));\n    }\n\n    @Test\n    public void testNextChangesPrevious() {\n        {\n            final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);\n            nextNextPrevious(threes.listIterator(), filtered);\n        }\n\n        {\n            final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);\n            nextNextPrevious(list.listIterator(), filtered);\n        }\n    }\n\n    @Test\n    public void testOdds() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), oddPred);\n        walkLists(odds, filtered);\n    }\n\n    @Test\n    public void testPreviousChangesNext() {\n        {\n            final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);\n            final ListIterator<Integer> expected = threes.listIterator();\n            walkForward(expected, filtered);\n            previousPreviousNext(expected, filtered);\n        }\n        {\n            final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);\n            final ListIterator<Integer> expected = list.listIterator();\n            walkForward(expected, filtered);\n            previousPreviousNext(expected, filtered);\n        }\n    }\n\n    @Test\n    public void testThrees() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);\n        walkLists(threes, filtered);\n    }\n\n    // Utilities\n\n    @Test\n    public void testTruePredicate() {\n        final FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);\n        walkLists(list, filtered);\n    }\n\n    @Test\n    public void testWalkLists() {\n        // this just confirms that our walkLists method works OK\n        walkLists(list, list.listIterator());\n    }\n\n    private void walkBackward(final ListIterator<?> expected, final ListIterator<?> testing) {\n        while (expected.hasPrevious()) {\n            assertEquals(expected.nextIndex(), testing.nextIndex());\n            assertEquals(expected.previousIndex(), testing.previousIndex());\n            assertTrue(testing.hasPrevious());\n            assertEquals(expected.previous(), testing.previous());\n        }\n    }\n\n    private void walkForward(final ListIterator<?> expected, final ListIterator<?> testing) {\n        while (expected.hasNext()) {\n            assertEquals(expected.nextIndex(), testing.nextIndex());\n            assertEquals(expected.previousIndex(), testing.previousIndex());\n            assertTrue(testing.hasNext());\n            assertEquals(expected.next(), testing.next());\n        }\n    }\n\n    private <E> void walkLists(final List<E> list, final ListIterator<E> testing) {\n        final ListIterator<E> expected = list.listIterator();\n\n        // walk all the way forward\n        walkForward(expected, testing);\n\n        // walk all the way back\n        walkBackward(expected, testing);\n\n        // forward,back,forward\n        while (expected.hasNext()) {\n            assertEquals(expected.nextIndex(), testing.nextIndex());\n            assertEquals(expected.previousIndex(), testing.previousIndex());\n            assertTrue(testing.hasNext());\n            assertEquals(expected.next(), testing.next());\n            assertTrue(testing.hasPrevious());\n            assertEquals(expected.previous(), testing.previous());\n            assertTrue(testing.hasNext());\n            assertEquals(expected.next(), testing.next());\n        }\n\n        // walk all the way back\n        walkBackward(expected, testing);\n\n        for (int i = 0; i < list.size(); i++) {\n            // walk forward i\n            for (int j = 0; j < i; j++) {\n                assertEquals(expected.nextIndex(), testing.nextIndex());\n                assertEquals(expected.previousIndex(), testing.previousIndex());\n                assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test\n                assertTrue(testing.hasNext());\n                assertEquals(expected.next(), testing.next());\n            }\n            // walk back i/2\n            for (int j = 0; j < i / 2; j++) {\n                assertEquals(expected.nextIndex(), testing.nextIndex());\n                assertEquals(expected.previousIndex(), testing.previousIndex());\n                assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test\n                assertTrue(testing.hasPrevious());\n                assertEquals(expected.previous(), testing.previous());\n            }\n            // walk forward i/2\n            for (int j = 0; j < i / 2; j++) {\n                assertEquals(expected.nextIndex(), testing.nextIndex());\n                assertEquals(expected.previousIndex(), testing.previousIndex());\n                assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test\n                assertTrue(testing.hasNext());\n                assertEquals(expected.next(), testing.next());\n            }\n            // walk back i\n            for (int j = 0; j < i; j++) {\n                assertEquals(expected.nextIndex(), testing.nextIndex());\n                assertEquals(expected.previousIndex(), testing.previousIndex());\n                assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test\n                assertTrue(testing.hasPrevious());\n                assertEquals(expected.previous(), testing.previous());\n            }\n        }\n\n        // random walk\n        final StringBuilder walkdescr = new StringBuilder(500);\n        for (int i = 0; i < 500; i++) {\n            if (random.nextBoolean()) {\n                // step forward\n                walkdescr.append(\"+\");\n                if (expected.hasNext()) {\n                    assertEquals(expected.next(), testing.next(), walkdescr.toString());\n                }\n            } else {\n                // step backward\n                walkdescr.append(\"-\");\n                if (expected.hasPrevious()) {\n                    assertEquals(expected.previous(), testing.previous(), walkdescr.toString());\n                }\n            }\n            assertEquals(expected.nextIndex(), testing.nextIndex(), walkdescr.toString());\n            assertEquals(expected.previousIndex(), testing.previousIndex(), walkdescr.toString());\n        }\n\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ArrayList<Integer> list;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> odds;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "odds", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> evens;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "evens", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> threes;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "threes", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> fours;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "fours", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> sixes;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "sixes", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> truePred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "truePred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> falsePred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "falsePred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> evenPred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "evenPred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> oddPred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "oddPred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> threePred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "threePred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> fourPred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "fourPred", "syntax_pass": true}, {"attribute_expression": "private final Random random = new Random();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Random", "name": "random = new Random()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/FilterListIterator_nextTest.java.FilterListIterator_nextTest", "name": "FilterListIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/FilterListIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNextWithValidElement()", "[void]testNextWithNoValidElement()", "[void]testNextWithMultipleValidElements()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/FilterListIterator_nextTest.java.FilterListIterator_nextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FilterListIterator_nextTest {\n\n    private ArrayList<Integer> list;\n    private ArrayList<Integer> fours;\n    private Predicate<Integer> fourPred;\n\n    @BeforeEach\n    public void setUp() {\n        list = new ArrayList<>();\n        fours = new ArrayList<>();\n        for (int i = 0; i < 20; i++) {\n            list.add(Integer.valueOf(i));\n            if (i % 4 == 0) {\n                fours.add(Integer.valueOf(i));\n            }\n        }\n\n        fourPred = x -> x % 4 == 0;\n    }\n\n    @Test\n    public void testNextWithValidElement() {\n        FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), fourPred);\n        assertTrue(filtered.hasNext());\n        assertEquals(fours.get(0), filtered.next());\n    }\n\n    @Test\n    public void testNextWithNoValidElement() {\n        FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), x -> x % 100 == 0);\n        assertThrows(NoSuchElementException.class, () -> {\n            while (filtered.hasNext()) {\n                filtered.next();\n            }\n            filtered.next(); // This should throw NoSuchElementException\n        });\n    }\n\n    @Test\n    public void testNextWithMultipleValidElements() {\n        FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), fourPred);\n        ListIterator<Integer> expected = fours.listIterator();\n        while (expected.hasNext()) {\n            assertEquals(expected.next(), filtered.next());\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ArrayList<Integer> list;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> fours;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "fours", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> fourPred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "fourPred", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_removeTest.java.PeekingIterator_removeTest", "name": "PeekingIterator_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveAfterNext()", "[void]testRemoveWithoutPeekOrElement()", "[void]testRemoveAfterPeek()", "[void]testRemoveAfterElement()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_removeTest.java.PeekingIterator_removeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PeekingIterator_removeTest {\n\n    private List<String> testList;\n    private static final String[] testArray = {\"a\", \"b\", \"c\"};\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    protected void setUp() throws Exception {\n        testList = new ArrayList<>(Arrays.asList((String[]) testArray));\n    }\n\n    @Test\n    public void testRemoveAfterNext() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertTrue(it.hasNext());\n        assertEquals(\"a\", it.next());\n        it.remove();\n        assertEquals(Arrays.asList(\"b\", \"c\"), testList);\n    }\n\n    @Test\n    public void testRemoveWithoutPeekOrElement() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertTrue(it.hasNext());\n        assertThrows(IllegalStateException.class, () -> it.remove());\n    }\n\n    @Test\n    public void testRemoveAfterPeek() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertTrue(it.hasNext());\n        assertEquals(\"a\", it.peek());\n        assertThrows(IllegalStateException.class, () -> it.remove());\n    }\n\n    @Test\n    public void testRemoveAfterElement() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertTrue(it.hasNext());\n        assertEquals(\"a\", it.element());\n        assertThrows(IllegalStateException.class, () -> it.remove());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<String> testList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "testList", "syntax_pass": true}, {"attribute_expression": "private static final String[] testArray = {\"a\", \"b\", \"c\"};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "testArray = {\"a\", \"b\", \"c\"}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/NodeListIterator_nextTest.java.NodeListIterator_nextTest", "name": "NodeListIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/NodeListIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNextWithElements()", "[void]testNextWithNoElements()", "[void]testNextWithNodeConstructor()", "[void]testNextWithNodeConstructorNoElements()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/NodeListIterator_nextTest.java.NodeListIterator_nextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class NodeListIterator_nextTest {\n\n    private NodeListIterator nodeListIterator;\n    private Node[] nodes;\n    private boolean createIteratorWithStandardConstr;\n\n    @BeforeEach\n    protected void setUp() throws Exception {\n        // Default: use standard constr.\n        createIteratorWithStandardConstr = true;\n\n        // create mocked Node Instances and fill Node[] to be used by test cases\n        final Node node1 = createMock(Element.class);\n        final Node node2 = createMock(Element.class);\n        final Node node3 = createMock(Text.class);\n        final Node node4 = createMock(Element.class);\n        nodes = new Node[] { node1, node2, node3, node4 };\n\n        replay(node1);\n        replay(node2);\n        replay(node3);\n        replay(node4);\n    }\n\n    @Test\n    public void testNextWithElements() {\n        NodeList nodeList = createMock(NodeList.class);\n        expect(nodeList.getLength()).andReturn(nodes.length).anyTimes();\n        for (int i = 0; i < nodes.length; i++) {\n            expect(nodeList.item(i)).andReturn(nodes[i]).anyTimes();\n        }\n        replay(nodeList);\n\n        nodeListIterator = new NodeListIterator(nodeList);\n\n        for (Node node : nodes) {\n            assertEquals(node, nodeListIterator.next());\n        }\n    }\n\n    @Test\n    public void testNextWithNoElements() {\n        NodeList nodeList = createMock(NodeList.class);\n        expect(nodeList.getLength()).andReturn(0).anyTimes();\n        replay(nodeList);\n\n        nodeListIterator = new NodeListIterator(nodeList);\n\n        assertThrows(NoSuchElementException.class, () -> {\n            nodeListIterator.next();\n        });\n    }\n\n    @Test\n    public void testNextWithNodeConstructor() {\n        Node node = createMock(Element.class);\n        NodeList nodeList = createMock(NodeList.class);\n        expect(node.getChildNodes()).andReturn(nodeList).anyTimes();\n        expect(nodeList.getLength()).andReturn(nodes.length).anyTimes();\n        for (int i = 0; i < nodes.length; i++) {\n            expect(nodeList.item(i)).andReturn(nodes[i]).anyTimes();\n        }\n        replay(node);\n        replay(nodeList);\n\n        nodeListIterator = new NodeListIterator(node);\n\n        for (Node childNode : nodes) {\n            assertEquals(childNode, nodeListIterator.next());\n        }\n    }\n\n    @Test\n    public void testNextWithNodeConstructorNoElements() {\n        Node node = createMock(Element.class);\n        NodeList nodeList = createMock(NodeList.class);\n        expect(node.getChildNodes()).andReturn(nodeList).anyTimes();\n        expect(nodeList.getLength()).andReturn(0).anyTimes();\n        replay(node);\n        replay(nodeList);\n\n        nodeListIterator = new NodeListIterator(node);\n\n        assertThrows(NoSuchElementException.class, () -> {\n            nodeListIterator.next();\n        });\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private NodeListIterator nodeListIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "NodeListIterator", "name": "nodeListIterator", "syntax_pass": true}, {"attribute_expression": "private Node[] nodes;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Node[]", "name": "nodes", "syntax_pass": true}, {"attribute_expression": "private boolean createIteratorWithStandardConstr;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "createIteratorWithStandardConstr", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SkippingIterator_nextTest.java.SkippingIterator_nextTest", "name": "SkippingIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SkippingIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNext()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SkippingIterator_nextTest {\n\n    @Test\n    public void testNext() {\n        Iterator<String> iterator = Arrays.asList(\"a\", \"b\", \"c\", \"d\").iterator();\n        SkippingIterator<String> skippingIterator = new SkippingIterator<>(iterator, 2);\n\n        assertEquals(\"c\", skippingIterator.next());\n        assertEquals(\"d\", skippingIterator.next());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java.ArrayIterator2Test", "name": "ArrayIterator2Test", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java", "superclasses": "", "methods": ["[void]testIndexedArray()", "[void]testIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java.ArrayIterator2Test.[]ArrayIterator2Test()", "src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java.ArrayIterator2Test.[ArrayIterator<E>]makeArrayIterator(Object)", "src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java.ArrayIterator2Test.[ArrayIterator<E>]makeArrayIterator(Object,int)", "src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java.ArrayIterator2Test.[ArrayIterator<E>]makeArrayIterator(Object,int,int)", "src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java.ArrayIterator2Test.[ArrayIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java.ArrayIterator2Test.[ArrayIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java.ArrayIterator2Test.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the ArrayIterator with primitive type arrays.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ArrayIterator2Test<E> extends AbstractIteratorTest<E> {\n\n    protected int[] testArray = { 2, 4, 6, 8 };\n\n    public ArrayIterator2Test() {\n        super(ArrayIterator2Test.class.getSimpleName());\n    }\n\n    public ArrayIterator<E> makeArrayIterator(final Object array) {\n        return new ArrayIterator<>(array);\n    }\n\n    public ArrayIterator<E> makeArrayIterator(final Object array, final int index) {\n        return new ArrayIterator<>(array, index);\n    }\n\n    public ArrayIterator<E> makeArrayIterator(final Object array, final int start, final int end) {\n        return new ArrayIterator<>(array, start, end);\n    }\n\n    @Override\n    public ArrayIterator<E> makeEmptyIterator() {\n        return new ArrayIterator<>(new int[0]);\n    }\n\n    @Override\n    public ArrayIterator<E> makeObject() {\n        return new ArrayIterator<>(testArray);\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Test\n    public void testIndexedArray() {\n        Iterator<E> iter = makeArrayIterator(testArray, 2);\n        int count = 0;\n        while (iter.hasNext()) {\n            ++count;\n            iter.next();\n        }\n\n        assertEquals(count, testArray.length - 2, \"the count should be right using ArrayIterator(Object,2) \");\n\n        iter = makeArrayIterator(testArray, 1, testArray.length - 1);\n        count = 0;\n        while (iter.hasNext()) {\n            ++count;\n            iter.next();\n        }\n\n        assertEquals(\n                count,\n                testArray.length - 2,\n                \"the count should be right using ArrayIterator(Object,1,\" + (testArray.length - 1) + \") \");\n        assertAll(\n                () -> assertThrows(ArrayIndexOutOfBoundsException.class, () -> makeArrayIterator(testArray, -1),\n                        \"new ArrayIterator(Object,-1) should throw an ArrayIndexOutOfBoundsException\"),\n                () -> assertThrows(ArrayIndexOutOfBoundsException.class, () -> makeArrayIterator(testArray, testArray.length + 1),\n                        \"new ArrayIterator(Object,length+1) should throw an ArrayIndexOutOfBoundsException\"),\n                () -> assertThrows(ArrayIndexOutOfBoundsException.class, () -> makeArrayIterator(testArray, 0, -1),\n                        \"new ArrayIterator(Object,0,-1) should throw an ArrayIndexOutOfBoundsException\"),\n                () -> assertThrows(ArrayIndexOutOfBoundsException.class, () -> makeArrayIterator(testArray, 0, testArray.length + 1),\n                        \"new ArrayIterator(Object,0,length+1) should throw an ArrayIndexOutOfBoundsException\"),\n                () -> assertThrows(IllegalArgumentException.class, () -> makeArrayIterator(testArray, testArray.length - 1, testArray.length - 2),\n                        \"new ArrayIterator(Object,length-2,length-1) should throw an IllegalArgumentException\")\n        );\n\n        try {\n            iter = makeArrayIterator(testArray, 1, 1);\n            // expected not to fail\n        } catch (final IllegalArgumentException iae) {\n            // MODIFIED: an iterator over a zero-length section of array\n            //  should be perfectly legal behavior\n            fail(\"new ArrayIterator(Object,1,1) should NOT throw an IllegalArgumentException\");\n        }\n    }\n\n    @Test\n    public void testIterator() {\n        final Iterator<E> iter = makeObject();\n        for (final int element : testArray) {\n            final Integer testValue = Integer.valueOf(element);\n            final Number iterValue = (Number) iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected int[] testArray = { 2, 4, 6, 8 };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int[]", "name": "testArray = { 2, 4, 6, 8 }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/FilterListIterator_previousTest.java.FilterListIterator_previousTest", "name": "FilterListIterator_previousTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/FilterListIterator_previousTest.java", "superclasses": "", "methods": ["[void]testPreviousWithTruePredicate()", "[void]testPreviousWithFalsePredicate()", "[void]testPreviousWithEvenPredicate()", "[void]testPreviousWithOddPredicate()", "[void]testPreviousWithThreePredicate()", "[void]testPreviousWithFourPredicate()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/FilterListIterator_previousTest.java.FilterListIterator_previousTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FilterListIterator_previousTest {\n\n    private ArrayList<Integer> list;\n    private Predicate<Integer> truePred;\n    private Predicate<Integer> falsePred;\n    private Predicate<Integer> evenPred;\n    private Predicate<Integer> oddPred;\n    private Predicate<Integer> threePred;\n    private Predicate<Integer> fourPred;\n\n    @BeforeEach\n    public void setUp() {\n        list = new ArrayList<>();\n        for (int i = 0; i < 20; i++) {\n            list.add(Integer.valueOf(i));\n        }\n\n        truePred = x -> true;\n        falsePred = x -> false;\n        evenPred = x -> x % 2 == 0;\n        oddPred = x -> x % 2 != 0;\n        threePred = x -> x % 3 == 0;\n        fourPred = x -> x % 4 == 0;\n    }\n\n    @Test\n    public void testPreviousWithTruePredicate() {\n        FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), truePred);\n        filtered.next(); // Move to the first element\n        assertEquals(Integer.valueOf(0), filtered.previous());\n    }\n\n    @Test\n    public void testPreviousWithFalsePredicate() {\n        FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), falsePred);\n        assertThrows(NoSuchElementException.class, () -> filtered.previous());\n    }\n\n    @Test\n    public void testPreviousWithEvenPredicate() {\n        FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), evenPred);\n        filtered.next(); // Move to the first even element\n        assertEquals(Integer.valueOf(0), filtered.previous());\n    }\n\n    @Test\n    public void testPreviousWithOddPredicate() {\n        FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), oddPred);\n        filtered.next(); // Move to the first odd element\n        assertEquals(Integer.valueOf(1), filtered.previous());\n    }\n\n    @Test\n    public void testPreviousWithThreePredicate() {\n        FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), threePred);\n        filtered.next(); // Move to the first multiple of 3\n        assertEquals(Integer.valueOf(0), filtered.previous());\n    }\n\n    @Test\n    public void testPreviousWithFourPredicate() {\n        FilterListIterator<Integer> filtered = new FilterListIterator<>(list.listIterator(), fourPred);\n        filtered.next(); // Move to the first multiple of 4\n        assertEquals(Integer.valueOf(0), filtered.previous());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ArrayList<Integer> list;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> truePred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "truePred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> falsePred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "falsePred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> evenPred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "evenPred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> oddPred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "oddPred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> threePred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "threePred", "syntax_pass": true}, {"attribute_expression": "private Predicate<Integer> fourPred;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<Integer>", "name": "fourPred", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java.UnmodifiableMapIteratorTest", "name": "UnmodifiableMapIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testMapIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java.UnmodifiableMapIteratorTest.[]UnmodifiableMapIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java.UnmodifiableMapIteratorTest.[Map<K, V>]getConfirmedMap()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java.UnmodifiableMapIteratorTest.[IterableMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java.UnmodifiableMapIteratorTest.[MapIterator<K, V>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java.UnmodifiableMapIteratorTest.[MapIterator<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java.UnmodifiableMapIteratorTest.[boolean]supportsRemove()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java.UnmodifiableMapIteratorTest.[boolean]supportsSetValue()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the UnmodifiableMapIterator.\n\n@param <K> the type of the keys in the maps tested.\n@param <V> the type of the values in the maps tested.\n", "original_string": "public class UnmodifiableMapIteratorTest<K, V> extends AbstractMapIteratorTest<K, V> {\n\n    public UnmodifiableMapIteratorTest() {\n        super(UnmodifiableMapIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Map<K, V> getConfirmedMap() {\n        final Map<K, V> testMap = new HashMap<>();\n        testMap.put((K) \"A\", (V) \"a\");\n        testMap.put((K) \"B\", (V) \"b\");\n        testMap.put((K) \"C\", (V) \"c\");\n        return testMap;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public IterableMap<K, V> getMap() {\n        final IterableMap<K, V> testMap = new DualHashBidiMap<>();\n        testMap.put((K) \"A\", (V) \"a\");\n        testMap.put((K) \"B\", (V) \"b\");\n        testMap.put((K) \"C\", (V) \"c\");\n        return testMap;\n    }\n\n    @Override\n    public MapIterator<K, V> makeEmptyIterator() {\n        return UnmodifiableMapIterator.unmodifiableMapIterator(new DualHashBidiMap<K, V>().mapIterator());\n    }\n\n    @Override\n    public MapIterator<K, V> makeObject() {\n        return UnmodifiableMapIterator.unmodifiableMapIterator(getMap().mapIterator());\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Override\n    public boolean supportsSetValue() {\n        return false;\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        MapIterator<K, V> it = makeObject();\n        assertSame(it, UnmodifiableMapIterator.unmodifiableMapIterator(it));\n\n        it = getMap().mapIterator();\n        assertNotSame(it, UnmodifiableMapIterator.unmodifiableMapIterator(it));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableMapIterator.unmodifiableMapIterator(null));\n    }\n\n    @Test\n    public void testMapIterator() {\n        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator_unmodifiableListIteratorTest.java.UnmodifiableListIterator_unmodifiableListIteratorTest", "name": "UnmodifiableListIterator_unmodifiableListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator_unmodifiableListIteratorTest.java", "superclasses": "", "methods": ["[void]testUnmodifiableListIteratorWithUnmodifiableIterator()", "[void]testUnmodifiableListIteratorWithModifiableIterator()", "[void]testUnmodifiableListIteratorWithNullIterator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class UnmodifiableListIterator_unmodifiableListIteratorTest {\n\n    @Test\n    void testUnmodifiableListIteratorWithUnmodifiableIterator() {\n        // Given\n        ListIterator<String> mockIterator = mock(ListIterator.class);\n        when(mockIterator.hasNext()).thenReturn(true);\n        when(mockIterator.next()).thenReturn(\"element\");\n        when(mockIterator.hasPrevious()).thenReturn(false);\n        when(mockIterator.previous()).thenThrow(new NoSuchElementException());\n\n        // When\n        ListIterator<String> result = UnmodifiableListIterator.unmodifiableListIterator(mockIterator);\n\n        // Then\n        assertTrue(result instanceof UnmodifiableListIterator);\n    }\n\n    @Test\n    void testUnmodifiableListIteratorWithModifiableIterator() {\n        // Given\n        ListIterator<String> mockIterator = mock(ListIterator.class);\n        when(mockIterator.hasNext()).thenReturn(true);\n        when(mockIterator.next()).thenReturn(\"element\");\n        when(mockIterator.hasPrevious()).thenReturn(false);\n        when(mockIterator.previous()).thenThrow(new NoSuchElementException());\n\n        // When\n        ListIterator<String> result = UnmodifiableListIterator.unmodifiableListIterator(mockIterator);\n\n        // Then\n        assertNotSame(mockIterator, result);\n        assertTrue(result instanceof UnmodifiableListIterator);\n    }\n\n    @Test\n    void testUnmodifiableListIteratorWithNullIterator() {\n        // Given\n        ListIterator<String> nullIterator = null;\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> {\n            UnmodifiableListIterator.unmodifiableListIterator(nullIterator);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/LoopingIteratorTest.java.LoopingIteratorTest", "name": "LoopingIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/LoopingIteratorTest.java", "superclasses": "", "methods": ["[void]testConstructorEx()", "[void]testLooping0()", "[void]testLooping1()", "[void]testLooping2()", "[void]testLooping3()", "[void]testRemoving1()", "[void]testReset()", "[void]testSize()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests the LoopingIterator class.\n", "original_string": "public class LoopingIteratorTest {\n\n    /**\n     * Tests constructor exception.\n     */\n    @Test\n    public void testConstructorEx() {\n        assertThrows(NullPointerException.class, () -> new LoopingIterator<>(null));\n    }\n\n    /**\n     * Tests whether an empty looping iterator works as designed.\n     */\n    @Test\n    public void testLooping0() {\n        final List<Object> list = new ArrayList<>();\n        final LoopingIterator<Object> loop = new LoopingIterator<>(list);\n        assertFalse(loop.hasNext(), \"hasNext should return false\");\n\n        assertThrows(NoSuchElementException.class, () -> loop.next(),\n                \"NoSuchElementException was not thrown during next() call.\");\n    }\n\n    /**\n     * Tests whether a populated looping iterator works as designed.\n     */\n    @Test\n    public void testLooping1() {\n        final List<String> list = Arrays.asList(\"a\");\n        final LoopingIterator<String> loop = new LoopingIterator<>(list);\n\n        assertTrue(loop.hasNext(), \"1st hasNext should return true\");\n        assertEquals(\"a\", loop.next());\n\n        assertTrue(loop.hasNext(), \"2nd hasNext should return true\");\n        assertEquals(\"a\", loop.next());\n\n        assertTrue(loop.hasNext(), \"3rd hasNext should return true\");\n        assertEquals(\"a\", loop.next());\n    }\n\n    /**\n     * Tests whether a populated looping iterator works as designed.\n     */\n    @Test\n    public void testLooping2() {\n        final List<String> list = Arrays.asList(\"a\", \"b\");\n        final LoopingIterator<String> loop = new LoopingIterator<>(list);\n\n        assertTrue(loop.hasNext(), \"1st hasNext should return true\");\n        assertEquals(\"a\", loop.next());\n\n        assertTrue(loop.hasNext(), \"2nd hasNext should return true\");\n        assertEquals(\"b\", loop.next());\n\n        assertTrue(loop.hasNext(), \"3rd hasNext should return true\");\n        assertEquals(\"a\", loop.next());\n    }\n\n    /**\n     * Tests whether a populated looping iterator works as designed.\n     */\n    @Test\n    public void testLooping3() {\n        final List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        final LoopingIterator<String> loop = new LoopingIterator<>(list);\n\n        assertTrue(loop.hasNext(), \"1st hasNext should return true\");\n        assertEquals(\"a\", loop.next());\n\n        assertTrue(loop.hasNext(), \"2nd hasNext should return true\");\n        assertEquals(\"b\", loop.next());\n\n        assertTrue(loop.hasNext(), \"3rd hasNext should return true\");\n        assertEquals(\"c\", loop.next());\n\n        assertTrue(loop.hasNext(), \"4th hasNext should return true\");\n        assertEquals(\"a\", loop.next());\n    }\n\n    /**\n     * Tests the remove() method on a LoopingIterator wrapped ArrayList.\n     */\n    @Test\n    public void testRemoving1() {\n        final List<String> list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\n        final LoopingIterator<String> loop = new LoopingIterator<>(list);\n        assertEquals(3, list.size(), \"list should have 3 elements.\");\n\n        assertTrue(loop.hasNext(), \"1st hasNext should return true\");\n        assertEquals(\"a\", loop.next());\n        loop.remove();  // removes a\n        assertEquals(2, list.size(), \"list should have 2 elements.\");\n\n        assertTrue(loop.hasNext(), \"2nd hasNext should return true\");\n        assertEquals(\"b\", loop.next());\n        loop.remove();  // removes b\n        assertEquals(1, list.size(), \"list should have 1 elements.\");\n\n        assertTrue(loop.hasNext(), \"3rd hasNext should return true\");\n        assertEquals(\"c\", loop.next());\n        loop.remove();  // removes c\n        assertEquals(0, list.size(), \"list should have 0 elements.\");\n\n        assertFalse(loop.hasNext(), \"4th hasNext should return false\");\n\n        assertThrows(NoSuchElementException.class, () -> loop.next(),\n                \"Expected NoSuchElementException to be thrown.\");\n    }\n\n    /**\n     * Tests the reset() method on a LoopingIterator wrapped ArrayList.\n     */\n    @Test\n    public void testReset() {\n        final List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        final LoopingIterator<String> loop = new LoopingIterator<>(list);\n\n        assertEquals(\"a\", loop.next());\n        assertEquals(\"b\", loop.next());\n        loop.reset();\n        assertEquals(\"a\", loop.next());\n        loop.reset();\n        assertEquals(\"a\", loop.next());\n        assertEquals(\"b\", loop.next());\n        assertEquals(\"c\", loop.next());\n        loop.reset();\n        assertEquals(\"a\", loop.next());\n        assertEquals(\"b\", loop.next());\n        assertEquals(\"c\", loop.next());\n    }\n\n    /**\n     * Tests the size() method on a LoopingIterator wrapped ArrayList.\n     */\n    @Test\n    public void testSize() {\n        final List<String> list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\n        final LoopingIterator<String> loop = new LoopingIterator<>(list);\n\n        assertEquals(3, loop.size());\n        loop.next();\n        loop.next();\n        assertEquals(3, loop.size());\n        loop.reset();\n        assertEquals(3, loop.size());\n        loop.next();\n        loop.remove();\n        assertEquals(2, loop.size());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_removeTest.java.CollatingIterator_removeTest", "name": "CollatingIterator_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveWithoutNext()", "[void]testRemoveAfterNext()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_removeTest.java.CollatingIterator_removeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CollatingIterator_removeTest {\n\n    private Comparator<Integer> comparator;\n    private ArrayList<Integer> evens;\n    private CollatingIterator<Integer> collatingIterator;\n\n    @BeforeEach\n    public void setUp() {\n        comparator = new ComparableComparator<>();\n        evens = new ArrayList<>();\n        for (int i = 0; i < 20; i++) {\n            if (i % 2 == 0) {\n                evens.add(i);\n            }\n        }\n        collatingIterator = new CollatingIterator<>(comparator);\n        collatingIterator.addIterator(evens.iterator());\n    }\n\n    @Test\n    public void testRemoveWithoutNext() {\n        assertThrows(IllegalStateException.class, () -> {\n            collatingIterator.remove();\n        });\n    }\n\n    @Test\n    public void testRemoveAfterNext() {\n        Iterator<Integer> iterator = evens.iterator();\n        collatingIterator.next(); // Ensure next() has been called\n        collatingIterator.remove();\n        assertEquals(9, evens.size()); // Corrected the expected size\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Comparator<Integer> comparator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Comparator<Integer>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> evens;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "evens", "syntax_pass": true}, {"attribute_expression": "private CollatingIterator<Integer> collatingIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CollatingIterator<Integer>", "name": "collatingIterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PermutationIterator_nextTest.java.PermutationIterator_nextTest", "name": "PermutationIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PermutationIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNextPermutation()", "[void]testNextPermutationThrowsNoSuchElementException()", "[void]testRemoveNotSupported()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/PermutationIterator_nextTest.java.PermutationIterator_nextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PermutationIterator_nextTest {\n\n    private PermutationIterator<Character> permutationIterator;\n\n    @BeforeEach\n    public void setUp() {\n        List<Character> collection = Arrays.asList('A', 'B', 'C');\n        permutationIterator = new PermutationIterator<>(collection);\n    }\n\n    @Test\n    public void testNextPermutation() {\n        assertTrue(permutationIterator.hasNext());\n\n        List<Character> firstPermutation = permutationIterator.next();\n        assertEquals(Arrays.asList('A', 'B', 'C'), firstPermutation);\n\n        assertTrue(permutationIterator.hasNext());\n\n        List<Character> secondPermutation = permutationIterator.next();\n        assertEquals(Arrays.asList('A', 'C', 'B'), secondPermutation);\n\n        assertTrue(permutationIterator.hasNext());\n\n        List<Character> thirdPermutation = permutationIterator.next();\n        assertEquals(Arrays.asList('C', 'A', 'B'), thirdPermutation);\n\n        assertTrue(permutationIterator.hasNext());\n\n        List<Character> fourthPermutation = permutationIterator.next();\n        assertEquals(Arrays.asList('C', 'B', 'A'), fourthPermutation);\n\n        assertTrue(permutationIterator.hasNext());\n\n        List<Character> fifthPermutation = permutationIterator.next();\n        assertEquals(Arrays.asList('B', 'C', 'A'), fifthPermutation);\n\n        assertTrue(permutationIterator.hasNext());\n\n        List<Character> sixthPermutation = permutationIterator.next();\n        assertEquals(Arrays.asList('B', 'A', 'C'), sixthPermutation);\n\n        assertFalse(permutationIterator.hasNext());\n    }\n\n    @Test\n    public void testNextPermutationThrowsNoSuchElementException() {\n        List<Character> collection = new ArrayList<>();\n        PermutationIterator<Character> emptyIterator = new PermutationIterator<>(collection);\n\n        assertTrue(emptyIterator.hasNext());\n        assertEquals(0, emptyIterator.next().size());\n\n        assertThrows(NoSuchElementException.class, () -> {\n            emptyIterator.next();\n        });\n    }\n\n    @Test\n    public void testRemoveNotSupported() {\n        assertThrows(UnsupportedOperationException.class, () -> {\n            permutationIterator.remove();\n        });\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private PermutationIterator<Character> permutationIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PermutationIterator<Character>", "name": "permutationIterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java.UnmodifiableIteratorTest", "name": "UnmodifiableIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java.UnmodifiableIteratorTest.[]UnmodifiableIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java.UnmodifiableIteratorTest.[Iterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java.UnmodifiableIteratorTest.[Iterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java.UnmodifiableIteratorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java.UnmodifiableIteratorTest.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the UnmodifiableIterator.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class UnmodifiableIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n    protected List<E> testList;\n\n    public UnmodifiableIteratorTest() {\n        super(UnmodifiableIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public Iterator<E> makeEmptyIterator() {\n        return UnmodifiableIterator.unmodifiableIterator(Collections.<E>emptyList().iterator());\n    }\n\n    @Override\n    public Iterator<E> makeObject() {\n        return UnmodifiableIterator.unmodifiableIterator(testList.iterator());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    protected void setUp() throws Exception {\n        testList = new ArrayList<>(Arrays.asList((E[]) testArray));\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        Iterator<E> it = makeObject();\n        assertSame(it, UnmodifiableIterator.unmodifiableIterator(it));\n\n        it = testList.iterator();\n        assertNotSame(it, UnmodifiableIterator.unmodifiableIterator(it));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableIterator.unmodifiableIterator(null));\n    }\n\n    @Test\n    public void testIterator() {\n        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = { \"One\", \"Two\", \"Three\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = { \"One\", \"Two\", \"Three\" }", "syntax_pass": true}, {"attribute_expression": "protected List<E> testList;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<E>", "name": "testList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/LoopingListIterator_nextTest.java.LoopingListIterator_nextTest", "name": "LoopingListIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/LoopingListIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNextWithElements()", "[void]testNextWithEmptyList()", "[void]testNextWithReset()", "[void]testNextWithHasNext()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/LoopingListIterator_nextTest.java.LoopingListIterator_nextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LoopingListIterator_nextTest {\n\n    private LoopingListIterator<String> loopingListIterator;\n    private List<String> list;\n\n    @BeforeEach\n    public void setUp() {\n        list = Arrays.asList(\"a\", \"b\", \"c\");\n        loopingListIterator = new LoopingListIterator<>(list);\n    }\n\n    @Test\n    public void testNextWithElements() {\n        assertEquals(\"a\", loopingListIterator.next());\n        assertEquals(\"b\", loopingListIterator.next());\n        assertEquals(\"c\", loopingListIterator.next());\n        assertEquals(\"a\", loopingListIterator.next()); // Looping back to the start\n    }\n\n    @Test\n    public void testNextWithEmptyList() {\n        list = Arrays.asList();\n        loopingListIterator = new LoopingListIterator<>(list);\n        assertThrows(NoSuchElementException.class, () -> {\n            loopingListIterator.next();\n        });\n    }\n\n    @Test\n    public void testNextWithReset() {\n        assertEquals(\"a\", loopingListIterator.next());\n        assertEquals(\"b\", loopingListIterator.next());\n        loopingListIterator.reset();\n        assertEquals(\"a\", loopingListIterator.next());\n    }\n\n    @Test\n    public void testNextWithHasNext() {\n        assertTrue(loopingListIterator.hasNext());\n        assertEquals(\"a\", loopingListIterator.next());\n        assertTrue(loopingListIterator.hasNext());\n        assertEquals(\"b\", loopingListIterator.next());\n        assertTrue(loopingListIterator.hasNext());\n        assertEquals(\"c\", loopingListIterator.next());\n        assertTrue(loopingListIterator.hasNext());\n        assertEquals(\"a\", loopingListIterator.next());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private LoopingListIterator<String> loopingListIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "LoopingListIterator<String>", "name": "loopingListIterator", "syntax_pass": true}, {"attribute_expression": "private List<String> list;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "list", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ZippingIteratorTest.java.ZippingIteratorTest", "name": "ZippingIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ZippingIteratorTest.java", "superclasses": "", "methods": ["[void]testIterateEven()", "[void]testIterateEvenEven()", "[void]testIterateEvenOdd()", "[void]testIterateFibEvenOdd()", "[void]testIterateOddEven()", "[void]testRemoveFromDouble()", "[void]testRemoveFromSingle()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ZippingIteratorTest.java.ZippingIteratorTest.[]ZippingIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/ZippingIteratorTest.java.ZippingIteratorTest.[ZippingIterator<Integer>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ZippingIteratorTest.java.ZippingIteratorTest.[ZippingIterator<Integer>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/ZippingIteratorTest.java.ZippingIteratorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nUnit test suite for {@link ZippingIterator}.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class ZippingIteratorTest extends AbstractIteratorTest<Integer> {\n\n    //------------------------------------------------------------ Conventional\n\n    private ArrayList<Integer> evens;\n\n    //--------------------------------------------------------------- Lifecycle\n\n    private ArrayList<Integer> odds;\n    private ArrayList<Integer> fib;\n    public ZippingIteratorTest() {\n        super(ZippingIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ZippingIterator<Integer> makeEmptyIterator() {\n        return new ZippingIterator<>(IteratorUtils.<Integer>emptyIterator());\n    }\n\n    //---------------------------------------------------- TestIterator Methods\n\n    @Override\n    public ZippingIterator<Integer> makeObject() {\n        return new ZippingIterator<>(evens.iterator(), odds.iterator(), fib.iterator());\n    }\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        evens = new ArrayList<>();\n        odds = new ArrayList<>();\n        for (int i = 0; i < 20; i++) {\n            if (0 == i % 2) {\n                evens.add(i);\n            } else {\n                odds.add(i);\n            }\n        }\n        fib = new ArrayList<>();\n        fib.add(1);\n        fib.add(1);\n        fib.add(2);\n        fib.add(3);\n        fib.add(5);\n        fib.add(8);\n        fib.add(13);\n        fib.add(21);\n    }\n\n    //------------------------------------------------------------------- Tests\n\n    @Test\n    public void testIterateEven() {\n        @SuppressWarnings(\"unchecked\")\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator());\n        for (final Integer even : evens) {\n            assertTrue(iter.hasNext());\n            assertEquals(even, iter.next());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testIterateEvenEven() {\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), evens.iterator());\n        for (final Integer even : evens) {\n            assertTrue(iter.hasNext());\n            assertEquals(even, iter.next());\n            assertTrue(iter.hasNext());\n            assertEquals(even, iter.next());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testIterateEvenOdd() {\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), odds.iterator());\n        for (int i = 0; i < 20; i++) {\n            assertTrue(iter.hasNext());\n            assertEquals(Integer.valueOf(i), iter.next());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testIterateFibEvenOdd() {\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(fib.iterator(), evens.iterator(), odds.iterator());\n\n        assertEquals(Integer.valueOf(1), iter.next());  // fib    1\n        assertEquals(Integer.valueOf(0), iter.next());  // even   0\n        assertEquals(Integer.valueOf(1), iter.next());  // odd    1\n        assertEquals(Integer.valueOf(1), iter.next());  // fib    1\n        assertEquals(Integer.valueOf(2), iter.next());  // even   2\n        assertEquals(Integer.valueOf(3), iter.next());  // odd    3\n        assertEquals(Integer.valueOf(2), iter.next());  // fib    2\n        assertEquals(Integer.valueOf(4), iter.next());  // even   4\n        assertEquals(Integer.valueOf(5), iter.next());  // odd    5\n        assertEquals(Integer.valueOf(3), iter.next());  // fib    3\n        assertEquals(Integer.valueOf(6), iter.next());  // even   6\n        assertEquals(Integer.valueOf(7), iter.next());  // odd    7\n        assertEquals(Integer.valueOf(5), iter.next());  // fib    5\n        assertEquals(Integer.valueOf(8), iter.next());  // even   8\n        assertEquals(Integer.valueOf(9), iter.next());  // odd    9\n        assertEquals(Integer.valueOf(8), iter.next());  // fib    8\n        assertEquals(Integer.valueOf(10), iter.next()); // even  10\n        assertEquals(Integer.valueOf(11), iter.next()); // odd   11\n        assertEquals(Integer.valueOf(13), iter.next()); // fib   13\n        assertEquals(Integer.valueOf(12), iter.next()); // even  12\n        assertEquals(Integer.valueOf(13), iter.next()); // odd   13\n        assertEquals(Integer.valueOf(21), iter.next()); // fib   21\n        assertEquals(Integer.valueOf(14), iter.next()); // even  14\n        assertEquals(Integer.valueOf(15), iter.next()); // odd   15\n        assertEquals(Integer.valueOf(16), iter.next()); // even  16\n        assertEquals(Integer.valueOf(17), iter.next()); // odd   17\n        assertEquals(Integer.valueOf(18), iter.next()); // even  18\n        assertEquals(Integer.valueOf(19), iter.next()); // odd   19\n\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testIterateOddEven() {\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(odds.iterator(), evens.iterator());\n        for (int i = 0, j = 0; i < 20; i++) {\n            assertTrue(iter.hasNext());\n            final int val = iter.next();\n            if (i % 2 == 0) {\n                assertEquals(odds.get(j).intValue(), val);\n            } else {\n                assertEquals(evens.get(j).intValue(), val);\n                j++;\n            }\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testRemoveFromDouble() {\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), odds.iterator());\n        int expectedSize = evens.size() + odds.size();\n        while (iter.hasNext()) {\n            final Object o = iter.next();\n            final Integer val = (Integer) o;\n            if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {\n                expectedSize--;\n                iter.remove();\n            }\n        }\n        assertEquals(expectedSize, evens.size() + odds.size());\n    }\n\n    @Test\n    public void testRemoveFromSingle() {\n        @SuppressWarnings(\"unchecked\")\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator());\n        int expectedSize = evens.size();\n        while (iter.hasNext()) {\n            final Object o = iter.next();\n            final Integer val = (Integer) o;\n            if (val.intValue() % 4 == 0) {\n                expectedSize--;\n                iter.remove();\n            }\n        }\n        assertEquals(expectedSize, evens.size());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ArrayList<Integer> evens;", "docstring": "------------------------------------------------------------ Conventional", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "evens", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> odds;", "docstring": "--------------------------------------------------------------- Lifecycle", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "odds", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> fib;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "fib", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_setIteratorTest.java.CollatingIterator_setIteratorTest", "name": "CollatingIterator_setIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_setIteratorTest.java", "superclasses": "", "methods": ["[void]testSetIterator_Success()", "[void]testSetIterator_NullIterator()", "[void]testSetIterator_IterationStarted()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CollatingIterator_setIteratorTest {\n\n    @Test\n    void testSetIterator_Success() {\n        // Given\n        CollatingIterator<Integer> collatingIterator = new CollatingIterator<>();\n        Iterator<Integer> mockIterator = mock(Iterator.class);\n\n        // When\n        collatingIterator.addIterator(mockIterator); // Ensure the list has at least one iterator\n        collatingIterator.setIterator(0, mockIterator);\n\n        // Then\n        assertEquals(mockIterator, collatingIterator.getIterators().get(0));\n    }\n\n    @Test\n    void testSetIterator_NullIterator() {\n        // Given\n        CollatingIterator<Integer> collatingIterator = new CollatingIterator<>();\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> {\n            collatingIterator.setIterator(0, null);\n        });\n    }\n\n    @Test\n    void testSetIterator_IterationStarted() {\n        // Given\n        CollatingIterator<Integer> collatingIterator = new CollatingIterator<>();\n        Iterator<Integer> mockIterator = mock(Iterator.class);\n        when(mockIterator.hasNext()).thenReturn(true);\n        collatingIterator.addIterator(mockIterator);\n\n        // When\n        collatingIterator.next(); // Start iteration\n\n        // Then\n        assertThrows(IllegalStateException.class, () -> {\n            collatingIterator.setIterator(0, mockIterator);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator_unmodifiableMapIteratorTest.java.UnmodifiableMapIterator_unmodifiableMapIteratorTest", "name": "UnmodifiableMapIterator_unmodifiableMapIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator_unmodifiableMapIteratorTest.java", "superclasses": "", "methods": ["[void]testUnmodifiableMapIteratorWithUnmodifiableIterator()", "[void]testUnmodifiableMapIteratorWithModifiableIterator()", "[void]testUnmodifiableMapIteratorWithNullIterator()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    private static class MockUnmodifiableMapIterator<K, V> implements MapIterator<K, V>, Unmodifiable {\n        @Override\n        public K getKey() {\n            return null;\n        }\n\n        @Override\n        public V getValue() {\n            return null;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return false;\n        }\n\n        @Override\n        public K next() {\n            return null;\n        }\n\n        @Override\n        public void remove() {\n        }\n\n        @Override\n        public V setValue(V value) {\n            return null;\n        }\n    }", "definition": "    private static class MockUnmodifiableMapIterator<K, V> implements MapIterator<K, V>, Unmodifiable", "class_docstring": " Mock implementation of UnmodifiableMapIterator for testing", "name": "MockUnmodifiableMapIterator", "super_interfaces": ["MapIterator<K, V>", "Unmodifiable"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            return null;\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            return null;\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return false;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return null;\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(V value) {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                   {\n            return null;\n        }", "signature": "@Override\n        public V setValue(V value)"}]}, {"original_string": "    private static class HashMapIterator<K, V> implements MapIterator<K, V> {\n        private final Map<K, V> map;\n        private java.util.Iterator<Map.Entry<K, V>> iterator;\n        private Map.Entry<K, V> currentEntry;\n\n        public HashMapIterator(Map<K, V> map) {\n            this.map = map;\n            this.iterator = map.entrySet().iterator();\n        }\n\n        @Override\n        public K getKey() {\n            return currentEntry.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            return currentEntry.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public K next() {\n            currentEntry = iterator.next();\n            return currentEntry.getKey();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n        }\n\n        @Override\n        public V setValue(V value) {\n            return currentEntry.setValue(value);\n        }\n    }", "definition": "    private static class HashMapIterator<K, V> implements MapIterator<K, V>", "class_docstring": " Mock implementation of MapIterator for testing", "name": "HashMapIterator", "super_interfaces": ["MapIterator<K, V>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Map<K, V> map;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<K, V>", "name": "map", "syntax_pass": true}, {"attribute_expression": "private java.util.Iterator<Map.Entry<K, V>> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "java.util.Iterator<Map.Entry<K, V>>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private Map.Entry<K, V> currentEntry;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map.Entry<K, V>", "name": "currentEntry", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public HashMapIterator(Map<K, V> map) {\n            this.map = map;\n            this.iterator = map.entrySet().iterator();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "HashMapIterator", "params": [{"name": "map", "type": "Map<K, V>"}], "body": "                                              {\n            this.map = map;\n            this.iterator = map.entrySet().iterator();\n        }", "signature": "public HashMapIterator(Map<K, V> map)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            return currentEntry.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            return currentEntry.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            return currentEntry.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            return currentEntry.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return iterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            currentEntry = iterator.next();\n            return currentEntry.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            currentEntry = iterator.next();\n            return currentEntry.getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            iterator.remove();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            iterator.remove();\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(V value) {\n            return currentEntry.setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                   {\n            return currentEntry.setValue(value);\n        }", "signature": "@Override\n        public V setValue(V value)"}]}], "class_docstring": "", "original_string": "class UnmodifiableMapIterator_unmodifiableMapIteratorTest {\n\n    @Test\n    void testUnmodifiableMapIteratorWithUnmodifiableIterator() {\n        // Given\n        MapIterator<String, String> mockIterator = new MockUnmodifiableMapIterator<>();\n\n        // When\n        MapIterator<String, String> result = UnmodifiableMapIterator.unmodifiableMapIterator(mockIterator);\n\n        // Then\n        assertSame(mockIterator, result);\n    }\n\n    @Test\n    void testUnmodifiableMapIteratorWithModifiableIterator() {\n        // Given\n        Map<String, String> map = new HashMap<>();\n        map.put(\"key1\", \"value1\");\n        MapIterator<String, String> modifiableIterator = new HashMapIterator<>(map);\n\n        // When\n        MapIterator<String, String> result = UnmodifiableMapIterator.unmodifiableMapIterator(modifiableIterator);\n\n        // Then\n        assertTrue(result instanceof UnmodifiableMapIterator);\n    }\n\n    @Test\n    void testUnmodifiableMapIteratorWithNullIterator() {\n        // Given\n        MapIterator<String, String> nullIterator = null;\n\n        // When / Then\n        assertThrows(NullPointerException.class, () -> {\n            UnmodifiableMapIterator.unmodifiableMapIterator(nullIterator);\n        });\n    }\n\n    // Mock implementation of UnmodifiableMapIterator for testing\n    private static class MockUnmodifiableMapIterator<K, V> implements MapIterator<K, V>, Unmodifiable {\n        @Override\n        public K getKey() {\n            return null;\n        }\n\n        @Override\n        public V getValue() {\n            return null;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return false;\n        }\n\n        @Override\n        public K next() {\n            return null;\n        }\n\n        @Override\n        public void remove() {\n        }\n\n        @Override\n        public V setValue(V value) {\n            return null;\n        }\n    }\n\n    // Mock implementation of MapIterator for testing\n    private static class HashMapIterator<K, V> implements MapIterator<K, V> {\n        private final Map<K, V> map;\n        private java.util.Iterator<Map.Entry<K, V>> iterator;\n        private Map.Entry<K, V> currentEntry;\n\n        public HashMapIterator(Map<K, V> map) {\n            this.map = map;\n            this.iterator = map.entrySet().iterator();\n        }\n\n        @Override\n        public K getKey() {\n            return currentEntry.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            return currentEntry.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public K next() {\n            currentEntry = iterator.next();\n            return currentEntry.getKey();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n        }\n\n        @Override\n        public V setValue(V value) {\n            return currentEntry.setValue(value);\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/CartesianProductIteratorTest.java.CartesianProductIteratorTest", "name": "CartesianProductIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/CartesianProductIteratorTest.java", "superclasses": "", "methods": ["[void]testRemoveThrows()", "[void]testEmptyCollection()", "[void]testExhaustivity()", "[void]testExhaustivityWithEmptyList()", "[void]testExhaustivityWithEmptyFirstList()", "[void]testExhaustivityWithEmptyLastList()", "[void]testExhaustivityWithAllEmptyLists()", "[void]testExhaustivityWithSameList()", "[void]testForEachRemaining()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/CartesianProductIteratorTest.java.CartesianProductIteratorTest.[]CartesianProductIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/CartesianProductIteratorTest.java.CartesianProductIteratorTest.[CartesianProductIterator<Character>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/CartesianProductIteratorTest.java.CartesianProductIteratorTest.[CartesianProductIterator<Character>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/CartesianProductIteratorTest.java.CartesianProductIteratorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/CartesianProductIteratorTest.java.CartesianProductIteratorTest.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTest class for {@link CartesianProductIterator}.\n", "original_string": "public class CartesianProductIteratorTest extends AbstractIteratorTest<List<Character>> {\n\n    private List<Character> letters;\n    private List<Character> numbers;\n    private List<Character> symbols;\n    private List<Character> emptyList;\n\n    public CartesianProductIteratorTest() {\n        super(CartesianProductIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public CartesianProductIterator<Character> makeEmptyIterator() {\n        return new CartesianProductIterator<>();\n    }\n\n    @Override\n    public CartesianProductIterator<Character> makeObject() {\n        return new CartesianProductIterator<>(letters, numbers, symbols);\n    }\n\n    @BeforeEach\n    public void setUp() {\n        letters = Arrays.asList('A', 'B', 'C');\n        numbers = Arrays.asList('1', '2', '3');\n        symbols = Arrays.asList('!', '?');\n        emptyList = Collections.emptyList();\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Test\n    public void testRemoveThrows() {\n        final CartesianProductIterator<Character> it = makeObject();\n        assertThrows(UnsupportedOperationException.class, it::remove);\n    }\n\n    @Test\n    public void testEmptyCollection() {\n        final CartesianProductIterator<Character> it = new CartesianProductIterator<>(letters, Collections.emptyList());\n        assertFalse(it.hasNext());\n        assertThrows(NoSuchElementException.class, it::next);\n    }\n\n    /**\n     * test checking that all the tuples are returned\n     */\n    @Test\n    public void testExhaustivity() {\n        final List<Character[]> resultsList = new ArrayList<>();\n        final CartesianProductIterator<Character> it = makeObject();\n        while (it.hasNext()) {\n            final List<Character> tuple = it.next();\n            resultsList.add(tuple.toArray(new Character[0]));\n        }\n        assertThrows(NoSuchElementException.class, it::next);\n        assertEquals(18, resultsList.size());\n        final Iterator<Character[]> itResults = resultsList.iterator();\n        for (final Character a : letters) {\n            for (final Character b : numbers) {\n                for (final Character c : symbols) {\n                    assertArrayEquals(new Character[]{a, b, c}, itResults.next());\n                }\n            }\n        }\n    }\n\n    /**\n     * test checking that no tuples are returned when at least one of the lists is empty\n     */\n    @Test\n    public void testExhaustivityWithEmptyList() {\n        final List<Character[]> resultsList = new ArrayList<>();\n        final CartesianProductIterator<Character> it = new CartesianProductIterator<>(letters, emptyList, symbols);\n        while (it.hasNext()) {\n            final List<Character> tuple = it.next();\n            resultsList.add(tuple.toArray(new Character[0]));\n        }\n        assertThrows(NoSuchElementException.class, it::next);\n        assertEquals(0, resultsList.size());\n    }\n\n    /**\n     * test checking that no tuples are returned when first of the lists is empty\n     */\n    @Test\n    public void testExhaustivityWithEmptyFirstList() {\n        final List<Character[]> resultsList = new ArrayList<>();\n        final CartesianProductIterator<Character> it = new CartesianProductIterator<>(emptyList, numbers, symbols);\n        while (it.hasNext()) {\n            final List<Character> tuple = it.next();\n            resultsList.add(tuple.toArray(new Character[0]));\n        }\n        assertThrows(NoSuchElementException.class, it::next);\n        assertEquals(0, resultsList.size());\n    }\n\n    /**\n     * test checking that no tuples are returned when last of the lists is empty\n     */\n    @Test\n    public void testExhaustivityWithEmptyLastList() {\n        final List<Character[]> resultsList = new ArrayList<>();\n        final CartesianProductIterator<Character> it = new CartesianProductIterator<>(letters, numbers, emptyList);\n        while (it.hasNext()) {\n            final List<Character> tuple = it.next();\n            resultsList.add(tuple.toArray(new Character[0]));\n        }\n        assertThrows(NoSuchElementException.class, it::next);\n        assertEquals(0, resultsList.size());\n    }\n\n    /**\n     * test checking that no tuples are returned when all the lists are empty\n     */\n    @Test\n    public void testExhaustivityWithAllEmptyLists() {\n        final List<Character[]> resultsList = new ArrayList<>();\n        final CartesianProductIterator<Character> it = new CartesianProductIterator<>(emptyList, emptyList, emptyList);\n        while (it.hasNext()) {\n            final List<Character> tuple = it.next();\n            resultsList.add(tuple.toArray(new Character[0]));\n        }\n        assertThrows(NoSuchElementException.class, it::next);\n        assertEquals(0, resultsList.size());\n    }\n\n    /**\n     * test checking that all tuples are returned when same list is passed multiple times\n     */\n    @Test\n    public void testExhaustivityWithSameList() {\n        final List<Character[]> resultsList = new ArrayList<>();\n        final CartesianProductIterator<Character> it = new CartesianProductIterator<>(letters, letters, letters);\n        while (it.hasNext()) {\n            final List<Character> tuple = it.next();\n            resultsList.add(tuple.toArray(new Character[0]));\n        }\n        assertThrows(NoSuchElementException.class, it::next);\n        assertEquals(27, resultsList.size());\n        final Iterator<Character[]> itResults = resultsList.iterator();\n        for (final Character a : letters) {\n            for (final Character b : letters) {\n                for (final Character c : letters) {\n                    assertArrayEquals(new Character[]{a, b, c}, itResults.next());\n                }\n            }\n        }\n    }\n\n    /**\n     * test that all tuples are provided to consumer\n     */\n    @Test\n    public void testForEachRemaining() {\n        final List<Character[]> resultsList = new ArrayList<>();\n        final CartesianProductIterator<Character> it = makeObject();\n        it.forEachRemaining(tuple -> resultsList.add(tuple.toArray(new Character[0])));\n        assertEquals(18, resultsList.size());\n        final Iterator<Character[]> itResults = resultsList.iterator();\n        for (final Character a : letters) {\n            for (final Character b : numbers) {\n                for (final Character c : symbols) {\n                    assertArrayEquals(new Character[]{a, b, c}, itResults.next());\n                }\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<Character> letters;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Character>", "name": "letters", "syntax_pass": true}, {"attribute_expression": "private List<Character> numbers;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Character>", "name": "numbers", "syntax_pass": true}, {"attribute_expression": "private List<Character> symbols;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Character>", "name": "symbols", "syntax_pass": true}, {"attribute_expression": "private List<Character> emptyList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Character>", "name": "emptyList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_addIteratorTest.java.CollatingIterator_addIteratorTest", "name": "CollatingIterator_addIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_addIteratorTest.java", "superclasses": "", "methods": ["[void]testAddIterator_Success()", "[void]testAddIterator_NullIterator()", "[void]testAddIterator_AfterStart()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_addIteratorTest.java.CollatingIterator_addIteratorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CollatingIterator_addIteratorTest {\n\n    private CollatingIterator<Integer> collatingIterator;\n\n    @BeforeEach\n    void setUp() {\n        collatingIterator = new CollatingIterator<>(Comparator.naturalOrder());\n    }\n\n    @Test\n    void testAddIterator_Success() {\n        Iterator<Integer> iterator = Arrays.asList(1, 2, 3).iterator();\n        collatingIterator.addIterator(iterator);\n        assertEquals(1, collatingIterator.getIterators().size());\n    }\n\n    @Test\n    void testAddIterator_NullIterator() {\n        assertThrows(NullPointerException.class, () -> collatingIterator.addIterator(null));\n    }\n\n    @Test\n    void testAddIterator_AfterStart() {\n        collatingIterator.hasNext(); // This will call start() internally\n        Iterator<Integer> iterator = Arrays.asList(1, 2, 3).iterator();\n        assertThrows(IllegalStateException.class, () -> collatingIterator.addIterator(iterator));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CollatingIterator<Integer> collatingIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CollatingIterator<Integer>", "name": "collatingIterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_nextTest.java.PeekingIterator_nextTest", "name": "PeekingIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNextWithPeek()", "[void]testNextWithoutPeek()", "[void]testNextThrowsNoSuchElementException()", "[void]testNextAfterElement()", "[void]testNextAfterPeek()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_nextTest.java.PeekingIterator_nextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PeekingIterator_nextTest {\n\n    private List<String> testList;\n    private static final String[] testArray = {\"a\", \"b\", \"c\"};\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    protected void setUp() throws Exception {\n        testList = new ArrayList<>(Arrays.asList((String[]) testArray));\n    }\n\n    @Test\n    public void testNextWithPeek() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertEquals(\"a\", it.peek());\n        assertEquals(\"a\", it.next());\n        assertEquals(\"b\", it.peek());\n        assertEquals(\"b\", it.next());\n        assertEquals(\"c\", it.peek());\n        assertEquals(\"c\", it.next());\n    }\n\n    @Test\n    public void testNextWithoutPeek() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertEquals(\"a\", it.next());\n        assertEquals(\"b\", it.next());\n        assertEquals(\"c\", it.next());\n    }\n\n    @Test\n    public void testNextThrowsNoSuchElementException() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        while (it.hasNext()) {\n            it.next();\n        }\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    public void testNextAfterElement() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertEquals(\"a\", it.element());\n        assertEquals(\"a\", it.next());\n        assertEquals(\"b\", it.element());\n        assertEquals(\"b\", it.next());\n        assertEquals(\"c\", it.element());\n        assertEquals(\"c\", it.next());\n    }\n\n    @Test\n    public void testNextAfterPeek() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertEquals(\"a\", it.peek());\n        assertEquals(\"a\", it.next());\n        assertEquals(\"b\", it.peek());\n        assertEquals(\"b\", it.next());\n        assertEquals(\"c\", it.peek());\n        assertEquals(\"c\", it.next());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<String> testList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "testList", "syntax_pass": true}, {"attribute_expression": "private static final String[] testArray = {\"a\", \"b\", \"c\"};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "testArray = {\"a\", \"b\", \"c\"}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java.ListIteratorWrapper2Test", "name": "ListIteratorWrapper2Test", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java", "superclasses": "", "methods": ["[void]testIterator()", "[void]testRemove()", "[void]testReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java.ListIteratorWrapper2Test.[]ListIteratorWrapper2Test()", "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java.ListIteratorWrapper2Test.[ResettableListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java.ListIteratorWrapper2Test.[ResettableListIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java.ListIteratorWrapper2Test.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the ListIteratorWrapper to ensure that it behaves as expected when wrapping a ListIterator.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ListIteratorWrapper2Test<E> extends AbstractIteratorTest<E> {\n\n    protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };\n\n    protected List<E> list1;\n\n    public ListIteratorWrapper2Test() {\n        super(ListIteratorWrapper2Test.class.getSimpleName());\n    }\n\n    @Override\n    public ResettableListIterator<E> makeEmptyIterator() {\n        final ArrayList<E> list = new ArrayList<>();\n        return new ListIteratorWrapper<>(list.listIterator());\n    }\n\n    @Override\n    public ResettableListIterator<E> makeObject() {\n        return new ListIteratorWrapper<>(list1.listIterator());\n    }\n\n    @BeforeEach\n    @SuppressWarnings(\"unchecked\")\n    public void setUp() {\n        list1 = new ArrayList<>();\n        list1.add((E) \"One\");\n        list1.add((E) \"Two\");\n        list1.add((E) \"Three\");\n        list1.add((E) \"Four\");\n        list1.add((E) \"Five\");\n        list1.add((E) \"Six\");\n    }\n\n    @Test\n    public void testIterator() {\n        final ListIterator<E> iter = makeObject();\n        for (final String testValue : testArray) {\n            final Object iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n\n        // now, read it backwards\n        for (int i = testArray.length - 1; i > -1; --i) {\n            final Object testValue = testArray[i];\n            final E iterValue = iter.previous();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        try {\n            iter.previous();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n\n        // now, read it forwards again\n        for (final String testValue : testArray) {\n            final Object iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n    }\n\n    @Test\n    @Override\n    public void testRemove() {\n        final ListIterator<E> iter = makeObject();\n\n        //initial state:\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        assertThrows(IllegalStateException.class, () -> iter.remove(), \"ListIteratorWrapper#remove() should fail; must be initially positioned first\");\n\n        //no change from invalid op:\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        //establish size:\n        int sz = list1.size();\n\n        //verify initial next() call:\n        assertEquals(list1.get(0), iter.next());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n\n        //verify remove():\n        iter.remove();\n        assertEquals(--sz, list1.size());\n        //like we never started iterating:\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        assertThrows(IllegalStateException.class, () -> iter.remove(), \"ListIteratorWrapper#remove() should fail; must be repositioned first\");\n\n        //no change from invalid op:\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        //two consecutive next() calls:\n        assertEquals(list1.get(0), iter.next());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n\n        assertEquals(list1.get(1), iter.next());\n        assertEquals(1, iter.previousIndex());\n        assertEquals(2, iter.nextIndex());\n\n        //call previous():\n        assertEquals(list1.get(1), iter.previous());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n\n        //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:\n        iter.remove();\n        assertEquals(--sz, list1.size());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n\n        //this would dig into cache on a plain Iterator, but forwards directly to wrapped ListIterator:\n        assertEquals(list1.get(0), iter.previous());\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        //here's the proof; remove() still works:\n        iter.remove();\n        assertEquals(--sz, list1.size());\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        //further testing would be fairly meaningless:\n    }\n\n    @Test\n    public void testReset() {\n        final ResettableListIterator<E> iter = makeObject();\n        final E first = iter.next();\n        final E second = iter.next();\n\n        iter.reset();\n\n        // after reset, there shouldn't be any previous elements\n        assertFalse(iter.hasPrevious(), \"No previous elements after reset()\");\n\n        // after reset, the results should be the same as before\n        assertEquals(first, iter.next(), \"First element should be the same\");\n        assertEquals(second, iter.next(), \"Second element should be the same\");\n\n        // after passing the point, where we reset, continuation should work as expected\n        for (int i = 2; i < testArray.length; i++) {\n            final Object testValue = testArray[i];\n            final E iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    }", "syntax_pass": true}, {"attribute_expression": "protected List<E> list1;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<E>", "name": "list1", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/BoundedIterator_hasNextTest.java.BoundedIterator_hasNextTest", "name": "BoundedIterator_hasNextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/BoundedIterator_hasNextTest.java", "superclasses": "", "methods": ["[void]testHasNextWithinBounds()", "[void]testHasNextOutOfBounds()", "[void]testHasNextWithNoElements()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class BoundedIterator_hasNextTest {\n\n    @Test\n    void testHasNextWithinBounds() {\n        Iterator<String> mockIterator = mock(Iterator.class);\n        when(mockIterator.hasNext()).thenReturn(true);\n\n        BoundedIterator<String> boundedIterator = new BoundedIterator<>(mockIterator, 0, 1);\n        assertTrue(boundedIterator.hasNext());\n    }\n\n    @Test\n    void testHasNextOutOfBounds() {\n        Iterator<String> mockIterator = mock(Iterator.class);\n        when(mockIterator.hasNext()).thenReturn(true);\n\n        BoundedIterator<String> boundedIterator = new BoundedIterator<>(mockIterator, 0, 0);\n        assertFalse(boundedIterator.hasNext());\n    }\n\n    @Test\n    void testHasNextWithNoElements() {\n        Iterator<String> mockIterator = mock(Iterator.class);\n        when(mockIterator.hasNext()).thenReturn(false);\n\n        BoundedIterator<String> boundedIterator = new BoundedIterator<>(mockIterator, 0, 1);\n        assertFalse(boundedIterator.hasNext());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/IteratorIterable_iteratorTest.java.IteratorIterable_iteratorTest", "name": "IteratorIterable_iteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/IteratorIterable_iteratorTest.java", "superclasses": "", "methods": ["[void]testIteratorWithResettableIterator()", "[void]testIteratorWithNonResettableIterator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IteratorIterable_iteratorTest {\n\n    @Test\n    public void testIteratorWithResettableIterator() {\n        // Given\n        ResettableIterator<String> mockResettableIterator = mock(ResettableIterator.class);\n        IteratorIterable<String> iterable = new IteratorIterable<>(mockResettableIterator);\n\n        // When\n        Iterator<String> result = iterable.iterator();\n\n        // Then\n        assertNotNull(result);\n        verify(mockResettableIterator, times(1)).reset();\n    }\n\n    @Test\n    public void testIteratorWithNonResettableIterator() {\n        // Given\n        Iterator<String> mockIterator = mock(Iterator.class);\n        IteratorIterable<String> iterable = new IteratorIterable<>(mockIterator);\n\n        // When\n        Iterator<String> result = iterable.iterator();\n\n        // Then\n        assertNotNull(result);\n        verifyNoInteractions(mockIterator);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/BoundedIterator_nextTest.java.BoundedIterator_nextTest", "name": "BoundedIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/BoundedIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNextWithinBounds()", "[void]testNextOutOfBounds()", "[void]testNextWithOffsetGreaterThanSize()", "[void]testNextWithMaxZero()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/BoundedIterator_nextTest.java.BoundedIterator_nextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BoundedIterator_nextTest {\n\n    private List<String> testList;\n\n    @BeforeEach\n    public void setUp() {\n        testList = Arrays.asList(\"A\", \"B\", \"C\", \"D\", \"E\");\n    }\n\n    @Test\n    public void testNextWithinBounds() {\n        Iterator<String> iter = new BoundedIterator<>(testList.iterator(), 1, 3);\n        assertTrue(iter.hasNext());\n        assertEquals(\"B\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"C\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"D\", iter.next());\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testNextOutOfBounds() {\n        Iterator<String> iter = new BoundedIterator<>(testList.iterator(), 1, 3);\n        iter.next(); // Move to \"B\"\n        iter.next(); // Move to \"C\"\n        iter.next(); // Move to \"D\"\n        assertThrows(NoSuchElementException.class, () -> iter.next());\n    }\n\n    @Test\n    public void testNextWithOffsetGreaterThanSize() {\n        Iterator<String> iter = new BoundedIterator<>(testList.iterator(), 10, 4);\n        assertFalse(iter.hasNext());\n        assertThrows(NoSuchElementException.class, () -> iter.next());\n    }\n\n    @Test\n    public void testNextWithMaxZero() {\n        Iterator<String> iter = new BoundedIterator<>(testList.iterator(), 0, 0);\n        assertFalse(iter.hasNext());\n        assertThrows(NoSuchElementException.class, () -> iter.next());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<String> testList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "testList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_elementTest.java.PeekingIterator_elementTest", "name": "PeekingIterator_elementTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_elementTest.java", "superclasses": "", "methods": ["[void]testElementWithValidIterator()", "[void]testElementWithExhaustedIterator()", "[void]testElementAfterPeek()", "[void]testElementAfterNext()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_elementTest.java.PeekingIterator_elementTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PeekingIterator_elementTest {\n\n    private List<String> testList;\n    private static final String[] testArray = {\"a\", \"b\", \"c\"};\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    protected void setUp() throws Exception {\n        testList = new ArrayList<>(Arrays.asList((String[]) testArray));\n    }\n\n    @Test\n    public void testElementWithValidIterator() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertEquals(\"a\", it.element());\n    }\n\n    @Test\n    public void testElementWithExhaustedIterator() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        while (it.hasNext()) {\n            it.next();\n        }\n        assertThrows(NoSuchElementException.class, () -> it.element());\n    }\n\n    @Test\n    public void testElementAfterPeek() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertEquals(\"a\", it.peek());\n        assertEquals(\"a\", it.element());\n    }\n\n    @Test\n    public void testElementAfterNext() {\n        PeekingIterator<String> it = new PeekingIterator<>(testList.iterator());\n        assertEquals(\"a\", it.next());\n        assertEquals(\"b\", it.element());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<String> testList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "testList", "syntax_pass": true}, {"attribute_expression": "private static final String[] testArray = {\"a\", \"b\", \"c\"};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "testArray = {\"a\", \"b\", \"c\"}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_hasNextTest.java.PeekingIterator_hasNextTest", "name": "PeekingIterator_hasNextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_hasNextTest.java", "superclasses": "", "methods": ["[void]testHasNextWithElements()", "[void]testHasNextWithNoElements()", "[void]testHasNextAfterPeek()", "[void]testHasNextAfterElement()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_hasNextTest.java.PeekingIterator_hasNextTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_hasNextTest.java.PeekingIterator_hasNextTest.[PeekingIterator<String>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_hasNextTest.java.PeekingIterator_hasNextTest.[void]validate(Iterator<String>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PeekingIterator_hasNextTest {\n\n    private List<String> testList;\n    private static final String[] testArray = {\"a\", \"b\", \"c\"};\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    protected void setUp() throws Exception {\n        testList = new ArrayList<>(Arrays.asList((String[]) testArray));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private PeekingIterator<String> makeObject() {\n        return new PeekingIterator<>(testList.iterator());\n    }\n\n    private void validate(Iterator<String> iter, String... items) {\n        for (String item : items) {\n            assertTrue(iter.hasNext());\n            assertEquals(item, iter.next());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testHasNextWithElements() {\n        PeekingIterator<String> it = makeObject();\n        assertTrue(it.hasNext());\n        it.next();\n        assertTrue(it.hasNext());\n        it.next();\n        assertTrue(it.hasNext());\n        it.next();\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    public void testHasNextWithNoElements() {\n        PeekingIterator<String> it = new PeekingIterator<>(Collections.emptyIterator());\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    public void testHasNextAfterPeek() {\n        PeekingIterator<String> it = makeObject();\n        it.peek();\n        assertTrue(it.hasNext());\n        it.next();\n        it.peek();\n        assertTrue(it.hasNext());\n        it.next();\n        it.peek();\n        assertTrue(it.hasNext());\n        it.next();\n        it.peek();\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    public void testHasNextAfterElement() {\n        PeekingIterator<String> it = makeObject();\n        it.element();\n        assertTrue(it.hasNext());\n        it.next();\n        it.element();\n        assertTrue(it.hasNext());\n        it.next();\n        it.element();\n        assertTrue(it.hasNext());\n        it.next();\n        assertThrows(NoSuchElementException.class, it::element);\n        assertFalse(it.hasNext());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<String> testList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "testList", "syntax_pass": true}, {"attribute_expression": "private static final String[] testArray = {\"a\", \"b\", \"c\"};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "testArray = {\"a\", \"b\", \"c\"}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SingletonIterator_removeTest.java.SingletonIterator_removeTest", "name": "SingletonIterator_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SingletonIterator_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveAllowed()", "[void]testRemoveNotAllowed()", "[void]testRemoveBeforeNext()", "[void]testRemoveAfterAlreadyRemoved()", "[void]testRemoveAfterReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SingletonIterator_removeTest.java.SingletonIterator_removeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonIterator_removeTest {\n\n    private static final Object testValue = new Object();\n    private SingletonIterator<Object> iterator;\n\n    @BeforeEach\n    public void setUp() {\n        iterator = new SingletonIterator<>(testValue, true);\n    }\n\n    @Test\n    public void testRemoveAllowed() {\n        iterator.next(); // Move to the element\n        iterator.remove(); // Remove the element\n        assertFalse(iterator.hasNext(), \"Iterator should be empty after removal\");\n    }\n\n    @Test\n    public void testRemoveNotAllowed() {\n        iterator = new SingletonIterator<>(testValue, false);\n        iterator.next(); // Move to the element\n        assertThrows(UnsupportedOperationException.class, () -> iterator.remove());\n    }\n\n    @Test\n    public void testRemoveBeforeNext() {\n        assertThrows(IllegalStateException.class, () -> iterator.remove());\n    }\n\n    @Test\n    public void testRemoveAfterAlreadyRemoved() {\n        iterator.next(); // Move to the element\n        iterator.remove(); // Remove the element\n        assertThrows(IllegalStateException.class, () -> iterator.remove());\n    }\n\n    @Test\n    public void testRemoveAfterReset() {\n        iterator.next(); // Move to the element\n        iterator.reset(); // Reset the iterator\n        assertThrows(IllegalStateException.class, () -> iterator.remove());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object testValue = new Object();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "testValue = new Object()", "syntax_pass": true}, {"attribute_expression": "private SingletonIterator<Object> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SingletonIterator<Object>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/IteratorIterableTest.java.IteratorIterableTest", "name": "IteratorIterableTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/IteratorIterableTest.java", "superclasses": "BulkTest", "methods": ["[void]testIterator()", "[void]testMultipleUserIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/IteratorIterableTest.java.IteratorIterableTest.[]IteratorIterableTest()", "src/test/java/org/apache/commons/collections4/iterators/IteratorIterableTest.java.IteratorIterableTest.[Iterator<Integer>]createIterator()", "src/test/java/org/apache/commons/collections4/iterators/IteratorIterableTest.java.IteratorIterableTest.[void]verifyIteration(Iterable<Number>)"], "overrides": null, "attributes": [], "class_docstring": "\nTests for IteratorIterable.\n", "original_string": "public class IteratorIterableTest extends BulkTest {\n\n    public IteratorIterableTest() {\n        super(IteratorIterableTest.class.getSimpleName());\n    }\n\n    private Iterator<Integer> createIterator() {\n        final List<Integer> list = new ArrayList<>();\n        list.add(Integer.valueOf(0));\n        list.add(Integer.valueOf(1));\n        list.add(Integer.valueOf(2));\n        return list.iterator();\n    }\n\n    @Test\n    @SuppressWarnings(\"unused\")\n    public void testIterator() {\n        final Iterator<Integer> iter = createIterator();\n        final Iterable<Number> iterable = new IteratorIterable<>(iter);\n\n        // first use\n        verifyIteration(iterable);\n\n        // second use\n        for (final Number actual : iterable) {\n            fail(\"should not be able to iterate twice\");\n        }\n    }\n\n    @Test\n    public void testMultipleUserIterator() {\n        final Iterator<Integer> iter = createIterator();\n\n        final Iterable<Number> iterable = new IteratorIterable<>(iter, true);\n\n        // first use\n        verifyIteration(iterable);\n\n        // second use\n        verifyIteration(iterable);\n    }\n\n    private void verifyIteration(final Iterable<Number> iterable) {\n        int expected = 0;\n        for (final Number actual : iterable) {\n            assertEquals(expected, actual.intValue());\n            ++expected;\n        }\n        assertTrue(expected > 0);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_peekingIteratorTest.java.PeekingIterator_peekingIteratorTest", "name": "PeekingIterator_peekingIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PeekingIterator_peekingIteratorTest.java", "superclasses": "", "methods": ["[void]testPeekingIteratorWithNullIterator()", "[void]testPeekingIteratorWithNonPeekingIterator()", "[void]testPeekingIteratorWithPeekingIterator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PeekingIterator_peekingIteratorTest {\n\n    @Test\n    void testPeekingIteratorWithNullIterator() {\n        assertThrows(NullPointerException.class, () -> {\n            PeekingIterator.peekingIterator(null);\n        });\n    }\n\n    @Test\n    void testPeekingIteratorWithNonPeekingIterator() {\n        Iterator<String> mockIterator = mock(Iterator.class);\n        PeekingIterator<String> peekingIterator = PeekingIterator.peekingIterator(mockIterator);\n        assertNotNull(peekingIterator);\n        assertNotSame(mockIterator, peekingIterator);\n    }\n\n    @Test\n    void testPeekingIteratorWithPeekingIterator() {\n        PeekingIterator<String> mockPeekingIterator = mock(PeekingIterator.class);\n        PeekingIterator<String> result = PeekingIterator.peekingIterator(mockPeekingIterator);\n        assertSame(mockPeekingIterator, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ZippingIterator_hasNextTest.java.ZippingIterator_hasNextTest", "name": "ZippingIterator_hasNextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ZippingIterator_hasNextTest.java", "superclasses": "", "methods": ["[void]testHasNextWithSingleIterator()", "[void]testHasNextWithMultipleIterators()", "[void]testHasNextWithExhaustedIterator()", "[void]testHasNextWithAllExhaustedIterators()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ZippingIterator_hasNextTest.java.ZippingIterator_hasNextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ZippingIterator_hasNextTest {\n\n    private List<Integer> evens;\n    private List<Integer> odds;\n    private List<Integer> fib;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        evens = new ArrayList<>();\n        odds = new ArrayList<>();\n        for (int i = 0; i < 20; i++) {\n            if (0 == i % 2) {\n                evens.add(i);\n            } else {\n                odds.add(i);\n            }\n        }\n        fib = new ArrayList<>();\n        fib.add(1);\n        fib.add(1);\n        fib.add(2);\n        fib.add(3);\n        fib.add(5);\n        fib.add(8);\n        fib.add(13);\n        fib.add(21);\n    }\n\n    @Test\n    public void testHasNextWithSingleIterator() {\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator());\n        for (final Integer even : evens) {\n            assertTrue(iter.hasNext());\n            assertEquals(even, iter.next());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testHasNextWithMultipleIterators() {\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(evens.iterator(), odds.iterator(), fib.iterator());\n        int totalElements = evens.size() + odds.size() + fib.size();\n        for (int i = 0; i < totalElements; i++) {\n            assertTrue(iter.hasNext());\n            iter.next();\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testHasNextWithExhaustedIterator() {\n        final List<Integer> shortList = new ArrayList<>();\n        shortList.add(1);\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(shortList.iterator(), evens.iterator());\n        assertTrue(iter.hasNext());\n        assertEquals(1, iter.next());\n        for (final Integer even : evens) {\n            assertTrue(iter.hasNext());\n            assertEquals(even, iter.next());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testHasNextWithAllExhaustedIterators() {\n        final List<Integer> emptyList = new ArrayList<>();\n        final ZippingIterator<Integer> iter = new ZippingIterator<>(emptyList.iterator(), emptyList.iterator());\n        assertFalse(iter.hasNext());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<Integer> evens;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Integer>", "name": "evens", "syntax_pass": true}, {"attribute_expression": "private List<Integer> odds;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Integer>", "name": "odds", "syntax_pass": true}, {"attribute_expression": "private List<Integer> fib;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Integer>", "name": "fib", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_nextTest.java.SingletonListIterator_nextTest", "name": "SingletonListIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNextSuccess()", "[void]testNextAfterReset()", "[void]testNextAfterRemove()", "[void]testNextWithoutHasNext()", "[void]testNextAfterPrevious()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_nextTest.java.SingletonListIterator_nextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonListIterator_nextTest {\n\n    private static final Object testValue = new Object();\n    private SingletonListIterator<Object> iterator;\n\n    @BeforeEach\n    public void setUp() {\n        iterator = new SingletonListIterator<>(testValue);\n    }\n\n    @Test\n    public void testNextSuccess() {\n        assertTrue(iterator.hasNext(), \"Iterator should have next item\");\n        assertEquals(testValue, iterator.next(), \"Iteration value is correct\");\n        assertFalse(iterator.hasNext(), \"Iterator should have no next item\");\n    }\n\n    @Test\n    public void testNextAfterReset() {\n        iterator.next();\n        iterator.reset();\n        assertTrue(iterator.hasNext(), \"Iterator should have next item after reset\");\n        assertEquals(testValue, iterator.next(), \"Iteration value is correct after reset\");\n    }\n\n    @Test\n    public void testNextAfterRemove() {\n        iterator.next();\n        iterator.remove();\n        assertFalse(iterator.hasNext(), \"Iterator should have no next item after remove\");\n        assertThrows(NoSuchElementException.class, () -> iterator.next(), \"NoSuchElementException must be thrown after remove\");\n    }\n\n    @Test\n    public void testNextWithoutHasNext() {\n        iterator.next();\n        assertThrows(NoSuchElementException.class, () -> iterator.next(), \"NoSuchElementException must be thrown without hasNext check\");\n    }\n\n    @Test\n    public void testNextAfterPrevious() {\n        iterator.next();\n        iterator.previous();\n        assertTrue(iterator.hasNext(), \"Iterator should have next item after previous\");\n        assertEquals(testValue, iterator.next(), \"Iteration value is correct after previous\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object testValue = new Object();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "testValue = new Object()", "syntax_pass": true}, {"attribute_expression": "private SingletonListIterator<Object> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SingletonListIterator<Object>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIterator_removeTest.java.ObjectGraphIterator_removeTest", "name": "ObjectGraphIterator_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIterator_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveWithoutNext()", "[void]testRemoveAfterNext()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIterator_removeTest.java.ObjectGraphIterator_removeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ObjectGraphIterator_removeTest {\n\n    private List<String> list1;\n    private List<String> list2;\n    private List<String> list3;\n    private List<Iterator<String>> iteratorList;\n\n    @BeforeEach\n    public void setUp() {\n        list1 = new ArrayList<>();\n        list1.add(\"One\");\n        list1.add(\"Two\");\n        list1.add(\"Three\");\n        list2 = new ArrayList<>();\n        list2.add(\"Four\");\n        list3 = new ArrayList<>();\n        list3.add(\"Five\");\n        list3.add(\"Six\");\n        iteratorList = new ArrayList<>();\n        iteratorList.add(list1.iterator());\n        iteratorList.add(list2.iterator());\n        iteratorList.add(list3.iterator());\n    }\n\n    @Test\n    public void testRemoveWithoutNext() {\n        final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator(), null);\n        assertThrows(IllegalStateException.class, it::remove);\n    }\n\n    @Test\n    public void testRemoveAfterNext() {\n        final Iterator<Object> it = new ObjectGraphIterator<>(iteratorList.iterator(), null);\n        assertTrue(it.hasNext());\n        it.next();\n        it.remove();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<String> list1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "list1", "syntax_pass": true}, {"attribute_expression": "private List<String> list2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "list2", "syntax_pass": true}, {"attribute_expression": "private List<String> list3;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "list3", "syntax_pass": true}, {"attribute_expression": "private List<Iterator<String>> iteratorList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Iterator<String>>", "name": "iteratorList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/UniqueFilterIteratorTest.java.UniqueFilterIteratorTest", "name": "UniqueFilterIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/UniqueFilterIteratorTest.java", "superclasses": "", "methods": ["[void]testIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/UniqueFilterIteratorTest.java.UniqueFilterIteratorTest.[]UniqueFilterIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/UniqueFilterIteratorTest.java.UniqueFilterIteratorTest.[UniqueFilterIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/UniqueFilterIteratorTest.java.UniqueFilterIteratorTest.[UniqueFilterIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/UniqueFilterIteratorTest.java.UniqueFilterIteratorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the UniqueFilterIterator class.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class UniqueFilterIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };\n\n    protected List<E> list1;\n\n    public UniqueFilterIteratorTest() {\n        super(UniqueFilterIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public UniqueFilterIterator<E> makeEmptyIterator() {\n        final ArrayList<E> list = new ArrayList<>();\n        return new UniqueFilterIterator<>(list.iterator());\n    }\n\n    @Override\n    public UniqueFilterIterator<E> makeObject() {\n        final Iterator<E> i = list1.iterator();\n        return new UniqueFilterIterator<>(i);\n    }\n\n    @BeforeEach\n    @SuppressWarnings(\"unchecked\")\n    public void setUp() {\n        list1 = new ArrayList<>();\n        list1.add((E) \"One\");\n        list1.add((E) \"Two\");\n        list1.add((E) \"Three\");\n        list1.add((E) \"Two\");\n        list1.add((E) \"One\");\n        list1.add((E) \"Four\");\n        list1.add((E) \"Five\");\n        list1.add((E) \"Five\");\n        list1.add((E) \"Six\");\n        list1.add((E) \"Five\");\n    }\n\n    @Test\n    public void testIterator() {\n        final Iterator<E> iter = makeObject();\n        for (final String testValue : testArray) {\n            final E iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    }", "syntax_pass": true}, {"attribute_expression": "protected List<E> list1;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<E>", "name": "list1", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_getIteratorIndexTest.java.CollatingIterator_getIteratorIndexTest", "name": "CollatingIterator_getIteratorIndexTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_getIteratorIndexTest.java", "superclasses": "", "methods": ["[void]testGetIteratorIndexSuccess()", "[void]testGetIteratorIndexNoValueReturnedYet()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_getIteratorIndexTest.java.CollatingIterator_getIteratorIndexTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CollatingIterator_getIteratorIndexTest {\n\n    private Comparator<Integer> comparator;\n    private ArrayList<Integer> evens;\n    private CollatingIterator<Integer> collatingIterator;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        comparator = new ComparableComparator<>();\n        evens = new ArrayList<>();\n        for (int i = 0; i < 20; i++) {\n            if (0 == i % 2) {\n                evens.add(i);\n            }\n        }\n        collatingIterator = new CollatingIterator<>(comparator);\n        collatingIterator.addIterator(evens.iterator());\n    }\n\n    @Test\n    public void testGetIteratorIndexSuccess() {\n        collatingIterator.next(); // This should set lastReturned to 0\n        assertEquals(0, collatingIterator.getIteratorIndex());\n    }\n\n    @Test\n    public void testGetIteratorIndexNoValueReturnedYet() {\n        assertThrows(IllegalStateException.class, () -> {\n            collatingIterator.getIteratorIndex();\n        });\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Comparator<Integer> comparator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Comparator<Integer>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> evens;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "evens", "syntax_pass": true}, {"attribute_expression": "private CollatingIterator<Integer> collatingIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CollatingIterator<Integer>", "name": "collatingIterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator_unmodifiableOrderedMapIteratorTest.java.UnmodifiableOrderedMapIterator_unmodifiableOrderedMapIteratorTest", "name": "UnmodifiableOrderedMapIterator_unmodifiableOrderedMapIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator_unmodifiableOrderedMapIteratorTest.java", "superclasses": "", "methods": ["[void]testUnmodifiableOrderedMapIteratorWithUnmodifiableIterator()", "[void]testUnmodifiableOrderedMapIteratorWithModifiableIterator()", "[void]testUnmodifiableOrderedMapIteratorWithNullIterator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class UnmodifiableOrderedMapIterator_unmodifiableOrderedMapIteratorTest {\n\n    @Test\n    void testUnmodifiableOrderedMapIteratorWithUnmodifiableIterator() {\n        // Given\n        OrderedMapIterator<String, String> mockIterator = mock(OrderedMapIterator.class);\n        when(mockIterator.hasNext()).thenReturn(false); // Add a valid method call to mock\n\n        // When\n        OrderedMapIterator<String, String> result = UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(mockIterator);\n\n        // Then\n        assertTrue(result instanceof UnmodifiableOrderedMapIterator);\n    }\n\n    @Test\n    void testUnmodifiableOrderedMapIteratorWithModifiableIterator() {\n        // Given\n        OrderedMapIterator<String, String> mockIterator = mock(OrderedMapIterator.class);\n        when(mockIterator.hasNext()).thenReturn(false); // Add a valid method call to mock\n\n        // When\n        OrderedMapIterator<String, String> result = UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(mockIterator);\n\n        // Then\n        assertTrue(result instanceof UnmodifiableOrderedMapIterator);\n    }\n\n    @Test\n    void testUnmodifiableOrderedMapIteratorWithNullIterator() {\n        // Given\n        OrderedMapIterator<String, String> nullIterator = null;\n\n        // When & Then\n        assertThrows(NullPointerException.class, () -> {\n            UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(nullIterator);\n        });\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ArrayListIteratorTest.java.ArrayListIteratorTest", "name": "ArrayListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ArrayListIteratorTest.java", "superclasses": "", "methods": ["[void]testListIterator()", "[void]testListIteratorSet()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ArrayListIteratorTest.java.ArrayListIteratorTest.[]ArrayListIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/ArrayListIteratorTest.java.ArrayListIteratorTest.[ArrayListIterator<E>]makeArrayListIterator(Object)", "src/test/java/org/apache/commons/collections4/iterators/ArrayListIteratorTest.java.ArrayListIteratorTest.[ArrayListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ArrayListIteratorTest.java.ArrayListIteratorTest.[ArrayListIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/ArrayListIteratorTest.java.ArrayListIteratorTest.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTest the ArrayListIterator class.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ArrayListIteratorTest<E> extends ArrayIteratorTest<E> {\n\n    public ArrayListIteratorTest() {\n    }\n\n    public ArrayListIterator<E> makeArrayListIterator(final Object array) {\n        return new ArrayListIterator<>(array);\n    }\n\n    @Override\n    public ArrayListIterator<E> makeEmptyIterator() {\n        return new ArrayListIterator<>(new Object[0]);\n    }\n\n    @Override\n    public ArrayListIterator<E> makeObject() {\n        return new ArrayListIterator<>(testArray);\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    /**\n     * Test the basic ListIterator functionality - going backwards using\n     * {@code previous()}.\n     */\n    @Test\n    public void testListIterator() {\n        final ListIterator<E> iter = makeObject();\n\n        // TestArrayIterator#testIterator() has already tested the iterator forward,\n        //  now we need to test it in reverse\n\n        // fast-forward the iterator to the end...\n        while (iter.hasNext()) {\n            iter.next();\n        }\n\n        for (int x = testArray.length - 1; x >= 0; x--) {\n            final Object testValue = testArray[x];\n            final Object iterValue = iter.previous();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasPrevious(), \"Iterator should now be empty\");\n\n        try {\n            iter.previous();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n\n    }\n\n    /**\n     * Tests the {@link java.util.ListIterator#set} operation.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListIteratorSet() {\n        final String[] testData = { \"a\", \"b\", \"c\" };\n\n        final String[] result = { \"0\", \"1\", \"2\" };\n\n        ListIterator<E> iter = makeArrayListIterator(testData);\n        int x = 0;\n\n        while (iter.hasNext()) {\n            iter.next();\n            iter.set((E) Integer.toString(x));\n            x++;\n        }\n\n        assertArrayEquals(testData, result, \"The two arrays should have the same value, i.e. {0,1,2}\");\n\n        // a call to set() before a call to next() or previous() should throw an IllegalStateException\n        iter = makeArrayListIterator(testArray);\n\n        final ListIterator<E> finalIter = iter;\n        assertThrows(IllegalStateException.class, () -> finalIter.set((E) \"should fail\"), \"ListIterator#set should fail if next() or previous() have not yet been called.\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/LoopingListIteratorTest.java.LoopingListIteratorTest", "name": "LoopingListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/LoopingListIteratorTest.java", "superclasses": "", "methods": ["[void]testAdd()", "[void]testConstructorEx()", "[void]testJoggingNotOverBoundary()", "[void]testJoggingOverBoundary()", "[void]testLooping0()", "[void]testLooping1()", "[void]testLooping2()", "[void]testNextAndPreviousIndex()", "[void]testRemovingElementsAndIteratingBackwards()", "[void]testRemovingElementsAndIteratingForward()", "[void]testReset()", "[void]testSet()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests the LoopingListIterator class.\n", "original_string": "public class LoopingListIteratorTest {\n\n    /**\n     * Tests the add method.\n     */\n    @Test\n    public void testAdd() {\n        List<String> list = new ArrayList<>(Arrays.asList(\"b\", \"e\", \"f\"));\n        LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <b> e f\n\n        loop.add(\"a\");                      // <a> b e f\n        assertEquals(\"b\", loop.next());     // a <b> e f\n        loop.reset();                       // <a> b e f\n        assertEquals(\"a\", loop.next());     // a <b> e f\n        assertEquals(\"b\", loop.next());     // a b <e> f\n\n        loop.add(\"c\");                      // a b c <e> f\n        assertEquals(\"e\", loop.next());     // a b c e <f>\n        assertEquals(\"e\", loop.previous()); // a b c <e> f\n        assertEquals(\"c\", loop.previous()); // a b <c> e f\n        assertEquals(\"c\", loop.next());     // a b c <e> f\n\n        loop.add(\"d\");                      // a b c d <e> f\n        loop.reset();                       // <a> b c d e f\n        assertEquals(\"a\", loop.next());     // a <b> c d e f\n        assertEquals(\"b\", loop.next());     // a b <c> d e f\n        assertEquals(\"c\", loop.next());     // a b c <d> e f\n        assertEquals(\"d\", loop.next());     // a b c d <e> f\n        assertEquals(\"e\", loop.next());     // a b c d e <f>\n        assertEquals(\"f\", loop.next());     // <a> b c d e f\n        assertEquals(\"a\", loop.next());     // a <b> c d e f\n\n        list = new ArrayList<>(Arrays.asList(\"b\", \"e\", \"f\"));\n        loop = new LoopingListIterator<>(list); // <b> e f\n\n        loop.add(\"a\");                      // a <b> e f\n        assertEquals(\"a\", loop.previous()); // a b e <f>\n        loop.reset();                       // <a> b e f\n        assertEquals(\"f\", loop.previous()); // a b e <f>\n        assertEquals(\"e\", loop.previous()); // a b <e> f\n\n        loop.add(\"d\");                      // a b d <e> f\n        assertEquals(\"d\", loop.previous()); // a b <d> e f\n\n        loop.add(\"c\");                      // a b c <d> e f\n        assertEquals(\"c\", loop.previous()); // a b <c> d e f\n\n        loop.reset();\n        assertEquals(\"a\", loop.next());     // a <b> c d e f\n        assertEquals(\"b\", loop.next());     // a b <c> d e f\n        assertEquals(\"c\", loop.next());     // a b c <d> e f\n        assertEquals(\"d\", loop.next());     // a b c d <e> f\n        assertEquals(\"e\", loop.next());     // a b c d e <f>\n        assertEquals(\"f\", loop.next());     // <a> b c d e f\n        assertEquals(\"a\", loop.next());     // a <b> c d e f\n    }\n\n    /**\n     * Tests constructor exception.\n     */\n    @Test\n    public void testConstructorEx() {\n        assertThrows(NullPointerException.class, () -> new LoopingListIterator<>(null));\n    }\n\n    /**\n     * Tests jogging back and forth between two elements, but not over\n     * the begin/end boundary of the list.\n     */\n    @Test\n    public void testJoggingNotOverBoundary() {\n        final List<String> list = Arrays.asList(\"a\", \"b\");\n        final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b\n\n        // Try jogging back and forth between the elements, but not\n        // over the begin/end boundary.\n        loop.reset();\n        assertEquals(\"a\", loop.next());     // a <b>\n        assertEquals(\"a\", loop.previous()); // <a> b\n        assertEquals(\"a\", loop.next());     // a <b>\n\n        assertEquals(\"b\", loop.next());     // <a> b\n        assertEquals(\"b\", loop.previous()); // a <b>\n        assertEquals(\"b\", loop.next());     // <a> b\n    }\n\n    /**\n     * Tests jogging back and forth between two elements over the\n     * begin/end boundary of the list.\n     */\n    @Test\n    public void testJoggingOverBoundary() {\n        final List<String> list = Arrays.asList(\"a\", \"b\");\n        final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b\n\n        // Try jogging back and forth between the elements, but not\n        // over the begin/end boundary.\n        assertEquals(\"b\", loop.previous()); // a <b>\n        assertEquals(\"b\", loop.next());     // <a> b\n        assertEquals(\"b\", loop.previous()); // a <b>\n\n        assertEquals(\"a\", loop.previous()); // <a> b\n        assertEquals(\"a\", loop.next());     // a <b>\n        assertEquals(\"a\", loop.previous()); // <a> b\n    }\n\n    /**\n     * Tests whether an empty looping list iterator works.\n     */\n    @Test\n    public void testLooping0() {\n        final List<Object> list = new ArrayList<>();\n        final LoopingListIterator<Object> loop = new LoopingListIterator<>(list);\n        assertFalse(loop.hasNext());\n        assertFalse(loop.hasPrevious());\n        assertAll(\n                () -> assertThrows(NoSuchElementException.class, () -> loop.next()),\n                () -> assertThrows(NoSuchElementException.class, () -> loop.previous())\n        );\n    }\n\n    /**\n     * Tests whether a looping list iterator works on a list with only\n     * one element.\n     */\n    @Test\n    public void testLooping1() {\n        final List<String> list = Arrays.asList(\"a\");\n        final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a>\n\n        assertTrue(loop.hasNext());\n        assertEquals(\"a\", loop.next());     // <a>\n\n        assertTrue(loop.hasNext());\n        assertEquals(\"a\", loop.next());     // <a>\n\n        assertTrue(loop.hasNext());\n        assertEquals(\"a\", loop.next());     // <a>\n\n        assertTrue(loop.hasPrevious());\n        assertEquals(\"a\", loop.previous()); // <a>\n\n        assertTrue(loop.hasPrevious());\n        assertEquals(\"a\", loop.previous()); // <a>\n\n        assertTrue(loop.hasPrevious());\n        assertEquals(\"a\", loop.previous()); // <a>\n    }\n\n    /**\n     * Tests whether a looping list iterator works on a list with two\n     * elements.\n     */\n    @Test\n    public void testLooping2() {\n        final List<String> list = Arrays.asList(\"a\", \"b\");\n        final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b\n\n        assertTrue(loop.hasNext());\n        assertEquals(\"a\", loop.next());     // a <b>\n\n        assertTrue(loop.hasNext());\n        assertEquals(\"b\", loop.next());     // <a> b\n\n        assertTrue(loop.hasNext());\n        assertEquals(\"a\", loop.next());     // a <b>\n\n        // Reset the iterator and try using previous.\n        loop.reset();                       // <a> b\n\n        assertTrue(loop.hasPrevious());\n        assertEquals(\"b\", loop.previous()); // a <b>\n\n        assertTrue(loop.hasPrevious());\n        assertEquals(\"a\", loop.previous()); // <a> b\n\n        assertTrue(loop.hasPrevious());\n        assertEquals(\"b\", loop.previous()); // a <b>\n    }\n\n    /**\n     * Tests nextIndex and previousIndex.\n     */\n    @Test\n    public void testNextAndPreviousIndex() {\n        final List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c\n\n        assertEquals(0, loop.nextIndex());\n        assertEquals(2, loop.previousIndex());\n\n        assertEquals(\"a\", loop.next());        // a <b> c\n        assertEquals(1, loop.nextIndex());\n        assertEquals(0, loop.previousIndex());\n\n        assertEquals(\"a\", loop.previous());    // <a> b c\n        assertEquals(0, loop.nextIndex());\n        assertEquals(2, loop.previousIndex());\n\n        assertEquals(\"c\", loop.previous());    // a b <c>\n        assertEquals(2, loop.nextIndex());\n        assertEquals(1, loop.previousIndex());\n\n        assertEquals(\"b\", loop.previous());    // a <b> c\n        assertEquals(1, loop.nextIndex());\n        assertEquals(0, loop.previousIndex());\n\n        assertEquals(\"a\", loop.previous());    // <a> b c\n        assertEquals(0, loop.nextIndex());\n        assertEquals(2, loop.previousIndex());\n    }\n\n    /**\n     * Tests removing an element from a wrapped ArrayList.\n     */\n    @Test\n    public void testRemovingElementsAndIteratingBackwards() {\n        final List<String> list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\n        final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c\n\n        assertTrue(loop.hasPrevious());\n        assertEquals(\"c\", loop.previous()); // a b <c>\n        loop.remove();                      // <a> b\n        assertEquals(2, list.size());\n\n        assertTrue(loop.hasPrevious());\n        assertEquals(\"b\", loop.previous()); // a <b>\n        loop.remove();                      // <a>\n        assertEquals(1, list.size());\n\n        assertTrue(loop.hasPrevious());\n        assertEquals(\"a\", loop.previous()); // <a>\n        loop.remove();                      // ---\n        assertEquals(0, list.size());\n\n        assertFalse(loop.hasPrevious());\n\n        assertThrows(NoSuchElementException.class, () -> loop.previous());\n    }\n\n    /**\n     * Tests removing an element from a wrapped ArrayList.\n     */\n    @Test\n    public void testRemovingElementsAndIteratingForward() {\n        final List<String> list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\n        final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c\n\n        assertTrue(loop.hasNext());\n        assertEquals(\"a\", loop.next()); // a <b> c\n        loop.remove();                  // <b> c\n        assertEquals(2, list.size());\n\n        assertTrue(loop.hasNext());\n        assertEquals(\"b\", loop.next()); // b <c>\n        loop.remove();                  // <c>\n        assertEquals(1, list.size());\n\n        assertTrue(loop.hasNext());\n        assertEquals(\"c\", loop.next()); // <c>\n        loop.remove();                  // ---\n        assertEquals(0, list.size());\n\n        assertFalse(loop.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> loop.next());\n    }\n\n    /**\n     * Tests the reset method.\n     */\n    @Test\n    public void testReset() {\n        final List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <a> b c\n\n        assertEquals(\"a\", loop.next()); // a <b> c\n        assertEquals(\"b\", loop.next()); // a b <c>\n        loop.reset();                   // <a> b c\n        assertEquals(\"a\", loop.next()); // a <b> c\n        loop.reset();                   // <a> b c\n        assertEquals(\"a\", loop.next()); // a <b> c\n        assertEquals(\"b\", loop.next()); // a b <c>\n        assertEquals(\"c\", loop.next()); // <a> b c\n        loop.reset();                   // <a> b c\n\n        assertEquals(\"c\", loop.previous()); // a b <c>\n        assertEquals(\"b\", loop.previous()); // a <b> c\n        loop.reset();                       // <a> b c\n        assertEquals(\"c\", loop.previous()); // a b <c>\n        loop.reset();                       // <a> b c\n        assertEquals(\"c\", loop.previous()); // a b <c>\n        assertEquals(\"b\", loop.previous()); // a <b> c\n        assertEquals(\"a\", loop.previous()); // <a> b c\n    }\n\n    /**\n     * Tests using the set method to change elements.\n     */\n    @Test\n    public void testSet() {\n        final List<String> list = Arrays.asList(\"q\", \"r\", \"z\");\n        final LoopingListIterator<String> loop = new LoopingListIterator<>(list); // <q> r z\n\n        assertEquals(\"z\", loop.previous()); // q r <z>\n        loop.set(\"c\");                      // q r <c>\n\n        loop.reset();                       // <q> r c\n        assertEquals(\"q\", loop.next());     // q <r> c\n        loop.set(\"a\");                      // a <r> c\n\n        assertEquals(\"r\", loop.next());     // a r <c>\n        loop.set(\"b\");                      // a b <c>\n\n        loop.reset();                       // <a> b c\n        assertEquals(\"a\", loop.next());     // a <b> c\n        assertEquals(\"b\", loop.next());     // a b <c>\n        assertEquals(\"c\", loop.next());     // <a> b c\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ReverseListIteratorTest.java.ReverseListIteratorTest", "name": "ReverseListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ReverseListIteratorTest.java", "superclasses": "", "methods": ["[void]testEmptyListIteratorIsIndeedEmpty()", "[void]testReset()", "[void]testReverse()", "[void]testWalkForwardAndBack()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ReverseListIteratorTest.java.ReverseListIteratorTest.[]ReverseListIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/ReverseListIteratorTest.java.ReverseListIteratorTest.[ListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ReverseListIteratorTest.java.ReverseListIteratorTest.[ReverseListIterator<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the ReverseListIterator.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ReverseListIteratorTest<E> extends AbstractListIteratorTest<E> {\n\n    protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\" };\n\n    public ReverseListIteratorTest() {\n        super(ReverseListIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public ListIterator<E> makeEmptyIterator() {\n        return new ReverseListIterator<>(new ArrayList<>());\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ReverseListIterator<E> makeObject() {\n        final List<E> list = new ArrayList<>(Arrays.asList((E[]) testArray));\n        return new ReverseListIterator<>(list);\n    }\n\n    // overrides\n    @Test\n    @Override\n    public void testEmptyListIteratorIsIndeedEmpty() {\n        final ListIterator<E> it = makeEmptyIterator();\n\n        assertFalse(it.hasNext());\n        assertEquals(-1, it.nextIndex());  // reversed index\n        assertFalse(it.hasPrevious());\n        assertEquals(0, it.previousIndex());  // reversed index\n\n        assertAll(\n                // next() should throw a NoSuchElementException\n                () -> assertThrows(NoSuchElementException.class, () -> it.next(),\n                        \"NoSuchElementException must be thrown from empty ListIterator\"),\n                // previous() should throw a NoSuchElementException\n                () -> assertThrows(NoSuchElementException.class, () -> it.previous(),\n                        \"NoSuchElementException must be thrown from empty ListIterator\")\n        );\n    }\n\n    @Test\n    public void testReset() {\n        final ResettableListIterator<E> it = makeObject();\n        assertEquals(\"Four\", it.next());\n        it.reset();\n        assertEquals(\"Four\", it.next());\n        it.next();\n        it.next();\n        it.reset();\n        assertEquals(\"Four\", it.next());\n    }\n\n    @Test\n    public void testReverse() {\n        final ListIterator<E> it = makeObject();\n        assertTrue(it.hasNext());\n        assertEquals(3, it.nextIndex());\n        assertFalse(it.hasPrevious());\n        assertEquals(4, it.previousIndex());\n        assertEquals(\"Four\", it.next());\n        assertEquals(2, it.nextIndex());\n        assertTrue(it.hasNext());\n        assertEquals(3, it.previousIndex());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"Three\", it.next());\n        assertTrue(it.hasNext());\n        assertEquals(1, it.nextIndex());\n        assertTrue(it.hasPrevious());\n        assertEquals(2, it.previousIndex());\n        assertEquals(\"Two\", it.next());\n        assertTrue(it.hasNext());\n        assertEquals(0, it.nextIndex());\n        assertTrue(it.hasPrevious());\n        assertEquals(1, it.previousIndex());\n        assertEquals(\"One\", it.next());\n        assertFalse(it.hasNext());\n        assertEquals(-1, it.nextIndex());\n        assertTrue(it.hasPrevious());\n        assertEquals(0, it.previousIndex());\n        assertEquals(\"One\", it.previous());\n        assertEquals(\"Two\", it.previous());\n        assertEquals(\"Three\", it.previous());\n        assertEquals(\"Four\", it.previous());\n    }\n\n    @Test\n    @Override\n    public void testWalkForwardAndBack() {\n        final ArrayList<E> list = new ArrayList<>();\n        final ListIterator<E> it = makeObject();\n        while (it.hasNext()) {\n            list.add(it.next());\n        }\n\n        // check state at end\n        assertFalse(it.hasNext());\n        assertTrue(it.hasPrevious());\n\n        // this had to be commented out, as there is a bug in the JDK before JDK1.5\n        // where calling previous at the start of an iterator would push the cursor\n        // back to an invalid negative value\n//        try {\n//            it.next();\n//            fail(\"NoSuchElementException must be thrown from next at end of ListIterator\");\n//        } catch (NoSuchElementException e) {\n//        }\n\n        // loop back through comparing\n        for (int i = list.size() - 1; i >= 0; i--) {\n            assertEquals(list.size() - i - 2, it.nextIndex(), \"\" + i);  // reversed index\n            assertEquals(list.size() - i - 1, it.previousIndex());  // reversed index\n\n            final Object obj = list.get(i);\n            assertEquals(obj, it.previous());\n        }\n\n        // check state at start\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n\n        assertThrows(NoSuchElementException.class, () -> it.previous(),\n                \"NoSuchElementException must be thrown from previous at start of ListIterator\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = { \"One\", \"Two\", \"Three\", \"Four\" }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java.UnmodifiableListIteratorTest", "name": "UnmodifiableListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testListIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java.UnmodifiableListIteratorTest.[]UnmodifiableListIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java.UnmodifiableListIteratorTest.[ListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java.UnmodifiableListIteratorTest.[ListIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java.UnmodifiableListIteratorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java.UnmodifiableListIteratorTest.[boolean]supportsAdd()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java.UnmodifiableListIteratorTest.[boolean]supportsRemove()", "src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java.UnmodifiableListIteratorTest.[boolean]supportsSet()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the UnmodifiableListIterator.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class UnmodifiableListIteratorTest<E> extends AbstractListIteratorTest<E> {\n\n    protected String[] testArray = {\"One\", \"Two\", \"Three\"};\n    protected List<E> testList;\n\n    public UnmodifiableListIteratorTest() {\n        super(UnmodifiableListIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public ListIterator<E> makeEmptyIterator() {\n        return UnmodifiableListIterator.unmodifiableListIterator(Collections.<E>emptyList().listIterator());\n    }\n\n    @Override\n    public ListIterator<E> makeObject() {\n        return UnmodifiableListIterator.unmodifiableListIterator(testList.listIterator());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    protected void setUp() throws Exception {\n        testList = new ArrayList<>(Arrays.asList((E[]) testArray));\n    }\n\n    @Override\n    public boolean supportsAdd() {\n        return false;\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Override\n    public boolean supportsSet() {\n        return false;\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        ListIterator<E> it = makeObject();\n        assertSame(it, UnmodifiableListIterator.unmodifiableListIterator(it));\n\n        it = testList.listIterator();\n        assertNotSame(it, UnmodifiableListIterator.unmodifiableListIterator(it));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableListIterator.unmodifiableListIterator(null));\n    }\n\n    @Test\n    public void testListIterator() {\n        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = {\"One\", \"Two\", \"Three\"};", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = {\"One\", \"Two\", \"Three\"}", "syntax_pass": true}, {"attribute_expression": "protected List<E> testList;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<E>", "name": "testList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/LoopingListIterator_previousIndexTest.java.LoopingListIterator_previousIndexTest", "name": "LoopingListIterator_previousIndexTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/LoopingListIterator_previousIndexTest.java", "superclasses": "", "methods": ["[void]testPreviousIndexWithEmptyList()", "[void]testPreviousIndexAtBeginning()", "[void]testPreviousIndexAfterPrevious()", "[void]testPreviousIndexAfterReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/LoopingListIterator_previousIndexTest.java.LoopingListIterator_previousIndexTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LoopingListIterator_previousIndexTest {\n\n    private LoopingListIterator<String> loopingListIterator;\n    private List<String> list;\n\n    @BeforeEach\n    public void setUp() {\n        list = Arrays.asList(\"a\", \"b\", \"c\");\n        loopingListIterator = new LoopingListIterator<>(list);\n    }\n\n    @Test\n    public void testPreviousIndexWithEmptyList() {\n        loopingListIterator = new LoopingListIterator<>(Arrays.asList());\n        assertThrows(NoSuchElementException.class, () -> {\n            loopingListIterator.previousIndex();\n        });\n    }\n\n    @Test\n    public void testPreviousIndexAtBeginning() {\n        assertEquals(2, loopingListIterator.previousIndex());\n    }\n\n    @Test\n    public void testPreviousIndexAfterPrevious() {\n        loopingListIterator.previous();\n        assertEquals(1, loopingListIterator.previousIndex());\n    }\n\n    @Test\n    public void testPreviousIndexAfterReset() {\n        loopingListIterator.reset();\n        assertEquals(2, loopingListIterator.previousIndex());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private LoopingListIterator<String> loopingListIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "LoopingListIterator<String>", "name": "loopingListIterator", "syntax_pass": true}, {"attribute_expression": "private List<String> list;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "list", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java.PermutationIteratorTest", "name": "PermutationIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java", "superclasses": "", "methods": ["[void]testEmptyCollection()", "[void]testPermutationException()", "[void]testPermutationExhaustivity()", "[void]testPermutationResultSize()", "[void]testPermutationUnicity()", "[void]testPermutatorHasMore()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java.PermutationIteratorTest.[]PermutationIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java.PermutationIteratorTest.[PermutationIterator<Character>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java.PermutationIteratorTest.[PermutationIterator<Character>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java.PermutationIteratorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java.PermutationIteratorTest.[boolean]supportsEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java.PermutationIteratorTest.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTest class for PermutationIterator.\n", "original_string": "public class PermutationIteratorTest extends AbstractIteratorTest<List<Character>> {\n\n    @SuppressWarnings(\"boxing\") // OK in test code\n    protected Character[] testArray = { 'A', 'B', 'C' };\n    protected List<Character> testList;\n\n    public PermutationIteratorTest() {\n        super(PermutationIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public PermutationIterator<Character> makeEmptyIterator() {\n        return new PermutationIterator<>(new ArrayList<>());\n    }\n\n    @Override\n    public PermutationIterator<Character> makeObject() {\n        return new PermutationIterator<>(testList);\n    }\n\n    @BeforeEach\n    public void setUp() {\n        testList = new ArrayList<>();\n        testList.addAll(Arrays.asList(testArray));\n    }\n\n    @Override\n    public boolean supportsEmptyIterator() {\n        return false;\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n    @Test\n    public void testEmptyCollection() {\n        final PermutationIterator<Character> it = makeEmptyIterator();\n        // there is one permutation for an empty set: 0! = 1\n        assertTrue(it.hasNext());\n\n        final List<Character> nextPermutation = it.next();\n        assertEquals(0, nextPermutation.size());\n\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    public void testPermutationException() {\n        final List<List<Character>> resultsList = new ArrayList<>();\n\n        final PermutationIterator<Character> it = makeObject();\n        while (it.hasNext()) {\n            final List<Character> permutation = it.next();\n            resultsList.add(permutation);\n        }\n        //asking for another permutation should throw an exception\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    /**\n     * test checking that all the permutations are returned\n     */\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testPermutationExhaustivity() {\n        final List<Character> perm1 = new ArrayList<>();\n        final List<Character> perm2 = new ArrayList<>();\n        final List<Character> perm3 = new ArrayList<>();\n        final List<Character> perm4 = new ArrayList<>();\n        final List<Character> perm5 = new ArrayList<>();\n        final List<Character> perm6 = new ArrayList<>();\n\n        perm1.add('A');\n        perm2.add('A');\n        perm3.add('B');\n        perm4.add('B');\n        perm5.add('C');\n        perm6.add('C');\n\n        perm1.add('B');\n        perm2.add('C');\n        perm3.add('A');\n        perm4.add('C');\n        perm5.add('A');\n        perm6.add('B');\n\n        perm1.add('C');\n        perm2.add('B');\n        perm3.add('C');\n        perm4.add('A');\n        perm5.add('B');\n        perm6.add('A');\n\n        final List<List<Character>> results = new ArrayList<>();\n\n        final PermutationIterator<Character> it = makeObject();\n        while (it.hasNext()) {\n            final List<Character> next = it.next();\n            results.add(next);\n        }\n        //3! permutation for 3 elements\n        assertEquals(6, results.size());\n        assertTrue(results.contains(perm1));\n        assertTrue(results.contains(perm2));\n        assertTrue(results.contains(perm3));\n        assertTrue(results.contains(perm4));\n        assertTrue(results.contains(perm5));\n        assertTrue(results.contains(perm6));\n    }\n\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testPermutationResultSize() {\n        int factorial = 1;\n        for (int i = 0; i < 8; i++, factorial *= i) {\n            final List<Integer> list = new ArrayList<>();\n            for (int j = 0; j < i; j++) {\n                list.add(j);\n            }\n            final Iterator<List<Integer>> it = new PermutationIterator<>(list);\n            int count = 0;\n            while (it.hasNext()) {\n                it.next();\n                count++;\n            }\n            assertEquals(factorial, count);\n        }\n    }\n\n    /**\n     * test checking that all the permutations are returned only once.\n     */\n    @Test\n    public void testPermutationUnicity() {\n        final List<List<Character>> resultsList = new ArrayList<>();\n        final Set<List<Character>> resultsSet = new HashSet<>();\n\n        final PermutationIterator<Character> it = makeObject();\n        while (it.hasNext()) {\n            final List<Character> permutation = it.next();\n            resultsList.add(permutation);\n            resultsSet.add(permutation);\n        }\n        //3! permutation for 3 elements\n        assertEquals(6, resultsList.size());\n        assertEquals(6, resultsSet.size());\n    }\n\n    @Test\n    public void testPermutatorHasMore() {\n        final PermutationIterator<Character> it = makeObject();\n        for (int i = 0; i < 6; i++) {\n            assertTrue(it.hasNext());\n            it.next();\n        }\n        assertFalse(it.hasNext());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"boxing\") // OK in test code\n    protected Character[] testArray = { 'A', 'B', 'C' };", "docstring": "", "modifiers": "@SuppressWarnings(\"boxing\") // OK in test code\n    protected", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"boxing\")", "protected"], "comments": ["// OK in test code"], "type": "Character[]", "name": "testArray = { 'A', 'B', 'C' }", "syntax_pass": true}, {"attribute_expression": "protected List<Character> testList;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<Character>", "name": "testList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java.ListIteratorWrapperTest", "name": "ListIteratorWrapperTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java", "superclasses": "", "methods": ["[void]testIterator()", "[void]testRemove()", "[void]testReset()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java.ListIteratorWrapperTest.[]ListIteratorWrapperTest()", "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java.ListIteratorWrapperTest.[ResettableListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java.ListIteratorWrapperTest.[ResettableListIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java.ListIteratorWrapperTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the ListIteratorWrapper to ensure that it simulates\na ListIterator correctly.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ListIteratorWrapperTest<E> extends AbstractIteratorTest<E> {\n\n    protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };\n\n    protected List<E> list1;\n\n    public ListIteratorWrapperTest() {\n        super(ListIteratorWrapperTest.class.getSimpleName());\n    }\n\n    @Override\n    public ResettableListIterator<E> makeEmptyIterator() {\n        final ArrayList<E> list = new ArrayList<>();\n        return new ListIteratorWrapper<>(list.iterator());\n    }\n\n    @Override\n    public ResettableListIterator<E> makeObject() {\n        return new ListIteratorWrapper<>(list1.iterator());\n    }\n\n    @BeforeEach\n    @SuppressWarnings(\"unchecked\")\n    public void setUp() {\n        list1 = new ArrayList<>();\n        list1.add((E) \"One\");\n        list1.add((E) \"Two\");\n        list1.add((E) \"Three\");\n        list1.add((E) \"Four\");\n        list1.add((E) \"Five\");\n        list1.add((E) \"Six\");\n    }\n\n    @Test\n    public void testIterator() {\n        final ListIterator<E> iter = makeObject();\n        for (final String testValue : testArray) {\n            final Object iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        assertFalse(iter.hasNext(), \"Iterator should now be empty\");\n\n        try {\n            iter.next();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n\n        // now, read it backwards\n        for (int i = testArray.length - 1; i > -1; --i) {\n            final Object testValue = testArray[i];\n            final E iterValue = iter.previous();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n        try {\n            iter.previous();\n        } catch (final Exception e) {\n            assertEquals(e.getClass(), new NoSuchElementException().getClass(), \"NoSuchElementException must be thrown\");\n        }\n\n        // now, read it forwards again\n        for (final String testValue : testArray) {\n            final Object iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n\n    }\n\n    @Test\n    @Override\n    public void testRemove() {\n        final ListIterator<E> iter = makeObject();\n\n        //initial state:\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        assertThrows(IllegalStateException.class, () -> iter.remove(),\n                \"ListIteratorWrapper#remove() should fail; must be initially positioned first\");\n\n        //no change from invalid op:\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        //establish size:\n        int sz = list1.size();\n\n        //verify initial next() call:\n        assertEquals(list1.get(0), iter.next());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n\n        //verify remove():\n        iter.remove();\n        assertEquals(--sz, list1.size());\n        //like we never started iterating:\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        assertThrows(IllegalStateException.class, () -> iter.remove(),\n                \"ListIteratorWrapper#remove() should fail; must be repositioned first\");\n\n        //no change from invalid op:\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        //two consecutive next() calls:\n        assertEquals(list1.get(0), iter.next());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n\n        assertEquals(list1.get(1), iter.next());\n        assertEquals(1, iter.previousIndex());\n        assertEquals(2, iter.nextIndex());\n\n        //call previous():\n        assertEquals(list1.get(1), iter.previous());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n\n        //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:\n        iter.remove();\n        assertEquals(--sz, list1.size());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n\n        //dig into cache\n        assertEquals(list1.get(0), iter.previous());\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        assertThrows(IllegalStateException.class, () -> iter.remove(),\n                \"ListIteratorWrapper does not support the remove() method while dug into the cache via previous()\");\n\n        //no change from invalid op:\n        assertEquals(-1, iter.previousIndex());\n        assertEquals(0, iter.nextIndex());\n\n        //dig out of cache, first next() maintains current position:\n        assertEquals(list1.get(0), iter.next());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n        //continue traversing underlying iterator with this next() call, and we're out of the hole, so to speak:\n        assertEquals(list1.get(1), iter.next());\n        assertEquals(1, iter.previousIndex());\n        assertEquals(2, iter.nextIndex());\n\n        //verify remove() works again:\n        iter.remove();\n        assertEquals(--sz, list1.size());\n        assertEquals(0, iter.previousIndex());\n        assertEquals(1, iter.nextIndex());\n\n        assertEquals(list1.get(1), iter.next());\n        assertEquals(1, iter.previousIndex());\n        assertEquals(2, iter.nextIndex());\n\n    }\n\n    @Test\n    public void testReset() {\n        final ResettableListIterator<E> iter = makeObject();\n        final E first = iter.next();\n        final E second = iter.next();\n\n        iter.reset();\n\n        // after reset, there shouldn't be any previous elements\n        assertFalse(iter.hasPrevious(), \"No previous elements after reset()\");\n\n        // after reset, the results should be the same as before\n        assertEquals(first, iter.next(), \"First element should be the same\");\n        assertEquals(second, iter.next(), \"Second element should be the same\");\n\n        // after passing the point, where we reset, continuation should work as expected\n        for (int i = 2; i < testArray.length; i++) {\n            final Object testValue = testArray[i];\n            final E iterValue = iter.next();\n\n            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = {\n        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n    }", "syntax_pass": true}, {"attribute_expression": "protected List<E> list1;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<E>", "name": "list1", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/CollatingIteratorTest.java.CollatingIteratorTest", "name": "CollatingIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/CollatingIteratorTest.java", "superclasses": "", "methods": ["[void]testGetSetComparator()", "[void]testIterateEven()", "[void]testIterateEvenEven()", "[void]testIterateEvenOdd()", "[void]testIterateFibEvenOdd()", "[void]testIterateOddEven()", "[void]testNullComparator()", "[void]testRemoveFromDouble()", "[void]testRemoveFromSingle()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/CollatingIteratorTest.java.CollatingIteratorTest.[]CollatingIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/CollatingIteratorTest.java.CollatingIteratorTest.[CollatingIterator<Integer>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/CollatingIteratorTest.java.CollatingIteratorTest.[CollatingIterator<Integer>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/CollatingIteratorTest.java.CollatingIteratorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nUnit test suite for {@link CollatingIterator}.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class CollatingIteratorTest extends AbstractIteratorTest<Integer> {\n\n    //------------------------------------------------------------ Conventional\n\n    private Comparator<Integer> comparator;\n\n    //--------------------------------------------------------------- Lifecycle\n\n    private ArrayList<Integer> evens;\n    private ArrayList<Integer> odds;\n    private ArrayList<Integer> fib;\n    public CollatingIteratorTest() {\n        super(CollatingIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public CollatingIterator<Integer> makeEmptyIterator() {\n        return new CollatingIterator<>(comparator);\n    }\n\n    //---------------------------------------------------- TestIterator Methods\n\n    @Override\n    public CollatingIterator<Integer> makeObject() {\n        final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);\n        iter.addIterator(evens.iterator());\n        iter.addIterator(odds.iterator());\n        iter.addIterator(fib.iterator());\n        return iter;\n    }\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        comparator = new ComparableComparator<>();\n        evens = new ArrayList<>();\n        odds = new ArrayList<>();\n        for (int i = 0; i < 20; i++) {\n            if (0 == i % 2) {\n                evens.add(i);\n            } else {\n                odds.add(i);\n            }\n        }\n        fib = new ArrayList<>();\n        fib.add(1);\n        fib.add(1);\n        fib.add(2);\n        fib.add(3);\n        fib.add(5);\n        fib.add(8);\n        fib.add(13);\n        fib.add(21);\n    }\n\n    //------------------------------------------------------------------- Tests\n\n    @Test\n    public void testGetSetComparator() {\n        final CollatingIterator<Integer> iter = new CollatingIterator<>();\n        assertNull(iter.getComparator());\n        iter.setComparator(comparator);\n        assertSame(comparator, iter.getComparator());\n        iter.setComparator(null);\n        assertNull(iter.getComparator());\n    }\n\n    @Test\n    public void testIterateEven() {\n        final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);\n        iter.addIterator(evens.iterator());\n        for (final Integer even : evens) {\n            assertTrue(iter.hasNext());\n            assertEquals(even, iter.next());\n            assertEquals(0, iter.getIteratorIndex());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testIterateEvenEven() {\n        final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);\n        iter.addIterator(evens.iterator());\n        iter.addIterator(evens.iterator());\n        for (final Integer even : evens) {\n            assertTrue(iter.hasNext());\n            assertEquals(even, iter.next());\n            assertEquals(0, iter.getIteratorIndex());\n            assertTrue(iter.hasNext());\n            assertEquals(even, iter.next());\n            assertEquals(1, iter.getIteratorIndex());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testIterateEvenOdd() {\n        final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator, evens.iterator(), odds.iterator());\n        for (int i = 0; i < 20; i++) {\n            assertTrue(iter.hasNext());\n            assertEquals(Integer.valueOf(i), iter.next());\n            assertEquals(i % 2, iter.getIteratorIndex());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testIterateFibEvenOdd() {\n        final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);\n        iter.addIterator(fib.iterator());\n        iter.addIterator(evens.iterator());\n        iter.addIterator(odds.iterator());\n\n        assertEquals(Integer.valueOf(0), iter.next());  // even   0\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(1), iter.next());  // fib    1\n        assertEquals(0, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(1), iter.next());  // fib    1\n        assertEquals(0, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(1), iter.next());  // odd    1\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(2), iter.next());  // fib    2\n        assertEquals(0, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(2), iter.next());  // even   2\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(3), iter.next());  // fib    3\n        assertEquals(0, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(3), iter.next());  // odd    3\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(4), iter.next());  // even   4\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(5), iter.next());  // fib    5\n        assertEquals(0, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(5), iter.next());  // odd    5\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(6), iter.next());  // even   6\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(7), iter.next());  // odd    7\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(8), iter.next());  // fib    8\n        assertEquals(0, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(8), iter.next());  // even   8\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(9), iter.next());  // odd    9\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(10), iter.next()); // even  10\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(11), iter.next()); // odd   11\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(12), iter.next()); // even  12\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(13), iter.next()); // fib   13\n        assertEquals(0, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(13), iter.next()); // odd   13\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(14), iter.next()); // even  14\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(15), iter.next()); // odd   15\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(16), iter.next()); // even  16\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(17), iter.next()); // odd   17\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(18), iter.next()); // even  18\n        assertEquals(1, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(19), iter.next()); // odd   19\n        assertEquals(2, iter.getIteratorIndex());\n        assertEquals(Integer.valueOf(21), iter.next()); // fib   21\n        assertEquals(0, iter.getIteratorIndex());\n\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testIterateOddEven() {\n        final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator, odds.iterator(), evens.iterator());\n        for (int i = 0; i < 20; i++) {\n            assertTrue(iter.hasNext());\n            assertEquals(Integer.valueOf(i), iter.next());\n            assertEquals(i % 2 == 0 ? 1 : 0, iter.getIteratorIndex());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n    @Test\n    public void testNullComparator() {\n        final List<Integer> l1 = Arrays.asList(1, 3, 5);\n        final List<Integer> l2 = Arrays.asList(2, 4, 6);\n\n        final CollatingIterator<Integer> collatingIterator1 = new CollatingIterator<>(null, l1.iterator(), l2.iterator());\n        try {\n            collatingIterator1.next();\n        } catch (final NullPointerException e) {\n            assertTrue(e.getMessage().startsWith(\"You must invoke setComparator\"));\n        }\n\n        int i = 0;\n        final CollatingIterator<Integer> collatingIterator2 = new CollatingIterator<>(null, l1.iterator(), l2.iterator());\n        collatingIterator2.setComparator(new ComparableComparator<>());\n        for ( ; collatingIterator2.hasNext(); i++ ) {\n            final Integer n = collatingIterator2.next();\n            assertEquals((int) n, i + 1, \"wrong order\");\n        }\n        assertEquals(i, l1.size() + l2.size(), \"wrong size\");\n    }\n\n    @Test\n    public void testRemoveFromDouble() {\n        final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);\n        iter.addIterator(evens.iterator());\n        iter.addIterator(odds.iterator());\n        int expectedSize = evens.size() + odds.size();\n        while (iter.hasNext()) {\n            final Object o = iter.next();\n            final Integer val = (Integer) o;\n            if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {\n                expectedSize--;\n                iter.remove();\n            }\n        }\n        assertEquals(expectedSize, evens.size() + odds.size());\n    }\n\n    @Test\n    public void testRemoveFromSingle() {\n        final CollatingIterator<Integer> iter = new CollatingIterator<>(comparator);\n        iter.addIterator(evens.iterator());\n        int expectedSize = evens.size();\n        while (iter.hasNext()) {\n            final Object o = iter.next();\n            final Integer val = (Integer) o;\n            if (val.intValue() % 4 == 0) {\n                expectedSize--;\n                iter.remove();\n            }\n        }\n        assertEquals(expectedSize, evens.size());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Comparator<Integer> comparator;", "docstring": "------------------------------------------------------------ Conventional", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Comparator<Integer>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> evens;", "docstring": "--------------------------------------------------------------- Lifecycle", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "evens", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> odds;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "odds", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Integer> fib;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Integer>", "name": "fib", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_hasNextTest.java.CollatingIterator_hasNextTest", "name": "CollatingIterator_hasNextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_hasNextTest.java", "superclasses": "", "methods": ["[void]testHasNext_WithNoIterators()", "[void]testHasNext_WithEmptyIterators()", "[void]testHasNext_WithNonEmptyIterators()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/CollatingIterator_hasNextTest.java.CollatingIterator_hasNextTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CollatingIterator_hasNextTest {\n\n    private CollatingIterator<Integer> collatingIterator;\n    private List<Iterator<Integer>> iterators;\n\n    @BeforeEach\n    public void setUp() {\n        collatingIterator = new CollatingIterator<>(Comparator.naturalOrder());\n        iterators = new ArrayList<>();\n    }\n\n    @Test\n    public void testHasNext_WithNoIterators() {\n        assertFalse(collatingIterator.hasNext());\n    }\n\n    @Test\n    public void testHasNext_WithEmptyIterators() {\n        iterators.add(Arrays.<Integer>asList().iterator());\n        iterators.add(Arrays.<Integer>asList().iterator());\n        iterators.forEach(collatingIterator::addIterator);\n        assertFalse(collatingIterator.hasNext());\n    }\n\n    @Test\n    public void testHasNext_WithNonEmptyIterators() {\n        iterators.add(Arrays.asList(1, 2).iterator());\n        iterators.add(Arrays.asList(3, 4).iterator());\n        iterators.forEach(collatingIterator::addIterator);\n        assertTrue(collatingIterator.hasNext());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CollatingIterator<Integer> collatingIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CollatingIterator<Integer>", "name": "collatingIterator", "syntax_pass": true}, {"attribute_expression": "private List<Iterator<Integer>> iterators;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Iterator<Integer>>", "name": "iterators", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java.BoundedIteratorTest", "name": "BoundedIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java", "superclasses": "", "methods": ["[void]testBounded()", "[void]testEmptyBounded()", "[void]testMaxGreaterThanSize()", "[void]testNegativeMax()", "[void]testNegativeOffset()", "[void]testOffsetGreaterThanSize()", "[void]testRemoveCalledTwice()", "[void]testRemoveFirst()", "[void]testRemoveLast()", "[void]testRemoveMiddle()", "[void]testRemoveUnsupported()", "[void]testRemoveWithoutCallingNext()", "[void]testSameAsDecorated()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java.BoundedIteratorTest.[]BoundedIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java.BoundedIteratorTest.[Iterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java.BoundedIteratorTest.[Iterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java.BoundedIteratorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nA unit test to test the basic functions of {@link BoundedIterator}.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class BoundedIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    /** Test array of size 7 */\n    private final String[] testArray = {\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\n    };\n\n    private List<E> testList;\n\n    public BoundedIteratorTest() {\n        super(BoundedIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public Iterator<E> makeEmptyIterator() {\n        return new BoundedIterator<>(Collections.<E>emptyList().iterator(), 0, 10);\n    }\n\n    @Override\n    public Iterator<E> makeObject() {\n        return new BoundedIterator<>(new ArrayList<>(testList).iterator(), 1, testList.size() - 1);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    public void setUp()\n        throws Exception {\n        testList = Arrays.asList((E[]) testArray);\n    }\n\n    /**\n     * Test a decorated iterator bounded such that the first element returned is\n     * at an index greater its first element, and the last element returned is\n     * at an index less than its last element.\n     */\n    @Test\n    public void testBounded() {\n        final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 2, 4);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"c\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"d\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next(),\n                \"Expected NoSuchElementException.\");\n    }\n\n    /**\n     * Test a decorated iterator bounded to a {@code max} of 0. The\n     * BoundedIterator should behave as if there are no more elements to return,\n     * since it is technically an empty iterator.\n     */\n    @Test\n    public void testEmptyBounded() {\n        final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 3, 0);\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next());\n    }\n\n    /**\n     * Test the case if the {@code max} passed to the constructor is\n     * greater than the size of the decorated iterator. The last element\n     * returned should be the same as the last element of the decorated\n     * iterator.\n     */\n    @Test\n    public void testMaxGreaterThanSize() {\n        final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 1, 10);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"c\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"d\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"g\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next());\n    }\n\n    /**\n     * Test the case if a negative {@code max} is passed to the\n     * constructor. {@link IllegalArgumentException} is expected.\n     */\n    @Test\n    public void testNegativeMax() {\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> new BoundedIterator<>(testList.iterator(), 3, -1));\n        assertThat(thrown.getMessage(), is(equalTo(\"Max parameter must not be negative.\")));\n    }\n\n    /**\n     * Test the case if a negative {@code offset} is passed to the\n     * constructor. {@link IllegalArgumentException} is expected.\n     */\n    @Test\n    public void testNegativeOffset() {\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> new BoundedIterator<>(testList.iterator(), -1, 4));\n        assertThat(thrown.getMessage(), is(equalTo(\"Offset parameter must not be negative.\")));\n    }\n\n    /**\n     * Test the case if the {@code offset} passed to the constructor is\n     * greater than the decorated iterator's size. The BoundedIterator should\n     * behave as if there are no more elements to return.\n     */\n    @Test\n    public void testOffsetGreaterThanSize() {\n        final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 10, 4);\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next());\n    }\n\n    /**\n     * Test the {@code remove()} method being called twice without calling\n     * {@code next()} in between.\n     */\n    @Test\n    public void testRemoveCalledTwice() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n        iter.remove();\n\n        assertThrows(IllegalStateException.class, () -> iter.remove());\n    }\n\n    /**\n     * Test removing the first element. Verify that the element is removed from\n     * the underlying collection.\n     */\n    @Test\n    public void testRemoveFirst() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n\n        iter.remove();\n        assertFalse(testListCopy.contains(\"b\"));\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"c\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"d\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next());\n    }\n\n    /**\n     * Test removing the last element. Verify that the element is removed from\n     * the underlying collection.\n     */\n    @Test\n    public void testRemoveLast() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"c\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"d\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        final NoSuchElementException thrown = assertThrows(NoSuchElementException.class, () -> iter.next());\n        assertThat(thrown.getMessage(), is(nullValue()));\n\n        iter.remove();\n        assertFalse(testListCopy.contains(\"f\"));\n\n        assertFalse(iter.hasNext());\n\n        final NoSuchElementException thrown1 = assertThrows(NoSuchElementException.class, () -> iter.next());\n        assertThat(thrown1.getMessage(), is(nullValue()));\n    }\n\n    /**\n     * Test removing an element in the middle of the iterator. Verify that the\n     * element is removed from the underlying collection.\n     */\n    @Test\n    public void testRemoveMiddle() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"c\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"d\", iter.next());\n\n        iter.remove();\n        assertFalse(testListCopy.contains(\"d\"));\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next());\n    }\n\n    /**\n     * Test the case if the decorated iterator does not support the\n     * {@code remove()} method and throws an {@link UnsupportedOperationException}.\n     */\n    @Test\n    public void testRemoveUnsupported() {\n        final Iterator<E> mockIterator = new AbstractIteratorDecorator<E>(testList.iterator()) {\n            @Override\n            public void remove() {\n                throw new UnsupportedOperationException();\n            }\n        };\n\n        final Iterator<E> iter = new BoundedIterator<>(mockIterator, 1, 5);\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n\n        final UnsupportedOperationException thrown = assertThrows(UnsupportedOperationException.class, () -> iter.remove());\n        assertThat(thrown.getMessage(), is(nullValue()));\n    }\n\n    /**\n     * Test the {@code remove()} method being called without\n     * {@code next()} being called first.\n     */\n    @Test\n    public void testRemoveWithoutCallingNext() {\n        final List<E> testListCopy = new ArrayList<>(testList);\n        final Iterator<E> iter = new BoundedIterator<>(testListCopy.iterator(), 1, 5);\n\n        final IllegalStateException thrown = assertThrows(IllegalStateException.class, () -> iter.remove());\n        assertThat(thrown.getMessage(), is(equalTo(\"remove() can not be called before calling next()\")));\n    }\n\n    /**\n     * Test a decorated iterator bounded such that the {@code offset} is\n     * zero and the {@code max} is its size, in that the BoundedIterator\n     * should return all the same elements as its decorated iterator.\n     */\n    @Test\n    public void testSameAsDecorated() {\n        final Iterator<E> iter = new BoundedIterator<>(testList.iterator(), 0,\n                                                  testList.size());\n\n        assertTrue(iter.hasNext());\n        assertEquals(\"a\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"b\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"c\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"d\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"e\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"f\", iter.next());\n        assertTrue(iter.hasNext());\n        assertEquals(\"g\", iter.next());\n\n        assertFalse(iter.hasNext());\n\n        assertThrows(NoSuchElementException.class, () -> iter.next());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final String[] testArray = {\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\n    };", "docstring": " Test array of size 7", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "testArray = {\n        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\n    }", "syntax_pass": true}, {"attribute_expression": "private List<E> testList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<E>", "name": "testList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_removeTest.java.SingletonListIterator_removeTest", "name": "SingletonListIterator_removeTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_removeTest.java", "superclasses": "", "methods": ["[void]testRemoveSuccess()", "[void]testRemoveWithoutNextCall()", "[void]testRemoveTwice()", "[void]testRemoveAfterReset()", "[void]testRemoveAfterSet()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_removeTest.java.SingletonListIterator_removeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonListIterator_removeTest {\n\n    private static final Object testValue = new Object();\n    private SingletonListIterator<Object> iterator;\n\n    @BeforeEach\n    public void setUp() {\n        iterator = new SingletonListIterator<>(testValue);\n    }\n\n    @Test\n    public void testRemoveSuccess() {\n        iterator.next();\n        iterator.remove();\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    public void testRemoveWithoutNextCall() {\n        assertThrows(IllegalStateException.class, () -> {\n            iterator.remove();\n        });\n    }\n\n    @Test\n    public void testRemoveTwice() {\n        iterator.next();\n        iterator.remove();\n        assertThrows(IllegalStateException.class, () -> {\n            iterator.remove();\n        });\n    }\n\n    @Test\n    public void testRemoveAfterReset() {\n        iterator.next();\n        iterator.reset();\n        assertThrows(IllegalStateException.class, () -> {\n            iterator.remove();\n        });\n    }\n\n    @Test\n    public void testRemoveAfterSet() {\n        iterator.next();\n        iterator.set(new Object());\n        iterator.remove();\n        assertFalse(iterator.hasNext());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object testValue = new Object();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "testValue = new Object()", "syntax_pass": true}, {"attribute_expression": "private SingletonListIterator<Object> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SingletonListIterator<Object>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_resetTest.java.SingletonListIterator_resetTest", "name": "SingletonListIterator_resetTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_resetTest.java", "superclasses": "", "methods": ["[void]testResetAfterInitialization()", "[void]testResetAfterNextCall()", "[void]testResetAfterRemove()", "[void]testResetAfterSet()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/SingletonListIterator_resetTest.java.SingletonListIterator_resetTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SingletonListIterator_resetTest {\n    private static final Object testValue = new Object();\n    private SingletonListIterator<Object> iterator;\n\n    @BeforeEach\n    public void setUp() {\n        iterator = new SingletonListIterator<>(testValue);\n    }\n\n    @Test\n    public void testResetAfterInitialization() {\n        iterator.reset();\n        assertTrue(iterator.hasNext(), \"Iterator should have next item after reset\");\n        assertFalse(iterator.hasPrevious(), \"Iterator should have no previous item after reset\");\n        assertEquals(0, iterator.nextIndex(), \"Iteration next index after reset\");\n        assertEquals(-1, iterator.previousIndex(), \"Iteration previous index after reset\");\n    }\n\n    @Test\n    public void testResetAfterNextCall() {\n        iterator.next();\n        iterator.reset();\n        assertTrue(iterator.hasNext(), \"Iterator should have next item after reset\");\n        assertFalse(iterator.hasPrevious(), \"Iterator should have no previous item after reset\");\n        assertEquals(0, iterator.nextIndex(), \"Iteration next index after reset\");\n        assertEquals(-1, iterator.previousIndex(), \"Iteration previous index after reset\");\n    }\n\n    @Test\n    public void testResetAfterRemove() {\n        iterator.next();\n        iterator.remove();\n        iterator = new SingletonListIterator<>(testValue); // Reset the iterator to its initial state\n        assertTrue(iterator.hasNext(), \"Iterator should have next item after reset\");\n        assertFalse(iterator.hasPrevious(), \"Iterator should have no previous item after reset\");\n        assertEquals(0, iterator.nextIndex(), \"Iteration next index after reset\");\n        assertEquals(-1, iterator.previousIndex(), \"Iteration previous index after reset\");\n    }\n\n    @Test\n    public void testResetAfterSet() {\n        iterator.next();\n        iterator.set(new Object());\n        iterator.reset();\n        assertTrue(iterator.hasNext(), \"Iterator should have next item after reset\");\n        assertFalse(iterator.hasPrevious(), \"Iterator should have no previous item after reset\");\n        assertEquals(0, iterator.nextIndex(), \"Iteration next index after reset\");\n        assertEquals(-1, iterator.previousIndex(), \"Iteration previous index after reset\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Object testValue = new Object();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "testValue = new Object()", "syntax_pass": true}, {"attribute_expression": "private SingletonListIterator<Object> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SingletonListIterator<Object>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/PeekingIteratorTest.java.PeekingIteratorTest", "name": "PeekingIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/PeekingIteratorTest.java", "superclasses": "", "methods": ["[void]testEmpty()", "[void]testIllegalRemove()", "[void]testIteratorExhausted()", "[void]testMultiplePeek()", "[void]testSinglePeek()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/PeekingIteratorTest.java.PeekingIteratorTest.[]PeekingIteratorTest()", "src/test/java/org/apache/commons/collections4/iterators/PeekingIteratorTest.java.PeekingIteratorTest.[Iterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/PeekingIteratorTest.java.PeekingIteratorTest.[PeekingIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/PeekingIteratorTest.java.PeekingIteratorTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/PeekingIteratorTest.java.PeekingIteratorTest.[boolean]supportsRemove()", "src/test/java/org/apache/commons/collections4/iterators/PeekingIteratorTest.java.PeekingIteratorTest.[void]validate(Iterator<E>)"], "overrides": null, "attributes": [], "class_docstring": "\nTests the PeekingIterator.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class PeekingIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    private final String[] testArray = { \"a\", \"b\", \"c\" };\n\n    private List<E> testList;\n\n    public PeekingIteratorTest() {\n        super(PeekingIteratorTest.class.getSimpleName());\n    }\n\n    @Override\n    public Iterator<E> makeEmptyIterator() {\n        return PeekingIterator.peekingIterator(Collections.<E>emptyList().iterator());\n    }\n\n    @Override\n    public PeekingIterator<E> makeObject() {\n        return PeekingIterator.peekingIterator(testList.iterator());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @BeforeEach\n    protected void setUp() throws Exception {\n        testList = new ArrayList<>(Arrays.asList((E[]) testArray));\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return true;\n    }\n\n    @Test\n    public void testEmpty() {\n        final Iterator<E> it = makeEmptyIterator();\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    public void testIllegalRemove() {\n        final PeekingIterator<E> it = makeObject();\n        it.next();\n        it.remove(); // supported\n\n        assertTrue(it.hasNext());\n        assertEquals(\"b\", it.peek());\n\n        assertThrows(IllegalStateException.class, () -> it.remove());\n    }\n\n    @Test\n    public void testIteratorExhausted() {\n        final PeekingIterator<E> it = makeObject();\n        it.next();\n        it.next();\n        it.next();\n        assertFalse(it.hasNext());\n        assertNull(it.peek());\n\n        assertThrows(NoSuchElementException.class, () -> it.element());\n    }\n\n    @Test\n    public void testMultiplePeek() {\n        final PeekingIterator<E> it = makeObject();\n        assertEquals(\"a\", it.peek());\n        assertEquals(\"a\", it.peek());\n        assertEquals(\"a\", it.next());\n        assertTrue(it.hasNext());\n        assertEquals(\"b\", it.peek());\n        assertEquals(\"b\", it.peek());\n        assertEquals(\"b\", it.next());\n        assertTrue(it.hasNext());\n        assertEquals(\"c\", it.peek());\n        assertEquals(\"c\", it.peek());\n        assertEquals(\"c\", it.next());\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSinglePeek() {\n        final PeekingIterator<E> it = makeObject();\n        assertEquals(\"a\", it.peek());\n        assertEquals(\"a\", it.element());\n        validate(it, (E[]) testArray);\n    }\n\n    private void validate(final Iterator<E> iter, final E... items) {\n        for (final E x : items) {\n            assertTrue(iter.hasNext());\n            assertEquals(x, iter.next());\n        }\n        assertFalse(iter.hasNext());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final String[] testArray = { \"a\", \"b\", \"c\" };", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "testArray = { \"a\", \"b\", \"c\" }", "syntax_pass": true}, {"attribute_expression": "private List<E> testList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<E>", "name": "testList", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/FilterIterator_nextTest.java.FilterIterator_nextTest", "name": "FilterIterator_nextTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/FilterIterator_nextTest.java", "superclasses": "", "methods": ["[void]testNextWithValidElement()", "[void]testNextWithNoSuchElementException()", "[void]testNextAfterHasNext()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/FilterIterator_nextTest.java.FilterIterator_nextTest.[void]setUp()", "src/test/java/org/apache/commons/collections4/iterators/FilterIterator_nextTest.java.FilterIterator_nextTest.[void]initIterator()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FilterIterator_nextTest {\n\n    private FilterIterator<String> iterator;\n    private String[] array;\n\n    @BeforeEach\n    public void setUp() {\n        array = new String[] { \"a\", \"b\", \"c\" };\n        initIterator();\n    }\n\n    private void initIterator() {\n        List<String> list = new ArrayList<>(Arrays.asList(array));\n        iterator = new FilterIterator<>(list.iterator(), truePredicate());\n    }\n\n    @Test\n    public void testNextWithValidElement() {\n        assertTrue(iterator.hasNext());\n        assertEquals(\"a\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"b\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"c\", iterator.next());\n    }\n\n    @Test\n    public void testNextWithNoSuchElementException() {\n        iterator = new FilterIterator<>(Collections.emptyIterator(), truePredicate());\n        assertThrows(NoSuchElementException.class, () -> iterator.next());\n    }\n\n    @Test\n    public void testNextAfterHasNext() {\n        assertTrue(iterator.hasNext());\n        assertEquals(\"a\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"b\", iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(\"c\", iterator.next());\n        assertFalse(iterator.hasNext());\n        assertThrows(NoSuchElementException.class, () -> iterator.next());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private FilterIterator<String> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FilterIterator<String>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private String[] array;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String[]", "name": "array", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/properties/SortedPropertiesTest.java.SortedPropertiesTest", "name": "SortedPropertiesTest", "file_path": "src/test/java/org/apache/commons/collections4/properties/SortedPropertiesTest.java", "superclasses": "", "methods": ["[void]testEntrySet()", "[void]testKeys()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SortedPropertiesTest {\n\n    @Test\n    public void testEntrySet() {\n        final SortedProperties sortedProperties = new SortedProperties();\n        for (char ch = 'Z'; ch >= 'A'; ch--) {\n            sortedProperties.put(String.valueOf(ch), \"Value\" + ch);\n        }\n        final Iterator<Map.Entry<Object, Object>> entries = sortedProperties.entrySet().iterator();\n        for (char ch = 'A'; ch <= 'Z'; ch++) {\n            final Map.Entry<Object, Object> entry = entries.next();\n            assertEquals(String.valueOf(ch), entry.getKey());\n            assertEquals(\"Value\" + ch, entry.getValue());\n        }\n    }\n\n    @Test\n    public void testKeys() {\n        final SortedProperties sortedProperties = new SortedProperties();\n        for (char ch = 'Z'; ch >= 'A'; ch--) {\n            sortedProperties.put(String.valueOf(ch), \"Value\" + ch);\n        }\n        final Enumeration<Object> keys = sortedProperties.keys();\n        for (char ch = 'A'; ch <= 'Z'; ch++) {\n            assertEquals(String.valueOf(ch), keys.nextElement());\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/properties/OrderedPropertiesFactoryTest.java.OrderedPropertiesFactoryTest", "name": "OrderedPropertiesFactoryTest", "file_path": "src/test/java/org/apache/commons/collections4/properties/OrderedPropertiesFactoryTest.java", "superclasses": "", "methods": ["[void]testInstance()"], "method_uris": ["src/test/java/org/apache/commons/collections4/properties/OrderedPropertiesFactoryTest.java.OrderedPropertiesFactoryTest.[]OrderedPropertiesFactoryTest()"], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link OrderedPropertiesFactory}.\n", "original_string": "public class OrderedPropertiesFactoryTest extends AbstractPropertiesFactoryTest<OrderedProperties> {\n\n    public OrderedPropertiesFactoryTest() {\n        super(OrderedPropertiesFactory.INSTANCE);\n    }\n\n    @Test\n    @Override\n    public void testInstance() {\n        assertNotNull(OrderedPropertiesFactory.INSTANCE);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/properties/EmptyPropertiesTest.java.EmptyPropertiesTest", "name": "EmptyPropertiesTest", "file_path": "src/test/java/org/apache/commons/collections4/properties/EmptyPropertiesTest.java", "superclasses": "", "methods": ["[void]testClear()", "[void]testClone()", "[void]testCompute()", "[void]testComputeIfAbsent()", "[void]testComputeIfPresent()", "[void]testContains()", "[void]testContainsKey()", "[void]testContainsValue()", "[void]testElements()", "[void]testEntrySet()", "[void]testEquals()", "[void]testForEach()", "[void]testGet()", "[void]testGetOrDefault()", "[void]testGetProperty()", "[void]testGetPropertyDefault()", "[void]testHashCode()", "[void]testIsEmpty()", "[void]testKeys()", "[void]testKeySet()", "[void]testListToPrintStream()", "[void]testListToPrintWriter()", "[void]testLoadFromXML()", "[void]testLoadInputStream()", "[void]testLoadReader()", "[void]testMerge()", "[void]testPropertyName()", "[void]testPut()", "[void]testPutAll()", "[void]testPutIfAbsent()", "[void]testRehash()", "[void]testRemove()", "[void]testRemoveKey()", "[void]testReplace()", "[void]testReplaceAll()", "[void]testReplaceOldValue()", "[void]testSave()", "[void]testSetProperty()", "[void]testSize()", "[void]testStoreToOutputStream()", "[void]testStoreToPrintWriter()", "[void]testStoreToXMLOutputStream()", "[void]testStoreToXMLOutputStreamWithEncoding()", "[void]testStringPropertyName()", "[void]testToString()", "[void]testValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/properties/EmptyPropertiesTest.java.EmptyPropertiesTest.[String]getFirstLine(String)", "src/test/java/org/apache/commons/collections4/properties/EmptyPropertiesTest.java.EmptyPropertiesTest.[PrintStream]newPrintStream(ByteArrayOutputStream)", "src/test/java/org/apache/commons/collections4/properties/EmptyPropertiesTest.java.EmptyPropertiesTest.[String]removeLine2(ByteArrayOutputStream)", "src/test/java/org/apache/commons/collections4/properties/EmptyPropertiesTest.java.EmptyPropertiesTest.[String]removeLine2(String)", "src/test/java/org/apache/commons/collections4/properties/EmptyPropertiesTest.java.EmptyPropertiesTest.[String]toString(ByteArrayOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class EmptyPropertiesTest {\n\n    /**\n     * Returns the first line from multi-lined string separated by a line separator character\n     *\n     * @param x the multi-lined String\n     * @return the first line from x\n     */\n    private String getFirstLine(final String x) {\n        return x.split(\"\\\\R\", 2)[0];\n    }\n\n    private PrintStream newPrintStream(final ByteArrayOutputStream baos) throws UnsupportedEncodingException {\n        return new PrintStream(baos, true, StandardCharsets.UTF_8.name());\n    }\n\n    private String removeLine2(final ByteArrayOutputStream baos) {\n        return removeLine2(toString(baos));\n    }\n\n    private String removeLine2(final String x) {\n        final String[] s = x.split(\"\\\\R\", 2);\n        return s[0] + System.lineSeparator() + (s.length > 2 ? s[2] : StringUtils.EMPTY);\n    }\n\n    @Test\n    public void testClear() {\n        PropertiesFactory.EMPTY_PROPERTIES.clear();\n        assertEquals(0, PropertiesFactory.EMPTY_PROPERTIES.size());\n    }\n\n    @Test\n    public void testClone() {\n        // TODO Better test?\n        PropertiesFactory.EMPTY_PROPERTIES.clone();\n        assertEquals(0, PropertiesFactory.EMPTY_PROPERTIES.size());\n    }\n\n    @Test\n    public void testCompute() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.compute(\"key\", (k, v) -> \"foo\"));\n    }\n\n    @Test\n    public void testComputeIfAbsent() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.computeIfAbsent(\"key\", k -> \"foo\"));\n    }\n\n    @Test\n    public void testComputeIfPresent() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.computeIfPresent(\"key\", (k, v) -> \"foo\"));\n    }\n\n    @Test\n    public void testContains() {\n        assertFalse(PropertiesFactory.EMPTY_PROPERTIES.contains(\"foo\"));\n    }\n\n    @Test\n    public void testContainsKey() {\n        assertFalse(PropertiesFactory.EMPTY_PROPERTIES.containsKey(\"foo\"));\n    }\n\n    @Test\n    public void testContainsValue() {\n        assertFalse(PropertiesFactory.EMPTY_PROPERTIES.containsValue(\"foo\"));\n    }\n\n    @Test\n    public void testElements() {\n        assertFalse(PropertiesFactory.EMPTY_PROPERTIES.elements().hasMoreElements());\n    }\n\n    @Test\n    public void testEntrySet() {\n        assertTrue(PropertiesFactory.EMPTY_PROPERTIES.entrySet().isEmpty());\n    }\n\n    @Test\n    public void testEquals() {\n        assertEquals(PropertiesFactory.EMPTY_PROPERTIES, PropertiesFactory.EMPTY_PROPERTIES);\n        assertEquals(PropertiesFactory.EMPTY_PROPERTIES, new Properties());\n        assertEquals(new Properties(), PropertiesFactory.EMPTY_PROPERTIES);\n        assertNotEquals(null, PropertiesFactory.EMPTY_PROPERTIES);\n        final Properties p = new Properties();\n        p.put(\"Key\", \"Value\");\n        assertNotEquals(PropertiesFactory.EMPTY_PROPERTIES, p);\n        assertNotEquals(p, PropertiesFactory.EMPTY_PROPERTIES);\n    }\n\n    @Test\n    public void testForEach() {\n        PropertiesFactory.EMPTY_PROPERTIES.forEach((k, v) -> fail());\n    }\n\n    @Test\n    public void testGet() {\n        assertNull(PropertiesFactory.EMPTY_PROPERTIES.get(\"foo\"));\n    }\n\n    @Test\n    public void testGetOrDefault() {\n        assertEquals(\"bar\", PropertiesFactory.EMPTY_PROPERTIES.getOrDefault(\"foo\", \"bar\"));\n    }\n\n    @Test\n    public void testGetProperty() {\n        assertNull(PropertiesFactory.EMPTY_PROPERTIES.getProperty(\"foo\"));\n    }\n\n    @Test\n    public void testGetPropertyDefault() {\n        assertEquals(\"bar\", PropertiesFactory.EMPTY_PROPERTIES.getProperty(\"foo\", \"bar\"));\n    }\n\n    @Test\n    public void testHashCode() {\n        assertEquals(PropertiesFactory.EMPTY_PROPERTIES.hashCode(), PropertiesFactory.EMPTY_PROPERTIES.hashCode());\n        // Should be equals?\n        // assertEquals(PropertiesFactory.EMPTY_PROPERTIES.hashCode(), new Properties().hashCode());\n    }\n\n    @Test\n    public void testIsEmpty() {\n        assertTrue(PropertiesFactory.EMPTY_PROPERTIES.isEmpty());\n    }\n\n    @Test\n    public void testKeys() {\n        assertFalse(PropertiesFactory.EMPTY_PROPERTIES.keys().hasMoreElements());\n    }\n\n    @Test\n    public void testKeySet() {\n        assertTrue(PropertiesFactory.EMPTY_PROPERTIES.isEmpty());\n    }\n\n    @Test\n    public void testListToPrintStream() {\n        // actual\n        final ByteArrayOutputStream actual = new ByteArrayOutputStream();\n        PropertiesFactory.EMPTY_PROPERTIES.list(new PrintStream(actual));\n        // expected\n        final ByteArrayOutputStream expected = new ByteArrayOutputStream();\n        PropertiesFactory.INSTANCE.createProperties().list(new PrintStream(expected));\n        assertArrayEquals(expected.toByteArray(), actual.toByteArray());\n        expected.reset();\n        new Properties().list(new PrintStream(expected));\n        assertArrayEquals(expected.toByteArray(), actual.toByteArray());\n    }\n\n    @Test\n    public void testListToPrintWriter() {\n        // actual\n        final ByteArrayOutputStream actual = new ByteArrayOutputStream();\n        PropertiesFactory.EMPTY_PROPERTIES.list(new PrintWriter(actual));\n        // expected\n        final ByteArrayOutputStream expected = new ByteArrayOutputStream();\n        PropertiesFactory.INSTANCE.createProperties().list(new PrintWriter(expected));\n        assertArrayEquals(expected.toByteArray(), actual.toByteArray());\n        expected.reset();\n        new Properties().list(new PrintWriter(expected));\n        assertArrayEquals(expected.toByteArray(), actual.toByteArray());\n    }\n\n    @Test\n    public void testLoadFromXML() {\n        assertThrows(UnsupportedOperationException.class,\n            () -> PropertiesFactory.EMPTY_PROPERTIES.loadFromXML(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY)));\n    }\n\n    @Test\n    public void testLoadInputStream() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.load(new ByteArrayInputStream(ArrayUtils.EMPTY_BYTE_ARRAY)));\n    }\n\n    @Test\n    public void testLoadReader() throws IOException {\n        try (NullReader reader = new NullReader(0)) {\n            assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.load(reader));\n        }\n    }\n\n    @Test\n    public void testMerge() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.merge(\"key\", \"value\", (k, v) -> \"foo\"));\n    }\n\n    @Test\n    public void testPropertyName() {\n        assertFalse(PropertiesFactory.EMPTY_PROPERTIES.propertyNames().hasMoreElements());\n    }\n\n    @Test\n    public void testPut() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.put(\"Key\", \"Value\"));\n    }\n\n    @Test\n    public void testPutAll() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.putAll(new HashMap<>()));\n    }\n\n    @Test\n    public void testPutIfAbsent() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.putIfAbsent(\"Key\", \"Value\"));\n    }\n\n    @Test\n    public void testRehash() {\n        // Can't really test without extending and casting to a currently private class\n        // PropertiesFactory.EMPTY_PROPERTIES.rehash();\n    }\n\n    @Test\n    public void testRemove() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.remove(\"key\", \"value\"));\n    }\n\n    @Test\n    public void testRemoveKey() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.remove(\"key\"));\n    }\n\n    @Test\n    public void testReplace() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.replace(\"key\", \"value1\"));\n    }\n\n    @Test\n    public void testReplaceAll() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.replaceAll((k, v) -> \"value1\"));\n    }\n\n    @Test\n    public void testReplaceOldValue() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.replace(\"key\", \"value1\", \"value2\"));\n    }\n\n    @Test\n    public void testSave() throws IOException {\n        final String comments = \"Hello world!\";\n        try (ByteArrayOutputStream actual = new ByteArrayOutputStream(); ByteArrayOutputStream expected = new ByteArrayOutputStream()) {\n            // actual\n            PropertiesFactory.EMPTY_PROPERTIES.store(actual, comments);\n            // expected\n            PropertiesFactory.INSTANCE.createProperties().store(expected, comments);\n\n            // Properties.store stores the specified comment appended with current time stamp in the next line\n            final String expectedComment = getFirstLine(expected.toString(StandardCharsets.UTF_8.name()));\n            final String actualComment = getFirstLine(actual.toString(StandardCharsets.UTF_8.name()));\n            assertEquals(expectedComment, actualComment,\n                () -> String.format(\"Expected String '%s' with length '%s'\", expectedComment, expectedComment.length()));\n            expected.reset();\n            try (PrintStream out = new PrintStream(expected)) {\n                new Properties().store(out, comments);\n            }\n            final String[] expectedLines = expected.toString(StandardCharsets.UTF_8.displayName()).split(\"\\\\n\");\n            final String[] actualLines = actual.toString(StandardCharsets.UTF_8.displayName()).split(\"\\\\n\");\n            assertEquals(expectedLines.length, actualLines.length);\n            // The assertion below checks that the comment is the same in both files\n            assertEquals(expectedLines[0], actualLines[0]);\n            // N.B.: We must not expect expectedLines[1] and actualLines[1] to have the same value as\n            // it contains the timestamp of when the data was written to the stream, which makes\n            // this test brittle, causing intermitent failures, see COLLECTIONS-812\n        }\n    }\n\n    @Test\n    public void testSetProperty() {\n        assertThrows(UnsupportedOperationException.class, () -> PropertiesFactory.EMPTY_PROPERTIES.setProperty(\"Key\", \"Value\"));\n    }\n\n    @Test\n    public void testSize() {\n        assertEquals(0, PropertiesFactory.EMPTY_PROPERTIES.size());\n    }\n\n    @Test\n    public void testStoreToOutputStream() throws IOException {\n        // Note: The second line is always a comment with a timestamp.\n        final String comments = \"Hello world!\";\n        // actual\n        final ByteArrayOutputStream actual = new ByteArrayOutputStream();\n        try (PrintStream ps = newPrintStream(actual)) {\n            PropertiesFactory.EMPTY_PROPERTIES.store(ps, comments);\n        }\n        // expected\n        final ByteArrayOutputStream expected = new ByteArrayOutputStream();\n        try (PrintStream ps = newPrintStream(expected)) {\n            PropertiesFactory.INSTANCE.createProperties().store(ps, comments);\n        }\n        assertEquals(removeLine2(expected), removeLine2(actual));\n        expected.reset();\n        try (PrintStream ps = newPrintStream(expected)) {\n            new Properties().store(ps, comments);\n        }\n        assertEquals(removeLine2(expected), removeLine2(actual), () -> removeLine2(actual));\n    }\n\n    @Test\n    public void testStoreToPrintWriter() throws IOException {\n        // Note: The second line is always a comment with a timestamp.\n        final String comments = \"Hello world!\";\n        // actual\n        final ByteArrayOutputStream actual = new ByteArrayOutputStream();\n        try (PrintStream ps = newPrintStream(actual)) {\n            PropertiesFactory.EMPTY_PROPERTIES.store(ps, comments);\n        }\n        // expected\n        final ByteArrayOutputStream expected = new ByteArrayOutputStream();\n        try (PrintStream ps = newPrintStream(expected)) {\n            PropertiesFactory.INSTANCE.createProperties().store(ps, comments);\n        }\n        assertEquals(removeLine2(expected), removeLine2(actual));\n        expected.reset();\n        try (PrintStream ps = newPrintStream(expected)) {\n            new Properties().store(ps, comments);\n        }\n        assertEquals(removeLine2(expected), removeLine2(actual));\n    }\n\n    @Test\n    public void testStoreToXMLOutputStream() throws IOException {\n        // Note: The second line is always a comment with a timestamp.\n        final String comments = \"Hello world!\";\n        // actual\n        final ByteArrayOutputStream actual = new ByteArrayOutputStream();\n        try (PrintStream ps = newPrintStream(actual)) {\n            PropertiesFactory.EMPTY_PROPERTIES.storeToXML(ps, comments);\n        }\n        // expected\n        final ByteArrayOutputStream expected = new ByteArrayOutputStream();\n        try (PrintStream ps = newPrintStream(expected)) {\n            PropertiesFactory.INSTANCE.createProperties().storeToXML(ps, comments);\n        }\n        assertEquals(toString(expected), toString(actual));\n        expected.reset();\n        try (PrintStream ps = new PrintStream(expected)) {\n            new Properties().storeToXML(ps, comments);\n        }\n        assertEquals(removeLine2(expected), removeLine2(actual));\n    }\n\n    @Test\n    public void testStoreToXMLOutputStreamWithEncoding() throws IOException {\n        // Note: The second line is always a comment with a timestamp.\n        final String comments = \"Hello world!\";\n        final String encoding = StandardCharsets.UTF_8.name();\n        // actual\n        final ByteArrayOutputStream actual = new ByteArrayOutputStream();\n        try (PrintStream ps = newPrintStream(actual)) {\n            PropertiesFactory.EMPTY_PROPERTIES.storeToXML(ps, comments, encoding);\n        }\n        // expected\n        final ByteArrayOutputStream expected = new ByteArrayOutputStream();\n        try (PrintStream ps = newPrintStream(expected)) {\n            PropertiesFactory.INSTANCE.createProperties().storeToXML(ps, comments, encoding);\n        }\n        assertEquals(removeLine2(expected), removeLine2(actual));\n        expected.reset();\n        try (PrintStream ps = newPrintStream(expected)) {\n            new Properties().storeToXML(ps, comments, encoding);\n        }\n        assertEquals(removeLine2(expected), removeLine2(actual));\n    }\n\n    @Test\n    public void testStringPropertyName() {\n        assertTrue(PropertiesFactory.EMPTY_PROPERTIES.stringPropertyNames().isEmpty());\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(new Properties().toString(), PropertiesFactory.EMPTY_PROPERTIES.toString());\n    }\n\n    @Test\n    public void testValues() {\n        assertTrue(PropertiesFactory.EMPTY_PROPERTIES.isEmpty());\n    }\n\n    private String toString(final ByteArrayOutputStream expected) {\n        return new String(expected.toByteArray(), StandardCharsets.UTF_8);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/properties/PropertiesFactoryTest.java.PropertiesFactoryTest", "name": "PropertiesFactoryTest", "file_path": "src/test/java/org/apache/commons/collections4/properties/PropertiesFactoryTest.java", "superclasses": "", "methods": ["[void]testInstance()"], "method_uris": ["src/test/java/org/apache/commons/collections4/properties/PropertiesFactoryTest.java.PropertiesFactoryTest.[]PropertiesFactoryTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PropertiesFactoryTest extends AbstractPropertiesFactoryTest<Properties> {\n\n    public PropertiesFactoryTest() {\n        super(PropertiesFactory.INSTANCE);\n    }\n\n    @Test\n    @Override\n    public void testInstance() {\n        assertNotNull(PropertiesFactory.INSTANCE);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/properties/OrderedPropertiesTest.java.OrderedPropertiesTest", "name": "OrderedPropertiesTest", "file_path": "src/test/java/org/apache/commons/collections4/properties/OrderedPropertiesTest.java", "superclasses": "", "methods": ["[void]testCompute()", "[void]testComputeIfAbsent()", "[void]testEntrySet()", "[void]testForEach()", "[void]testKeys()", "[void]testLoadOrderedKeys()", "[void]testLoadOrderedKeysReverse()", "[void]testMerge()", "[void]testPut()", "[void]testPutAll()", "[void]testPutIfAbsent()", "[void]testRemoveKey()", "[void]testRemoveKeyValue()", "[void]testToString()"], "method_uris": ["src/test/java/org/apache/commons/collections4/properties/OrderedPropertiesTest.java.OrderedPropertiesTest.[void]assertAscendingOrder(OrderedProperties)", "src/test/java/org/apache/commons/collections4/properties/OrderedPropertiesTest.java.OrderedPropertiesTest.[OrderedProperties]assertDescendingOrder(OrderedProperties)", "src/test/java/org/apache/commons/collections4/properties/OrderedPropertiesTest.java.OrderedPropertiesTest.[OrderedProperties]loadOrderedKeysReverse()"], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link OrderedProperties}.\n", "original_string": "public class OrderedPropertiesTest {\n\n    private void assertAscendingOrder(final OrderedProperties orderedProperties) {\n        final int first = 1;\n        final int last = 11;\n        final Enumeration<Object> enumObjects = orderedProperties.keys();\n        for (int i = first; i <= last; i++) {\n            assertEquals(\"key\" + i, enumObjects.nextElement());\n        }\n        final Iterator<Object> iterSet = orderedProperties.keySet().iterator();\n        for (int i = first; i <= last; i++) {\n            assertEquals(\"key\" + i, iterSet.next());\n        }\n        final Iterator<Entry<Object, Object>> iterEntrySet = orderedProperties.entrySet().iterator();\n        for (int i = first; i <= last; i++) {\n            final Entry<Object, Object> next = iterEntrySet.next();\n            assertEquals(\"key\" + i, next.getKey());\n            assertEquals(\"value\" + i, next.getValue());\n        }\n        final Enumeration<?> propertyNames = orderedProperties.propertyNames();\n        for (int i = first; i <= last; i++) {\n            assertEquals(\"key\" + i, propertyNames.nextElement());\n        }\n    }\n\n    private OrderedProperties assertDescendingOrder(final OrderedProperties orderedProperties) {\n        final int first = 11;\n        final int last = 1;\n        final Enumeration<Object> enumObjects = orderedProperties.keys();\n        for (int i = first; i <= last; i--) {\n            assertEquals(\"key\" + i, enumObjects.nextElement());\n        }\n        final Iterator<Object> iterSet = orderedProperties.keySet().iterator();\n        for (int i = first; i <= last; i--) {\n            assertEquals(\"key\" + i, iterSet.next());\n        }\n        final Iterator<Entry<Object, Object>> iterEntrySet = orderedProperties.entrySet().iterator();\n        for (int i = first; i <= last; i--) {\n            final Entry<Object, Object> next = iterEntrySet.next();\n            assertEquals(\"key\" + i, next.getKey());\n            assertEquals(\"value\" + i, next.getValue());\n        }\n        final Enumeration<?> propertyNames = orderedProperties.propertyNames();\n        for (int i = first; i <= last; i--) {\n            assertEquals(\"key\" + i, propertyNames.nextElement());\n        }\n        return orderedProperties;\n    }\n\n    private OrderedProperties loadOrderedKeysReverse() throws FileNotFoundException, IOException {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        try (FileReader reader = new FileReader(\"src/test/resources/org/apache/commons/collections4/properties/test-reverse.properties\")) {\n            orderedProperties.load(reader);\n        }\n        return assertDescendingOrder(orderedProperties);\n    }\n\n    @Test\n    public void testCompute() {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        int first = 1;\n        int last = 11;\n        for (int i = first; i <= last; i++) {\n            final AtomicInteger aInt = new AtomicInteger(i);\n            orderedProperties.compute(\"key\" + i, (k, v) -> \"value\" + aInt.get());\n        }\n        assertAscendingOrder(orderedProperties);\n        orderedProperties.clear();\n        first = 11;\n        last = 1;\n        for (int i = first; i >= last; i--) {\n            final AtomicInteger aInt = new AtomicInteger(i);\n            orderedProperties.compute(\"key\" + i, (k, v) -> \"value\" + aInt.get());\n        }\n        assertDescendingOrder(orderedProperties);\n    }\n\n    @Test\n    public void testComputeIfAbsent() {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        int first = 1;\n        int last = 11;\n        for (int i = first; i <= last; i++) {\n            final AtomicInteger aInt = new AtomicInteger(i);\n            orderedProperties.computeIfAbsent(\"key\" + i, k -> \"value\" + aInt.get());\n        }\n        assertAscendingOrder(orderedProperties);\n        orderedProperties.clear();\n        first = 11;\n        last = 1;\n        for (int i = first; i >= last; i--) {\n            final AtomicInteger aInt = new AtomicInteger(i);\n            orderedProperties.computeIfAbsent(\"key\" + i, k -> \"value\" + aInt.get());\n        }\n        assertDescendingOrder(orderedProperties);\n    }\n\n    @Test\n    public void testEntrySet() {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        final char first = 'Z';\n        final char last = 'A';\n        for (char ch = first; ch >= last; ch--) {\n            orderedProperties.put(String.valueOf(ch), \"Value\" + ch);\n        }\n        final Iterator<Map.Entry<Object, Object>> entries = orderedProperties.entrySet().iterator();\n        for (char ch = first; ch <= last; ch++) {\n            final Map.Entry<Object, Object> entry = entries.next();\n            assertEquals(String.valueOf(ch), entry.getKey());\n            assertEquals(\"Value\" + ch, entry.getValue());\n        }\n    }\n\n    @Test\n    public void testForEach() {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        final char first = 'Z';\n        final char last = 'A';\n        for (char ch = first; ch >= last; ch--) {\n            orderedProperties.put(String.valueOf(ch), \"Value\" + ch);\n        }\n        final AtomicInteger aCh = new AtomicInteger(first);\n        orderedProperties.forEach((k, v) -> {\n            final char ch = (char) aCh.getAndDecrement();\n            assertEquals(String.valueOf(ch), k);\n            assertEquals(\"Value\" + ch, v);\n        });\n    }\n\n    @Test\n    public void testKeys() {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        final char first = 'Z';\n        final char last = 'A';\n        for (char ch = first; ch >= last; ch--) {\n            orderedProperties.put(String.valueOf(ch), \"Value\" + ch);\n        }\n        final Enumeration<Object> keys = orderedProperties.keys();\n        for (char ch = first; ch <= last; ch++) {\n            assertEquals(String.valueOf(ch), keys.nextElement());\n        }\n    }\n\n    @Test\n    public void testLoadOrderedKeys() throws IOException {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        try (FileReader reader = new FileReader(\"src/test/resources/org/apache/commons/collections4/properties/test.properties\")) {\n            orderedProperties.load(reader);\n        }\n        assertAscendingOrder(orderedProperties);\n    }\n\n    @Test\n    public void testLoadOrderedKeysReverse() throws IOException {\n        loadOrderedKeysReverse();\n    }\n\n    @Test\n    public void testMerge() {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        int first = 1;\n        int last = 11;\n        for (int i = first; i <= last; i++) {\n            orderedProperties.merge(\"key\" + i, \"value\" + i, (k, v) -> v);\n        }\n        assertAscendingOrder(orderedProperties);\n        orderedProperties.clear();\n        first = 11;\n        last = 1;\n        for (int i = first; i >= last; i--) {\n            orderedProperties.merge(\"key\" + i, \"value\" + i, (k, v) -> v);\n        }\n        assertDescendingOrder(orderedProperties);\n    }\n\n    @Test\n    public void testPut() {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        int first = 1;\n        int last = 11;\n        for (int i = first; i <= last; i++) {\n            orderedProperties.put(\"key\" + i, \"value\" + i);\n        }\n        assertAscendingOrder(orderedProperties);\n        orderedProperties.clear();\n        first = 11;\n        last = 1;\n        for (int i = first; i >= last; i--) {\n            orderedProperties.put(\"key\" + i, \"value\" + i);\n        }\n        assertDescendingOrder(orderedProperties);\n    }\n\n    @Test\n    public void testPutAll() {\n        final OrderedProperties sourceProperties = new OrderedProperties();\n        int first = 1;\n        int last = 11;\n        for (int i = first; i <= last; i++) {\n            sourceProperties.put(\"key\" + i, \"value\" + i);\n        }\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        orderedProperties.putAll(sourceProperties);\n        assertAscendingOrder(orderedProperties);\n        orderedProperties.clear();\n        first = 11;\n        last = 1;\n        for (int i = first; i >= last; i--) {\n            orderedProperties.put(\"key\" + i, \"value\" + i);\n        }\n        assertDescendingOrder(orderedProperties);\n    }\n\n    @Test\n    public void testPutIfAbsent() {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        int first = 1;\n        int last = 11;\n        for (int i = first; i <= last; i++) {\n            orderedProperties.putIfAbsent(\"key\" + i, \"value\" + i);\n        }\n        assertAscendingOrder(orderedProperties);\n        orderedProperties.clear();\n        first = 11;\n        last = 1;\n        for (int i = first; i >= last; i--) {\n            orderedProperties.putIfAbsent(\"key\" + i, \"value\" + i);\n        }\n        assertDescendingOrder(orderedProperties);\n    }\n\n    @Test\n    public void testRemoveKey() throws FileNotFoundException, IOException {\n        final OrderedProperties props = loadOrderedKeysReverse();\n        final String k = \"key1\";\n        props.remove(k);\n        assertFalse(props.contains(k));\n        assertFalse(props.containsKey(k));\n        assertFalse(Collections.list(props.keys()).contains(k));\n        assertFalse(Collections.list(props.propertyNames()).contains(k));\n    }\n\n    @Test\n    public void testRemoveKeyValue() throws FileNotFoundException, IOException {\n        final OrderedProperties props = loadOrderedKeysReverse();\n        final String k = \"key1\";\n        props.remove(k, \"value1\");\n        assertFalse(props.contains(k));\n        assertFalse(props.containsKey(k));\n        assertFalse(Collections.list(props.keys()).contains(k));\n        assertFalse(Collections.list(props.propertyNames()).contains(k));\n    }\n\n    @Test\n    public void testToString() {\n        final OrderedProperties orderedProperties = new OrderedProperties();\n        final char first = 'Z';\n        final char last = 'A';\n        for (char ch = first; ch >= last; ch--) {\n            orderedProperties.put(String.valueOf(ch), \"Value\" + ch);\n        }\n        assertEquals(\n                \"{Z=ValueZ, Y=ValueY, X=ValueX, W=ValueW, V=ValueV, U=ValueU, T=ValueT, S=ValueS, R=ValueR, Q=ValueQ, P=ValueP, O=ValueO, N=ValueN, M=ValueM, L=ValueL, K=ValueK, J=ValueJ, I=ValueI, H=ValueH, G=ValueG, F=ValueF, E=ValueE, D=ValueD, C=ValueC, B=ValueB, A=ValueA}\",\n                orderedProperties.toString());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/properties/SortedPropertiesFactoryTest.java.SortedPropertiesFactoryTest", "name": "SortedPropertiesFactoryTest", "file_path": "src/test/java/org/apache/commons/collections4/properties/SortedPropertiesFactoryTest.java", "superclasses": "", "methods": ["[void]testInstance()"], "method_uris": ["src/test/java/org/apache/commons/collections4/properties/SortedPropertiesFactoryTest.java.SortedPropertiesFactoryTest.[]SortedPropertiesFactoryTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SortedPropertiesFactoryTest extends AbstractPropertiesFactoryTest<SortedProperties> {\n\n    public SortedPropertiesFactoryTest() {\n        super(SortedPropertiesFactory.INSTANCE);\n    }\n\n    @Test\n    @Override\n    public void testInstance() {\n        assertNotNull(SortedPropertiesFactory.INSTANCE);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest", "name": "UnmodifiableOrderedBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[]UnmodifiableOrderedBidiMapTest()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[boolean]isAllowNullValue()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[boolean]isPutChangeSupported()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[Map<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[OrderedBidiMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java.UnmodifiableOrderedBidiMapTest.[OrderedBidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class UnmodifiableOrderedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {\n\n    public UnmodifiableOrderedBidiMapTest() {\n        super(UnmodifiableOrderedBidiMapTest.class.getSimpleName());\n    }\n\n    /**\n     * Override to prevent infinite recursion of tests.\n     */\n    @Override\n    public String[] ignoredTests() {\n        return new String[] {\"UnmodifiableOrderedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public boolean isAllowNullValue() {\n        return false;\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isPutChangeSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public Map<K, V> makeConfirmedMap() {\n        return new TreeMap<>();\n    }\n\n    @Override\n    public OrderedBidiMap<K, V> makeFullMap() {\n        final OrderedBidiMap<K, V> bidi = new TreeBidiMap<>();\n        addSampleMappings(bidi);\n        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(bidi);\n    }\n\n    @Override\n    public OrderedBidiMap<K, V> makeObject() {\n        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(new TreeBidiMap<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final OrderedBidiMap<K, V> map = makeFullMap();\n        assertSame(map, UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(map));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullMap() instanceof Unmodifiable);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java.DualTreeBidiMap2Test", "name": "DualTreeBidiMap2Test", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java", "superclasses": "", "methods": ["[void]testCollections364()", "[void]testComparator()", "[void]testComparator2()", "[void]testSerializeDeserializeCheckComparator()", "[void]testSortOrder()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java.DualTreeBidiMap2Test.[]DualTreeBidiMap2Test()", "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java.DualTreeBidiMap2Test.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java.DualTreeBidiMap2Test.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java.DualTreeBidiMap2Test.[TreeMap<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java.DualTreeBidiMap2Test.[DualTreeBidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    private static final class IntegerComparator implements Comparator<Integer>, Serializable {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public int compare(final Integer o1, final Integer o2) {\n            return o1.compareTo(o2);\n        }\n    }", "definition": "    private static final class IntegerComparator implements Comparator<Integer>, Serializable", "class_docstring": "", "name": "IntegerComparator", "super_interfaces": ["Comparator<Integer>", "Serializable"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public int compare(final Integer o1, final Integer o2) {\n            return o1.compareTo(o2);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "o1", "type": "Integer"}, {"name": "o2", "type": "Integer"}], "body": "                                                               {\n            return o1.compareTo(o2);\n        }", "signature": "@Override\n        public int compare(final Integer o1, final Integer o2)"}]}], "class_docstring": "\nJUnit tests.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class DualTreeBidiMap2Test<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {\n\n    private static final class IntegerComparator implements Comparator<Integer>, Serializable {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public int compare(final Integer o1, final Integer o2) {\n            return o1.compareTo(o2);\n        }\n    }\n\n    public DualTreeBidiMap2Test() {\n        super(DualTreeBidiMap2Test.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.Test2\";\n    }\n\n    /**\n     * Override to prevent infinite recursion of tests.\n     */\n    @Override\n    public String[] ignoredTests() {\n        final String recursiveTest = \"DualTreeBidiMap2Test.bulkTestInverseMap.bulkTestInverseMap\";\n        return new String[] { recursiveTest };\n    }\n\n    @Override\n    public TreeMap<K, V> makeConfirmedMap() {\n        return new TreeMap<>(new ReverseComparator<>(ComparableComparator.<K>comparableComparator()));\n    }\n\n    @Override\n    public DualTreeBidiMap<K, V> makeObject() {\n        return new DualTreeBidiMap<>(\n                new ReverseComparator<>(ComparableComparator.<K>comparableComparator()),\n                new ReverseComparator<>(ComparableComparator.<V>comparableComparator()));\n    }\n\n    @Test\n    public void testCollections364() throws Exception {\n        final DualTreeBidiMap<String, Integer> original = new DualTreeBidiMap<>(\n                String.CASE_INSENSITIVE_ORDER, new IntegerComparator());\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n        out.writeObject(original);\n        out.close();\n\n        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n        @SuppressWarnings(\"unchecked\")\n        final DualTreeBidiMap<String, Integer> deserialized = (DualTreeBidiMap<String, Integer>) in.readObject();\n        in.close();\n\n        assertNotNull(original.comparator());\n        assertNotNull(deserialized.comparator());\n        assertEquals(original.comparator().getClass(), deserialized.comparator().getClass());\n        assertEquals(original.valueComparator().getClass(), deserialized.valueComparator().getClass());\n    }\n\n    @Test\n    public void testComparator() {\n        resetEmpty();\n        final SortedBidiMap<K, V> bidi = (SortedBidiMap<K, V>) map;\n        assertNotNull(bidi.comparator());\n        assertTrue(bidi.comparator() instanceof ReverseComparator);\n    }\n\n    @Test\n    public void testComparator2() {\n        final DualTreeBidiMap<String, Integer> dtbm = new DualTreeBidiMap<>(\n                String.CASE_INSENSITIVE_ORDER, null);\n        dtbm.put(\"two\", 0);\n        dtbm.put(\"one\", 1);\n        assertEquals(\"one\", dtbm.firstKey());\n        assertEquals(\"two\", dtbm.lastKey());\n\n    }\n\n    @Test\n    public void testSerializeDeserializeCheckComparator() throws Exception {\n        final SortedBidiMap<?, ?> obj = makeObject();\n        if (obj instanceof Serializable && isTestSerialization()) {\n            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            final ObjectOutputStream out = new ObjectOutputStream(buffer);\n            out.writeObject(obj);\n            out.close();\n\n            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n            final Object dest = in.readObject();\n            in.close();\n\n            final SortedBidiMap<?, ?> bidi = (SortedBidiMap<?, ?>) dest;\n            assertNotNull(obj.comparator());\n            assertNotNull(bidi.comparator());\n            assertTrue(bidi.comparator() instanceof ReverseComparator);\n        }\n    }\n\n    @Test\n    public void testSortOrder() throws Exception {\n        final SortedBidiMap<K, V> sm = makeFullMap();\n\n        // Sort by the comparator used in the makeEmptyBidiMap() method\n        List<K> newSortedKeys = getAsList(getSampleKeys());\n        newSortedKeys.sort(new ReverseComparator<>(ComparableComparator.<K>comparableComparator()));\n        newSortedKeys = Collections.unmodifiableList(newSortedKeys);\n\n        final Iterator<K> mapIter = sm.keySet().iterator();\n        for (final K expectedKey : newSortedKeys) {\n            final K mapKey = mapIter.next();\n            assertNotNull(expectedKey, \"key in sorted list may not be null\");\n            assertNotNull(mapKey, \"key in map may not be null\");\n            assertEquals(expectedKey, mapKey, \"key from sorted list and map must be equal\");\n        }\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualTreeBidiMap.emptyCollection.version4.Test2.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualTreeBidiMap.fullCollection.version4.Test2.obj\");\n//    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest", "name": "UnmodifiableBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest.[]UnmodifiableBidiMapTest()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest.[boolean]isPutChangeSupported()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest.[Map<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest.[BidiMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java.UnmodifiableBidiMapTest.[BidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class UnmodifiableBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n\n    public UnmodifiableBidiMapTest() {\n        super(UnmodifiableBidiMapTest.class.getSimpleName());\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return AbstractCollectionTest.UNORDERED;\n    }\n\n    /**\n     * Override to prevent infinite recursion of tests.\n     */\n    @Override\n    public String[] ignoredTests() {\n        return new String[] {\"UnmodifiableBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isPutChangeSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public Map<K, V> makeConfirmedMap() {\n        return new HashMap<>();\n    }\n\n    @Override\n    public BidiMap<K, V> makeFullMap() {\n        final BidiMap<K, V> bidi = new DualHashBidiMap<>();\n        addSampleMappings(bidi);\n        return UnmodifiableBidiMap.unmodifiableBidiMap(bidi);\n    }\n\n    @Override\n    public BidiMap<K, V> makeObject() {\n        return UnmodifiableBidiMap.unmodifiableBidiMap(new DualHashBidiMap<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final BidiMap<K, V> map = makeFullMap();\n        assertSame(map, UnmodifiableBidiMap.unmodifiableBidiMap(map));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableBidiMap.unmodifiableBidiMap(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullMap() instanceof Unmodifiable);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest", "name": "UnmodifiableSortedBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[]UnmodifiableSortedBidiMapTest()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[boolean]isAllowNullValue()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[boolean]isPutChangeSupported()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[boolean]isSubMapViewsSerializable()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[SortedMap<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[SortedBidiMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java.UnmodifiableSortedBidiMapTest.[SortedBidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class UnmodifiableSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {\n\n    public UnmodifiableSortedBidiMapTest() {\n        super(UnmodifiableSortedBidiMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String[] ignoredTests() {\n        // Override to prevent infinite recursion of tests.\n        return new String[] {\"UnmodifiableSortedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public boolean isAllowNullValue() {\n        return false;\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isPutChangeSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isSubMapViewsSerializable() {\n        // TreeMap sub map views have a bug in deserialization.\n        return false;\n    }\n\n    @Override\n    public SortedMap<K, V> makeConfirmedMap() {\n        return new TreeMap<>();\n    }\n\n    @Override\n    public SortedBidiMap<K, V> makeFullMap() {\n        final SortedBidiMap<K, V> bidi = new DualTreeBidiMap<>();\n        addSampleMappings(bidi);\n        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(bidi);\n    }\n\n    @Override\n    public SortedBidiMap<K, V> makeObject() {\n        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(new DualTreeBidiMap<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final SortedBidiMap<K, V> map = makeFullMap();\n        assertSame(map, UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(map));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullMap() instanceof Unmodifiable);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java.UnmodifiableSetTest", "name": "UnmodifiableSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java.UnmodifiableSetTest.[]UnmodifiableSetTest()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java.UnmodifiableSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java.UnmodifiableSetTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java.UnmodifiableSetTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java.UnmodifiableSetTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java.UnmodifiableSetTest.[Set<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java.UnmodifiableSetTest.[Set<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSetTest} for exercising the\n{@link UnmodifiableSet} implementation.\n", "original_string": "public class UnmodifiableSetTest<E> extends AbstractSetTest<E> {\n\n    public UnmodifiableSetTest() {\n        super(UnmodifiableSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public Set<E> makeFullCollection() {\n        final HashSet<E> set = new HashSet<>(Arrays.asList(getFullElements()));\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public Set<E> makeObject() {\n        return UnmodifiableSet.unmodifiableSet(new HashSet<>());\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final Set<E> set = makeFullCollection();\n        assertSame(set, UnmodifiableSet.unmodifiableSet(set));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableSet.unmodifiableSet(null));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullCollection() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableSet.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableSet.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/CompositeSetTest.java.CompositeSetTest", "name": "CompositeSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/CompositeSetTest.java", "superclasses": "", "methods": ["[void]testAddComposited()", "[void]testAddCompositedCollision()", "[void]testContains()", "[void]testContainsAll()", "[void]testFailedCollisionResolution()", "[void]testRemoveAll()", "[void]testRemoveComposited()", "[void]testRemoveUnderlying()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/CompositeSetTest.java.CompositeSetTest.[]CompositeSetTest()", "src/test/java/org/apache/commons/collections4/set/CompositeSetTest.java.CompositeSetTest.[Set<E>]buildOne()", "src/test/java/org/apache/commons/collections4/set/CompositeSetTest.java.CompositeSetTest.[Set<E>]buildTwo()", "src/test/java/org/apache/commons/collections4/set/CompositeSetTest.java.CompositeSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/CompositeSetTest.java.CompositeSetTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/set/CompositeSetTest.java.CompositeSetTest.[CompositeSet<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSetTest} for exercising the\n{@link CompositeSet} implementation.\n", "original_string": "public class CompositeSetTest<E> extends AbstractSetTest<E> {\n\n    public CompositeSetTest() {\n        super(CompositeSetTest.class.getSimpleName());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Set<E> buildOne() {\n        final HashSet<E> set = new HashSet<>();\n        set.add((E) \"1\");\n        set.add((E) \"2\");\n        return set;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Set<E> buildTwo() {\n        final HashSet<E> set = new HashSet<>();\n        set.add((E) \"3\");\n        set.add((E) \"4\");\n        return set;\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public CompositeSet<E> makeObject() {\n        final HashSet<E> contained = new HashSet<>();\n        final CompositeSet<E> set = new CompositeSet<>(contained);\n        set.setMutator( new EmptySetMutator<>(contained) );\n        return set;\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddComposited() {\n        final Set<E> one = buildOne();\n        final Set<E> two = buildTwo();\n        final CompositeSet<E> set = new CompositeSet<>();\n        set.addComposited(one, two);\n        set.addComposited((Set<E>) null);\n        set.addComposited((Set<E>[]) null);\n        set.addComposited(null, null);\n        set.addComposited(null, null, null);\n        final CompositeSet<E> set2 = new CompositeSet<>(buildOne());\n        set2.addComposited(buildTwo());\n        assertEquals(set, set2);\n        final HashSet<E> set3 = new HashSet<>();\n        set3.add((E) \"1\");\n        set3.add((E) \"2\");\n        set3.add((E) \"3\");\n        final HashSet<E> set4 = new HashSet<>();\n        set4.add((E) \"4\");\n        final CompositeSet<E> set5 = new CompositeSet<>(set3);\n        set5.addComposited(set4);\n        assertEquals(set, set5);\n        assertThrows(UnsupportedOperationException.class, () -> set.addComposited(set3),\n                \"Expecting UnsupportedOperationException.\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddCompositedCollision() {\n        final HashSet<E> set1 = new HashSet<>();\n        set1.add((E) \"1\");\n        set1.add((E) \"2\");\n        set1.add((E) \"3\");\n        final HashSet<E> set2 = new HashSet<>();\n        set2.add((E) \"4\");\n        final CompositeSet<E> set3 = new CompositeSet<>(set1);\n        assertThrows(UnsupportedOperationException.class, () -> set3.addComposited(set1, buildOne()),\n                \"Expecting UnsupportedOperationException.\");\n        assertThrows(UnsupportedOperationException.class, () -> set3.addComposited(set1, buildOne(), buildTwo()),\n                \"Expecting UnsupportedOperationException.\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testContains() {\n        final CompositeSet<E> set = new CompositeSet<>(buildOne(), buildTwo());\n        assertTrue(set.contains(\"1\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testContainsAll() {\n        final CompositeSet<E> set = new CompositeSet<>(buildOne(), buildTwo());\n        assertFalse(set.containsAll(null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFailedCollisionResolution() {\n        final Set<E> one = buildOne();\n        final Set<E> two = buildTwo();\n        final CompositeSet<E> set = new CompositeSet<>(one, two);\n        set.setMutator(new SetMutator<E>() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public boolean add(final CompositeSet<E> composite,\n                    final List<Set<E>> collections, final E obj) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public boolean addAll(final CompositeSet<E> composite,\n                    final List<Set<E>> collections, final Collection<? extends E> coll) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing,\n                final Set<E> added, final Collection<E> intersects) {\n                //noop\n            }\n        });\n\n        final HashSet<E> three = new HashSet<>();\n        three.add((E) \"1\");\n        assertThrows(IllegalArgumentException.class, () -> set.addComposited(three),\n                \"IllegalArgumentException should have been thrown\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveAll() {\n        final CompositeSet<E> set = new CompositeSet<>(buildOne(), buildTwo());\n        assertFalse(set.removeAll(null));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveComposited() {\n        final Set<E> one = buildOne();\n        final Set<E> two = buildTwo();\n        final CompositeSet<E> set = new CompositeSet<>(one, two);\n        set.remove(\"1\");\n        assertFalse(one.contains(\"1\"));\n\n        set.remove(\"3\");\n        assertFalse(one.contains(\"3\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveUnderlying() {\n        final Set<E> one = buildOne();\n        final Set<E> two = buildTwo();\n        final CompositeSet<E> set = new CompositeSet<>(one, two);\n        one.remove(\"1\");\n        assertFalse(set.contains(\"1\"));\n\n        two.remove(\"3\");\n        assertFalse(set.contains(\"3\"));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CompositeSet.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CompositeSet.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java.UnmodifiableNavigableSetTest", "name": "UnmodifiableNavigableSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java", "superclasses": "", "methods": ["[void]testComparator()", "[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java.UnmodifiableNavigableSetTest.[]UnmodifiableNavigableSetTest()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java.UnmodifiableNavigableSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java.UnmodifiableNavigableSetTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java.UnmodifiableNavigableSetTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java.UnmodifiableNavigableSetTest.[UnmodifiableNavigableSet<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java.UnmodifiableNavigableSetTest.[NavigableSet<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java.UnmodifiableNavigableSetTest.[void]setupSet()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java.UnmodifiableNavigableSetTest.[void]verifyUnmodifiable(Set<E>)"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractNavigableSetTest} for exercising the\n{@link UnmodifiableNavigableSet} implementation.\n", "original_string": "public class UnmodifiableNavigableSetTest<E> extends AbstractNavigableSetTest<E> {\n    protected UnmodifiableNavigableSet<E> set;\n    protected ArrayList<E> array;\n\n    public UnmodifiableNavigableSetTest() {\n        super(UnmodifiableNavigableSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.1\";\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public UnmodifiableNavigableSet<E> makeFullCollection() {\n        final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));\n        return (UnmodifiableNavigableSet<E>) UnmodifiableNavigableSet.unmodifiableNavigableSet(set);\n    }\n\n    @Override\n    public NavigableSet<E> makeObject() {\n        return UnmodifiableNavigableSet.unmodifiableNavigableSet(new TreeSet<>());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected void setupSet() {\n        set = makeFullCollection();\n        array = new ArrayList<>();\n        array.add((E) Integer.valueOf(1));\n    }\n\n    @Test\n    public void testComparator() {\n        setupSet();\n        final Comparator<? super E> c = set.comparator();\n        assertNull(c, \"natural order, so comparator should be null\");\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final NavigableSet<E> set = makeFullCollection();\n        assertSame(set, UnmodifiableNavigableSet.unmodifiableNavigableSet(set));\n        assertThrows(NullPointerException.class, () -> UnmodifiableNavigableSet.unmodifiableNavigableSet(null));\n    }\n\n    /**\n     * Verify that base set and subsets are not modifiable\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnmodifiable() {\n        setupSet();\n        verifyUnmodifiable(set);\n        verifyUnmodifiable(set.descendingSet());\n        verifyUnmodifiable(set.headSet((E) Integer.valueOf(1)));\n        verifyUnmodifiable(set.headSet((E) Integer.valueOf(1), true));\n        verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1)));\n        verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1), false));\n        verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), (E) Integer.valueOf(3)));\n        verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), false, (E) Integer.valueOf(3), false));\n        verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), true, (E) Integer.valueOf(3), true));\n    }\n\n    /**\n     * Verifies that a set is not modifiable\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void verifyUnmodifiable(final Set<E> set) {\n        assertThrows(UnsupportedOperationException.class, () -> set.add((E) \"value\"));\n        assertThrows(UnsupportedOperationException.class, () -> set.addAll(new TreeSet<>()));\n        assertThrows(UnsupportedOperationException.class, () -> set.clear());\n        assertThrows(UnsupportedOperationException.class, () -> set.iterator().remove());\n        assertThrows(UnsupportedOperationException.class, () -> set.remove(\"x\"));\n        assertThrows(UnsupportedOperationException.class, () -> set.removeAll(array));\n        assertThrows(UnsupportedOperationException.class, () -> set.removeIf(element -> true));\n        assertThrows(UnsupportedOperationException.class, () -> set.retainAll(array));\n\n        if (set instanceof NavigableSet) {\n            final NavigableSet<E> navigableSet = (NavigableSet<E>) set;\n            assertThrows(UnsupportedOperationException.class, () -> navigableSet.pollFirst());\n            assertThrows(UnsupportedOperationException.class, () -> navigableSet.pollLast());\n        }\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableNavigableSet.emptyCollection.version4.1.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableNavigableSet.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected UnmodifiableNavigableSet<E> set;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "UnmodifiableNavigableSet<E>", "name": "set", "syntax_pass": true}, {"attribute_expression": "protected ArrayList<E> array;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ArrayList<E>", "name": "array", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/set/TransformedNavigableSetTest.java.TransformedNavigableSetTest", "name": "TransformedNavigableSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/TransformedNavigableSetTest.java", "superclasses": "", "methods": ["[void]testTransformedSet()", "[void]testTransformedSet_decorateTransform()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/TransformedNavigableSetTest.java.TransformedNavigableSetTest.[]TransformedNavigableSetTest()", "src/test/java/org/apache/commons/collections4/set/TransformedNavigableSetTest.java.TransformedNavigableSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/TransformedNavigableSetTest.java.TransformedNavigableSetTest.[NavigableSet<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/TransformedNavigableSetTest.java.TransformedNavigableSetTest.[NavigableSet<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractNavigableSetTest} for exercising the\n{@link TransformedNavigableSet} implementation.\n", "original_string": "public class TransformedNavigableSetTest<E> extends AbstractNavigableSetTest<E> {\n\n    public TransformedNavigableSetTest() {\n        super(TransformedNavigableSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.1\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public NavigableSet<E> makeFullCollection() {\n        final NavigableSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));\n        return TransformedNavigableSet.transformingNavigableSet(set,\n                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public NavigableSet<E> makeObject() {\n        return TransformedNavigableSet.transformingNavigableSet(new TreeSet<>(),\n                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testTransformedSet() {\n        final NavigableSet<E> set = TransformedNavigableSet.transformingNavigableSet(new TreeSet<>(),\n                (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, set.size());\n        final E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n        for (int i = 0; i < els.length; i++) {\n            set.add(els[i]);\n            assertEquals(i + 1, set.size());\n            assertTrue(set.contains(Integer.valueOf((String) els[i])));\n        }\n\n        assertTrue(set.remove(Integer.valueOf((String) els[0])));\n    }\n\n    @Test\n    public void testTransformedSet_decorateTransform() {\n        final Set<Object> originalSet = new TreeSet<>();\n        final Object[] els = {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        Collections.addAll(originalSet, els);\n        final Set<?> set = TransformedSet.transformedSet(originalSet,\n                TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(els.length, set.size());\n        for (final Object el : els) {\n            assertTrue(set.contains(Integer.valueOf((String) el)));\n        }\n\n        assertTrue(set.remove(Integer.valueOf((String) els[0])));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedNavigableSet.emptyCollection.version4.1.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedNavigableSet.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java.UnmodifiableSortedSetTest", "name": "UnmodifiableSortedSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java", "superclasses": "", "methods": ["[void]testComparator()", "[void]testDecorateFactory()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java.UnmodifiableSortedSetTest.[]UnmodifiableSortedSetTest()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java.UnmodifiableSortedSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java.UnmodifiableSortedSetTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java.UnmodifiableSortedSetTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java.UnmodifiableSortedSetTest.[UnmodifiableSortedSet<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java.UnmodifiableSortedSetTest.[SortedSet<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java.UnmodifiableSortedSetTest.[void]setupSet()", "src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java.UnmodifiableSortedSetTest.[void]verifyUnmodifiable(Set<E>)"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSortedSetTest} for exercising the\n{@link UnmodifiableSortedSet} implementation.\n", "original_string": "public class UnmodifiableSortedSetTest<E> extends AbstractSortedSetTest<E> {\n    protected UnmodifiableSortedSet<E> set;\n    protected ArrayList<E> array;\n\n    public UnmodifiableSortedSetTest() {\n        super(UnmodifiableSortedSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public UnmodifiableSortedSet<E> makeFullCollection() {\n        final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));\n        return (UnmodifiableSortedSet<E>) UnmodifiableSortedSet.unmodifiableSortedSet(set);\n    }\n\n    @Override\n    public SortedSet<E> makeObject() {\n        return UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<>());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected void setupSet() {\n        set = makeFullCollection();\n        array = new ArrayList<>();\n        array.add((E) Integer.valueOf(1));\n    }\n\n    @Test\n    public void testComparator() {\n        setupSet();\n        final Comparator<? super E> c = set.comparator();\n        assertNull(c, \"natural order, so comparator should be null\");\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final SortedSet<E> set = makeFullCollection();\n        assertSame(set, UnmodifiableSortedSet.unmodifiableSortedSet(set));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableSortedSet.unmodifiableSortedSet(null));\n    }\n\n    /**\n     * Verify that base set and subsets are not modifiable\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnmodifiable() {\n        setupSet();\n        verifyUnmodifiable(set);\n        verifyUnmodifiable(set.headSet((E) Integer.valueOf(1)));\n        verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1)));\n        verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), (E) Integer.valueOf(3)));\n    }\n\n    /**\n     * Verifies that a set is not modifiable\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void verifyUnmodifiable(final Set<E> set) {\n        assertAll(\n                () -> assertThrows(UnsupportedOperationException.class, () -> set.add((E) \"value\"),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> set.addAll(new TreeSet<>()),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> set.clear(),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> set.remove(\"x\"),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> set.removeAll(array),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> set.retainAll(array),\n                        \"Expecting UnsupportedOperationException.\")\n        );\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableSortedSet.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableSortedSet.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected UnmodifiableSortedSet<E> set;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "UnmodifiableSortedSet<E>", "name": "set", "syntax_pass": true}, {"attribute_expression": "protected ArrayList<E> array;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ArrayList<E>", "name": "array", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/set/TransformedSortedSetTest.java.TransformedSortedSetTest", "name": "TransformedSortedSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/TransformedSortedSetTest.java", "superclasses": "", "methods": ["[void]testTransformedSet()", "[void]testTransformedSet_decorateTransform()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/TransformedSortedSetTest.java.TransformedSortedSetTest.[]TransformedSortedSetTest()", "src/test/java/org/apache/commons/collections4/set/TransformedSortedSetTest.java.TransformedSortedSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/TransformedSortedSetTest.java.TransformedSortedSetTest.[SortedSet<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/TransformedSortedSetTest.java.TransformedSortedSetTest.[SortedSet<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSortedSetTest} for exercising the {@link TransformedSortedSet}\nimplementation.\n", "original_string": "public class TransformedSortedSetTest<E> extends AbstractSortedSetTest<E> {\n\n    public TransformedSortedSetTest() {\n        super(TransformedSortedSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SortedSet<E> makeFullCollection() {\n        final SortedSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));\n        return TransformedSortedSet.transformingSortedSet(set, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SortedSet<E> makeObject() {\n        return TransformedSortedSet.transformingSortedSet(new TreeSet<>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testTransformedSet() {\n        final SortedSet<E> set = TransformedSortedSet.transformingSortedSet(new TreeSet<>(),\n                (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, set.size());\n        final E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n        for (int i = 0; i < els.length; i++) {\n            set.add(els[i]);\n            assertEquals(i + 1, set.size());\n            assertTrue(set.contains(Integer.valueOf((String) els[i])));\n        }\n\n        assertTrue(set.remove(Integer.valueOf((String) els[0])));\n    }\n\n    @Test\n    public void testTransformedSet_decorateTransform() {\n        final Set<Object> originalSet = new TreeSet<>();\n        final Object[] els = {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        Collections.addAll(originalSet, els);\n        final Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(els.length, set.size());\n        for (final Object el : els) {\n            assertTrue(set.contains(Integer.valueOf((String) el)));\n        }\n\n        assertTrue(set.remove(Integer.valueOf((String) els[0])));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedSortedSet.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedSortedSet.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java.PredicatedSetTest", "name": "PredicatedSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java", "superclasses": "", "methods": ["[void]testGetSet()", "[void]testIllegalAdd()", "[void]testIllegalAddAll()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java.PredicatedSetTest.[]PredicatedSetTest()", "src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java.PredicatedSetTest.[PredicatedSet<E>]decorateSet(Set<E>,Predicate<? super E>)", "src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java.PredicatedSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java.PredicatedSetTest.[E[]]getFullElements()", "src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java.PredicatedSetTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java.PredicatedSetTest.[PredicatedSet<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java.PredicatedSetTest.[PredicatedSet<E>]makeTestSet()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSetTest} for exercising the\n{@link PredicatedSet} implementation.\n", "original_string": "public class PredicatedSetTest<E> extends AbstractSetTest<E> {\n\n    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n\n    protected Predicate<E> testPredicate =\n        String.class::isInstance;\n\n    public PredicatedSetTest() {\n        super(PredicatedSetTest.class.getSimpleName());\n    }\n\n    protected PredicatedSet<E> decorateSet(final Set<E> set, final Predicate<? super E> predicate) {\n        return PredicatedSet.predicatedSet(set, predicate);\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E[] getFullElements() {\n        return (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public PredicatedSet<E> makeObject() {\n        return decorateSet(new HashSet<>(), truePredicate);\n    }\n\n    protected PredicatedSet<E> makeTestSet() {\n        return decorateSet(new HashSet<>(), testPredicate);\n    }\n\n    @Test\n    public void testGetSet() {\n        final PredicatedSet<E> set = makeTestSet();\n        assertNotNull(set.decorated(), \"returned set should not be null\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAdd() {\n        final Set<E> set = makeTestSet();\n        final Integer i = Integer.valueOf(3);\n        assertThrows(IllegalArgumentException.class, () -> set.add((E) i),\n                \"Integer should fail string predicate.\");\n        assertFalse(set.contains(i), \"Collection shouldn't contain illegal element\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAddAll() {\n        final Set<E> set = makeTestSet();\n        final Set<E> elements = new HashSet<>();\n        elements.add((E) \"one\");\n        elements.add((E) \"two\");\n        elements.add((E) Integer.valueOf(3));\n        elements.add((E) \"four\");\n        assertThrows(IllegalArgumentException.class, () -> set.addAll(elements),\n                \"Integer should fail string predicate.\");\n        assertFalse(set.contains(\"one\"), \"Set shouldn't contain illegal element\");\n        assertFalse(set.contains(\"two\"), \"Set shouldn't contain illegal element\");\n        assertFalse(set.contains(Integer.valueOf(3)), \"Set shouldn't contain illegal element\");\n        assertFalse(set.contains(\"four\"), \"Set shouldn't contain illegal element\");\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedSet.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedSet.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "truePredicate = TruePredicate.<E>truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected Predicate<E> testPredicate =\n        String.class::isInstance;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "testPredicate =\n        String.class::isInstance", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/set/MapBackedSet2Test.java.MapBackedSet2Test", "name": "MapBackedSet2Test", "file_path": "src/test/java/org/apache/commons/collections4/set/MapBackedSet2Test.java", "superclasses": "", "methods": ["[void]testCanonicalEmptyCollectionExists()", "[void]testCanonicalFullCollectionExists()", "[void]testOrdering()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/MapBackedSet2Test.java.MapBackedSet2Test.[]MapBackedSet2Test()", "src/test/java/org/apache/commons/collections4/set/MapBackedSet2Test.java.MapBackedSet2Test.[Set<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/MapBackedSet2Test.java.MapBackedSet2Test.[Set<E>]setupSet()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit test.\n", "original_string": "public class MapBackedSet2Test<E> extends AbstractSetTest<E> {\n\n    public MapBackedSet2Test() {\n        super(MapBackedSet2Test.class.getSimpleName());\n    }\n\n    @Override\n    public Set<E> makeObject() {\n        return MapBackedSet.mapBackedSet(new LinkedMap<>());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected Set<E> setupSet() {\n        final Set<E> set = makeObject();\n\n        for (int i = 0; i < 10; i++) {\n            set.add((E) Integer.toString(i));\n        }\n        return set;\n    }\n\n    @Test\n    @Override\n    public void testCanonicalEmptyCollectionExists() {\n    }\n\n    @Test\n    @Override\n    public void testCanonicalFullCollectionExists() {\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testOrdering() {\n        final Set<E> set = setupSet();\n        Iterator<E> it = set.iterator();\n\n        for (int i = 0; i < 10; i++) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong\");\n        }\n\n        for (int i = 0; i < 10; i += 2) {\n            assertTrue(set.remove(Integer.toString(i)), \"Must be able to remove int\");\n        }\n\n        it = set.iterator();\n        for (int i = 1; i < 10; i += 2) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong after remove \");\n        }\n\n        for (int i = 0; i < 10; i++) {\n            set.add((E) Integer.toString(i));\n        }\n\n        assertEquals(10, set.size(), \"Size of set is wrong!\");\n\n        it = set.iterator();\n        for (int i = 1; i < 10; i += 2) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong\");\n        }\n        for (int i = 0; i < 10; i += 2) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/PredicatedNavigableSetTest.java.PredicatedNavigableSetTest", "name": "PredicatedNavigableSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/PredicatedNavigableSetTest.java", "superclasses": "", "methods": ["[void]testComparator()", "[void]testGetSet()", "[void]testIllegalAdd()", "[void]testIllegalAddAll()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/PredicatedNavigableSetTest.java.PredicatedNavigableSetTest.[]PredicatedNavigableSetTest()", "src/test/java/org/apache/commons/collections4/set/PredicatedNavigableSetTest.java.PredicatedNavigableSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/PredicatedNavigableSetTest.java.PredicatedNavigableSetTest.[NavigableSet<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/PredicatedNavigableSetTest.java.PredicatedNavigableSetTest.[NavigableSet<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/PredicatedNavigableSetTest.java.PredicatedNavigableSetTest.[PredicatedNavigableSet<E>]makeTestSet()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractNavigableSetTest} for exercising the\n{@link PredicatedNavigableSet} implementation.\n", "original_string": "public class PredicatedNavigableSetTest<E> extends AbstractNavigableSetTest<E> {\n\n    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n\n    protected Predicate<E> testPredicate =\n        o -> o instanceof String && ((String) o).startsWith(\"A\");\n\n    public PredicatedNavigableSetTest() {\n        super(PredicatedNavigableSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.1\";\n    }\n\n    @Override\n    public NavigableSet<E> makeFullCollection() {\n        final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));\n        return PredicatedNavigableSet.predicatedNavigableSet(set, truePredicate);\n    }\n\n    @Override\n    public NavigableSet<E> makeObject() {\n        return PredicatedNavigableSet.predicatedNavigableSet(new TreeSet<>(), truePredicate);\n    }\n\n    protected PredicatedNavigableSet<E> makeTestSet() {\n        return PredicatedNavigableSet.predicatedNavigableSet(new TreeSet<>(), testPredicate);\n    }\n\n    @Test\n    public void testComparator() {\n        final NavigableSet<E> set = makeTestSet();\n        final Comparator<? super E> c = set.comparator();\n        assertNull(c, \"natural order, so comparator should be null\");\n    }\n\n    @Test\n    public void testGetSet() {\n        final PredicatedNavigableSet<E> set = makeTestSet();\n        assertNotNull(set.decorated(), \"returned set should not be null\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAdd() {\n        final NavigableSet<E> set = makeTestSet();\n        final String testString = \"B\";\n        assertThrows(IllegalArgumentException.class, () -> set.add((E) testString),\n                \"Should fail string predicate.\");\n        assertFalse(set.contains(testString), \"Collection shouldn't contain illegal element\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAddAll() {\n        final NavigableSet<E> set = makeTestSet();\n        final Set<E> elements = new TreeSet<>();\n        elements.add((E) \"Aone\");\n        elements.add((E) \"Atwo\");\n        elements.add((E) \"Bthree\");\n        elements.add((E) \"Afour\");\n        assertThrows(IllegalArgumentException.class, () -> set.addAll(elements),\n                \"Should fail string predicate.\");\n        assertFalse(set.contains(\"Aone\"), \"Set shouldn't contain illegal element\");\n        assertFalse(set.contains(\"Atwo\"), \"Set shouldn't contain illegal element\");\n        assertFalse(set.contains(\"Bthree\"), \"Set shouldn't contain illegal element\");\n        assertFalse(set.contains(\"Afour\"), \"Set shouldn't contain illegal element\");\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedNavigableSet.emptyCollection.version4.1.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedNavigableSet.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "truePredicate = TruePredicate.<E>truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected Predicate<E> testPredicate =\n        o -> o instanceof String && ((String) o).startsWith(\"A\");", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "testPredicate =\n        o -> o instanceof String && ((String) o).startsWith(\"A\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/set/ListOrderedSetTest.java.ListOrderedSetTest", "name": "ListOrderedSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/ListOrderedSetTest.java", "superclasses": "", "methods": ["[void]testDecorator()", "[void]testDuplicates()", "[void]testListAddIndexed()", "[void]testListAddRemove()", "[void]testListAddReplacing()", "[void]testOrdering()", "[void]testRetainAll()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/ListOrderedSetTest.java.ListOrderedSetTest.[]ListOrderedSetTest()", "src/test/java/org/apache/commons/collections4/set/ListOrderedSetTest.java.ListOrderedSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/ListOrderedSetTest.java.ListOrderedSetTest.[ListOrderedSet<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/ListOrderedSetTest.java.ListOrderedSetTest.[ListOrderedSet<E>]setupSet()"], "overrides": null, "attributes": [{"original_string": "    static class A {\n\n        @Override\n        public boolean equals(final Object obj) {\n            return obj instanceof A || obj instanceof B;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n    }", "definition": "    static class A", "class_docstring": "", "name": "A", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            return obj instanceof A || obj instanceof B;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            return obj instanceof A || obj instanceof B;\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return 1;\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    static class B {\n\n        @Override\n        public boolean equals(final Object obj) {\n            return obj instanceof A || obj instanceof B;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n    }", "definition": "    static class B", "class_docstring": "", "name": "B", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            return obj instanceof A || obj instanceof B;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            return obj instanceof A || obj instanceof B;\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return 1;\n        }", "signature": "@Override\n        public int hashCode()"}]}], "class_docstring": "\nExtension of {@link AbstractSetTest} for exercising the\n{@link ListOrderedSet} implementation.\n", "original_string": "public class ListOrderedSetTest<E>\n    extends AbstractSetTest<E> {\n\n    static class A {\n\n        @Override\n        public boolean equals(final Object obj) {\n            return obj instanceof A || obj instanceof B;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n    }\n\n    static class B {\n\n        @Override\n        public boolean equals(final Object obj) {\n            return obj instanceof A || obj instanceof B;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n    }\n\n    private static final Integer ZERO = Integer.valueOf(0);\n\n    private static final Integer ONE = Integer.valueOf(1);\n\n    private static final Integer TWO = Integer.valueOf(2);\n\n    private static final Integer THREE = Integer.valueOf(3);\n\n    public ListOrderedSetTest() {\n        super(ListOrderedSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public ListOrderedSet<E> makeObject() {\n        return ListOrderedSet.listOrderedSet(new HashSet<>());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected ListOrderedSet<E> setupSet() {\n        final ListOrderedSet<E> set = makeObject();\n\n        for (int i = 0; i < 10; i++) {\n            set.add((E) Integer.toString(i));\n        }\n        return set;\n    }\n\n    @Test\n    public void testDecorator() {\n        assertAll(\n                () -> assertThrows(NullPointerException.class, () -> ListOrderedSet.listOrderedSet((List<E>) null)),\n                () -> assertThrows(NullPointerException.class, () -> ListOrderedSet.listOrderedSet((Set<E>) null)),\n                () -> assertThrows(NullPointerException.class, () -> ListOrderedSet.listOrderedSet(null, null)),\n                () -> assertThrows(NullPointerException.class, () -> ListOrderedSet.listOrderedSet(new HashSet<>(), null)),\n                () -> assertThrows(NullPointerException.class, () -> ListOrderedSet.listOrderedSet(null, new ArrayList<>()))\n        );\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testDuplicates() {\n        final List<E> list = new ArrayList<>(10);\n        list.add((E) Integer.valueOf(1));\n        list.add((E) Integer.valueOf(2));\n        list.add((E) Integer.valueOf(3));\n        list.add((E) Integer.valueOf(1));\n\n        final ListOrderedSet<E> orderedSet = ListOrderedSet.listOrderedSet(list);\n\n        assertEquals(3, orderedSet.size());\n        assertEquals(3, IteratorUtils.toArray(orderedSet.iterator()).length);\n\n        // insertion order preserved?\n        assertEquals(Integer.valueOf(1), orderedSet.get(0));\n        assertEquals(Integer.valueOf(2), orderedSet.get(1));\n        assertEquals(Integer.valueOf(3), orderedSet.get(2));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListAddIndexed() {\n        final ListOrderedSet<E> set = makeObject();\n        set.add((E) ZERO);\n        set.add((E) TWO);\n\n        set.add(1, (E) ONE);\n        assertEquals(3, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(ONE, set.get(1));\n        assertSame(TWO, set.get(2));\n\n        set.add(0, (E) ONE);\n        assertEquals(3, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(ONE, set.get(1));\n        assertSame(TWO, set.get(2));\n\n        final List<E> list = new ArrayList<>();\n        list.add((E) ZERO);\n        list.add((E) TWO);\n\n        set.addAll(0, list);\n        assertEquals(3, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(ONE, set.get(1));\n        assertSame(TWO, set.get(2));\n\n        list.add(0, (E) THREE); // list = [3,0,2]\n        set.remove(TWO); //  set = [0,1]\n        set.addAll(1, list);\n        assertEquals(4, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(THREE, set.get(1));\n        assertSame(TWO, set.get(2));\n        assertSame(ONE, set.get(3));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListAddRemove() {\n        final ListOrderedSet<E> set = makeObject();\n        final List<E> view = set.asList();\n        set.add((E) ZERO);\n        set.add((E) ONE);\n        set.add((E) TWO);\n\n        assertEquals(3, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(ONE, set.get(1));\n        assertSame(TWO, set.get(2));\n        assertEquals(3, view.size());\n        assertSame(ZERO, view.get(0));\n        assertSame(ONE, view.get(1));\n        assertSame(TWO, view.get(2));\n\n        assertEquals(0, set.indexOf(ZERO));\n        assertEquals(1, set.indexOf(ONE));\n        assertEquals(2, set.indexOf(TWO));\n\n        set.remove(1);\n        assertEquals(2, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(TWO, set.get(1));\n        assertEquals(2, view.size());\n        assertSame(ZERO, view.get(0));\n        assertSame(TWO, view.get(1));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListAddReplacing() {\n        final ListOrderedSet<E> set = makeObject();\n        final A a = new A();\n        final B b = new B();\n        set.add((E) a);\n        assertEquals(1, set.size());\n        set.add((E) b); // will match but not replace A as equal\n        assertEquals(1, set.size());\n        assertSame(a, set.decorated().iterator().next());\n        assertSame(a, set.iterator().next());\n        assertSame(a, set.get(0));\n        assertSame(a, set.asList().get(0));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testOrdering() {\n        final ListOrderedSet<E> set = setupSet();\n        Iterator<E> it = set.iterator();\n\n        for (int i = 0; i < 10; i++) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong\");\n        }\n\n        for (int i = 0; i < 10; i += 2) {\n            assertTrue(set.remove(Integer.toString(i)),\n                       \"Must be able to remove int\");\n        }\n\n        it = set.iterator();\n        for (int i = 1; i < 10; i += 2) {\n            assertEquals(Integer.toString(i), it.next(),\n                         \"Sequence is wrong after remove \");\n        }\n\n        for (int i = 0; i < 10; i++) {\n            set.add((E) Integer.toString(i));\n        }\n\n        assertEquals(10, set.size(), \"Size of set is wrong!\");\n\n        it = set.iterator();\n        for (int i = 1; i < 10; i += 2) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong\");\n        }\n        for (int i = 0; i < 10; i += 2) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong\");\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRetainAll() {\n        final List<E> list = new ArrayList<>(10);\n        final Set<E> set = new HashSet<>(10);\n        final ListOrderedSet<E> orderedSet = ListOrderedSet.listOrderedSet(set, list);\n        for (int i = 0; i < 10; ++i) {\n            orderedSet.add((E) Integer.valueOf(10 - i - 1));\n        }\n\n        final Collection<E> retained = new ArrayList<>(5);\n        for (int i = 0; i < 5; ++i) {\n            retained.add((E) Integer.valueOf(i * 2));\n        }\n\n        assertTrue(orderedSet.retainAll(retained));\n        assertEquals(5, orderedSet.size());\n        // insertion order preserved?\n        assertEquals(Integer.valueOf(8), orderedSet.get(0));\n        assertEquals(Integer.valueOf(6), orderedSet.get(1));\n        assertEquals(Integer.valueOf(4), orderedSet.get(2));\n        assertEquals(Integer.valueOf(2), orderedSet.get(3));\n        assertEquals(Integer.valueOf(0), orderedSet.get(4));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/ListOrderedSet.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/ListOrderedSet.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Integer ZERO = Integer.valueOf(0);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "ZERO = Integer.valueOf(0)", "syntax_pass": true}, {"attribute_expression": "private static final Integer ONE = Integer.valueOf(1);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "ONE = Integer.valueOf(1)", "syntax_pass": true}, {"attribute_expression": "private static final Integer TWO = Integer.valueOf(2);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "TWO = Integer.valueOf(2)", "syntax_pass": true}, {"attribute_expression": "private static final Integer THREE = Integer.valueOf(3);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "THREE = Integer.valueOf(3)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java.TransformedSetTest", "name": "TransformedSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java", "superclasses": "", "methods": ["[void]testTransformedSet()", "[void]testTransformedSet_decorateTransform()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java.TransformedSetTest.[]TransformedSetTest()", "src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java.TransformedSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java.TransformedSetTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java.TransformedSetTest.[Set<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java.TransformedSetTest.[Set<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java.TransformedSetTest.[Set<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java.TransformedSetTest.[Set<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSetTest} for exercising the {@link TransformedSet}\nimplementation.\n", "original_string": "public class TransformedSetTest<E> extends AbstractSetTest<E> {\n\n    public TransformedSetTest() {\n        super(TransformedSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public Set<E> makeConfirmedCollection() {\n        return new HashSet<>();\n    }\n\n    @Override\n    public Set<E> makeConfirmedFullCollection() {\n        return new HashSet<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Set<E> makeFullCollection() {\n        final Set<E> list = new HashSet<>(Arrays.asList(getFullElements()));\n        return TransformedSet.transformingSet(list,\n                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Set<E> makeObject() {\n        return TransformedSet.transformingSet(new HashSet<>(),\n                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testTransformedSet() {\n        final Set<E> set = TransformedSet.transformingSet(new HashSet<>(),\n                (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, set.size());\n        final E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n        for (int i = 0; i < els.length; i++) {\n            set.add(els[i]);\n            assertEquals(i + 1, set.size());\n            assertTrue(set.contains(Integer.valueOf((String) els[i])));\n            assertFalse(set.contains(els[i]));\n        }\n\n        assertFalse(set.remove(els[0]));\n        assertTrue(set.remove(Integer.valueOf((String) els[0])));\n\n    }\n\n    @Test\n    public void testTransformedSet_decorateTransform() {\n        final Set<Object> originalSet = new HashSet<>();\n        final Object[] els = {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        Collections.addAll(originalSet, els);\n        final Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(els.length, set.size());\n        for (final Object el : els) {\n            assertTrue(set.contains(Integer.valueOf((String) el)));\n            assertFalse(set.contains(el));\n        }\n\n        assertFalse(set.remove(els[0]));\n        assertTrue(set.remove(Integer.valueOf((String) els[0])));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedSet.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedSet.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/PredicatedSortedSetTest.java.PredicatedSortedSetTest", "name": "PredicatedSortedSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/PredicatedSortedSetTest.java", "superclasses": "", "methods": ["[void]testComparator()", "[void]testGetSet()", "[void]testIllegalAdd()", "[void]testIllegalAddAll()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/PredicatedSortedSetTest.java.PredicatedSortedSetTest.[]PredicatedSortedSetTest()", "src/test/java/org/apache/commons/collections4/set/PredicatedSortedSetTest.java.PredicatedSortedSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/PredicatedSortedSetTest.java.PredicatedSortedSetTest.[SortedSet<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/PredicatedSortedSetTest.java.PredicatedSortedSetTest.[SortedSet<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/PredicatedSortedSetTest.java.PredicatedSortedSetTest.[PredicatedSortedSet<E>]makeTestSet()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSortedSetTest} for exercising the\n{@link PredicatedSortedSet} implementation.\n", "original_string": "public class PredicatedSortedSetTest<E> extends AbstractSortedSetTest<E> {\n\n    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n\n    protected Predicate<E> testPredicate =\n        o -> o instanceof String && ((String) o).startsWith(\"A\");\n\n    public PredicatedSortedSetTest() {\n        super(PredicatedSortedSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public SortedSet<E> makeFullCollection() {\n        final TreeSet<E> set = new TreeSet<>(Arrays.asList(getFullElements()));\n        return PredicatedSortedSet.predicatedSortedSet(set, truePredicate);\n    }\n\n    @Override\n    public SortedSet<E> makeObject() {\n        return PredicatedSortedSet.predicatedSortedSet(new TreeSet<>(), truePredicate);\n    }\n\n    protected PredicatedSortedSet<E> makeTestSet() {\n        return PredicatedSortedSet.predicatedSortedSet(new TreeSet<>(), testPredicate);\n    }\n\n    @Test\n    public void testComparator() {\n        final SortedSet<E> set = makeTestSet();\n        final Comparator<? super E> c = set.comparator();\n        assertNull(c, \"natural order, so comparator should be null\");\n    }\n\n    @Test\n    public void testGetSet() {\n        final PredicatedSortedSet<E> set = makeTestSet();\n        assertNotNull(set.decorated(), \"returned set should not be null\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAdd() {\n        final SortedSet<E> set = makeTestSet();\n        final String testString = \"B\";\n        assertThrows(IllegalArgumentException.class, () -> set.add((E) testString),\n                \"Should fail string predicate.\");\n        assertFalse(set.contains(testString), \"Collection shouldn't contain illegal element\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAddAll() {\n        final SortedSet<E> set = makeTestSet();\n        final Set<E> elements = new TreeSet<>();\n        elements.add((E) \"Aone\");\n        elements.add((E) \"Atwo\");\n        elements.add((E) \"Bthree\");\n        elements.add((E) \"Afour\");\n        assertThrows(IllegalArgumentException.class, () -> set.addAll(elements),\n                \"Should fail string predicate.\");\n        assertFalse(set.contains(\"Aone\"), \"Set shouldn't contain illegal element\");\n        assertFalse(set.contains(\"Atwo\"), \"Set shouldn't contain illegal element\");\n        assertFalse(set.contains(\"Bthree\"), \"Set shouldn't contain illegal element\");\n        assertFalse(set.contains(\"Afour\"), \"Set shouldn't contain illegal element\");\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedSortedSet.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedSortedSet.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "truePredicate = TruePredicate.<E>truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected Predicate<E> testPredicate =\n        o -> o instanceof String && ((String) o).startsWith(\"A\");", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "testPredicate =\n        o -> o instanceof String && ((String) o).startsWith(\"A\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/set/ListOrderedSet2Test.java.ListOrderedSet2Test", "name": "ListOrderedSet2Test", "file_path": "src/test/java/org/apache/commons/collections4/set/ListOrderedSet2Test.java", "superclasses": "", "methods": ["[void]testListAddIndexed()", "[void]testListAddRemove()", "[void]testOrdering()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/ListOrderedSet2Test.java.ListOrderedSet2Test.[]ListOrderedSet2Test()", "src/test/java/org/apache/commons/collections4/set/ListOrderedSet2Test.java.ListOrderedSet2Test.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/ListOrderedSet2Test.java.ListOrderedSet2Test.[ListOrderedSet<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/ListOrderedSet2Test.java.ListOrderedSet2Test.[ListOrderedSet<E>]setupSet()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSetTest} for exercising the {@link ListOrderedSet}\nimplementation.\n", "original_string": "public class ListOrderedSet2Test<E> extends AbstractSetTest<E> {\n\n    private static final Integer ZERO = Integer.valueOf(0);\n    private static final Integer ONE = Integer.valueOf(1);\n    private static final Integer TWO = Integer.valueOf(2);\n    private static final Integer THREE = Integer.valueOf(3);\n\n    public ListOrderedSet2Test() {\n        super(ListOrderedSet2Test.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public ListOrderedSet<E> makeObject() {\n        return new ListOrderedSet<>();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected ListOrderedSet<E> setupSet() {\n        final ListOrderedSet<E> set = makeObject();\n\n        for (int i = 0; i < 10; i++) {\n            set.add((E) Integer.toString(i));\n        }\n        return set;\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListAddIndexed() {\n        final ListOrderedSet<E> set = makeObject();\n        set.add((E) ZERO);\n        set.add((E) TWO);\n\n        set.add(1, (E) ONE);\n        assertEquals(3, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(ONE, set.get(1));\n        assertSame(TWO, set.get(2));\n\n        set.add(0, (E) ONE);\n        assertEquals(3, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(ONE, set.get(1));\n        assertSame(TWO, set.get(2));\n\n        final List<E> list = new ArrayList<>();\n        list.add((E) ZERO);\n        list.add((E) TWO);\n\n        set.addAll(0, list);\n        assertEquals(3, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(ONE, set.get(1));\n        assertSame(TWO, set.get(2));\n\n        list.add(0, (E) THREE); // list = [3,0,2]\n        set.remove(TWO);    //  set = [0,1]\n        set.addAll(1, list);\n        assertEquals(4, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(THREE, set.get(1));\n        assertSame(TWO, set.get(2));\n        assertSame(ONE, set.get(3));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListAddRemove() {\n        final ListOrderedSet<E> set = makeObject();\n        final List<E> view = set.asList();\n        set.add((E) ZERO);\n        set.add((E) ONE);\n        set.add((E) TWO);\n\n        assertEquals(3, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(ONE, set.get(1));\n        assertSame(TWO, set.get(2));\n        assertEquals(3, view.size());\n        assertSame(ZERO, view.get(0));\n        assertSame(ONE, view.get(1));\n        assertSame(TWO, view.get(2));\n\n        assertEquals(0, set.indexOf(ZERO));\n        assertEquals(1, set.indexOf(ONE));\n        assertEquals(2, set.indexOf(TWO));\n\n        set.remove(1);\n        assertEquals(2, set.size());\n        assertSame(ZERO, set.get(0));\n        assertSame(TWO, set.get(1));\n        assertEquals(2, view.size());\n        assertSame(ZERO, view.get(0));\n        assertSame(TWO, view.get(1));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testOrdering() {\n        final ListOrderedSet<E> set = setupSet();\n        Iterator<E> it = set.iterator();\n\n        for (int i = 0; i < 10; i++) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong\");\n        }\n\n        for (int i = 0; i < 10; i += 2) {\n            assertTrue(set.remove(Integer.toString(i)), \"Must be able to remove int\");\n        }\n\n        it = set.iterator();\n        for (int i = 1; i < 10; i += 2) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong after remove \");\n        }\n\n        for (int i = 0; i < 10; i++) {\n            set.add((E) Integer.toString(i));\n        }\n\n        assertEquals(10, set.size(), \"Size of set is wrong!\");\n\n        it = set.iterator();\n        for (int i = 1; i < 10; i += 2) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong\");\n        }\n        for (int i = 0; i < 10; i += 2) {\n            assertEquals(Integer.toString(i), it.next(), \"Sequence is wrong\");\n        }\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/ListOrderedSet.emptyCollection.version3.1.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/ListOrderedSet.fullCollection.version3.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Integer ZERO = Integer.valueOf(0);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "ZERO = Integer.valueOf(0)", "syntax_pass": true}, {"attribute_expression": "private static final Integer ONE = Integer.valueOf(1);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "ONE = Integer.valueOf(1)", "syntax_pass": true}, {"attribute_expression": "private static final Integer TWO = Integer.valueOf(2);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "TWO = Integer.valueOf(2)", "syntax_pass": true}, {"attribute_expression": "private static final Integer THREE = Integer.valueOf(3);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "THREE = Integer.valueOf(3)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java.FixedSizeListTest", "name": "FixedSizeListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java", "superclasses": "", "methods": ["[void]testAdd()", "[void]testAddAll()", "[void]testIsFull()", "[void]testListAllowsMutationOfUnderlyingCollection()", "[void]testMaxSize()", "[void]testRemove()", "[void]testSubList()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java.FixedSizeListTest.[]FixedSizeListTest()", "src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java.FixedSizeListTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java.FixedSizeListTest.[FixedSizeList<String>]initFixedSizeList()", "src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java.FixedSizeListTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java.FixedSizeListTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java.FixedSizeListTest.[List<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java.FixedSizeListTest.[List<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractListTest} for exercising the {@link FixedSizeList}\nimplementation.\n", "original_string": "public class FixedSizeListTest<E> extends AbstractListTest<E> {\n\n    public FixedSizeListTest() {\n        super(FixedSizeListTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    private FixedSizeList<String> initFixedSizeList() {\n        final List<String> decoratedList = new ArrayList<>();\n        decoratedList.add(\"item 1\");\n        decoratedList.add(\"item 2\");\n        //\n        return FixedSizeList.fixedSizeList(decoratedList);\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public List<E> makeFullCollection() {\n        final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));\n        return FixedSizeList.fixedSizeList(list);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/FixedSizeList.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/FixedSizeList.fullCollection.version4.obj\");\n//    }\n\n    @Override\n    public List<E> makeObject() {\n        return FixedSizeList.fixedSizeList(new ArrayList<>());\n    }\n\n    @Test\n    public void testAdd() {\n        final FixedSizeList<String> fixedSizeList = initFixedSizeList();\n\n        assertThrows(UnsupportedOperationException.class, () -> fixedSizeList.add(2, \"New Value\"));\n    }\n\n    @Test\n    public void testAddAll() {\n        final FixedSizeList<String> fixedSizeList = initFixedSizeList();\n\n        final List<String> addList = new ArrayList<>();\n        addList.add(\"item 3\");\n        addList.add(\"item 4\");\n\n        assertThrows(UnsupportedOperationException.class, () -> fixedSizeList.addAll(2, addList));\n    }\n\n    @Test\n    public void testIsFull() {\n        final FixedSizeList<String> fixedSizeList = initFixedSizeList();\n\n        assertTrue(fixedSizeList.isFull());\n    }\n\n    @Test\n    public void testListAllowsMutationOfUnderlyingCollection() {\n\n        final List<String> decoratedList = new ArrayList<>();\n        decoratedList.add(\"item 1\");\n        decoratedList.add(\"item 2\");\n        //\n        final FixedSizeList<String> fixedSizeList = FixedSizeList.fixedSizeList(decoratedList);\n        final int sizeBefore = fixedSizeList.size();\n        //\n        final boolean changed = decoratedList.add(\"New Value\");\n        assertTrue(changed);\n        //\n        assertEquals(sizeBefore + 1, fixedSizeList.size(),\n                \"Modifying an the underlying list is allowed\");\n    }\n\n    @Test\n    public void testMaxSize() {\n        final FixedSizeList<String> fixedSizeList = initFixedSizeList();\n\n        assertEquals(2, fixedSizeList.maxSize());\n    }\n\n    @Test\n    public void testRemove() {\n        final FixedSizeList<String> fixedSizeList = initFixedSizeList();\n\n        assertThrows(UnsupportedOperationException.class, () -> fixedSizeList.remove(1));\n    }\n\n    @Test\n    public void testSubList() {\n        final FixedSizeList<String> fixedSizeList = initFixedSizeList();\n\n        final List<String> subFixedSizeList = fixedSizeList.subList(1, 1);\n        assertNotNull(subFixedSizeList);\n        assertEquals(0, subFixedSizeList.size());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/NodeCachingLinkedListTest.java.NodeCachingLinkedListTest", "name": "NodeCachingLinkedListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/NodeCachingLinkedListTest.java", "superclasses": "", "methods": ["[void]testShrinkCache()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/NodeCachingLinkedListTest.java.NodeCachingLinkedListTest.[void]compareSpeed()", "src/test/java/org/apache/commons/collections4/list/NodeCachingLinkedListTest.java.NodeCachingLinkedListTest.[]NodeCachingLinkedListTest()", "src/test/java/org/apache/commons/collections4/list/NodeCachingLinkedListTest.java.NodeCachingLinkedListTest.[NodeCachingLinkedList<E>]getCollection()", "src/test/java/org/apache/commons/collections4/list/NodeCachingLinkedListTest.java.NodeCachingLinkedListTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/list/NodeCachingLinkedListTest.java.NodeCachingLinkedListTest.[NodeCachingLinkedList<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTest class for NodeCachingLinkedList, a performance optimized LinkedList.\n", "original_string": "public class NodeCachingLinkedListTest<E> extends AbstractLinkedListTest<E> {\n\n    public static void compareSpeed() {\n        final NodeCachingLinkedList<Object> ncll = new NodeCachingLinkedList<>();\n        final LinkedList<Object> ll = new LinkedList<>();\n\n        final Object o1 = new Object();\n        final Object o2 = new Object();\n\n        final int loopCount = 4000000;\n\n        long startTime, endTime;\n\n        System.out.println(\"Testing relative execution time of commonly-used methods...\");\n\n        startTime = System.currentTimeMillis();\n        for (int x = loopCount; x > 0; x--) {\n            // unrolled a few times to minimize effect of loop\n            ll.addFirst(o1);\n            ll.addLast(o2);\n            ll.removeFirst();\n            ll.removeLast();\n            ll.add(o1);\n            ll.remove(0);\n            //\n            ll.addFirst(o1);\n            ll.addLast(o2);\n            ll.removeFirst();\n            ll.removeLast();\n            ll.add(o1);\n            ll.remove(0);\n            //\n            ll.addFirst(o1);\n            ll.addLast(o2);\n            ll.removeFirst();\n            ll.removeLast();\n            ll.add(o1);\n            ll.remove(0);\n        }\n        endTime = System.currentTimeMillis();\n        System.out.println(\"Time with LinkedList: \" + (endTime - startTime) + \" ms\");\n\n        startTime = System.currentTimeMillis();\n        for (int x = loopCount; x > 0; x--) {\n            ncll.addFirst(o1);\n            ncll.addLast(o2);\n            ncll.removeFirst();\n            ncll.removeLast();\n            ncll.add(o1);\n            ncll.remove(0);\n            //\n            ncll.addFirst(o1);\n            ncll.addLast(o2);\n            ncll.removeFirst();\n            ncll.removeLast();\n            ncll.add(o1);\n            ncll.remove(0);\n            //\n            ncll.addFirst(o1);\n            ncll.addLast(o2);\n            ncll.removeFirst();\n            ncll.removeLast();\n            ncll.add(o1);\n            ncll.remove(0);\n        }\n        endTime = System.currentTimeMillis();\n        System.out.println(\"Time with NodeCachingLinkedList: \" + (endTime - startTime) + \" ms\");\n\n    }\n\n    public NodeCachingLinkedListTest() {\n        super(NodeCachingLinkedListTest.class.getSimpleName());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NodeCachingLinkedList<E> getCollection() {\n        return (NodeCachingLinkedList<E>) super.getCollection();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public NodeCachingLinkedList<E> makeObject() {\n        return new NodeCachingLinkedList<>();\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(),\n//           \"src/test/resources/data/test/NodeCachingLinkedList.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(),\n//            \"src/test/resources/data/test/NodeCachingLinkedList.fullCollection.version4.obj\");\n//    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testShrinkCache() {\n        if (!isRemoveSupported() || !isAddSupported()) {\n            return;\n        }\n        resetEmpty();\n        final NodeCachingLinkedList<E> list = getCollection();\n\n        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n        list.removeAllNodes(); // Will dump all 4 elements into cache\n        list.setMaximumCacheSize(2); // shrink cache\n        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n        checkNodes();\n        list.removeNode(list.getNode(0, false)); // no room in cache\n        list.removeNode(list.getNode(0, false));\n        list.removeNode(list.getNode(0, false));\n        checkNodes();\n        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n        checkNodes();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/Collections701Test.java.Collections701Test", "name": "Collections701Test", "file_path": "src/test/java/org/apache/commons/collections4/list/Collections701Test.java", "superclasses": "", "methods": ["[void]testArrayList()", "[void]testHashSet()", "[void]testSetUniqueList()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests for COLLECTIONS-701.\n", "original_string": "public class Collections701Test {\n\n    @Test\n    public void testArrayList() {\n        final List<Object> list = new ArrayList<>();\n        list.add(list);\n        assertEquals(1, list.size());\n        assertEquals(list, list.get(0));\n    }\n\n    @Test\n    public void testHashSet() {\n        final Set<Object> set = new HashSet<>();\n        set.add(set);\n        assertEquals(1, set.size());\n        assertEquals(set, set.iterator().next());\n    }\n\n    @Test\n    public void testSetUniqueList() {\n        final List<Object> source = new ArrayList<>();\n        final List<Object> list = SetUniqueList.setUniqueList(source);\n        list.add(list);\n        assertEquals(1, list.size());\n        assertEquals(list, list.get(0));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java.CursorableLinkedListTest", "name": "CursorableLinkedListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java", "superclasses": "", "methods": ["[void]testAdd()", "[void]testClear()", "[void]testContains()", "[void]testContainsAll()", "[void]testCursorAdd()", "[void]testCursorConcurrentModification()", "[void]testCursorNavigation()", "[void]testCursorNextIndexAddAfter()", "[void]testCursorNextIndexAddBefore()", "[void]testCursorNextIndexAddNext()", "[void]testCursorNextIndexFirst()", "[void]testCursorNextIndexMid()", "[void]testCursorRemove()", "[void]testCursorSet()", "[void]testEqualsAndHashCode()", "[void]testGet()", "[void]testIndexOf()", "[void]testInternalState_CursorNextAddIndex1ByList()", "[void]testInternalState_CursorNextNextAddByIterator()", "[void]testInternalState_CursorNextNextAddIndex1ByList()", "[void]testInternalState_CursorNextNextNextRemoveIndex1ByList()", "[void]testInternalState_CursorNextNextPreviousAddByIterator()", "[void]testInternalState_CursorNextNextPreviousAddIndex1ByList()", "[void]testInternalState_CursorNextNextPreviousRemoveByIterator()", "[void]testInternalState_CursorNextNextPreviousRemoveIndex1ByList()", "[void]testInternalState_CursorNextNextPreviousSetByIterator()", "[void]testInternalState_CursorNextNextRemoveByIterator()", "[void]testInternalState_CursorNextNextRemoveByListSetByIterator()", "[void]testInternalState_CursorNextNextRemoveIndex1ByList()", "[void]testInternalState_CursorNextNextSetByIterator()", "[void]testInternalState_CursorNextRemoveIndex1ByList()", "[void]testIsEmpty()", "[void]testIterator()", "[void]testListIteratorAdd()", "[void]testListIteratorNavigation()", "[void]testListIteratorRemove()", "[void]testListIteratorSet()", "[void]testLongSerialization()", "[void]testRemove()", "[void]testRemoveAll()", "[void]testRemoveByIndex()", "[void]testRetainAll()", "[void]testSerialization()", "[void]testSerializationWithOpenCursor()", "[void]testSet()", "[void]testSubList()", "[void]testSubListAddBegin()", "[void]testSubListAddEnd()", "[void]testSubListAddMiddle()", "[void]testSubListRemove()", "[void]testToArray()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java.CursorableLinkedListTest.[]CursorableLinkedListTest()", "src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java.CursorableLinkedListTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java.CursorableLinkedListTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java.CursorableLinkedListTest.[CursorableLinkedList<E>]makeObject()", "src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java.CursorableLinkedListTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest class.\n", "original_string": "public class CursorableLinkedListTest<E> extends AbstractLinkedListTest<E> {\n\n    private CursorableLinkedList<E> list;\n    public CursorableLinkedListTest() {\n        super(CursorableLinkedListTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     *  Ignore the serialization tests for sublists and sub-sublists.\n     *\n     *  @return an array of sublist serialization test names\n     */\n    @Override\n    public String[] ignoredTests() {\n        final ArrayList<String> list = new ArrayList<>();\n        final String prefix = \"CursorableLinkedListTest\";\n        final String bulk = \".bulkTestSubList\";\n        final String[] ignored = {\n            \".testEmptyListSerialization\",\n            \".testFullListSerialization\",\n            \".testEmptyListCompatibility\",\n            \".testFullListCompatibility\",\n            \".testSimpleSerialization\",\n            \".testCanonicalEmptyCollectionExists\",\n            \".testCanonicalFullCollectionExists\",\n            \".testSerializeDeserializeThenCompare\"\n        };\n        for (final String element : ignored) {\n            list.add(prefix + bulk + element);\n            list.add(prefix + bulk + bulk + element);\n        }\n        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public CursorableLinkedList<E> makeObject() {\n        return new CursorableLinkedList<>();\n    }\n\n    @BeforeEach\n    public void setUp() {\n        list = new CursorableLinkedList<>();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAdd() {\n        assertEquals(\"[]\", list.toString());\n        assertTrue(list.add((E) Integer.valueOf(1)));\n        assertEquals(\"[1]\", list.toString());\n        assertTrue(list.add((E) Integer.valueOf(2)));\n        assertEquals(\"[1, 2]\", list.toString());\n        assertTrue(list.add((E) Integer.valueOf(3)));\n        assertEquals(\"[1, 2, 3]\", list.toString());\n        assertTrue(list.addFirst((E) Integer.valueOf(0)));\n        assertEquals(\"[0, 1, 2, 3]\", list.toString());\n        assertTrue(list.addLast((E) Integer.valueOf(4)));\n        assertEquals(\"[0, 1, 2, 3, 4]\", list.toString());\n        list.add(0, (E) Integer.valueOf(-2));\n        assertEquals(\"[-2, 0, 1, 2, 3, 4]\", list.toString());\n        list.add(1, (E) Integer.valueOf(-1));\n        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4]\", list.toString());\n        list.add(7, (E) Integer.valueOf(5));\n        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5]\", list.toString());\n\n        final List<E> list2 = new LinkedList<>();\n        list2.add((E) \"A\");\n        list2.add((E) \"B\");\n        list2.add((E) \"C\");\n\n        assertTrue(list.addAll(list2));\n        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5, A, B, C]\", list.toString());\n        assertTrue(list.addAll(3, list2));\n        assertEquals(\"[-2, -1, 0, A, B, C, 1, 2, 3, 4, 5, A, B, C]\", list.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testClear() {\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n\n        list.add((E) \"element\");\n        assertEquals(1, list.size());\n        assertFalse(list.isEmpty());\n\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n\n        list.add((E) \"element1\");\n        list.add((E) \"element2\");\n        assertEquals(2, list.size());\n        assertFalse(list.isEmpty());\n\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n\n        for (int i = 0; i < 1000; i++) {\n            list.add((E) Integer.valueOf(i));\n        }\n        assertEquals(1000, list.size());\n        assertFalse(list.isEmpty());\n\n        list.clear();\n        assertEquals(0, list.size());\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testContains() {\n        assertFalse(list.contains(\"A\"));\n        assertTrue(list.add((E) \"A\"));\n        assertTrue(list.contains(\"A\"));\n        assertTrue(list.add((E) \"B\"));\n        assertTrue(list.contains(\"A\"));\n        assertTrue(list.addFirst((E) \"a\"));\n        assertTrue(list.contains(\"A\"));\n        assertTrue(list.remove(\"a\"));\n        assertTrue(list.contains(\"A\"));\n        assertTrue(list.remove(\"A\"));\n        assertFalse(list.contains(\"A\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testContainsAll() {\n        assertTrue(list.containsAll(list));\n        final java.util.List<E> list2 = new java.util.LinkedList<>();\n        assertTrue(list.containsAll(list2));\n        list2.add((E) \"A\");\n        assertFalse(list.containsAll(list2));\n        list.add((E) \"B\");\n        list.add((E) \"A\");\n        assertTrue(list.containsAll(list2));\n        list2.add((E) \"B\");\n        assertTrue(list.containsAll(list2));\n        list2.add((E) \"C\");\n        assertFalse(list.containsAll(list2));\n        list.add((E) \"C\");\n        assertTrue(list.containsAll(list2));\n        list2.add((E) \"C\");\n        assertTrue(list.containsAll(list2));\n        assertTrue(list.containsAll(list));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorAdd() {\n        final CursorableLinkedList.Cursor<E> it = list.cursor();\n        it.add((E) \"1\");\n        assertEquals(\"[1]\", list.toString());\n        it.add((E) \"3\");\n        assertEquals(\"[1, 3]\", list.toString());\n        it.add((E) \"5\");\n        assertEquals(\"[1, 3, 5]\", list.toString());\n        assertEquals(\"5\", it.previous());\n        it.add((E) \"4\");\n        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n        assertEquals(\"4\", it.previous());\n        assertEquals(\"3\", it.previous());\n        it.add((E) \"2\");\n        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n        it.close();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorConcurrentModification() {\n        // this test verifies that cursors remain valid when the list\n        // is modified via other means.\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"5\");\n        list.add((E) \"7\");\n        list.add((E) \"9\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        final CursorableLinkedList.Cursor<E> c2 = list.cursor();\n        final Iterator<E> li = list.iterator();\n\n        // test cursors remain valid when list modified by std Iterator\n        // test cursors skip elements removed via ListIterator\n        assertEquals(\"1\", li.next());\n        assertEquals(\"2\", li.next());\n        li.remove();\n        assertEquals(\"3\", li.next());\n        assertEquals(\"1\", c1.next());\n        assertEquals(\"3\", c1.next());\n        assertEquals(\"1\", c2.next());\n\n        // test cursor c1 can remove elements from previously modified list\n        // test cursor c2 skips elements removed via different cursor\n        c1.remove();\n        assertEquals(\"5\", c2.next());\n        c2.add((E) \"6\");\n        assertEquals(\"5\", c1.next());\n        assertEquals(\"6\", c1.next());\n        assertEquals(\"7\", c1.next());\n\n        // test cursors remain valid when list mod via CursorableLinkedList\n        // test cursor remains valid when elements inserted into list before\n        // the current position of the cursor.\n        list.add(0, (E) \"0\");\n\n        // test cursor remains valid when element inserted immediately after\n        // current element of a cursor, and the element is seen on the\n        // next call to the next method of that cursor.\n        list.add(5, (E) \"8\");\n\n        assertEquals(\"8\", c1.next());\n        assertEquals(\"9\", c1.next());\n        c1.add((E) \"10\");\n        assertEquals(\"7\", c2.next());\n        assertEquals(\"8\", c2.next());\n        assertEquals(\"9\", c2.next());\n        assertEquals(\"10\", c2.next());\n\n        assertThrows(NoSuchElementException.class, () -> c2.next());\n\n        assertThrows(ConcurrentModificationException.class, () -> li.next());\n\n        c1.close(); // not necessary\n        c2.close(); // not necessary\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorNavigation() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n        final CursorableLinkedList.Cursor<E> it = list.cursor();\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        assertEquals(\"1\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"1\", it.previous());\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        assertEquals(\"1\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"2\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"2\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"2\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"3\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"4\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"5\", it.next());\n        assertFalse(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"5\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"4\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"3\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"2\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"1\", it.previous());\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        it.close();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorNextIndexAddAfter() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"5\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n\n        assertEquals(0, c1.nextIndex());\n        list.add(1, (E) \"0\");\n        assertEquals(0, c1.nextIndex());\n        assertEquals(\"1\", c1.next());\n        assertEquals(1, c1.nextIndex());\n        assertEquals(\"0\", c1.next());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorNextIndexAddBefore() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"5\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n\n        assertEquals(0, c1.nextIndex());\n        assertEquals(\"1\", c1.next());\n        list.add(0, (E) \"0\");\n        assertEquals(2, c1.nextIndex());\n        assertEquals(\"2\", c1.next());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorNextIndexAddNext() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"5\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n\n        assertEquals(0, c1.nextIndex());\n        list.add(0, (E) \"0\");\n        assertEquals(0, c1.nextIndex());\n        assertEquals(\"0\", c1.next());\n        assertEquals(1, c1.nextIndex());\n        assertEquals(\"1\", c1.next());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorNextIndexFirst() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"5\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n\n        assertEquals(0, c1.nextIndex());\n        list.remove(0);\n        assertEquals(0, c1.nextIndex());\n        assertEquals(\"2\", c1.next());\n        assertEquals(1, c1.nextIndex());\n        assertEquals(\"3\", c1.next());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorNextIndexMid() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"5\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        final Iterator<E> li = list.iterator();\n\n        // test cursors remain valid when list modified by std Iterator\n        // test cursors skip elements removed via ListIterator\n        assertEquals(\"1\", li.next());\n        assertEquals(\"2\", li.next());\n        li.remove();\n        assertEquals(0, c1.nextIndex());\n        assertEquals(\"1\", c1.next());\n        assertEquals(1, c1.nextIndex());\n        assertEquals(\"3\", c1.next());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorRemove() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n\n        final CursorableLinkedList.Cursor<E> it = list.cursor();\n\n        assertThrows(IllegalStateException.class, () -> it.remove());\n\n        assertEquals(\"1\", it.next());\n        assertEquals(\"2\", it.next());\n        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n        it.remove();\n        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n        assertEquals(\"3\", it.next());\n        assertEquals(\"3\", it.previous());\n        assertEquals(\"1\", it.previous());\n        it.remove();\n        assertEquals(\"[3, 4, 5]\", list.toString());\n        assertFalse(it.hasPrevious());\n        assertEquals(\"3\", it.next());\n        it.remove();\n        assertEquals(\"[4, 5]\", list.toString());\n        try {\n            it.remove();\n        } catch (final IllegalStateException e) {\n            // expected\n        }\n        assertEquals(\"4\", it.next());\n        assertEquals(\"5\", it.next());\n        it.remove();\n        assertEquals(\"[4]\", list.toString());\n        assertEquals(\"4\", it.previous());\n        it.remove();\n        assertEquals(\"[]\", list.toString());\n        it.close();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCursorSet() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n\n        final CursorableLinkedList.Cursor<E> it = list.cursor();\n        assertEquals(\"1\", it.next());\n        it.set((E) \"a\");\n        assertEquals(\"a\", it.previous());\n        it.set((E) \"A\");\n        assertEquals(\"A\", it.next());\n        assertEquals(\"2\", it.next());\n        it.set((E) \"B\");\n        assertEquals(\"3\", it.next());\n        assertEquals(\"4\", it.next());\n        it.set((E) \"D\");\n        assertEquals(\"5\", it.next());\n        it.set((E) \"E\");\n        assertEquals(\"[A, B, 3, D, E]\", list.toString());\n        it.close();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEqualsAndHashCode() {\n        assertEquals(list, list);\n        assertEquals(list.hashCode(), list.hashCode());\n        list.add((E) \"A\");\n        assertEquals(list, list);\n        assertEquals(list.hashCode(), list.hashCode());\n\n        final CursorableLinkedList<E> list2 = new CursorableLinkedList<>();\n        assertFalse(list.equals(list2));\n        assertFalse(list2.equals(list));\n\n        final java.util.List<E> list3 = new java.util.LinkedList<>();\n        assertFalse(list.equals(list3));\n        assertFalse(list3.equals(list));\n        assertEquals(list2, list3);\n        assertEquals(list3, list2);\n        assertEquals(list2.hashCode(), list3.hashCode());\n\n        list2.add((E) \"A\");\n        assertEquals(list, list2);\n        assertEquals(list2, list);\n        assertFalse(list2.equals(list3));\n        assertFalse(list3.equals(list2));\n\n        list3.add((E) \"A\");\n        assertEquals(list2, list3);\n        assertEquals(list3, list2);\n        assertEquals(list2.hashCode(), list3.hashCode());\n\n        list.add((E) \"B\");\n        assertEquals(list, list);\n        assertFalse(list.equals(list2));\n        assertFalse(list2.equals(list));\n        assertFalse(list.equals(list3));\n        assertFalse(list3.equals(list));\n\n        list2.add((E) \"B\");\n        list3.add((E) \"B\");\n        assertEquals(list, list);\n        assertEquals(list, list2);\n        assertEquals(list2, list);\n        assertEquals(list2, list3);\n        assertEquals(list3, list2);\n        assertEquals(list2.hashCode(), list3.hashCode());\n\n        list.add((E) \"C\");\n        list2.add((E) \"C\");\n        list3.add((E) \"C\");\n        assertEquals(list, list);\n        assertEquals(list, list2);\n        assertEquals(list2, list);\n        assertEquals(list2, list3);\n        assertEquals(list3, list2);\n        assertEquals(list.hashCode(), list2.hashCode());\n        assertEquals(list2.hashCode(), list3.hashCode());\n\n        list.add((E) \"D\");\n        list2.addFirst((E) \"D\");\n        assertEquals(list, list);\n        assertFalse(list.equals(list2));\n        assertFalse(list2.equals(list));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testGet() {\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(0),\n                \"shouldn't get here\");\n\n        assertTrue(list.add((E) \"A\"));\n        assertEquals(\"A\", list.get(0));\n        assertTrue(list.add((E) \"B\"));\n        assertEquals(\"A\", list.get(0));\n        assertEquals(\"B\", list.get(1));\n        assertAll(\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> list.get(-1),\n                        \"shouldn't get here\"),\n                () -> assertThrows(IndexOutOfBoundsException.class, () -> list.get(2),\n                        \"shouldn't get here\")\n        );\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIndexOf() {\n        assertEquals(-1, list.indexOf(\"A\"));\n        assertEquals(-1, list.lastIndexOf(\"A\"));\n        list.add((E) \"A\");\n        assertEquals(0, list.indexOf(\"A\"));\n        assertEquals(0, list.lastIndexOf(\"A\"));\n        assertEquals(-1, list.indexOf(\"B\"));\n        assertEquals(-1, list.lastIndexOf(\"B\"));\n        list.add((E) \"B\");\n        assertEquals(0, list.indexOf(\"A\"));\n        assertEquals(0, list.lastIndexOf(\"A\"));\n        assertEquals(1, list.indexOf(\"B\"));\n        assertEquals(1, list.lastIndexOf(\"B\"));\n        list.addFirst((E) \"B\");\n        assertEquals(1, list.indexOf(\"A\"));\n        assertEquals(1, list.lastIndexOf(\"A\"));\n        assertEquals(0, list.indexOf(\"B\"));\n        assertEquals(2, list.lastIndexOf(\"B\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextAddIndex1ByList() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n\n        list.add(1, (E) \"Z\");\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(1, c1.nextIndex);\n        assertEquals(\"A\", c1.current.value);\n        assertEquals(\"Z\", c1.next.value);\n\n        assertEquals(\"[A, Z, B, C]\", list.toString());\n        c1.remove();  // works ok\n        assertEquals(\"[Z, B, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextAddByIterator() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n\n        c1.add((E) \"Z\");\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(3, c1.nextIndex);\n        assertFalse(c1.currentRemovedByAnother);\n        assertNull(c1.current);\n        assertEquals(\"C\", c1.next.value);\n\n        assertEquals(\"[A, B, Z, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextAddIndex1ByList() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n\n        list.add(1, (E) \"Z\");\n\n        assertFalse(c1.nextIndexValid);\n        assertEquals(\"B\", c1.current.value);\n        assertEquals(\"C\", c1.next.value);\n\n        assertEquals(\"[A, Z, B, C]\", list.toString());\n        c1.remove();  // works ok\n        assertEquals(\"[A, Z, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextNextRemoveIndex1ByList() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n        assertEquals(\"C\", c1.next());\n\n        assertEquals(\"B\", list.remove(1));\n\n        assertFalse(c1.nextIndexValid);\n        assertFalse(c1.currentRemovedByAnother);\n        assertEquals(\"C\", c1.current.value);\n        assertEquals(\"D\", c1.next.value);\n\n        assertEquals(\"[A, C, D]\", list.toString());\n        c1.remove();  // works ok\n        assertEquals(\"[A, D]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextPreviousAddByIterator() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n        assertEquals(\"B\", c1.previous());\n\n        c1.add((E) \"Z\");\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(2, c1.nextIndex);\n        assertNull(c1.current);\n        assertEquals(\"B\", c1.next.value);\n\n        assertEquals(\"[A, Z, B, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextPreviousAddIndex1ByList() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n        assertEquals(\"B\", c1.previous());\n\n        list.add(1, (E) \"Z\");\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(1, c1.nextIndex);\n        assertEquals(\"B\", c1.current.value);\n        assertEquals(\"Z\", c1.next.value);\n\n        assertEquals(\"[A, Z, B, C]\", list.toString());\n        c1.remove();  // works ok\n        assertEquals(\"[A, Z, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextPreviousRemoveByIterator() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n        assertEquals(\"B\", c1.previous());\n\n        c1.remove();\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(1, c1.nextIndex);\n        assertFalse(c1.currentRemovedByAnother);\n        assertNull(c1.current);\n        assertEquals(\"C\", c1.next.value);\n\n        assertEquals(\"[A, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextPreviousRemoveIndex1ByList() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n        assertEquals(\"B\", c1.previous());\n\n        assertEquals(\"B\", list.remove(1));\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(1, c1.nextIndex);\n        assertTrue(c1.currentRemovedByAnother);\n        assertNull(c1.current);\n        assertEquals(\"C\", c1.next.value);\n\n        assertEquals(\"[A, C]\", list.toString());\n        c1.remove();  // works ok\n        assertEquals(\"[A, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextPreviousSetByIterator() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n        assertEquals(\"B\", c1.previous());\n\n        c1.set((E) \"Z\");\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(1, c1.nextIndex);\n        assertEquals(\"Z\", c1.current.value);\n        assertEquals(\"Z\", c1.next.value);\n\n        assertEquals(\"[A, Z, C]\", list.toString());\n        c1.remove();  // works ok\n        assertEquals(\"[A, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextRemoveByIterator() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n\n        c1.remove();\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(1, c1.nextIndex);\n        assertFalse(c1.currentRemovedByAnother);\n        assertNull(c1.current);\n        assertEquals(\"C\", c1.next.value);\n\n        assertEquals(\"[A, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextRemoveByListSetByIterator() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n\n        list.remove(1);\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(1, c1.nextIndex);\n        assertNull(c1.current);\n        assertEquals(\"C\", c1.next.value);\n        assertEquals(\"[A, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.set((E) \"Z\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextRemoveIndex1ByList() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n\n        assertEquals(\"B\", list.remove(1));\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(1, c1.nextIndex);\n        assertTrue(c1.currentRemovedByAnother);\n        assertNull(c1.current);\n        assertEquals(\"C\", c1.next.value);\n\n        assertEquals(\"[A, C]\", list.toString());\n        c1.remove();  // works ok\n        assertEquals(\"[A, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextNextSetByIterator() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n        assertEquals(\"B\", c1.next());\n\n        c1.set((E) \"Z\");\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(2, c1.nextIndex);\n        assertEquals(\"Z\", c1.current.value);\n        assertEquals(\"C\", c1.next.value);\n\n        assertEquals(\"[A, Z, C]\", list.toString());\n        c1.remove();  // works ok\n        assertEquals(\"[A, C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInternalState_CursorNextRemoveIndex1ByList() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n\n        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n        assertEquals(\"A\", c1.next());\n\n        assertEquals(\"B\", list.remove(1));\n\n        assertTrue(c1.nextIndexValid);\n        assertEquals(1, c1.nextIndex);\n        assertFalse(c1.currentRemovedByAnother);\n        assertEquals(\"A\", c1.current.value);\n        assertEquals(\"C\", c1.next.value);\n\n        assertEquals(\"[A, C]\", list.toString());\n        c1.remove();  // works ok\n        assertEquals(\"[C]\", list.toString());\n\n        assertThrows(IllegalStateException.class, () -> c1.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIsEmpty() {\n        assertTrue(list.isEmpty());\n        list.add((E) \"element\");\n        assertFalse(list.isEmpty());\n        list.remove(\"element\");\n        assertTrue(list.isEmpty());\n        list.add((E) \"element\");\n        assertFalse(list.isEmpty());\n        list.clear();\n        assertTrue(list.isEmpty());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIterator() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n        Iterator<E> it = list.iterator();\n        assertTrue(it.hasNext());\n        assertEquals(\"1\", it.next());\n        assertTrue(it.hasNext());\n        assertEquals(\"2\", it.next());\n        assertTrue(it.hasNext());\n        assertEquals(\"3\", it.next());\n        assertTrue(it.hasNext());\n        assertEquals(\"4\", it.next());\n        assertTrue(it.hasNext());\n        assertEquals(\"5\", it.next());\n        assertFalse(it.hasNext());\n\n        it = list.iterator();\n        assertTrue(it.hasNext());\n        assertEquals(\"1\", it.next());\n        it.remove();\n        assertEquals(\"[2, 3, 4, 5]\", list.toString());\n        assertTrue(it.hasNext());\n        assertEquals(\"2\", it.next());\n        it.remove();\n        assertEquals(\"[3, 4, 5]\", list.toString());\n        assertTrue(it.hasNext());\n        assertEquals(\"3\", it.next());\n        it.remove();\n        assertEquals(\"[4, 5]\", list.toString());\n        assertTrue(it.hasNext());\n        assertEquals(\"4\", it.next());\n        it.remove();\n        assertEquals(\"[5]\", list.toString());\n        assertTrue(it.hasNext());\n        assertEquals(\"5\", it.next());\n        it.remove();\n        assertEquals(\"[]\", list.toString());\n        assertFalse(it.hasNext());\n    }\n\n    @Test\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void testListIteratorAdd() {\n        final ListIterator<E> it = list.listIterator();\n        it.add((E) \"1\");\n        assertEquals(\"[1]\", list.toString());\n        it.add((E) \"3\");\n        assertEquals(\"[1, 3]\", list.toString());\n        it.add((E) \"5\");\n        assertEquals(\"[1, 3, 5]\", list.toString());\n        assertEquals(\"5\", it.previous());\n        it.add((E) \"4\");\n        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n        assertEquals(\"4\", it.previous());\n        assertEquals(\"3\", it.previous());\n        it.add((E) \"2\");\n        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListIteratorNavigation() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n        final ListIterator<E> it = list.listIterator();\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        assertEquals(-1, it.previousIndex());\n        assertEquals(0, it.nextIndex());\n        assertEquals(\"1\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(0, it.previousIndex());\n        assertEquals(1, it.nextIndex());\n        assertEquals(\"1\", it.previous());\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        assertEquals(-1, it.previousIndex());\n        assertEquals(0, it.nextIndex());\n        assertEquals(\"1\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(0, it.previousIndex());\n        assertEquals(1, it.nextIndex());\n        assertEquals(\"2\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(1, it.previousIndex());\n        assertEquals(2, it.nextIndex());\n        assertEquals(\"2\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(0, it.previousIndex());\n        assertEquals(1, it.nextIndex());\n        assertEquals(\"2\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(1, it.previousIndex());\n        assertEquals(2, it.nextIndex());\n        assertEquals(\"3\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(2, it.previousIndex());\n        assertEquals(3, it.nextIndex());\n        assertEquals(\"4\", it.next());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(3, it.previousIndex());\n        assertEquals(4, it.nextIndex());\n        assertEquals(\"5\", it.next());\n        assertFalse(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(4, it.previousIndex());\n        assertEquals(5, it.nextIndex());\n        assertEquals(\"5\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(3, it.previousIndex());\n        assertEquals(4, it.nextIndex());\n        assertEquals(\"4\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(2, it.previousIndex());\n        assertEquals(3, it.nextIndex());\n        assertEquals(\"3\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(1, it.previousIndex());\n        assertEquals(2, it.nextIndex());\n        assertEquals(\"2\", it.previous());\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertEquals(0, it.previousIndex());\n        assertEquals(1, it.nextIndex());\n        assertEquals(\"1\", it.previous());\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        assertEquals(-1, it.previousIndex());\n        assertEquals(0, it.nextIndex());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListIteratorRemove() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n\n        final ListIterator<E> it = list.listIterator();\n        try {\n            it.remove();\n        } catch (final IllegalStateException e) {\n            // expected\n        }\n        assertEquals(\"1\", it.next());\n        assertEquals(\"2\", it.next());\n        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n        it.remove();\n        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n        assertEquals(\"3\", it.next());\n        assertEquals(\"3\", it.previous());\n        assertEquals(\"1\", it.previous());\n        it.remove();\n        assertEquals(\"[3, 4, 5]\", list.toString());\n        assertFalse(it.hasPrevious());\n        assertEquals(\"3\", it.next());\n        it.remove();\n        assertEquals(\"[4, 5]\", list.toString());\n        try {\n            it.remove();\n        } catch (final IllegalStateException e) {\n            // expected\n        }\n        assertEquals(\"4\", it.next());\n        assertEquals(\"5\", it.next());\n        it.remove();\n        assertEquals(\"[4]\", list.toString());\n        assertEquals(\"4\", it.previous());\n        it.remove();\n        assertEquals(\"[]\", list.toString());\n    }\n\n    @Test\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void testListIteratorSet() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n\n        final ListIterator<E> it = list.listIterator();\n        assertEquals(\"1\", it.next());\n        it.set((E) \"a\");\n        assertEquals(\"a\", it.previous());\n        it.set((E) \"A\");\n        assertEquals(\"A\", it.next());\n        assertEquals(\"2\", it.next());\n        it.set((E) \"B\");\n        assertEquals(\"3\", it.next());\n        assertEquals(\"4\", it.next());\n        it.set((E) \"D\");\n        assertEquals(\"5\", it.next());\n        it.set((E) \"E\");\n        assertEquals(\"[A, B, 3, D, E]\", list.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLongSerialization() throws Exception {\n        // recursive serialization will cause a stack\n        // overflow exception with long lists\n        for (int i = 0; i < 10000; i++) {\n            list.add((E) Integer.valueOf(i));\n        }\n\n        final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n        final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n        out.writeObject(list);\n        out.flush();\n        out.close();\n\n        final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n        final Object list2 = in.readObject();\n\n        assertNotSame(list, list2);\n        assertEquals(list2, list);\n        assertEquals(list, list2);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemove() {\n        list.add((E) \"1\");\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n        assertEquals(\"[1, 1, 2, 3, 4, 5, 2, 3, 4, 5]\", list.toString());\n        assertFalse(list.remove(\"6\"));\n        assertTrue(list.remove(\"5\"));\n        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4, 5]\", list.toString());\n        assertTrue(list.remove(\"5\"));\n        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4]\", list.toString());\n        assertFalse(list.remove(\"5\"));\n        assertTrue(list.remove(\"1\"));\n        assertEquals(\"[1, 2, 3, 4, 2, 3, 4]\", list.toString());\n        assertTrue(list.remove(\"1\"));\n        assertEquals(\"[2, 3, 4, 2, 3, 4]\", list.toString());\n        assertTrue(list.remove(\"2\"));\n        assertEquals(\"[3, 4, 2, 3, 4]\", list.toString());\n        assertTrue(list.remove(\"2\"));\n        assertEquals(\"[3, 4, 3, 4]\", list.toString());\n        assertTrue(list.remove(\"3\"));\n        assertEquals(\"[4, 3, 4]\", list.toString());\n        assertTrue(list.remove(\"3\"));\n        assertEquals(\"[4, 4]\", list.toString());\n        assertTrue(list.remove(\"4\"));\n        assertEquals(\"[4]\", list.toString());\n        assertTrue(list.remove(\"4\"));\n        assertEquals(\"[]\", list.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveAll() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n\n        final HashSet<E> set = new HashSet<>();\n        set.add((E) \"A\");\n        set.add((E) \"2\");\n        set.add((E) \"C\");\n        set.add((E) \"4\");\n        set.add((E) \"D\");\n\n        assertTrue(list.removeAll(set));\n        assertEquals(\"[1, 3, 5]\", list.toString());\n        assertFalse(list.removeAll(set));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveByIndex() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n        assertEquals(\"1\", list.remove(0));\n        assertEquals(\"[2, 3, 4, 5]\", list.toString());\n        assertEquals(\"3\", list.remove(1));\n        assertEquals(\"[2, 4, 5]\", list.toString());\n        assertEquals(\"4\", list.remove(1));\n        assertEquals(\"[2, 5]\", list.toString());\n        assertEquals(\"5\", list.remove(1));\n        assertEquals(\"[2]\", list.toString());\n        assertEquals(\"2\", list.remove(0));\n        assertEquals(\"[]\", list.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRetainAll() {\n        list.add((E) \"1\");\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n        list.add((E) \"5\");\n\n        final HashSet<E> set = new HashSet<>();\n        set.add((E) \"A\");\n        set.add((E) \"2\");\n        set.add((E) \"C\");\n        set.add((E) \"4\");\n        set.add((E) \"D\");\n\n        assertTrue(list.retainAll(set));\n        assertEquals(\"[2, 2, 4, 4]\", list.toString());\n        assertFalse(list.retainAll(set));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSerialization() throws Exception {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n        final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n        out.writeObject(list);\n        out.flush();\n        out.close();\n\n        final java.io.ByteArrayInputStream bufIn = new java.io.ByteArrayInputStream(buf.toByteArray());\n        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufIn);\n        final Object list2 = in.readObject();\n\n        assertNotSame(list, list2);\n        assertEquals(list2, list);\n        assertEquals(list, list2);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSerializationWithOpenCursor() throws Exception {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n        final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n        final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n        out.writeObject(list);\n        out.flush();\n        out.close();\n\n        final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n        final Object list2 = in.readObject();\n\n        assertNotSame(list, list2);\n        assertEquals(list2, list);\n        assertEquals(list, list2);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSet() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n        list.set(0, (E) \"A\");\n        assertEquals(\"[A, 2, 3, 4, 5]\", list.toString());\n        list.set(1, (E) \"B\");\n        assertEquals(\"[A, B, 3, 4, 5]\", list.toString());\n        list.set(2, (E) \"C\");\n        assertEquals(\"[A, B, C, 4, 5]\", list.toString());\n        list.set(3, (E) \"D\");\n        assertEquals(\"[A, B, C, D, 5]\", list.toString());\n        list.set(4, (E) \"E\");\n        assertEquals(\"[A, B, C, D, E]\", list.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubList() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        assertEquals(\"[A, B, C, D, E]\", list.toString());\n        assertEquals(\"[A, B, C, D, E]\", list.subList(0, 5).toString());\n        assertEquals(\"[B, C, D, E]\", list.subList(1, 5).toString());\n        assertEquals(\"[C, D, E]\", list.subList(2, 5).toString());\n        assertEquals(\"[D, E]\", list.subList(3, 5).toString());\n        assertEquals(\"[E]\", list.subList(4, 5).toString());\n        assertEquals(\"[]\", list.subList(5, 5).toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubListAddBegin() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        final List<E> sublist = list.subList(0, 0);\n        sublist.add((E) \"a\");\n        assertEquals(\"[a, A, B, C, D, E]\", list.toString());\n        assertEquals(\"[a]\", sublist.toString());\n        sublist.add((E) \"b\");\n        assertEquals(\"[a, b, A, B, C, D, E]\", list.toString());\n        assertEquals(\"[a, b]\", sublist.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubListAddEnd() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        final List<E> sublist = list.subList(5, 5);\n        sublist.add((E) \"F\");\n        assertEquals(\"[A, B, C, D, E, F]\", list.toString());\n        assertEquals(\"[F]\", sublist.toString());\n        sublist.add((E) \"G\");\n        assertEquals(\"[A, B, C, D, E, F, G]\", list.toString());\n        assertEquals(\"[F, G]\", sublist.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubListAddMiddle() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        final List<E> sublist = list.subList(1, 3);\n        sublist.add((E) \"a\");\n        assertEquals(\"[A, B, C, a, D, E]\", list.toString());\n        assertEquals(\"[B, C, a]\", sublist.toString());\n        sublist.add((E) \"b\");\n        assertEquals(\"[A, B, C, a, b, D, E]\", list.toString());\n        assertEquals(\"[B, C, a, b]\", sublist.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubListRemove() {\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        final List<E> sublist = list.subList(1, 4);\n        assertEquals(\"[B, C, D]\", sublist.toString());\n        assertEquals(\"[A, B, C, D, E]\", list.toString());\n        sublist.remove(\"C\");\n        assertEquals(\"[B, D]\", sublist.toString());\n        assertEquals(\"[A, B, D, E]\", list.toString());\n        sublist.remove(1);\n        assertEquals(\"[B]\", sublist.toString());\n        assertEquals(\"[A, B, E]\", list.toString());\n        sublist.clear();\n        assertEquals(\"[]\", sublist.toString());\n        assertEquals(\"[A, E]\", list.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testToArray() {\n        list.add((E) \"1\");\n        list.add((E) \"2\");\n        list.add((E) \"3\");\n        list.add((E) \"4\");\n        list.add((E) \"5\");\n\n        final Object[] elts = list.toArray();\n        assertEquals(\"1\", elts[0]);\n        assertEquals(\"2\", elts[1]);\n        assertEquals(\"3\", elts[2]);\n        assertEquals(\"4\", elts[3]);\n        assertEquals(\"5\", elts[4]);\n        assertEquals(5, elts.length);\n\n        final String[] elts2 = list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n        assertEquals(\"1\", elts2[0]);\n        assertEquals(\"2\", elts2[1]);\n        assertEquals(\"3\", elts2[2]);\n        assertEquals(\"4\", elts2[3]);\n        assertEquals(\"5\", elts2[4]);\n        assertEquals(5, elts2.length);\n\n        final String[] elts3 = new String[5];\n        assertSame(elts3, list.toArray(elts3));\n        assertEquals(\"1\", elts3[0]);\n        assertEquals(\"2\", elts3[1]);\n        assertEquals(\"3\", elts3[2]);\n        assertEquals(\"4\", elts3[3]);\n        assertEquals(\"5\", elts3[4]);\n        assertEquals(5, elts3.length);\n\n        final String[] elts4 = new String[3];\n        final String[] elts4b = list.toArray(elts4);\n        assertNotSame(elts4, elts4b);\n        assertEquals(\"1\", elts4b[0]);\n        assertEquals(\"2\", elts4b[1]);\n        assertEquals(\"3\", elts4b[2]);\n        assertEquals(\"4\", elts4b[3]);\n        assertEquals(\"5\", elts4b[4]);\n        assertEquals(5, elts4b.length);\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CursorableLinkedList.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CursorableLinkedList.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CursorableLinkedList<E> list;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CursorableLinkedList<E>", "name": "list", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/list/TreeListTest.java.TreeListTest", "name": "TreeListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/TreeListTest.java", "superclasses": "", "methods": ["[void]testAddMultiple()", "[void]testBug35258()", "[void]testBugCollections447()", "[void]testIndexOf()", "[void]testInsertBefore()", "[void]testIterationOrder()", "[void]testIterationOrderAfterAddAll()", "[void]testRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/TreeListTest.java.TreeListTest.[void]benchmark(List<? super Integer>)", "src/test/java/org/apache/commons/collections4/list/TreeListTest.java.TreeListTest.[]TreeListTest()", "src/test/java/org/apache/commons/collections4/list/TreeListTest.java.TreeListTest.[TreeList<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests\n", "original_string": "public class TreeListTest<E> extends AbstractListTest<E> {\n\n    public static void benchmark(final List<? super Integer> l) {\n        long startMillis = System.currentTimeMillis();\n        for (int i = 0; i < 100000; i++) {\n            l.add(Integer.valueOf(i));\n        }\n        System.out.print(System.currentTimeMillis() - startMillis + \";\");\n\n        startMillis = System.currentTimeMillis();\n        for (int i = 0; i < 200; i++) {\n            l.toArray();\n        }\n        System.out.print(System.currentTimeMillis() - startMillis + \";\");\n\n        startMillis = System.currentTimeMillis();\n        for (int i = 0; i < 100; i++) {\n            final java.util.Iterator<? super Integer> it = l.iterator();\n            while (it.hasNext()) {\n                it.next();\n            }\n        }\n        System.out.print(System.currentTimeMillis() - startMillis + \";\");\n\n        startMillis = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            final int j = (int) (Math.random() * 100000);\n            l.add(j, Integer.valueOf(-j));\n        }\n        System.out.print(System.currentTimeMillis() - startMillis + \";\");\n\n        startMillis = System.currentTimeMillis();\n        for (int i = 0; i < 50000; i++) {\n            final int j = (int) (Math.random() * 110000);\n            l.get(j);\n        }\n        System.out.print(System.currentTimeMillis() - startMillis + \";\");\n\n        startMillis = System.currentTimeMillis();\n        for (int i = 0; i < 200; i++) {\n            final int j = (int) (Math.random() * 100000);\n            l.indexOf(Integer.valueOf(j));\n        }\n        System.out.print(System.currentTimeMillis() - startMillis + \";\");\n\n        startMillis = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            final int j = (int) (Math.random() * 100000);\n            l.remove(j);\n        }\n        System.out.print(System.currentTimeMillis() - startMillis + \";\");\n    }\n\n//    public static void main(String[] args) {\n//        junit.textui.TestRunner.run(suite());\n//        System.out.println(\"         add; toArray; iterator; insert; get; indexOf; remove\");\n//        System.out.print(\"   TreeList = \");\n//        benchmark(new TreeList());\n//        System.out.print(\"\\n  ArrayList = \");\n//        benchmark(new java.util.ArrayList());\n//        System.out.print(\"\\n LinkedList = \");\n//        benchmark(new java.util.LinkedList());\n//        System.out.print(\"\\n NodeCachingLinkedList = \");\n//        benchmark(new NodeCachingLinkedList());\n//    }\n\n    public TreeListTest() {\n        super(TreeListTest.class.getSimpleName());\n    }\n\n    @Override\n    public TreeList<E> makeObject() {\n        return new TreeList<>();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddMultiple() {\n        final List<E> l = makeObject();\n        l.add((E) \"hugo\");\n        l.add((E) \"erna\");\n        l.add((E) \"daniel\");\n        l.add((E) \"andres\");\n        l.add((E) \"harald\");\n        l.add(0, null);\n        assertNull(l.get(0));\n        assertEquals(\"hugo\", l.get(1));\n        assertEquals(\"erna\", l.get(2));\n        assertEquals(\"daniel\", l.get(3));\n        assertEquals(\"andres\", l.get(4));\n        assertEquals(\"harald\", l.get(5));\n    }\n\n    @Test\n    public void testBug35258() {\n        final Object objectToRemove = Integer.valueOf(3);\n\n        final List<Integer> treelist = new TreeList<>();\n        treelist.add(Integer.valueOf(0));\n        treelist.add(Integer.valueOf(1));\n        treelist.add(Integer.valueOf(2));\n        treelist.add(Integer.valueOf(3));\n        treelist.add(Integer.valueOf(4));\n\n        // this cause inconsistency in ListIterator()\n        treelist.remove(objectToRemove);\n\n        final ListIterator<Integer> li = treelist.listIterator();\n        assertEquals(Integer.valueOf(0), li.next());\n        assertEquals(Integer.valueOf(0), li.previous());\n        assertEquals(Integer.valueOf(0), li.next());\n        assertEquals(Integer.valueOf(1), li.next());\n        // this caused error in bug 35258\n        assertEquals(Integer.valueOf(1), li.previous());\n        assertEquals(Integer.valueOf(1), li.next());\n        assertEquals(Integer.valueOf(2), li.next());\n        assertEquals(Integer.valueOf(2), li.previous());\n        assertEquals(Integer.valueOf(2), li.next());\n        assertEquals(Integer.valueOf(4), li.next());\n        assertEquals(Integer.valueOf(4), li.previous());\n        assertEquals(Integer.valueOf(4), li.next());\n        assertFalse(li.hasNext());\n    }\n\n    @Test\n    public void testBugCollections447() {\n        final List<String> treeList = new TreeList<>();\n        treeList.add(\"A\");\n        treeList.add(\"B\");\n        treeList.add(\"C\");\n        treeList.add(\"D\");\n\n        final ListIterator<String> li = treeList.listIterator();\n        assertEquals(\"A\", li.next());\n        assertEquals(\"B\", li.next());\n\n        assertEquals(\"B\", li.previous());\n\n        li.remove(); // Deletes \"B\"\n\n        // previous() after remove() should move to\n        // the element before the one just removed\n        assertEquals(\"A\", li.previous());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIndexOf() {\n        final List<E> l = makeObject();\n        l.add((E) \"0\");\n        l.add((E) \"1\");\n        l.add((E) \"2\");\n        l.add((E) \"3\");\n        l.add((E) \"4\");\n        l.add((E) \"5\");\n        l.add((E) \"6\");\n        assertEquals(0, l.indexOf(\"0\"));\n        assertEquals(1, l.indexOf(\"1\"));\n        assertEquals(2, l.indexOf(\"2\"));\n        assertEquals(3, l.indexOf(\"3\"));\n        assertEquals(4, l.indexOf(\"4\"));\n        assertEquals(5, l.indexOf(\"5\"));\n        assertEquals(6, l.indexOf(\"6\"));\n\n        l.set(1, (E) \"0\");\n        assertEquals(0, l.indexOf(\"0\"));\n\n        l.set(3, (E) \"3\");\n        assertEquals(3, l.indexOf(\"3\"));\n        l.set(2, (E) \"3\");\n        assertEquals(2, l.indexOf(\"3\"));\n        l.set(1, (E) \"3\");\n        assertEquals(1, l.indexOf(\"3\"));\n        l.set(0, (E) \"3\");\n        assertEquals(0, l.indexOf(\"3\"));\n    }\n\n//    public void testCheck() {\n//        List l = makeEmptyList();\n//        l.add(\"A1\");\n//        l.add(\"A2\");\n//        l.add(\"A3\");\n//        l.add(\"A4\");\n//        l.add(\"A5\");\n//        l.add(\"A6\");\n//    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testInsertBefore() {\n        final List<E> l = makeObject();\n        l.add((E) \"erna\");\n        l.add(0, (E) \"hugo\");\n        assertEquals(\"hugo\", l.get(0));\n        assertEquals(\"erna\", l.get(1));\n    }\n\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testIterationOrder() {\n        // COLLECTIONS-433:\n        // ensure that the iteration order of elements is correct\n        // when initializing the TreeList with another collection\n\n        for (int size = 1; size < 1000; size++) {\n            final List<Integer> other = new ArrayList<>(size);\n            for (int i = 0; i < size; i++) {\n                other.add(i);\n            }\n            final TreeList<Integer> l = new TreeList<>(other);\n            final ListIterator<Integer> it = l.listIterator();\n            int i = 0;\n            while (it.hasNext()) {\n                final Integer val = it.next();\n                assertEquals(i++, val.intValue());\n            }\n\n            while (it.hasPrevious()) {\n                final Integer val = it.previous();\n                assertEquals(--i, val.intValue());\n            }\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testIterationOrderAfterAddAll() {\n        // COLLECTIONS-433:\n        // ensure that the iteration order of elements is correct\n        // when calling addAll on the TreeList\n\n        // to simulate different cases in addAll, do different runs where\n        // the number of elements already in the list and being added by addAll differ\n\n        final int size = 1000;\n        for (int i = 0; i < 100; i++) {\n            final List<Integer> other = new ArrayList<>(size);\n            for (int j = i; j < size; j++) {\n                other.add(j);\n            }\n            final TreeList<Integer> l = new TreeList<>();\n            for (int j = 0; j < i; j++) {\n                l.add(j);\n            }\n\n            l.addAll(other);\n\n            final ListIterator<Integer> it = l.listIterator();\n            int cnt = 0;\n            while (it.hasNext()) {\n                final Integer val = it.next();\n                assertEquals(cnt++, val.intValue());\n            }\n\n            while (it.hasPrevious()) {\n                final Integer val = it.previous();\n                assertEquals(--cnt, val.intValue());\n            }\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemove() {\n        final List<E> l = makeObject();\n        l.add((E) \"hugo\");\n        l.add((E) \"erna\");\n        l.add((E) \"daniel\");\n        l.add((E) \"andres\");\n        l.add((E) \"harald\");\n        l.add(0, null);\n        int i = 0;\n        assertNull(l.get(i++));\n        assertEquals(\"hugo\", l.get(i++));\n        assertEquals(\"erna\", l.get(i++));\n        assertEquals(\"daniel\", l.get(i++));\n        assertEquals(\"andres\", l.get(i++));\n        assertEquals(\"harald\", l.get(i++));\n\n        l.remove(0);\n        i = 0;\n        assertEquals(\"hugo\", l.get(i++));\n        assertEquals(\"erna\", l.get(i++));\n        assertEquals(\"daniel\", l.get(i++));\n        assertEquals(\"andres\", l.get(i++));\n        assertEquals(\"harald\", l.get(i++));\n\n        i = 0;\n        l.remove(1);\n        assertEquals(\"hugo\", l.get(i++));\n        assertEquals(\"daniel\", l.get(i++));\n        assertEquals(\"andres\", l.get(i++));\n        assertEquals(\"harald\", l.get(i++));\n\n        i = 0;\n        l.remove(2);\n        assertEquals(\"hugo\", l.get(i++));\n        assertEquals(\"daniel\", l.get(i++));\n        assertEquals(\"harald\", l.get(i++));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/PredicatedListTest.java.PredicatedListTest", "name": "PredicatedListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/PredicatedListTest.java", "superclasses": "", "methods": ["[void]testIllegalAdd()", "[void]testIllegalAddAll()", "[void]testIllegalSet()", "[void]testLegalAddAll()", "[void]testSubList()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/PredicatedListTest.java.PredicatedListTest.[]PredicatedListTest()", "src/test/java/org/apache/commons/collections4/list/PredicatedListTest.java.PredicatedListTest.[List<E>]decorateList(List<E>,Predicate<E>)", "src/test/java/org/apache/commons/collections4/list/PredicatedListTest.java.PredicatedListTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/list/PredicatedListTest.java.PredicatedListTest.[E[]]getFullElements()", "src/test/java/org/apache/commons/collections4/list/PredicatedListTest.java.PredicatedListTest.[List<E>]makeObject()", "src/test/java/org/apache/commons/collections4/list/PredicatedListTest.java.PredicatedListTest.[List<E>]makeTestList()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractListTest} for exercising the\n{@link PredicatedList} implementation.\n", "original_string": "public class PredicatedListTest<E> extends AbstractListTest<E> {\n\n    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n\n    protected Predicate<E> testPredicate =\n        String.class::isInstance;\n\n    public PredicatedListTest() {\n        super(PredicatedListTest.class.getSimpleName());\n    }\n\n    protected List<E> decorateList(final List<E> list, final Predicate<E> predicate) {\n        return PredicatedList.predicatedList(list, predicate);\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E[] getFullElements() {\n        return (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n    }\n\n    @Override\n    public List<E> makeObject() {\n        return decorateList(new ArrayList<>(), truePredicate);\n    }\n\n    public List<E> makeTestList() {\n        return decorateList(new ArrayList<>(), testPredicate);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAdd() {\n        final List<E> list = makeTestList();\n        final Integer i = Integer.valueOf(3);\n\n        assertThrows(IllegalArgumentException.class, () -> list.add((E) i),\n                \"Integer should fail string predicate.\");\n\n        assertFalse(list.contains(i), \"Collection shouldn't contain illegal element\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAddAll() {\n        final List<E> list = makeTestList();\n        final List<E> elements = new ArrayList<>();\n        elements.add((E) \"one\");\n        elements.add((E) \"two\");\n        elements.add((E) Integer.valueOf(3));\n        elements.add((E) \"four\");\n\n        assertThrows(IllegalArgumentException.class, () -> list.addAll(0, elements),\n                \"Integer should fail string predicate.\");\n\n        assertFalse(list.contains(\"one\"), \"List shouldn't contain illegal element\");\n        assertFalse(list.contains(\"two\"), \"List shouldn't contain illegal element\");\n        assertFalse(list.contains(Integer.valueOf(3)), \"List shouldn't contain illegal element\");\n        assertFalse(list.contains(\"four\"), \"List shouldn't contain illegal element\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalSet() {\n        final List<E> list = makeTestList();\n        assertThrows(IllegalArgumentException.class, () -> list.set(0, (E) Integer.valueOf(3)),\n                \"Integer should fail string predicate.\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLegalAddAll() {\n        final List<E> list = makeTestList();\n        list.add((E) \"zero\");\n        final List<E> elements = new ArrayList<>();\n        elements.add((E) \"one\");\n        elements.add((E) \"two\");\n        elements.add((E) \"three\");\n        list.addAll(1, elements);\n        assertTrue(list.contains(\"zero\"), \"List should contain legal element\");\n        assertTrue(list.contains(\"one\"), \"List should contain legal element\");\n        assertTrue(list.contains(\"two\"), \"List should contain legal element\");\n        assertTrue(list.contains(\"three\"), \"List should contain legal element\");\n    }\n\n    @Test\n    public void testSubList() {\n        final List<E> list = makeTestList();\n        list.add((E) \"zero\");\n        //subList without any element of list\n        List<E> subList = list.subList(0, 0);\n        assertNotNull(subList);\n        assertEquals(0, subList.size());\n\n        //subList with one element oif list\n        subList = list.subList(0, 1);\n        assertEquals(1, subList.size());\n\n        final List<E> elements = new ArrayList<>();\n        elements.add((E) \"one\");\n        elements.add((E) \"two\");\n        elements.add((E) \"three\");\n        list.addAll(1, elements);\n        //subList with all elements of list\n        subList = list.subList(0, list.size());\n        assertEquals(list.size(), subList.size());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedList.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedList.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "truePredicate = TruePredicate.<E>truePredicate()", "syntax_pass": true}, {"attribute_expression": "protected Predicate<E> testPredicate =\n        String.class::isInstance;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<E>", "name": "testPredicate =\n        String.class::isInstance", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/list/TransformedListTest.java.TransformedListTest", "name": "TransformedListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/TransformedListTest.java", "superclasses": "", "methods": ["[void]testSubList()", "[void]testTransformedList()", "[void]testTransformedList_decorateTransform()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/TransformedListTest.java.TransformedListTest.[]TransformedListTest()", "src/test/java/org/apache/commons/collections4/list/TransformedListTest.java.TransformedListTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/list/TransformedListTest.java.TransformedListTest.[List<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/list/TransformedListTest.java.TransformedListTest.[List<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/list/TransformedListTest.java.TransformedListTest.[List<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/list/TransformedListTest.java.TransformedListTest.[List<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractListTest} for exercising the {@link TransformedList}\nimplementation.\n", "original_string": "public class TransformedListTest<E> extends AbstractListTest<E> {\n\n    public TransformedListTest() {\n        super(TransformedListTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public List<E> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public List<E> makeConfirmedFullCollection() {\n        return new ArrayList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<E> makeFullCollection() {\n        final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));\n        return TransformedList.transformingList(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public List<E> makeObject() {\n        return TransformedList.transformingList(new ArrayList<>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n    }\n\n    @Test\n    public void testSubList() {\n        final List<E> list = makeObject();\n        List<E> subList = list.subList(0, 0);\n        assertNotNull(subList);\n        list.add((E) \"zero\");\n        //subList without any element of list\n        subList = list.subList(0, 0);\n        assertNotNull(subList);\n        assertEquals(0, subList.size());\n\n        //subList with one element oif list\n        subList = list.subList(0, 1);\n        assertEquals(1, subList.size());\n\n        final List<E> elements = new ArrayList<>();\n        elements.add((E) \"one\");\n        elements.add((E) \"two\");\n        elements.add((E) \"three\");\n        list.addAll(1, elements);\n        //subList with all elements of list\n        subList = list.subList(0, list.size());\n        assertEquals(list.size(), subList.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testTransformedList() {\n        final List<E> list = TransformedList.transformingList(new ArrayList<>(), (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, list.size());\n        final E[] els = (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        for (int i = 0; i < els.length; i++) {\n            list.add(els[i]);\n            assertEquals(i + 1, list.size());\n            assertTrue(list.contains(Integer.valueOf((String) els[i])));\n            assertFalse(list.contains(els[i]));\n        }\n\n        assertFalse(list.remove(els[0]));\n        assertTrue(list.remove(Integer.valueOf((String) els[0])));\n\n        list.clear();\n        for (int i = 0; i < els.length; i++) {\n            list.add(0, els[i]);\n            assertEquals(i + 1, list.size());\n            assertEquals(Integer.valueOf((String) els[i]), list.get(0));\n        }\n\n        list.set(0, (E) \"22\");\n        assertEquals(Integer.valueOf(22), list.get(0));\n\n        final ListIterator<E> it = list.listIterator();\n        it.next();\n        it.set((E) \"33\");\n        assertEquals(Integer.valueOf(33), list.get(0));\n        it.add((E) \"44\");\n        assertEquals(Integer.valueOf(44), list.get(1));\n\n        final List<E> adds = new ArrayList<>();\n        adds.add((E) \"1\");\n        adds.add((E) \"2\");\n        list.clear();\n        list.addAll(adds);\n        assertEquals(Integer.valueOf(1), list.get(0));\n        assertEquals(Integer.valueOf(2), list.get(1));\n\n        adds.clear();\n        adds.add((E) \"3\");\n        list.addAll(1, adds);\n        assertEquals(Integer.valueOf(1), list.get(0));\n        assertEquals(Integer.valueOf(3), list.get(1));\n        assertEquals(Integer.valueOf(2), list.get(2));\n    }\n\n    @Test\n    public void testTransformedList_decorateTransform() {\n        final List<Object> originalList = new ArrayList<>();\n        final Object[] els = {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n        Collections.addAll(originalList, els);\n        final List<?> list = TransformedList.transformedList(originalList, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(els.length, list.size());\n        for (final Object el : els) {\n            assertTrue(list.contains(Integer.valueOf((String) el)));\n            assertFalse(list.contains(el));\n        }\n\n        assertFalse(list.remove(els[0]));\n        assertTrue(list.remove(Integer.valueOf((String) els[0])));\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedList.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedList.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java.DefaultAbstractLinkedListForJava21Test", "name": "DefaultAbstractLinkedListForJava21Test", "file_path": "src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java", "superclasses": "", "methods": ["[void]testAddNodeAfter()", "[void]testGetNode()", "[void]testRemoveFirst()", "[void]testRemoveLast()", "[void]testRemoveNode()", "[void]testSubList()", "[void]testSubListAddBegin()", "[void]testSubListAddEnd()", "[void]testSubListAddMiddle()", "[void]testSubListRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java.DefaultAbstractLinkedListForJava21Test.[]DefaultAbstractLinkedListForJava21Test()", "src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java.DefaultAbstractLinkedListForJava21Test.[void]checkNodes()", "src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java.DefaultAbstractLinkedListForJava21Test.[AbstractLinkedListForJava21<E>]getCollection()", "src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java.DefaultAbstractLinkedListForJava21Test.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java.DefaultAbstractLinkedListForJava21Test.[List<E>]makeObject()", "src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java.DefaultAbstractLinkedListForJava21Test.[boolean]skipSerializedCanonicalTests()"], "overrides": null, "attributes": [{"original_string": "    private static class DefaultAbstractLinkedListForJava21<E> extends AbstractLinkedListForJava21<E> {\n        DefaultAbstractLinkedListForJava21() {\n            init();\n        }\n\n        /**\n         * Deserializes an instance from an ObjectInputStream.\n         *\n         * @param in The source ObjectInputStream.\n         * @throws IOException            Any of the usual Input/Output related exceptions.\n         * @throws ClassNotFoundException A class of a serialized object cannot be found.\n         */\n        private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n            in.defaultReadObject();\n            doReadObject(in);\n        }\n\n        /**\n         * Serializes this object to an ObjectOutputStream.\n         *\n         * @param out the target ObjectOutputStream.\n         * @throws IOException thrown when an I/O errors occur writing to the target stream.\n         */\n        private void writeObject(final ObjectOutputStream out) throws IOException {\n            out.defaultWriteObject();\n            doWriteObject(out);\n        }\n    }", "definition": "    private static class DefaultAbstractLinkedListForJava21<E> extends AbstractLinkedListForJava21<E>", "class_docstring": "", "name": "DefaultAbstractLinkedListForJava21", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        DefaultAbstractLinkedListForJava21() {\n            init();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DefaultAbstractLinkedListForJava21", "params": [], "body": "                                             {\n            init();\n        }", "signature": "DefaultAbstractLinkedListForJava21()"}, {"syntax_pass": true, "original_string": "        private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n            in.defaultReadObject();\n            doReadObject(in);\n        }", "docstring": "\nDeserializes an instance from an ObjectInputStream.\n\n@param in The source ObjectInputStream.\n@throws IOException            Any of the usual Input/Output related exceptions.\n@throws ClassNotFoundException A class of a serialized object cannot be found.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "readObject", "params": [{"name": "in", "type": "ObjectInputStream"}], "body": "                                                                                                       {\n            in.defaultReadObject();\n            doReadObject(in);\n        }", "signature": "private void readObject(final ObjectInputStream in)"}, {"syntax_pass": true, "original_string": "        private void writeObject(final ObjectOutputStream out) throws IOException {\n            out.defaultWriteObject();\n            doWriteObject(out);\n        }", "docstring": "\nSerializes this object to an ObjectOutputStream.\n\n@param out the target ObjectOutputStream.\n@throws IOException thrown when an I/O errors occur writing to the target stream.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "writeObject", "params": [{"name": "out", "type": "ObjectOutputStream"}], "body": "                                                                                  {\n            out.defaultWriteObject();\n            doWriteObject(out);\n        }", "signature": "private void writeObject(final ObjectOutputStream out)"}]}], "class_docstring": "\nTest case for {@link AbstractLinkedListForJava21}.\n", "original_string": "public class DefaultAbstractLinkedListForJava21Test<E> extends AbstractListTest<E> {\n\n    private static class DefaultAbstractLinkedListForJava21<E> extends AbstractLinkedListForJava21<E> {\n        DefaultAbstractLinkedListForJava21() {\n            init();\n        }\n\n        /**\n         * Deserializes an instance from an ObjectInputStream.\n         *\n         * @param in The source ObjectInputStream.\n         * @throws IOException            Any of the usual Input/Output related exceptions.\n         * @throws ClassNotFoundException A class of a serialized object cannot be found.\n         */\n        private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n            in.defaultReadObject();\n            doReadObject(in);\n        }\n\n        /**\n         * Serializes this object to an ObjectOutputStream.\n         *\n         * @param out the target ObjectOutputStream.\n         * @throws IOException thrown when an I/O errors occur writing to the target stream.\n         */\n        private void writeObject(final ObjectOutputStream out) throws IOException {\n            out.defaultWriteObject();\n            doWriteObject(out);\n        }\n    }\n\n    public DefaultAbstractLinkedListForJava21Test() {\n        super(DefaultAbstractLinkedListForJava21Test.class.getSimpleName());\n    }\n\n    protected void checkNodes() {\n        final AbstractLinkedListForJava21<E> list = getCollection();\n        for (int i = 0; i < list.size; i++) {\n            assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));\n            if (i < list.size - 1) {\n                assertEquals(list.getNode(i + 1, false).previous, list.getNode(i, false));\n            }\n        }\n    }\n\n    @Override\n    public AbstractLinkedListForJava21<E> getCollection() {\n        return (AbstractLinkedListForJava21<E>) super.getCollection();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return null;\n    }\n\n    @Override\n    public List<E> makeObject() {\n        return new DefaultAbstractLinkedListForJava21<>();\n    }\n\n    @Override\n    protected boolean skipSerializedCanonicalTests() {\n        return true;\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddNodeAfter() {\n        resetEmpty();\n        final AbstractLinkedListForJava21<E> list = getCollection();\n        if (!isAddSupported()) {\n            try {\n                list.addFirst(null);\n            } catch (final UnsupportedOperationException ex) {\n            }\n        }\n\n        list.addFirst((E) \"value1\");\n        list.addNodeAfter(list.getNode(0, false), (E) \"value2\");\n        assertEquals(\"value1\", list.getFirst());\n        assertEquals(\"value2\", list.getLast());\n        list.removeFirst();\n        checkNodes();\n        list.addNodeAfter(list.getNode(0, false), (E) \"value3\");\n        checkNodes();\n        assertEquals(\"value2\", list.getFirst());\n        assertEquals(\"value3\", list.getLast());\n        list.addNodeAfter(list.getNode(0, false), (E) \"value4\");\n        checkNodes();\n        assertEquals(\"value2\", list.getFirst());\n        assertEquals(\"value3\", list.getLast());\n        assertEquals(\"value4\", list.get(1));\n        list.addNodeAfter(list.getNode(2, false), (E) \"value5\");\n        checkNodes();\n        assertEquals(\"value2\", list.getFirst());\n        assertEquals(\"value4\", list.get(1));\n        assertEquals(\"value3\", list.get(2));\n        assertEquals(\"value5\", list.getLast());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testGetNode() {\n        resetEmpty();\n        final AbstractLinkedListForJava21<E> list = getCollection();\n        // get marker\n        assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);\n        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(0, false), \"Expecting IndexOutOfBoundsException.\");\n        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n        checkNodes();\n        list.addFirst((E) \"value0\");\n        checkNodes();\n        list.removeNode(list.getNode(1, false));\n        checkNodes();\n        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(2, false), \"Expecting IndexOutOfBoundsException.\");\n        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(-1, false), \"Expecting IndexOutOfBoundsException.\");\n        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(3, true), \"Expecting IndexOutOfBoundsException.\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveFirst() {\n        resetEmpty();\n        final AbstractLinkedListForJava21<E> list = getCollection();\n        if (!isRemoveSupported()) {\n            try {\n                list.removeFirst();\n            } catch (final UnsupportedOperationException ex) {\n            }\n        }\n\n        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n        assertEquals(\"value1\", list.removeFirst());\n        checkNodes();\n        list.addLast((E) \"value3\");\n        checkNodes();\n        assertEquals(\"value2\", list.removeFirst());\n        assertEquals(\"value3\", list.removeFirst());\n        checkNodes();\n        list.addLast((E) \"value4\");\n        checkNodes();\n        assertEquals(\"value4\", list.removeFirst());\n        checkNodes();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveLast() {\n        resetEmpty();\n        final AbstractLinkedListForJava21<E> list = getCollection();\n        if (!isRemoveSupported()) {\n            try {\n                list.removeLast();\n            } catch (final UnsupportedOperationException ex) {\n            }\n        }\n\n        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n        assertEquals(\"value2\", list.removeLast());\n        list.addFirst((E) \"value3\");\n        checkNodes();\n        assertEquals(\"value1\", list.removeLast());\n        assertEquals(\"value3\", list.removeLast());\n        list.addFirst((E) \"value4\");\n        checkNodes();\n        assertEquals(\"value4\", list.removeFirst());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveNode() {\n        resetEmpty();\n        if (!isAddSupported() || !isRemoveSupported()) {\n            return;\n        }\n        final AbstractLinkedListForJava21<E> list = getCollection();\n\n        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n        list.removeNode(list.getNode(0, false));\n        checkNodes();\n        assertEquals(\"value2\", list.getFirst());\n        assertEquals(\"value2\", list.getLast());\n        list.addFirst((E) \"value1\");\n        list.addFirst((E) \"value0\");\n        checkNodes();\n        list.removeNode(list.getNode(1, false));\n        assertEquals(\"value0\", list.getFirst());\n        assertEquals(\"value2\", list.getLast());\n        checkNodes();\n        list.removeNode(list.getNode(1, false));\n        assertEquals(\"value0\", list.getFirst());\n        assertEquals(\"value0\", list.getLast());\n        checkNodes();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubList() {\n        final List<E> list = makeObject();\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        assertEquals(\"[A, B, C, D, E]\", list.toString());\n        assertEquals(\"[A, B, C, D, E]\", list.subList(0, 5).toString());\n        assertEquals(\"[B, C, D, E]\", list.subList(1, 5).toString());\n        assertEquals(\"[C, D, E]\", list.subList(2, 5).toString());\n        assertEquals(\"[D, E]\", list.subList(3, 5).toString());\n        assertEquals(\"[E]\", list.subList(4, 5).toString());\n        assertEquals(\"[]\", list.subList(5, 5).toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubListAddBegin() {\n        final List<E> list = makeObject();\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        final List<E> sublist = list.subList(0, 0);\n        sublist.add((E) \"a\");\n        assertEquals(\"[a, A, B, C, D, E]\", list.toString());\n        assertEquals(\"[a]\", sublist.toString());\n        sublist.add((E) \"b\");\n        assertEquals(\"[a, b, A, B, C, D, E]\", list.toString());\n        assertEquals(\"[a, b]\", sublist.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubListAddEnd() {\n        final List<E> list = makeObject();\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        final List<E> sublist = list.subList(5, 5);\n        sublist.add((E) \"F\");\n        assertEquals(\"[A, B, C, D, E, F]\", list.toString());\n        assertEquals(\"[F]\", sublist.toString());\n        sublist.add((E) \"G\");\n        assertEquals(\"[A, B, C, D, E, F, G]\", list.toString());\n        assertEquals(\"[F, G]\", sublist.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubListAddMiddle() {\n        final List<E> list = makeObject();\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        final List<E> sublist = list.subList(1, 3);\n        sublist.add((E) \"a\");\n        assertEquals(\"[A, B, C, a, D, E]\", list.toString());\n        assertEquals(\"[B, C, a]\", sublist.toString());\n        sublist.add((E) \"b\");\n        assertEquals(\"[A, B, C, a, b, D, E]\", list.toString());\n        assertEquals(\"[B, C, a, b]\", sublist.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSubListRemove() {\n        final List<E> list = makeObject();\n        list.add((E) \"A\");\n        list.add((E) \"B\");\n        list.add((E) \"C\");\n        list.add((E) \"D\");\n        list.add((E) \"E\");\n\n        final List<E> sublist = list.subList(1, 4);\n        assertEquals(\"[B, C, D]\", sublist.toString());\n        assertEquals(\"[A, B, C, D, E]\", list.toString());\n        sublist.remove(\"C\");\n        assertEquals(\"[B, D]\", sublist.toString());\n        assertEquals(\"[A, B, D, E]\", list.toString());\n        sublist.remove(1);\n        assertEquals(\"[B]\", sublist.toString());\n        assertEquals(\"[A, B, E]\", list.toString());\n        sublist.clear();\n        assertEquals(\"[]\", sublist.toString());\n        assertEquals(\"[A, E]\", list.toString());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/GrowthListTest.java.GrowthListTest", "name": "GrowthListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/GrowthListTest.java", "superclasses": "", "methods": ["[void]testGrowthAdd()", "[void]testGrowthAddAll()", "[void]testGrowthList()", "[void]testGrowthSet1()", "[void]testGrowthSet2()", "[void]testListAddByIndexBoundsChecking()", "[void]testListAddByIndexBoundsChecking2()", "[void]testListSetByIndexBoundsChecking()", "[void]testListSetByIndexBoundsChecking2()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/GrowthListTest.java.GrowthListTest.[]GrowthListTest()", "src/test/java/org/apache/commons/collections4/list/GrowthListTest.java.GrowthListTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/list/GrowthListTest.java.GrowthListTest.[List<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/list/GrowthListTest.java.GrowthListTest.[List<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractListTest} for exercising the {@link GrowthList}.\n", "original_string": "public class GrowthListTest<E> extends AbstractListTest<E> {\n\n    public GrowthListTest() {\n        super(GrowthListTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public List<E> makeFullCollection() {\n        final List<E> list = new ArrayList<>(Arrays.asList(getFullElements()));\n        return GrowthList.growthList(list);\n    }\n\n    @Override\n    public List<E> makeObject() {\n        return new GrowthList<>();\n    }\n\n    @Test\n    public void testGrowthAdd() {\n        final Integer one = Integer.valueOf(1);\n        final GrowthList<Integer> grower = new GrowthList<>();\n        assertEquals(0, grower.size());\n        grower.add(1, one);\n        assertEquals(2, grower.size());\n        assertNull(grower.get(0));\n        assertEquals(one, grower.get(1));\n    }\n\n    @Test\n    public void testGrowthAddAll() {\n        final Integer one = Integer.valueOf(1);\n        final Integer two = Integer.valueOf(2);\n        final Collection<Integer> coll = new ArrayList<>();\n        coll.add(one);\n        coll.add(two);\n        final GrowthList<Integer> grower = new GrowthList<>();\n        assertEquals(0, grower.size());\n        grower.addAll(1, coll);\n        assertEquals(3, grower.size());\n        assertNull(grower.get(0));\n        assertEquals(one, grower.get(1));\n        assertEquals(two, grower.get(2));\n    }\n\n    @Test\n    public void testGrowthList() {\n        final Integer zero = Integer.valueOf(0);\n        final Integer one = Integer.valueOf(1);\n        final Integer two = Integer.valueOf(2);\n        final GrowthList<Integer> grower = new GrowthList(1);\n        assertEquals(0, grower.size());\n        grower.add(0, zero);\n        assertEquals(1, grower.size());\n        grower.add(1, one);\n        assertEquals(2, grower.size());\n        grower.add(2, two);\n        assertEquals(3, grower.size());\n    }\n\n    @Test\n    public void testGrowthSet1() {\n        final Integer one = Integer.valueOf(1);\n        final GrowthList<Integer> grower = new GrowthList<>();\n        assertEquals(0, grower.size());\n        grower.set(1, one);\n        assertEquals(2, grower.size());\n        assertNull(grower.get(0));\n        assertEquals(one, grower.get(1));\n    }\n\n    @Test\n    public void testGrowthSet2() {\n        final Integer one = Integer.valueOf(1);\n        final GrowthList<Integer> grower = new GrowthList<>();\n        assertEquals(0, grower.size());\n        grower.set(0, one);\n        assertEquals(1, grower.size());\n        assertEquals(one, grower.get(0));\n    }\n\n    /**\n     * Override.\n     */\n    @Test\n    @Override\n    public void testListAddByIndexBoundsChecking() {\n        final E element = getOtherElements()[0];\n        final List<E> list = makeObject();\n\n        final Executable testMethod = () -> list.add(-1, element);\n        final IndexOutOfBoundsException thrown = assertThrows(IndexOutOfBoundsException.class, testMethod,\n                \"List.add should throw IndexOutOfBoundsException [-1]\");\n        assertThat(thrown.getMessage(), is(equalTo(\"Index: -1, Size: 0\")));\n    }\n\n    /**\n     * Override.\n     */\n    @Test\n    @Override\n    public void testListAddByIndexBoundsChecking2() {\n        final E element = getOtherElements()[0];\n        final List<E> list = makeFullCollection();\n        assertThrows(IndexOutOfBoundsException.class, () -> list.add(-1, element),\n                \"List.add should throw IndexOutOfBoundsException [-1]\");\n    }\n\n    /**\n     * Override.\n     */\n    @Test\n    @Override\n    public void testListSetByIndexBoundsChecking() {\n        final List<E> list = makeObject();\n        final E element = getOtherElements()[0];\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(-1, element),\n                \"List.set should throw IndexOutOfBoundsException [-1]\");\n    }\n\n    /**\n     * Override.\n     */\n    @Test\n    @Override\n    public void testListSetByIndexBoundsChecking2() {\n        final List<E> list = makeFullCollection();\n        final E element = getOtherElements()[0];\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(-1, element),\n                \"List.set should throw IndexOutOfBoundsException [-1]\");\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/GrowthList.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/GrowthList.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/LazyListTest.java.LazyListTest", "name": "LazyListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/LazyListTest.java", "superclasses": "AbstractObjectTest", "methods": ["[void]testCanonicalEmptyCollectionExists()", "[void]testCanonicalFullCollectionExists()", "[void]testCreateNullGapsWithFactory()", "[void]testCreateNullGapsWithTransformer()", "[void]testElementCreationWithFactory()", "[void]testElementCreationWithTransformer()", "[void]testGetWithNull()", "[void]testSerializeDeserializeThenCompare()", "[void]testSimpleSerialization()", "[void]testSubListWitheFactory()", "[void]testSubListWithTransformer()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/LazyListTest.java.LazyListTest.[]LazyListTest()", "src/test/java/org/apache/commons/collections4/list/LazyListTest.java.LazyListTest.[Object]makeObject()", "src/test/java/org/apache/commons/collections4/list/LazyListTest.java.LazyListTest.[void]testSubList(List<LocalDateTime>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LazyListTest extends AbstractObjectTest {\n\n    public LazyListTest() {\n        super(LazyListTest.class.getSimpleName());\n    }\n\n    @Override\n    public Object makeObject() {\n        final Factory<LocalDateTime> dateFactory = LocalDateTime::now;\n        return new LazyList<>(new ArrayList<>(), dateFactory);\n    }\n\n    @Test\n    @Override\n    public void testCanonicalEmptyCollectionExists() {\n        // Factory and Transformer are not serializable\n    }\n\n    @Test\n    @Override\n    public void testCanonicalFullCollectionExists() {\n        // Factory and Transformer are not serializable\n    }\n\n    @Test\n    public void testCreateNullGapsWithFactory() {\n        final Factory<LocalDateTime> dateFactory = LocalDateTime::now;\n        final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);\n\n        final LocalDateTime fourthElement = list.get(3);\n        assertFalse(list.isEmpty());\n        assertNotNull(fourthElement);\n    }\n\n    @Test\n    public void testCreateNullGapsWithTransformer() {\n        final List<Integer> hours = Arrays.asList(7, 5, 8, 2);\n        final Transformer<Integer, LocalDateTime> dateFactory = input -> LocalDateTime.now().withHour(hours.get(input));\n        final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);\n\n        final LocalDateTime fourthElement = list.get(3);\n        assertFalse(list.isEmpty());\n        assertNotNull(fourthElement);\n    }\n\n    @Test\n    public void testElementCreationWithFactory() {\n        final Factory<LocalDateTime> dateFactory = LocalDateTime::now;\n        final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);\n\n        assertTrue(list.isEmpty());\n\n        final LocalDateTime firstElement = list.get(0);\n        assertNotNull(firstElement);\n        assertFalse(list.isEmpty());\n    }\n\n    @Test\n    public void testElementCreationWithTransformer() {\n        final Factory<LocalDateTime> dateFactory = LocalDateTime::now;\n        final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);\n\n        assertTrue(list.isEmpty());\n\n        final LocalDateTime firstElement = list.get(0);\n        assertNotNull(firstElement);\n        assertFalse(list.isEmpty());\n    }\n\n    @Test\n    public void testGetWithNull() {\n        final List<Integer> hours = Arrays.asList(7, 5, 8, 2);\n        final Transformer<Integer, LocalDateTime> transformer = input -> LocalDateTime.now().withHour(hours.get(input));\n        final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), transformer);\n        LocalDateTime fourthElement = list.get(3);\n        assertFalse(list.isEmpty());\n        assertNotNull(fourthElement);\n        list.remove(3);\n        list.add(3, null);\n        fourthElement = list.get(3);\n        assertNotNull(fourthElement);\n    }\n\n    @Test\n    @Override\n    public void testSerializeDeserializeThenCompare() {\n        // Factory and Transformer are not serializable\n    }\n\n    @Test\n    @Override\n    public void testSimpleSerialization() {\n        // Factory and Transformer are not serializable\n    }\n\n    private void testSubList(final List<LocalDateTime> list) {\n        List<LocalDateTime> subList = list.subList(1, 3);\n        assertFalse(subList.isEmpty());\n        assertNotNull(subList);\n        assertEquals(2, subList.size());\n\n        subList = list.subList(0, 1);\n        assertFalse(subList.isEmpty());\n        assertEquals(1, subList.size());\n\n        subList = list.subList(1, 1);\n        assertTrue(subList.isEmpty());\n\n        subList = list.subList(0, list.size());\n        assertFalse(subList.isEmpty());\n        assertEquals(list.size(), subList.size());\n    }\n\n    @Test\n    public void testSubListWitheFactory() {\n        final Factory<LocalDateTime> dateFactory = LocalDateTime::now;\n        final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), dateFactory);\n        final LocalDateTime fourthElement = list.get(3);\n        assertFalse(list.isEmpty());\n        assertNotNull(fourthElement);\n        testSubList(list);\n    }\n\n    @Test\n    public void testSubListWithTransformer() {\n        final List<Integer> hours = Arrays.asList(7, 5, 8, 2);\n        final Transformer<Integer, LocalDateTime> transformer = input -> LocalDateTime.now().withHour(hours.get(input));\n        final List<LocalDateTime> list = new LazyList<>(new ArrayList<>(), transformer);\n        final LocalDateTime fourthElement = list.get(3);\n        assertFalse(list.isEmpty());\n        assertNotNull(fourthElement);\n        testSubList(list);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java.SetUniqueListTest", "name": "SetUniqueListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java", "superclasses": "", "methods": ["[void]testAdd()", "[void]testAddAll()", "[void]testCollectionAddAll()", "[void]testCollectionIteratorRemove()", "[void]testCollections304()", "[void]testCollections307()", "[void]testCollections701()", "[void]testCreateSetBasedOnList()", "[void]testFactory()", "[void]testIntCollectionAddAll()", "[void]testListIterator()", "[void]testListIteratorAdd()", "[void]testListIteratorSet()", "[void]testListSetByIndex()", "[void]testRetainAll()", "[void]testRetainAllWithInitialList()", "[void]testSet()", "[void]testSetCollections444()", "[void]testSetDownwardsInList()", "[void]testSetInBiggerList()", "[void]testSetUpwardsInList()", "[void]testSubListIsUnmodifiable()", "[void]testUniqueListDoubleInsert()", "[void]testUniqueListReInsert()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java.SetUniqueListTest.[]SetUniqueListTest()", "src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java.SetUniqueListTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java.SetUniqueListTest.[E[]]getFullNonNullElements()", "src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java.SetUniqueListTest.[List<E>]makeObject()", "src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java.SetUniqueListTest.[void]verify()"], "overrides": null, "attributes": [{"original_string": "    final class SetUniqueList307 extends SetUniqueList<E> {\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = 1415013031022962158L;\n\n        SetUniqueList307(final List<E> list, final Set<E> set) {\n            super(list, set);\n        }\n    }", "definition": "    final class SetUniqueList307 extends SetUniqueList<E>", "class_docstring": "", "name": "SetUniqueList307", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1415013031022962158L;", "docstring": "\nGenerated serial version ID.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1415013031022962158L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SetUniqueList307(final List<E> list, final Set<E> set) {\n            super(list, set);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SetUniqueList307", "params": [{"name": "list", "type": "List<E>"}, {"name": "set", "type": "Set<E>"}], "body": "                                                               {\n            super(list, set);\n        }", "signature": "SetUniqueList307(final List<E> list, final Set<E> set)"}]}], "class_docstring": "\nJUnit tests.\n", "original_string": "public class SetUniqueListTest<E> extends AbstractListTest<E> {\n\n    final class SetUniqueList307 extends SetUniqueList<E> {\n        /**\n         * Generated serial version ID.\n         */\n        private static final long serialVersionUID = 1415013031022962158L;\n\n        SetUniqueList307(final List<E> list, final Set<E> set) {\n            super(list, set);\n        }\n    }\n\n    boolean extraVerify = true;\n\n    public SetUniqueListTest() {\n        super(SetUniqueListTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E[] getFullNonNullElements() {\n        // override to avoid duplicate \"One\"\n        return (E[]) new Object[] {\n            StringUtils.EMPTY,\n            \"One\",\n            Integer.valueOf(2),\n            \"Three\",\n            Integer.valueOf(4),\n            Double.valueOf(5),\n            Float.valueOf(6),\n            \"Seven\",\n            \"Eight\",\n            \"Nine\",\n            Integer.valueOf(10),\n            Short.valueOf((short) 11),\n            Long.valueOf(12),\n            \"Thirteen\",\n            \"14\",\n            \"15\",\n            Byte.valueOf((byte) 16)\n        };\n    }\n\n    @Override\n    public List<E> makeObject() {\n        return new SetUniqueList<>(new ArrayList<>(), new HashSet<>());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAdd() {\n        final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<>(), new HashSet<>());\n\n        // Duplicate element\n        final E obj = (E) Integer.valueOf(1);\n        lset.add(obj);\n        lset.add(obj);\n        assertEquals(1, lset.size(), \"Duplicate element was added.\");\n\n        // Unique element\n        lset.add((E) Integer.valueOf(2));\n        assertEquals(2, lset.size(), \"Unique element was not added.\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddAll() {\n        final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<>(), new HashSet<>());\n\n        lset.addAll(\n            Arrays.asList((E[]) new Integer[] { Integer.valueOf(1), Integer.valueOf(1)}));\n\n        assertEquals(1, lset.size(), \"Duplicate element was added.\");\n    }\n\n    @Test\n    @Override\n    public void testCollectionAddAll() {\n        // override for set behavior\n        resetEmpty();\n        E[] elements = getFullElements();\n        boolean r = getCollection().addAll(Arrays.asList(elements));\n        getConfirmed().addAll(Arrays.asList(elements));\n        verify();\n        assertTrue(r, \"Empty collection should change after addAll\");\n        for (final E element : elements) {\n            assertTrue(getCollection().contains(element),\n                    \"Collection should contain added element\");\n        }\n\n        resetFull();\n        final int size = getCollection().size();\n        elements = getOtherElements();\n        r = getCollection().addAll(Arrays.asList(elements));\n        getConfirmed().addAll(Arrays.asList(elements));\n        verify();\n        assertTrue(r, \"Full collection should change after addAll\");\n        for (int i = 0; i < elements.length; i++) {\n            assertTrue(getCollection().contains(elements[i]),\n                    \"Full collection should contain added element \" + i);\n        }\n        assertEquals(size + elements.length, getCollection().size(),\n                \"Size should increase after addAll\");\n    }\n\n    @Test\n    @Override\n    public void testCollectionIteratorRemove() {\n        try {\n            extraVerify = false;\n            super.testCollectionIteratorRemove();\n        } finally {\n            extraVerify = true;\n        }\n    }\n    @Test\n    public void testCollections304() {\n        final List<String> list = new LinkedList<>();\n        final SetUniqueList<String> decoratedList = SetUniqueList.setUniqueList(list);\n        final String s1 = \"Apple\";\n        final String s2 = \"Lemon\";\n        final String s3 = \"Orange\";\n        final String s4 = \"Strawberry\";\n\n        decoratedList.add(s1);\n        decoratedList.add(s2);\n        decoratedList.add(s3);\n        assertEquals(3, decoratedList.size());\n\n        decoratedList.set(1, s4);\n        assertEquals(3, decoratedList.size());\n\n        decoratedList.add(1, s4);\n        assertEquals(3, decoratedList.size());\n\n        decoratedList.add(1, s2);\n        assertEquals(4, decoratedList.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCollections307() {\n        List<E> list = new ArrayList<>();\n        List<E> uniqueList = SetUniqueList.setUniqueList(list);\n\n        final String hello = \"Hello\";\n        final String world = \"World\";\n        uniqueList.add((E) hello);\n        uniqueList.add((E) world);\n\n        List<E> subList = list.subList(0, 0);\n        List<E> subUniqueList = uniqueList.subList(0, 0);\n\n        assertFalse(subList.contains(world)); // passes\n        assertFalse(subUniqueList.contains(world)); // fails\n\n        List<E> worldList = new ArrayList<>();\n        worldList.add((E) world);\n        assertFalse(subList.contains(\"World\")); // passes\n        assertFalse(subUniqueList.contains(\"World\")); // fails\n\n        // repeat the test with a different class than HashSet;\n        // which means subclassing SetUniqueList below\n        list = new ArrayList<>();\n        uniqueList = new SetUniqueList307(list, new TreeSet<>());\n\n        uniqueList.add((E) hello);\n        uniqueList.add((E) world);\n\n        subList = list.subList(0, 0);\n        subUniqueList = uniqueList.subList(0, 0);\n\n        assertFalse(subList.contains(world)); // passes\n        assertFalse(subUniqueList.contains(world)); // fails\n\n        worldList = new ArrayList<>();\n        worldList.add((E) world);\n        assertFalse(subList.contains(\"World\")); // passes\n        assertFalse(subUniqueList.contains(\"World\")); // fails\n    }\n\n    @Test\n    public void testCollections701() {\n        final SetUniqueList<Object> uniqueList = new SetUniqueList<>(new ArrayList<>(), new HashSet<>());\n        final Integer obj1 = Integer.valueOf(1);\n        final Integer obj2 = Integer.valueOf(2);\n        uniqueList.add(obj1);\n        uniqueList.add(obj2);\n        assertEquals(2, uniqueList.size());\n        uniqueList.add(uniqueList);\n        assertEquals(3, uniqueList.size());\n        final List<Object> list = new LinkedList<>();\n        final SetUniqueList<Object> decoratedList = SetUniqueList.setUniqueList(list);\n        final String s1 = \"Apple\";\n        final String s2 = \"Lemon\";\n        final String s3 = \"Orange\";\n        final String s4 = \"Strawberry\";\n        decoratedList.add(s1);\n        decoratedList.add(s2);\n        decoratedList.add(s3);\n        assertEquals(3, decoratedList.size());\n        decoratedList.set(1, s4);\n        assertEquals(3, decoratedList.size());\n        decoratedList.add(decoratedList);\n        assertEquals(4, decoratedList.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCreateSetBasedOnList() {\n        final List<String> list = new ArrayList<>();\n        list.add(\"One\");\n        list.add(\"Two\");\n        @SuppressWarnings(\"rawtypes\") final SetUniqueList setUniqueList = (SetUniqueList) makeObject();\n\n        // Standard case with HashSet\n        final Set<String> setBasedOnList = setUniqueList.createSetBasedOnList(new HashSet<>(), list);\n        assertEquals(list.size(), setBasedOnList.size());\n        list.forEach(item -> assertTrue(setBasedOnList.contains(item)));\n\n        // Use different Set than HashSet\n        final Set<String> setBasedOnList1 = setUniqueList.createSetBasedOnList(new TreeSet<>(), list);\n        assertEquals(list.size(), setBasedOnList1.size());\n        list.forEach(item -> assertTrue(setBasedOnList1.contains(item)));\n\n        // throws internally NoSuchMethodException --> results in HashSet\n        final Set<String> setBasedOnList2 = setUniqueList.createSetBasedOnList(UnmodifiableSet.unmodifiableSet(new HashSet<>()), list);\n        assertEquals(list.size(), setBasedOnList2.size());\n        list.forEach(item -> assertTrue(setBasedOnList2.contains(item)));\n\n        // provide null values as Parameter\n        assertThrows(NullPointerException.class, () -> setUniqueList.createSetBasedOnList(null, list));\n        assertThrows(NullPointerException.class, () -> setUniqueList.createSetBasedOnList(new HashSet<>(), null));\n    }\n\n    @Test\n    public void testFactory() {\n        final Integer[] array = { Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(1) };\n        final ArrayList<Integer> list = new ArrayList<>(Arrays.asList(array));\n        final SetUniqueList<Integer> lset = SetUniqueList.setUniqueList(list);\n\n        assertEquals(2, lset.size(), \"Duplicate element was added.\");\n        assertEquals(Integer.valueOf(1), lset.get(0));\n        assertEquals(Integer.valueOf(2), lset.get(1));\n        assertEquals(Integer.valueOf(1), list.get(0));\n        assertEquals(Integer.valueOf(2), list.get(1));\n    }\n\n    @Test\n    public void testIntCollectionAddAll() {\n        // make a SetUniqueList with one element\n        final List<Integer> list = new SetUniqueList<>(new ArrayList<>(), new HashSet<>());\n        final Integer existingElement = Integer.valueOf(1);\n        list.add(existingElement);\n\n        // add two new unique elements at index 0\n        final Integer firstNewElement = Integer.valueOf(2);\n        final Integer secondNewElement = Integer.valueOf(3);\n        Collection<Integer> collection = Arrays.asList(firstNewElement, secondNewElement);\n        list.addAll(0, collection);\n        assertEquals(3, list.size(), \"Unique elements should be added.\");\n        assertEquals(firstNewElement, list.get(0), \"First new element should be at index 0\");\n        assertEquals(secondNewElement, list.get(1), \"Second new element should be at index 1\");\n        assertEquals(existingElement, list.get(2), \"Existing element should shift to index 2\");\n\n        // add a duplicate element and a unique element at index 0\n        final Integer thirdNewElement = Integer.valueOf(4);\n        collection = Arrays.asList(existingElement, thirdNewElement);\n        list.addAll(0, collection);\n        assertEquals(4, list.size(),\n                \"Duplicate element should not be added, unique element should be added.\");\n        assertEquals(thirdNewElement, list.get(0), \"Third new element should be at index 0\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListIterator() {\n        final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<>(), new HashSet<>());\n\n        final E obj1 = (E) Integer.valueOf(1);\n        final E obj2 = (E) Integer.valueOf(2);\n        lset.add(obj1);\n        lset.add(obj2);\n\n        // Attempts to add a duplicate object\n        for (final ListIterator<E> it = lset.listIterator(); it.hasNext();) {\n            it.next();\n\n            if (!it.hasNext()) {\n                it.add(obj1);\n                break;\n            }\n        }\n\n        assertEquals(2, lset.size(), \"Duplicate element was added\");\n    }\n\n    @Test\n    @Override\n    public void testListIteratorAdd() {\n        // override to cope with Set behavior\n        resetEmpty();\n        final List<E> list1 = getCollection();\n        final List<E> list2 = getConfirmed();\n\n        final E[] elements = getOtherElements();  // changed here\n        ListIterator<E> iter1 = list1.listIterator();\n        ListIterator<E> iter2 = list2.listIterator();\n\n        for (final E element : elements) {\n            iter1.add(element);\n            iter2.add(element);\n            super.verify();  // changed here\n        }\n\n        resetFull();\n        iter1 = getCollection().listIterator();\n        iter2 = getConfirmed().listIterator();\n        for (final E element : elements) {\n            iter1.next();\n            iter2.next();\n            iter1.add(element);\n            iter2.add(element);\n            super.verify();  // changed here\n        }\n    }\n\n    @Test\n    @Override\n    public void testListIteratorSet() {\n        // override to block\n        resetFull();\n        final ListIterator<E> it = getCollection().listIterator();\n        it.next();\n\n        assertThrows(UnsupportedOperationException.class, () -> it.set(null));\n    }\n\n    @Test\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void testListSetByIndex() {\n        // override for set behavior\n        resetFull();\n        final int size = getCollection().size();\n        getCollection().set(0, (E) Long.valueOf(1000));\n        assertEquals(size, getCollection().size());\n\n        getCollection().set(2, (E) Long.valueOf(1000));\n        assertEquals(size - 1, getCollection().size());\n        assertEquals(Long.valueOf(1000), getCollection().get(1));  // set into 2, but shifted down to 1\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRetainAll() {\n        final List<E> list = new ArrayList<>(10);\n        final SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n        for (int i = 0; i < 10; ++i) {\n            uniqueList.add((E) Integer.valueOf(i));\n        }\n\n        final Collection<E> retained = new ArrayList<>(5);\n        for (int i = 0; i < 5; ++i) {\n            retained.add((E) Integer.valueOf(i * 2));\n        }\n\n        assertTrue(uniqueList.retainAll(retained));\n        assertEquals(5, uniqueList.size());\n        assertTrue(uniqueList.contains(Integer.valueOf(0)));\n        assertTrue(uniqueList.contains(Integer.valueOf(2)));\n        assertTrue(uniqueList.contains(Integer.valueOf(4)));\n        assertTrue(uniqueList.contains(Integer.valueOf(6)));\n        assertTrue(uniqueList.contains(Integer.valueOf(8)));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRetainAllWithInitialList() {\n        // initialized with empty list\n        final List<E> list = new ArrayList<>(10);\n        for (int i = 0; i < 5; ++i) {\n            list.add((E) Integer.valueOf(i));\n        }\n        final SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n        for (int i = 5; i < 10; ++i) {\n            uniqueList.add((E) Integer.valueOf(i));\n        }\n\n        final Collection<E> retained = new ArrayList<>(5);\n        for (int i = 0; i < 5; ++i) {\n            retained.add((E) Integer.valueOf(i * 2));\n        }\n\n        assertTrue(uniqueList.retainAll(retained));\n        assertEquals(5, uniqueList.size());\n        assertTrue(uniqueList.contains(Integer.valueOf(0)));\n        assertTrue(uniqueList.contains(Integer.valueOf(2)));\n        assertTrue(uniqueList.contains(Integer.valueOf(4)));\n        assertTrue(uniqueList.contains(Integer.valueOf(6)));\n        assertTrue(uniqueList.contains(Integer.valueOf(8)));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSet() {\n        final SetUniqueList<E> lset = new SetUniqueList<>(new ArrayList<>(), new HashSet<>());\n\n        // Duplicate element\n        final E obj1 = (E) Integer.valueOf(1);\n        final E obj2 = (E) Integer.valueOf(2);\n        final E obj3 = (E) Integer.valueOf(3);\n\n        lset.add(obj1);\n        lset.add(obj2);\n        lset.set(0, obj1);\n        assertEquals(2, lset.size());\n        assertSame(obj1, lset.get(0));\n        assertSame(obj2, lset.get(1));\n\n        lset.clear();\n        lset.add(obj1);\n        lset.add(obj2);\n        lset.set(0, obj2);\n        assertEquals(1, lset.size());\n        assertSame(obj2, lset.get(0));\n\n        lset.clear();\n        lset.add(obj1);\n        lset.add(obj2);\n        lset.set(0, obj3);\n        assertEquals(2, lset.size());\n        assertSame(obj3, lset.get(0));\n        assertSame(obj2, lset.get(1));\n\n        lset.clear();\n        lset.add(obj1);\n        lset.add(obj2);\n        lset.set(1, obj1);\n        assertEquals(1, lset.size());\n        assertSame(obj1, lset.get(0));\n    }\n\n    @Test\n    public void testSetCollections444() {\n        final SetUniqueList<Integer> lset = new SetUniqueList<>(new ArrayList<>(), new HashSet<>());\n\n        // Duplicate element\n        final Integer obj1 = Integer.valueOf(1);\n        final Integer obj2 = Integer.valueOf(2);\n\n        lset.add(obj1);\n        lset.add(obj2);\n        lset.set(0, obj1);\n        assertEquals(2, lset.size());\n        assertSame(obj1, lset.get(0));\n        assertSame(obj2, lset.get(1));\n\n        assertTrue(lset.contains(obj1));\n        assertTrue(lset.contains(obj2));\n    }\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetDownwardsInList() {\n        /*\n         * Checks the following semantics\n         * [a,b]\n         * set(0,b): [b]->a\n         * So UniqList contains [b] and a is returned\n         */\n        final ArrayList<E> l = new ArrayList<>();\n        final HashSet<E> s = new HashSet<>();\n        final SetUniqueList<E> ul = new SetUniqueList<>(l, s);\n\n        final E a = (E) new Object();\n        final E b = (E) new Object();\n        ul.add(a);\n        ul.add(b);\n        assertEquals(a, l.get(0));\n        assertEquals(b, l.get(1));\n        assertTrue(s.contains(a));\n        assertTrue(s.contains(b));\n\n        assertEquals(a, ul.set(0, b));\n        assertEquals(1, s.size());\n        assertEquals(1, l.size());\n        assertEquals(b, l.get(0));\n        assertTrue(s.contains(b));\n        assertFalse(s.contains(a));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetInBiggerList() {\n        /*\n         * Checks the following semantics\n         * [a,b,c]\n         * set(0,b): [b,c]->a\n         * So UniqList contains [b,c] and a is returned\n         */\n        final ArrayList<E> l = new ArrayList<>();\n        final HashSet<E> s = new HashSet<>();\n        final SetUniqueList<E> ul = new SetUniqueList<>(l, s);\n\n        final E a = (E) new Object();\n        final E b = (E) new Object();\n        final E c = (E) new Object();\n\n        ul.add(a);\n        ul.add(b);\n        ul.add(c);\n        assertEquals(a, l.get(0));\n        assertEquals(b, l.get(1));\n        assertEquals(c, l.get(2));\n        assertTrue(s.contains(a));\n        assertTrue(s.contains(b));\n        assertTrue(s.contains(c));\n\n        assertEquals(a, ul.set(0, b));\n        assertEquals(2, s.size());\n        assertEquals(2, l.size());\n        assertEquals(b, l.get(0));\n        assertEquals(c, l.get(1));\n        assertFalse(s.contains(a));\n        assertTrue(s.contains(b));\n        assertTrue(s.contains(c));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetUpwardsInList() {\n        /*\n         * Checks the following semantics\n         * [a,b,c]\n         * set(1,a): [a,c]->b\n         * So UniqList contains [a,c] and b is returned\n         */\n        final ArrayList<E> l = new ArrayList<>();\n        final HashSet<E> s = new HashSet<>();\n        final SetUniqueList<E> ul = new SetUniqueList<>(l, s);\n\n        final E a = (E) \"A\";\n        final E b = (E) \"B\";\n        final E c = (E) \"C\";\n\n        ul.add(a);\n        ul.add(b);\n        ul.add(c);\n        assertEquals(a, l.get(0));\n        assertEquals(b, l.get(1));\n        assertEquals(c, l.get(2));\n        assertTrue(s.contains(a));\n        assertTrue(s.contains(b));\n        assertTrue(s.contains(c));\n\n        assertEquals(b, ul.set(1, a));\n        assertEquals(2, s.size());\n        assertEquals(2, l.size());\n        assertEquals(a, l.get(0));\n        assertEquals(c, l.get(1));\n        assertTrue(s.contains(a));\n        assertFalse(s.contains(b));\n        assertTrue(s.contains(c));\n    }\n\n    @Test\n    public void testSubListIsUnmodifiable() {\n        resetFull();\n        final List<E> subList = getCollection().subList(1, 3);\n        assertEquals(2, subList.size());\n        assertThrows(UnsupportedOperationException.class, () -> subList.remove(0));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUniqueListDoubleInsert() {\n        final List<E> l = SetUniqueList.setUniqueList(new LinkedList<>());\n        l.add((E) new Object());\n        l.add((E) new Object());\n\n        // duplicate is removed\n        l.set(0, l.get(1));\n        assertEquals(1, l.size());\n\n        // duplicate should be removed again\n        l.add(1, l.get(0));\n        assertEquals(1, l.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUniqueListReInsert() {\n        final List<E> l = SetUniqueList.setUniqueList(new LinkedList<>());\n        l.add((E) new Object());\n        l.add((E) new Object());\n\n        final E a = l.get(0);\n\n        // duplicate is removed\n        l.set(0, l.get(1));\n        assertEquals(1, l.size());\n\n        // old object is added back in\n        l.add(1, a);\n        assertEquals(2, l.size());\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void verify() {\n        super.verify();\n\n        if (extraVerify) {\n            final int size = getCollection().size();\n            getCollection().add((E) Long.valueOf(1000));\n            assertEquals(size + 1, getCollection().size());\n\n            getCollection().add((E) Long.valueOf(1000));\n            assertEquals(size + 1, getCollection().size());\n            assertEquals(Long.valueOf(1000), getCollection().get(size));\n\n            getCollection().remove(size);\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "boolean extraVerify = true;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "extraVerify = true", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest", "name": "UnmodifiableListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java", "superclasses": "", "methods": ["[void]testDecorateFactory()", "[void]testUnmodifiable()", "[void]testUnmodifiableIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest.[]UnmodifiableListTest()", "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest.[boolean]isSetSupported()", "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest.[UnmodifiableList<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest.[UnmodifiableList<E>]makeObject()", "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest.[void]setupList()", "src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java.UnmodifiableListTest.[void]verifyUnmodifiable(List<E>)"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractListTest} for exercising the\n{@link UnmodifiableList} implementation.\n", "original_string": "public class UnmodifiableListTest<E> extends AbstractListTest<E> {\n\n    protected UnmodifiableList<E> list;\n\n    protected ArrayList<E> array;\n\n    public UnmodifiableListTest() {\n        super(UnmodifiableListTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isSetSupported() {\n        return false;\n    }\n    @Override\n    public UnmodifiableList<E> makeFullCollection() {\n        final ArrayList<E> list = new ArrayList<>(Arrays.asList(getFullElements()));\n        return new UnmodifiableList<>(list);\n    }\n\n    @Override\n    public UnmodifiableList<E> makeObject() {\n        return new UnmodifiableList<>(new ArrayList<>());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected void setupList() {\n        list = makeFullCollection();\n        array = new ArrayList<>();\n        array.add((E) Integer.valueOf(1));\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final List<E> list = makeObject();\n        assertSame(list, UnmodifiableList.unmodifiableList(list));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableList.unmodifiableList(null));\n    }\n\n    /**\n     * Verify that base list and sublists are not modifiable\n     */\n    @Test\n    public void testUnmodifiable() {\n        setupList();\n        verifyUnmodifiable(list);\n        verifyUnmodifiable(list.subList(0, 2));\n    }\n\n    /**\n     * Verify that iterator is not modifiable\n     */\n    @Test\n    public void testUnmodifiableIterator() {\n        setupList();\n        final Iterator<E> iterator = list.iterator();\n        iterator.next();\n\n        assertThrows(UnsupportedOperationException.class, () -> iterator.remove(),\n                \"Expecting UnsupportedOperationException.\");\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected void verifyUnmodifiable(final List<E> list) {\n        assertAll(\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.add(0, (E) Integer.valueOf(0)),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.add((E) Integer.valueOf(0)),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.addAll(0, array),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.addAll(array),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.clear(),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.remove(0),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.remove(Integer.valueOf(0)),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.removeAll(array),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.retainAll(array),\n                        \"Expecting UnsupportedOperationException.\"),\n                () -> assertThrows(UnsupportedOperationException.class, () -> list.set(0, (E) Integer.valueOf(0)),\n                        \"Expecting UnsupportedOperationException.\")\n        );\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableList.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableList.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected UnmodifiableList<E> list;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "UnmodifiableList<E>", "name": "list", "syntax_pass": true}, {"attribute_expression": "protected ArrayList<E> array;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ArrayList<E>", "name": "array", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapsTest.java.BitMapsTest", "name": "BitMapsTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapsTest.java", "superclasses": "", "methods": ["[void]testContains()", "[void]testGetLongBit()", "[void]testGetLongIndex()", "[void]testMod()", "[void]testModEdgeCases()", "[void]testNumberOfBitMaps()", "[void]testSet()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BitMapsTest.java.BitMapsTest.[void]assertMod(long,int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BitMapsTest {\n\n    /**\n     * Assert the {@link BitMaps#mod(long, int)} method functions as an unsigned modulus.\n     *\n     * @param dividend the dividend\n     * @param divisor the divisor\n     */\n    private void assertMod(final long dividend, final int divisor) {\n        assertTrue(divisor > 0 && divisor <= Integer.MAX_VALUE,\n            \"Incorrect usage. Divisor must be strictly positive.\");\n        assertEquals((int) Long.remainderUnsigned(dividend, divisor), BitMaps.mod(dividend, divisor),\n            () -> String.format(\"failure with dividend=%s and divisor=%s.\", dividend, divisor));\n    }\n\n    @Test\n    public final void testContains() {\n        final long[] bitMaps = new long[1];\n\n        for (int i = 0; i < 64; i++) {\n            bitMaps[0] = 0L;\n            BitMaps.set(bitMaps, i);\n            for (int j = 0; j < 64; j++) {\n                if (j == i) {\n                    assertTrue(BitMaps.contains(bitMaps, j), String.format(\"Failed at index: %d for %d\", i, j));\n                } else {\n                    assertFalse(BitMaps.contains(bitMaps, j), String.format(\"Failed at index %d for %d\", i, j));\n                }\n            }\n        }\n\n        // test boundary conditions\n        long[] ary = new long[1];\n\n        final long[] aryT = ary;\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMaps.contains(aryT, -1));\n        assertFalse(BitMaps.contains(ary, 0));\n        ary[0] = 0x01;\n        assertTrue(BitMaps.contains(ary, 0));\n\n        assertFalse(BitMaps.contains(ary, 63));\n        ary[0] = 1L << 63;\n        assertTrue(BitMaps.contains(ary, 63));\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMaps.contains(aryT, 64));\n\n        ary = new long[2];\n        assertFalse(BitMaps.contains(ary, 64));\n        ary[1] = 1;\n        assertTrue(BitMaps.contains(ary, 64));\n    }\n\n    @Test\n    public final void testGetLongBit() {\n        assertEquals(1, BitMaps.getLongBit(0));\n        assertEquals(0x8000000000000000L, BitMaps.getLongBit(63));\n        assertEquals(1, BitMaps.getLongBit(64));\n        assertEquals(0x8000000000000000L, BitMaps.getLongBit(127));\n        assertEquals(1, BitMaps.getLongBit(128));\n    }\n\n    @Test\n    public final void testGetLongIndex() {\n        assertEquals(0, BitMaps.getLongIndex(0));\n        assertEquals(0, BitMaps.getLongIndex(63));\n        assertEquals(1, BitMaps.getLongIndex(64));\n        assertEquals(1, BitMaps.getLongIndex(127));\n        assertEquals(2, BitMaps.getLongIndex(128));\n    }\n\n    @Test\n    public void testMod() {\n        for (final long dividend : new long[] {0, -1, -2, -3, -6378683, -23567468136887892L,\n            Long.MIN_VALUE, 345, 678686, 67868768686878924L, Long.MAX_VALUE, Long.MAX_VALUE - 1}) {\n            for (final int divisor : new int[] {1, 2, 3, 5, 13, Integer.MAX_VALUE, Integer.MAX_VALUE - 1}) {\n                assertMod(dividend, divisor);\n            }\n        }\n    }\n\n    @Test\n    public void testModEdgeCases() {\n        for (final long dividend : new long[] {0, -1, 1, Long.MAX_VALUE}) {\n            assertThrows(ArithmeticException.class, () -> BitMaps.mod(dividend, 0));\n        }\n        assertNotEquals(Math.floorMod(5, -1), BitMaps.mod(5, -1));\n    }\n\n    @Test\n    public final void testNumberOfBitMaps() {\n        assertEquals(0, BitMaps.numberOfBitMaps(0), \"Number of bits 0\");\n        for (int i = 1; i < 65; i++) {\n            assertEquals(1, BitMaps.numberOfBitMaps(i), String.format(\"Number of bits %d\", i));\n        }\n        for (int i = 65; i < 129; i++) {\n            assertEquals(2, BitMaps.numberOfBitMaps(i), String.format(\"Number of bits %d\", i));\n        }\n        assertEquals(3, BitMaps.numberOfBitMaps(129), \"Number of bits 129\");\n    }\n\n    @Test\n    public final void testSet() {\n        final long[] bitMaps = new long[BitMaps.numberOfBitMaps(129)];\n        for (int i = 0; i < 129; i++) {\n            BitMaps.set(bitMaps, i);\n            assertTrue(BitMaps.contains(bitMaps, i), String.format(\"Failed at index: %d\", i));\n        }\n        assertEquals(0xFFFFFFFFFFFFFFFFL, bitMaps[0]);\n        assertEquals(0xFFFFFFFFFFFFFFFFL, bitMaps[1]);\n        assertEquals(1L, bitMaps[2]);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java.DefaultIndexExtractorTest", "name": "DefaultIndexExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[void]testEntries(int)", "[void]testFromBitMapExtractor()", "[void]testFromIndexArray()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java.DefaultIndexExtractorTest.[int[]]generateIntArray(int,int)", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java.DefaultIndexExtractorTest.[int[]]unique(int[])", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java.DefaultIndexExtractorTest.[BitSet]uniqueSet(int[])", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java.DefaultIndexExtractorTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java.DefaultIndexExtractorTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java.DefaultIndexExtractorTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java.DefaultIndexExtractorTest.[int[]]getExpectedIndices()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java.DefaultIndexExtractorTest.[int]getForEachIndexBehaviour()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DefaultIndexExtractorTest extends AbstractIndexExtractorTest {\n\n    /**\n     * Generates an array of integers.\n     * @param size the size of the array\n     * @param bound the upper bound (exclusive) of the values in the array.\n     * @return an array of int.\n     */\n    public static int[] generateIntArray(final int size, final int bound) {\n        return ThreadLocalRandom.current().ints(size, 0, bound).toArray();\n    }\n\n    /**\n     * Creates a sorted unique array of ints.\n     * @param ary the array to sort and make unique\n     * @return the sorted unique array.\n     */\n    public static int[] unique(final int[] ary) {\n        return Arrays.stream(ary).distinct().sorted().toArray();\n    }\n\n    /**\n     * Creates a BitSet of indices.\n     * @param ary the array\n     * @return the set.\n     */\n    public static BitSet uniqueSet(final int[] ary) {\n        final BitSet bs = new BitSet();\n        Arrays.stream(ary).forEach(bs::set);\n        return bs;\n    }\n\n    /** Make forEachIndex unordered and contain duplicates. */\n    private final int[] values = {10, 1, 10, 1};\n\n    @Override\n    protected IndexExtractor createEmptyExtractor() {\n        return predicate -> {\n            Objects.requireNonNull(predicate);\n            return true;\n        };\n    }\n\n    @Override\n    protected IndexExtractor createExtractor() {\n        return predicate -> {\n            Objects.requireNonNull(predicate);\n            for (final int i : values) {\n                if (!predicate.test(i)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n\n    @Override\n    protected int getAsIndexArrayBehaviour() {\n        return 0;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return values;\n    }\n\n    @Override\n    protected int getForEachIndexBehaviour() {\n        // the forEachIndex implementation returns unordered duplicates.\n        return 0;\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {32, 33})\n    public void testEntries(final int size) {\n        final int[] values = IntStream.range(0, size).toArray();\n        final IndexExtractor indexExtractor = predicate -> {\n            Objects.requireNonNull(predicate);\n            for (final int i : values) {\n                if (!predicate.test(i)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        final int[] other = indexExtractor.asIndexArray();\n        assertArrayEquals(values, other);\n    }\n\n    @Test\n    public void testFromBitMapExtractor() {\n        for (int i = 0; i < 5; i++) {\n            final int[] expected = generateIntArray(7, 256);\n            final long[] bits = new long[BitMaps.numberOfBitMaps(256)];\n            for (final int bitIndex : expected) {\n                BitMaps.set(bits, bitIndex);\n            }\n            final IndexExtractor ip = IndexExtractor.fromBitMapExtractor(BitMapExtractor.fromBitMapArray(bits));\n            assertArrayEquals(unique(expected), ip.asIndexArray());\n        }\n    }\n\n    @Test\n    public void testFromIndexArray() {\n        for (int i = 0; i < 5; i++) {\n            final int[] expected = generateIntArray(10, 256);\n            final IndexExtractor ip = IndexExtractor.fromIndexArray(expected);\n            assertArrayEquals(expected, ip.asIndexArray());\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final int[] values = {10, 1, 10, 1};", "docstring": " Make forEachIndex unordered and contain duplicates.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "values = {10, 1, 10, 1}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java.EnhancedDoubleHasherTest", "name": "EnhancedDoubleHasherTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java", "superclasses": "AbstractHasherTest", "methods": ["[void]testByteConstructor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java.EnhancedDoubleHasherTest.[Hasher]createEmptyHasher()", "src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java.EnhancedDoubleHasherTest.[Hasher]createHasher()", "src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java.EnhancedDoubleHasherTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java.EnhancedDoubleHasherTest.[int[]]getExpectedIndices()", "src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java.EnhancedDoubleHasherTest.[int]getHasherSize(Hasher)"], "overrides": null, "attributes": [], "class_docstring": "\nTests the {@link EnhancedDoubleHasher}.\n", "original_string": "public class EnhancedDoubleHasherTest extends AbstractHasherTest {\n    int[] expected = {1, 0, 0, 2, 7, 16, 30, 50, 5, 40, 12, 66, 59, 64, 10, 42, 17};\n\n    @Override\n    protected Hasher createEmptyHasher() {\n        return NullHasher.INSTANCE;\n    }\n\n    @Override\n    protected Hasher createHasher() {\n        return new EnhancedDoubleHasher(1, 1);\n    }\n\n    @Override\n    protected int getAsIndexArrayBehaviour() {\n        // Allows duplicates and may be unordered\n        return 0;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return expected;\n    }\n\n    @Override\n    protected int getHasherSize(final Hasher hasher) {\n        return 1;\n    }\n\n    @Test\n    public void testByteConstructor() {\n        // single value become increment.\n        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher(new byte[] {1});\n        assertEquals(0, hasher.getInitial());\n        assertEquals(0x01_00_00_00_00_00_00_00L, hasher.getIncrement());\n\n        // 2 bytes become initial and increment.\n        hasher = new EnhancedDoubleHasher(new byte[] {1, 2});\n        assertEquals(0x01_00_00_00_00_00_00_00L, hasher.getInitial());\n        assertEquals(0x02_00_00_00_00_00_00_00L, hasher.getIncrement());\n\n        // odd values place extra byte in increment.\n        hasher = new EnhancedDoubleHasher(new byte[] {1, 2, 3});\n        assertEquals(0x01_00_00_00_00_00_00_00L, hasher.getInitial());\n        assertEquals(0x02_03_00_00_00_00_00_00L, hasher.getIncrement());\n\n        // even short split\n        hasher = new EnhancedDoubleHasher(new byte[] {0, 1, 0, 2});\n        assertEquals(0x01_00_00_00_00_00_00L, hasher.getInitial());\n        assertEquals(0x02_00_00_00_00_00_00L, hasher.getIncrement());\n\n        // longs are parse correctly\n        hasher = new EnhancedDoubleHasher(new byte[] {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2});\n        assertEquals(1, hasher.getInitial());\n        assertEquals(2, hasher.getIncrement());\n\n        // excess bytes are ignored before mid point and at end\n        hasher = new EnhancedDoubleHasher(new byte[] {0, 0, 0, 0, 0, 0, 0, 1, 5, 5, 0, 0, 0, 0, 0, 0, 0, 2, 5, 5});\n        assertEquals(1, hasher.getInitial());\n        assertEquals(2, hasher.getIncrement());\n\n        // odd extra bytes are accounted for correctly\n        hasher = new EnhancedDoubleHasher(new byte[] {0, 0, 0, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 0, 0, 0, 2, 5, 5});\n        assertEquals(1, hasher.getInitial());\n        assertEquals(0x01_00_00_00_00_00_00_02L, hasher.getIncrement());\n\n        // test empty buffer\n        assertThrows(IllegalArgumentException.class, () -> new EnhancedDoubleHasher(new byte[0]));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "int[] expected = {1, 0, 0, 2, 7, 16, 30, 50, 5, 40, 12, 66, 59, 64, 10, 42, 17};", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "expected = {1, 0, 0, 2, 7, 16, 30, 50, 5, 40, 12, 66, 59, 64, 10, 42, 17}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/ArrayTrackerTest.java.ArrayTrackerTest", "name": "ArrayTrackerTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/ArrayTrackerTest.java", "superclasses": "", "methods": ["[void]testSeen()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests the Filter class.\n", "original_string": "public class ArrayTrackerTest {\n\n    @Test\n    public void testSeen() {\n        final Shape shape = Shape.fromKM(3, 12);\n        final IntPredicate tracker = new IndexFilter.ArrayTracker(shape);\n\n        assertTrue(tracker.test(0));\n        assertFalse(tracker.test(0));\n        assertTrue(tracker.test(1));\n        assertFalse(tracker.test(1));\n        assertTrue(tracker.test(2));\n        assertFalse(tracker.test(2));\n\n        assertThrows(IndexOutOfBoundsException.class, () -> tracker.test(3));\n        assertThrows(IndexOutOfBoundsException.class, () -> tracker.test(-1));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java.IndexExtractorFromBitmapExtractorTest", "name": "IndexExtractorFromBitmapExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[void]testFromBitMapExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java.IndexExtractorFromBitmapExtractorTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java.IndexExtractorFromBitmapExtractorTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java.IndexExtractorFromBitmapExtractorTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java.IndexExtractorFromBitmapExtractorTest.[int[]]getExpectedIndices()"], "overrides": null, "attributes": [{"original_string": "    private static final class TestingBitMapExtractor implements BitMapExtractor {\n        long[] values;\n\n        TestingBitMapExtractor(final long[] values) {\n            this.values = values;\n        }\n\n        @Override\n        public boolean processBitMaps(final LongPredicate consumer) {\n            for (final long l : values) {\n                if (!consumer.test(l)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }", "definition": "    private static final class TestingBitMapExtractor implements BitMapExtractor", "class_docstring": "", "name": "TestingBitMapExtractor", "super_interfaces": ["BitMapExtractor"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "long[] values;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long[]", "name": "values", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TestingBitMapExtractor(final long[] values) {\n            this.values = values;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestingBitMapExtractor", "params": [{"name": "values", "type": "long[]"}], "body": "                                                    {\n            this.values = values;\n        }", "signature": "TestingBitMapExtractor(final long[] values)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean processBitMaps(final LongPredicate consumer) {\n            for (final long l : values) {\n                if (!consumer.test(l)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "processBitMaps", "params": [{"name": "consumer", "type": "LongPredicate"}], "body": "                                                                    {\n            for (final long l : values) {\n                if (!consumer.test(l)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "signature": "@Override\n        public boolean processBitMaps(final LongPredicate consumer)"}]}], "class_docstring": "", "original_string": "public class IndexExtractorFromBitmapExtractorTest extends AbstractIndexExtractorTest {\n\n    private static final class TestingBitMapExtractor implements BitMapExtractor {\n        long[] values;\n\n        TestingBitMapExtractor(final long[] values) {\n            this.values = values;\n        }\n\n        @Override\n        public boolean processBitMaps(final LongPredicate consumer) {\n            for (final long l : values) {\n                if (!consumer.test(l)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    @Override\n    protected IndexExtractor createEmptyExtractor() {\n        final TestingBitMapExtractor testingBitMapExtractor = new TestingBitMapExtractor(new long[0]);\n        return IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);\n    }\n\n    @Override\n    protected IndexExtractor createExtractor() {\n        /* Creates an index testingBitMapExtractor that produces the values:\n         * 0, 65, 128, and 129\n         @formatter:off\n                Index2    Index1     Index0\n         bit       128        64          0\n                     |         |          |\n         1L =>       |         |    ...0001\n         2L =>       |   ...0010\n         3L => ...0011\n         @formatter:on\n         */\n        final TestingBitMapExtractor testingBitMapExtractor = new TestingBitMapExtractor(new long[] {1L, 2L, 3L});\n        return IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);\n    }\n\n    @Override\n    protected int getAsIndexArrayBehaviour() {\n        // Bit maps will be distinct. Conversion to indices should be ordered.\n        return DISTINCT | ORDERED;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return new int[] {0, 65, 128, 129};\n    }\n\n    @Test\n    public final void testFromBitMapExtractor() {\n        IndexExtractor underTest = createExtractor();\n        List<Integer> lst = new ArrayList<>();\n\n        underTest.processIndices(lst::add);\n        assertEquals(4, lst.size());\n        assertEquals(Integer.valueOf(0), lst.get(0));\n        assertEquals(Integer.valueOf(1 + 64), lst.get(1));\n        assertEquals(Integer.valueOf(0 + 128), lst.get(2));\n        assertEquals(Integer.valueOf(1 + 128), lst.get(3));\n\n        final BitMapExtractor bitMapExtractor = new TestingBitMapExtractor(new long[] {0xFFFFFFFFFFFFFFFFL});\n        underTest = IndexExtractor.fromBitMapExtractor(bitMapExtractor);\n        lst = new ArrayList<>();\n\n        underTest.processIndices(lst::add);\n\n        assertEquals(64, lst.size());\n        for (int i = 0; i < 64; i++) {\n            assertEquals(Integer.valueOf(i), lst.get(i));\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java.SetOperationsTest", "name": "SetOperationsTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java", "superclasses": "", "methods": ["[void]testAndCardinality()", "[void]testAndCardinalityWithDifferentLengthFilters()", "[void]testCommutativityOnMismatchedSizes()", "[void]testCosineDistance()", "[void]testCosineSimilarity()", "[void]testHammingDistance()", "[void]testJaccardDistance()", "[void]testJaccardSimilarity()", "[void]testOrCardinality()", "[void]testOrCardinalityWithDifferentLengthFilters()", "[void]testXorCardinality()", "[void]testXorCardinalityWithDifferentLengthFilters()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java.SetOperationsTest.[void]assertSymmetricOperation(double,ToDoubleBiFunction<BloomFilter, BloomFilter>,BloomFilter,BloomFilter)", "src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java.SetOperationsTest.[void]assertSymmetricOperation(int,ToIntBiFunction<BloomFilter, BloomFilter>,BloomFilter,BloomFilter)", "src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java.SetOperationsTest.[BloomFilter]createFilter(Shape,Hasher)", "src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java.SetOperationsTest.[BloomFilter]createFilter(Shape,IndexExtractor)"], "overrides": null, "attributes": [], "class_docstring": "\nTest {@link SetOperations}.\n", "original_string": "public class SetOperationsTest {\n\n    private static void assertSymmetricOperation(final double expected, final ToDoubleBiFunction<BloomFilter, BloomFilter> operation,\n            final BloomFilter filter1, final BloomFilter filter2) {\n        assertEquals(expected, operation.applyAsDouble(filter1, filter2), \"op(filter1, filter2)\");\n        assertEquals(expected, operation.applyAsDouble(filter2, filter1), \"op(filter2, filter1)\");\n    }\n\n    private static void assertSymmetricOperation(final int expected, final ToIntBiFunction<BloomFilter, BloomFilter> operation,\n            final BloomFilter filter1, final BloomFilter filter2) {\n        assertEquals(expected, operation.applyAsInt(filter1, filter2), \"op(filter1, filter2)\");\n        assertEquals(expected, operation.applyAsInt(filter2, filter1), \"op(filter2, filter1)\");\n    }\n\n    private final Shape shape = Shape.fromKM(17, 72);\n\n    private BloomFilter createFilter(final Shape shape, final Hasher hasher) {\n        final BloomFilter bf = new SimpleBloomFilter(shape);\n        bf.merge(hasher);\n        return bf;\n    }\n\n    private BloomFilter createFilter(final Shape shape, final IndexExtractor indexExtractor) {\n        final BloomFilter bf = new SparseBloomFilter(shape);\n        bf.merge(indexExtractor);\n        return bf;\n    }\n\n    @Test\n    public final void testAndCardinality() {\n        final Shape shape = Shape.fromKM(3, 128);\n        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n        BloomFilter filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n        assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n        assertSymmetricOperation(0, SetOperations::andCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n        assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);\n    }\n\n    @Test\n    public final void testAndCardinalityWithDifferentLengthFilters() {\n        final Shape shape = Shape.fromKM(3, 128);\n        final Shape shape2 = Shape.fromKM(3, 192);\n        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n        BloomFilter filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n        assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n        assertSymmetricOperation(0, SetOperations::andCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n        assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);\n    }\n\n    @Test\n    public final void testCommutativityOnMismatchedSizes() {\n        final BitMapExtractor p1 = BitMapExtractor.fromBitMapArray(0x3L, 0x5L);\n        final BitMapExtractor p2 = BitMapExtractor.fromBitMapArray(0x1L);\n\n        assertEquals(SetOperations.orCardinality(p1, p2), SetOperations.orCardinality(p2, p1));\n        assertEquals(SetOperations.xorCardinality(p1, p2), SetOperations.xorCardinality(p2, p1));\n        assertEquals(SetOperations.andCardinality(p1, p2), SetOperations.andCardinality(p2, p1));\n        assertEquals(SetOperations.hammingDistance(p1, p2), SetOperations.hammingDistance(p2, p1));\n        assertEquals(SetOperations.cosineDistance(p1, p2), SetOperations.cosineDistance(p2, p1));\n        assertEquals(SetOperations.cosineSimilarity(p1, p2), SetOperations.cosineSimilarity(p2, p1));\n        assertEquals(SetOperations.jaccardDistance(p1, p2), SetOperations.jaccardDistance(p2, p1));\n        assertEquals(SetOperations.jaccardSimilarity(p1, p2), SetOperations.jaccardSimilarity(p2, p1));\n    }\n\n    /**\n     * Tests that the Cosine similarity is correctly calculated.\n     */\n    @Test\n    public final void testCosineDistance() {\n\n        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n\n        // identical filters should have no distance.\n        double expected = 0;\n        assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);\n\n        final Shape shape2 = Shape.fromKM(2, 72);\n        filter1 = createFilter(shape2, TestingHashers.FROM1);\n        filter2 = createFilter(shape2, new IncrementingHasher(2, 1));\n\n        int dotProduct = /* [1,2] & [2,3] = [2] = */ 1;\n        int cardinalityA = 2;\n        int cardinalityB = 2;\n        expected = 1 - dotProduct / Math.sqrt(cardinalityA * cardinalityB);\n        assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);\n\n        filter1 = createFilter(shape, TestingHashers.FROM1);\n        filter2 = createFilter(shape, TestingHashers.FROM11);\n        dotProduct = /* [1..17] & [11..27] = [] = */ 7;\n        cardinalityA = 17;\n        cardinalityB = 17;\n        expected = 1 - dotProduct / Math.sqrt(cardinalityA * cardinalityB);\n        assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);\n\n        // test with no values\n        filter1 = createFilter(shape, TestingHashers.FROM1);\n        filter2 = new SimpleBloomFilter(shape);\n\n        dotProduct = /* [1,2] & [] = [] = */ 0;\n        cardinalityA = 2;\n        cardinalityB = 0;\n        expected = /* 1 - (dotProduct/Math.sqrt(cardinalityA * cardinalityB)) = */ 1.0;\n        assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);\n\n        dotProduct = /* [] & [] = [] = */ 0;\n        cardinalityA = 0;\n        cardinalityB = 0;\n        expected = /* 1 - (dotProduct/Math.sqrt(cardinalityA * cardinalityB)) = */ 1.0;\n        assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);\n    }\n\n    /**\n     * Tests that the Cosine similarity is correctly calculated.\n     */\n    @Test\n    public final void testCosineSimilarity() {\n        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n\n        int dotProduct = /* [1..17] & [1..17] = [1..17] = */ 17;\n        int cardinalityA = 17;\n        int cardinalityB = 17;\n        double expected = /* dotProduct/Sqrt(cardinalityA * cardinalityB) = */ 1.0;\n        assertSymmetricOperation(expected, SetOperations::cosineSimilarity, filter1, filter2);\n\n        dotProduct = /* [1..17] & [11..27] = [11..17] = */ 7;\n        cardinalityA = 17;\n        cardinalityB = 17;\n        expected = dotProduct / Math.sqrt(cardinalityA * cardinalityB);\n        filter2 = createFilter(shape, TestingHashers.FROM11);\n        assertSymmetricOperation(expected, SetOperations::cosineSimilarity, filter1, filter2);\n\n        // test no values\n        filter1 = new SimpleBloomFilter(shape);\n        filter2 = new SimpleBloomFilter(shape);\n        // build a filter\n        final BloomFilter filter3 = createFilter(shape, TestingHashers.FROM1);\n        assertSymmetricOperation(0.0, SetOperations::cosineSimilarity, filter1, filter2);\n        assertSymmetricOperation(0.0, SetOperations::cosineSimilarity, filter1, filter3);\n    }\n\n    /**\n     * Tests that the Hamming distance is correctly calculated.\n     */\n    @Test\n    public final void testHammingDistance() {\n        final BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n\n        int hammingDistance = /* [1..17] ^ [1..17] = [] = */ 0;\n        assertSymmetricOperation(hammingDistance, SetOperations::hammingDistance, filter1, filter2);\n\n        filter2 = createFilter(shape, TestingHashers.FROM11);\n        hammingDistance = /* [1..17] ^ [11..27] = [1..10][17-27] = */ 20;\n        assertSymmetricOperation(hammingDistance, SetOperations::hammingDistance, filter1, filter2);\n    }\n\n    /**\n     * Tests that the Jaccard distance is correctly calculated.\n     */\n    @Test\n    public final void testJaccardDistance() {\n        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n\n        // 1 - jaccardSimilarity -- see jaccardSimilarityTest\n        assertSymmetricOperation(0.0, SetOperations::jaccardDistance, filter1, filter2);\n\n        filter2 = createFilter(shape, TestingHashers.FROM11);\n        final double intersection = /* [1..17] & [11..27] = [11..17] = */ 7.0;\n        final int union = /* [1..17] | [11..27] = [1..27] = */ 27;\n        final double expected = 1 - intersection / union;\n        assertSymmetricOperation(expected, SetOperations::jaccardDistance, filter1, filter2);\n\n        // test no values\n        filter1 = new SimpleBloomFilter(shape);\n        filter2 = new SimpleBloomFilter(shape);\n        final BloomFilter filter3 = createFilter(shape, TestingHashers.FROM1);\n\n        // 1 - jaccardSimilarity -- see jaccardSimilarityTest\n        assertSymmetricOperation(1.0, SetOperations::jaccardDistance, filter1, filter2);\n        assertSymmetricOperation(1.0, SetOperations::jaccardDistance, filter1, filter3);\n    }\n\n    /**\n     * Tests that the Jaccard similarity is correctly calculated.\n     */\n    @Test\n    public final void testJaccardSimilarity() {\n        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n\n        double intersection = /* [1..17] & [1..17] = [1..17] = */ 17.0;\n        int union = /* [1..17] | [1..17] = [1..17] = */ 17;\n        double expected = intersection / union;\n        assertSymmetricOperation(expected, SetOperations::jaccardSimilarity, filter1, filter2);\n\n        filter2 = createFilter(shape, TestingHashers.FROM11);\n        intersection = /* [1..17] & [11..27] = [11..17] = */ 7.0;\n        union = /* [1..17] | [11..27] = [1..27] = */ 27;\n        expected = intersection / union;\n        assertSymmetricOperation(expected, SetOperations::jaccardSimilarity, filter1, filter2);\n\n        // test no values\n        filter1 = new SimpleBloomFilter(shape);\n        filter2 = new SimpleBloomFilter(shape);\n        assertSymmetricOperation(0.0, SetOperations::jaccardSimilarity, filter1, filter2);\n\n        intersection = /* [] & [1..17] = [] = */ 0.0;\n        union = /* [] | [1..17] = [] = */ 17;\n        expected = intersection / union;\n        assertSymmetricOperation(expected, SetOperations::jaccardSimilarity, filter1, filter2);\n    }\n\n    @Test\n    public final void testOrCardinality() {\n        final Shape shape = Shape.fromKM(3, 128);\n        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n        BloomFilter filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n        assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n        assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n        assertSymmetricOperation(4, SetOperations::orCardinality, filter1, filter2);\n    }\n\n    @Test\n    public final void testOrCardinalityWithDifferentLengthFilters() {\n        final Shape shape = Shape.fromKM(3, 128);\n        final Shape shape2 = Shape.fromKM(3, 192);\n        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n        BloomFilter filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n        assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n        assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n        assertSymmetricOperation(4, SetOperations::orCardinality, filter1, filter2);\n    }\n\n    @Test\n    public final void testXorCardinality() {\n        final Shape shape = Shape.fromKM(3, 128);\n        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n        BloomFilter filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n        assertSymmetricOperation(4, SetOperations::xorCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n        assertSymmetricOperation(5, SetOperations::xorCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n        assertSymmetricOperation(3, SetOperations::xorCardinality, filter1, filter2);\n\n        final Shape bigShape = Shape.fromKM(3, 192);\n        filter1 = createFilter(bigShape, IndexExtractor.fromIndexArray(1, 63, 185));\n        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63, 69));\n        assertSymmetricOperation(4, SetOperations::xorCardinality, filter1, filter2);\n    }\n\n    @Test\n    public final void testXorCardinalityWithDifferentLengthFilters() {\n        final Shape shape = Shape.fromKM(3, 128);\n        final Shape shape2 = Shape.fromKM(3, 192);\n\n        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n        BloomFilter filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n        assertSymmetricOperation(4, SetOperations::xorCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n        assertSymmetricOperation(5, SetOperations::xorCardinality, filter1, filter2);\n\n        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n        assertSymmetricOperation(3, SetOperations::xorCardinality, filter1, filter2);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTrackerTest.java.BitMapTrackerTest", "name": "BitMapTrackerTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTrackerTest.java", "superclasses": "", "methods": ["[void]testSeen()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests the Filter class.\n", "original_string": "public class BitMapTrackerTest {\n\n    @Test\n    public void testSeen() {\n        final Shape shape = Shape.fromKM(3, 12);\n        final IntPredicate tracker = new IndexFilter.BitMapTracker(shape);\n\n        assertTrue(tracker.test(0));\n        assertFalse(tracker.test(0));\n        assertTrue(tracker.test(1));\n        assertFalse(tracker.test(1));\n        assertTrue(tracker.test(2));\n        assertFalse(tracker.test(2));\n\n        assertTrue(tracker.test(4));\n        assertFalse(tracker.test(4));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java.DefaultBitMapExtractorTest", "name": "DefaultBitMapExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java", "superclasses": "AbstractBitMapExtractorTest", "methods": ["[void]testAsBitMapArrayLargeArray()", "[void]testFromBitMapArray()", "[void]testFromIndexExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java.DefaultBitMapExtractorTest.[long[]]generateLongArray(int)", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java.DefaultBitMapExtractorTest.[BitMapExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java.DefaultBitMapExtractorTest.[BitMapExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java.DefaultBitMapExtractorTest.[boolean]emptyIsZeroLength()"], "overrides": null, "attributes": [{"original_string": "    class DefaultBitMapExtractor implements BitMapExtractor {\n        long[] bitMaps;\n\n        DefaultBitMapExtractor(final long[] bitMaps) {\n            this.bitMaps = bitMaps;\n        }\n\n        @Override\n        public boolean processBitMaps(final LongPredicate predicate) {\n            for (final long bitmap : bitMaps) {\n                if (!predicate.test(bitmap)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }", "definition": "    class DefaultBitMapExtractor implements BitMapExtractor", "class_docstring": "", "name": "DefaultBitMapExtractor", "super_interfaces": ["BitMapExtractor"], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "long[] bitMaps;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long[]", "name": "bitMaps", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        DefaultBitMapExtractor(final long[] bitMaps) {\n            this.bitMaps = bitMaps;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DefaultBitMapExtractor", "params": [{"name": "bitMaps", "type": "long[]"}], "body": "                                                     {\n            this.bitMaps = bitMaps;\n        }", "signature": "DefaultBitMapExtractor(final long[] bitMaps)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean processBitMaps(final LongPredicate predicate) {\n            for (final long bitmap : bitMaps) {\n                if (!predicate.test(bitmap)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "processBitMaps", "params": [{"name": "predicate", "type": "LongPredicate"}], "body": "                                                                     {\n            for (final long bitmap : bitMaps) {\n                if (!predicate.test(bitmap)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "signature": "@Override\n        public boolean processBitMaps(final LongPredicate predicate)"}]}], "class_docstring": "", "original_string": "public class DefaultBitMapExtractorTest extends AbstractBitMapExtractorTest {\n\n    class DefaultBitMapExtractor implements BitMapExtractor {\n        long[] bitMaps;\n\n        DefaultBitMapExtractor(final long[] bitMaps) {\n            this.bitMaps = bitMaps;\n        }\n\n        @Override\n        public boolean processBitMaps(final LongPredicate predicate) {\n            for (final long bitmap : bitMaps) {\n                if (!predicate.test(bitmap)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Generates an array of random long values.\n     * @param size the number of values to generate\n     * @return the array of random values.\n     */\n    static long[] generateLongArray(final int size) {\n        return ThreadLocalRandom.current().longs(size).toArray();\n    }\n\n    long[] values = generateLongArray(5);\n\n    @Override\n    protected BitMapExtractor createEmptyExtractor() {\n        return new DefaultBitMapExtractor(new long[0]);\n    }\n\n    @Override\n    protected BitMapExtractor createExtractor() {\n        return new DefaultBitMapExtractor(values);\n    }\n\n    @Override\n    protected boolean emptyIsZeroLength() {\n        return true;\n    }\n\n    @Test\n    public void testAsBitMapArrayLargeArray() {\n        final long[] expected = generateLongArray(32);\n        final BitMapExtractor bitMapExtractor = predicate -> {\n            for (final long l : expected) {\n                if (!predicate.test(l)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        final long[] ary = bitMapExtractor.asBitMapArray();\n        assertArrayEquals(expected, ary);\n    }\n\n    @Test\n    public void testFromBitMapArray() {\n        final int nOfBitMaps = BitMaps.numberOfBitMaps(256);\n        final long[] expected = generateLongArray(nOfBitMaps);\n        final long[] ary = BitMapExtractor.fromBitMapArray(expected).asBitMapArray();\n        assertArrayEquals(expected, ary);\n    }\n\n    @Test\n    public void testFromIndexExtractor() {\n        final int[] expected = DefaultIndexExtractorTest.generateIntArray(10, 256);\n        final IndexExtractor indexExtractor = IndexExtractor.fromIndexArray(expected);\n        final long[] ary = BitMapExtractor.fromIndexExtractor(indexExtractor, 256).asBitMapArray();\n        for (final int idx : expected) {\n            assertTrue(BitMaps.contains(ary, idx));\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "long[] values = generateLongArray(5);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long[]", "name": "values = generateLongArray(5)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java.SparseBloomFilterTest", "name": "SparseBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java", "superclasses": "", "methods": ["[void]testBitMapExtractorEdgeCases()", "[void]testBloomFilterBasedMergeEdgeCases()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java.SparseBloomFilterTest.[SparseBloomFilter]createEmptyFilter(Shape)"], "overrides": null, "attributes": [], "class_docstring": "\nTests for the {@link SparseBloomFilter}.\n", "original_string": "public class SparseBloomFilterTest extends AbstractBloomFilterTest<SparseBloomFilter> {\n    @Override\n    protected SparseBloomFilter createEmptyFilter(final Shape shape) {\n        return new SparseBloomFilter(shape);\n    }\n\n    @Test\n    public void testBitMapExtractorEdgeCases() {\n        int[] values = {1, 2, 3, 4, 5, 6, 7, 8, 9, 65, 66, 67, 68, 69, 70, 71};\n        BloomFilter bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n\n        // verify exit early before bitmap boundary\n        final int[] passes = new int[1];\n        assertFalse(bf.processBitMaps(l -> {\n            passes[0]++;\n            return false;\n        }));\n        assertEquals(1, passes[0]);\n\n        // verify exit early at bitmap boundary\n        bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n        passes[0] = 0;\n        assertFalse(bf.processBitMaps(l -> {\n            final boolean result = passes[0] == 0;\n            if (result) {\n                passes[0]++;\n            }\n            return result;\n        }));\n        assertEquals(1, passes[0]);\n\n        // verify add extra if all values in first bitmap\n        values = new int[] {1, 2, 3, 4};\n        bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n        passes[0] = 0;\n        assertTrue(bf.processBitMaps(l -> {\n            passes[0]++;\n            return true;\n        }));\n        assertEquals(2, passes[0]);\n\n        // verify exit early if all values in first bitmap and predicate returns false\n        // on 2nd block\n        values = new int[] {1, 2, 3, 4};\n        bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n        passes[0] = 0;\n        assertFalse(bf.processBitMaps(l -> {\n            final boolean result = passes[0] == 0;\n            if (result) {\n                passes[0]++;\n            }\n            return result;\n        }));\n        assertEquals(1, passes[0]);\n    }\n\n    @Test\n    public void testBloomFilterBasedMergeEdgeCases() {\n        final BloomFilter bf1 = createEmptyFilter(getTestShape());\n        final BloomFilter bf2 = new SimpleBloomFilter(getTestShape());\n        bf2.merge(TestingHashers.FROM1);\n        bf1.merge(bf2);\n        assertTrue(bf2.processBitMapPairs(bf1, (x, y) -> x == y));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java.BitMapExtractorFromIndexExtractorTest", "name": "BitMapExtractorFromIndexExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java", "superclasses": "AbstractBitMapExtractorTest", "methods": ["[void]testFromIndexExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java.BitMapExtractorFromIndexExtractorTest.[BitMapExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java.BitMapExtractorFromIndexExtractorTest.[BitMapExtractor]createExtractor()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BitMapExtractorFromIndexExtractorTest extends AbstractBitMapExtractorTest {\n\n    @Override\n    protected BitMapExtractor createEmptyExtractor() {\n        final IndexExtractor indexExtractor = consumer -> true;\n        return BitMapExtractor.fromIndexExtractor(indexExtractor, 200);\n    }\n\n    @Override\n    protected BitMapExtractor createExtractor() {\n        final IndexExtractor indexExtractor = consumer -> consumer.test(0) && consumer.test(1) && consumer.test(63) && consumer.test(64)\n                && consumer.test(127) && consumer.test(128);\n        return BitMapExtractor.fromIndexExtractor(indexExtractor, 200);\n    }\n\n    @Test\n    public final void testFromIndexExtractor() {\n        final List<Long> lst = new ArrayList<>();\n        createExtractor().processBitMaps(lst::add);\n        final long[] buckets = lst.stream().mapToLong(Long::longValue).toArray();\n        assertTrue(BitMaps.contains(buckets, 0));\n        assertTrue(BitMaps.contains(buckets, 1));\n        assertTrue(BitMaps.contains(buckets, 63));\n        assertTrue(BitMaps.contains(buckets, 64));\n        assertTrue(BitMaps.contains(buckets, 127));\n        assertTrue(BitMaps.contains(buckets, 128));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java.CountingPredicateTest", "name": "CountingPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java", "superclasses": "", "methods": ["[void]testPredicateLonger()", "[void]testPredicateSameLength()", "[void]testPredicateShorter()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java.CountingPredicateTest.[BiPredicate<Integer, Integer>]makeFunc(BiPredicate<Integer, Integer>,List<Pair<Integer, Integer>>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CountingPredicateTest {\n\n    private final Integer[] ary = {Integer.valueOf(1), Integer.valueOf(2)};\n\n    private BiPredicate<Integer, Integer> makeFunc(final BiPredicate<Integer, Integer> inner, final List<Pair<Integer, Integer>> result) {\n        return (x, y) -> {\n            if (inner.test(x, y)) {\n                result.add(Pair.of(x, y));\n                return true;\n            }\n            return false;\n        };\n    }\n\n    /**\n     * Test when the predicate array is longer than other array as determined by the number\n     * of times cp.test() is called and all other values result in a true statement.\n     */\n    @Test\n    public void testPredicateLonger() {\n        final List<Pair<Integer, Integer>> expected = new ArrayList<>();\n        final List<Pair<Integer, Integer>> result = new ArrayList<>();\n        expected.add(Pair.of(1, 3));\n\n        CountingPredicate<Integer> cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x != null, result));\n        assertTrue(cp.test(Integer.valueOf(3)));\n        assertEquals(expected, result);\n        expected.add(Pair.of(2, null));\n        assertTrue(cp.processRemaining());\n        assertEquals(expected, result);\n\n        // if the other array is zero length then cp.test() will not be called so\n        // we can just call cp.processRemaining() here.\n        expected.clear();\n        expected.add(Pair.of(1, null));\n        expected.add(Pair.of(2, null));\n        result.clear();\n        cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x != null, result));\n        assertTrue(cp.processRemaining());\n        assertEquals(expected, result);\n\n        // If a test fails then the result should be false and the rest of the list should\n        // not be processed.\n        expected.clear();\n        expected.add(Pair.of(1, null));\n        result.clear();\n        cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x == Integer.valueOf(1), result));\n        assertFalse(cp.processRemaining());\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Test when the predicate array is shorter than other array as determined by the number\n     * of times cp.test() is called and all other values result in a true statement.\n     */\n    @Test\n    public void testPredicateSameLength() {\n        final List<Pair<Integer, Integer>> expected = new ArrayList<>();\n        final List<Pair<Integer, Integer>> result = new ArrayList<>();\n        expected.add( Pair.of(1, 3));\n        expected.add( Pair.of(2, 3));\n        final CountingPredicate<Integer> cp = new CountingPredicate<>(ary, makeFunc((x, y) -> true, result));\n        assertTrue(cp.test(3));\n        assertTrue(cp.test(3));\n        assertEquals(expected, result);\n        assertTrue(cp.processRemaining());\n        assertEquals(expected, result);\n    }\n\n    /**\n     * Test when the predicate array is shorter than other array as determined by the number\n     * of times cp.test() is called and all other values result in a true statement.\n     */\n    @Test\n    public void testPredicateShorter() {\n        final List<Pair<Integer, Integer>> expected = new ArrayList<>();\n        final List<Pair<Integer, Integer>> result = new ArrayList<>();\n        final Integer[] shortAry = {Integer.valueOf(3)};\n        expected.add(Pair.of(3, 1));\n        expected.add(Pair.of(null, 2));\n        final CountingPredicate<Integer> cp = new CountingPredicate<>(shortAry, makeFunc((x, y) -> true, result));\n        for (final Integer i : ary) {\n            assertTrue(cp.test(i));\n        }\n        assertEquals(expected, result);\n        assertTrue(cp.processRemaining());\n        assertEquals(expected, result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Integer[] ary = {Integer.valueOf(1), Integer.valueOf(2)};", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer[]", "name": "ary = {Integer.valueOf(1), Integer.valueOf(2)}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java.LayerManagerTest", "name": "LayerManagerTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java", "superclasses": "", "methods": ["[void]testAdvanceOnCount(int)", "[void]testAdvanceOnCountInvalidArguments()", "[void]testAdvanceOnPopulated()", "[void]testAdvanceOnSaturation()", "[void]testBuilder()", "[void]testClear()", "[void]testCopy()", "[void]testForEachBloomFilter()", "[void]testGet()", "[void]testNeverAdvance()", "[void]testNextAndGetDepth()", "[void]testNoCleanup()", "[void]testOnMaxSize(int)", "[void]testOnMaxSizeIllegalValues()", "[void]testRemoveEmptyTarget()", "[void]testTarget()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java.LayerManagerTest.[LayerManager.Builder<BloomFilter>]testingBuilder()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LayerManagerTest {\n\n    private final Shape shape = Shape.fromKM(17, 72);\n\n    @ParameterizedTest\n    @ValueSource(ints = {4, 10, 2, 1})\n    public void testAdvanceOnCount(final int breakAt) {\n        final Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.advanceOnCount(breakAt);\n        final LayerManager<BloomFilter> layerManager = testingBuilder().get();\n        for (int i = 0; i < breakAt - 1; i++) {\n            assertFalse(underTest.test(layerManager), \"at \" + i);\n            layerManager.getTarget().merge(TestingHashers.FROM1);\n        }\n        assertTrue(underTest.test(layerManager));\n    }\n\n    @Test\n    public void testAdvanceOnCountInvalidArguments() {\n        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnCount(0));\n        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnCount(-1));\n    }\n\n    @Test\n    public void testAdvanceOnPopulated() {\n        final Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.advanceOnPopulated();\n        final LayerManager<BloomFilter> layerManager = testingBuilder().get();\n        assertFalse(underTest.test(layerManager));\n        layerManager.getTarget().merge(TestingHashers.FROM1);\n        assertTrue(underTest.test(layerManager));\n    }\n\n    @Test\n    public void testAdvanceOnSaturation() {\n        final double maxN = shape.estimateMaxN();\n        int hashStart = 0;\n        final Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.advanceOnSaturation(maxN);\n        final LayerManager<BloomFilter> layerManager = testingBuilder().get();\n        while (layerManager.getTarget().getShape().estimateN(layerManager.getTarget().cardinality()) < maxN) {\n            assertFalse(underTest.test(layerManager));\n            layerManager.getTarget().merge(new IncrementingHasher(hashStart, shape.getNumberOfHashFunctions()));\n            hashStart += shape.getNumberOfHashFunctions();\n        }\n        assertTrue(underTest.test(layerManager));\n        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnSaturation(0));\n        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnSaturation(-1));\n    }\n\n    @Test\n    public void testBuilder() {\n        final LayerManager.Builder<BloomFilter> underTest = LayerManager.builder();\n        NullPointerException npe = assertThrows(NullPointerException.class, underTest::get);\n        assertTrue(npe.getMessage().contains(\"filterSupplier\"));\n        underTest.setSupplier(() -> null).setCleanup(null);\n        npe = assertThrows(NullPointerException.class, underTest::get);\n        assertTrue(npe.getMessage().contains(\"filterCleanup\"));\n        underTest.setCleanup(x -> {\n        }).setExtendCheck(null);\n        npe = assertThrows(NullPointerException.class, underTest::get);\n        assertTrue(npe.getMessage().contains(\"extendCheck\"));\n\n        npe = assertThrows(NullPointerException.class, () -> LayerManager.builder().setSupplier(() -> null).get());\n        assertTrue(npe.getMessage().contains(\"filterSupplier.get() returned null.\"));\n\n    }\n\n    @Test\n    public void testClear() {\n        final LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).get();\n        underTest.getTarget().merge(TestingHashers.randomHasher());\n        underTest.next();\n        underTest.getTarget().merge(TestingHashers.randomHasher());\n        underTest.next();\n        underTest.getTarget().merge(TestingHashers.randomHasher());\n        assertEquals(3, underTest.getDepth());\n        underTest.clear();\n        assertEquals(1, underTest.getDepth());\n        assertEquals(0, underTest.getTarget().cardinality());\n    }\n\n    @Test\n    public void testCopy() {\n        final LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).get();\n        underTest.getTarget().merge(TestingHashers.randomHasher());\n        underTest.next();\n        underTest.getTarget().merge(TestingHashers.randomHasher());\n        underTest.next();\n        underTest.getTarget().merge(TestingHashers.randomHasher());\n        assertEquals(3, underTest.getDepth());\n\n        final LayerManager<BloomFilter> copy = underTest.copy();\n        assertNotSame(underTest, copy);\n        // object equals not implemented\n        assertNotEquals(underTest, copy);\n\n        assertEquals(underTest.getDepth(), copy.getDepth());\n        assertTrue(\n                underTest.processBloomFilterPair(copy, (x, y) -> Arrays.equals(x.asBitMapArray(), y.asBitMapArray())));\n    }\n\n    @Test\n    public void testForEachBloomFilter() {\n        final LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))\n                .setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated()).get();\n\n        final List<BloomFilter> lst = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            final BloomFilter bf = new SimpleBloomFilter(shape);\n            bf.merge(TestingHashers.randomHasher());\n            lst.add(bf);\n            underTest.getTarget().merge(bf);\n        }\n        final List<BloomFilter> lst2 = new ArrayList<>();\n        underTest.processBloomFilters(lst2::add);\n        assertEquals(10, lst.size());\n        assertEquals(10, lst2.size());\n        for (int i = 0; i < lst.size(); i++) {\n            assertArrayEquals(lst.get(i).asBitMapArray(), lst2.get(i).asBitMapArray());\n        }\n    }\n\n    @Test\n    public void testGet() {\n        final SimpleBloomFilter f = new SimpleBloomFilter(shape);\n        final LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> f).get();\n        assertEquals(1, underTest.getDepth());\n        assertSame(f, underTest.get(0));\n        assertThrows(NoSuchElementException.class, () -> underTest.get(-1));\n        assertThrows(NoSuchElementException.class, () -> underTest.get(1));\n    }\n\n    private LayerManager.Builder<BloomFilter> testingBuilder() {\n        return LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape));\n    }\n\n    @Test\n    public void testNeverAdvance() {\n        final Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.neverAdvance();\n        final LayerManager<BloomFilter> layerManager = testingBuilder().get();\n        assertFalse(underTest.test(layerManager));\n        for (int i = 0; i < 10; i++) {\n            layerManager.getTarget().merge(TestingHashers.randomHasher());\n            assertFalse(underTest.test(layerManager));\n        }\n    }\n\n    @Test\n    public void testNextAndGetDepth() {\n        final LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).get();\n        assertEquals(1, underTest.getDepth());\n        underTest.getTarget().merge(TestingHashers.randomHasher());\n        assertEquals(1, underTest.getDepth());\n        underTest.next();\n        assertEquals(2, underTest.getDepth());\n    }\n\n    @Test\n    public void testNoCleanup() {\n        final Consumer<Deque<BloomFilter>> underTest = LayerManager.Cleanup.noCleanup();\n        final Deque<BloomFilter> list = new LinkedList<>();\n        for (int i = 0; i < 20; i++) {\n            assertEquals(i, list.size());\n            list.add(new SimpleBloomFilter(shape));\n            underTest.accept(list);\n        }\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {5, 100, 2, 1})\n    public void testOnMaxSize(final int maxSize) {\n        final Consumer<Deque<BloomFilter>> underTest = LayerManager.Cleanup.onMaxSize(maxSize);\n        final LinkedList<BloomFilter> list = new LinkedList<>();\n        for (int i = 0; i < maxSize; i++) {\n            assertEquals(i, list.size());\n            list.add(new SimpleBloomFilter(shape));\n            underTest.accept(list);\n        }\n        assertEquals(maxSize, list.size());\n\n        for (int i = 0; i < maxSize; i++) {\n            list.add(new SimpleBloomFilter(shape));\n            underTest.accept(list);\n            assertEquals(maxSize, list.size());\n        }\n    }\n\n    @Test\n    public void testOnMaxSizeIllegalValues() {\n        assertThrows(IllegalArgumentException.class, () -> LayerManager.Cleanup.onMaxSize(0));\n        assertThrows(IllegalArgumentException.class, () -> LayerManager.Cleanup.onMaxSize(-1));\n    }\n\n    @Test\n    public void testRemoveEmptyTarget() {\n        final Consumer<Deque<BloomFilter>> underTest = LayerManager.Cleanup.removeEmptyTarget();\n        final LinkedList<BloomFilter> list = new LinkedList<>();\n\n        // removes an empty filter\n        final BloomFilter bf = new SimpleBloomFilter(shape);\n        list.add(bf);\n        assertEquals(bf, list.get(0));\n        underTest.accept(list);\n        assertTrue(list.isEmpty());\n\n        // does not remove a populated filter.\n        bf.merge(IndexExtractor.fromIndexArray(1));\n        list.add(bf);\n        assertEquals(bf, list.get(0));\n        underTest.accept(list);\n        assertEquals(bf, list.get(0));\n\n        // does not remove an empty filter followed by a populated filter.\n        list.clear();\n        list.add(new SimpleBloomFilter(shape));\n        list.add(bf);\n        assertEquals(2, list.size());\n        underTest.accept(list);\n        assertEquals(2, list.size());\n\n        // does not remove multiple empty filters at the end of the list, just the last\n        // one.\n        list.clear();\n        list.add(bf);\n        list.add(new SimpleBloomFilter(shape));\n        list.add(new SimpleBloomFilter(shape));\n        assertEquals(3, list.size());\n        underTest.accept(list);\n        assertEquals(2, list.size());\n        assertEquals(bf, list.get(0));\n    }\n\n    @Test\n    public void testTarget() {\n        final boolean[] extendCheckCalled = { false };\n        final boolean[] cleanupCalled = { false };\n        final int[] supplierCount = { 0 };\n        final LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> {\n            supplierCount[0]++;\n            return new SimpleBloomFilter(shape);\n        }).setExtendCheck(lm -> {\n            extendCheckCalled[0] = true;\n            return true;\n        }).setCleanup(ll -> {\n            cleanupCalled[0] = true;\n        }).get();\n        assertFalse(extendCheckCalled[0]);\n        assertFalse(cleanupCalled[0]);\n        assertEquals(1, supplierCount[0]);\n        underTest.getTarget();\n        assertTrue(extendCheckCalled[0]);\n        assertTrue(cleanupCalled[0]);\n        assertEquals(2, supplierCount[0]);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java.DefaultBloomFilterTest", "name": "DefaultBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java", "superclasses": "", "methods": ["[void]testDefaultBloomFilterSimpleSpecificMerge()", "[void]testDefaultBloomFilterSparseSpecificMerge()", "[void]testEstimateLargeN()", "[void]testEstimateNWithBrokenCardinality()", "[void]testHasherBasedMergeWithDifferingSparseness()", "[void]testIntersectionLimit()", "[void]testSparseNonSparseMerging()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java.DefaultBloomFilterTest.[AbstractDefaultBloomFilter]createEmptyFilter(Shape)"], "overrides": null, "attributes": [{"original_string": "    abstract static class AbstractDefaultBloomFilter implements BloomFilter {\n        private final Shape shape;\n        protected TreeSet<Integer> indices;\n\n        AbstractDefaultBloomFilter(final Shape shape) {\n            this.shape = shape;\n            this.indices = new TreeSet<>();\n        }\n\n        @Override\n        public int cardinality() {\n            return indices.size();\n        }\n\n        private void checkIndicesRange() {\n            if (!indices.isEmpty()) {\n                if (indices.last() >= shape.getNumberOfBits()) {\n                    throw new IllegalArgumentException(\n                        String.format(\"Value in list %s is greater than maximum value (%s)\", indices.last(),\n                            shape.getNumberOfBits()));\n                }\n                if (indices.first() < 0) {\n                    throw new IllegalArgumentException(\n                        String.format(\"Value in list %s is less than 0\", indices.first()));\n                }\n            }\n        }\n\n        @Override\n        public void clear() {\n            indices.clear();\n        }\n\n        @Override\n        public boolean contains(final BitMapExtractor bitMapExtractor) {\n            return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n        }\n\n        @Override\n        public boolean contains(final IndexExtractor indexExtractor) {\n            return indexExtractor.processIndices(indices::contains);\n        }\n\n        @Override\n        public Shape getShape() {\n            return shape;\n        }\n\n        @Override\n        public boolean merge(final BitMapExtractor bitMapExtractor) {\n            return merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n        }\n\n        @Override\n        public boolean merge(final IndexExtractor indexExtractor) {\n            final boolean result = indexExtractor.processIndices(x -> {\n                indices.add(x);\n                return true;\n            });\n            checkIndicesRange();\n            return result;\n        }\n\n        @Override\n        public boolean processBitMaps(final LongPredicate consumer) {\n            return BitMapExtractor.fromIndexExtractor(this, shape.getNumberOfBits()).processBitMaps(consumer);\n        }\n\n        @Override\n        public boolean processIndices(final IntPredicate consumer) {\n            for (final Integer i : indices) {\n                if (!consumer.test(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }", "definition": "    abstract static class AbstractDefaultBloomFilter implements BloomFilter", "class_docstring": "", "name": "AbstractDefaultBloomFilter", "super_interfaces": ["BloomFilter"], "superclasses": "", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [{"attribute_expression": "private final Shape shape;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shape", "name": "shape", "syntax_pass": true}, {"attribute_expression": "protected TreeSet<Integer> indices;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TreeSet<Integer>", "name": "indices", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        AbstractDefaultBloomFilter(final Shape shape) {\n            this.shape = shape;\n            this.indices = new TreeSet<>();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AbstractDefaultBloomFilter", "params": [{"name": "shape", "type": "Shape"}], "body": "                                                      {\n            this.shape = shape;\n            this.indices = new TreeSet<>();\n        }", "signature": "AbstractDefaultBloomFilter(final Shape shape)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int cardinality() {\n            return indices.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "cardinality", "params": [], "body": "                                 {\n            return indices.size();\n        }", "signature": "@Override\n        public int cardinality()"}, {"syntax_pass": true, "original_string": "        private void checkIndicesRange() {\n            if (!indices.isEmpty()) {\n                if (indices.last() >= shape.getNumberOfBits()) {\n                    throw new IllegalArgumentException(\n                        String.format(\"Value in list %s is greater than maximum value (%s)\", indices.last(),\n                            shape.getNumberOfBits()));\n                }\n                if (indices.first() < 0) {\n                    throw new IllegalArgumentException(\n                        String.format(\"Value in list %s is less than 0\", indices.first()));\n                }\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "checkIndicesRange", "params": [], "body": "                                         {\n            if (!indices.isEmpty()) {\n                if (indices.last() >= shape.getNumberOfBits()) {\n                    throw new IllegalArgumentException(\n                        String.format(\"Value in list %s is greater than maximum value (%s)\", indices.last(),\n                            shape.getNumberOfBits()));\n                }\n                if (indices.first() < 0) {\n                    throw new IllegalArgumentException(\n                        String.format(\"Value in list %s is less than 0\", indices.first()));\n                }\n            }\n        }", "signature": "private void checkIndicesRange()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            indices.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            indices.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final BitMapExtractor bitMapExtractor) {\n            return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "bitMapExtractor", "type": "BitMapExtractor"}], "body": "                                                                       {\n            return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n        }", "signature": "@Override\n        public boolean contains(final BitMapExtractor bitMapExtractor)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final IndexExtractor indexExtractor) {\n            return indexExtractor.processIndices(indices::contains);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "indexExtractor", "type": "IndexExtractor"}], "body": "                                                                     {\n            return indexExtractor.processIndices(indices::contains);\n        }", "signature": "@Override\n        public boolean contains(final IndexExtractor indexExtractor)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Shape getShape() {\n            return shape;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Shape", "classes": []}, "name": "getShape", "params": [], "body": "                                {\n            return shape;\n        }", "signature": "@Override\n        public Shape getShape()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean merge(final BitMapExtractor bitMapExtractor) {\n            return merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "merge", "params": [{"name": "bitMapExtractor", "type": "BitMapExtractor"}], "body": "                                                                    {\n            return merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n        }", "signature": "@Override\n        public boolean merge(final BitMapExtractor bitMapExtractor)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean merge(final IndexExtractor indexExtractor) {\n            final boolean result = indexExtractor.processIndices(x -> {\n                indices.add(x);\n                return true;\n            });\n            checkIndicesRange();\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "merge", "params": [{"name": "indexExtractor", "type": "IndexExtractor"}], "body": "                                                                  {\n            final boolean result = indexExtractor.processIndices(x -> {\n                indices.add(x);\n                return true;\n            });\n            checkIndicesRange();\n            return result;\n        }", "signature": "@Override\n        public boolean merge(final IndexExtractor indexExtractor)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean processBitMaps(final LongPredicate consumer) {\n            return BitMapExtractor.fromIndexExtractor(this, shape.getNumberOfBits()).processBitMaps(consumer);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "processBitMaps", "params": [{"name": "consumer", "type": "LongPredicate"}], "body": "                                                                    {\n            return BitMapExtractor.fromIndexExtractor(this, shape.getNumberOfBits()).processBitMaps(consumer);\n        }", "signature": "@Override\n        public boolean processBitMaps(final LongPredicate consumer)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean processIndices(final IntPredicate consumer) {\n            for (final Integer i : indices) {\n                if (!consumer.test(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "processIndices", "params": [{"name": "consumer", "type": "IntPredicate"}], "body": "                                                                   {\n            for (final Integer i : indices) {\n                if (!consumer.test(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "signature": "@Override\n        public boolean processIndices(final IntPredicate consumer)"}]}, {"original_string": "    static class BrokenCardinality extends NonSparseDefaultBloomFilter {\n\n        BrokenCardinality(final Shape shape) {\n            super(shape);\n        }\n\n        @Override\n        public int cardinality() {\n            return super.cardinality() + 1;\n        }\n    }", "definition": "    static class BrokenCardinality extends NonSparseDefaultBloomFilter", "class_docstring": "", "name": "BrokenCardinality", "super_interfaces": [], "superclasses": "NonSparseDefaultBloomFilter", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        BrokenCardinality(final Shape shape) {\n            super(shape);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "BrokenCardinality", "params": [{"name": "shape", "type": "Shape"}], "body": "                                             {\n            super(shape);\n        }", "signature": "BrokenCardinality(final Shape shape)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int cardinality() {\n            return super.cardinality() + 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "cardinality", "params": [], "body": "                                 {\n            return super.cardinality() + 1;\n        }", "signature": "@Override\n        public int cardinality()"}]}, {"original_string": "    public static class NonSparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n\n        public NonSparseDefaultBloomFilter(final Shape shape) {\n            super(shape);\n        }\n\n        @Override\n        public int characteristics() {\n            return 0;\n        }\n\n        @Override\n        public AbstractDefaultBloomFilter copy() {\n            final AbstractDefaultBloomFilter result = new NonSparseDefaultBloomFilter(getShape());\n            result.indices.addAll(indices);\n            return result;\n        }\n    }", "definition": "    public static class NonSparseDefaultBloomFilter extends AbstractDefaultBloomFilter", "class_docstring": "\nA default implementation of a non-sparse Bloom filter.\n", "name": "NonSparseDefaultBloomFilter", "super_interfaces": [], "superclasses": "AbstractDefaultBloomFilter", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public NonSparseDefaultBloomFilter(final Shape shape) {\n            super(shape);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "NonSparseDefaultBloomFilter", "params": [{"name": "shape", "type": "Shape"}], "body": "                                                              {\n            super(shape);\n        }", "signature": "public NonSparseDefaultBloomFilter(final Shape shape)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int characteristics() {\n            return 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "characteristics", "params": [], "body": "                                     {\n            return 0;\n        }", "signature": "@Override\n        public int characteristics()"}, {"syntax_pass": true, "original_string": "        @Override\n        public AbstractDefaultBloomFilter copy() {\n            final AbstractDefaultBloomFilter result = new NonSparseDefaultBloomFilter(getShape());\n            result.indices.addAll(indices);\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AbstractDefaultBloomFilter", "classes": []}, "name": "copy", "params": [], "body": "                                                 {\n            final AbstractDefaultBloomFilter result = new NonSparseDefaultBloomFilter(getShape());\n            result.indices.addAll(indices);\n            return result;\n        }", "signature": "@Override\n        public AbstractDefaultBloomFilter copy()"}]}, {"original_string": "    public static class SparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n\n        public SparseDefaultBloomFilter(final Shape shape) {\n            super(shape);\n        }\n\n        @Override\n        public int characteristics() {\n            return SPARSE;\n        }\n\n        @Override\n        public AbstractDefaultBloomFilter copy() {\n            final AbstractDefaultBloomFilter result = new SparseDefaultBloomFilter(getShape());\n            result.indices.addAll(indices);\n            return result;\n        }\n    }", "definition": "    public static class SparseDefaultBloomFilter extends AbstractDefaultBloomFilter", "class_docstring": "\nA default implementation of a Sparse bloom filter.\n", "name": "SparseDefaultBloomFilter", "super_interfaces": [], "superclasses": "AbstractDefaultBloomFilter", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public SparseDefaultBloomFilter(final Shape shape) {\n            super(shape);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SparseDefaultBloomFilter", "params": [{"name": "shape", "type": "Shape"}], "body": "                                                           {\n            super(shape);\n        }", "signature": "public SparseDefaultBloomFilter(final Shape shape)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int characteristics() {\n            return SPARSE;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "characteristics", "params": [], "body": "                                     {\n            return SPARSE;\n        }", "signature": "@Override\n        public int characteristics()"}, {"syntax_pass": true, "original_string": "        @Override\n        public AbstractDefaultBloomFilter copy() {\n            final AbstractDefaultBloomFilter result = new SparseDefaultBloomFilter(getShape());\n            result.indices.addAll(indices);\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "AbstractDefaultBloomFilter", "classes": []}, "name": "copy", "params": [], "body": "                                                 {\n            final AbstractDefaultBloomFilter result = new SparseDefaultBloomFilter(getShape());\n            result.indices.addAll(indices);\n            return result;\n        }", "signature": "@Override\n        public AbstractDefaultBloomFilter copy()"}]}], "class_docstring": "\nTests for the {@link BloomFilter}.\n", "original_string": "public class DefaultBloomFilterTest extends AbstractBloomFilterTest<DefaultBloomFilterTest.AbstractDefaultBloomFilter> {\n    abstract static class AbstractDefaultBloomFilter implements BloomFilter {\n        private final Shape shape;\n        protected TreeSet<Integer> indices;\n\n        AbstractDefaultBloomFilter(final Shape shape) {\n            this.shape = shape;\n            this.indices = new TreeSet<>();\n        }\n\n        @Override\n        public int cardinality() {\n            return indices.size();\n        }\n\n        private void checkIndicesRange() {\n            if (!indices.isEmpty()) {\n                if (indices.last() >= shape.getNumberOfBits()) {\n                    throw new IllegalArgumentException(\n                        String.format(\"Value in list %s is greater than maximum value (%s)\", indices.last(),\n                            shape.getNumberOfBits()));\n                }\n                if (indices.first() < 0) {\n                    throw new IllegalArgumentException(\n                        String.format(\"Value in list %s is less than 0\", indices.first()));\n                }\n            }\n        }\n\n        @Override\n        public void clear() {\n            indices.clear();\n        }\n\n        @Override\n        public boolean contains(final BitMapExtractor bitMapExtractor) {\n            return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n        }\n\n        @Override\n        public boolean contains(final IndexExtractor indexExtractor) {\n            return indexExtractor.processIndices(indices::contains);\n        }\n\n        @Override\n        public Shape getShape() {\n            return shape;\n        }\n\n        @Override\n        public boolean merge(final BitMapExtractor bitMapExtractor) {\n            return merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n        }\n\n        @Override\n        public boolean merge(final IndexExtractor indexExtractor) {\n            final boolean result = indexExtractor.processIndices(x -> {\n                indices.add(x);\n                return true;\n            });\n            checkIndicesRange();\n            return result;\n        }\n\n        @Override\n        public boolean processBitMaps(final LongPredicate consumer) {\n            return BitMapExtractor.fromIndexExtractor(this, shape.getNumberOfBits()).processBitMaps(consumer);\n        }\n\n        @Override\n        public boolean processIndices(final IntPredicate consumer) {\n            for (final Integer i : indices) {\n                if (!consumer.test(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    static class BrokenCardinality extends NonSparseDefaultBloomFilter {\n\n        BrokenCardinality(final Shape shape) {\n            super(shape);\n        }\n\n        @Override\n        public int cardinality() {\n            return super.cardinality() + 1;\n        }\n    }\n\n    /**\n     * A default implementation of a non-sparse Bloom filter.\n     */\n    public static class NonSparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n\n        public NonSparseDefaultBloomFilter(final Shape shape) {\n            super(shape);\n        }\n\n        @Override\n        public int characteristics() {\n            return 0;\n        }\n\n        @Override\n        public AbstractDefaultBloomFilter copy() {\n            final AbstractDefaultBloomFilter result = new NonSparseDefaultBloomFilter(getShape());\n            result.indices.addAll(indices);\n            return result;\n        }\n    }\n\n    /**\n     * A default implementation of a Sparse bloom filter.\n     */\n    public static class SparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n\n        public SparseDefaultBloomFilter(final Shape shape) {\n            super(shape);\n        }\n\n        @Override\n        public int characteristics() {\n            return SPARSE;\n        }\n\n        @Override\n        public AbstractDefaultBloomFilter copy() {\n            final AbstractDefaultBloomFilter result = new SparseDefaultBloomFilter(getShape());\n            result.indices.addAll(indices);\n            return result;\n        }\n    }\n\n    @Override\n    protected AbstractDefaultBloomFilter createEmptyFilter(final Shape shape) {\n        return new SparseDefaultBloomFilter(shape);\n    }\n\n    @Test\n    public void testDefaultBloomFilterSimpleSpecificMerge() {\n        final AbstractDefaultBloomFilter filter = new SparseDefaultBloomFilter(Shape.fromKM(3, 150));\n        final Hasher hasher = new IncrementingHasher(0, 1);\n        assertTrue(filter.merge(hasher));\n        assertEquals(3, filter.cardinality());\n    }\n\n    @Test\n    public void testDefaultBloomFilterSparseSpecificMerge() {\n        final Shape shape = Shape.fromKM(3, 150);\n        final AbstractDefaultBloomFilter filter = new SparseDefaultBloomFilter(shape);\n        final AbstractDefaultBloomFilter filter2 = createFilter(shape, new IncrementingHasher(0, 1));\n        final BloomFilter newFilter = filter.copy();\n        newFilter.merge(filter2);\n        assertEquals(3, newFilter.cardinality());\n    }\n\n    @Test\n    public void testEstimateLargeN() {\n        final Shape s = Shape.fromKM(1, Integer.MAX_VALUE);\n        // create a very large filter with Integer.MAX_VALUE-1 bits set.\n        final BloomFilter bf1 = new SimpleBloomFilter(s);\n        bf1.merge((BitMapExtractor) predicate -> {\n            int limit = Integer.MAX_VALUE - 1;\n            while (limit > 64) {\n                predicate.test(0xFFFFFFFFFFFFFFFFL);\n                limit -= 64;\n            }\n            long last = 0L;\n            for (int i = 0; i < limit; i++) {\n                last |= BitMaps.getLongBit(i);\n            }\n            predicate.test(last);\n            return true;\n        });\n        // the actual result of the calculation is: 46144189292, so the returned value\n        // should be Integer.MAX_VALUE.\n        assertEquals(Integer.MAX_VALUE, bf1.estimateN());\n    }\n\n    @Test\n    public void testEstimateNWithBrokenCardinality() {\n        // build a filter\n        final BloomFilter filter1 = TestingHashers.populateEntireFilter(new BrokenCardinality(getTestShape()));\n        assertThrows(IllegalArgumentException.class, () -> filter1.estimateN());\n    }\n\n    @Test\n    public void testHasherBasedMergeWithDifferingSparseness() {\n        final Hasher hasher = new IncrementingHasher(1, 1);\n\n        BloomFilter bf1 = new NonSparseDefaultBloomFilter(getTestShape());\n        bf1.merge(hasher);\n        assertTrue(BitMapExtractor.fromIndexExtractor(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())\n                .processBitMapPairs(bf1, (x, y) -> x == y));\n\n        bf1 = new SparseDefaultBloomFilter(getTestShape());\n        bf1.merge(hasher);\n        assertTrue(BitMapExtractor.fromIndexExtractor(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())\n                .processBitMapPairs(bf1, (x, y) -> x == y));\n    }\n\n    @Test\n    public void testIntersectionLimit() {\n        final Shape s = Shape.fromKM(1, Integer.MAX_VALUE);\n        // create a very large filter with Integer.MAX_VALUE-1 bit set.\n        final BloomFilter bf1 = new SimpleBloomFilter(s);\n        bf1.merge((BitMapExtractor) predicate -> {\n            int limit = Integer.MAX_VALUE - 1;\n            while (limit > 64) {\n                predicate.test(0xFFFFFFFFFFFFFFFFL);\n                limit -= 64;\n            }\n            long last = 0L;\n            for (int i = 0; i < limit; i++) {\n                last |= BitMaps.getLongBit(i);\n            }\n            predicate.test(last);\n            return true;\n        });\n        // the actual result of the calculation is: 46144189292\n        assertEquals(Integer.MAX_VALUE, bf1.estimateIntersection(bf1));\n    }\n\n    @Test\n    public void testSparseNonSparseMerging() {\n        final BloomFilter bf1 = new SparseDefaultBloomFilter(getTestShape());\n        bf1.merge(TestingHashers.FROM1);\n        final BloomFilter bf2 = new NonSparseDefaultBloomFilter(getTestShape());\n        bf2.merge(TestingHashers.FROM11);\n\n        BloomFilter result = bf1.copy();\n        result.merge(bf2);\n        assertEquals(27, result.cardinality());\n\n        result = bf2.copy();\n        result.merge(bf1);\n        assertEquals(27, result.cardinality());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java.SimpleBloomFilterTest", "name": "SimpleBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java", "superclasses": "", "methods": ["[void]testMergeShortBitMapExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java.SimpleBloomFilterTest.[SimpleBloomFilter]createEmptyFilter(Shape)"], "overrides": null, "attributes": [], "class_docstring": "\nTests for the {@link SimpleBloomFilter}.\n", "original_string": "public class SimpleBloomFilterTest extends AbstractBloomFilterTest<SimpleBloomFilter> {\n    @Override\n    protected SimpleBloomFilter createEmptyFilter(final Shape shape) {\n        return new SimpleBloomFilter(shape);\n    }\n\n    @Test\n    public void testMergeShortBitMapExtractor() {\n        final SimpleBloomFilter filter = createEmptyFilter(getTestShape());\n        // create a bitMapExtractor that returns too few values\n        // shape expects 2 longs we are sending 1.\n        final BitMapExtractor bitMapExtractor = p -> p.test(2L);\n        assertTrue(filter.merge(bitMapExtractor));\n        assertEquals(1, filter.cardinality());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexFilterTest.java.IndexFilterTest", "name": "IndexFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexFilterTest.java", "superclasses": "", "methods": ["[void]testFilter(int,int)", "[void]testFiltering()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests the Filter class.\n", "original_string": "public class IndexFilterTest {\n\n    @ParameterizedTest\n    @CsvSource({\n        \"1, 64\",\n        \"2, 64\",\n        \"3, 64\",\n        \"7, 357\",\n        \"7, 17\",\n    })\n    void testFilter(final int k, final int m) {\n        final Shape shape = Shape.fromKM(k, m);\n        final BitSet used = new BitSet(m);\n        for (int n = 0; n < 10; n++) {\n            used.clear();\n            final List<Integer> consumer = new ArrayList<>();\n            final IntPredicate filter = IndexFilter.create(shape, consumer::add);\n\n            // Make random indices; these may be duplicates\n            final long seed = ThreadLocalRandom.current().nextLong();\n            final SplittableRandom rng = new SplittableRandom(seed);\n            for (int i = Math.min(k, m / 2); i-- > 0;) {\n                final int bit = rng.nextInt(m);\n                // duplicates should not alter the list size\n                final int newSize = consumer.size() + (used.get(bit) ? 0 : 1);\n                assertTrue(filter.test(bit));\n                assertEquals(newSize, consumer.size(), () -> String.format(\"Bad filter. Seed=%d, bit=%d\", seed, bit));\n                used.set(bit);\n            }\n\n            // The list should have unique entries\n            assertArrayEquals(used.stream().toArray(), consumer.stream().mapToInt(i -> (int) i).sorted().toArray());\n            final int size = consumer.size();\n\n            // Second observations do not change the list size\n            used.stream().forEach(bit -> {\n                assertTrue(filter.test(bit));\n                assertEquals(size, consumer.size(), () -> String.format(\"Bad filter. Seed=%d, bit=%d\", seed, bit));\n            });\n\n            assertThrows(IndexOutOfBoundsException.class, () -> filter.test(m));\n            assertThrows(IndexOutOfBoundsException.class, () -> filter.test(-1));\n        }\n    }\n\n    @Test\n    public void testFiltering() {\n        final Shape shape = Shape.fromKM(3, 12);\n        final List<Integer> consumer = new ArrayList<>();\n        final IntPredicate filter = IndexFilter.create(shape, consumer::add);\n\n        for (int i = 0; i < 12; i++) {\n            assertTrue(filter.test(i));\n        }\n        assertEquals(12, consumer.size());\n\n        for (int i = 0; i < 12; i++) {\n            assertTrue(filter.test(i));\n        }\n        assertEquals(12, consumer.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorTest.java.IndexExtractorTest", "name": "IndexExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorTest.java", "superclasses": "", "methods": ["[void]testAsIndexArray(int)", "[void]testFromBitMapExtractor()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    private static final class TestingBitMapExtractor implements BitMapExtractor {\n        long[] values;\n\n        TestingBitMapExtractor(final long[] values) {\n            this.values = values;\n        }\n\n        @Override\n        public boolean processBitMaps(final LongPredicate consumer) {\n            for (final long l : values) {\n                if (!consumer.test(l)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }", "definition": "    private static final class TestingBitMapExtractor implements BitMapExtractor", "class_docstring": "", "name": "TestingBitMapExtractor", "super_interfaces": ["BitMapExtractor"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "long[] values;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long[]", "name": "values", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TestingBitMapExtractor(final long[] values) {\n            this.values = values;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestingBitMapExtractor", "params": [{"name": "values", "type": "long[]"}], "body": "                                                    {\n            this.values = values;\n        }", "signature": "TestingBitMapExtractor(final long[] values)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean processBitMaps(final LongPredicate consumer) {\n            for (final long l : values) {\n                if (!consumer.test(l)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "processBitMaps", "params": [{"name": "consumer", "type": "LongPredicate"}], "body": "                                                                    {\n            for (final long l : values) {\n                if (!consumer.test(l)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "signature": "@Override\n        public boolean processBitMaps(final LongPredicate consumer)"}]}], "class_docstring": "", "original_string": "public class IndexExtractorTest {\n\n    private static final class TestingBitMapExtractor implements BitMapExtractor {\n        long[] values;\n\n        TestingBitMapExtractor(final long[] values) {\n            this.values = values;\n        }\n\n        @Override\n        public boolean processBitMaps(final LongPredicate consumer) {\n            for (final long l : values) {\n                if (!consumer.test(l)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {32, 33})\n    void testAsIndexArray(final int n) {\n        final IndexExtractor ip = i -> {\n            for (int j = 0; j < n; j++) {\n                // Always test index zero\n                i.test(0);\n            }\n            return true;\n        };\n        Assertions.assertArrayEquals(new int[n], ip.asIndexArray());\n    }\n\n    @Test\n    public void testFromBitMapExtractor() {\n        TestingBitMapExtractor testingBitMapExtractor = new TestingBitMapExtractor(new long[] {1L, 2L, 3L});\n        IndexExtractor underTest = IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);\n        List<Integer> lst = new ArrayList<>();\n\n        underTest.processIndices(lst::add);\n        assertEquals(4, lst.size());\n        assertEquals(Integer.valueOf(0), lst.get(0));\n        assertEquals(Integer.valueOf(1 + 64), lst.get(1));\n        assertEquals(Integer.valueOf(0 + 128), lst.get(2));\n        assertEquals(Integer.valueOf(1 + 128), lst.get(3));\n\n        testingBitMapExtractor = new TestingBitMapExtractor(new long[] {0xFFFFFFFFFFFFFFFFL});\n        underTest = IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);\n        lst = new ArrayList<>();\n\n        underTest.processIndices(lst::add);\n\n        assertEquals(64, lst.size());\n        for (int i = 0; i < 64; i++) {\n            assertEquals(Integer.valueOf(i), lst.get(i));\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/ShapeTest.java.ShapeTest", "name": "ShapeTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/ShapeTest.java", "superclasses": "", "methods": ["[void]testBadNumberOfBits()", "[void]testBadNumberOfHashFunctions()", "[void]testBadNumberOfItems()", "[void]testBadProbability()", "[void]testEqualsAndHashCode(int,int)", "[void]testEstimateN()", "[void]testFromKM()", "[void]testFromNM()", "[void]testFromNMK()", "[void]testFromNP()", "[void]testFromPMK()", "[void]testGetProbability()", "[void]testIsSparse()", "[void]testProbability()", "[void]testToString()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests the {@link Shape} class.\n", "original_string": "public class ShapeTest {\n\n    /*\n     * values from https://hur.st/bloomfilter/?n=5&p=.1&m=&k=\n     *\n     * n = 5\n     *\n     * p = 0.100375138 (1 in 10)\n     *\n     * m = 24 (3B)\n     *\n     * k = 3\n     */\n\n    private final Shape shape = Shape.fromKM(3, 24);\n\n    /**\n     * Tests that if the number of bits is less than 1 an exception is thrown\n     */\n    @Test\n    public void testBadNumberOfBits() {\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromKM(5, 0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNM(5, 0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNMK(5, 0, 7));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromPMK(0.035, 0, 7));\n    }\n\n    /**\n     * Tests that if the number of hash functions is less than 1 an exception is thrown.\n     */\n    @Test\n    public void testBadNumberOfHashFunctions() {\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromKM(0, 7));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNMK(5, 26, 0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromPMK(0.35, 26, 0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNM(2, 1));\n    }\n\n    /**\n     * Tests that if the number of items less than 1 an IllegalArgumentException is thrown.\n     */\n    @Test\n    public void testBadNumberOfItems() {\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNM(0, 24));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNMK(0, 24, 5));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(0, 0.02));\n    }\n\n    /**\n     * Tests that if the calculated probability is greater than or equal to 1 an IllegalArgumentException is thrown\n     */\n    @Test\n    public void testBadProbability() {\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNMK(4000, 8, 1));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(10, 0.0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(10, 1.0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(10, Double.NaN));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(10, Double.POSITIVE_INFINITY));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(10, Double.NEGATIVE_INFINITY));\n    }\n\n    /**\n     * Test equality of shape.\n     */\n    @ParameterizedTest\n    @CsvSource({\n        \"3, 24\",\n        \"1, 24\",\n        \"1, 1\",\n        \"13, 124\",\n        \"13, 224\",\n    })\n    public void testEqualsAndHashCode(final int k, final int m) {\n        final Shape shape1 = Shape.fromKM(k, m);\n        assertEquals(shape1, shape1);\n        assertEquals(Arrays.hashCode(new int[] {m, k}), shape1.hashCode(),\n            \"Doesn't match Arrays.hashCode(new int[] {m, k})\");\n        assertNotEquals(shape1, null);\n        assertNotEquals(shape1, \"text\");\n        assertNotEquals(shape1, Integer.valueOf(3));\n        assertNotEquals(shape1, Shape.fromKM(k, m + 1));\n        assertNotEquals(shape1, Shape.fromKM(k + 1, m));\n\n        // Test this is reproducible\n        final Shape shape2 = Shape.fromKM(k, m);\n        assertEquals(shape1, shape2);\n        assertEquals(shape1.hashCode(), shape2.hashCode());\n    }\n\n    /*\n     * values from https://hur.st/bloomfilter/?n=5&p=.1&m=&k=\n     *\n     * n = 5\n     *\n     * p = 0.100375138 (1 in 10)\n     *\n     * m = 24 (3B)\n     *\n     * k = 3\n     */\n\n    @Test\n    public void testEstimateN() {\n        for (int i = 0; i < 24; i++) {\n            final double c = i;\n            final double expected = -(24.0 / 3.0) * Math.log1p(-c / 24.0);\n            assertEquals(expected, shape.estimateN(i), \"Error on \" + i);\n        }\n\n        assertEquals(Double.POSITIVE_INFINITY, shape.estimateN(24));\n\n        assertEquals(Double.NaN, shape.estimateN(25));\n    }\n\n    /**\n     * Tests that if the number of bits less than 1 an IllegalArgumentException is thrown.\n     */\n    @Test\n    public void testFromKM() {\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromKM(5, 0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromKM(0, 5));\n    }\n\n    /**\n     * Tests that the number of items and number of bits is passed the other values are calculated correctly.\n     */\n    @Test\n    public void testFromNM() {\n        /*\n         * values from https://hur.st/bloomfilter/?n=5&m=24\n         */\n        final Shape shape = Shape.fromNM(5, 24);\n\n        assertEquals(24, shape.getNumberOfBits());\n        assertEquals(3, shape.getNumberOfHashFunctions());\n        assertEquals(0.100375138, shape.getProbability(5), 0.000001);\n\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNM(5, 0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNM(0, 5));\n    }\n\n    /**\n     * Tests that when the number of items, number of bits and number of hash functions is passed the values are\n     * calculated correctly.\n     */\n    @Test\n    public void testFromNMK() {\n        /*\n         * values from https://hur.st/bloomfilter/?n=5&m=24&k=4\n         */\n        final Shape shape = Shape.fromNMK(5, 24, 4);\n\n        assertEquals(24, shape.getNumberOfBits());\n        assertEquals(4, shape.getNumberOfHashFunctions());\n        assertEquals(0.102194782, shape.getProbability(5), 0.000001);\n\n        assertThrows(IllegalArgumentException.class,\n                () -> Shape.fromNMK(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNMK(5, 5, 0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNMK(5, 0, 5));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNMK(0, 5, 5));\n    }\n\n    /**\n     * Tests the calculated values of calling the constructor with the probability, number of bits and number of hash\n     * functions.\n     */\n    @Test\n    public void testFromNP() {\n        /*\n         * values from https://hur.st/bloomfilter/?n=5&p=.1&m=24&k=3\n         */\n        final double probability = 1.0 / 2000000;\n        final Shape shape = Shape.fromNP(10, probability);\n\n        assertEquals(302, shape.getNumberOfBits());\n        assertEquals(21, shape.getNumberOfHashFunctions());\n\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(Integer.MAX_VALUE, Math.nextDown(1.0)));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(0, probability));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(5, 0.0));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(Integer.MAX_VALUE, Math.nextUp(0.0)));\n        // Test that if calculated number of bits is greater than Integer.MAX_VALUE an\n        // IllegalArgumentException is thrown.\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromNP(Integer.MAX_VALUE, 0.1));\n    }\n\n    /**\n     * Tests the calculated values of calling the constructor with the probability, number of bits and number of hash\n     * functions.\n     */\n    @Test\n    public void testFromPMK() {\n        /*\n         * values from https://hur.st/bloomfilter/?n=5&p=.1&m=24&k=3\n         */\n        Shape shape = Shape.fromPMK(0.1, 24, 3);\n\n        assertEquals(24, shape.getNumberOfBits());\n        assertEquals(3, shape.getNumberOfHashFunctions());\n        assertEquals(0.100375138, shape.getProbability(5), 0.000001);\n\n        assertThrows(IllegalArgumentException.class,\n                () -> Shape.fromPMK(Math.nextDown(1.0), Integer.MAX_VALUE, Integer.MAX_VALUE));\n        shape = Shape.fromPMK(Math.nextUp(0.0), 5, 5);\n        assertEquals(1.0, shape.getProbability(Integer.MAX_VALUE));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromPMK(Math.nextDown(1.0), 5, 5));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromPMK(0.0, 5, 5));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromPMK(0.5, 0, 5));\n        assertThrows(IllegalArgumentException.class, () -> Shape.fromPMK(0.5, 5, 0));\n    }\n\n    @Test\n    public void testGetProbability() {\n        for (int i = 0; i <= 24; i++) {\n            final double expected = Math.pow(-Math.expm1(-3.0 * i / 24), 3);\n            assertEquals(expected, shape.getProbability(i), \"error at \" + i);\n        }\n\n        assertEquals(0.0, shape.getProbability(0), 0.0);\n\n        assertThrows(IllegalArgumentException.class, () -> shape.getProbability(-1));\n    }\n\n    @Test\n    public void testIsSparse() {\n        final int functions = 1; // Ignored\n        for (int i = 1; i <= 3; i++) {\n            final int bits = i * Long.SIZE;\n            final Shape shape = Shape.fromKM(functions, bits);\n            for (int n = 0; n <= bits; n++) {\n                final int c = n;\n                // is sparse when number of bits stored as integers is less than 2 times the\n                // number of bitmaps\n                assertEquals(n * Integer.SIZE <= Math.ceil((double) bits / Long.SIZE) * Long.SIZE,\n                        shape.isSparse(n), () -> String.format(\"n=%d : bits=%d\", c, bits));\n            }\n        }\n    }\n\n    /**\n     * Tests that the probability is calculated correctly.\n     */\n    @Test\n    public void testProbability() {\n        final Shape shape = Shape.fromNMK(5, 24, 3);\n        assertEquals(24, shape.getNumberOfBits());\n        assertEquals(3, shape.getNumberOfHashFunctions());\n        assertEquals(0.100375138, shape.getProbability(5), 0.000001);\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(\"Shape[k=3 m=5]\", Shape.fromKM(3, 5).toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Shape shape = Shape.fromKM(3, 24);", "docstring": "\nvalues from https://hur.st/bloomfilter/?n=5&p=.1&m=&k=\n\nn = 5\n\np = 0.100375138 (1 in 10)\n\nm = 24 (3B)\n\nk = 3\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(3, 24)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java.WrappedBloomFilterTest", "name": "WrappedBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java", "superclasses": "", "methods": ["[void]testCharacteristics(int)"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java.WrappedBloomFilterTest.[WrappedBloomFilter]createEmptyFilter(Shape)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class WrappedBloomFilterTest extends AbstractBloomFilterTest<WrappedBloomFilter> {\n\n    @Override\n    protected WrappedBloomFilter createEmptyFilter(final Shape shape) {\n        return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n            @Override\n            public BloomFilter copy() {\n                final BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);\n                result.merge(getWrapped());\n                return result;\n            }\n        };\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 34})\n    public void testCharacteristics(final int characteristics) {\n        final Shape shape = getTestShape();\n        final BloomFilter inner = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape) {\n            @Override\n            public int characteristics() {\n                return characteristics;\n            }\n        };\n        final WrappedBloomFilter underTest = new WrappedBloomFilter(inner) {\n            @Override\n            public BloomFilter copy() {\n                final BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);\n                result.merge(getWrapped());\n                return result;\n            }\n        };\n        assertEquals(characteristics, underTest.characteristics());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java.BitMapExtractorFromLongArrayTest", "name": "BitMapExtractorFromLongArrayTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java", "superclasses": "AbstractBitMapExtractorTest", "methods": ["[void]constructorTest()", "[void]testFromIndexExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java.BitMapExtractorFromLongArrayTest.[BitMapExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java.BitMapExtractorFromLongArrayTest.[BitMapExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java.BitMapExtractorFromLongArrayTest.[boolean]emptyIsZeroLength()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BitMapExtractorFromLongArrayTest extends AbstractBitMapExtractorTest {\n\n    @Test\n    public void constructorTest() {\n        final List<Long> lst = new ArrayList<>();\n        createExtractor().processBitMaps(lst::add);\n        assertEquals(Long.valueOf(1), lst.get(0));\n        assertEquals(Long.valueOf(2), lst.get(1));\n        assertEquals(Long.valueOf(3), lst.get(2));\n        assertEquals(Long.valueOf(4), lst.get(3));\n        assertEquals(Long.valueOf(5), lst.get(4));\n    }\n\n    @Override\n    protected BitMapExtractor createEmptyExtractor() {\n        return BitMapExtractor.fromBitMapArray();\n    }\n\n    @Override\n    protected BitMapExtractor createExtractor() {\n        final long[] ary = {1L, 2L, 3L, 4L, 5L};\n        return BitMapExtractor.fromBitMapArray(ary);\n    }\n\n    @Override\n    protected boolean emptyIsZeroLength() {\n        return true;\n    }\n\n    @Test\n    public void testFromIndexExtractor() {\n        final int limit = Integer.SIZE + Long.SIZE;\n        final IndexExtractor indexExtractor = consumer -> {\n            for (int i = 0; i < limit; i++) {\n                if (!consumer.test(i)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        final BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(indexExtractor, limit);\n        final List<Long> lst = new ArrayList<>();\n        bitMapExtractor.processBitMaps(lst::add);\n        long expected = ~0L;\n        assertEquals(expected, lst.get(0).longValue());\n        expected &= 0XFFFFFFFFL;\n        assertEquals(expected, lst.get(1).longValue());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java.LayeredBloomFilterTest", "name": "LayeredBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java", "superclasses": "", "methods": ["[void]testCardinalityAndIsEmpty()", "[void]testCleanup()", "[void]testEstimateUnionCrossTypes()", "[void]testExpiration()", "[void]testFindBitMapExtractor()", "[void]testFindBloomFilter()", "[void]testFindIndexExtractor()", "[void]testGetLayer()", "[void]testMultipleFilters()", "[void]testNext()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java.LayeredBloomFilterTest.[LayeredBloomFilter<TimestampedBloomFilter>]createTimedLayeredFilter(Shape,Duration,Duration)", "src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java.LayeredBloomFilterTest.[LayeredBloomFilter<BloomFilter>]fixed(Shape,int)", "src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java.LayeredBloomFilterTest.[LayeredBloomFilter<T>]fixed(Shape,int,Supplier<T>)", "src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java.LayeredBloomFilterTest.[LayeredBloomFilter<BloomFilter>]createEmptyFilter(Shape)", "src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java.LayeredBloomFilterTest.[BloomFilter]makeFilter(Hasher)", "src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java.LayeredBloomFilterTest.[BloomFilter]makeFilter(IndexExtractor)", "src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java.LayeredBloomFilterTest.[BloomFilter]makeFilter()", "src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java.LayeredBloomFilterTest.[LayeredBloomFilter<BloomFilter>]setupFindTest()"], "overrides": null, "attributes": [{"original_string": "    static class AdvanceOnTimeQuanta implements Predicate<LayerManager<TimestampedBloomFilter>> {\n        Duration quanta;\n\n        AdvanceOnTimeQuanta(final Duration quanta) {\n            this.quanta = quanta;\n        }\n\n        @Override\n        public boolean test(final LayerManager<TimestampedBloomFilter> layerManager) {\n            // can not use getTarget() as it causes recursion.\n            return layerManager.last().getTimestamp().plus(quanta).isBefore(Instant.now());\n        }\n    }", "definition": "    static class AdvanceOnTimeQuanta implements Predicate<LayerManager<TimestampedBloomFilter>>", "class_docstring": "\nA Predicate that advances after a quantum of time.\n", "name": "AdvanceOnTimeQuanta", "super_interfaces": ["Predicate<LayerManager<TimestampedBloomFilter>>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Duration quanta;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Duration", "name": "quanta", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        AdvanceOnTimeQuanta(final Duration quanta) {\n            this.quanta = quanta;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AdvanceOnTimeQuanta", "params": [{"name": "quanta", "type": "Duration"}], "body": "                                                   {\n            this.quanta = quanta;\n        }", "signature": "AdvanceOnTimeQuanta(final Duration quanta)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean test(final LayerManager<TimestampedBloomFilter> layerManager) {\n            // can not use getTarget() as it causes recursion.\n            return layerManager.last().getTimestamp().plus(quanta).isBefore(Instant.now());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "test", "params": [{"name": "layerManager", "type": "LayerManager<TimestampedBloomFilter>"}], "body": "                                                                                     {\n            // can not use getTarget() as it causes recursion.\n            return layerManager.last().getTimestamp().plus(quanta).isBefore(Instant.now());\n        }", "signature": "@Override\n        public boolean test(final LayerManager<TimestampedBloomFilter> layerManager)"}]}, {"original_string": "    static class CleanByTime<T extends TimestampedBloomFilter> implements Consumer<List<T>> {\n        Duration elapsedTime;\n\n        CleanByTime(final Duration elapsedTime) {\n            this.elapsedTime = elapsedTime;\n        }\n\n        @Override\n        public void accept(final List<T> t) {\n            final Instant min = Instant.now().minus(elapsedTime);\n            final Iterator<T> iter = t.iterator();\n            while (iter.hasNext()) {\n                final TimestampedBloomFilter bf = iter.next();\n                if (bf.getTimestamp().isAfter(min) || bf.getTimestamp().equals(min)) {\n                    return;\n                }\n                dbgInstrument.add(String.format(\"Removing old entry: T:%s (Aged: %s) \\n\", bf.getTimestamp(), Duration.between(bf.getTimestamp(), min)));\n                iter.remove();\n            }\n        }\n    }", "definition": "    static class CleanByTime<T extends TimestampedBloomFilter> implements Consumer<List<T>>", "class_docstring": "\nA Consumer that cleans the list based on how long each filters has been in\nthe list.\n", "name": "CleanByTime", "super_interfaces": ["Consumer<List<T>>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "Duration elapsedTime;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Duration", "name": "elapsedTime", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        CleanByTime(final Duration elapsedTime) {\n            this.elapsedTime = elapsedTime;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CleanByTime", "params": [{"name": "elapsedTime", "type": "Duration"}], "body": "                                                {\n            this.elapsedTime = elapsedTime;\n        }", "signature": "CleanByTime(final Duration elapsedTime)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void accept(final List<T> t) {\n            final Instant min = Instant.now().minus(elapsedTime);\n            final Iterator<T> iter = t.iterator();\n            while (iter.hasNext()) {\n                final TimestampedBloomFilter bf = iter.next();\n                if (bf.getTimestamp().isAfter(min) || bf.getTimestamp().equals(min)) {\n                    return;\n                }\n                dbgInstrument.add(String.format(\"Removing old entry: T:%s (Aged: %s) \\n\", bf.getTimestamp(), Duration.between(bf.getTimestamp(), min)));\n                iter.remove();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "t", "type": "List<T>"}], "body": "                                            {\n            final Instant min = Instant.now().minus(elapsedTime);\n            final Iterator<T> iter = t.iterator();\n            while (iter.hasNext()) {\n                final TimestampedBloomFilter bf = iter.next();\n                if (bf.getTimestamp().isAfter(min) || bf.getTimestamp().equals(min)) {\n                    return;\n                }\n                dbgInstrument.add(String.format(\"Removing old entry: T:%s (Aged: %s) \\n\", bf.getTimestamp(), Duration.between(bf.getTimestamp(), min)));\n                iter.remove();\n            }\n        }", "signature": "@Override\n        public void accept(final List<T> t)"}]}, {"original_string": "    static class NumberedBloomFilter extends WrappedBloomFilter {\n        int value;\n        int sequence;\n        NumberedBloomFilter(final Shape shape, final int value, final int sequence) {\n            super(new SimpleBloomFilter(shape));\n            this.value = value;\n            this.sequence = sequence;\n        }\n\n        @Override\n        public BloomFilter copy() {\n            return new NumberedBloomFilter(getShape(), value, sequence);\n        }\n    }", "definition": "    static class NumberedBloomFilter extends WrappedBloomFilter", "class_docstring": "", "name": "NumberedBloomFilter", "super_interfaces": [], "superclasses": "WrappedBloomFilter", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "int value;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "value", "syntax_pass": true}, {"attribute_expression": "int sequence;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "sequence", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        NumberedBloomFilter(final Shape shape, final int value, final int sequence) {\n            super(new SimpleBloomFilter(shape));\n            this.value = value;\n            this.sequence = sequence;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "NumberedBloomFilter", "params": [{"name": "shape", "type": "Shape"}, {"name": "value", "type": "int"}, {"name": "sequence", "type": "int"}], "body": "                                                                                    {\n            super(new SimpleBloomFilter(shape));\n            this.value = value;\n            this.sequence = sequence;\n        }", "signature": "NumberedBloomFilter(final Shape shape, final int value, final int sequence)"}, {"syntax_pass": true, "original_string": "        @Override\n        public BloomFilter copy() {\n            return new NumberedBloomFilter(getShape(), value, sequence);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BloomFilter", "classes": []}, "name": "copy", "params": [], "body": "                                  {\n            return new NumberedBloomFilter(getShape(), value, sequence);\n        }", "signature": "@Override\n        public BloomFilter copy()"}]}, {"original_string": "    public static class TimestampedBloomFilter extends WrappedBloomFilter {\n\n        private final Instant timestamp;\n\n        TimestampedBloomFilter(final BloomFilter bf) {\n            this(bf, Instant.now());\n        }\n\n        TimestampedBloomFilter(final BloomFilter bf, final Instant timestamp) {\n            super(bf);\n            this.timestamp = timestamp;\n        }\n\n        @Override\n        public TimestampedBloomFilter copy() {\n            return new TimestampedBloomFilter(getWrapped().copy(), timestamp);\n        }\n\n        public Instant getTimestamp() {\n            return timestamp;\n        }\n    }", "definition": "    public static class TimestampedBloomFilter extends WrappedBloomFilter", "class_docstring": "\nA Bloom filter implementation that tracks the creation time.\n", "name": "TimestampedBloomFilter", "super_interfaces": [], "superclasses": "WrappedBloomFilter", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final Instant timestamp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Instant", "name": "timestamp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TimestampedBloomFilter(final BloomFilter bf) {\n            this(bf, Instant.now());\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TimestampedBloomFilter", "params": [{"name": "bf", "type": "BloomFilter"}], "body": "                                                     {\n            this(bf, Instant.now());\n        }", "signature": "TimestampedBloomFilter(final BloomFilter bf)"}, {"syntax_pass": true, "original_string": "        TimestampedBloomFilter(final BloomFilter bf, final Instant timestamp) {\n            super(bf);\n            this.timestamp = timestamp;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TimestampedBloomFilter", "params": [{"name": "bf", "type": "BloomFilter"}, {"name": "timestamp", "type": "Instant"}], "body": "                                                                              {\n            super(bf);\n            this.timestamp = timestamp;\n        }", "signature": "TimestampedBloomFilter(final BloomFilter bf, final Instant timestamp)"}, {"syntax_pass": true, "original_string": "        @Override\n        public TimestampedBloomFilter copy() {\n            return new TimestampedBloomFilter(getWrapped().copy(), timestamp);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "TimestampedBloomFilter", "classes": []}, "name": "copy", "params": [], "body": "                                             {\n            return new TimestampedBloomFilter(getWrapped().copy(), timestamp);\n        }", "signature": "@Override\n        public TimestampedBloomFilter copy()"}, {"syntax_pass": true, "original_string": "        public Instant getTimestamp() {\n            return timestamp;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Instant", "classes": []}, "name": "getTimestamp", "params": [], "body": "                                      {\n            return timestamp;\n        }", "signature": "public Instant getTimestamp()"}]}], "class_docstring": "", "original_string": "public class LayeredBloomFilterTest extends AbstractBloomFilterTest<LayeredBloomFilter<?>> {\n\n    /**\n     * A Predicate that advances after a quantum of time.\n     */\n    static class AdvanceOnTimeQuanta implements Predicate<LayerManager<TimestampedBloomFilter>> {\n        Duration quanta;\n\n        AdvanceOnTimeQuanta(final Duration quanta) {\n            this.quanta = quanta;\n        }\n\n        @Override\n        public boolean test(final LayerManager<TimestampedBloomFilter> layerManager) {\n            // can not use getTarget() as it causes recursion.\n            return layerManager.last().getTimestamp().plus(quanta).isBefore(Instant.now());\n        }\n    }\n\n    /**\n     * A Consumer that cleans the list based on how long each filters has been in\n     * the list.\n     */\n    static class CleanByTime<T extends TimestampedBloomFilter> implements Consumer<List<T>> {\n        Duration elapsedTime;\n\n        CleanByTime(final Duration elapsedTime) {\n            this.elapsedTime = elapsedTime;\n        }\n\n        @Override\n        public void accept(final List<T> t) {\n            final Instant min = Instant.now().minus(elapsedTime);\n            final Iterator<T> iter = t.iterator();\n            while (iter.hasNext()) {\n                final TimestampedBloomFilter bf = iter.next();\n                if (bf.getTimestamp().isAfter(min) || bf.getTimestamp().equals(min)) {\n                    return;\n                }\n                dbgInstrument.add(String.format(\"Removing old entry: T:%s (Aged: %s) \\n\", bf.getTimestamp(), Duration.between(bf.getTimestamp(), min)));\n                iter.remove();\n            }\n        }\n    }\n\n    static class NumberedBloomFilter extends WrappedBloomFilter {\n        int value;\n        int sequence;\n        NumberedBloomFilter(final Shape shape, final int value, final int sequence) {\n            super(new SimpleBloomFilter(shape));\n            this.value = value;\n            this.sequence = sequence;\n        }\n\n        @Override\n        public BloomFilter copy() {\n            return new NumberedBloomFilter(getShape(), value, sequence);\n        }\n    }\n\n    /**\n     * A Bloom filter implementation that tracks the creation time.\n     */\n    public static class TimestampedBloomFilter extends WrappedBloomFilter {\n\n        private final Instant timestamp;\n\n        TimestampedBloomFilter(final BloomFilter bf) {\n            this(bf, Instant.now());\n        }\n\n        TimestampedBloomFilter(final BloomFilter bf, final Instant timestamp) {\n            super(bf);\n            this.timestamp = timestamp;\n        }\n\n        @Override\n        public TimestampedBloomFilter copy() {\n            return new TimestampedBloomFilter(getWrapped().copy(), timestamp);\n        }\n\n        public Instant getTimestamp() {\n            return timestamp;\n        }\n    }\n\n    // ***example of instrumentation ***\n    private static final List<String> dbgInstrument = new ArrayList<>();\n\n    /**\n     * Creates a LayeredBloomFilter that retains enclosed filters for\n     * {@code duration} and limits the contents of each enclosed filter to a time\n     * {@code quanta}. This filter uses the timestamped Bloom filter internally.\n     *\n     * @param shape    The shape of the Bloom filters.\n     * @param duration The length of time to keep filters in the list.\n     * @param quanta   The quantization factor for each filter. Individual filters\n     *                 will span at most this much time.\n     * @return LayeredBloomFilter with the above properties.\n     */\n    static LayeredBloomFilter<TimestampedBloomFilter> createTimedLayeredFilter(final Shape shape, final Duration duration, final Duration quanta) {\n        final LayerManager.Builder<TimestampedBloomFilter> builder = LayerManager.builder();\n        final Consumer<Deque<TimestampedBloomFilter>> cleanup = Cleanup.removeEmptyTarget().andThen(new CleanByTime(duration));\n        final LayerManager<TimestampedBloomFilter> layerManager = builder\n                .setSupplier(() -> new TimestampedBloomFilter(new SimpleBloomFilter(shape)))\n                .setCleanup(cleanup)\n                .setExtendCheck(new AdvanceOnTimeQuanta(quanta)\n                        .or(LayerManager.ExtendCheck.advanceOnSaturation(shape.estimateMaxN())))\n                .get();\n        return new LayeredBloomFilter<>(shape, layerManager);\n    }\n\n    /**\n     * Creates a fixed size layered bloom filter that adds new filters to the list,\n     * but never merges them. List will never exceed maxDepth. As additional filters\n     * are added earlier filters are removed.  Uses SimpleBloomFilters.\n     *\n     * @param shape    The shape for the enclosed Bloom filters.\n     * @param maxDepth The maximum depth of layers.\n     * @return An empty layered Bloom filter of the specified shape and depth.\n     */\n    public static  LayeredBloomFilter<BloomFilter> fixed(final Shape shape, final int maxDepth) {\n        return fixed(shape, maxDepth, () -> new SimpleBloomFilter(shape));\n    }\n\n    /**\n     * Creates a fixed size layered bloom filter that adds new filters to the list,\n     * but never merges them. List will never exceed maxDepth. As additional filters\n     * are added earlier filters are removed.\n     *\n     * @param shape    The shape for the enclosed Bloom filters.\n     * @param maxDepth The maximum depth of layers.\n     * @param supplier A supplier of the Bloom filters to create layers with.\n     * @return An empty layered Bloom filter of the specified shape and depth.\n     */\n    public static <T extends BloomFilter> LayeredBloomFilter<T> fixed(final Shape shape, final int maxDepth, final Supplier<T> supplier) {\n        final LayerManager.Builder<T> builder = LayerManager.builder();\n        builder.setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated())\n                .setCleanup(LayerManager.Cleanup.onMaxSize(maxDepth)).setSupplier(supplier);\n        return new LayeredBloomFilter<>(shape, builder.get());\n    }\n\n    // instrumentation to record timestamps in dbgInstrument list\n    private final Predicate<BloomFilter> dbg = bf -> {\n        final TimestampedBloomFilter tbf = (TimestampedBloomFilter) bf;\n        final Instant ts = Instant.now();\n        dbgInstrument.add(String.format(\"T:%s (Elapsed:%s)- EstN:%s (Card:%s)\\n\", tbf.timestamp, Duration.between(tbf.timestamp, ts),\n                tbf.estimateN(), tbf.cardinality()));\n        return true;\n    };\n    // *** end of instrumentation ***\n\n    @Override\n    protected LayeredBloomFilter<BloomFilter> createEmptyFilter(final Shape shape) {\n        return LayeredBloomFilterTest.fixed(shape, 10);\n    }\n\n    protected BloomFilter makeFilter(final Hasher h) {\n        final BloomFilter bf = new SparseBloomFilter(getTestShape());\n        bf.merge(h);\n        return bf;\n    }\n\n    protected BloomFilter makeFilter(final IndexExtractor p) {\n        final BloomFilter bf = new SparseBloomFilter(getTestShape());\n        bf.merge(p);\n        return bf;\n    }\n\n    protected BloomFilter makeFilter(final int... values) {\n        return makeFilter(IndexExtractor.fromIndexArray(values));\n    }\n\n    private LayeredBloomFilter<BloomFilter> setupFindTest() {\n        final LayeredBloomFilter<BloomFilter> filter = LayeredBloomFilterTest.fixed(getTestShape(), 10);\n        filter.merge(TestingHashers.FROM1);\n        filter.merge(TestingHashers.FROM11);\n        filter.merge(new IncrementingHasher(11, 2));\n        filter.merge(TestingHashers.populateFromHashersFrom1AndFrom11(new SimpleBloomFilter(getTestShape())));\n        return filter;\n    }\n\n    @Override\n    @Test\n    public void testCardinalityAndIsEmpty() {\n        final LayerManager<BloomFilter> layerManager = LayerManager.builder().setExtendCheck(ExtendCheck.neverAdvance())\n                .setSupplier(() -> new SimpleBloomFilter(getTestShape())).get();\n        testCardinalityAndIsEmpty(new LayeredBloomFilter<>(getTestShape(), layerManager));\n    }\n\n    // ***** TESTS THAT CHECK LAYERED PROCESSING ******\n\n    @Test\n    public void testCleanup() {\n        final int[] sequence = {1};\n        final LayerManager layerManager = LayerManager.builder()\n                .setSupplier(() -> new NumberedBloomFilter(getTestShape(), 3, sequence[0]++))\n                .setExtendCheck(ExtendCheck.neverAdvance())\n                .setCleanup(ll -> ll.removeIf( f -> (((NumberedBloomFilter) f).value-- == 0))).get();\n        final LayeredBloomFilter underTest = new LayeredBloomFilter(getTestShape(), layerManager );\n        assertEquals(1, underTest.getDepth());\n        underTest.merge(TestingHashers.randomHasher());\n        underTest.cleanup(); // first count == 2\n        assertEquals(1, underTest.getDepth());\n        underTest.next(); // first count == 1\n        assertEquals(2, underTest.getDepth());\n        underTest.merge(TestingHashers.randomHasher());\n        underTest.cleanup(); // first count == 0\n        NumberedBloomFilter f = (NumberedBloomFilter) underTest.get(0);\n        assertEquals(1, f.sequence);\n\n        assertEquals(2, underTest.getDepth());\n        underTest.cleanup(); // should be removed ; second is now 1st with value 1\n        assertEquals(1, underTest.getDepth());\n        f = (NumberedBloomFilter) underTest.get(0);\n        assertEquals(2, f.sequence);\n\n        underTest.cleanup(); // first count == 0\n        underTest.cleanup(); // should be removed.  But there is always at least one\n        assertEquals(1, underTest.getDepth());\n        f = (NumberedBloomFilter) underTest.get(0);\n        assertEquals(3, f.sequence);  // it is a new one.\n    }\n    /**\n     * Tests that the estimated union calculations are correct.\n     */\n    @Test\n    public final void testEstimateUnionCrossTypes() {\n        final BloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n        final BloomFilter bf2 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());\n        bf2.merge(TestingHashers.FROM11);\n\n        assertEquals(2, bf.estimateUnion(bf2));\n        assertEquals(2, bf2.estimateUnion(bf));\n    }\n\n    @Test\n    public void testExpiration() throws InterruptedException {\n        // this test uses the instrumentation noted above to track changes for debugging\n        // purposes.\n\n        // list of timestamps that are expected to be expired.\n        final List<Instant> lst = new ArrayList<>();\n        final Shape shape = Shape.fromNM(4, 64);\n\n        // create a filter that removes filters that are 4 seconds old\n        // and quantises time to 1 second intervals.\n        final LayeredBloomFilter<TimestampedBloomFilter> underTest = createTimedLayeredFilter(shape, Duration.ofMillis(600), Duration.ofMillis(150));\n\n        for (int i = 0; i < 10; i++) {\n            underTest.merge(TestingHashers.randomHasher());\n        }\n        underTest.processBloomFilters(dbg.and(x -> lst.add(((TimestampedBloomFilter) x).timestamp)));\n        assertTrue(underTest.getDepth() > 1);\n\n        Thread.sleep(300);\n        for (int i = 0; i < 10; i++) {\n            underTest.merge(TestingHashers.randomHasher());\n        }\n        dbgInstrument.add(\"=== AFTER 300 milliseconds ====\\n\");\n        underTest.processBloomFilters(dbg);\n\n        Thread.sleep(150);\n        for (int i = 0; i < 10; i++) {\n            underTest.merge(TestingHashers.randomHasher());\n        }\n        dbgInstrument.add(\"=== AFTER 450 milliseconds ====\\n\");\n        underTest.processBloomFilters(dbg);\n\n        // sleep 200 milliseconds to ensure we cross the 600 millisecond boundary\n        Thread.sleep(200);\n        underTest.merge(TestingHashers.randomHasher());\n        dbgInstrument.add(\"=== AFTER 600 milliseconds ====\\n\");\n        assertTrue(underTest.processBloomFilters(dbg.and(x -> !lst.contains(((TimestampedBloomFilter) x).timestamp))),\n                \"Found filter that should have been deleted: \" + dbgInstrument.get(dbgInstrument.size() - 1));\n    }\n\n    @Test\n    public void testFindBitMapExtractor() {\n        final LayeredBloomFilter<BloomFilter> filter = setupFindTest();\n\n        IndexExtractor indexExtractor = TestingHashers.FROM1.indices(getTestShape());\n        BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(indexExtractor, getTestShape().getNumberOfBits());\n\n        int[] expected = {0, 3};\n        int[] result = filter.find(bitMapExtractor);\n        assertArrayEquals(expected, result);\n\n        expected = new int[]{1, 3};\n        indexExtractor = TestingHashers.FROM11.indices(getTestShape());\n        bitMapExtractor = BitMapExtractor.fromIndexExtractor(indexExtractor, getTestShape().getNumberOfBits());\n        result = filter.find(bitMapExtractor);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFindBloomFilter() {\n        final LayeredBloomFilter<BloomFilter> filter = setupFindTest();\n        int[] expected = {0, 3};\n        int[] result = filter.find(TestingHashers.FROM1);\n        assertArrayEquals(expected, result);\n        expected = new int[] {1, 3};\n        result = filter.find(TestingHashers.FROM11);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public void testFindIndexExtractor() {\n        IndexExtractor indexExtractor = TestingHashers.FROM1.indices(getTestShape());\n        final LayeredBloomFilter<BloomFilter> filter = setupFindTest();\n\n        int[] expected = {0, 3};\n        int[] result = filter.find(indexExtractor);\n        assertArrayEquals(expected, result);\n\n        expected = new int[] {1, 3};\n        indexExtractor = TestingHashers.FROM11.indices(getTestShape());\n        result = filter.find(indexExtractor);\n        assertArrayEquals(expected, result);\n    }\n\n    @Test\n    public final void testGetLayer() {\n        final BloomFilter bf = new SimpleBloomFilter(getTestShape());\n        bf.merge(TestingHashers.FROM11);\n        final LayeredBloomFilter<BloomFilter> filter = LayeredBloomFilterTest.fixed(getTestShape(), 10);\n        filter.merge(TestingHashers.FROM1);\n        filter.merge(TestingHashers.FROM11);\n        filter.merge(new IncrementingHasher(11, 2));\n        filter.merge(TestingHashers.populateFromHashersFrom1AndFrom11(new SimpleBloomFilter(getTestShape())));\n        assertArrayEquals(bf.asBitMapArray(), filter.get(1).asBitMapArray());\n    }\n\n    @Test\n    public void testMultipleFilters() {\n        final LayeredBloomFilter<BloomFilter> filter = LayeredBloomFilterTest.fixed(getTestShape(), 10);\n        filter.merge(TestingHashers.FROM1);\n        filter.merge(TestingHashers.FROM11);\n        assertEquals(2, filter.getDepth());\n        assertTrue(filter.contains(makeFilter(TestingHashers.FROM1)));\n        assertTrue(filter.contains(makeFilter(TestingHashers.FROM11)));\n        final BloomFilter t1 = makeFilter(6, 7, 17, 18, 19);\n        assertFalse(filter.contains(t1));\n        assertFalse(filter.copy().contains(t1));\n        assertTrue(filter.flatten().contains(t1));\n    }\n\n    @Test\n    public final void testNext() {\n        final LayerManager<BloomFilter> layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(getTestShape()))\n                .get();\n\n        final LayeredBloomFilter<BloomFilter> filter = new LayeredBloomFilter<>(getTestShape(), layerManager);\n        filter.merge(TestingHashers.FROM1);\n        filter.merge(TestingHashers.FROM11);\n        assertEquals(1, filter.getDepth());\n        filter.next();\n        filter.merge(new IncrementingHasher(11, 2));\n        assertEquals(2, filter.getDepth());\n        assertTrue(filter.get(0).contains(TestingHashers.FROM1));\n        assertTrue(filter.get(0).contains(TestingHashers.FROM11));\n        assertFalse(filter.get(0).contains(new IncrementingHasher(11, 2)));\n        assertFalse(filter.get(1).contains(TestingHashers.FROM1));\n        assertFalse(filter.get(1).contains(TestingHashers.FROM11));\n        assertTrue(filter.get(1).contains(new IncrementingHasher(11, 2)));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final List<String> dbgInstrument = new ArrayList<>();", "docstring": " ***example of instrumentation ***", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<String>", "name": "dbgInstrument = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final Predicate<BloomFilter> dbg = bf -> {\n        final TimestampedBloomFilter tbf = (TimestampedBloomFilter) bf;\n        final Instant ts = Instant.now();\n        dbgInstrument.add(String.format(\"T:%s (Elapsed:%s)- EstN:%s (Card:%s)\\n\", tbf.timestamp, Duration.between(tbf.timestamp, ts),\n                tbf.estimateN(), tbf.cardinality()));\n        return true;\n    };", "docstring": " instrumentation to record timestamps in dbgInstrument list", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<BloomFilter>", "name": "dbg = bf -> {\n        final TimestampedBloomFilter tbf = (TimestampedBloomFilter) bf;\n        final Instant ts = Instant.now();\n        dbgInstrument.add(String.format(\"T:%s (Elapsed:%s)- EstN:%s (Card:%s)\\n\", tbf.timestamp, Duration.between(tbf.timestamp, ts),\n                tbf.estimateN(), tbf.cardinality()));\n        return true;\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java.HashSetValuedHashMapTest", "name": "HashSetValuedHashMapTest", "file_path": "src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java", "superclasses": "", "methods": ["[void]testHashSetValuedHashMap_2()", "[void]testHashSetValueHashMap()", "[void]testHashSetValueHashMap_1()", "[void]testSetValuedMapAdd()", "[void]testSetValuedMapEqualsHashCodeContract()", "[void]testSetValuedMapRemove()", "[void]testSetValuedMapRemoveViaIterator()"], "method_uris": ["src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java.HashSetValuedHashMapTest.[]HashSetValuedHashMapTest()", "src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java.HashSetValuedHashMapTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java.HashSetValuedHashMapTest.[boolean]isHashSetValue()", "src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java.HashSetValuedHashMapTest.[MultiValuedMap<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java.HashSetValuedHashMapTest.[SetValuedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link HashSetValuedHashMap}.\n", "original_string": "public class HashSetValuedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n\n    public HashSetValuedHashMapTest() {\n        super(HashSetValuedHashMapTest.class.getSimpleName());\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return AbstractCollectionTest.UNORDERED;\n    }\n\n    @Override\n    public boolean isHashSetValue() {\n        return true;\n    }\n\n    @Override\n    public MultiValuedMap<K, V> makeConfirmedMap() {\n        return new HashSetValuedHashMap<>();\n    }\n\n    @Override\n    public SetValuedMap<K, V> makeObject() {\n        return new HashSetValuedHashMap<>();\n    }\n\n    @Test\n    public void testHashSetValuedHashMap_2() {\n        final Map<K, V> map = new HashMap<>();\n        final SetValuedMap<K, V> map1;\n        final SetValuedMap<K, V> map2;\n\n        map.put((K) \"A\", (V) \"W\");\n        map.put((K) \"B\", (V) \"X\");\n        map.put((K) \"C\", (V) \"F\");\n        map1 = new HashSetValuedHashMap<>(map);\n        assertEquals(1, map1.get((K) \"A\").size());\n\n        map.remove(\"A\");\n        map.remove(\"B\");\n        map.remove(\"C\");\n        map2 = new HashSetValuedHashMap<>(map);\n        assertEquals(\"{}\", map2.toString());\n    }\n\n    @Test\n    public void testHashSetValueHashMap() {\n        final SetValuedMap<K, V> setMap = new HashSetValuedHashMap<>(4);\n        assertEquals(0, setMap.get((K) \"whatever\").size());\n\n        final Set<V> set = setMap.get((K) \"A\");\n        set.add((V) \"W\");\n        set.add((V) \"X\");\n        set.add((V) \"F\");\n        assertEquals(3, setMap.get((K) \"A\").size());\n    }\n\n    @Test\n    public void testHashSetValueHashMap_1() {\n        final MultiValuedMap<K, V> map = new ArrayListValuedHashMap<>();\n        final SetValuedMap<K, V> map1;\n        final SetValuedMap<K, V> map2 = makeObject();\n        final SetValuedMap<K, V> map3;\n\n        map.put((K) \"A\", (V) \"W\");\n        map.put((K) \"A\", (V) \"X\");\n        map.put((K) \"A\", (V) \"F\");\n        map1 = new HashSetValuedHashMap<>(map);\n        assertEquals(3, map1.get((K) \"A\").size());\n        map2.put((K) \"A\", (V) \"X\");\n        map2.put((K) \"A\", (V) \"F\");\n        map2.put((K) \"A\", (V) \"W\");\n        assertEquals(map1, map2);\n        assertEquals(map1.hashCode(), map2.hashCode());\n\n        map.remove(\"A\");\n        map3 = new HashSetValuedHashMap<>(map);\n        assertEquals(\"{}\", map3.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetValuedMapAdd() {\n        final SetValuedMap<K, V> setMap = makeObject();\n        assertTrue(setMap.get((K) \"whatever\") instanceof Set);\n\n        final Set<V> set = setMap.get((K) \"A\");\n        assertTrue(set.add((V) \"a1\"));\n        assertTrue(set.add((V) \"a2\"));\n        assertFalse(set.add((V) \"a1\"));\n        assertEquals(2, setMap.size());\n        assertTrue(setMap.containsKey(\"A\"));\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @Test\n    public void testSetValuedMapEqualsHashCodeContract() {\n        final SetValuedMap map1 = makeObject();\n        final SetValuedMap map2 = makeObject();\n\n        map1.put(\"a\", \"a1\");\n        map1.put(\"a\", \"a2\");\n        map2.put(\"a\", \"a2\");\n        map2.put(\"a\", \"a1\");\n        assertEquals(map1, map2);\n        assertEquals(map1.hashCode(), map2.hashCode());\n\n        map2.put(\"a\", \"a2\");\n        assertEquals(map1, map2);\n        assertEquals(map1.hashCode(), map2.hashCode());\n\n        map2.put(\"a\", \"a3\");\n        assertNotSame(map1, map2);\n        assertNotSame(map1.hashCode(), map2.hashCode());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetValuedMapRemove() {\n        final SetValuedMap<K, V> setMap = makeObject();\n        assertTrue(setMap.get((K) \"whatever\") instanceof Set);\n\n        final Set<V> set = setMap.get((K) \"A\");\n        assertTrue(set.add((V) \"a1\"));\n        assertTrue(set.add((V) \"a2\"));\n        assertFalse(set.add((V) \"a1\"));\n        assertEquals(2, setMap.size());\n        assertTrue(setMap.containsKey(\"A\"));\n\n        assertTrue(set.remove(\"a1\"));\n        assertTrue(set.remove(\"a2\"));\n        assertFalse(set.remove(\"a1\"));\n\n        assertEquals(0, setMap.size());\n        assertFalse(setMap.containsKey(\"A\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetValuedMapRemoveViaIterator() {\n        final SetValuedMap<K, V> setMap = makeObject();\n        assertTrue(setMap.get((K) \"whatever\") instanceof Set);\n\n        final Set<V> set = setMap.get((K) \"A\");\n        set.add((V) \"a1\");\n        set.add((V) \"a2\");\n        set.add((V) \"a1\");\n\n        final Iterator<V> it = set.iterator();\n        while (it.hasNext()) {\n            it.next();\n            it.remove();\n        }\n        assertEquals(0, setMap.size());\n        assertFalse(setMap.containsKey(\"A\"));\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n//                \"src/test/resources/data/test/HashSetValuedHashMap.emptyCollection.version4.1.obj\");\n//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n//                \"src/test/resources/data/test/HashSetValuedHashMap.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java.UnmodifiableMultiValuedMapTest", "name": "UnmodifiableMultiValuedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java", "superclasses": "", "methods": ["[void]testAddException()", "[void]testClearException()", "[void]testDecorateFactory()", "[void]testDecoratorFactoryNullMap()", "[void]testPutAllException()", "[void]testRemoveException()", "[void]testRemoveMappingException()", "[void]testUnmodifiable()", "[void]testUnmodifiableAsMap()", "[void]testUnmodifiableEntries()", "[void]testUnmodifiableKeys()", "[void]testUnmodifiableKeySet()", "[void]testUnmodifiableMapIterator()", "[void]testUnmodifiableValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java.UnmodifiableMultiValuedMapTest.[]UnmodifiableMultiValuedMapTest()", "src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java.UnmodifiableMultiValuedMapTest.[void]assertMapContainsAllValues(MultiValuedMap<K, V>)", "src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java.UnmodifiableMultiValuedMapTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java.UnmodifiableMultiValuedMapTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java.UnmodifiableMultiValuedMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java.UnmodifiableMultiValuedMapTest.[MultiValuedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java.UnmodifiableMultiValuedMapTest.[MultiValuedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link UnmodifiableMultiValuedMap}.\n", "original_string": "public class UnmodifiableMultiValuedMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n\n    public UnmodifiableMultiValuedMapTest() {\n        super(UnmodifiableMultiValuedMapTest.class.getSimpleName());\n    }\n\n    /**\n     * Asserts the given map contains all added values after it was initialized\n     * with makeFullMap(). See COLLECTIONS-769.\n     *\n     * @param map the MultiValuedMap<K, V> to check\n     */\n    private void assertMapContainsAllValues(final MultiValuedMap<K, V> map) {\n        final int maxK = getSampleKeySize();\n        final int cpk = getSampleCountPerKey();\n        for (int k = 0; k < maxK; k++) {\n            final K key = makeKey(k);\n            final Collection<V> collection = map.get((K) key);\n            assertEquals(cpk, collection.size());\n            final String toString = collection.toString();\n            final List<V> expected = new ArrayList<>(cpk);\n            for (int j = 0; j < cpk; j++) {\n                expected.add(makeValue(k, j));\n            }\n            assertEquals(expected.size(), collection.size());\n            assertEquals(expected, new ArrayList<>(collection));\n            assertEquals(expected.toString(), toString);\n        }\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return AbstractCollectionTest.UNORDERED;\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    protected MultiValuedMap<K, V> makeFullMap() {\n        final MultiValuedMap<K, V> map = new ArrayListValuedHashMap<>();\n        addSampleMappings(map);\n        return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);\n    }\n\n    @Override\n    public MultiValuedMap<K, V> makeObject() {\n        return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(\n                new ArrayListValuedHashMap<>());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddException() {\n        final MultiValuedMap<K, V> map = makeObject();\n        assertThrows(UnsupportedOperationException.class, () -> map.put((K) \"one\", (V) \"uno\"));\n    }\n\n    @Test\n    public void testClearException() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        assertThrows(UnsupportedOperationException.class, () -> map.clear(),\n                \"expected, not support clear() method UnmodifiableMultiValuedMap does not support change\");\n        this.assertMapContainsAllValues(map);\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        assertSame(map, UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(map));\n    }\n\n    @Test\n    public void testDecoratorFactoryNullMap() {\n        assertThrows(NullPointerException.class, () -> UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(null),\n                \"map must not be null\");\n    }\n\n    @Test\n    public void testPutAllException() {\n        final MultiValuedMap<K, V> map = makeObject();\n        final MultiValuedMap<K, V> original = new ArrayListValuedHashMap<>();\n        final Map<K, V> originalMap = new HashMap<>();\n        final Collection<V> coll = (Collection<V>) Arrays.asList(\"X\", \"Y\", \"Z\");\n        original.put((K) \"key\", (V) \"object1\");\n        original.put((K) \"key\", (V) \"object2\");\n        originalMap.put((K) \"keyX\", (V) \"object1\");\n        originalMap.put((K) \"keyY\", (V) \"object2\");\n\n        assertThrows(UnsupportedOperationException.class, () -> map.putAll(original),\n                \"expected, not support putAll() method UnmodifiableMultiValuedMap does not support change\");\n        assertEquals(\"{}\", map.toString());\n\n        assertThrows(UnsupportedOperationException.class, () -> map.putAll(originalMap));\n        assertEquals(\"{}\", map.toString());\n\n        assertThrows(UnsupportedOperationException.class, () -> map.putAll((K) \"A\", coll));\n        assertEquals(\"{}\", map.toString());\n    }\n\n    @Test\n    public void testRemoveException() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        assertThrows(UnsupportedOperationException.class, () -> map.remove(\"one\"),\n                \"not support remove() method UnmodifiableMultiValuedMap does not support change\");\n        this.assertMapContainsAllValues(map);\n    }\n\n    @Test\n    public void testRemoveMappingException() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        assertThrows(UnsupportedOperationException.class, () -> map.removeMapping(\"one\", \"uno\"),\n                \"expected, not support removeMapping() method UnmodifiableMultiValuedMap does not support change\");\n        this.assertMapContainsAllValues(map);\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullMap() instanceof Unmodifiable);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnmodifiableAsMap() {\n        resetFull();\n        final Map<K, Collection<V>> mapCol = getMap().asMap();\n        assertThrows(UnsupportedOperationException.class, () -> mapCol.put((K) \"four\", (Collection<V>) Arrays.asList(\"four\")));\n\n        assertThrows(UnsupportedOperationException.class, () -> mapCol.remove(\"four\"));\n\n        assertThrows(UnsupportedOperationException.class, () -> mapCol.clear());\n\n        assertThrows(UnsupportedOperationException.class, () -> mapCol.clear());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnmodifiableEntries() {\n        resetFull();\n        final Collection<Entry<K, V>> entries = getMap().entries();\n        assertThrows(UnsupportedOperationException.class, () -> entries.clear());\n\n        final Iterator<Entry<K, V>> it = entries.iterator();\n        final Entry<K, V> entry = it.next();\n        assertThrows(UnsupportedOperationException.class, () -> it.remove());\n\n        assertThrows(UnsupportedOperationException.class, () -> entry.setValue((V) \"three\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnmodifiableKeys() {\n        resetFull();\n        final MultiSet<K> keys = getMap().keys();\n        assertThrows(UnsupportedOperationException.class, () -> keys.add((K) \"four\"));\n\n        assertThrows(UnsupportedOperationException.class, () -> keys.remove(\"four\"));\n\n        assertThrows(UnsupportedOperationException.class, () -> keys.clear());\n\n        final Iterator<K> it = keys.iterator();\n        assertThrows(UnsupportedOperationException.class, () -> it.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnmodifiableKeySet() {\n        resetFull();\n        final Set<K> keySet = getMap().keySet();\n        assertThrows(UnsupportedOperationException.class, () -> keySet.add((K) \"four\"));\n\n        assertThrows(UnsupportedOperationException.class, () -> keySet.remove(\"four\"));\n\n        assertThrows(UnsupportedOperationException.class, () -> keySet.clear());\n\n        final Iterator<K> it = keySet.iterator();\n        assertThrows(UnsupportedOperationException.class, () -> it.remove());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnmodifiableMapIterator() {\n        resetFull();\n        final MapIterator<K, V> mapIt = getMap().mapIterator();\n        assertThrows(UnsupportedOperationException.class, () -> mapIt.remove());\n\n        assertThrows(UnsupportedOperationException.class, () -> mapIt.setValue((V) \"three\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testUnmodifiableValues() {\n        resetFull();\n        final Collection<V> values = getMap().values();\n        assertThrows(UnsupportedOperationException.class, () -> values.add((V) \"four\"));\n\n        assertThrows(UnsupportedOperationException.class, () -> values.remove(\"four\"));\n\n        assertThrows(UnsupportedOperationException.class, () -> values.clear());\n\n        final Iterator<V> it = values.iterator();\n        assertThrows(UnsupportedOperationException.class, () -> it.remove());\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n//                \"src/test/resources/data/test/UnmodifiableMultiValuedMap.emptyCollection.version4.1.obj\");\n//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n//                \"src/test/resources/data/test/UnmodifiableMultiValuedMap.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java.ArrayListValuedHashMapTest", "name": "ArrayListValuedHashMapTest", "file_path": "src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java", "superclasses": "", "methods": ["[void]testArrayListValuedHashMap()", "[void]testEqualsHashCodeContract()", "[void]testListValuedMapAdd()", "[void]testListValuedMapAddViaListIterator()", "[void]testListValuedMapEqualsHashCodeContract()", "[void]testListValuedMapRemove()", "[void]testListValuedMapRemoveViaListIterator()", "[void]testTrimToSize()", "[void]testValuesListIteratorMethods()", "[void]testWrappedListAdd()", "[void]testWrappedListAddAll()"], "method_uris": ["src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java.ArrayListValuedHashMapTest.[]ArrayListValuedHashMapTest()", "src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java.ArrayListValuedHashMapTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java.ArrayListValuedHashMapTest.[ListValuedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link ArrayListValuedHashMap}.\n", "original_string": "public class ArrayListValuedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n\n    public ArrayListValuedHashMapTest() {\n        super(ArrayListValuedHashMapTest.class.getSimpleName());\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return AbstractCollectionTest.UNORDERED;\n    }\n\n    @Override\n    public ListValuedMap<K, V> makeObject() {\n        return new ArrayListValuedHashMap<>();\n    }\n\n    @Test\n    public void testArrayListValuedHashMap() {\n        final ListValuedMap<K, V> listMap;\n        final ListValuedMap<K, V> listMap1;\n        final Map<K, V> map = new HashMap<>();\n        final Map<K, V> map1 = new HashMap<>();\n        map.put((K) \"A\", (V) \"W\");\n        map.put((K) \"B\", (V) \"X\");\n        map.put((K) \"C\", (V) \"F\");\n\n        listMap = new ArrayListValuedHashMap<>(map);\n        assertEquals(1, listMap.get((K) \"A\").size());\n        assertEquals(1, listMap.get((K) \"B\").size());\n        assertEquals(1, listMap.get((K) \"C\").size());\n\n        listMap1 = new ArrayListValuedHashMap<>(map1);\n        assertEquals(\"{}\", listMap1.toString());\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @Test\n    public void testEqualsHashCodeContract() {\n        final MultiValuedMap map1 = makeObject();\n        final MultiValuedMap map2 = makeObject();\n\n        map1.put(\"a\", \"a1\");\n        map1.put(\"a\", \"a2\");\n        map2.put(\"a\", \"a1\");\n        map2.put(\"a\", \"a2\");\n        assertEquals(map1, map2);\n        assertEquals(map1.hashCode(), map2.hashCode());\n\n        map2.put(\"a\", \"a2\");\n        assertNotSame(map1, map2);\n        assertNotSame(map1.hashCode(), map2.hashCode());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListValuedMapAdd() {\n        final ListValuedMap<K, V> listMap = makeObject();\n        assertTrue(listMap.get((K) \"whatever\") instanceof List);\n        final List<V> list = listMap.get((K) \"A\");\n        list.add((V) \"a1\");\n        assertEquals(1, listMap.size());\n        assertTrue(listMap.containsKey(\"A\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListValuedMapAddViaListIterator() {\n        final ListValuedMap<K, V> listMap = makeObject();\n        final ListIterator<V> listIt = listMap.get((K) \"B\").listIterator();\n        assertFalse(listIt.hasNext());\n        listIt.add((V) \"b1\");\n        listIt.add((V) \"b2\");\n        listIt.add((V) \"b3\");\n        assertEquals(3, listMap.size());\n        assertTrue(listMap.containsKey(\"B\"));\n        // As ListIterator always adds before the current cursor\n        assertFalse(listIt.hasNext());\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @Test\n    public void testListValuedMapEqualsHashCodeContract() {\n        final ListValuedMap map1 = makeObject();\n        final ListValuedMap map2 = makeObject();\n\n        map1.put(\"a\", \"a1\");\n        map1.put(\"a\", \"a2\");\n        map2.put(\"a\", \"a1\");\n        map2.put(\"a\", \"a2\");\n        assertEquals(map1, map2);\n        assertEquals(map1.hashCode(), map2.hashCode());\n\n        map1.put(\"b\", \"b1\");\n        map1.put(\"b\", \"b2\");\n        map2.put(\"b\", \"b2\");\n        map2.put(\"b\", \"b1\");\n        assertNotSame(map1, map2);\n        assertNotSame(map1.hashCode(), map2.hashCode());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListValuedMapRemove() {\n        final ListValuedMap<K, V> listMap = makeObject();\n        final List<V> list = listMap.get((K) \"A\");\n        list.add((V) \"a1\");\n        list.add((V) \"a2\");\n        list.add((V) \"a3\");\n        assertEquals(3, listMap.size());\n        assertEquals(\"a1\", list.remove(0));\n        assertEquals(2, listMap.size());\n        assertEquals(\"a2\", list.remove(0));\n        assertEquals(1, listMap.size());\n        assertEquals(\"a3\", list.remove(0));\n        assertEquals(0, listMap.size());\n        assertFalse(listMap.containsKey(\"A\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testListValuedMapRemoveViaListIterator() {\n        final ListValuedMap<K, V> listMap = makeObject();\n        ListIterator<V> listIt = listMap.get((K) \"B\").listIterator();\n        listIt.add((V) \"b1\");\n        listIt.add((V) \"b2\");\n        assertEquals(2, listMap.size());\n        assertTrue(listMap.containsKey(\"B\"));\n        listIt = listMap.get((K) \"B\").listIterator();\n        while (listIt.hasNext()) {\n            listIt.next();\n            listIt.remove();\n        }\n        assertFalse(listMap.containsKey(\"B\"));\n        listIt.add((V) \"b1\");\n        listIt.add((V) \"b2\");\n        assertTrue(listMap.containsKey(\"B\"));\n        assertEquals(2, listMap.get((K) \"B\").size());\n    }\n\n    @Test\n    public void testTrimToSize() {\n        final ArrayListValuedHashMap<K, V> listMap = new ArrayListValuedHashMap<>(4);\n\n        assertEquals(\"{}\", listMap.toString());\n        listMap.put((K) \"A\", (V) \"W\");\n        listMap.put((K) \"A\", (V) \"X\");\n        listMap.put((K) \"B\", (V) \"F\");\n        assertEquals(2, listMap.get((K) \"A\").size());\n        assertEquals(1, listMap.get((K) \"B\").size());\n\n        listMap.trimToSize();\n        assertEquals(2, listMap.get((K) \"A\").size());\n        assertEquals(1, listMap.get((K) \"B\").size());\n    }\n\n    @Test\n    public void testValuesListIteratorMethods() {\n        final ListValuedMap<K, V> listMap = makeObject();\n        final List<V> listA = listMap.get((K) \"A\");\n        final List<V> list = Arrays.asList((V) \"W\", (V) \"X\", (V) \"F\", (V) \"Q\", (V) \"Q\", (V) \"F\");\n        listA.addAll(0, list);\n        final ListIterator<V> it = listMap.get((K) \"A\").listIterator(1);\n        assertTrue(it.hasNext());\n        assertEquals(\"X\", it.next());\n        assertEquals(\"F\", it.next());\n        assertTrue(it.hasPrevious());\n        assertEquals(\"F\", it.previous());\n        assertEquals(2, it.nextIndex());\n        assertEquals(1, it.previousIndex());\n        it.set((V) \"Z\");\n        assertEquals(\"Z\", it.next());\n        assertEquals(\"Q\", it.next());\n    }\n\n    @Test\n    public void testWrappedListAdd() {\n        final ListValuedMap<K, V> listMap = makeObject();\n        final List<V> listA = listMap.get((K) \"A\");\n        listA.add(0, (V) \"W\");\n        listA.add(1, (V) \"X\");\n        listA.add(2, (V) \"F\");\n        assertEquals(\"{A=[W, X, F]}\", listMap.toString());\n        listMap.get((K) \"A\").set(1, (V) \"Q\");\n        assertEquals(\"{A=[W, Q, F]}\", listMap.toString());\n    }\n\n    @Test\n    public void testWrappedListAddAll() {\n        final ListValuedMap<K, V> listMap = makeObject();\n        final List<V> listA = listMap.get((K) \"A\");\n        final List<V> list = Arrays.asList((V) \"W\", (V) \"X\", (V) \"F\");\n        listA.addAll(0, list);\n        assertEquals(\"{A=[W, X, F]}\", listMap.toString());\n\n        final List<V> list1 = Arrays.asList((V) \"Q\", (V) \"Q\", (V) \"L\");\n        listA.addAll(3, list1);\n        assertEquals(\"{A=[W, X, F, Q, Q, L]}\", listMap.toString());\n        assertEquals(\"W\", listMap.get((K) \"A\").get(0));\n        assertEquals(\"X\", listMap.get((K) \"A\").get(1));\n        assertEquals(\"F\", listMap.get((K) \"A\").get(2));\n        assertEquals(\"Q\", listMap.get((K) \"A\").get(3));\n        assertEquals(\"Q\", listMap.get((K) \"A\").get(4));\n        assertEquals(\"L\", listMap.get((K) \"A\").get(5));\n        assertEquals(0, listMap.get((K) \"A\").indexOf(\"W\"));\n        assertEquals(2, listMap.get((K) \"A\").indexOf(\"F\"));\n        assertEquals(-1, listMap.get((K) \"A\").indexOf(\"C\"));\n        assertEquals(3, listMap.get((K) \"A\").indexOf(\"Q\"));\n        assertEquals(4, listMap.get((K) \"A\").lastIndexOf(\"Q\"));\n        assertEquals(-1, listMap.get((K) \"A\").lastIndexOf(\"A\"));\n\n        final List<V> list2 = new ArrayList<>();\n        listMap.get((K) \"B\").addAll(0, list2);\n        assertEquals(\"{A=[W, X, F, Q, Q, L]}\", listMap.toString());\n        final List<V> list3 = listMap.get((K) \"A\").subList(1, 4);\n        assertEquals(3, list3.size());\n        assertEquals(\"Q\", list3.get(2));\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n//                \"src/test/resources/data/test/ArrayListValuedHashMap.emptyCollection.version4.1.obj\");\n//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n//                \"src/test/resources/data/test/ArrayListValuedHashMap.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java.TransformedMultiValuedMapTest", "name": "TransformedMultiValuedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java", "superclasses": "", "methods": ["[void]testFactory_Decorate()", "[void]testFactory_decorateTransform()", "[void]testKeyTransformedMap()", "[void]testValueTransformedMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java.TransformedMultiValuedMapTest.[]TransformedMultiValuedMapTest()", "src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java.TransformedMultiValuedMapTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java.TransformedMultiValuedMapTest.[MultiValuedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link TransformedMultiValuedMap}.\n", "original_string": "public class TransformedMultiValuedMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n\n    public TransformedMultiValuedMapTest() {\n        super(TransformedMultiValuedMapTest.class.getSimpleName());\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return AbstractCollectionTest.UNORDERED;\n    }\n\n    @Override\n    public MultiValuedMap<K, V> makeObject() {\n        return TransformedMultiValuedMap.transformingMap(new ArrayListValuedHashMap<>(),\n                TransformerUtils.<K>nopTransformer(), TransformerUtils.<V>nopTransformer());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFactory_Decorate() {\n        final MultiValuedMap<K, V> base = new ArrayListValuedHashMap<>();\n        base.put((K) \"A\", (V) \"1\");\n        base.put((K) \"B\", (V) \"2\");\n        base.put((K) \"C\", (V) \"3\");\n\n        final MultiValuedMap<K, V> trans = TransformedMultiValuedMap\n                .transformingMap(\n                        base,\n                        null,\n                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(3, trans.size());\n        assertTrue(trans.get((K) \"A\").contains(\"1\"));\n        assertTrue(trans.get((K) \"B\").contains(\"2\"));\n        assertTrue(trans.get((K) \"C\").contains(\"3\"));\n        trans.put((K) \"D\", (V) \"4\");\n        assertTrue(trans.get((K) \"D\").contains(Integer.valueOf(4)));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFactory_decorateTransform() {\n        final MultiValuedMap<K, V> base = new ArrayListValuedHashMap<>();\n        base.put((K) \"A\", (V) \"1\");\n        base.put((K) \"B\", (V) \"2\");\n        base.put((K) \"C\", (V) \"3\");\n\n        final MultiValuedMap<K, V> trans = TransformedMultiValuedMap\n                .transformedMap(\n                        base,\n                        null,\n                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(3, trans.size());\n        assertTrue(trans.get((K) \"A\").contains(Integer.valueOf(1)));\n        assertTrue(trans.get((K) \"B\").contains(Integer.valueOf(2)));\n        assertTrue(trans.get((K) \"C\").contains(Integer.valueOf(3)));\n        trans.put((K) \"D\", (V) \"4\");\n        assertTrue(trans.get((K) \"D\").contains(Integer.valueOf(4)));\n\n        final MultiValuedMap<K, V> baseMap = new ArrayListValuedHashMap<>();\n        final MultiValuedMap<K, V> transMap = TransformedMultiValuedMap\n                .transformedMap(\n                        baseMap,\n                        null,\n                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, transMap.size());\n        transMap.put((K) \"D\", (V) \"4\");\n        assertEquals(1, transMap.size());\n        assertTrue(transMap.get((K) \"D\").contains(Integer.valueOf(4)));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testKeyTransformedMap() {\n        final Object[] els = { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n\n        final MultiValuedMap<K, V> map = TransformedMultiValuedMap.transformingMap(\n                new ArrayListValuedHashMap<>(),\n                (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n                null);\n        assertEquals(0, map.size());\n        for (int i = 0; i < els.length; i++) {\n            map.put((K) els[i], (V) els[i]);\n            assertEquals(i + 1, map.size());\n            assertTrue(map.containsKey(Integer.valueOf((String) els[i])));\n            assertFalse(map.containsKey(els[i]));\n            assertTrue(map.containsValue(els[i]));\n            assertTrue(map.get((K) Integer.valueOf((String) els[i])).contains(els[i]));\n        }\n\n        final Collection<V> coll = map.remove(els[0]);\n        assertNotNull(coll);\n        assertEquals(0, coll.size());\n        assertTrue(map.remove(Integer.valueOf((String) els[0])).contains(els[0]));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testValueTransformedMap() {\n        final Object[] els = { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n\n        final MultiValuedMap<K, V> map = TransformedMultiValuedMap.transformingMap(\n                new ArrayListValuedHashMap<>(), null,\n                (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n        assertEquals(0, map.size());\n        for (int i = 0; i < els.length; i++) {\n            map.put((K) els[i], (V) els[i]);\n            assertEquals(i + 1, map.size());\n            assertTrue(map.containsValue(Integer.valueOf((String) els[i])));\n            assertFalse(map.containsValue(els[i]));\n            assertTrue(map.containsKey(els[i]));\n            assertTrue(map.get((K) els[i]).contains(Integer.valueOf((String) els[i])));\n        }\n        assertTrue(map.remove(els[0]).contains(Integer.valueOf((String) els[0])));\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n//                \"src/test/resources/data/test/TransformedMultiValuedMap.emptyCollection.version4.1.obj\");\n//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n//                \"src/test/resources/data/test/TransformedMultiValuedMap.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/multiset/PredicatedMultiSetTest.java.PredicatedMultiSetTest", "name": "PredicatedMultiSetTest", "file_path": "src/test/java/org/apache/commons/collections4/multiset/PredicatedMultiSetTest.java", "superclasses": "", "methods": ["[void]testIllegalAdd()", "[void]testIllegalDecorate()", "[void]testLegalAddRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/multiset/PredicatedMultiSetTest.java.PredicatedMultiSetTest.[]PredicatedMultiSetTest()", "src/test/java/org/apache/commons/collections4/multiset/PredicatedMultiSetTest.java.PredicatedMultiSetTest.[MultiSet<T>]decorateMultiSet(HashMultiSet<T>,Predicate<T>)", "src/test/java/org/apache/commons/collections4/multiset/PredicatedMultiSetTest.java.PredicatedMultiSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/multiset/PredicatedMultiSetTest.java.PredicatedMultiSetTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/multiset/PredicatedMultiSetTest.java.PredicatedMultiSetTest.[MultiSet<T>]makeObject()", "src/test/java/org/apache/commons/collections4/multiset/PredicatedMultiSetTest.java.PredicatedMultiSetTest.[MultiSet<T>]makeTestMultiSet()", "src/test/java/org/apache/commons/collections4/multiset/PredicatedMultiSetTest.java.PredicatedMultiSetTest.[Predicate<T>]stringPredicate()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMultiSetTest} for exercising the\n{@link PredicatedMultiSet} implementation.\n", "original_string": "public class PredicatedMultiSetTest<T> extends AbstractMultiSetTest<T> {\n\n    protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n\n    public PredicatedMultiSetTest() {\n        super(PredicatedMultiSetTest.class.getSimpleName());\n    }\n\n    protected MultiSet<T> decorateMultiSet(final HashMultiSet<T> multiset, final Predicate<T> predicate) {\n        return PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.1\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public MultiSet<T> makeObject() {\n        return decorateMultiSet(new HashMultiSet<>(), truePredicate);\n    }\n\n    protected MultiSet<T> makeTestMultiSet() {\n        return decorateMultiSet(new HashMultiSet<>(), stringPredicate());\n    }\n\n    protected Predicate<T> stringPredicate() {\n        return String.class::isInstance;\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalAdd() {\n        final MultiSet<T> multiset = makeTestMultiSet();\n        final Integer i = Integer.valueOf(3);\n        assertThrows(IllegalArgumentException.class, () -> multiset.add((T) i),\n                \"Integer should fail string predicate.\");\n        assertFalse(multiset.contains(i), \"Collection shouldn't contain illegal element\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testIllegalDecorate() {\n        final HashMultiSet<Object> elements = new HashMultiSet<>();\n        elements.add(\"one\");\n        elements.add(\"two\");\n        elements.add(Integer.valueOf(3));\n        elements.add(\"four\");\n        assertThrows(IllegalArgumentException.class, () -> decorateMultiSet((HashMultiSet<T>) elements, stringPredicate()),\n                \"MultiSet contains an element that should fail the predicate.\");\n        assertThrows(NullPointerException.class, () -> decorateMultiSet(new HashMultiSet<>(), null),\n                \"Expecting NullPointerException for null predicate.\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLegalAddRemove() {\n        final MultiSet<T> multiset = makeTestMultiSet();\n        assertEquals(0, multiset.size());\n        final T[] els = (T[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"1\" };\n        for (int i = 0; i < els.length; i++) {\n            multiset.add(els[i]);\n            assertEquals(i + 1, multiset.size());\n            assertTrue(multiset.contains(els[i]));\n        }\n        Set<T> set = ((PredicatedMultiSet<T>) multiset).uniqueSet();\n        assertTrue(set.contains(els[0]), \"Unique set contains the first element\");\n        assertTrue(multiset.remove(els[0]));\n        set = ((PredicatedMultiSet<T>) multiset).uniqueSet();\n        assertTrue(set.contains(els[0]),\n            \"Unique set does not contain anymore the first element\");\n    }\n\n//    public void testCreate() throws Exception {\n//        MultiSet<T> multiset = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) multiset, \"src/test/resources/data/test/PredicatedMultiSet.emptyCollection.version4.1.obj\");\n//        multiset = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) multiset, \"src/test/resources/data/test/PredicatedMultiSet.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Predicate<T>", "name": "truePredicate = TruePredicate.<T>truePredicate()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest", "name": "UnmodifiableMultiSetTest", "file_path": "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java", "superclasses": "", "methods": ["[void]testAdd()", "[void]testDecorateFactory()", "[void]testEntrySet()", "[void]testRemove()", "[void]testSetCount()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest.[]UnmodifiableMultiSetTest()", "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest.[MultiSet<E>]getCollection()", "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest.[boolean]isNullSupported()", "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest.[MultiSet<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSetTest.java.UnmodifiableMultiSetTest.[MultiSet<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMultiSetTest} for exercising the\n{@link UnmodifiableMultiSet} implementation.\n", "original_string": "public class UnmodifiableMultiSetTest<E> extends AbstractMultiSetTest<E> {\n\n    public UnmodifiableMultiSetTest() {\n        super(UnmodifiableMultiSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public MultiSet<E> getCollection() {\n        return super.getCollection();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.1\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public boolean isAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isNullSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public MultiSet<E> makeFullCollection() {\n        final MultiSet<E> multiset = new HashMultiSet<>();\n        multiset.addAll(Arrays.asList(getFullElements()));\n        return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n    }\n\n    @Override\n    public MultiSet<E> makeObject() {\n        return UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<>());\n    }\n\n    @Test\n    public void testAdd() {\n        final MultiSet<E> multiset = makeFullCollection();\n        final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n        assertThrows(UnsupportedOperationException.class, () -> unmodifiableMultiSet.add((E) \"One\", 1));\n    }\n\n    @Test\n    public void testDecorateFactory() {\n        final MultiSet<E> multiset = makeFullCollection();\n        assertSame(multiset, UnmodifiableMultiSet.unmodifiableMultiSet(multiset));\n\n        assertThrows(NullPointerException.class, () -> UnmodifiableMultiSet.unmodifiableMultiSet(null));\n    }\n\n    @Test\n    public void testEntrySet() {\n        final MultiSet<E> multiset = makeFullCollection();\n        final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n        assertSame( unmodifiableMultiSet.entrySet().size(), multiset.entrySet().size());\n    }\n\n    @Test\n    public void testRemove() {\n        final MultiSet<E> multiset = makeFullCollection();\n        final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n        assertThrows(UnsupportedOperationException.class, () -> unmodifiableMultiSet.remove(\"One\", 1));\n    }\n\n    @Test\n    public void testSetCount() {\n        final MultiSet<E> multiset = makeFullCollection();\n        final MultiSet<E> unmodifiableMultiSet =  UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n        assertThrows(UnsupportedOperationException.class, () -> unmodifiableMultiSet.setCount((E) \"One\", 2));\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        assertTrue(makeObject() instanceof Unmodifiable);\n        assertTrue(makeFullCollection() instanceof Unmodifiable);\n    }\n\n//    public void testCreate() throws Exception {\n//        MultiSet<E> multiset = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) multiset, \"src/test/resources/data/test/UnmodifiableMultiSet.emptyCollection.version4.1.obj\");\n//        multiset = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) multiset, \"src/test/resources/data/test/UnmodifiableMultiSet.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/keyvalue/TiedMapEntryTest.java.TiedMapEntryTest", "name": "TiedMapEntryTest", "file_path": "src/test/java/org/apache/commons/collections4/keyvalue/TiedMapEntryTest.java", "superclasses": "", "methods": ["[void]testConstructors()", "[void]testSetValue()"], "method_uris": ["src/test/java/org/apache/commons/collections4/keyvalue/TiedMapEntryTest.java.TiedMapEntryTest.[Map.Entry<K, V>]makeMapEntry(K,V)"], "overrides": null, "attributes": [], "class_docstring": "\nTest the TiedMapEntry class.\n", "original_string": "public class TiedMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n\n    /**\n     * Gets the instance to test\n     */\n    @Override\n    public Map.Entry<K, V> makeMapEntry(final K key, final V value) {\n        final Map<K, V> map = new HashMap<>();\n        map.put(key, value);\n        return new TiedMapEntry<>(map, key);\n    }\n\n    /**\n     * Tests the constructors.\n     */\n    @Test\n    @Override\n    public void testConstructors() {\n        // ignore\n    }\n\n    /**\n     * Tests the constructors.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetValue() {\n        final Map<K, V> map = new HashMap<>();\n        map.put((K) \"A\", (V) \"a\");\n        map.put((K) \"B\", (V) \"b\");\n        map.put((K) \"C\", (V) \"c\");\n        Map.Entry<K, V> entry = new TiedMapEntry<>(map, (K) \"A\");\n        assertSame(\"A\", entry.getKey());\n        assertSame(\"a\", entry.getValue());\n        assertSame(\"a\", entry.setValue((V) \"x\"));\n        assertSame(\"A\", entry.getKey());\n        assertSame(\"x\", entry.getValue());\n\n        entry = new TiedMapEntry<>(map, (K) \"B\");\n        assertSame(\"B\", entry.getKey());\n        assertSame(\"b\", entry.getValue());\n        assertSame(\"b\", entry.setValue((V) \"y\"));\n        assertSame(\"B\", entry.getKey());\n        assertSame(\"y\", entry.getValue());\n\n        entry = new TiedMapEntry<>(map, (K) \"C\");\n        assertSame(\"C\", entry.getKey());\n        assertSame(\"c\", entry.getValue());\n        assertSame(\"c\", entry.setValue((V) \"z\"));\n        assertSame(\"C\", entry.getKey());\n        assertSame(\"z\", entry.getValue());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/keyvalue/DefaultMapEntryTest.java.DefaultMapEntryTest", "name": "DefaultMapEntryTest", "file_path": "src/test/java/org/apache/commons/collections4/keyvalue/DefaultMapEntryTest.java", "superclasses": "", "methods": ["[void]testConstructors()", "[void]testSelfReferenceHandling()"], "method_uris": ["src/test/java/org/apache/commons/collections4/keyvalue/DefaultMapEntryTest.java.DefaultMapEntryTest.[Map.Entry<K, V>]makeMapEntry()", "src/test/java/org/apache/commons/collections4/keyvalue/DefaultMapEntryTest.java.DefaultMapEntryTest.[Map.Entry<K, V>]makeMapEntry(K,V)"], "overrides": null, "attributes": [], "class_docstring": "\nTest the DefaultMapEntry class.\n", "original_string": "public class DefaultMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n\n    /**\n     * Make an instance of Map.Entry with the default (null) key and value.\n     * Subclasses should override this method to return a Map.Entry\n     * of the type being tested.\n     */\n    @Override\n    public Map.Entry<K, V> makeMapEntry() {\n        return new DefaultMapEntry<>(null, null);\n    }\n\n    /**\n     * Make an instance of Map.Entry with the specified key and value.\n     * Subclasses should override this method to return a Map.Entry\n     * of the type being tested.\n     */\n    @Override\n    public Map.Entry<K, V> makeMapEntry(final K key, final V value) {\n        return new DefaultMapEntry<>(key, value);\n    }\n\n    /**\n     * Subclasses should override this method.\n     */\n    @Test\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void testConstructors() {\n        // 1. test key-value constructor\n        final Map.Entry<K, V> entry = new DefaultMapEntry<>((K) key, (V) value);\n        assertSame(key, entry.getKey());\n        assertSame(value, entry.getValue());\n\n        // 2. test pair constructor\n        final KeyValue<K, V> pair = new DefaultKeyValue<>((K) key, (V) value);\n        assertSame(key, pair.getKey());\n        assertSame(value, pair.getValue());\n\n        // 3. test copy constructor\n        final Map.Entry<K, V> entry2 = new DefaultMapEntry<>(entry);\n        assertSame(key, entry2.getKey());\n        assertSame(value, entry2.getValue());\n\n        // test that the objects are independent\n        entry.setValue(null);\n        assertSame(value, entry2.getValue());\n    }\n\n    @Test\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void testSelfReferenceHandling() {\n        final Map.Entry<K, V> entry = makeMapEntry();\n\n        entry.setValue((V) entry);\n        assertSame(entry, entry.getValue());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/keyvalue/DefaultKeyValueTest.java.DefaultKeyValueTest", "name": "DefaultKeyValueTest", "file_path": "src/test/java/org/apache/commons/collections4/keyvalue/DefaultKeyValueTest.java", "superclasses": "", "methods": ["[void]testAccessorsAndMutators()", "[void]testConstructors()", "[void]testEqualsAndHashCode()", "[void]testSelfReferenceHandling()", "[void]testToMapEntry()", "[void]testToString()"], "method_uris": ["src/test/java/org/apache/commons/collections4/keyvalue/DefaultKeyValueTest.java.DefaultKeyValueTest.[DefaultKeyValue<K, V>]makeDefaultKeyValue()", "src/test/java/org/apache/commons/collections4/keyvalue/DefaultKeyValueTest.java.DefaultKeyValueTest.[DefaultKeyValue<K, V>]makeDefaultKeyValue(K,V)"], "overrides": null, "attributes": [], "class_docstring": "\nTest the DefaultKeyValue class.\n", "original_string": "public class DefaultKeyValueTest<K, V> {\n\n    private final String key = \"name\";\n    private final String value = \"duke\";\n\n    /**\n     * Make an instance of DefaultKeyValue with the default (null) key and value.\n     * Subclasses should override this method to return a DefaultKeyValue\n     * of the type being tested.\n     */\n    protected DefaultKeyValue<K, V> makeDefaultKeyValue() {\n        return new DefaultKeyValue<>(null, null);\n    }\n\n    /**\n     * Make an instance of DefaultKeyValue with the specified key and value.\n     * Subclasses should override this method to return a DefaultKeyValue\n     * of the type being tested.\n     */\n    protected DefaultKeyValue<K, V> makeDefaultKeyValue(final K key, final V value) {\n        return new DefaultKeyValue<>(key, value);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAccessorsAndMutators() {\n        final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n\n        kv.setKey((K) key);\n        assertSame(key, kv.getKey());\n\n        kv.setValue((V) value);\n        assertSame(value, kv.getValue());\n\n        // check that null doesn't do anything funny\n        kv.setKey(null);\n        assertNull(kv.getKey());\n\n        kv.setValue(null);\n        assertNull(kv.getValue());\n    }\n\n    /**\n     * Subclasses should override this method to test their own constructors.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testConstructors() {\n        // 1. test default constructor\n        DefaultKeyValue<K, V> kv = new DefaultKeyValue<>();\n        assertTrue(kv.getKey() == null && kv.getValue() == null);\n\n        // 2. test key-value constructor\n        kv = new DefaultKeyValue<>((K) key, (V) value);\n        assertTrue(kv.getKey() == key && kv.getValue() == value);\n\n        // 3. test copy constructor\n        final DefaultKeyValue<K, V> kv2 = new DefaultKeyValue<>(kv);\n        assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n\n        // test that the KVPs are independent\n        kv.setKey(null);\n        kv.setValue(null);\n\n        assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n\n        // 4. test Map.Entry constructor\n        final Map<K, V> map = new HashMap<>();\n        map.put((K) key, (V) value);\n        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n\n        kv = new DefaultKeyValue<>(entry);\n        assertTrue(kv.getKey() == key && kv.getValue() == value);\n\n        // test that the KVP is independent of the Map.Entry\n        entry.setValue(null);\n        assertSame(value, kv.getValue());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEqualsAndHashCode() {\n        // 1. test with object data\n        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n        DefaultKeyValue<K, V> kv2 = makeDefaultKeyValue((K) key, (V) value);\n\n        assertEquals(kv, kv);\n        assertEquals(kv, kv2);\n        assertEquals(kv.hashCode(), kv2.hashCode());\n\n        // 2. test with nulls\n        kv = makeDefaultKeyValue(null, null);\n        kv2 = makeDefaultKeyValue(null, null);\n\n        assertEquals(kv, kv);\n        assertEquals(kv, kv2);\n        assertEquals(kv.hashCode(), kv2.hashCode());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSelfReferenceHandling() {\n        // test that #setKey and #setValue do not permit\n        //  the KVP to contain itself (and thus cause infinite recursion\n        //  in #hashCode and #toString)\n\n        final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n\n        assertThrows(IllegalArgumentException.class, () -> kv.setKey((K) kv));\n        // check that the KVP's state has not changed\n        assertTrue(kv.getKey() == null && kv.getValue() == null);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testToMapEntry() {\n        final DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n\n        final Map<K, V> map = new HashMap<>();\n        map.put(kv.getKey(), kv.getValue());\n        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n\n        assertEquals(entry, kv.toMapEntry());\n        assertEquals(entry.hashCode(), kv.hashCode());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testToString() {\n        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n        assertEquals(kv.toString(), kv.getKey() + \"=\" + kv.getValue());\n\n        // test with nulls\n        kv = makeDefaultKeyValue(null, null);\n        assertEquals(kv.toString(), kv.getKey() + \"=\" + kv.getValue());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final String key = \"name\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "key = \"name\"", "syntax_pass": true}, {"attribute_expression": "private final String value = \"duke\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "value = \"duke\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntryTest.java.UnmodifiableMapEntryTest", "name": "UnmodifiableMapEntryTest", "file_path": "src/test/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntryTest.java", "superclasses": "", "methods": ["[void]testAccessorsAndMutators()", "[void]testConstructors()", "[void]testSelfReferenceHandling()", "[void]testUnmodifiable()"], "method_uris": ["src/test/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntryTest.java.UnmodifiableMapEntryTest.[Map.Entry<K, V>]makeMapEntry()", "src/test/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntryTest.java.UnmodifiableMapEntryTest.[Map.Entry<K, V>]makeMapEntry(K,V)"], "overrides": null, "attributes": [], "class_docstring": "\nTest the UnmodifiableMapEntry class.\n", "original_string": "public class UnmodifiableMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n\n    /**\n     * Make an instance of Map.Entry with the default (null) key and value.\n     * Subclasses should override this method to return a Map.Entry\n     * of the type being tested.\n     */\n    @Override\n    public Map.Entry<K, V> makeMapEntry() {\n        return new UnmodifiableMapEntry<>(null, null);\n    }\n\n    /**\n     * Make an instance of Map.Entry with the specified key and value.\n     * Subclasses should override this method to return a Map.Entry\n     * of the type being tested.\n     */\n    @Override\n    public Map.Entry<K, V> makeMapEntry(final K key, final V value) {\n        return new UnmodifiableMapEntry<>(key, value);\n    }\n\n    @Test\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void testAccessorsAndMutators() {\n        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n\n        assertSame(key, entry.getKey());\n        assertSame(value, entry.getValue());\n\n        // check that null doesn't do anything funny\n        entry = makeMapEntry(null, null);\n        assertSame(null, entry.getKey());\n        assertSame(null, entry.getValue());\n    }\n\n    /**\n     * Subclasses should override this method.\n     */\n    @Test\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void testConstructors() {\n        // 1. test key-value constructor\n        Map.Entry<K, V> entry = new UnmodifiableMapEntry<>((K) key, (V) value);\n        assertSame(key, entry.getKey());\n        assertSame(value, entry.getValue());\n\n        // 2. test pair constructor\n        final KeyValue<K, V> pair = new DefaultKeyValue<>((K) key, (V) value);\n        entry = new UnmodifiableMapEntry<>(pair);\n        assertSame(key, entry.getKey());\n        assertSame(value, entry.getValue());\n\n        // 3. test copy constructor\n        final Map.Entry<K, V> entry2 = new UnmodifiableMapEntry<>(entry);\n        assertSame(key, entry2.getKey());\n        assertSame(value, entry2.getValue());\n\n        assertInstanceOf(Unmodifiable.class, entry);\n    }\n\n    @Test\n    @Override\n    public void testSelfReferenceHandling() {\n        // block\n    }\n\n    @Test\n    public void testUnmodifiable() {\n        final Map.Entry<K, V> entry = makeMapEntry();\n\n        assertThrows(UnsupportedOperationException.class, () -> entry.setValue(null));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/keyvalue/MultiKeyTest.java.MultiKeyTest", "name": "MultiKeyTest", "file_path": "src/test/java/org/apache/commons/collections4/keyvalue/MultiKeyTest.java", "superclasses": "", "methods": ["[void]testConstructors()", "[void]testConstructorsByArray()", "[void]testEquals()", "[void]testEqualsAfterSerialization()", "[void]testEqualsAfterSerializationOfDerivedClass()", "[void]testGetKeysArrayConstructorCloned()", "[void]testGetKeysArrayConstructorNonCloned()", "[void]testGetKeysSimpleConstructor()", "[void]testHashCode()", "[void]testSize()", "[void]testTwoArgCtor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/keyvalue/MultiKeyTest.java.MultiKeyTest.[Collection<DynamicTest>]testConstructorsByArrayNull()", "src/test/java/org/apache/commons/collections4/keyvalue/MultiKeyTest.java.MultiKeyTest.[Collection<DynamicTest>]testGetIndexed()"], "overrides": null, "attributes": [{"original_string": "    static class DerivedMultiKey<T> extends MultiKey<T> {\n\n        private static final long serialVersionUID = 1928896152249821416L;\n\n        DerivedMultiKey(final T key1, final T key2) {\n            super(key1, key2);\n        }\n\n        public T getFirst() {\n            return getKey(0);\n        }\n\n        public T getSecond() {\n            return getKey(1);\n        }\n\n    }", "definition": "    static class DerivedMultiKey<T> extends MultiKey<T>", "class_docstring": "", "name": "DerivedMultiKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1928896152249821416L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1928896152249821416L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        DerivedMultiKey(final T key1, final T key2) {\n            super(key1, key2);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "DerivedMultiKey", "params": [{"name": "key1", "type": "T"}, {"name": "key2", "type": "T"}], "body": "                                                    {\n            super(key1, key2);\n        }", "signature": "DerivedMultiKey(final T key1, final T key2)"}, {"syntax_pass": true, "original_string": "        public T getFirst() {\n            return getKey(0);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getFirst", "params": [], "body": "                            {\n            return getKey(0);\n        }", "signature": "public T getFirst()"}, {"syntax_pass": true, "original_string": "        public T getSecond() {\n            return getKey(1);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getSecond", "params": [], "body": "                             {\n            return getKey(1);\n        }", "signature": "public T getSecond()"}]}, {"original_string": "    static class SystemHashCodeSimulatingKey implements Serializable {\n\n        private static final long serialVersionUID = -1736147315703444603L;\n        private final String name;\n        private int hashCode = 1;\n\n        SystemHashCodeSimulatingKey(final String name) {\n            this.name = name;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            return obj instanceof SystemHashCodeSimulatingKey\n                && name.equals(((SystemHashCodeSimulatingKey) obj).name);\n        }\n\n        @Override\n        public int hashCode() {\n            return hashCode;\n        }\n\n        private Object readResolve() {\n            hashCode = 2; // simulate different hashCode after deserialization in another process\n            return this;\n        }\n    }", "definition": "    static class SystemHashCodeSimulatingKey implements Serializable", "class_docstring": "", "name": "SystemHashCodeSimulatingKey", "super_interfaces": ["Serializable"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -1736147315703444603L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -1736147315703444603L", "syntax_pass": true}, {"attribute_expression": "private final String name;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "private int hashCode = 1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "hashCode = 1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SystemHashCodeSimulatingKey(final String name) {\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SystemHashCodeSimulatingKey", "params": [{"name": "name", "type": "String"}], "body": "                                                       {\n            this.name = name;\n        }", "signature": "SystemHashCodeSimulatingKey(final String name)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            return obj instanceof SystemHashCodeSimulatingKey\n                && name.equals(((SystemHashCodeSimulatingKey) obj).name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            return obj instanceof SystemHashCodeSimulatingKey\n                && name.equals(((SystemHashCodeSimulatingKey) obj).name);\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return hashCode;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return hashCode;\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        private Object readResolve() {\n            hashCode = 2; // simulate different hashCode after deserialization in another process\n            return this;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object", "classes": []}, "name": "readResolve", "params": [], "body": "                                     {\n            hashCode = 2; // simulate different hashCode after deserialization in another process\n            return this;\n        }", "signature": "private Object readResolve()"}]}], "class_docstring": "\nUnit tests for {@link org.apache.commons.collections4.keyvalue.MultiKey}.\n", "original_string": "public class MultiKeyTest {\n\n    static class DerivedMultiKey<T> extends MultiKey<T> {\n\n        private static final long serialVersionUID = 1928896152249821416L;\n\n        DerivedMultiKey(final T key1, final T key2) {\n            super(key1, key2);\n        }\n\n        public T getFirst() {\n            return getKey(0);\n        }\n\n        public T getSecond() {\n            return getKey(1);\n        }\n\n    }\n\n    static class SystemHashCodeSimulatingKey implements Serializable {\n\n        private static final long serialVersionUID = -1736147315703444603L;\n        private final String name;\n        private int hashCode = 1;\n\n        SystemHashCodeSimulatingKey(final String name) {\n            this.name = name;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            return obj instanceof SystemHashCodeSimulatingKey\n                && name.equals(((SystemHashCodeSimulatingKey) obj).name);\n        }\n\n        @Override\n        public int hashCode() {\n            return hashCode;\n        }\n\n        private Object readResolve() {\n            hashCode = 2; // simulate different hashCode after deserialization in another process\n            return this;\n        }\n    }\n\n    Integer ONE = Integer.valueOf(1);\n\n    Integer TWO = Integer.valueOf(2);\n    Integer THREE = Integer.valueOf(3);\n    Integer FOUR = Integer.valueOf(4);\n    Integer FIVE = Integer.valueOf(5);\n\n    @Test\n    public void testConstructors() throws Exception {\n        MultiKey<Integer> mk;\n        mk = new MultiKey<>(ONE, TWO);\n        assertArrayEquals(new Object[]{ONE, TWO}, mk.getKeys());\n\n        mk = new MultiKey<>(ONE, TWO, THREE);\n        assertArrayEquals(new Object[]{ONE, TWO, THREE}, mk.getKeys());\n\n        mk = new MultiKey<>(ONE, TWO, THREE, FOUR);\n        assertArrayEquals(new Object[]{ONE, TWO, THREE, FOUR}, mk.getKeys());\n\n        mk = new MultiKey<>(ONE, TWO, THREE, FOUR, FIVE);\n        assertArrayEquals(new Object[]{ONE, TWO, THREE, FOUR, FIVE}, mk.getKeys());\n\n        mk = new MultiKey<>(new Integer[] { THREE, FOUR, ONE, TWO }, false);\n        assertArrayEquals(new Object[]{THREE, FOUR, ONE, TWO}, mk.getKeys());\n    }\n\n    @Test\n    public void testConstructorsByArray() throws Exception {\n        MultiKey<Integer> mk;\n        Integer[] keys = { THREE, FOUR, ONE, TWO };\n        mk = new MultiKey<>(keys);\n        assertArrayEquals(new Object[]{THREE, FOUR, ONE, TWO}, mk.getKeys());\n        keys[3] = FIVE;  // no effect\n        assertArrayEquals(new Object[]{THREE, FOUR, ONE, TWO}, mk.getKeys());\n\n        keys = new Integer[] {};\n        mk = new MultiKey<>(keys);\n        assertArrayEquals(new Object[]{}, mk.getKeys());\n\n        keys = new Integer[] { THREE, FOUR, ONE, TWO };\n        mk = new MultiKey<>(keys, true);\n        assertArrayEquals(new Object[]{THREE, FOUR, ONE, TWO}, mk.getKeys());\n        keys[3] = FIVE;  // no effect\n        assertArrayEquals(new Object[]{THREE, FOUR, ONE, TWO}, mk.getKeys());\n\n        keys = new Integer[] { THREE, FOUR, ONE, TWO };\n        mk = new MultiKey<>(keys, false);\n        assertArrayEquals(new Object[]{THREE, FOUR, ONE, TWO}, mk.getKeys());\n        // change key - don't do this!\n        // the hash code of the MultiKey is now broken\n        keys[3] = FIVE;\n        assertArrayEquals(new Object[]{THREE, FOUR, ONE, FIVE}, mk.getKeys());\n    }\n\n    @TestFactory\n    public Collection<DynamicTest> testConstructorsByArrayNull() {\n        final Integer[] keys = null;\n        return Arrays.asList(\n                dynamicTest(\"Integer[] null\", () -> {\n                    assertThrows(NullPointerException.class, () -> new MultiKey<>(keys));\n                }),\n                dynamicTest(\"Integer[] null + makeClone true\", () -> {\n                    assertThrows(NullPointerException.class, () -> new MultiKey<>(keys, true));\n                }),\n                dynamicTest(\"Integer[] null + makeClone false\", () -> {\n                    assertThrows(NullPointerException.class, () -> new MultiKey<>(keys, false));\n                })\n        );\n    }\n\n    @Test\n    public void testEquals() {\n        final MultiKey<Integer> mk1 = new MultiKey<>(ONE, TWO);\n        final MultiKey<Integer> mk2 = new MultiKey<>(ONE, TWO);\n        final MultiKey<Object> mk3 = new MultiKey<>(ONE, \"TWO\");\n\n        assertEquals(mk1, mk1);\n        assertEquals(mk1, mk2);\n        assertNotEquals(mk1, mk3);\n        assertNotEquals(StringUtils.EMPTY, mk1);\n        assertNotEquals(null, mk1);\n    }\n\n    @Test\n    public void testEqualsAfterSerialization() throws IOException, ClassNotFoundException {\n        SystemHashCodeSimulatingKey sysKey = new SystemHashCodeSimulatingKey(\"test\");\n        final MultiKey<?> mk = new MultiKey<Object>(ONE, sysKey);\n        final Map<MultiKey<?>, Integer> map = new HashMap<>();\n        map.put(mk, TWO);\n\n        // serialize\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(baos);\n        out.writeObject(sysKey);\n        out.writeObject(map);\n        out.close();\n\n        // deserialize\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream in = new ObjectInputStream(bais);\n        sysKey = (SystemHashCodeSimulatingKey) in.readObject(); // simulate deserialization in another process\n        final Map<?, ?> map2 = (Map<?, ?>) in.readObject();\n        in.close();\n\n        assertEquals(2, sysKey.hashCode()); // different hashCode now\n\n        final MultiKey<?> mk2 = new MultiKey<Object>(ONE, sysKey);\n        assertEquals(TWO, map2.get(mk2));\n    }\n\n    @Test\n    public void testEqualsAfterSerializationOfDerivedClass() throws IOException, ClassNotFoundException {\n        final DerivedMultiKey<?> mk = new DerivedMultiKey<>(\"A\", \"B\");\n\n        // serialize\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(baos);\n        out.writeObject(mk);\n        out.close();\n\n        // deserialize\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream in = new ObjectInputStream(bais);\n        final DerivedMultiKey<?> mk2 = (DerivedMultiKey<?>) in.readObject();\n        in.close();\n\n        assertEquals(mk.hashCode(), mk2.hashCode());\n    }\n\n    @TestFactory\n    public Collection<DynamicTest> testGetIndexed() {\n        final MultiKey<Integer> mk = new MultiKey<>(ONE, TWO);\n        return Arrays.asList(\n                dynamicTest(\"0\", () -> {\n                    assertSame(ONE, mk.getKey(0));\n                }),\n                dynamicTest(\"1\", () -> {\n                    assertSame(TWO, mk.getKey(1));\n                }),\n                dynamicTest(\"-1\", () -> {\n                    assertThrows(IndexOutOfBoundsException.class, () -> mk.getKey(-1));\n                }),\n                dynamicTest(\"2\", () -> {\n                    assertThrows(IndexOutOfBoundsException.class, () -> mk.getKey(2));\n                })\n        );\n    }\n\n    @Test\n    public void testGetKeysArrayConstructorCloned() {\n        final Integer[] keys = { ONE, TWO };\n        final MultiKey<Integer> mk = new MultiKey<>(keys, true);\n        final Object[] array = mk.getKeys();\n        assertNotSame(array, keys);\n        assertArrayEquals(array, keys);\n        assertSame(ONE, array[0]);\n        assertSame(TWO, array[1]);\n        assertEquals(2, array.length);\n    }\n\n    @Test\n    public void testGetKeysArrayConstructorNonCloned() {\n        final Integer[] keys = { ONE, TWO };\n        final MultiKey<Integer> mk = new MultiKey<>(keys, false);\n        final Object[] array = mk.getKeys();\n        assertNotSame(array, keys);  // still not equal\n        assertArrayEquals(array, keys);\n        assertSame(ONE, array[0]);\n        assertSame(TWO, array[1]);\n        assertEquals(2, array.length);\n    }\n\n    @Test\n    public void testGetKeysSimpleConstructor() {\n        final MultiKey<Integer> mk = new MultiKey<>(ONE, TWO);\n        final Object[] array = mk.getKeys();\n        assertSame(ONE, array[0]);\n        assertSame(TWO, array[1]);\n        assertEquals(2, array.length);\n    }\n\n    @Test\n    public void testHashCode() {\n        final MultiKey<Integer> mk1 = new MultiKey<>(ONE, TWO);\n        final MultiKey<Integer> mk2 = new MultiKey<>(ONE, TWO);\n        final MultiKey<Object> mk3 = new MultiKey<>(ONE, \"TWO\");\n\n        assertEquals(mk1.hashCode(), mk1.hashCode());\n        assertEquals(mk1.hashCode(), mk2.hashCode());\n        assertTrue(mk1.hashCode() != mk3.hashCode());\n\n        final int total = 0 ^ ONE.hashCode() ^ TWO.hashCode();\n        assertEquals(total, mk1.hashCode());\n    }\n\n    @Test\n    public void testSize() {\n        assertEquals(2, new MultiKey<>(ONE, TWO).size());\n        assertEquals(2, new MultiKey<>(null, null).size());\n        assertEquals(3, new MultiKey<>(ONE, TWO, THREE).size());\n        assertEquals(3, new MultiKey<>(null, null, null).size());\n        assertEquals(4, new MultiKey<>(ONE, TWO, THREE, FOUR).size());\n        assertEquals(4, new MultiKey<>(null, null, null, null).size());\n        assertEquals(5, new MultiKey<>(ONE, TWO, THREE, FOUR, FIVE).size());\n        assertEquals(5, new MultiKey<>(null, null, null, null, null).size());\n\n        assertEquals(0, new MultiKey<>(new Object[] {}).size());\n        assertEquals(1, new MultiKey<>(new Integer[] { ONE }).size());\n        assertEquals(2, new MultiKey<>(new Integer[] { ONE, TWO }).size());\n        assertEquals(7, new MultiKey<>(new Integer[] { ONE, TWO, ONE, TWO, ONE, TWO, ONE }).size());\n    }\n\n    @Test\n    public void testTwoArgCtor() {\n        final MultiKeyTest key1 = new MultiKeyTest();\n        final MultiKeyTest key2 = new MultiKeyTest();\n        final MultiKeyTest[] keys = new MultiKey<>(key1, key2).getKeys();\n        assertNotNull(keys);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "Integer ONE = Integer.valueOf(1);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Integer", "name": "ONE = Integer.valueOf(1)", "syntax_pass": true}, {"attribute_expression": "Integer TWO = Integer.valueOf(2);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Integer", "name": "TWO = Integer.valueOf(2)", "syntax_pass": true}, {"attribute_expression": "Integer THREE = Integer.valueOf(3);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Integer", "name": "THREE = Integer.valueOf(3)", "syntax_pass": true}, {"attribute_expression": "Integer FOUR = Integer.valueOf(4);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Integer", "name": "FOUR = Integer.valueOf(4)", "syntax_pass": true}, {"attribute_expression": "Integer FIVE = Integer.valueOf(5);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Integer", "name": "FIVE = Integer.valueOf(5)", "syntax_pass": true}]}]