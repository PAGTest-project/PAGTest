[{"relative_path": "src/test/java/org/openapitools/openapidiff/core/RequestDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;\n\nimport org.junit.jupiter.api.Test;\n\npublic class RequestDiffTest {\n  private final String OPENAPI_DOC1 = \"request_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"request_diff_2.yaml\";\n\n  @Test\n  public void testDiffDifferent() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC2);\n  }\n}\n", "file_hash": "5599999de680ac55f6797e4cfad2cc388a18d7ebb860ffbe2a93a25df40faa46", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class RequestDiffTest {\n  private final String OPENAPI_DOC1 = \"request_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"request_diff_2.yaml\";\n\n  @Test\n  public void testDiffDifferent() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC2);\n  }\n}", "definition": "public class RequestDiffTest", "class_docstring": "", "name": "RequestDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"request_diff_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"request_diff_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"request_diff_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"request_diff_2.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferent() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC2);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferent", "params": [], "body": "                                  {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC2);\n  }", "signature": "@Test\n  public void testDiffDifferent()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/ReferenceDiffCacheTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ReferenceDiffCacheTest {\n\n  private final String OPENAPI_DOC1 = \"schema_diff_cache_1.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n}\n", "file_hash": "7a544519f643e177a2ee729299a36ed52117118d76faa9ccfbd21beefb2c81eb", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class ReferenceDiffCacheTest {\n\n  private final String OPENAPI_DOC1 = \"schema_diff_cache_1.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n}", "definition": "public class ReferenceDiffCacheTest", "class_docstring": "", "name": "ReferenceDiffCacheTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"schema_diff_cache_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"schema_diff_cache_1.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffSame", "params": [], "body": "                             {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "signature": "@Test\n  public void testDiffSame()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/SecurityDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport io.swagger.v3.oas.models.security.SecurityRequirement;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.*;\n\npublic class SecurityDiffTest {\n  private final String OPENAPI_DOC1 = \"security_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"security_diff_2.yaml\";\n  private final String OPENAPI_DOC3 = \"security_diff_3.yaml\";\n  private final String OPENAPI_DOC4 = \"security_diff_4.yaml\";\n  private final String OPENAPI_DOC5 = \"security_diff_5.yaml\";\n\n  @Test\n  public void testDiffDifferent() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getChangedOperations()).hasSize(3);\n\n    ChangedOperation changedOperation1 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet/{petId}\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation1).isNotNull();\n    assertThat(changedOperation1.isCompatible()).isFalse();\n    ChangedSecurityRequirements changedSecurityRequirements1 =\n        changedOperation1.getSecurityRequirements();\n    assertThat(changedSecurityRequirements1).isNotNull();\n    assertThat(changedSecurityRequirements1.isCompatible()).isFalse();\n    assertThat(changedSecurityRequirements1.getIncreased()).hasSize(1);\n    assertThat(changedSecurityRequirements1.getChanged()).hasSize(1);\n    ChangedSecurityRequirement changedSecurityRequirement1 =\n        changedSecurityRequirements1.getChanged().get(0);\n    assertThat(changedSecurityRequirement1.getChanged()).hasSize(1);\n    ChangedSecuritySchemeScopes changedScopes1 =\n        changedSecurityRequirement1.getChanged().get(0).getChangedScopes();\n    assertThat(changedScopes1)\n        .isNotNull()\n        .satisfies(\n            stringListDiff ->\n                assertThat(stringListDiff.getIncreased())\n                    .hasSize(1)\n                    .first()\n                    .asString()\n                    .isEqualTo(\"read:pets\"));\n\n    ChangedOperation changedOperation2 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet3\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation2).isNotNull();\n    assertThat(changedOperation2.isCompatible()).isFalse();\n    ChangedSecurityRequirements changedSecurityRequirements2 =\n        changedOperation2.getSecurityRequirements();\n    assertThat(changedSecurityRequirements2).isNotNull();\n    assertThat(changedSecurityRequirements2.isCompatible()).isFalse();\n    assertThat(changedSecurityRequirements2.getChanged()).hasSize(1);\n    ChangedSecurityRequirement changedSecurityRequirement2 =\n        changedSecurityRequirements2.getChanged().get(0);\n    assertThat(changedSecurityRequirement2.getChanged()).hasSize(1);\n    ChangedOAuthFlow changedImplicitOAuthFlow2 =\n        changedSecurityRequirement2.getChanged().get(0).getOAuthFlows().getImplicitOAuthFlow();\n    assertThat(changedImplicitOAuthFlow2).isNotNull();\n    assertThat(changedImplicitOAuthFlow2.isAuthorizationUrl()).isTrue();\n\n    ChangedOperation changedOperation3 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet/findByStatus2\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation3).isNotNull();\n    assertThat(changedOperation3.isCompatible()).isTrue();\n    ChangedSecurityRequirements changedSecurityRequirements3 =\n        changedOperation3.getSecurityRequirements();\n    assertThat(changedSecurityRequirements3).isNotNull();\n    assertThat(changedSecurityRequirements3.getIncreased()).hasSize(1);\n    SecurityRequirement securityRequirement3 = changedSecurityRequirements3.getIncreased().get(0);\n    assertThat(securityRequirement3)\n        .hasSize(1)\n        .hasEntrySatisfying(\"petstore_auth\", values -> assertThat(values).hasSize(2));\n  }\n\n  @Test\n  public void testWithUnknownSecurityScheme() {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC3, OPENAPI_DOC3));\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC4, OPENAPI_DOC4));\n  }\n\n  @Test\n  public void testMissingSecurityDefinition() {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC5, OPENAPI_DOC5));\n  }\n}\n", "file_hash": "a7248207dbec1da7ee6dc64b32cedf936514c7ff2bddfe3fce6cb59f72d68c73", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import io.swagger.v3.oas.models.security.SecurityRequirement;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.*;"], "methods": [], "classes": [{"original_string": "public class SecurityDiffTest {\n  private final String OPENAPI_DOC1 = \"security_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"security_diff_2.yaml\";\n  private final String OPENAPI_DOC3 = \"security_diff_3.yaml\";\n  private final String OPENAPI_DOC4 = \"security_diff_4.yaml\";\n  private final String OPENAPI_DOC5 = \"security_diff_5.yaml\";\n\n  @Test\n  public void testDiffDifferent() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getChangedOperations()).hasSize(3);\n\n    ChangedOperation changedOperation1 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet/{petId}\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation1).isNotNull();\n    assertThat(changedOperation1.isCompatible()).isFalse();\n    ChangedSecurityRequirements changedSecurityRequirements1 =\n        changedOperation1.getSecurityRequirements();\n    assertThat(changedSecurityRequirements1).isNotNull();\n    assertThat(changedSecurityRequirements1.isCompatible()).isFalse();\n    assertThat(changedSecurityRequirements1.getIncreased()).hasSize(1);\n    assertThat(changedSecurityRequirements1.getChanged()).hasSize(1);\n    ChangedSecurityRequirement changedSecurityRequirement1 =\n        changedSecurityRequirements1.getChanged().get(0);\n    assertThat(changedSecurityRequirement1.getChanged()).hasSize(1);\n    ChangedSecuritySchemeScopes changedScopes1 =\n        changedSecurityRequirement1.getChanged().get(0).getChangedScopes();\n    assertThat(changedScopes1)\n        .isNotNull()\n        .satisfies(\n            stringListDiff ->\n                assertThat(stringListDiff.getIncreased())\n                    .hasSize(1)\n                    .first()\n                    .asString()\n                    .isEqualTo(\"read:pets\"));\n\n    ChangedOperation changedOperation2 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet3\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation2).isNotNull();\n    assertThat(changedOperation2.isCompatible()).isFalse();\n    ChangedSecurityRequirements changedSecurityRequirements2 =\n        changedOperation2.getSecurityRequirements();\n    assertThat(changedSecurityRequirements2).isNotNull();\n    assertThat(changedSecurityRequirements2.isCompatible()).isFalse();\n    assertThat(changedSecurityRequirements2.getChanged()).hasSize(1);\n    ChangedSecurityRequirement changedSecurityRequirement2 =\n        changedSecurityRequirements2.getChanged().get(0);\n    assertThat(changedSecurityRequirement2.getChanged()).hasSize(1);\n    ChangedOAuthFlow changedImplicitOAuthFlow2 =\n        changedSecurityRequirement2.getChanged().get(0).getOAuthFlows().getImplicitOAuthFlow();\n    assertThat(changedImplicitOAuthFlow2).isNotNull();\n    assertThat(changedImplicitOAuthFlow2.isAuthorizationUrl()).isTrue();\n\n    ChangedOperation changedOperation3 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet/findByStatus2\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation3).isNotNull();\n    assertThat(changedOperation3.isCompatible()).isTrue();\n    ChangedSecurityRequirements changedSecurityRequirements3 =\n        changedOperation3.getSecurityRequirements();\n    assertThat(changedSecurityRequirements3).isNotNull();\n    assertThat(changedSecurityRequirements3.getIncreased()).hasSize(1);\n    SecurityRequirement securityRequirement3 = changedSecurityRequirements3.getIncreased().get(0);\n    assertThat(securityRequirement3)\n        .hasSize(1)\n        .hasEntrySatisfying(\"petstore_auth\", values -> assertThat(values).hasSize(2));\n  }\n\n  @Test\n  public void testWithUnknownSecurityScheme() {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC3, OPENAPI_DOC3));\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC4, OPENAPI_DOC4));\n  }\n\n  @Test\n  public void testMissingSecurityDefinition() {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC5, OPENAPI_DOC5));\n  }\n}", "definition": "public class SecurityDiffTest", "class_docstring": "", "name": "SecurityDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"security_diff_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"security_diff_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"security_diff_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"security_diff_2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC3 = \"security_diff_3.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC3 = \"security_diff_3.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC4 = \"security_diff_4.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC4 = \"security_diff_4.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC5 = \"security_diff_5.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC5 = \"security_diff_5.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferent() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getChangedOperations()).hasSize(3);\n\n    ChangedOperation changedOperation1 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet/{petId}\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation1).isNotNull();\n    assertThat(changedOperation1.isCompatible()).isFalse();\n    ChangedSecurityRequirements changedSecurityRequirements1 =\n        changedOperation1.getSecurityRequirements();\n    assertThat(changedSecurityRequirements1).isNotNull();\n    assertThat(changedSecurityRequirements1.isCompatible()).isFalse();\n    assertThat(changedSecurityRequirements1.getIncreased()).hasSize(1);\n    assertThat(changedSecurityRequirements1.getChanged()).hasSize(1);\n    ChangedSecurityRequirement changedSecurityRequirement1 =\n        changedSecurityRequirements1.getChanged().get(0);\n    assertThat(changedSecurityRequirement1.getChanged()).hasSize(1);\n    ChangedSecuritySchemeScopes changedScopes1 =\n        changedSecurityRequirement1.getChanged().get(0).getChangedScopes();\n    assertThat(changedScopes1)\n        .isNotNull()\n        .satisfies(\n            stringListDiff ->\n                assertThat(stringListDiff.getIncreased())\n                    .hasSize(1)\n                    .first()\n                    .asString()\n                    .isEqualTo(\"read:pets\"));\n\n    ChangedOperation changedOperation2 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet3\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation2).isNotNull();\n    assertThat(changedOperation2.isCompatible()).isFalse();\n    ChangedSecurityRequirements changedSecurityRequirements2 =\n        changedOperation2.getSecurityRequirements();\n    assertThat(changedSecurityRequirements2).isNotNull();\n    assertThat(changedSecurityRequirements2.isCompatible()).isFalse();\n    assertThat(changedSecurityRequirements2.getChanged()).hasSize(1);\n    ChangedSecurityRequirement changedSecurityRequirement2 =\n        changedSecurityRequirements2.getChanged().get(0);\n    assertThat(changedSecurityRequirement2.getChanged()).hasSize(1);\n    ChangedOAuthFlow changedImplicitOAuthFlow2 =\n        changedSecurityRequirement2.getChanged().get(0).getOAuthFlows().getImplicitOAuthFlow();\n    assertThat(changedImplicitOAuthFlow2).isNotNull();\n    assertThat(changedImplicitOAuthFlow2.isAuthorizationUrl()).isTrue();\n\n    ChangedOperation changedOperation3 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet/findByStatus2\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation3).isNotNull();\n    assertThat(changedOperation3.isCompatible()).isTrue();\n    ChangedSecurityRequirements changedSecurityRequirements3 =\n        changedOperation3.getSecurityRequirements();\n    assertThat(changedSecurityRequirements3).isNotNull();\n    assertThat(changedSecurityRequirements3.getIncreased()).hasSize(1);\n    SecurityRequirement securityRequirement3 = changedSecurityRequirements3.getIncreased().get(0);\n    assertThat(securityRequirement3)\n        .hasSize(1)\n        .hasEntrySatisfying(\"petstore_auth\", values -> assertThat(values).hasSize(2));\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferent", "params": [], "body": "                                  {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getChangedOperations()).hasSize(3);\n\n    ChangedOperation changedOperation1 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet/{petId}\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation1).isNotNull();\n    assertThat(changedOperation1.isCompatible()).isFalse();\n    ChangedSecurityRequirements changedSecurityRequirements1 =\n        changedOperation1.getSecurityRequirements();\n    assertThat(changedSecurityRequirements1).isNotNull();\n    assertThat(changedSecurityRequirements1.isCompatible()).isFalse();\n    assertThat(changedSecurityRequirements1.getIncreased()).hasSize(1);\n    assertThat(changedSecurityRequirements1.getChanged()).hasSize(1);\n    ChangedSecurityRequirement changedSecurityRequirement1 =\n        changedSecurityRequirements1.getChanged().get(0);\n    assertThat(changedSecurityRequirement1.getChanged()).hasSize(1);\n    ChangedSecuritySchemeScopes changedScopes1 =\n        changedSecurityRequirement1.getChanged().get(0).getChangedScopes();\n    assertThat(changedScopes1)\n        .isNotNull()\n        .satisfies(\n            stringListDiff ->\n                assertThat(stringListDiff.getIncreased())\n                    .hasSize(1)\n                    .first()\n                    .asString()\n                    .isEqualTo(\"read:pets\"));\n\n    ChangedOperation changedOperation2 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet3\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation2).isNotNull();\n    assertThat(changedOperation2.isCompatible()).isFalse();\n    ChangedSecurityRequirements changedSecurityRequirements2 =\n        changedOperation2.getSecurityRequirements();\n    assertThat(changedSecurityRequirements2).isNotNull();\n    assertThat(changedSecurityRequirements2.isCompatible()).isFalse();\n    assertThat(changedSecurityRequirements2.getChanged()).hasSize(1);\n    ChangedSecurityRequirement changedSecurityRequirement2 =\n        changedSecurityRequirements2.getChanged().get(0);\n    assertThat(changedSecurityRequirement2.getChanged()).hasSize(1);\n    ChangedOAuthFlow changedImplicitOAuthFlow2 =\n        changedSecurityRequirement2.getChanged().get(0).getOAuthFlows().getImplicitOAuthFlow();\n    assertThat(changedImplicitOAuthFlow2).isNotNull();\n    assertThat(changedImplicitOAuthFlow2.isAuthorizationUrl()).isTrue();\n\n    ChangedOperation changedOperation3 =\n        changedOpenApi.getChangedOperations().stream()\n            .filter(x -> x.getPathUrl().equals(\"/pet/findByStatus2\"))\n            .findFirst()\n            .get();\n    assertThat(changedOperation3).isNotNull();\n    assertThat(changedOperation3.isCompatible()).isTrue();\n    ChangedSecurityRequirements changedSecurityRequirements3 =\n        changedOperation3.getSecurityRequirements();\n    assertThat(changedSecurityRequirements3).isNotNull();\n    assertThat(changedSecurityRequirements3.getIncreased()).hasSize(1);\n    SecurityRequirement securityRequirement3 = changedSecurityRequirements3.getIncreased().get(0);\n    assertThat(securityRequirement3)\n        .hasSize(1)\n        .hasEntrySatisfying(\"petstore_auth\", values -> assertThat(values).hasSize(2));\n  }", "signature": "@Test\n  public void testDiffDifferent()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testWithUnknownSecurityScheme() {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC3, OPENAPI_DOC3));\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC4, OPENAPI_DOC4));\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWithUnknownSecurityScheme", "params": [], "body": "                                              {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC3, OPENAPI_DOC3));\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC4, OPENAPI_DOC4));\n  }", "signature": "@Test\n  public void testWithUnknownSecurityScheme()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testMissingSecurityDefinition() {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC5, OPENAPI_DOC5));\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMissingSecurityDefinition", "params": [], "body": "                                              {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(OPENAPI_DOC5, OPENAPI_DOC5));\n  }", "signature": "@Test\n  public void testMissingSecurityDefinition()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/ParameterDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ParameterDiffTest {\n\n  @Test\n  public void testDiffDifferent() {\n    assertOpenApiChangedEndpoints(\"parameters_diff_1.yaml\", \"parameters_diff_2.yaml\");\n  }\n\n  @Test\n  public void issue458MaximumDecreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_2.yaml\");\n  }\n\n  @Test\n  public void issue458MaximumIncreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_3.yaml\");\n  }\n\n  @Test\n  public void issue458MinimumDecreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_4.yaml\");\n  }\n\n  @Test\n  public void issue458MinimumIncreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_5.yaml\");\n  }\n\n  @Test\n  public void issue458IntegerFormatChanged() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_6.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMinimumChanged() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_7.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMaximumChanged() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_8.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMinimumRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_9.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMaximumRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_10.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMaximumTrueToFalse() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_12.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMinimumTrueToFalse() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_13.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMaximumTrueRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_12.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMinimumTrueRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_13.yaml\");\n  }\n\n  @Test\n  public void issue488RenameParameterAddAndRemoveParameterReturnFalse() {\n    assertOpenApiChangedEndpoints(\"issue-488-1.json\", \"issue-488-2.json\");\n  }\n}\n", "file_hash": "4d9fb7663db64e7f7976928a75171d882ac6d6eaec14f5ee7922a2017d9b8922", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class ParameterDiffTest {\n\n  @Test\n  public void testDiffDifferent() {\n    assertOpenApiChangedEndpoints(\"parameters_diff_1.yaml\", \"parameters_diff_2.yaml\");\n  }\n\n  @Test\n  public void issue458MaximumDecreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_2.yaml\");\n  }\n\n  @Test\n  public void issue458MaximumIncreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_3.yaml\");\n  }\n\n  @Test\n  public void issue458MinimumDecreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_4.yaml\");\n  }\n\n  @Test\n  public void issue458MinimumIncreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_5.yaml\");\n  }\n\n  @Test\n  public void issue458IntegerFormatChanged() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_6.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMinimumChanged() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_7.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMaximumChanged() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_8.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMinimumRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_9.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMaximumRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_10.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMaximumTrueToFalse() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_12.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMinimumTrueToFalse() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_13.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMaximumTrueRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_12.yaml\");\n  }\n\n  @Test\n  public void issue458ExclusiveMinimumTrueRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_13.yaml\");\n  }\n\n  @Test\n  public void issue488RenameParameterAddAndRemoveParameterReturnFalse() {\n    assertOpenApiChangedEndpoints(\"issue-488-1.json\", \"issue-488-2.json\");\n  }\n}", "definition": "public class ParameterDiffTest", "class_docstring": "", "name": "ParameterDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferent() {\n    assertOpenApiChangedEndpoints(\"parameters_diff_1.yaml\", \"parameters_diff_2.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferent", "params": [], "body": "                                  {\n    assertOpenApiChangedEndpoints(\"parameters_diff_1.yaml\", \"parameters_diff_2.yaml\");\n  }", "signature": "@Test\n  public void testDiffDifferent()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458MaximumDecreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_2.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458MaximumDecreased", "params": [], "body": "                                         {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_2.yaml\");\n  }", "signature": "@Test\n  public void issue458MaximumDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458MaximumIncreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_3.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458MaximumIncreased", "params": [], "body": "                                         {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_3.yaml\");\n  }", "signature": "@Test\n  public void issue458MaximumIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458MinimumDecreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_4.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458MinimumDecreased", "params": [], "body": "                                         {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_4.yaml\");\n  }", "signature": "@Test\n  public void issue458MinimumDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458MinimumIncreased() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_5.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458MinimumIncreased", "params": [], "body": "                                         {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_5.yaml\");\n  }", "signature": "@Test\n  public void issue458MinimumIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458IntegerFormatChanged() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_6.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458IntegerFormatChanged", "params": [], "body": "                                             {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_6.yaml\");\n  }", "signature": "@Test\n  public void issue458IntegerFormatChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458ExclusiveMinimumChanged() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_7.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458ExclusiveMinimumChanged", "params": [], "body": "                                                {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_7.yaml\");\n  }", "signature": "@Test\n  public void issue458ExclusiveMinimumChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458ExclusiveMaximumChanged() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_8.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458ExclusiveMaximumChanged", "params": [], "body": "                                                {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_8.yaml\");\n  }", "signature": "@Test\n  public void issue458ExclusiveMaximumChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458ExclusiveMinimumRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_9.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458ExclusiveMinimumRemoved", "params": [], "body": "                                                {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_9.yaml\");\n  }", "signature": "@Test\n  public void issue458ExclusiveMinimumRemoved()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458ExclusiveMaximumRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_10.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458ExclusiveMaximumRemoved", "params": [], "body": "                                                {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_1.yaml\", \"issue-458-integer-limits_10.yaml\");\n  }", "signature": "@Test\n  public void issue458ExclusiveMaximumRemoved()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458ExclusiveMaximumTrueToFalse() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_12.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458ExclusiveMaximumTrueToFalse", "params": [], "body": "                                                    {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_12.yaml\");\n  }", "signature": "@Test\n  public void issue458ExclusiveMaximumTrueToFalse()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458ExclusiveMinimumTrueToFalse() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_13.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458ExclusiveMinimumTrueToFalse", "params": [], "body": "                                                    {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_13.yaml\");\n  }", "signature": "@Test\n  public void issue458ExclusiveMinimumTrueToFalse()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458ExclusiveMaximumTrueRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_12.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458ExclusiveMaximumTrueRemoved", "params": [], "body": "                                                    {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_12.yaml\");\n  }", "signature": "@Test\n  public void issue458ExclusiveMaximumTrueRemoved()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue458ExclusiveMinimumTrueRemoved() {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_13.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue458ExclusiveMinimumTrueRemoved", "params": [], "body": "                                                    {\n    assertOpenApiChangedEndpoints(\n        \"issue-458-integer-limits_11.yaml\", \"issue-458-integer-limits_13.yaml\");\n  }", "signature": "@Test\n  public void issue458ExclusiveMinimumTrueRemoved()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void issue488RenameParameterAddAndRemoveParameterReturnFalse() {\n    assertOpenApiChangedEndpoints(\"issue-488-1.json\", \"issue-488-2.json\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "issue488RenameParameterAddAndRemoveParameterReturnFalse", "params": [], "body": "                                                                        {\n    assertOpenApiChangedEndpoints(\"issue-488-1.json\", \"issue-488-2.json\");\n  }", "signature": "@Test\n  public void issue488RenameParameterAddAndRemoveParameterReturnFalse()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/LargeSchemaTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardIncompatible;\nimport static org.slf4j.LoggerFactory.getLogger;\n\nimport io.swagger.v3.core.util.Yaml;\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.oas.models.Operation;\nimport io.swagger.v3.oas.models.PathItem;\nimport io.swagger.v3.oas.models.Paths;\nimport io.swagger.v3.oas.models.media.ArraySchema;\nimport io.swagger.v3.oas.models.media.Content;\nimport io.swagger.v3.oas.models.media.MediaType;\nimport io.swagger.v3.oas.models.media.ObjectSchema;\nimport io.swagger.v3.oas.models.media.Schema;\nimport io.swagger.v3.oas.models.media.StringSchema;\nimport io.swagger.v3.oas.models.parameters.RequestBody;\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport io.swagger.v3.oas.models.responses.ApiResponses;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.slf4j.Logger;\n\npublic class LargeSchemaTest {\n  public static final Logger LOG = getLogger(LargeSchemaTest.class);\n\n  @Test\n  public void testGeneratedApiSame() {\n    OpenAPI generated = largeGeneratedApi();\n    assertOpenApiAreEquals(generated, generated);\n  }\n\n  @Test\n  public void testGeneratedApiDifferent() {\n    OpenAPI generated = largeGeneratedApi();\n    OpenAPI generated2 = largeGeneratedApi();\n    assertOpenApiBackwardIncompatible(generated, generated2);\n  }\n\n  public static void assertOpenApiAreEquals(OpenAPI oldSpec, OpenAPI newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isEmpty();\n  }\n\n  public static void assertOpenApiBackwardIncompatible(OpenAPI oldSpec, OpenAPI newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }\n\n  public OpenAPI largeGeneratedApi() {\n    final int modelCount = 200;\n    final int arrayCount = 50;\n    final int refPerModelCount = 5;\n    final int endpointCount = 20;\n\n    Random random = new Random();\n\n    OpenAPI api = new OpenAPI();\n    api.setPaths(new Paths());\n    api.setComponents(new Components());\n\n    // create 200 model schemas\n    Map<String, Schema> schemas = new LinkedHashMap<>();\n    api.getComponents().setSchemas(schemas);\n    for (int i = 0; i < modelCount; i++) {\n      ObjectSchema schema = new ObjectSchema();\n      schema.setProperties(new LinkedHashMap<>());\n      schema.getProperties().put(\"name\", new StringSchema());\n      schema.getProperties().put(\"description\", new StringSchema());\n      List<String> required = new ArrayList<>();\n      required.add(\"name\");\n      schema.setRequired(required);\n      schemas.put(modelName(i), schema);\n    }\n\n    // create 50 array schemas\n    for (int i = modelCount; i < modelCount + arrayCount; i++) {\n      ArraySchema arraySchema = new ArraySchema();\n      arraySchema.setItems(refSchema(i));\n      schemas.put(modelName(i), arraySchema);\n    }\n\n    // list of schema names\n\n    // Create cyclic properties on schemas, make the refs required\n    schemas.values().stream()\n        .filter(schema -> schema instanceof ObjectSchema)\n        .map(schema -> (ObjectSchema) schema)\n        .forEach(\n            schema -> {\n              for (int i = 0; i < refPerModelCount; i++) {\n                int schemaNumber = random.nextInt(modelCount + arrayCount);\n                String propertyName = \"refTo\" + schemaNumber;\n                schema.getProperties().put(propertyName, refSchema(schemaNumber));\n                schema.getRequired().add(propertyName);\n              }\n            });\n\n    // generated endpoints\n    for (int i = 0; i < endpointCount; i++) {\n      String path = \"/endpoint\" + i;\n      PathItem pathItem = new PathItem();\n      Operation operation = new Operation();\n      pathItem.post(operation);\n\n      operation.setRequestBody(\n          new RequestBody()\n              .content(\n                  new Content()\n                      .addMediaType(\n                          \"application/json\", new MediaType().schema(refSchema(i % modelCount)))));\n      ApiResponse responseOk =\n          new ApiResponses()\n              .put(\n                  \"200\",\n                  new ApiResponse()\n                      .content(\n                          new Content()\n                              .addMediaType(\n                                  \"application/json\",\n                                  new MediaType().schema(refSchema(i % modelCount)))));\n      ApiResponses responses = new ApiResponses();\n      responses.put(\"200\", responseOk);\n      operation.setResponses(responses);\n      api.getPaths().put(path, pathItem);\n    }\n\n    try {\n      LOG.info(\"Printing schema to target/large-api.yaml\");\n      Yaml.pretty().writeValue(new File(\"target/large-api.yaml\"), api);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return api;\n  }\n\n  private Schema refSchema(final int i) {\n    String itemModelName = modelName(i);\n    Schema refSchema = new Schema();\n    refSchema.set$ref(\"#/components/schemas/\" + itemModelName);\n    return refSchema;\n  }\n\n  private String modelName(final int i) {\n    return String.format(\"Model%03d\", i);\n  }\n}\n", "file_hash": "47697d24791da3a15cb4c48522c4aa56fd195aaf27d02bcaf850ea1290e0375d", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardIncompatible;", "import static org.slf4j.LoggerFactory.getLogger;", "import io.swagger.v3.core.util.Yaml;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.OpenAPI;", "import io.swagger.v3.oas.models.Operation;", "import io.swagger.v3.oas.models.PathItem;", "import io.swagger.v3.oas.models.Paths;", "import io.swagger.v3.oas.models.media.ArraySchema;", "import io.swagger.v3.oas.models.media.Content;", "import io.swagger.v3.oas.models.media.MediaType;", "import io.swagger.v3.oas.models.media.ObjectSchema;", "import io.swagger.v3.oas.models.media.Schema;", "import io.swagger.v3.oas.models.media.StringSchema;", "import io.swagger.v3.oas.models.parameters.RequestBody;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import io.swagger.v3.oas.models.responses.ApiResponses;", "import java.io.File;", "import java.io.IOException;", "import java.util.ArrayList;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Random;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.slf4j.Logger;"], "methods": [], "classes": [{"original_string": "public class LargeSchemaTest {\n  public static final Logger LOG = getLogger(LargeSchemaTest.class);\n\n  @Test\n  public void testGeneratedApiSame() {\n    OpenAPI generated = largeGeneratedApi();\n    assertOpenApiAreEquals(generated, generated);\n  }\n\n  @Test\n  public void testGeneratedApiDifferent() {\n    OpenAPI generated = largeGeneratedApi();\n    OpenAPI generated2 = largeGeneratedApi();\n    assertOpenApiBackwardIncompatible(generated, generated2);\n  }\n\n  public static void assertOpenApiAreEquals(OpenAPI oldSpec, OpenAPI newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isEmpty();\n  }\n\n  public static void assertOpenApiBackwardIncompatible(OpenAPI oldSpec, OpenAPI newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }\n\n  public OpenAPI largeGeneratedApi() {\n    final int modelCount = 200;\n    final int arrayCount = 50;\n    final int refPerModelCount = 5;\n    final int endpointCount = 20;\n\n    Random random = new Random();\n\n    OpenAPI api = new OpenAPI();\n    api.setPaths(new Paths());\n    api.setComponents(new Components());\n\n    // create 200 model schemas\n    Map<String, Schema> schemas = new LinkedHashMap<>();\n    api.getComponents().setSchemas(schemas);\n    for (int i = 0; i < modelCount; i++) {\n      ObjectSchema schema = new ObjectSchema();\n      schema.setProperties(new LinkedHashMap<>());\n      schema.getProperties().put(\"name\", new StringSchema());\n      schema.getProperties().put(\"description\", new StringSchema());\n      List<String> required = new ArrayList<>();\n      required.add(\"name\");\n      schema.setRequired(required);\n      schemas.put(modelName(i), schema);\n    }\n\n    // create 50 array schemas\n    for (int i = modelCount; i < modelCount + arrayCount; i++) {\n      ArraySchema arraySchema = new ArraySchema();\n      arraySchema.setItems(refSchema(i));\n      schemas.put(modelName(i), arraySchema);\n    }\n\n    // list of schema names\n\n    // Create cyclic properties on schemas, make the refs required\n    schemas.values().stream()\n        .filter(schema -> schema instanceof ObjectSchema)\n        .map(schema -> (ObjectSchema) schema)\n        .forEach(\n            schema -> {\n              for (int i = 0; i < refPerModelCount; i++) {\n                int schemaNumber = random.nextInt(modelCount + arrayCount);\n                String propertyName = \"refTo\" + schemaNumber;\n                schema.getProperties().put(propertyName, refSchema(schemaNumber));\n                schema.getRequired().add(propertyName);\n              }\n            });\n\n    // generated endpoints\n    for (int i = 0; i < endpointCount; i++) {\n      String path = \"/endpoint\" + i;\n      PathItem pathItem = new PathItem();\n      Operation operation = new Operation();\n      pathItem.post(operation);\n\n      operation.setRequestBody(\n          new RequestBody()\n              .content(\n                  new Content()\n                      .addMediaType(\n                          \"application/json\", new MediaType().schema(refSchema(i % modelCount)))));\n      ApiResponse responseOk =\n          new ApiResponses()\n              .put(\n                  \"200\",\n                  new ApiResponse()\n                      .content(\n                          new Content()\n                              .addMediaType(\n                                  \"application/json\",\n                                  new MediaType().schema(refSchema(i % modelCount)))));\n      ApiResponses responses = new ApiResponses();\n      responses.put(\"200\", responseOk);\n      operation.setResponses(responses);\n      api.getPaths().put(path, pathItem);\n    }\n\n    try {\n      LOG.info(\"Printing schema to target/large-api.yaml\");\n      Yaml.pretty().writeValue(new File(\"target/large-api.yaml\"), api);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return api;\n  }\n\n  private Schema refSchema(final int i) {\n    String itemModelName = modelName(i);\n    Schema refSchema = new Schema();\n    refSchema.set$ref(\"#/components/schemas/\" + itemModelName);\n    return refSchema;\n  }\n\n  private String modelName(final int i) {\n    return String.format(\"Model%03d\", i);\n  }\n}", "definition": "public class LargeSchemaTest", "class_docstring": "", "name": "LargeSchemaTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "public static final Logger LOG = getLogger(LargeSchemaTest.class);", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Logger", "name": "LOG = getLogger(LargeSchemaTest.class)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testGeneratedApiSame() {\n    OpenAPI generated = largeGeneratedApi();\n    assertOpenApiAreEquals(generated, generated);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGeneratedApiSame", "params": [], "body": "                                     {\n    OpenAPI generated = largeGeneratedApi();\n    assertOpenApiAreEquals(generated, generated);\n  }", "signature": "@Test\n  public void testGeneratedApiSame()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testGeneratedApiDifferent() {\n    OpenAPI generated = largeGeneratedApi();\n    OpenAPI generated2 = largeGeneratedApi();\n    assertOpenApiBackwardIncompatible(generated, generated2);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGeneratedApiDifferent", "params": [], "body": "                                          {\n    OpenAPI generated = largeGeneratedApi();\n    OpenAPI generated2 = largeGeneratedApi();\n    assertOpenApiBackwardIncompatible(generated, generated2);\n  }", "signature": "@Test\n  public void testGeneratedApiDifferent()"}, {"syntax_pass": true, "original_string": "  public static void assertOpenApiAreEquals(OpenAPI oldSpec, OpenAPI newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isEmpty();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertOpenApiAreEquals", "params": [{"name": "oldSpec", "type": "OpenAPI"}, {"name": "newSpec", "type": "OpenAPI"}], "body": "                                                                              {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isEmpty();\n  }", "signature": "public static void assertOpenApiAreEquals(OpenAPI oldSpec, OpenAPI newSpec)"}, {"syntax_pass": true, "original_string": "  public static void assertOpenApiBackwardIncompatible(OpenAPI oldSpec, OpenAPI newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertOpenApiBackwardIncompatible", "params": [{"name": "oldSpec", "type": "OpenAPI"}, {"name": "newSpec", "type": "OpenAPI"}], "body": "                                                                                         {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }", "signature": "public static void assertOpenApiBackwardIncompatible(OpenAPI oldSpec, OpenAPI newSpec)"}, {"syntax_pass": true, "original_string": "  public OpenAPI largeGeneratedApi() {\n    final int modelCount = 200;\n    final int arrayCount = 50;\n    final int refPerModelCount = 5;\n    final int endpointCount = 20;\n\n    Random random = new Random();\n\n    OpenAPI api = new OpenAPI();\n    api.setPaths(new Paths());\n    api.setComponents(new Components());\n\n    // create 200 model schemas\n    Map<String, Schema> schemas = new LinkedHashMap<>();\n    api.getComponents().setSchemas(schemas);\n    for (int i = 0; i < modelCount; i++) {\n      ObjectSchema schema = new ObjectSchema();\n      schema.setProperties(new LinkedHashMap<>());\n      schema.getProperties().put(\"name\", new StringSchema());\n      schema.getProperties().put(\"description\", new StringSchema());\n      List<String> required = new ArrayList<>();\n      required.add(\"name\");\n      schema.setRequired(required);\n      schemas.put(modelName(i), schema);\n    }\n\n    // create 50 array schemas\n    for (int i = modelCount; i < modelCount + arrayCount; i++) {\n      ArraySchema arraySchema = new ArraySchema();\n      arraySchema.setItems(refSchema(i));\n      schemas.put(modelName(i), arraySchema);\n    }\n\n    // list of schema names\n\n    // Create cyclic properties on schemas, make the refs required\n    schemas.values().stream()\n        .filter(schema -> schema instanceof ObjectSchema)\n        .map(schema -> (ObjectSchema) schema)\n        .forEach(\n            schema -> {\n              for (int i = 0; i < refPerModelCount; i++) {\n                int schemaNumber = random.nextInt(modelCount + arrayCount);\n                String propertyName = \"refTo\" + schemaNumber;\n                schema.getProperties().put(propertyName, refSchema(schemaNumber));\n                schema.getRequired().add(propertyName);\n              }\n            });\n\n    // generated endpoints\n    for (int i = 0; i < endpointCount; i++) {\n      String path = \"/endpoint\" + i;\n      PathItem pathItem = new PathItem();\n      Operation operation = new Operation();\n      pathItem.post(operation);\n\n      operation.setRequestBody(\n          new RequestBody()\n              .content(\n                  new Content()\n                      .addMediaType(\n                          \"application/json\", new MediaType().schema(refSchema(i % modelCount)))));\n      ApiResponse responseOk =\n          new ApiResponses()\n              .put(\n                  \"200\",\n                  new ApiResponse()\n                      .content(\n                          new Content()\n                              .addMediaType(\n                                  \"application/json\",\n                                  new MediaType().schema(refSchema(i % modelCount)))));\n      ApiResponses responses = new ApiResponses();\n      responses.put(\"200\", responseOk);\n      operation.setResponses(responses);\n      api.getPaths().put(path, pathItem);\n    }\n\n    try {\n      LOG.info(\"Printing schema to target/large-api.yaml\");\n      Yaml.pretty().writeValue(new File(\"target/large-api.yaml\"), api);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return api;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OpenAPI", "classes": []}, "name": "largeGeneratedApi", "params": [], "body": "                                     {\n    final int modelCount = 200;\n    final int arrayCount = 50;\n    final int refPerModelCount = 5;\n    final int endpointCount = 20;\n\n    Random random = new Random();\n\n    OpenAPI api = new OpenAPI();\n    api.setPaths(new Paths());\n    api.setComponents(new Components());\n\n    // create 200 model schemas\n    Map<String, Schema> schemas = new LinkedHashMap<>();\n    api.getComponents().setSchemas(schemas);\n    for (int i = 0; i < modelCount; i++) {\n      ObjectSchema schema = new ObjectSchema();\n      schema.setProperties(new LinkedHashMap<>());\n      schema.getProperties().put(\"name\", new StringSchema());\n      schema.getProperties().put(\"description\", new StringSchema());\n      List<String> required = new ArrayList<>();\n      required.add(\"name\");\n      schema.setRequired(required);\n      schemas.put(modelName(i), schema);\n    }\n\n    // create 50 array schemas\n    for (int i = modelCount; i < modelCount + arrayCount; i++) {\n      ArraySchema arraySchema = new ArraySchema();\n      arraySchema.setItems(refSchema(i));\n      schemas.put(modelName(i), arraySchema);\n    }\n\n    // list of schema names\n\n    // Create cyclic properties on schemas, make the refs required\n    schemas.values().stream()\n        .filter(schema -> schema instanceof ObjectSchema)\n        .map(schema -> (ObjectSchema) schema)\n        .forEach(\n            schema -> {\n              for (int i = 0; i < refPerModelCount; i++) {\n                int schemaNumber = random.nextInt(modelCount + arrayCount);\n                String propertyName = \"refTo\" + schemaNumber;\n                schema.getProperties().put(propertyName, refSchema(schemaNumber));\n                schema.getRequired().add(propertyName);\n              }\n            });\n\n    // generated endpoints\n    for (int i = 0; i < endpointCount; i++) {\n      String path = \"/endpoint\" + i;\n      PathItem pathItem = new PathItem();\n      Operation operation = new Operation();\n      pathItem.post(operation);\n\n      operation.setRequestBody(\n          new RequestBody()\n              .content(\n                  new Content()\n                      .addMediaType(\n                          \"application/json\", new MediaType().schema(refSchema(i % modelCount)))));\n      ApiResponse responseOk =\n          new ApiResponses()\n              .put(\n                  \"200\",\n                  new ApiResponse()\n                      .content(\n                          new Content()\n                              .addMediaType(\n                                  \"application/json\",\n                                  new MediaType().schema(refSchema(i % modelCount)))));\n      ApiResponses responses = new ApiResponses();\n      responses.put(\"200\", responseOk);\n      operation.setResponses(responses);\n      api.getPaths().put(path, pathItem);\n    }\n\n    try {\n      LOG.info(\"Printing schema to target/large-api.yaml\");\n      Yaml.pretty().writeValue(new File(\"target/large-api.yaml\"), api);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return api;\n  }", "signature": "public OpenAPI largeGeneratedApi()"}, {"syntax_pass": true, "original_string": "  private Schema refSchema(final int i) {\n    String itemModelName = modelName(i);\n    Schema refSchema = new Schema();\n    refSchema.set$ref(\"#/components/schemas/\" + itemModelName);\n    return refSchema;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Schema", "classes": []}, "name": "refSchema", "params": [{"name": "i", "type": "int"}], "body": "                                        {\n    String itemModelName = modelName(i);\n    Schema refSchema = new Schema();\n    refSchema.set$ref(\"#/components/schemas/\" + itemModelName);\n    return refSchema;\n  }", "signature": "private Schema refSchema(final int i)"}, {"syntax_pass": true, "original_string": "  private String modelName(final int i) {\n    return String.format(\"Model%03d\", i);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "modelName", "params": [{"name": "i", "type": "int"}], "body": "                                        {\n    return String.format(\"Model%03d\", i);\n  }", "signature": "private String modelName(final int i)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/AddPropDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardCompatible;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AddPropDiffTest {\n  private final String OPENAPI_DOC1 = \"add-prop-1.yaml\";\n  private final String OPENAPI_DOC2 = \"add-prop-2.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testDiffDifferent() {\n    assertOpenApiBackwardCompatible(OPENAPI_DOC1, OPENAPI_DOC2, true);\n  }\n}\n", "file_hash": "bbe56cc6c311edfd254864a98cd33e10d9aadbc2d2987a8b7435b5c0dca1f76b", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardCompatible;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class AddPropDiffTest {\n  private final String OPENAPI_DOC1 = \"add-prop-1.yaml\";\n  private final String OPENAPI_DOC2 = \"add-prop-2.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testDiffDifferent() {\n    assertOpenApiBackwardCompatible(OPENAPI_DOC1, OPENAPI_DOC2, true);\n  }\n}", "definition": "public class AddPropDiffTest", "class_docstring": "", "name": "AddPropDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"add-prop-1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"add-prop-1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"add-prop-2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"add-prop-2.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffSame", "params": [], "body": "                             {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "signature": "@Test\n  public void testDiffSame()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferent() {\n    assertOpenApiBackwardCompatible(OPENAPI_DOC1, OPENAPI_DOC2, true);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferent", "params": [], "body": "                                  {\n    assertOpenApiBackwardCompatible(OPENAPI_DOC1, OPENAPI_DOC2, true);\n  }", "signature": "@Test\n  public void testDiffDifferent()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/RecursiveSchemaTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardIncompatible;\n\nimport org.junit.jupiter.api.Test;\n\npublic class RecursiveSchemaTest {\n\n  private final String OPENAPI_DOC1 = \"recursive_model_1.yaml\";\n  private final String OPENAPI_DOC2 = \"recursive_model_2.yaml\";\n  private final String OPENAPI_DOC3 = \"recursive_model_3.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testDiffDifferentCyclic() {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC1, OPENAPI_DOC3);\n  }\n\n  @Test\n  public void testDiffDifferent() {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC1, OPENAPI_DOC2);\n  }\n}\n", "file_hash": "30d9512acddca840d1d1f4dafc6b048991e29d257bc2ad5bc843764ea3c6c911", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardIncompatible;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class RecursiveSchemaTest {\n\n  private final String OPENAPI_DOC1 = \"recursive_model_1.yaml\";\n  private final String OPENAPI_DOC2 = \"recursive_model_2.yaml\";\n  private final String OPENAPI_DOC3 = \"recursive_model_3.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testDiffDifferentCyclic() {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC1, OPENAPI_DOC3);\n  }\n\n  @Test\n  public void testDiffDifferent() {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC1, OPENAPI_DOC2);\n  }\n}", "definition": "public class RecursiveSchemaTest", "class_docstring": "", "name": "RecursiveSchemaTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"recursive_model_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"recursive_model_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"recursive_model_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"recursive_model_2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC3 = \"recursive_model_3.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC3 = \"recursive_model_3.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffSame", "params": [], "body": "                             {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "signature": "@Test\n  public void testDiffSame()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferentCyclic() {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC1, OPENAPI_DOC3);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferentCyclic", "params": [], "body": "                                        {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC1, OPENAPI_DOC3);\n  }", "signature": "@Test\n  public void testDiffDifferentCyclic()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferent() {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC1, OPENAPI_DOC2);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferent", "params": [], "body": "                                  {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC1, OPENAPI_DOC2);\n  }", "signature": "@Test\n  public void testDiffDifferent()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/JsonRenderTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStreamWriter;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.output.JsonRender;\n\npublic class JsonRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    JsonRender render = new JsonRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotFailForJsr310Types() {\n    JsonRender render = new JsonRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"jsr310_property_1.yaml\", \"jsr310_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}\n", "file_hash": "7169208abf6db9fd27a1d3b4171d1ade402396ca9c1bbebe11dac8a2ac568169", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import java.io.ByteArrayOutputStream;", "import java.io.OutputStreamWriter;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.output.JsonRender;"], "methods": [], "classes": [{"original_string": "public class JsonRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    JsonRender render = new JsonRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotFailForJsr310Types() {\n    JsonRender render = new JsonRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"jsr310_property_1.yaml\", \"jsr310_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}", "definition": "public class JsonRenderTest", "class_docstring": "", "name": "JsonRenderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    JsonRender render = new JsonRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotFailWhenPropertyHasBeenRemoved", "params": [], "body": "                                                            {\n    JsonRender render = new JsonRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotFailForJsr310Types() {\n    JsonRender render = new JsonRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"jsr310_property_1.yaml\", \"jsr310_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotFailForJsr310Types", "params": [], "body": "                                                {\n    JsonRender render = new JsonRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"jsr310_property_1.yaml\", \"jsr310_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotFailForJsr310Types()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/ConsoleRenderTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStreamWriter;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.output.ConsoleRender;\n\npublic class ConsoleRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderShowsWhatsDeletedSectionWhenEndpointIsDeleted() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"delete_endpoint_1.yaml\", \"delete_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's Deleted\");\n  }\n\n  @Test\n  public void renderShowsWhatsNewSectionWhenEndpointIsAdded() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"add_endpoint_1.yaml\", \"add_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's New\");\n  }\n\n  @Test\n  public void renderShowsWhatsDeprecatedSectionWhenEndpointIsDeprecated() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"deprecate_endpoint_1.yaml\", \"deprecate_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's Deprecated\");\n  }\n\n  @Test\n  public void renderShowsWhatsChangedSectionWithCorrectFormattingWhenEndpointIsChanged() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"change_endpoint_1.yaml\", \"change_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .contains(\"What's Changed\")\n        .containsSubsequence(\"- GET    /widgets\", \"Parameter:\", \"- Changed query-param-1 in query\");\n  }\n}\n", "file_hash": "031fccba136b64edd822ef0021b2b46e1879ccc6493b6833974ab40427934634", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import java.io.ByteArrayOutputStream;", "import java.io.OutputStreamWriter;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.output.ConsoleRender;"], "methods": [], "classes": [{"original_string": "public class ConsoleRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderShowsWhatsDeletedSectionWhenEndpointIsDeleted() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"delete_endpoint_1.yaml\", \"delete_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's Deleted\");\n  }\n\n  @Test\n  public void renderShowsWhatsNewSectionWhenEndpointIsAdded() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"add_endpoint_1.yaml\", \"add_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's New\");\n  }\n\n  @Test\n  public void renderShowsWhatsDeprecatedSectionWhenEndpointIsDeprecated() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"deprecate_endpoint_1.yaml\", \"deprecate_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's Deprecated\");\n  }\n\n  @Test\n  public void renderShowsWhatsChangedSectionWithCorrectFormattingWhenEndpointIsChanged() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"change_endpoint_1.yaml\", \"change_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .contains(\"What's Changed\")\n        .containsSubsequence(\"- GET    /widgets\", \"Parameter:\", \"- Changed query-param-1 in query\");\n  }\n}", "definition": "public class ConsoleRenderTest", "class_docstring": "", "name": "ConsoleRenderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotFailWhenPropertyHasBeenRemoved", "params": [], "body": "                                                            {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotFailWhenHTTPStatusCodeIsRange", "params": [], "body": "                                                           {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderShowsWhatsDeletedSectionWhenEndpointIsDeleted() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"delete_endpoint_1.yaml\", \"delete_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's Deleted\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderShowsWhatsDeletedSectionWhenEndpointIsDeleted", "params": [], "body": "                                                                    {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"delete_endpoint_1.yaml\", \"delete_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's Deleted\");\n  }", "signature": "@Test\n  public void renderShowsWhatsDeletedSectionWhenEndpointIsDeleted()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderShowsWhatsNewSectionWhenEndpointIsAdded() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"add_endpoint_1.yaml\", \"add_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's New\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderShowsWhatsNewSectionWhenEndpointIsAdded", "params": [], "body": "                                                              {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"add_endpoint_1.yaml\", \"add_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's New\");\n  }", "signature": "@Test\n  public void renderShowsWhatsNewSectionWhenEndpointIsAdded()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderShowsWhatsDeprecatedSectionWhenEndpointIsDeprecated() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"deprecate_endpoint_1.yaml\", \"deprecate_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's Deprecated\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderShowsWhatsDeprecatedSectionWhenEndpointIsDeprecated", "params": [], "body": "                                                                          {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"deprecate_endpoint_1.yaml\", \"deprecate_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).contains(\"What's Deprecated\");\n  }", "signature": "@Test\n  public void renderShowsWhatsDeprecatedSectionWhenEndpointIsDeprecated()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderShowsWhatsChangedSectionWithCorrectFormattingWhenEndpointIsChanged() {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"change_endpoint_1.yaml\", \"change_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .contains(\"What's Changed\")\n        .containsSubsequence(\"- GET    /widgets\", \"Parameter:\", \"- Changed query-param-1 in query\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderShowsWhatsChangedSectionWithCorrectFormattingWhenEndpointIsChanged", "params": [], "body": "                                                                                         {\n    ConsoleRender render = new ConsoleRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"change_endpoint_1.yaml\", \"change_endpoint_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .contains(\"What's Changed\")\n        .containsSubsequence(\"- GET    /widgets\", \"Parameter:\", \"- Changed query-param-1 in query\");\n  }", "signature": "@Test\n  public void renderShowsWhatsChangedSectionWithCorrectFormattingWhenEndpointIsChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/ResponseHeaderDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedHeaders;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.model.ChangedResponse;\n\npublic class ResponseHeaderDiffTest {\n\n  private final String OPENAPI_DOC1 = \"header_1.yaml\";\n  private final String OPENAPI_DOC2 = \"header_2.yaml\";\n\n  @Test\n  public void testDiffDifferent() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n\n    Map<String, ChangedResponse> changedResponses =\n        changedOpenApi.getChangedOperations().get(0).getApiResponses().getChanged();\n    assertThat(changedResponses).isNotEmpty();\n    assertThat(changedResponses).containsKey(\"200\");\n    ChangedHeaders changedHeaders = changedResponses.get(\"200\").getHeaders();\n    assertThat(changedHeaders.isDifferent()).isTrue();\n    assertThat(changedHeaders.getChanged()).hasSize(1);\n    assertThat(changedHeaders.getIncreased()).hasSize(1);\n    assertThat(changedHeaders.getMissing()).hasSize(1);\n  }\n}\n", "file_hash": "d8f76641cea629f25d745c37dbc9e16098a011ea71393c2bc0345e05064c812f", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import java.util.Map;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedHeaders;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.model.ChangedResponse;"], "methods": [], "classes": [{"original_string": "public class ResponseHeaderDiffTest {\n\n  private final String OPENAPI_DOC1 = \"header_1.yaml\";\n  private final String OPENAPI_DOC2 = \"header_2.yaml\";\n\n  @Test\n  public void testDiffDifferent() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n\n    Map<String, ChangedResponse> changedResponses =\n        changedOpenApi.getChangedOperations().get(0).getApiResponses().getChanged();\n    assertThat(changedResponses).isNotEmpty();\n    assertThat(changedResponses).containsKey(\"200\");\n    ChangedHeaders changedHeaders = changedResponses.get(\"200\").getHeaders();\n    assertThat(changedHeaders.isDifferent()).isTrue();\n    assertThat(changedHeaders.getChanged()).hasSize(1);\n    assertThat(changedHeaders.getIncreased()).hasSize(1);\n    assertThat(changedHeaders.getMissing()).hasSize(1);\n  }\n}", "definition": "public class ResponseHeaderDiffTest", "class_docstring": "", "name": "ResponseHeaderDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"header_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"header_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"header_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"header_2.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferent() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n\n    Map<String, ChangedResponse> changedResponses =\n        changedOpenApi.getChangedOperations().get(0).getApiResponses().getChanged();\n    assertThat(changedResponses).isNotEmpty();\n    assertThat(changedResponses).containsKey(\"200\");\n    ChangedHeaders changedHeaders = changedResponses.get(\"200\").getHeaders();\n    assertThat(changedHeaders.isDifferent()).isTrue();\n    assertThat(changedHeaders.getChanged()).hasSize(1);\n    assertThat(changedHeaders.getIncreased()).hasSize(1);\n    assertThat(changedHeaders.getMissing()).hasSize(1);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferent", "params": [], "body": "                                  {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n\n    Map<String, ChangedResponse> changedResponses =\n        changedOpenApi.getChangedOperations().get(0).getApiResponses().getChanged();\n    assertThat(changedResponses).isNotEmpty();\n    assertThat(changedResponses).containsKey(\"200\");\n    ChangedHeaders changedHeaders = changedResponses.get(\"200\").getHeaders();\n    assertThat(changedHeaders.isDifferent()).isTrue();\n    assertThat(changedHeaders.getChanged()).hasSize(1);\n    assertThat(changedHeaders.getIncreased()).hasSize(1);\n    assertThat(changedHeaders.getMissing()).hasSize(1);\n  }", "signature": "@Test\n  public void testDiffDifferent()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/ResponseAddedContentSchemaTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport io.swagger.v3.oas.models.media.Content;\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.model.ChangedResponse;\nimport org.openapitools.openapidiff.core.output.ConsoleRender;\nimport org.openapitools.openapidiff.core.output.HtmlRender;\nimport org.openapitools.openapidiff.core.output.MarkdownRender;\nimport org.openapitools.openapidiff.core.output.Render;\n\npublic class ResponseAddedContentSchemaTest {\n\n  private final String OPENAPI_DOC1 = \"response_schema_added_1.yaml\";\n  private final String OPENAPI_DOC2 = \"response_schema_added_2.yaml\";\n\n  @Test\n  public void testDiffDifferent() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n\n    Map<String, ChangedResponse> changedResponses =\n        changedOpenApi.getChangedOperations().get(0).getApiResponses().getChanged();\n    assertThat(changedResponses).containsKey(\"200\");\n\n    ChangedResponse changedResponse = changedResponses.get(\"200\");\n    Content oldContent = changedResponse.getOldApiResponse().getContent();\n    Content newContent = changedResponse.getNewApiResponse().getContent();\n    assertThat(oldContent.get(\"application/json\").getSchema()).isNull();\n    assertThat(newContent.get(\"application/json\").getSchema()).isNotNull();\n  }\n\n  @Test\n  public void testDiffCanBeRendered() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new ConsoleRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n\n    outputStream = new ByteArrayOutputStream();\n    outputStreamWriter = new OutputStreamWriter(outputStream);\n    render = new HtmlRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n\n    outputStream = new ByteArrayOutputStream();\n    outputStreamWriter = new OutputStreamWriter(outputStream);\n    render = new MarkdownRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}\n", "file_hash": "97f3d27ef76554d71119863eb89e8bb3f0cc8b51f953020f918805de84b419cc", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import io.swagger.v3.oas.models.media.Content;", "import java.io.ByteArrayOutputStream;", "import java.io.OutputStreamWriter;", "import java.util.Map;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.model.ChangedResponse;", "import org.openapitools.openapidiff.core.output.ConsoleRender;", "import org.openapitools.openapidiff.core.output.HtmlRender;", "import org.openapitools.openapidiff.core.output.MarkdownRender;", "import org.openapitools.openapidiff.core.output.Render;"], "methods": [], "classes": [{"original_string": "public class ResponseAddedContentSchemaTest {\n\n  private final String OPENAPI_DOC1 = \"response_schema_added_1.yaml\";\n  private final String OPENAPI_DOC2 = \"response_schema_added_2.yaml\";\n\n  @Test\n  public void testDiffDifferent() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n\n    Map<String, ChangedResponse> changedResponses =\n        changedOpenApi.getChangedOperations().get(0).getApiResponses().getChanged();\n    assertThat(changedResponses).containsKey(\"200\");\n\n    ChangedResponse changedResponse = changedResponses.get(\"200\");\n    Content oldContent = changedResponse.getOldApiResponse().getContent();\n    Content newContent = changedResponse.getNewApiResponse().getContent();\n    assertThat(oldContent.get(\"application/json\").getSchema()).isNull();\n    assertThat(newContent.get(\"application/json\").getSchema()).isNotNull();\n  }\n\n  @Test\n  public void testDiffCanBeRendered() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new ConsoleRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n\n    outputStream = new ByteArrayOutputStream();\n    outputStreamWriter = new OutputStreamWriter(outputStream);\n    render = new HtmlRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n\n    outputStream = new ByteArrayOutputStream();\n    outputStreamWriter = new OutputStreamWriter(outputStream);\n    render = new MarkdownRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}", "definition": "public class ResponseAddedContentSchemaTest", "class_docstring": "", "name": "ResponseAddedContentSchemaTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"response_schema_added_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"response_schema_added_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"response_schema_added_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"response_schema_added_2.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferent() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n\n    Map<String, ChangedResponse> changedResponses =\n        changedOpenApi.getChangedOperations().get(0).getApiResponses().getChanged();\n    assertThat(changedResponses).containsKey(\"200\");\n\n    ChangedResponse changedResponse = changedResponses.get(\"200\");\n    Content oldContent = changedResponse.getOldApiResponse().getContent();\n    Content newContent = changedResponse.getNewApiResponse().getContent();\n    assertThat(oldContent.get(\"application/json\").getSchema()).isNull();\n    assertThat(newContent.get(\"application/json\").getSchema()).isNotNull();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferent", "params": [], "body": "                                  {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n\n    Map<String, ChangedResponse> changedResponses =\n        changedOpenApi.getChangedOperations().get(0).getApiResponses().getChanged();\n    assertThat(changedResponses).containsKey(\"200\");\n\n    ChangedResponse changedResponse = changedResponses.get(\"200\");\n    Content oldContent = changedResponse.getOldApiResponse().getContent();\n    Content newContent = changedResponse.getNewApiResponse().getContent();\n    assertThat(oldContent.get(\"application/json\").getSchema()).isNull();\n    assertThat(newContent.get(\"application/json\").getSchema()).isNotNull();\n  }", "signature": "@Test\n  public void testDiffDifferent()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffCanBeRendered() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new ConsoleRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n\n    outputStream = new ByteArrayOutputStream();\n    outputStreamWriter = new OutputStreamWriter(outputStream);\n    render = new HtmlRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n\n    outputStream = new ByteArrayOutputStream();\n    outputStreamWriter = new OutputStreamWriter(outputStream);\n    render = new MarkdownRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffCanBeRendered", "params": [], "body": "                                      {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new ConsoleRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n\n    outputStream = new ByteArrayOutputStream();\n    outputStreamWriter = new OutputStreamWriter(outputStream);\n    render = new HtmlRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n\n    outputStream = new ByteArrayOutputStream();\n    outputStreamWriter = new OutputStreamWriter(outputStream);\n    render = new MarkdownRender();\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void testDiffCanBeRendered()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/HtmlRenderTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStreamWriter;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.output.HtmlRender;\n\npublic class HtmlRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    HtmlRender render = new HtmlRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}\n", "file_hash": "1d6c55e2846bfe1646494bf42f4157ddc50447247cde2c90d52836e7fce10fbd", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import java.io.ByteArrayOutputStream;", "import java.io.OutputStreamWriter;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.output.HtmlRender;"], "methods": [], "classes": [{"original_string": "public class HtmlRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    HtmlRender render = new HtmlRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}", "definition": "public class HtmlRenderTest", "class_docstring": "", "name": "HtmlRenderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    HtmlRender render = new HtmlRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotFailWhenPropertyHasBeenRemoved", "params": [], "body": "                                                            {\n    HtmlRender render = new HtmlRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/AllOfOneOfDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\n\npublic class AllOfOneOfDiffTest {\n  @Test\n  void allOfReferringToOneOfSchemasAreSupported() {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"issue-317_1.json\", \"issue-317_2.json\");\n    assertThat(diff.isCoreChanged().isUnchanged());\n  }\n}\n", "file_hash": "e8e6b77ee84e23fe8971b0422fd820b1bc8371705568cfe568f92bc1c6d5e7f1", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;"], "methods": [], "classes": [{"original_string": "public class AllOfOneOfDiffTest {\n  @Test\n  void allOfReferringToOneOfSchemasAreSupported() {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"issue-317_1.json\", \"issue-317_2.json\");\n    assertThat(diff.isCoreChanged().isUnchanged());\n  }\n}", "definition": "public class AllOfOneOfDiffTest", "class_docstring": "", "name": "AllOfOneOfDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  void allOfReferringToOneOfSchemasAreSupported() {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"issue-317_1.json\", \"issue-317_2.json\");\n    assertThat(diff.isCoreChanged().isUnchanged());\n  }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "allOfReferringToOneOfSchemasAreSupported", "params": [], "body": "                                                  {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"issue-317_1.json\", \"issue-317_2.json\");\n    assertThat(diff.isCoreChanged().isUnchanged());\n  }", "signature": "@Test\n  void allOfReferringToOneOfSchemasAreSupported()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/ParametersOverloadingTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\n\nimport org.junit.jupiter.api.Test;\n\nclass ParametersOverloadingTest {\n\n  private final String OVERLOADED_PARAMETERS = \"parameters_overloading.yaml\";\n  private final String DUPLICATED_PARAMETER_TYPES = \"parameters_overloading_2.yaml\";\n\n  @Test\n  void testDiffWithOverloadedParameterTypes() {\n    assertDoesNotThrow(\n        () -> OpenApiCompare.fromLocations(OVERLOADED_PARAMETERS, OVERLOADED_PARAMETERS));\n    assertOpenApiAreEquals(OVERLOADED_PARAMETERS, OVERLOADED_PARAMETERS);\n  }\n\n  @Test\n  void testDiffWithDuplicatedParameterTypes() {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(DUPLICATED_PARAMETER_TYPES, DUPLICATED_PARAMETER_TYPES),\n        \"Two path items have the same signature: /projects/{}\");\n  }\n}\n", "file_hash": "af34d4eb6fc87635e1b88ac1ae4f387bc28e3737412dfca054aad1dfdbb14f8b", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.junit.jupiter.api.Assertions.*;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "class ParametersOverloadingTest {\n\n  private final String OVERLOADED_PARAMETERS = \"parameters_overloading.yaml\";\n  private final String DUPLICATED_PARAMETER_TYPES = \"parameters_overloading_2.yaml\";\n\n  @Test\n  void testDiffWithOverloadedParameterTypes() {\n    assertDoesNotThrow(\n        () -> OpenApiCompare.fromLocations(OVERLOADED_PARAMETERS, OVERLOADED_PARAMETERS));\n    assertOpenApiAreEquals(OVERLOADED_PARAMETERS, OVERLOADED_PARAMETERS);\n  }\n\n  @Test\n  void testDiffWithDuplicatedParameterTypes() {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(DUPLICATED_PARAMETER_TYPES, DUPLICATED_PARAMETER_TYPES),\n        \"Two path items have the same signature: /projects/{}\");\n  }\n}", "definition": "class ParametersOverloadingTest", "class_docstring": "", "name": "ParametersOverloadingTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private final String OVERLOADED_PARAMETERS = \"parameters_overloading.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OVERLOADED_PARAMETERS = \"parameters_overloading.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String DUPLICATED_PARAMETER_TYPES = \"parameters_overloading_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "DUPLICATED_PARAMETER_TYPES = \"parameters_overloading_2.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  void testDiffWithOverloadedParameterTypes() {\n    assertDoesNotThrow(\n        () -> OpenApiCompare.fromLocations(OVERLOADED_PARAMETERS, OVERLOADED_PARAMETERS));\n    assertOpenApiAreEquals(OVERLOADED_PARAMETERS, OVERLOADED_PARAMETERS);\n  }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffWithOverloadedParameterTypes", "params": [], "body": "                                              {\n    assertDoesNotThrow(\n        () -> OpenApiCompare.fromLocations(OVERLOADED_PARAMETERS, OVERLOADED_PARAMETERS));\n    assertOpenApiAreEquals(OVERLOADED_PARAMETERS, OVERLOADED_PARAMETERS);\n  }", "signature": "@Test\n  void testDiffWithOverloadedParameterTypes()"}, {"syntax_pass": true, "original_string": "  @Test\n  void testDiffWithDuplicatedParameterTypes() {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(DUPLICATED_PARAMETER_TYPES, DUPLICATED_PARAMETER_TYPES),\n        \"Two path items have the same signature: /projects/{}\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffWithDuplicatedParameterTypes", "params": [], "body": "                                              {\n    assertThrows(\n        IllegalArgumentException.class,\n        () -> OpenApiCompare.fromLocations(DUPLICATED_PARAMETER_TYPES, DUPLICATED_PARAMETER_TYPES),\n        \"Two path items have the same signature: /projects/{}\");\n  }", "signature": "@Test\n  void testDiffWithDuplicatedParameterTypes()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/AddPropPutDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\n\npublic class AddPropPutDiffTest {\n  private final String OPENAPI_DOC1 = \"add-prop-put-1.yaml\";\n  private final String OPENAPI_DOC2 = \"add-prop-put-2.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testFieldAdditionalInPutApiIsCompatible() {\n    // See https://github.com/OpenAPITools/openapi-diff/pull/537\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n}\n", "file_hash": "f6e656b4f3ea7a89aff3b26b1d49ae81952b5ac361955882a71d145a2e33889a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;"], "methods": [], "classes": [{"original_string": "public class AddPropPutDiffTest {\n  private final String OPENAPI_DOC1 = \"add-prop-put-1.yaml\";\n  private final String OPENAPI_DOC2 = \"add-prop-put-2.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testFieldAdditionalInPutApiIsCompatible() {\n    // See https://github.com/OpenAPITools/openapi-diff/pull/537\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n}", "definition": "public class AddPropPutDiffTest", "class_docstring": "", "name": "AddPropPutDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"add-prop-put-1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"add-prop-put-1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"add-prop-put-2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"add-prop-put-2.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffSame", "params": [], "body": "                             {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "signature": "@Test\n  public void testDiffSame()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testFieldAdditionalInPutApiIsCompatible() {\n    // See https://github.com/OpenAPITools/openapi-diff/pull/537\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFieldAdditionalInPutApiIsCompatible", "params": [], "body": "                                                        {\n    // See https://github.com/OpenAPITools/openapi-diff/pull/537\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "signature": "@Test\n  public void testFieldAdditionalInPutApiIsCompatible()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/PathDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\n\npublic class PathDiffTest {\n\n  private final String OPENAPI_PATH1 = \"path_1.yaml\";\n  private final String OPENAPI_PATH2 = \"path_2.yaml\";\n  private final String OPENAPI_PATH3 = \"path_3.yaml\";\n  private final String OPENAPI_PATH4 = \"path_4.yaml\";\n  private final String OPENAPI_PATH5 = \"path_5.yaml\";\n  private final String OPENAPI_PATH6 = \"path_6.yaml\";\n\n  @Test\n  public void testEqual() {\n    assertOpenApiAreEquals(OPENAPI_PATH1, OPENAPI_PATH2);\n  }\n\n  @Test\n  public void testMultiplePathWithSameSignature() {\n    assertThrows(\n        IllegalArgumentException.class, () -> assertOpenApiAreEquals(OPENAPI_PATH3, OPENAPI_PATH3));\n  }\n\n  @Test\n  public void testSameTemplateDifferentMethods() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_PATH1, OPENAPI_PATH4);\n    assertThat(changedOpenApi.getNewEndpoints())\n        .hasSize(1)\n        .satisfiesExactly(\n            endpoint ->\n                assertThat(endpoint.getOperation().getOperationId()).isEqualTo(\"deletePet\"));\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n\n  @Test\n  public void testDiffWithSimilarBeginningPaths() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_PATH5, OPENAPI_PATH6);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromSpecifications(\n            changedOpenApi.getOldSpecOpenApi(), changedOpenApi.getNewSpecOpenApi());\n    assertThat(diff.getChangedOperations()).isEmpty();\n  }\n}\n", "file_hash": "b1d2abae3205dccf41f269e50847567963fefd3615e8ac9253da81a9f8854557", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import static org.junit.jupiter.api.Assertions.assertThrows;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;"], "methods": [], "classes": [{"original_string": "public class PathDiffTest {\n\n  private final String OPENAPI_PATH1 = \"path_1.yaml\";\n  private final String OPENAPI_PATH2 = \"path_2.yaml\";\n  private final String OPENAPI_PATH3 = \"path_3.yaml\";\n  private final String OPENAPI_PATH4 = \"path_4.yaml\";\n  private final String OPENAPI_PATH5 = \"path_5.yaml\";\n  private final String OPENAPI_PATH6 = \"path_6.yaml\";\n\n  @Test\n  public void testEqual() {\n    assertOpenApiAreEquals(OPENAPI_PATH1, OPENAPI_PATH2);\n  }\n\n  @Test\n  public void testMultiplePathWithSameSignature() {\n    assertThrows(\n        IllegalArgumentException.class, () -> assertOpenApiAreEquals(OPENAPI_PATH3, OPENAPI_PATH3));\n  }\n\n  @Test\n  public void testSameTemplateDifferentMethods() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_PATH1, OPENAPI_PATH4);\n    assertThat(changedOpenApi.getNewEndpoints())\n        .hasSize(1)\n        .satisfiesExactly(\n            endpoint ->\n                assertThat(endpoint.getOperation().getOperationId()).isEqualTo(\"deletePet\"));\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n\n  @Test\n  public void testDiffWithSimilarBeginningPaths() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_PATH5, OPENAPI_PATH6);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromSpecifications(\n            changedOpenApi.getOldSpecOpenApi(), changedOpenApi.getNewSpecOpenApi());\n    assertThat(diff.getChangedOperations()).isEmpty();\n  }\n}", "definition": "public class PathDiffTest", "class_docstring": "", "name": "PathDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_PATH1 = \"path_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_PATH1 = \"path_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_PATH2 = \"path_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_PATH2 = \"path_2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_PATH3 = \"path_3.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_PATH3 = \"path_3.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_PATH4 = \"path_4.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_PATH4 = \"path_4.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_PATH5 = \"path_5.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_PATH5 = \"path_5.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_PATH6 = \"path_6.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_PATH6 = \"path_6.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testEqual() {\n    assertOpenApiAreEquals(OPENAPI_PATH1, OPENAPI_PATH2);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEqual", "params": [], "body": "                          {\n    assertOpenApiAreEquals(OPENAPI_PATH1, OPENAPI_PATH2);\n  }", "signature": "@Test\n  public void testEqual()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testMultiplePathWithSameSignature() {\n    assertThrows(\n        IllegalArgumentException.class, () -> assertOpenApiAreEquals(OPENAPI_PATH3, OPENAPI_PATH3));\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMultiplePathWithSameSignature", "params": [], "body": "                                                  {\n    assertThrows(\n        IllegalArgumentException.class, () -> assertOpenApiAreEquals(OPENAPI_PATH3, OPENAPI_PATH3));\n  }", "signature": "@Test\n  public void testMultiplePathWithSameSignature()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testSameTemplateDifferentMethods() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_PATH1, OPENAPI_PATH4);\n    assertThat(changedOpenApi.getNewEndpoints())\n        .hasSize(1)\n        .satisfiesExactly(\n            endpoint ->\n                assertThat(endpoint.getOperation().getOperationId()).isEqualTo(\"deletePet\"));\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSameTemplateDifferentMethods", "params": [], "body": "                                                 {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_PATH1, OPENAPI_PATH4);\n    assertThat(changedOpenApi.getNewEndpoints())\n        .hasSize(1)\n        .satisfiesExactly(\n            endpoint ->\n                assertThat(endpoint.getOperation().getOperationId()).isEqualTo(\"deletePet\"));\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "signature": "@Test\n  public void testSameTemplateDifferentMethods()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffWithSimilarBeginningPaths() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_PATH5, OPENAPI_PATH6);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromSpecifications(\n            changedOpenApi.getOldSpecOpenApi(), changedOpenApi.getNewSpecOpenApi());\n    assertThat(diff.getChangedOperations()).isEmpty();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffWithSimilarBeginningPaths", "params": [], "body": "                                                  {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_PATH5, OPENAPI_PATH6);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromSpecifications(\n            changedOpenApi.getOldSpecOpenApi(), changedOpenApi.getNewSpecOpenApi());\n    assertThat(diff.getChangedOperations()).isEmpty();\n  }", "signature": "@Test\n  public void testDiffWithSimilarBeginningPaths()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/OperationDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.model.DiffResult;\n\npublic class OperationDiffTest {\n\n  private final String OPENAPI_DOC1 = \"operation_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"operation_diff_2.yaml\";\n\n  @Test\n  public void testContentDiffWithOneEmptyMediaType() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isChanged()).isEqualTo(DiffResult.METADATA);\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.getChangedOperations().size()).isEqualTo(1);\n    assertThat(changedOpenApi.getChangedOperations().get(0).getOperationId().isDifferent())\n        .isTrue();\n  }\n}\n", "file_hash": "a0666e1069d115c6eb530763dbe28840da1d82866184edd0bc0ec376d0e21a8d", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.model.DiffResult;"], "methods": [], "classes": [{"original_string": "public class OperationDiffTest {\n\n  private final String OPENAPI_DOC1 = \"operation_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"operation_diff_2.yaml\";\n\n  @Test\n  public void testContentDiffWithOneEmptyMediaType() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isChanged()).isEqualTo(DiffResult.METADATA);\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.getChangedOperations().size()).isEqualTo(1);\n    assertThat(changedOpenApi.getChangedOperations().get(0).getOperationId().isDifferent())\n        .isTrue();\n  }\n}", "definition": "public class OperationDiffTest", "class_docstring": "", "name": "OperationDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"operation_diff_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"operation_diff_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"operation_diff_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"operation_diff_2.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testContentDiffWithOneEmptyMediaType() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isChanged()).isEqualTo(DiffResult.METADATA);\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.getChangedOperations().size()).isEqualTo(1);\n    assertThat(changedOpenApi.getChangedOperations().get(0).getOperationId().isDifferent())\n        .isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContentDiffWithOneEmptyMediaType", "params": [], "body": "                                                     {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isChanged()).isEqualTo(DiffResult.METADATA);\n    assertThat(changedOpenApi.isDifferent()).isTrue();\n    assertThat(changedOpenApi.getChangedOperations().size()).isEqualTo(1);\n    assertThat(changedOpenApi.getChangedOperations().get(0).getOperationId().isDifferent())\n        .isTrue();\n  }", "signature": "@Test\n  public void testContentDiffWithOneEmptyMediaType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/OpenApiDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\n\nimport io.swagger.parser.OpenAPIParser;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.parser.core.models.ParseOptions;\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.model.ChangedOperation;\nimport org.openapitools.openapidiff.core.model.DiffResult;\nimport org.openapitools.openapidiff.core.model.Endpoint;\nimport org.openapitools.openapidiff.core.output.HtmlRender;\nimport org.openapitools.openapidiff.core.output.JsonRender;\nimport org.openapitools.openapidiff.core.output.MarkdownRender;\nimport org.openapitools.openapidiff.core.output.Render;\n\npublic class OpenApiDiffTest {\n\n  private final String OPENAPI_DOC1 = \"petstore_v2_1.yaml\";\n  private final String OPENAPI_DOC2 = \"petstore_v2_2.yaml\";\n  private final String OPENAPI_EMPTY_DOC = \"petstore_v2_empty.yaml\";\n  private final String OPENAPI_DOC3 = \"petstore_openapi3.yaml\";\n\n  private static final OpenAPIParser PARSER = new OpenAPIParser();\n\n  @Test\n  public void testEqual() {\n    assertOpenApiAreEquals(OPENAPI_DOC2, OPENAPI_DOC2);\n  }\n\n  @Test\n  public void testNewApi() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_EMPTY_DOC, OPENAPI_DOC2);\n    List<Endpoint> newEndpoints = changedOpenApi.getNewEndpoints();\n    List<Endpoint> missingEndpoints = changedOpenApi.getMissingEndpoints();\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(newEndpoints).isNotEmpty();\n    assertThat(missingEndpoints).isEmpty();\n    assertThat(changedEndPoints).isEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void testDeprecatedApi() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_EMPTY_DOC);\n    List<Endpoint> newEndpoints = changedOpenApi.getNewEndpoints();\n    List<Endpoint> missingEndpoints = changedOpenApi.getMissingEndpoints();\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(newEndpoints).isEmpty();\n    assertThat(missingEndpoints).isNotEmpty();\n    assertThat(changedEndPoints).isEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void testDiff() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(changedEndPoints).isNotEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void testDiffAndMarkdown() {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new MarkdownRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void testDiffAndJson() {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new JsonRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  /** Testing that repetitive specs comparisons has to produce consistent result. */\n  @Test\n  public void testComparisonConsistency() {\n    final OpenAPI oldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI newSpec = loadSpecFromFile(OPENAPI_DOC3);\n\n    final ChangedOpenApi diff1 = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    assertThat(diff1.isChanged()).isEqualTo(DiffResult.NO_CHANGES);\n    assertThat(diff1.getNewEndpoints()).isEmpty();\n    assertThat(diff1.getMissingEndpoints()).isEmpty();\n    assertThat(diff1.getChangedOperations()).isEmpty();\n\n    final ChangedOpenApi diff2 = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    assertThat(diff2.isChanged()).isEqualTo(DiffResult.NO_CHANGES);\n    assertThat(diff2.getNewEndpoints()).isEmpty();\n    assertThat(diff2.getMissingEndpoints()).isEmpty();\n    assertThat(diff2.getChangedOperations()).isEmpty();\n  }\n\n  @Test\n  public void testSpecObjectsAreNotChangesAfterComparison() {\n    final OpenAPI oldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI newSpec = loadSpecFromFile(OPENAPI_DOC3);\n\n    OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n\n    final OpenAPI expectedOldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI expectedNewSpec = loadSpecFromFile(OPENAPI_DOC3);\n    assertThat(oldSpec).isEqualTo(expectedOldSpec);\n    assertThat(newSpec).isEqualTo(expectedNewSpec);\n  }\n\n  private static OpenAPI loadSpecFromFile(String specFile) {\n    return PARSER.readLocation(specFile, null, new ParseOptions()).getOpenAPI();\n  }\n}\n", "file_hash": "7ad091421b36902baf2122aa60b303d2ef0a309af7e4121e0e839cf9a90e9d88", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import io.swagger.parser.OpenAPIParser;", "import io.swagger.v3.oas.models.OpenAPI;", "import io.swagger.v3.parser.core.models.ParseOptions;", "import java.io.ByteArrayOutputStream;", "import java.io.OutputStreamWriter;", "import java.util.List;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.model.ChangedOperation;", "import org.openapitools.openapidiff.core.model.DiffResult;", "import org.openapitools.openapidiff.core.model.Endpoint;", "import org.openapitools.openapidiff.core.output.HtmlRender;", "import org.openapitools.openapidiff.core.output.JsonRender;", "import org.openapitools.openapidiff.core.output.MarkdownRender;", "import org.openapitools.openapidiff.core.output.Render;"], "methods": [], "classes": [{"original_string": "public class OpenApiDiffTest {\n\n  private final String OPENAPI_DOC1 = \"petstore_v2_1.yaml\";\n  private final String OPENAPI_DOC2 = \"petstore_v2_2.yaml\";\n  private final String OPENAPI_EMPTY_DOC = \"petstore_v2_empty.yaml\";\n  private final String OPENAPI_DOC3 = \"petstore_openapi3.yaml\";\n\n  private static final OpenAPIParser PARSER = new OpenAPIParser();\n\n  @Test\n  public void testEqual() {\n    assertOpenApiAreEquals(OPENAPI_DOC2, OPENAPI_DOC2);\n  }\n\n  @Test\n  public void testNewApi() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_EMPTY_DOC, OPENAPI_DOC2);\n    List<Endpoint> newEndpoints = changedOpenApi.getNewEndpoints();\n    List<Endpoint> missingEndpoints = changedOpenApi.getMissingEndpoints();\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(newEndpoints).isNotEmpty();\n    assertThat(missingEndpoints).isEmpty();\n    assertThat(changedEndPoints).isEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void testDeprecatedApi() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_EMPTY_DOC);\n    List<Endpoint> newEndpoints = changedOpenApi.getNewEndpoints();\n    List<Endpoint> missingEndpoints = changedOpenApi.getMissingEndpoints();\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(newEndpoints).isEmpty();\n    assertThat(missingEndpoints).isNotEmpty();\n    assertThat(changedEndPoints).isEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void testDiff() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(changedEndPoints).isNotEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void testDiffAndMarkdown() {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new MarkdownRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void testDiffAndJson() {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new JsonRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  /** Testing that repetitive specs comparisons has to produce consistent result. */\n  @Test\n  public void testComparisonConsistency() {\n    final OpenAPI oldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI newSpec = loadSpecFromFile(OPENAPI_DOC3);\n\n    final ChangedOpenApi diff1 = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    assertThat(diff1.isChanged()).isEqualTo(DiffResult.NO_CHANGES);\n    assertThat(diff1.getNewEndpoints()).isEmpty();\n    assertThat(diff1.getMissingEndpoints()).isEmpty();\n    assertThat(diff1.getChangedOperations()).isEmpty();\n\n    final ChangedOpenApi diff2 = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    assertThat(diff2.isChanged()).isEqualTo(DiffResult.NO_CHANGES);\n    assertThat(diff2.getNewEndpoints()).isEmpty();\n    assertThat(diff2.getMissingEndpoints()).isEmpty();\n    assertThat(diff2.getChangedOperations()).isEmpty();\n  }\n\n  @Test\n  public void testSpecObjectsAreNotChangesAfterComparison() {\n    final OpenAPI oldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI newSpec = loadSpecFromFile(OPENAPI_DOC3);\n\n    OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n\n    final OpenAPI expectedOldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI expectedNewSpec = loadSpecFromFile(OPENAPI_DOC3);\n    assertThat(oldSpec).isEqualTo(expectedOldSpec);\n    assertThat(newSpec).isEqualTo(expectedNewSpec);\n  }\n\n  private static OpenAPI loadSpecFromFile(String specFile) {\n    return PARSER.readLocation(specFile, null, new ParseOptions()).getOpenAPI();\n  }\n}", "definition": "public class OpenApiDiffTest", "class_docstring": "", "name": "OpenApiDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"petstore_v2_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"petstore_v2_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"petstore_v2_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"petstore_v2_2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_EMPTY_DOC = \"petstore_v2_empty.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_EMPTY_DOC = \"petstore_v2_empty.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC3 = \"petstore_openapi3.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC3 = \"petstore_openapi3.yaml\"", "syntax_pass": true}, {"attribute_expression": "private static final OpenAPIParser PARSER = new OpenAPIParser();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "OpenAPIParser", "name": "PARSER = new OpenAPIParser()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testEqual() {\n    assertOpenApiAreEquals(OPENAPI_DOC2, OPENAPI_DOC2);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEqual", "params": [], "body": "                          {\n    assertOpenApiAreEquals(OPENAPI_DOC2, OPENAPI_DOC2);\n  }", "signature": "@Test\n  public void testEqual()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testNewApi() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_EMPTY_DOC, OPENAPI_DOC2);\n    List<Endpoint> newEndpoints = changedOpenApi.getNewEndpoints();\n    List<Endpoint> missingEndpoints = changedOpenApi.getMissingEndpoints();\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(newEndpoints).isNotEmpty();\n    assertThat(missingEndpoints).isEmpty();\n    assertThat(changedEndPoints).isEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNewApi", "params": [], "body": "                           {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_EMPTY_DOC, OPENAPI_DOC2);\n    List<Endpoint> newEndpoints = changedOpenApi.getNewEndpoints();\n    List<Endpoint> missingEndpoints = changedOpenApi.getMissingEndpoints();\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(newEndpoints).isNotEmpty();\n    assertThat(missingEndpoints).isEmpty();\n    assertThat(changedEndPoints).isEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void testNewApi()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDeprecatedApi() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_EMPTY_DOC);\n    List<Endpoint> newEndpoints = changedOpenApi.getNewEndpoints();\n    List<Endpoint> missingEndpoints = changedOpenApi.getMissingEndpoints();\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(newEndpoints).isEmpty();\n    assertThat(missingEndpoints).isNotEmpty();\n    assertThat(changedEndPoints).isEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeprecatedApi", "params": [], "body": "                                  {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_EMPTY_DOC);\n    List<Endpoint> newEndpoints = changedOpenApi.getNewEndpoints();\n    List<Endpoint> missingEndpoints = changedOpenApi.getMissingEndpoints();\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(newEndpoints).isEmpty();\n    assertThat(missingEndpoints).isNotEmpty();\n    assertThat(changedEndPoints).isEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void testDeprecatedApi()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiff() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(changedEndPoints).isNotEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiff", "params": [], "body": "                         {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    List<ChangedOperation> changedEndPoints = changedOpenApi.getChangedOperations();\n    assertThat(changedEndPoints).isNotEmpty();\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render =\n        new HtmlRender(\"Changelog\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n    render.render(changedOpenApi, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void testDiff()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffAndMarkdown() {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new MarkdownRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffAndMarkdown", "params": [], "body": "                                    {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new MarkdownRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void testDiffAndMarkdown()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffAndJson() {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new JsonRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffAndJson", "params": [], "body": "                                {\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    Render render = new JsonRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void testDiffAndJson()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testComparisonConsistency() {\n    final OpenAPI oldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI newSpec = loadSpecFromFile(OPENAPI_DOC3);\n\n    final ChangedOpenApi diff1 = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    assertThat(diff1.isChanged()).isEqualTo(DiffResult.NO_CHANGES);\n    assertThat(diff1.getNewEndpoints()).isEmpty();\n    assertThat(diff1.getMissingEndpoints()).isEmpty();\n    assertThat(diff1.getChangedOperations()).isEmpty();\n\n    final ChangedOpenApi diff2 = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    assertThat(diff2.isChanged()).isEqualTo(DiffResult.NO_CHANGES);\n    assertThat(diff2.getNewEndpoints()).isEmpty();\n    assertThat(diff2.getMissingEndpoints()).isEmpty();\n    assertThat(diff2.getChangedOperations()).isEmpty();\n  }", "docstring": " Testing that repetitive specs comparisons has to produce consistent result.", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testComparisonConsistency", "params": [], "body": "                                          {\n    final OpenAPI oldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI newSpec = loadSpecFromFile(OPENAPI_DOC3);\n\n    final ChangedOpenApi diff1 = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    assertThat(diff1.isChanged()).isEqualTo(DiffResult.NO_CHANGES);\n    assertThat(diff1.getNewEndpoints()).isEmpty();\n    assertThat(diff1.getMissingEndpoints()).isEmpty();\n    assertThat(diff1.getChangedOperations()).isEmpty();\n\n    final ChangedOpenApi diff2 = OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    assertThat(diff2.isChanged()).isEqualTo(DiffResult.NO_CHANGES);\n    assertThat(diff2.getNewEndpoints()).isEmpty();\n    assertThat(diff2.getMissingEndpoints()).isEmpty();\n    assertThat(diff2.getChangedOperations()).isEmpty();\n  }", "signature": "@Test\n  public void testComparisonConsistency()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testSpecObjectsAreNotChangesAfterComparison() {\n    final OpenAPI oldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI newSpec = loadSpecFromFile(OPENAPI_DOC3);\n\n    OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n\n    final OpenAPI expectedOldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI expectedNewSpec = loadSpecFromFile(OPENAPI_DOC3);\n    assertThat(oldSpec).isEqualTo(expectedOldSpec);\n    assertThat(newSpec).isEqualTo(expectedNewSpec);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSpecObjectsAreNotChangesAfterComparison", "params": [], "body": "                                                            {\n    final OpenAPI oldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI newSpec = loadSpecFromFile(OPENAPI_DOC3);\n\n    OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n    OpenApiCompare.fromSpecifications(oldSpec, newSpec);\n\n    final OpenAPI expectedOldSpec = loadSpecFromFile(OPENAPI_DOC3);\n    final OpenAPI expectedNewSpec = loadSpecFromFile(OPENAPI_DOC3);\n    assertThat(oldSpec).isEqualTo(expectedOldSpec);\n    assertThat(newSpec).isEqualTo(expectedNewSpec);\n  }", "signature": "@Test\n  public void testSpecObjectsAreNotChangesAfterComparison()"}, {"syntax_pass": true, "original_string": "  private static OpenAPI loadSpecFromFile(String specFile) {\n    return PARSER.readLocation(specFile, null, new ParseOptions()).getOpenAPI();\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "OpenAPI", "classes": []}, "name": "loadSpecFromFile", "params": [{"name": "specFile", "type": "String"}], "body": "                                                           {\n    return PARSER.readLocation(specFile, null, new ParseOptions()).getOpenAPI();\n  }", "signature": "private static OpenAPI loadSpecFromFile(String specFile)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/AsciidocRenderTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStreamWriter;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.output.AsciidocRender;\n\npublic class AsciidocRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotCauseStackOverflowWithRecursiveDefinitions() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"recursive_old.yaml\", \"recursive_new.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void validateAsciiDocChangeFile() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .isEqualTo(\n            \"= TITLE (v 1.0.0)\\n\"\n                + \":reproducible:\\n\"\n                + \":sectlinks:\\n\"\n                + \":toc:\\n\"\n                + \"\\n\"\n                + \"== What's Changed\\n\"\n                + \"=== GET   /\\n\"\n                + \"* Return Type:\\n\"\n                + \"** Changed default \\n\"\n                + \"** Media types:\\n\"\n                + \"*** Changed application/json\\n\"\n                + \"*** Schema:\\n\"\n                + \"Backward compatible\\n\"\n                + \"\\n\"\n                + \"\\n\"\n                + \"NOTE: API changes are backward compatible\\n\");\n  }\n\n  @Test\n  public void validateAsciiDocRangeStatus() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .isEqualTo(\n            \"= PROJECTS API (v 1.0.0)\\n\"\n                + \":reproducible:\\n\"\n                + \":sectlinks:\\n\"\n                + \":toc:\\n\"\n                + \"\\n\"\n                + \"== What's Changed\\n\"\n                + \"=== GET   /pet/\\n\"\n                + \"* Return Type:\\n\"\n                + \"** Add 4XX \\n\"\n                + \"** Deleted 405 Method Not Allowed\\n\"\n                + \"\\n\"\n                + \"\\n\"\n                + \"WARNING: API changes broke backward compatibility\\n\");\n  }\n}\n", "file_hash": "58a9881ced4f1ef1e07059217af9fd895764859b71829d263d5f205237b01616", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import java.io.ByteArrayOutputStream;", "import java.io.OutputStreamWriter;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.output.AsciidocRender;"], "methods": [], "classes": [{"original_string": "public class AsciidocRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotCauseStackOverflowWithRecursiveDefinitions() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"recursive_old.yaml\", \"recursive_new.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void validateAsciiDocChangeFile() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .isEqualTo(\n            \"= TITLE (v 1.0.0)\\n\"\n                + \":reproducible:\\n\"\n                + \":sectlinks:\\n\"\n                + \":toc:\\n\"\n                + \"\\n\"\n                + \"== What's Changed\\n\"\n                + \"=== GET   /\\n\"\n                + \"* Return Type:\\n\"\n                + \"** Changed default \\n\"\n                + \"** Media types:\\n\"\n                + \"*** Changed application/json\\n\"\n                + \"*** Schema:\\n\"\n                + \"Backward compatible\\n\"\n                + \"\\n\"\n                + \"\\n\"\n                + \"NOTE: API changes are backward compatible\\n\");\n  }\n\n  @Test\n  public void validateAsciiDocRangeStatus() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .isEqualTo(\n            \"= PROJECTS API (v 1.0.0)\\n\"\n                + \":reproducible:\\n\"\n                + \":sectlinks:\\n\"\n                + \":toc:\\n\"\n                + \"\\n\"\n                + \"== What's Changed\\n\"\n                + \"=== GET   /pet/\\n\"\n                + \"* Return Type:\\n\"\n                + \"** Add 4XX \\n\"\n                + \"** Deleted 405 Method Not Allowed\\n\"\n                + \"\\n\"\n                + \"\\n\"\n                + \"WARNING: API changes broke backward compatibility\\n\");\n  }\n}", "definition": "public class AsciidocRenderTest", "class_docstring": "", "name": "AsciidocRenderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotFailWhenPropertyHasBeenRemoved", "params": [], "body": "                                                            {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotCauseStackOverflowWithRecursiveDefinitions() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"recursive_old.yaml\", \"recursive_new.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotCauseStackOverflowWithRecursiveDefinitions", "params": [], "body": "                                                                        {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"recursive_old.yaml\", \"recursive_new.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotCauseStackOverflowWithRecursiveDefinitions()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotFailWhenHTTPStatusCodeIsRange", "params": [], "body": "                                                           {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void validateAsciiDocChangeFile() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .isEqualTo(\n            \"= TITLE (v 1.0.0)\\n\"\n                + \":reproducible:\\n\"\n                + \":sectlinks:\\n\"\n                + \":toc:\\n\"\n                + \"\\n\"\n                + \"== What's Changed\\n\"\n                + \"=== GET   /\\n\"\n                + \"* Return Type:\\n\"\n                + \"** Changed default \\n\"\n                + \"** Media types:\\n\"\n                + \"*** Changed application/json\\n\"\n                + \"*** Schema:\\n\"\n                + \"Backward compatible\\n\"\n                + \"\\n\"\n                + \"\\n\"\n                + \"NOTE: API changes are backward compatible\\n\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "validateAsciiDocChangeFile", "params": [], "body": "                                           {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .isEqualTo(\n            \"= TITLE (v 1.0.0)\\n\"\n                + \":reproducible:\\n\"\n                + \":sectlinks:\\n\"\n                + \":toc:\\n\"\n                + \"\\n\"\n                + \"== What's Changed\\n\"\n                + \"=== GET   /\\n\"\n                + \"* Return Type:\\n\"\n                + \"** Changed default \\n\"\n                + \"** Media types:\\n\"\n                + \"*** Changed application/json\\n\"\n                + \"*** Schema:\\n\"\n                + \"Backward compatible\\n\"\n                + \"\\n\"\n                + \"\\n\"\n                + \"NOTE: API changes are backward compatible\\n\");\n  }", "signature": "@Test\n  public void validateAsciiDocChangeFile()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void validateAsciiDocRangeStatus() {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .isEqualTo(\n            \"= PROJECTS API (v 1.0.0)\\n\"\n                + \":reproducible:\\n\"\n                + \":sectlinks:\\n\"\n                + \":toc:\\n\"\n                + \"\\n\"\n                + \"== What's Changed\\n\"\n                + \"=== GET   /pet/\\n\"\n                + \"* Return Type:\\n\"\n                + \"** Add 4XX \\n\"\n                + \"** Deleted 405 Method Not Allowed\\n\"\n                + \"\\n\"\n                + \"\\n\"\n                + \"WARNING: API changes broke backward compatibility\\n\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "validateAsciiDocRangeStatus", "params": [], "body": "                                            {\n    AsciidocRender render = new AsciidocRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString())\n        .isEqualTo(\n            \"= PROJECTS API (v 1.0.0)\\n\"\n                + \":reproducible:\\n\"\n                + \":sectlinks:\\n\"\n                + \":toc:\\n\"\n                + \"\\n\"\n                + \"== What's Changed\\n\"\n                + \"=== GET   /pet/\\n\"\n                + \"* Return Type:\\n\"\n                + \"** Add 4XX \\n\"\n                + \"** Deleted 405 Method Not Allowed\\n\"\n                + \"\\n\"\n                + \"\\n\"\n                + \"WARNING: API changes broke backward compatibility\\n\");\n  }", "signature": "@Test\n  public void validateAsciiDocRangeStatus()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/AdditionalPropertiesTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStreamWriter;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.output.ConsoleRender;\n\nclass AdditionalPropertiesTest {\n  @Test\n  void booleanAdditionalPropertiesAreSupported() {\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"issue-256_1.json\", \"issue-256_2.json\");\n    ConsoleRender render = new ConsoleRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}\n", "file_hash": "0793012f20714f54c075ff53336fd577addf754bb6d44a3b23844346b50a8555", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import java.io.ByteArrayOutputStream;", "import java.io.OutputStreamWriter;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.output.ConsoleRender;"], "methods": [], "classes": [{"original_string": "class AdditionalPropertiesTest {\n  @Test\n  void booleanAdditionalPropertiesAreSupported() {\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"issue-256_1.json\", \"issue-256_2.json\");\n    ConsoleRender render = new ConsoleRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}", "definition": "class AdditionalPropertiesTest", "class_docstring": "", "name": "AdditionalPropertiesTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  void booleanAdditionalPropertiesAreSupported() {\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"issue-256_1.json\", \"issue-256_2.json\");\n    ConsoleRender render = new ConsoleRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "booleanAdditionalPropertiesAreSupported", "params": [], "body": "                                                 {\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"issue-256_1.json\", \"issue-256_2.json\");\n    ConsoleRender render = new ConsoleRender();\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  void booleanAdditionalPropertiesAreSupported()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/AllOfDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AllOfDiffTest {\n\n  private final String OPENAPI_DOC1 = \"allOf_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"allOf_diff_2.yaml\";\n  private final String OPENAPI_DOC3 = \"allOf_diff_3.yaml\";\n  private final String OPENAPI_DOC4 = \"allOf_diff_4.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testDiffSameWithAllOf() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC2);\n  }\n\n  @Test\n  public void testDiffDifferent1() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC3);\n  }\n\n  @Test\n  public void testDiffDifferent2() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC4);\n  }\n}\n", "file_hash": "c70dcb9e2669843abfeeb58f235c2f5cc9142b42175779134b499df3cff60e7b", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class AllOfDiffTest {\n\n  private final String OPENAPI_DOC1 = \"allOf_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"allOf_diff_2.yaml\";\n  private final String OPENAPI_DOC3 = \"allOf_diff_3.yaml\";\n  private final String OPENAPI_DOC4 = \"allOf_diff_4.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testDiffSameWithAllOf() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC2);\n  }\n\n  @Test\n  public void testDiffDifferent1() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC3);\n  }\n\n  @Test\n  public void testDiffDifferent2() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC4);\n  }\n}", "definition": "public class AllOfDiffTest", "class_docstring": "", "name": "AllOfDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"allOf_diff_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"allOf_diff_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"allOf_diff_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"allOf_diff_2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC3 = \"allOf_diff_3.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC3 = \"allOf_diff_3.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC4 = \"allOf_diff_4.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC4 = \"allOf_diff_4.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffSame", "params": [], "body": "                             {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "signature": "@Test\n  public void testDiffSame()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffSameWithAllOf() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC2);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffSameWithAllOf", "params": [], "body": "                                      {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC2);\n  }", "signature": "@Test\n  public void testDiffSameWithAllOf()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferent1() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC3);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferent1", "params": [], "body": "                                   {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC3);\n  }", "signature": "@Test\n  public void testDiffDifferent1()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferent2() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC4);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferent2", "params": [], "body": "                                   {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC4);\n  }", "signature": "@Test\n  public void testDiffDifferent2()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/OneOfDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;\n\nimport org.junit.jupiter.api.Test;\n\npublic class OneOfDiffTest {\n\n  private final String OPENAPI_DOC1 = \"oneOf_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"oneOf_diff_2.yaml\";\n  private final String OPENAPI_DOC3 = \"oneOf_diff_3.yaml\";\n  private final String OPENAPI_DOC4 = \"composed_schema_1.yaml\";\n  private final String OPENAPI_DOC5 = \"composed_schema_2.yaml\";\n  private final String OPENAPI_DOC6 = \"oneOf_discriminator-changed_1.yaml\";\n  private final String OPENAPI_DOC7 = \"oneOf_discriminator-changed_2.yaml\";\n  private final String OPENAPI_DOC8 = \"oneOf_discriminator-missing_1.yaml\";\n  private final String OPENAPI_DOC9 = \"oneOf_discriminator-missing_2.yaml\";\n  private final String OPENAPI_DOC10 = \"unnamed_oneof_schema_1.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testDiffDifferentMapping() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC2);\n  }\n\n  @Test\n  public void testDiffSameWithOneOf() {\n    assertOpenApiAreEquals(OPENAPI_DOC2, OPENAPI_DOC3);\n  }\n\n  @Test\n  public void testComposedSchema() {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC4, OPENAPI_DOC5);\n  }\n\n  @Test\n  public void testComposedSchemaDiff() {\n    assertOpenApiAreEquals(OPENAPI_DOC10, OPENAPI_DOC10);\n  }\n\n  @Test\n  public void testOneOfDiscrimitatorChanged() {\n    // The oneOf 'discriminator' changed: 'realtype' -> 'othertype':\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC6, OPENAPI_DOC7);\n  }\n\n  @Test\n  public void testOneOfDiscrimitatorMissingSameOrder() {\n    assertOpenApiAreEquals(OPENAPI_DOC8, OPENAPI_DOC8);\n  }\n\n  @Test\n  public void testOneOfDiscrimitatorMissingDifferentOrder() {\n    assertOpenApiAreEquals(OPENAPI_DOC8, OPENAPI_DOC9);\n  }\n}\n", "file_hash": "e46e599e0cb682bd0e96c8f23103cc0de07d804fdddbbd0611238003afcdb743", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class OneOfDiffTest {\n\n  private final String OPENAPI_DOC1 = \"oneOf_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"oneOf_diff_2.yaml\";\n  private final String OPENAPI_DOC3 = \"oneOf_diff_3.yaml\";\n  private final String OPENAPI_DOC4 = \"composed_schema_1.yaml\";\n  private final String OPENAPI_DOC5 = \"composed_schema_2.yaml\";\n  private final String OPENAPI_DOC6 = \"oneOf_discriminator-changed_1.yaml\";\n  private final String OPENAPI_DOC7 = \"oneOf_discriminator-changed_2.yaml\";\n  private final String OPENAPI_DOC8 = \"oneOf_discriminator-missing_1.yaml\";\n  private final String OPENAPI_DOC9 = \"oneOf_discriminator-missing_2.yaml\";\n  private final String OPENAPI_DOC10 = \"unnamed_oneof_schema_1.yaml\";\n\n  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }\n\n  @Test\n  public void testDiffDifferentMapping() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC2);\n  }\n\n  @Test\n  public void testDiffSameWithOneOf() {\n    assertOpenApiAreEquals(OPENAPI_DOC2, OPENAPI_DOC3);\n  }\n\n  @Test\n  public void testComposedSchema() {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC4, OPENAPI_DOC5);\n  }\n\n  @Test\n  public void testComposedSchemaDiff() {\n    assertOpenApiAreEquals(OPENAPI_DOC10, OPENAPI_DOC10);\n  }\n\n  @Test\n  public void testOneOfDiscrimitatorChanged() {\n    // The oneOf 'discriminator' changed: 'realtype' -> 'othertype':\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC6, OPENAPI_DOC7);\n  }\n\n  @Test\n  public void testOneOfDiscrimitatorMissingSameOrder() {\n    assertOpenApiAreEquals(OPENAPI_DOC8, OPENAPI_DOC8);\n  }\n\n  @Test\n  public void testOneOfDiscrimitatorMissingDifferentOrder() {\n    assertOpenApiAreEquals(OPENAPI_DOC8, OPENAPI_DOC9);\n  }\n}", "definition": "public class OneOfDiffTest", "class_docstring": "", "name": "OneOfDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"oneOf_diff_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"oneOf_diff_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"oneOf_diff_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"oneOf_diff_2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC3 = \"oneOf_diff_3.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC3 = \"oneOf_diff_3.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC4 = \"composed_schema_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC4 = \"composed_schema_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC5 = \"composed_schema_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC5 = \"composed_schema_2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC6 = \"oneOf_discriminator-changed_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC6 = \"oneOf_discriminator-changed_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC7 = \"oneOf_discriminator-changed_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC7 = \"oneOf_discriminator-changed_2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC8 = \"oneOf_discriminator-missing_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC8 = \"oneOf_discriminator-missing_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC9 = \"oneOf_discriminator-missing_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC9 = \"oneOf_discriminator-missing_2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC10 = \"unnamed_oneof_schema_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC10 = \"unnamed_oneof_schema_1.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffSame", "params": [], "body": "                             {\n    assertOpenApiAreEquals(OPENAPI_DOC1, OPENAPI_DOC1);\n  }", "signature": "@Test\n  public void testDiffSame()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffDifferentMapping() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC2);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffDifferentMapping", "params": [], "body": "                                         {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC1, OPENAPI_DOC2);\n  }", "signature": "@Test\n  public void testDiffDifferentMapping()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDiffSameWithOneOf() {\n    assertOpenApiAreEquals(OPENAPI_DOC2, OPENAPI_DOC3);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDiffSameWithOneOf", "params": [], "body": "                                      {\n    assertOpenApiAreEquals(OPENAPI_DOC2, OPENAPI_DOC3);\n  }", "signature": "@Test\n  public void testDiffSameWithOneOf()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testComposedSchema() {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC4, OPENAPI_DOC5);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testComposedSchema", "params": [], "body": "                                   {\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC4, OPENAPI_DOC5);\n  }", "signature": "@Test\n  public void testComposedSchema()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testComposedSchemaDiff() {\n    assertOpenApiAreEquals(OPENAPI_DOC10, OPENAPI_DOC10);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testComposedSchemaDiff", "params": [], "body": "                                       {\n    assertOpenApiAreEquals(OPENAPI_DOC10, OPENAPI_DOC10);\n  }", "signature": "@Test\n  public void testComposedSchemaDiff()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testOneOfDiscrimitatorChanged() {\n    // The oneOf 'discriminator' changed: 'realtype' -> 'othertype':\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC6, OPENAPI_DOC7);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOneOfDiscrimitatorChanged", "params": [], "body": "                                              {\n    // The oneOf 'discriminator' changed: 'realtype' -> 'othertype':\n    assertOpenApiBackwardIncompatible(OPENAPI_DOC6, OPENAPI_DOC7);\n  }", "signature": "@Test\n  public void testOneOfDiscrimitatorChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testOneOfDiscrimitatorMissingSameOrder() {\n    assertOpenApiAreEquals(OPENAPI_DOC8, OPENAPI_DOC8);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOneOfDiscrimitatorMissingSameOrder", "params": [], "body": "                                                       {\n    assertOpenApiAreEquals(OPENAPI_DOC8, OPENAPI_DOC8);\n  }", "signature": "@Test\n  public void testOneOfDiscrimitatorMissingSameOrder()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testOneOfDiscrimitatorMissingDifferentOrder() {\n    assertOpenApiAreEquals(OPENAPI_DOC8, OPENAPI_DOC9);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testOneOfDiscrimitatorMissingDifferentOrder", "params": [], "body": "                                                            {\n    assertOpenApiAreEquals(OPENAPI_DOC8, OPENAPI_DOC9);\n  }", "signature": "@Test\n  public void testOneOfDiscrimitatorMissingDifferentOrder()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/PathParameterSchemaDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class PathParameterSchemaDiffTest {\n  final String TEST_MSG_1 =\n      \"Testing: \\n\"\n          + \"1. Same path but different pathParameters\\n\"\n          + \"2. different parameters in the parameters: section\\n\"\n          + \"3. Parameters have different schema\\n\"\n          + \"eg:\\n\"\n          + \"old path   -- students/{id}\\n\"\n          + \"old schema -- id: integer\\n\"\n          + \"new path   -- students/{username}\\n\"\n          + \"new schema -- username: string\";\n\n  final String TEST_MSG_2 =\n      \"Testing: \\n\"\n          + \"1. Same path but different pathParameters\\n\"\n          + \"2. different parameters in the parameters: section\\n\"\n          + \"3. Parameters have same schema\\n\";\n\n  @Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, Different Schema\")\n  public void pathSamePathParamsDiffParamSameAsInPathButSchemaDiff() {\n    final Logger logger = LoggerFactory.getLogger(PathParameterSchemaDiffTest.class);\n    logger.info(TEST_MSG_1);\n    String OPENAPI_DOC1 = \"path_parameter_diff_param_schema_diff_old.yaml\";\n    String OPENAPI_DOC2 = \"path_parameter_diff_param_schema_diff_new.yaml\";\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    Assertions.assertTrue(diff.isDifferent());\n    Assertions.assertFalse(diff.isCompatible());\n  }\n\n  @Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, same Schema\")\n  public void pathSamePathParamsDiffParamNameDiffSchemaSame() {\n    final Logger logger = LoggerFactory.getLogger(PathParameterSchemaDiffTest.class);\n    logger.info(TEST_MSG_2);\n    String OPENAPI_DOC1 = \"path_parameter_diff_param_name_diff_old.yaml\";\n    String OPENAPI_DOC2 = \"path_parameter_diff_param_name_diff_new.yaml\";\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    Assertions.assertFalse(diff.isDifferent());\n    Assertions.assertTrue(diff.isCompatible());\n  }\n}\n", "file_hash": "93bafe90bac0a4ead16eec6337fac5f79c022c929c174d46073a16ec6c8e5916", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import org.junit.jupiter.api.Assertions;", "import org.junit.jupiter.api.DisplayName;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.slf4j.Logger;", "import org.slf4j.LoggerFactory;"], "methods": [], "classes": [{"original_string": "public class PathParameterSchemaDiffTest {\n  final String TEST_MSG_1 =\n      \"Testing: \\n\"\n          + \"1. Same path but different pathParameters\\n\"\n          + \"2. different parameters in the parameters: section\\n\"\n          + \"3. Parameters have different schema\\n\"\n          + \"eg:\\n\"\n          + \"old path   -- students/{id}\\n\"\n          + \"old schema -- id: integer\\n\"\n          + \"new path   -- students/{username}\\n\"\n          + \"new schema -- username: string\";\n\n  final String TEST_MSG_2 =\n      \"Testing: \\n\"\n          + \"1. Same path but different pathParameters\\n\"\n          + \"2. different parameters in the parameters: section\\n\"\n          + \"3. Parameters have same schema\\n\";\n\n  @Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, Different Schema\")\n  public void pathSamePathParamsDiffParamSameAsInPathButSchemaDiff() {\n    final Logger logger = LoggerFactory.getLogger(PathParameterSchemaDiffTest.class);\n    logger.info(TEST_MSG_1);\n    String OPENAPI_DOC1 = \"path_parameter_diff_param_schema_diff_old.yaml\";\n    String OPENAPI_DOC2 = \"path_parameter_diff_param_schema_diff_new.yaml\";\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    Assertions.assertTrue(diff.isDifferent());\n    Assertions.assertFalse(diff.isCompatible());\n  }\n\n  @Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, same Schema\")\n  public void pathSamePathParamsDiffParamNameDiffSchemaSame() {\n    final Logger logger = LoggerFactory.getLogger(PathParameterSchemaDiffTest.class);\n    logger.info(TEST_MSG_2);\n    String OPENAPI_DOC1 = \"path_parameter_diff_param_name_diff_old.yaml\";\n    String OPENAPI_DOC2 = \"path_parameter_diff_param_name_diff_new.yaml\";\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    Assertions.assertFalse(diff.isDifferent());\n    Assertions.assertTrue(diff.isCompatible());\n  }\n}", "definition": "public class PathParameterSchemaDiffTest", "class_docstring": "", "name": "PathParameterSchemaDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "final String TEST_MSG_1 =\n      \"Testing: \\n\"\n          + \"1. Same path but different pathParameters\\n\"\n          + \"2. different parameters in the parameters: section\\n\"\n          + \"3. Parameters have different schema\\n\"\n          + \"eg:\\n\"\n          + \"old path   -- students/{id}\\n\"\n          + \"old schema -- id: integer\\n\"\n          + \"new path   -- students/{username}\\n\"\n          + \"new schema -- username: string\";", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "TEST_MSG_1 =\n      \"Testing: \\n\"\n          + \"1. Same path but different pathParameters\\n\"\n          + \"2. different parameters in the parameters: section\\n\"\n          + \"3. Parameters have different schema\\n\"\n          + \"eg:\\n\"\n          + \"old path   -- students/{id}\\n\"\n          + \"old schema -- id: integer\\n\"\n          + \"new path   -- students/{username}\\n\"\n          + \"new schema -- username: string\"", "syntax_pass": true}, {"attribute_expression": "final String TEST_MSG_2 =\n      \"Testing: \\n\"\n          + \"1. Same path but different pathParameters\\n\"\n          + \"2. different parameters in the parameters: section\\n\"\n          + \"3. Parameters have same schema\\n\";", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "TEST_MSG_2 =\n      \"Testing: \\n\"\n          + \"1. Same path but different pathParameters\\n\"\n          + \"2. different parameters in the parameters: section\\n\"\n          + \"3. Parameters have same schema\\n\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, Different Schema\")\n  public void pathSamePathParamsDiffParamSameAsInPathButSchemaDiff() {\n    final Logger logger = LoggerFactory.getLogger(PathParameterSchemaDiffTest.class);\n    logger.info(TEST_MSG_1);\n    String OPENAPI_DOC1 = \"path_parameter_diff_param_schema_diff_old.yaml\";\n    String OPENAPI_DOC2 = \"path_parameter_diff_param_schema_diff_new.yaml\";\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    Assertions.assertTrue(diff.isDifferent());\n    Assertions.assertFalse(diff.isCompatible());\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, Different Schema\")\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, Different Schema\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "pathSamePathParamsDiffParamSameAsInPathButSchemaDiff", "params": [], "body": "                                                                     {\n    final Logger logger = LoggerFactory.getLogger(PathParameterSchemaDiffTest.class);\n    logger.info(TEST_MSG_1);\n    String OPENAPI_DOC1 = \"path_parameter_diff_param_schema_diff_old.yaml\";\n    String OPENAPI_DOC2 = \"path_parameter_diff_param_schema_diff_new.yaml\";\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    Assertions.assertTrue(diff.isDifferent());\n    Assertions.assertFalse(diff.isCompatible());\n  }", "signature": "@Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, Different Schema\")\n  public void pathSamePathParamsDiffParamSameAsInPathButSchemaDiff()"}, {"syntax_pass": true, "original_string": "  @Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, same Schema\")\n  public void pathSamePathParamsDiffParamNameDiffSchemaSame() {\n    final Logger logger = LoggerFactory.getLogger(PathParameterSchemaDiffTest.class);\n    logger.info(TEST_MSG_2);\n    String OPENAPI_DOC1 = \"path_parameter_diff_param_name_diff_old.yaml\";\n    String OPENAPI_DOC2 = \"path_parameter_diff_param_name_diff_new.yaml\";\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    Assertions.assertFalse(diff.isDifferent());\n    Assertions.assertTrue(diff.isCompatible());\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, same Schema\")\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, same Schema\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "pathSamePathParamsDiffParamNameDiffSchemaSame", "params": [], "body": "                                                              {\n    final Logger logger = LoggerFactory.getLogger(PathParameterSchemaDiffTest.class);\n    logger.info(TEST_MSG_2);\n    String OPENAPI_DOC1 = \"path_parameter_diff_param_name_diff_old.yaml\";\n    String OPENAPI_DOC2 = \"path_parameter_diff_param_name_diff_new.yaml\";\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    Assertions.assertFalse(diff.isDifferent());\n    Assertions.assertTrue(diff.isCompatible());\n  }", "signature": "@Test\n  @DisplayName(\n      \"Same Path, different PathParams, Params in the `Parameters`: match pathParam, same Schema\")\n  public void pathSamePathParamsDiffParamNameDiffSchemaSame()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/ArrayDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ArrayDiffTest {\n\n  private final String OPENAPI_DOC31 = \"array_diff_1.yaml\";\n  private final String OPENAPI_DOC32 = \"array_diff_2.yaml\";\n\n  @Test\n  public void testArrayDiffDifferent() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC31, OPENAPI_DOC32);\n  }\n\n  @Test\n  public void testArrayDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC31, OPENAPI_DOC31);\n  }\n}\n", "file_hash": "b60295507d55af28bdfbf511dc20ae902b252d33afd4db7a67632e508e2af41a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiChangedEndpoints;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class ArrayDiffTest {\n\n  private final String OPENAPI_DOC31 = \"array_diff_1.yaml\";\n  private final String OPENAPI_DOC32 = \"array_diff_2.yaml\";\n\n  @Test\n  public void testArrayDiffDifferent() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC31, OPENAPI_DOC32);\n  }\n\n  @Test\n  public void testArrayDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC31, OPENAPI_DOC31);\n  }\n}", "definition": "public class ArrayDiffTest", "class_docstring": "", "name": "ArrayDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC31 = \"array_diff_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC31 = \"array_diff_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC32 = \"array_diff_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC32 = \"array_diff_2.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testArrayDiffDifferent() {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC31, OPENAPI_DOC32);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testArrayDiffDifferent", "params": [], "body": "                                       {\n    assertOpenApiChangedEndpoints(OPENAPI_DOC31, OPENAPI_DOC32);\n  }", "signature": "@Test\n  public void testArrayDiffDifferent()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testArrayDiffSame() {\n    assertOpenApiAreEquals(OPENAPI_DOC31, OPENAPI_DOC31);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testArrayDiffSame", "params": [], "body": "                                  {\n    assertOpenApiAreEquals(OPENAPI_DOC31, OPENAPI_DOC31);\n  }", "signature": "@Test\n  public void testArrayDiffSame()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/TestUtils.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.slf4j.LoggerFactory.getLogger;\n\nimport org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.model.DiffResult;\nimport org.slf4j.Logger;\n\npublic class TestUtils {\n  public static final Logger LOG = getLogger(TestUtils.class);\n\n  public static void assertOpenApiAreEquals(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isEmpty();\n  }\n\n  public static void assertOpenApiChangedEndpoints(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n  }\n\n  public static void assertSpecUnchanged(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }\n\n  public static void assertSpecChangedButCompatible(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    DiffResult diffResult = changedOpenApi.isChanged();\n    LOG.info(\"Result: {}\", diffResult.getValue());\n    assertThat(diffResult.isDifferent()).isTrue();\n    assertThat(diffResult.isCompatible()).isTrue();\n  }\n\n  public static void assertSpecIncompatible(\n      String oldSpec, String newSpec, BackwardIncompatibleProp prop) {\n    OpenApiDiffOptions.Builder builder = OpenApiDiffOptions.builder();\n    // Expect incompatible when BackwardIncompatibleProp enabled\n    builder.configProperty(prop.getPropertyName(), \"true\");\n    OpenApiDiffOptions optsIncompat = builder.build();\n    ChangedOpenApi apiIncompat = OpenApiCompare.fromLocations(oldSpec, newSpec, null, optsIncompat);\n    LOG.info(\"Result: {}\", apiIncompat.isChanged().getValue());\n    assertThat(apiIncompat.isIncompatible()).isTrue();\n    // Expect changed but compatible when BackwardIncompatibleProp disabled\n    builder.configProperty(prop.getPropertyName(), \"false\");\n    OpenApiDiffOptions optsCompat = builder.build();\n    ChangedOpenApi apiCompat = OpenApiCompare.fromLocations(oldSpec, newSpec, null, optsCompat);\n    LOG.info(\"Result: {}\", apiCompat.isChanged().getValue());\n    assertThat(apiCompat.isDifferent()).isTrue();\n    assertThat(apiCompat.isCompatible()).isTrue();\n  }\n\n  public static void assertOpenApiBackwardCompatible(\n      String oldSpec, String newSpec, boolean isDiff) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n\n  public static void assertOpenApiBackwardIncompatible(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }\n}\n", "file_hash": "23458dc79b18bf75d28ca85007e0214362b51c1942772dd4365ee9a5aa0046e7", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import static org.slf4j.LoggerFactory.getLogger;", "import org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.model.DiffResult;", "import org.slf4j.Logger;"], "methods": [], "classes": [{"original_string": "public class TestUtils {\n  public static final Logger LOG = getLogger(TestUtils.class);\n\n  public static void assertOpenApiAreEquals(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isEmpty();\n  }\n\n  public static void assertOpenApiChangedEndpoints(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n  }\n\n  public static void assertSpecUnchanged(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }\n\n  public static void assertSpecChangedButCompatible(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    DiffResult diffResult = changedOpenApi.isChanged();\n    LOG.info(\"Result: {}\", diffResult.getValue());\n    assertThat(diffResult.isDifferent()).isTrue();\n    assertThat(diffResult.isCompatible()).isTrue();\n  }\n\n  public static void assertSpecIncompatible(\n      String oldSpec, String newSpec, BackwardIncompatibleProp prop) {\n    OpenApiDiffOptions.Builder builder = OpenApiDiffOptions.builder();\n    // Expect incompatible when BackwardIncompatibleProp enabled\n    builder.configProperty(prop.getPropertyName(), \"true\");\n    OpenApiDiffOptions optsIncompat = builder.build();\n    ChangedOpenApi apiIncompat = OpenApiCompare.fromLocations(oldSpec, newSpec, null, optsIncompat);\n    LOG.info(\"Result: {}\", apiIncompat.isChanged().getValue());\n    assertThat(apiIncompat.isIncompatible()).isTrue();\n    // Expect changed but compatible when BackwardIncompatibleProp disabled\n    builder.configProperty(prop.getPropertyName(), \"false\");\n    OpenApiDiffOptions optsCompat = builder.build();\n    ChangedOpenApi apiCompat = OpenApiCompare.fromLocations(oldSpec, newSpec, null, optsCompat);\n    LOG.info(\"Result: {}\", apiCompat.isChanged().getValue());\n    assertThat(apiCompat.isDifferent()).isTrue();\n    assertThat(apiCompat.isCompatible()).isTrue();\n  }\n\n  public static void assertOpenApiBackwardCompatible(\n      String oldSpec, String newSpec, boolean isDiff) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n\n  public static void assertOpenApiBackwardIncompatible(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }\n}", "definition": "public class TestUtils", "class_docstring": "", "name": "TestUtils", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "public static final Logger LOG = getLogger(TestUtils.class);", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Logger", "name": "LOG = getLogger(TestUtils.class)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public static void assertOpenApiAreEquals(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isEmpty();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertOpenApiAreEquals", "params": [{"name": "oldSpec", "type": "String"}, {"name": "newSpec", "type": "String"}], "body": "                                                                            {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isEmpty();\n  }", "signature": "public static void assertOpenApiAreEquals(String oldSpec, String newSpec)"}, {"syntax_pass": true, "original_string": "  public static void assertOpenApiChangedEndpoints(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertOpenApiChangedEndpoints", "params": [{"name": "oldSpec", "type": "String"}, {"name": "newSpec", "type": "String"}], "body": "                                                                                   {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.getNewEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getMissingEndpoints()).isEmpty();\n    assertThat(changedOpenApi.getChangedOperations()).isNotEmpty();\n  }", "signature": "public static void assertOpenApiChangedEndpoints(String oldSpec, String newSpec)"}, {"syntax_pass": true, "original_string": "  public static void assertSpecUnchanged(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertSpecUnchanged", "params": [{"name": "oldSpec", "type": "String"}, {"name": "newSpec", "type": "String"}], "body": "                                                                         {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }", "signature": "public static void assertSpecUnchanged(String oldSpec, String newSpec)"}, {"syntax_pass": true, "original_string": "  public static void assertSpecChangedButCompatible(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    DiffResult diffResult = changedOpenApi.isChanged();\n    LOG.info(\"Result: {}\", diffResult.getValue());\n    assertThat(diffResult.isDifferent()).isTrue();\n    assertThat(diffResult.isCompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertSpecChangedButCompatible", "params": [{"name": "oldSpec", "type": "String"}, {"name": "newSpec", "type": "String"}], "body": "                                                                                    {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    DiffResult diffResult = changedOpenApi.isChanged();\n    LOG.info(\"Result: {}\", diffResult.getValue());\n    assertThat(diffResult.isDifferent()).isTrue();\n    assertThat(diffResult.isCompatible()).isTrue();\n  }", "signature": "public static void assertSpecChangedButCompatible(String oldSpec, String newSpec)"}, {"syntax_pass": true, "original_string": "  public static void assertSpecIncompatible(\n      String oldSpec, String newSpec, BackwardIncompatibleProp prop) {\n    OpenApiDiffOptions.Builder builder = OpenApiDiffOptions.builder();\n    // Expect incompatible when BackwardIncompatibleProp enabled\n    builder.configProperty(prop.getPropertyName(), \"true\");\n    OpenApiDiffOptions optsIncompat = builder.build();\n    ChangedOpenApi apiIncompat = OpenApiCompare.fromLocations(oldSpec, newSpec, null, optsIncompat);\n    LOG.info(\"Result: {}\", apiIncompat.isChanged().getValue());\n    assertThat(apiIncompat.isIncompatible()).isTrue();\n    // Expect changed but compatible when BackwardIncompatibleProp disabled\n    builder.configProperty(prop.getPropertyName(), \"false\");\n    OpenApiDiffOptions optsCompat = builder.build();\n    ChangedOpenApi apiCompat = OpenApiCompare.fromLocations(oldSpec, newSpec, null, optsCompat);\n    LOG.info(\"Result: {}\", apiCompat.isChanged().getValue());\n    assertThat(apiCompat.isDifferent()).isTrue();\n    assertThat(apiCompat.isCompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertSpecIncompatible", "params": [{"name": "oldSpec", "type": "String"}, {"name": "newSpec", "type": "String"}, {"name": "prop", "type": "BackwardIncompatibleProp"}], "body": "                                                                     {\n    OpenApiDiffOptions.Builder builder = OpenApiDiffOptions.builder();\n    // Expect incompatible when BackwardIncompatibleProp enabled\n    builder.configProperty(prop.getPropertyName(), \"true\");\n    OpenApiDiffOptions optsIncompat = builder.build();\n    ChangedOpenApi apiIncompat = OpenApiCompare.fromLocations(oldSpec, newSpec, null, optsIncompat);\n    LOG.info(\"Result: {}\", apiIncompat.isChanged().getValue());\n    assertThat(apiIncompat.isIncompatible()).isTrue();\n    // Expect changed but compatible when BackwardIncompatibleProp disabled\n    builder.configProperty(prop.getPropertyName(), \"false\");\n    OpenApiDiffOptions optsCompat = builder.build();\n    ChangedOpenApi apiCompat = OpenApiCompare.fromLocations(oldSpec, newSpec, null, optsCompat);\n    LOG.info(\"Result: {}\", apiCompat.isChanged().getValue());\n    assertThat(apiCompat.isDifferent()).isTrue();\n    assertThat(apiCompat.isCompatible()).isTrue();\n  }", "signature": "public static void assertSpecIncompatible(\n      String oldSpec, String newSpec, BackwardIncompatibleProp prop)"}, {"syntax_pass": true, "original_string": "  public static void assertOpenApiBackwardCompatible(\n      String oldSpec, String newSpec, boolean isDiff) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertOpenApiBackwardCompatible", "params": [{"name": "oldSpec", "type": "String"}, {"name": "newSpec", "type": "String"}, {"name": "isDiff", "type": "boolean"}], "body": "                                                      {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "signature": "public static void assertOpenApiBackwardCompatible(\n      String oldSpec, String newSpec, boolean isDiff)"}, {"syntax_pass": true, "original_string": "  public static void assertOpenApiBackwardIncompatible(String oldSpec, String newSpec) {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertOpenApiBackwardIncompatible", "params": [{"name": "oldSpec", "type": "String"}, {"name": "newSpec", "type": "String"}], "body": "                                                                                       {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(oldSpec, newSpec);\n    LOG.info(\"Result: {}\", changedOpenApi.isChanged().getValue());\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }", "signature": "public static void assertOpenApiBackwardIncompatible(String oldSpec, String newSpec)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/MarkdownRenderTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.OutputStreamWriter;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.output.MarkdownRender;\n\npublic class MarkdownRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotCauseStackOverflowWithRecursiveDefinitions() {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"recursive_old.yaml\", \"recursive_new.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange() {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}\n", "file_hash": "2d0de715df6ee0d5cd60d7249ca3847352643145bdffcc5be1670d3496c6791a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import java.io.ByteArrayOutputStream;", "import java.io.OutputStreamWriter;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.output.MarkdownRender;"], "methods": [], "classes": [{"original_string": "public class MarkdownRenderTest {\n  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotCauseStackOverflowWithRecursiveDefinitions() {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"recursive_old.yaml\", \"recursive_new.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n\n  @Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange() {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }\n}", "definition": "public class MarkdownRenderTest", "class_docstring": "", "name": "MarkdownRenderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved() {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotFailWhenPropertyHasBeenRemoved", "params": [], "body": "                                                            {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"missing_property_1.yaml\", \"missing_property_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotFailWhenPropertyHasBeenRemoved()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotCauseStackOverflowWithRecursiveDefinitions() {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"recursive_old.yaml\", \"recursive_new.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotCauseStackOverflowWithRecursiveDefinitions", "params": [], "body": "                                                                        {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff = OpenApiCompare.fromLocations(\"recursive_old.yaml\", \"recursive_new.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotCauseStackOverflowWithRecursiveDefinitions()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange() {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderDoesNotFailWhenHTTPStatusCodeIsRange", "params": [], "body": "                                                           {\n    MarkdownRender render = new MarkdownRender();\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);\n    ChangedOpenApi diff =\n        OpenApiCompare.fromLocations(\"range_statuscode_1.yaml\", \"range_statuscode_2.yaml\");\n    render.render(diff, outputStreamWriter);\n    assertThat(outputStream.toString()).isNotBlank();\n  }", "signature": "@Test\n  public void renderDoesNotFailWhenHTTPStatusCodeIsRange()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/ContentDiffTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\n\npublic class ContentDiffTest {\n\n  private final String OPENAPI_DOC1 = \"content_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"content_diff_2.yaml\";\n\n  @Test\n  public void testContentDiffWithOneEmptyMediaType() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }\n\n  @Test\n  public void testContentDiffWithEmptyMediaTypes() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC1);\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }\n\n  @Test\n  public void testSameContentDiff() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC2, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }\n\n  @Test\n  public void testAddedResponseContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_response_add_1.yaml\", \"content_type_response_add_2.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n\n  @Test\n  public void testRemovedResponseContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_response_add_2.yaml\", \"content_type_response_add_1.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isFalse();\n  }\n\n  @Test\n  public void testAddedRequestContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_request_add_1.yaml\", \"content_type_request_add_2.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n\n  @Test\n  public void testRemovedRequestContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_request_add_2.yaml\", \"content_type_request_add_1.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isFalse();\n  }\n}\n", "file_hash": "52817c467bd5945a95252c9dde698e14a24ee227b1b1580450a1b784f6fddfa2", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.assertj.core.api.Assertions.assertThat;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;"], "methods": [], "classes": [{"original_string": "public class ContentDiffTest {\n\n  private final String OPENAPI_DOC1 = \"content_diff_1.yaml\";\n  private final String OPENAPI_DOC2 = \"content_diff_2.yaml\";\n\n  @Test\n  public void testContentDiffWithOneEmptyMediaType() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }\n\n  @Test\n  public void testContentDiffWithEmptyMediaTypes() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC1);\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }\n\n  @Test\n  public void testSameContentDiff() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC2, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }\n\n  @Test\n  public void testAddedResponseContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_response_add_1.yaml\", \"content_type_response_add_2.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n\n  @Test\n  public void testRemovedResponseContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_response_add_2.yaml\", \"content_type_response_add_1.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isFalse();\n  }\n\n  @Test\n  public void testAddedRequestContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_request_add_1.yaml\", \"content_type_request_add_2.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }\n\n  @Test\n  public void testRemovedRequestContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_request_add_2.yaml\", \"content_type_request_add_1.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isFalse();\n  }\n}", "definition": "public class ContentDiffTest", "class_docstring": "", "name": "ContentDiffTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String OPENAPI_DOC1 = \"content_diff_1.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC1 = \"content_diff_1.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"content_diff_2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"content_diff_2.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testContentDiffWithOneEmptyMediaType() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContentDiffWithOneEmptyMediaType", "params": [], "body": "                                                     {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isIncompatible()).isTrue();\n  }", "signature": "@Test\n  public void testContentDiffWithOneEmptyMediaType()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testContentDiffWithEmptyMediaTypes() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC1);\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testContentDiffWithEmptyMediaTypes", "params": [], "body": "                                                   {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC1, OPENAPI_DOC1);\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }", "signature": "@Test\n  public void testContentDiffWithEmptyMediaTypes()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testSameContentDiff() {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC2, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSameContentDiff", "params": [], "body": "                                    {\n    ChangedOpenApi changedOpenApi = OpenApiCompare.fromLocations(OPENAPI_DOC2, OPENAPI_DOC2);\n    assertThat(changedOpenApi.isUnchanged()).isTrue();\n  }", "signature": "@Test\n  public void testSameContentDiff()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testAddedResponseContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_response_add_1.yaml\", \"content_type_response_add_2.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddedResponseContentTypeDiff", "params": [], "body": "                                                 {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_response_add_1.yaml\", \"content_type_response_add_2.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "signature": "@Test\n  public void testAddedResponseContentTypeDiff()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testRemovedResponseContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_response_add_2.yaml\", \"content_type_response_add_1.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isFalse();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRemovedResponseContentTypeDiff", "params": [], "body": "                                                   {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_response_add_2.yaml\", \"content_type_response_add_1.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isFalse();\n  }", "signature": "@Test\n  public void testRemovedResponseContentTypeDiff()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testAddedRequestContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_request_add_1.yaml\", \"content_type_request_add_2.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddedRequestContentTypeDiff", "params": [], "body": "                                                {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_request_add_1.yaml\", \"content_type_request_add_2.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isTrue();\n  }", "signature": "@Test\n  public void testAddedRequestContentTypeDiff()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testRemovedRequestContentTypeDiff() {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_request_add_2.yaml\", \"content_type_request_add_1.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isFalse();\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRemovedRequestContentTypeDiff", "params": [], "body": "                                                  {\n    ChangedOpenApi changedOpenApi =\n        OpenApiCompare.fromLocations(\n            \"content_type_request_add_2.yaml\", \"content_type_request_add_1.yaml\");\n    assertThat(changedOpenApi.isCompatible()).isFalse();\n  }", "signature": "@Test\n  public void testRemovedRequestContentTypeDiff()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/Swagger2CompatibilityTest.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;\n\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n\n@Disabled\npublic class Swagger2CompatibilityTest {\n  private final String SWAGGER_DOC1 = \"petstore_swagger2.yaml\";\n  private final String OPENAPI_DOC2 = \"petstore_openapi3.yaml\";\n\n  @Test\n  public void testEqual() {\n    assertOpenApiAreEquals(SWAGGER_DOC1, SWAGGER_DOC1);\n  }\n\n  @Test\n  public void testSwagger2ToOpenapi3() {\n    assertOpenApiAreEquals(SWAGGER_DOC1, OPENAPI_DOC2);\n  }\n}\n", "file_hash": "0c98bb1db6e28797acd814b2e8e43340bf2bde2994ae4e57de64a8d723a5e41b", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiAreEquals;", "import org.junit.jupiter.api.Disabled;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "@Disabled\npublic class Swagger2CompatibilityTest {\n  private final String SWAGGER_DOC1 = \"petstore_swagger2.yaml\";\n  private final String OPENAPI_DOC2 = \"petstore_openapi3.yaml\";\n\n  @Test\n  public void testEqual() {\n    assertOpenApiAreEquals(SWAGGER_DOC1, SWAGGER_DOC1);\n  }\n\n  @Test\n  public void testSwagger2ToOpenapi3() {\n    assertOpenApiAreEquals(SWAGGER_DOC1, OPENAPI_DOC2);\n  }\n}", "definition": "@Disabled\npublic class Swagger2CompatibilityTest", "class_docstring": "", "name": "Swagger2CompatibilityTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@Disabled\npublic", "marker_annotations": ["@Disabled"], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String SWAGGER_DOC1 = \"petstore_swagger2.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "SWAGGER_DOC1 = \"petstore_swagger2.yaml\"", "syntax_pass": true}, {"attribute_expression": "private final String OPENAPI_DOC2 = \"petstore_openapi3.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "OPENAPI_DOC2 = \"petstore_openapi3.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testEqual() {\n    assertOpenApiAreEquals(SWAGGER_DOC1, SWAGGER_DOC1);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEqual", "params": [], "body": "                          {\n    assertOpenApiAreEquals(SWAGGER_DOC1, SWAGGER_DOC1);\n  }", "signature": "@Test\n  public void testEqual()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testSwagger2ToOpenapi3() {\n    assertOpenApiAreEquals(SWAGGER_DOC1, OPENAPI_DOC2);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSwagger2ToOpenapi3", "params": [], "body": "                                       {\n    assertOpenApiAreEquals(SWAGGER_DOC1, OPENAPI_DOC2);\n  }", "signature": "@Test\n  public void testSwagger2ToOpenapi3()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/output/ConsoleRender_titleTest.java", "original_string": "package org.openapitools.openapidiff.core.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class ConsoleRender_titleTest {\n\n  @Test\n  public void testTitle() {\n    ConsoleRender consoleRender = new ConsoleRender();\n    String expected =\n        \"==========================================================================\\n\"\n            + \"==                                Title                                 ==\\n\"\n            + \"==========================================================================\\n\";\n    String actual = consoleRender.title(\"Title\", '=');\n    assertEquals(expected, actual);\n  }\n}\n", "file_hash": "1f94613e4e4d72423cd48a18a6e0239e893af5fa658b24950e2603ebb798c0f0", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.output;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class ConsoleRender_titleTest {\n\n  @Test\n  public void testTitle() {\n    ConsoleRender consoleRender = new ConsoleRender();\n    String expected =\n        \"==========================================================================\\n\"\n            + \"==                                Title                                 ==\\n\"\n            + \"==========================================================================\\n\";\n    String actual = consoleRender.title(\"Title\", '=');\n    assertEquals(expected, actual);\n  }\n}", "definition": "public class ConsoleRender_titleTest", "class_docstring": "", "name": "ConsoleRender_titleTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testTitle() {\n    ConsoleRender consoleRender = new ConsoleRender();\n    String expected =\n        \"==========================================================================\\n\"\n            + \"==                                Title                                 ==\\n\"\n            + \"==========================================================================\\n\";\n    String actual = consoleRender.title(\"Title\", '=');\n    assertEquals(expected, actual);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTitle", "params": [], "body": "                          {\n    ConsoleRender consoleRender = new ConsoleRender();\n    String expected =\n        \"==========================================================================\\n\"\n            + \"==                                Title                                 ==\\n\"\n            + \"==========================================================================\\n\";\n    String actual = consoleRender.title(\"Title\", '=');\n    assertEquals(expected, actual);\n  }", "signature": "@Test\n  public void testTitle()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/utils/FileUtilsTest.java", "original_string": "package org.openapitools.openapidiff.core.utils;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.output.ConsoleRender;\n\nclass FileUtilsTest {\n  private ChangedOpenApi changedOpenApi;\n\n  @BeforeEach\n  void setup() {\n    changedOpenApi = new ChangedOpenApi(OpenApiDiffOptions.builder().build());\n    changedOpenApi.setChangedSchemas(Collections.emptyList());\n    changedOpenApi.setChangedOperations(Collections.emptyList());\n    changedOpenApi.setNewEndpoints(Collections.emptyList());\n    changedOpenApi.setMissingEndpoints(Collections.emptyList());\n  }\n\n  @Test\n  void writeToFile_filenameIsNull_doesNothing() {\n    assertDoesNotThrow(() -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, null));\n  }\n\n  @Test\n  void writeToFile_filenameIsEmpty_doesNothing() {\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, StringUtils.EMPTY));\n  }\n\n  @Test\n  void writeToFile_fileExists_overwrites_file(@TempDir Path tempDir) throws IOException {\n    final Path path = tempDir.resolve(\"output.txt\");\n    Files.write(path, \"Test\".getBytes(StandardCharsets.UTF_8));\n\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, path.toString()));\n    assertThat(path).exists().content().isNotEqualTo(\"Test\");\n  }\n\n  @Test\n  void writeToFile_fileDoesNotExist_createsFile(@TempDir Path tempDir) {\n    final Path path = tempDir.resolve(\"output.txt\");\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, path.toString()));\n    assertThat(path).exists().content().isNotBlank();\n  }\n}\n", "file_hash": "ecd0f8d0e08c1b23935bc781af7b8952a218babb43654c0e51e4ff1ec758fe04", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.utils;", "import static org.assertj.core.api.Assertions.assertThat;", "import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;", "import java.io.IOException;", "import java.nio.charset.StandardCharsets;", "import java.nio.file.Files;", "import java.nio.file.Path;", "import java.util.Collections;", "import org.apache.commons.lang3.StringUtils;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.io.TempDir;", "import org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.output.ConsoleRender;"], "methods": [], "classes": [{"original_string": "class FileUtilsTest {\n  private ChangedOpenApi changedOpenApi;\n\n  @BeforeEach\n  void setup() {\n    changedOpenApi = new ChangedOpenApi(OpenApiDiffOptions.builder().build());\n    changedOpenApi.setChangedSchemas(Collections.emptyList());\n    changedOpenApi.setChangedOperations(Collections.emptyList());\n    changedOpenApi.setNewEndpoints(Collections.emptyList());\n    changedOpenApi.setMissingEndpoints(Collections.emptyList());\n  }\n\n  @Test\n  void writeToFile_filenameIsNull_doesNothing() {\n    assertDoesNotThrow(() -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, null));\n  }\n\n  @Test\n  void writeToFile_filenameIsEmpty_doesNothing() {\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, StringUtils.EMPTY));\n  }\n\n  @Test\n  void writeToFile_fileExists_overwrites_file(@TempDir Path tempDir) throws IOException {\n    final Path path = tempDir.resolve(\"output.txt\");\n    Files.write(path, \"Test\".getBytes(StandardCharsets.UTF_8));\n\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, path.toString()));\n    assertThat(path).exists().content().isNotEqualTo(\"Test\");\n  }\n\n  @Test\n  void writeToFile_fileDoesNotExist_createsFile(@TempDir Path tempDir) {\n    final Path path = tempDir.resolve(\"output.txt\");\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, path.toString()));\n    assertThat(path).exists().content().isNotBlank();\n  }\n}", "definition": "class FileUtilsTest", "class_docstring": "", "name": "FileUtilsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private ChangedOpenApi changedOpenApi;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedOpenApi", "name": "changedOpenApi", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @BeforeEach\n  void setup() {\n    changedOpenApi = new ChangedOpenApi(OpenApiDiffOptions.builder().build());\n    changedOpenApi.setChangedSchemas(Collections.emptyList());\n    changedOpenApi.setChangedOperations(Collections.emptyList());\n    changedOpenApi.setNewEndpoints(Collections.emptyList());\n    changedOpenApi.setMissingEndpoints(Collections.emptyList());\n  }", "docstring": "", "attributes": {"modifiers": "@BeforeEach", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "setup", "params": [], "body": "               {\n    changedOpenApi = new ChangedOpenApi(OpenApiDiffOptions.builder().build());\n    changedOpenApi.setChangedSchemas(Collections.emptyList());\n    changedOpenApi.setChangedOperations(Collections.emptyList());\n    changedOpenApi.setNewEndpoints(Collections.emptyList());\n    changedOpenApi.setMissingEndpoints(Collections.emptyList());\n  }", "signature": "@BeforeEach\n  void setup()"}, {"syntax_pass": true, "original_string": "  @Test\n  void writeToFile_filenameIsNull_doesNothing() {\n    assertDoesNotThrow(() -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, null));\n  }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "writeToFile_filenameIsNull_doesNothing", "params": [], "body": "                                                {\n    assertDoesNotThrow(() -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, null));\n  }", "signature": "@Test\n  void writeToFile_filenameIsNull_doesNothing()"}, {"syntax_pass": true, "original_string": "  @Test\n  void writeToFile_filenameIsEmpty_doesNothing() {\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, StringUtils.EMPTY));\n  }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "writeToFile_filenameIsEmpty_doesNothing", "params": [], "body": "                                                 {\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, StringUtils.EMPTY));\n  }", "signature": "@Test\n  void writeToFile_filenameIsEmpty_doesNothing()"}, {"syntax_pass": true, "original_string": "  @Test\n  void writeToFile_fileExists_overwrites_file(@TempDir Path tempDir) throws IOException {\n    final Path path = tempDir.resolve(\"output.txt\");\n    Files.write(path, \"Test\".getBytes(StandardCharsets.UTF_8));\n\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, path.toString()));\n    assertThat(path).exists().content().isNotEqualTo(\"Test\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "writeToFile_fileExists_overwrites_file", "params": [{"name": "tempDir", "type": "Path"}], "body": "                                                                                        {\n    final Path path = tempDir.resolve(\"output.txt\");\n    Files.write(path, \"Test\".getBytes(StandardCharsets.UTF_8));\n\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, path.toString()));\n    assertThat(path).exists().content().isNotEqualTo(\"Test\");\n  }", "signature": "@Test\n  void writeToFile_fileExists_overwrites_file(@TempDir Path tempDir)"}, {"syntax_pass": true, "original_string": "  @Test\n  void writeToFile_fileDoesNotExist_createsFile(@TempDir Path tempDir) {\n    final Path path = tempDir.resolve(\"output.txt\");\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, path.toString()));\n    assertThat(path).exists().content().isNotBlank();\n  }", "docstring": "", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "writeToFile_fileDoesNotExist_createsFile", "params": [{"name": "tempDir", "type": "Path"}], "body": "                                                                       {\n    final Path path = tempDir.resolve(\"output.txt\");\n    assertDoesNotThrow(\n        () -> FileUtils.writeToFile(new ConsoleRender(), changedOpenApi, path.toString()));\n    assertThat(path).exists().content().isNotBlank();\n  }", "signature": "@Test\n  void writeToFile_fileDoesNotExist_createsFile(@TempDir Path tempDir)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/model/ChangedHeaders_equalsTest.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport io.swagger.v3.oas.models.headers.Header;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\n\npublic class ChangedHeaders_equalsTest {\n\n  @Test\n  public void testEquals_SameInstance() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertTrue(changedHeaders.equals(changedHeaders));\n  }\n\n  @Test\n  public void testEquals_DifferentClass() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertFalse(changedHeaders.equals(new Object()));\n  }\n\n  @Test\n  public void testEquals_NullObject() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertFalse(changedHeaders.equals(null));\n  }\n\n  @Test\n  public void testEquals_DifferentFields() {\n    Map<String, Header> oldHeaders1 = new HashMap<>();\n    Map<String, Header> newHeaders1 = new HashMap<>();\n    DiffContext context1 = new DiffContext(null);\n    ChangedHeaders changedHeaders1 = new ChangedHeaders(oldHeaders1, newHeaders1, context1);\n\n    Map<String, Header> oldHeaders2 = new HashMap<>();\n    Map<String, Header> newHeaders2 = new HashMap<>();\n    DiffContext context2 = new DiffContext(null);\n    ChangedHeaders changedHeaders2 = new ChangedHeaders(oldHeaders2, newHeaders2, context2);\n\n    // Initialize the fields that are not initialized in the constructor\n    changedHeaders1\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n    changedHeaders2\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n\n    // Ensure the fields are different\n    changedHeaders1.getIncreased().put(\"key1\", new Header());\n    changedHeaders2.getIncreased().put(\"key2\", new Header());\n\n    assertFalse(changedHeaders1.equals(changedHeaders2));\n  }\n\n  @Test\n  public void testEquals_SameFields() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders1 = new ChangedHeaders(oldHeaders, newHeaders, context);\n    ChangedHeaders changedHeaders2 = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    // Initialize the fields that are not initialized in the constructor\n    changedHeaders1\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n    changedHeaders2\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n\n    assertTrue(changedHeaders1.equals(changedHeaders2));\n  }\n}\n", "file_hash": "3682f1ebdee4bc4feee7754e914c1b15497716b9530b118d1066b995fa1bdeb1", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.junit.jupiter.api.Assertions.assertFalse;", "import static org.junit.jupiter.api.Assertions.assertTrue;", "import io.swagger.v3.oas.models.headers.Header;", "import java.util.HashMap;", "import java.util.Map;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class ChangedHeaders_equalsTest {\n\n  @Test\n  public void testEquals_SameInstance() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertTrue(changedHeaders.equals(changedHeaders));\n  }\n\n  @Test\n  public void testEquals_DifferentClass() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertFalse(changedHeaders.equals(new Object()));\n  }\n\n  @Test\n  public void testEquals_NullObject() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertFalse(changedHeaders.equals(null));\n  }\n\n  @Test\n  public void testEquals_DifferentFields() {\n    Map<String, Header> oldHeaders1 = new HashMap<>();\n    Map<String, Header> newHeaders1 = new HashMap<>();\n    DiffContext context1 = new DiffContext(null);\n    ChangedHeaders changedHeaders1 = new ChangedHeaders(oldHeaders1, newHeaders1, context1);\n\n    Map<String, Header> oldHeaders2 = new HashMap<>();\n    Map<String, Header> newHeaders2 = new HashMap<>();\n    DiffContext context2 = new DiffContext(null);\n    ChangedHeaders changedHeaders2 = new ChangedHeaders(oldHeaders2, newHeaders2, context2);\n\n    // Initialize the fields that are not initialized in the constructor\n    changedHeaders1\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n    changedHeaders2\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n\n    // Ensure the fields are different\n    changedHeaders1.getIncreased().put(\"key1\", new Header());\n    changedHeaders2.getIncreased().put(\"key2\", new Header());\n\n    assertFalse(changedHeaders1.equals(changedHeaders2));\n  }\n\n  @Test\n  public void testEquals_SameFields() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders1 = new ChangedHeaders(oldHeaders, newHeaders, context);\n    ChangedHeaders changedHeaders2 = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    // Initialize the fields that are not initialized in the constructor\n    changedHeaders1\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n    changedHeaders2\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n\n    assertTrue(changedHeaders1.equals(changedHeaders2));\n  }\n}", "definition": "public class ChangedHeaders_equalsTest", "class_docstring": "", "name": "ChangedHeaders_equalsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testEquals_SameInstance() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertTrue(changedHeaders.equals(changedHeaders));\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEquals_SameInstance", "params": [], "body": "                                        {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertTrue(changedHeaders.equals(changedHeaders));\n  }", "signature": "@Test\n  public void testEquals_SameInstance()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testEquals_DifferentClass() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertFalse(changedHeaders.equals(new Object()));\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEquals_DifferentClass", "params": [], "body": "                                          {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertFalse(changedHeaders.equals(new Object()));\n  }", "signature": "@Test\n  public void testEquals_DifferentClass()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testEquals_NullObject() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertFalse(changedHeaders.equals(null));\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEquals_NullObject", "params": [], "body": "                                      {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    assertFalse(changedHeaders.equals(null));\n  }", "signature": "@Test\n  public void testEquals_NullObject()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testEquals_DifferentFields() {\n    Map<String, Header> oldHeaders1 = new HashMap<>();\n    Map<String, Header> newHeaders1 = new HashMap<>();\n    DiffContext context1 = new DiffContext(null);\n    ChangedHeaders changedHeaders1 = new ChangedHeaders(oldHeaders1, newHeaders1, context1);\n\n    Map<String, Header> oldHeaders2 = new HashMap<>();\n    Map<String, Header> newHeaders2 = new HashMap<>();\n    DiffContext context2 = new DiffContext(null);\n    ChangedHeaders changedHeaders2 = new ChangedHeaders(oldHeaders2, newHeaders2, context2);\n\n    // Initialize the fields that are not initialized in the constructor\n    changedHeaders1\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n    changedHeaders2\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n\n    // Ensure the fields are different\n    changedHeaders1.getIncreased().put(\"key1\", new Header());\n    changedHeaders2.getIncreased().put(\"key2\", new Header());\n\n    assertFalse(changedHeaders1.equals(changedHeaders2));\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEquals_DifferentFields", "params": [], "body": "                                           {\n    Map<String, Header> oldHeaders1 = new HashMap<>();\n    Map<String, Header> newHeaders1 = new HashMap<>();\n    DiffContext context1 = new DiffContext(null);\n    ChangedHeaders changedHeaders1 = new ChangedHeaders(oldHeaders1, newHeaders1, context1);\n\n    Map<String, Header> oldHeaders2 = new HashMap<>();\n    Map<String, Header> newHeaders2 = new HashMap<>();\n    DiffContext context2 = new DiffContext(null);\n    ChangedHeaders changedHeaders2 = new ChangedHeaders(oldHeaders2, newHeaders2, context2);\n\n    // Initialize the fields that are not initialized in the constructor\n    changedHeaders1\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n    changedHeaders2\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n\n    // Ensure the fields are different\n    changedHeaders1.getIncreased().put(\"key1\", new Header());\n    changedHeaders2.getIncreased().put(\"key2\", new Header());\n\n    assertFalse(changedHeaders1.equals(changedHeaders2));\n  }", "signature": "@Test\n  public void testEquals_DifferentFields()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testEquals_SameFields() {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders1 = new ChangedHeaders(oldHeaders, newHeaders, context);\n    ChangedHeaders changedHeaders2 = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    // Initialize the fields that are not initialized in the constructor\n    changedHeaders1\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n    changedHeaders2\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n\n    assertTrue(changedHeaders1.equals(changedHeaders2));\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEquals_SameFields", "params": [], "body": "                                      {\n    Map<String, Header> oldHeaders = new HashMap<>();\n    Map<String, Header> newHeaders = new HashMap<>();\n    DiffContext context = new DiffContext(null);\n    ChangedHeaders changedHeaders1 = new ChangedHeaders(oldHeaders, newHeaders, context);\n    ChangedHeaders changedHeaders2 = new ChangedHeaders(oldHeaders, newHeaders, context);\n\n    // Initialize the fields that are not initialized in the constructor\n    changedHeaders1\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n    changedHeaders2\n        .setIncreased(new HashMap<>())\n        .setMissing(new HashMap<>())\n        .setChanged(new HashMap<>());\n\n    assertTrue(changedHeaders1.equals(changedHeaders2));\n  }", "signature": "@Test\n  public void testEquals_SameFields()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/model/ChangedResponse_hashCodeTest.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport java.util.Objects;\nimport org.junit.jupiter.api.Test;\n\npublic class ChangedResponse_hashCodeTest {\n\n  @Test\n  public void testHashCode() {\n    ApiResponse oldApiResponse = new ApiResponse().description(\"Old Response\");\n    ApiResponse newApiResponse = new ApiResponse().description(\"New Response\");\n    DiffContext context = new DiffContext(null);\n    ChangedResponse changedResponse = new ChangedResponse(oldApiResponse, newApiResponse, context);\n\n    int expectedHashCode =\n        Objects.hash(oldApiResponse, newApiResponse, context, null, null, null, null);\n    assertEquals(expectedHashCode, changedResponse.hashCode());\n  }\n}\n", "file_hash": "985b5454faf7d80d438d22cbfd2508e687db1b8e012323b2d814a013ffe5fdc9", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import java.util.Objects;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class ChangedResponse_hashCodeTest {\n\n  @Test\n  public void testHashCode() {\n    ApiResponse oldApiResponse = new ApiResponse().description(\"Old Response\");\n    ApiResponse newApiResponse = new ApiResponse().description(\"New Response\");\n    DiffContext context = new DiffContext(null);\n    ChangedResponse changedResponse = new ChangedResponse(oldApiResponse, newApiResponse, context);\n\n    int expectedHashCode =\n        Objects.hash(oldApiResponse, newApiResponse, context, null, null, null, null);\n    assertEquals(expectedHashCode, changedResponse.hashCode());\n  }\n}", "definition": "public class ChangedResponse_hashCodeTest", "class_docstring": "", "name": "ChangedResponse_hashCodeTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testHashCode() {\n    ApiResponse oldApiResponse = new ApiResponse().description(\"Old Response\");\n    ApiResponse newApiResponse = new ApiResponse().description(\"New Response\");\n    DiffContext context = new DiffContext(null);\n    ChangedResponse changedResponse = new ChangedResponse(oldApiResponse, newApiResponse, context);\n\n    int expectedHashCode =\n        Objects.hash(oldApiResponse, newApiResponse, context, null, null, null, null);\n    assertEquals(expectedHashCode, changedResponse.hashCode());\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHashCode", "params": [], "body": "                             {\n    ApiResponse oldApiResponse = new ApiResponse().description(\"Old Response\");\n    ApiResponse newApiResponse = new ApiResponse().description(\"New Response\");\n    DiffContext context = new DiffContext(null);\n    ChangedResponse changedResponse = new ChangedResponse(oldApiResponse, newApiResponse, context);\n\n    int expectedHashCode =\n        Objects.hash(oldApiResponse, newApiResponse, context, null, null, null, null);\n    assertEquals(expectedHashCode, changedResponse.hashCode());\n  }", "signature": "@Test\n  public void testHashCode()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/model/deferred/PendingChanged_setValueTest.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Optional;\nimport org.junit.jupiter.api.Test;\n\npublic class PendingChanged_setValueTest {\n\n  @Test\n  public void testSetValue_FirstTime() {\n    PendingChanged<String> pendingChanged = new PendingChanged<>();\n    Optional<String> value = Optional.of(\"test\");\n\n    pendingChanged.setValue(value);\n\n    assertTrue(pendingChanged.isValueSet());\n    assertTrue(pendingChanged.isPresent());\n    assertEquals(\"test\", pendingChanged.get());\n  }\n\n  @Test\n  public void testSetValue_SecondTime() {\n    PendingChanged<String> pendingChanged = new PendingChanged<>();\n    Optional<String> value = Optional.of(\"test\");\n\n    pendingChanged.setValue(value);\n\n    IllegalStateException exception =\n        assertThrows(\n            IllegalStateException.class,\n            () -> {\n              pendingChanged.setValue(value);\n            });\n\n    assertEquals(\n        \"PendingChanged may not be set more than once. Value was already set.\",\n        exception.getMessage());\n  }\n}\n", "file_hash": "7f7d6201ac617acc12bb041b327d0bcbd9f9ff442161733d9d2e3a0ebbff6556", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import static org.junit.jupiter.api.Assertions.*;", "import java.util.Optional;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class PendingChanged_setValueTest {\n\n  @Test\n  public void testSetValue_FirstTime() {\n    PendingChanged<String> pendingChanged = new PendingChanged<>();\n    Optional<String> value = Optional.of(\"test\");\n\n    pendingChanged.setValue(value);\n\n    assertTrue(pendingChanged.isValueSet());\n    assertTrue(pendingChanged.isPresent());\n    assertEquals(\"test\", pendingChanged.get());\n  }\n\n  @Test\n  public void testSetValue_SecondTime() {\n    PendingChanged<String> pendingChanged = new PendingChanged<>();\n    Optional<String> value = Optional.of(\"test\");\n\n    pendingChanged.setValue(value);\n\n    IllegalStateException exception =\n        assertThrows(\n            IllegalStateException.class,\n            () -> {\n              pendingChanged.setValue(value);\n            });\n\n    assertEquals(\n        \"PendingChanged may not be set more than once. Value was already set.\",\n        exception.getMessage());\n  }\n}", "definition": "public class PendingChanged_setValueTest", "class_docstring": "", "name": "PendingChanged_setValueTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void testSetValue_FirstTime() {\n    PendingChanged<String> pendingChanged = new PendingChanged<>();\n    Optional<String> value = Optional.of(\"test\");\n\n    pendingChanged.setValue(value);\n\n    assertTrue(pendingChanged.isValueSet());\n    assertTrue(pendingChanged.isPresent());\n    assertEquals(\"test\", pendingChanged.get());\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetValue_FirstTime", "params": [], "body": "                                       {\n    PendingChanged<String> pendingChanged = new PendingChanged<>();\n    Optional<String> value = Optional.of(\"test\");\n\n    pendingChanged.setValue(value);\n\n    assertTrue(pendingChanged.isValueSet());\n    assertTrue(pendingChanged.isPresent());\n    assertEquals(\"test\", pendingChanged.get());\n  }", "signature": "@Test\n  public void testSetValue_FirstTime()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testSetValue_SecondTime() {\n    PendingChanged<String> pendingChanged = new PendingChanged<>();\n    Optional<String> value = Optional.of(\"test\");\n\n    pendingChanged.setValue(value);\n\n    IllegalStateException exception =\n        assertThrows(\n            IllegalStateException.class,\n            () -> {\n              pendingChanged.setValue(value);\n            });\n\n    assertEquals(\n        \"PendingChanged may not be set more than once. Value was already set.\",\n        exception.getMessage());\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetValue_SecondTime", "params": [], "body": "                                        {\n    PendingChanged<String> pendingChanged = new PendingChanged<>();\n    Optional<String> value = Optional.of(\"test\");\n\n    pendingChanged.setValue(value);\n\n    IllegalStateException exception =\n        assertThrows(\n            IllegalStateException.class,\n            () -> {\n              pendingChanged.setValue(value);\n            });\n\n    assertEquals(\n        \"PendingChanged may not be set more than once. Value was already set.\",\n        exception.getMessage());\n  }", "signature": "@Test\n  public void testSetValue_SecondTime()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/model/deferred/DeferredBuilderChangedTest.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport java.util.Optional;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.schema.ChangedReadOnly;\nimport org.openapitools.openapidiff.core.model.schema.ChangedWriteOnly;\n\npublic class DeferredBuilderChangedTest {\n\n  private PendingChanged<ChangedReadOnly> changed;\n  private Optional<ChangedReadOnly> whenSet;\n  private ChangedWriteOnly mappedValue;\n  private Optional<?> chainedValue;\n\n  @BeforeEach\n  public void beforeEach() {\n    whenSet = Optional.empty();\n    mappedValue = null;\n    chainedValue = Optional.empty();\n    changed = new PendingChanged<>();\n  }\n\n  @Test\n  public void testPendingChangedValueSetBeforeListeners() {\n    PendingChanged<String> changed = new PendingChanged<>();\n    changed.setValue(Optional.of(\"Hello\"));\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(true);\n  }\n\n  @Test\n  public void testPendingChangedValueSetAfterListeners() {\n    PendingChanged<String> changed = new PendingChanged<>();\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    changed.setValue(Optional.of(\"Hello\"));\n    assertion.assertSet(true);\n  }\n\n  @Test\n  public void testPendingChangedValueEMpty() {\n    PendingChanged<String> changed = new PendingChanged<>();\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    changed.setValue(Optional.empty());\n    assertion.assertSet(false);\n  }\n\n  @Test\n  public void testRealizedChange() {\n    RealizedChanged<String> changed = new RealizedChanged<>(\"hello\");\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(true);\n  }\n\n  @Test\n  public void testRealizedChangeEmpty() {\n    RealizedChanged<String> changed = new RealizedChanged<>(Optional.empty());\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(false);\n  }\n\n  private static class ChangedAssertion {\n    AtomicBoolean map = new AtomicBoolean(false);\n    AtomicBoolean flatMap = new AtomicBoolean(false);\n    AtomicBoolean mapOptional = new AtomicBoolean(false);\n    AtomicBoolean whenSet = new AtomicBoolean(false);\n    AtomicBoolean ifPresent = new AtomicBoolean(false);\n\n    public ChangedAssertion(DeferredChanged<?> changed) {\n      changed.mapOptional(\n          (value) -> {\n            mapOptional.set(true);\n            return Optional.empty();\n          });\n      changed.map(\n          (value) -> {\n            map.set(true);\n            return Optional.empty();\n          });\n      changed.flatMap(\n          (value) -> {\n            flatMap.set(true);\n            return DeferredChanged.empty();\n          });\n      changed.whenSet((value) -> whenSet.set(true));\n      changed.ifPresent((value) -> ifPresent.set(true));\n    }\n\n    public void assertSet(boolean expectedIfPresent) {\n      Assertions.assertTrue(mapOptional.get(), \"mapOptional\");\n      Assertions.assertTrue(map.get(), \"map\");\n      Assertions.assertTrue(flatMap.get(), \"flatMap\");\n      Assertions.assertTrue(whenSet.get(), \"whenSet\");\n      Assertions.assertEquals(expectedIfPresent, ifPresent.get(), \"ifPresent\");\n    }\n\n    public void assertNotSet() {\n      Assertions.assertFalse(mapOptional.get(), \"mapOptional\");\n      Assertions.assertFalse(map.get(), \"map\");\n      Assertions.assertFalse(flatMap.get(), \"flatMap\");\n      Assertions.assertFalse(whenSet.get(), \"whenSet\");\n      Assertions.assertFalse(ifPresent.get(), \"ifPresent\");\n    }\n  }\n\n  @Test\n  public void testFlatMap() {\n    PendingChanged<ChangedWriteOnly> flatMapPending = new PendingChanged<>();\n\n    changed.whenSet((value) -> this.whenSet = value);\n\n    DeferredChanged<ChangedWriteOnly> chainedChanged =\n        changed.flatMap(\n            (value) -> {\n              System.out.println(\"Flatmap called\");\n              return flatMapPending;\n            });\n    chainedChanged.whenSet(value -> chainedValue = value);\n\n    DeferredChanged<ChangedWriteOnly> mappedDeferred =\n        changed.map(value -> new ChangedWriteOnly(false, true, null));\n    mappedDeferred.ifPresent(v -> mappedValue = v);\n\n    Assertions.assertFalse(whenSet.isPresent());\n    Assertions.assertFalse(chainedValue.isPresent());\n    Assertions.assertNull(mappedValue);\n\n    changed.setValue(Optional.of(new ChangedReadOnly(false, true, null)));\n    Assertions.assertTrue(whenSet.isPresent());\n    Assertions.assertNotNull(mappedValue);\n    Assertions.assertFalse(chainedValue.isPresent());\n\n    flatMapPending.setValue(Optional.of(new ChangedWriteOnly(false, true, null)));\n    Assertions.assertTrue(whenSet.isPresent());\n    Assertions.assertTrue(chainedValue.isPresent());\n  }\n\n  @Test\n  public void testDeferredBuilderEmpty() {\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertSet(false);\n  }\n\n  @Test\n  public void testDeferredBuilderAllRealized() {\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    builder.add(new RealizedChanged<>(\"hello\"));\n    builder.add(new RealizedChanged<>(\"bye\"));\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertSet(true);\n  }\n\n  @Test\n  public void testDeferredBuilderPending() {\n    PendingChanged<String> changed = new PendingChanged<>();\n\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    builder.add(new RealizedChanged<>(\"hello\"));\n    builder.add(changed);\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertNotSet();\n\n    changed.setValue(Optional.of(\"hello\"));\n    builderAssertion.assertSet(true);\n  }\n}\n", "file_hash": "b05e30be18082fb4b67ae491605f102734c645b9395ed1d1d9414ccb675efca8", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import java.util.Optional;", "import java.util.concurrent.atomic.AtomicBoolean;", "import org.junit.jupiter.api.Assertions;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.schema.ChangedReadOnly;", "import org.openapitools.openapidiff.core.model.schema.ChangedWriteOnly;"], "methods": [], "classes": [{"original_string": "public class DeferredBuilderChangedTest {\n\n  private PendingChanged<ChangedReadOnly> changed;\n  private Optional<ChangedReadOnly> whenSet;\n  private ChangedWriteOnly mappedValue;\n  private Optional<?> chainedValue;\n\n  @BeforeEach\n  public void beforeEach() {\n    whenSet = Optional.empty();\n    mappedValue = null;\n    chainedValue = Optional.empty();\n    changed = new PendingChanged<>();\n  }\n\n  @Test\n  public void testPendingChangedValueSetBeforeListeners() {\n    PendingChanged<String> changed = new PendingChanged<>();\n    changed.setValue(Optional.of(\"Hello\"));\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(true);\n  }\n\n  @Test\n  public void testPendingChangedValueSetAfterListeners() {\n    PendingChanged<String> changed = new PendingChanged<>();\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    changed.setValue(Optional.of(\"Hello\"));\n    assertion.assertSet(true);\n  }\n\n  @Test\n  public void testPendingChangedValueEMpty() {\n    PendingChanged<String> changed = new PendingChanged<>();\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    changed.setValue(Optional.empty());\n    assertion.assertSet(false);\n  }\n\n  @Test\n  public void testRealizedChange() {\n    RealizedChanged<String> changed = new RealizedChanged<>(\"hello\");\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(true);\n  }\n\n  @Test\n  public void testRealizedChangeEmpty() {\n    RealizedChanged<String> changed = new RealizedChanged<>(Optional.empty());\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(false);\n  }\n\n  private static class ChangedAssertion {\n    AtomicBoolean map = new AtomicBoolean(false);\n    AtomicBoolean flatMap = new AtomicBoolean(false);\n    AtomicBoolean mapOptional = new AtomicBoolean(false);\n    AtomicBoolean whenSet = new AtomicBoolean(false);\n    AtomicBoolean ifPresent = new AtomicBoolean(false);\n\n    public ChangedAssertion(DeferredChanged<?> changed) {\n      changed.mapOptional(\n          (value) -> {\n            mapOptional.set(true);\n            return Optional.empty();\n          });\n      changed.map(\n          (value) -> {\n            map.set(true);\n            return Optional.empty();\n          });\n      changed.flatMap(\n          (value) -> {\n            flatMap.set(true);\n            return DeferredChanged.empty();\n          });\n      changed.whenSet((value) -> whenSet.set(true));\n      changed.ifPresent((value) -> ifPresent.set(true));\n    }\n\n    public void assertSet(boolean expectedIfPresent) {\n      Assertions.assertTrue(mapOptional.get(), \"mapOptional\");\n      Assertions.assertTrue(map.get(), \"map\");\n      Assertions.assertTrue(flatMap.get(), \"flatMap\");\n      Assertions.assertTrue(whenSet.get(), \"whenSet\");\n      Assertions.assertEquals(expectedIfPresent, ifPresent.get(), \"ifPresent\");\n    }\n\n    public void assertNotSet() {\n      Assertions.assertFalse(mapOptional.get(), \"mapOptional\");\n      Assertions.assertFalse(map.get(), \"map\");\n      Assertions.assertFalse(flatMap.get(), \"flatMap\");\n      Assertions.assertFalse(whenSet.get(), \"whenSet\");\n      Assertions.assertFalse(ifPresent.get(), \"ifPresent\");\n    }\n  }\n\n  @Test\n  public void testFlatMap() {\n    PendingChanged<ChangedWriteOnly> flatMapPending = new PendingChanged<>();\n\n    changed.whenSet((value) -> this.whenSet = value);\n\n    DeferredChanged<ChangedWriteOnly> chainedChanged =\n        changed.flatMap(\n            (value) -> {\n              System.out.println(\"Flatmap called\");\n              return flatMapPending;\n            });\n    chainedChanged.whenSet(value -> chainedValue = value);\n\n    DeferredChanged<ChangedWriteOnly> mappedDeferred =\n        changed.map(value -> new ChangedWriteOnly(false, true, null));\n    mappedDeferred.ifPresent(v -> mappedValue = v);\n\n    Assertions.assertFalse(whenSet.isPresent());\n    Assertions.assertFalse(chainedValue.isPresent());\n    Assertions.assertNull(mappedValue);\n\n    changed.setValue(Optional.of(new ChangedReadOnly(false, true, null)));\n    Assertions.assertTrue(whenSet.isPresent());\n    Assertions.assertNotNull(mappedValue);\n    Assertions.assertFalse(chainedValue.isPresent());\n\n    flatMapPending.setValue(Optional.of(new ChangedWriteOnly(false, true, null)));\n    Assertions.assertTrue(whenSet.isPresent());\n    Assertions.assertTrue(chainedValue.isPresent());\n  }\n\n  @Test\n  public void testDeferredBuilderEmpty() {\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertSet(false);\n  }\n\n  @Test\n  public void testDeferredBuilderAllRealized() {\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    builder.add(new RealizedChanged<>(\"hello\"));\n    builder.add(new RealizedChanged<>(\"bye\"));\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertSet(true);\n  }\n\n  @Test\n  public void testDeferredBuilderPending() {\n    PendingChanged<String> changed = new PendingChanged<>();\n\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    builder.add(new RealizedChanged<>(\"hello\"));\n    builder.add(changed);\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertNotSet();\n\n    changed.setValue(Optional.of(\"hello\"));\n    builderAssertion.assertSet(true);\n  }\n}", "definition": "public class DeferredBuilderChangedTest", "class_docstring": "", "name": "DeferredBuilderChangedTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private PendingChanged<ChangedReadOnly> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PendingChanged<ChangedReadOnly>", "name": "changed", "syntax_pass": true}, {"attribute_expression": "private Optional<ChangedReadOnly> whenSet;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Optional<ChangedReadOnly>", "name": "whenSet", "syntax_pass": true}, {"attribute_expression": "private ChangedWriteOnly mappedValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedWriteOnly", "name": "mappedValue", "syntax_pass": true}, {"attribute_expression": "private Optional<?> chainedValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Optional<?>", "name": "chainedValue", "syntax_pass": true}], "classes": [{"original_string": "  private static class ChangedAssertion {\n    AtomicBoolean map = new AtomicBoolean(false);\n    AtomicBoolean flatMap = new AtomicBoolean(false);\n    AtomicBoolean mapOptional = new AtomicBoolean(false);\n    AtomicBoolean whenSet = new AtomicBoolean(false);\n    AtomicBoolean ifPresent = new AtomicBoolean(false);\n\n    public ChangedAssertion(DeferredChanged<?> changed) {\n      changed.mapOptional(\n          (value) -> {\n            mapOptional.set(true);\n            return Optional.empty();\n          });\n      changed.map(\n          (value) -> {\n            map.set(true);\n            return Optional.empty();\n          });\n      changed.flatMap(\n          (value) -> {\n            flatMap.set(true);\n            return DeferredChanged.empty();\n          });\n      changed.whenSet((value) -> whenSet.set(true));\n      changed.ifPresent((value) -> ifPresent.set(true));\n    }\n\n    public void assertSet(boolean expectedIfPresent) {\n      Assertions.assertTrue(mapOptional.get(), \"mapOptional\");\n      Assertions.assertTrue(map.get(), \"map\");\n      Assertions.assertTrue(flatMap.get(), \"flatMap\");\n      Assertions.assertTrue(whenSet.get(), \"whenSet\");\n      Assertions.assertEquals(expectedIfPresent, ifPresent.get(), \"ifPresent\");\n    }\n\n    public void assertNotSet() {\n      Assertions.assertFalse(mapOptional.get(), \"mapOptional\");\n      Assertions.assertFalse(map.get(), \"map\");\n      Assertions.assertFalse(flatMap.get(), \"flatMap\");\n      Assertions.assertFalse(whenSet.get(), \"whenSet\");\n      Assertions.assertFalse(ifPresent.get(), \"ifPresent\");\n    }\n  }", "definition": "  private static class ChangedAssertion", "class_docstring": "", "name": "ChangedAssertion", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "AtomicBoolean map = new AtomicBoolean(false);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "AtomicBoolean", "name": "map = new AtomicBoolean(false)", "syntax_pass": true}, {"attribute_expression": "AtomicBoolean flatMap = new AtomicBoolean(false);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "AtomicBoolean", "name": "flatMap = new AtomicBoolean(false)", "syntax_pass": true}, {"attribute_expression": "AtomicBoolean mapOptional = new AtomicBoolean(false);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "AtomicBoolean", "name": "mapOptional = new AtomicBoolean(false)", "syntax_pass": true}, {"attribute_expression": "AtomicBoolean whenSet = new AtomicBoolean(false);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "AtomicBoolean", "name": "whenSet = new AtomicBoolean(false)", "syntax_pass": true}, {"attribute_expression": "AtomicBoolean ifPresent = new AtomicBoolean(false);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "AtomicBoolean", "name": "ifPresent = new AtomicBoolean(false)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ChangedAssertion(DeferredChanged<?> changed) {\n      changed.mapOptional(\n          (value) -> {\n            mapOptional.set(true);\n            return Optional.empty();\n          });\n      changed.map(\n          (value) -> {\n            map.set(true);\n            return Optional.empty();\n          });\n      changed.flatMap(\n          (value) -> {\n            flatMap.set(true);\n            return DeferredChanged.empty();\n          });\n      changed.whenSet((value) -> whenSet.set(true));\n      changed.ifPresent((value) -> ifPresent.set(true));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedAssertion", "params": [{"name": "changed", "type": "DeferredChanged<?>"}], "body": "                                                        {\n      changed.mapOptional(\n          (value) -> {\n            mapOptional.set(true);\n            return Optional.empty();\n          });\n      changed.map(\n          (value) -> {\n            map.set(true);\n            return Optional.empty();\n          });\n      changed.flatMap(\n          (value) -> {\n            flatMap.set(true);\n            return DeferredChanged.empty();\n          });\n      changed.whenSet((value) -> whenSet.set(true));\n      changed.ifPresent((value) -> ifPresent.set(true));\n    }", "signature": "public ChangedAssertion(DeferredChanged<?> changed)"}, {"syntax_pass": true, "original_string": "    public void assertSet(boolean expectedIfPresent) {\n      Assertions.assertTrue(mapOptional.get(), \"mapOptional\");\n      Assertions.assertTrue(map.get(), \"map\");\n      Assertions.assertTrue(flatMap.get(), \"flatMap\");\n      Assertions.assertTrue(whenSet.get(), \"whenSet\");\n      Assertions.assertEquals(expectedIfPresent, ifPresent.get(), \"ifPresent\");\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "assertSet", "params": [{"name": "expectedIfPresent", "type": "boolean"}], "body": "                                                     {\n      Assertions.assertTrue(mapOptional.get(), \"mapOptional\");\n      Assertions.assertTrue(map.get(), \"map\");\n      Assertions.assertTrue(flatMap.get(), \"flatMap\");\n      Assertions.assertTrue(whenSet.get(), \"whenSet\");\n      Assertions.assertEquals(expectedIfPresent, ifPresent.get(), \"ifPresent\");\n    }", "signature": "public void assertSet(boolean expectedIfPresent)"}, {"syntax_pass": true, "original_string": "    public void assertNotSet() {\n      Assertions.assertFalse(mapOptional.get(), \"mapOptional\");\n      Assertions.assertFalse(map.get(), \"map\");\n      Assertions.assertFalse(flatMap.get(), \"flatMap\");\n      Assertions.assertFalse(whenSet.get(), \"whenSet\");\n      Assertions.assertFalse(ifPresent.get(), \"ifPresent\");\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "assertNotSet", "params": [], "body": "                               {\n      Assertions.assertFalse(mapOptional.get(), \"mapOptional\");\n      Assertions.assertFalse(map.get(), \"map\");\n      Assertions.assertFalse(flatMap.get(), \"flatMap\");\n      Assertions.assertFalse(whenSet.get(), \"whenSet\");\n      Assertions.assertFalse(ifPresent.get(), \"ifPresent\");\n    }", "signature": "public void assertNotSet()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @BeforeEach\n  public void beforeEach() {\n    whenSet = Optional.empty();\n    mappedValue = null;\n    chainedValue = Optional.empty();\n    changed = new PendingChanged<>();\n  }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n  public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "beforeEach", "params": [], "body": "                           {\n    whenSet = Optional.empty();\n    mappedValue = null;\n    chainedValue = Optional.empty();\n    changed = new PendingChanged<>();\n  }", "signature": "@BeforeEach\n  public void beforeEach()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testPendingChangedValueSetBeforeListeners() {\n    PendingChanged<String> changed = new PendingChanged<>();\n    changed.setValue(Optional.of(\"Hello\"));\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(true);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPendingChangedValueSetBeforeListeners", "params": [], "body": "                                                          {\n    PendingChanged<String> changed = new PendingChanged<>();\n    changed.setValue(Optional.of(\"Hello\"));\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(true);\n  }", "signature": "@Test\n  public void testPendingChangedValueSetBeforeListeners()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testPendingChangedValueSetAfterListeners() {\n    PendingChanged<String> changed = new PendingChanged<>();\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    changed.setValue(Optional.of(\"Hello\"));\n    assertion.assertSet(true);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPendingChangedValueSetAfterListeners", "params": [], "body": "                                                         {\n    PendingChanged<String> changed = new PendingChanged<>();\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    changed.setValue(Optional.of(\"Hello\"));\n    assertion.assertSet(true);\n  }", "signature": "@Test\n  public void testPendingChangedValueSetAfterListeners()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testPendingChangedValueEMpty() {\n    PendingChanged<String> changed = new PendingChanged<>();\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    changed.setValue(Optional.empty());\n    assertion.assertSet(false);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPendingChangedValueEMpty", "params": [], "body": "                                             {\n    PendingChanged<String> changed = new PendingChanged<>();\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    changed.setValue(Optional.empty());\n    assertion.assertSet(false);\n  }", "signature": "@Test\n  public void testPendingChangedValueEMpty()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testRealizedChange() {\n    RealizedChanged<String> changed = new RealizedChanged<>(\"hello\");\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(true);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRealizedChange", "params": [], "body": "                                   {\n    RealizedChanged<String> changed = new RealizedChanged<>(\"hello\");\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(true);\n  }", "signature": "@Test\n  public void testRealizedChange()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testRealizedChangeEmpty() {\n    RealizedChanged<String> changed = new RealizedChanged<>(Optional.empty());\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(false);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRealizedChangeEmpty", "params": [], "body": "                                        {\n    RealizedChanged<String> changed = new RealizedChanged<>(Optional.empty());\n    ChangedAssertion assertion = new ChangedAssertion(changed);\n    assertion.assertSet(false);\n  }", "signature": "@Test\n  public void testRealizedChangeEmpty()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testFlatMap() {\n    PendingChanged<ChangedWriteOnly> flatMapPending = new PendingChanged<>();\n\n    changed.whenSet((value) -> this.whenSet = value);\n\n    DeferredChanged<ChangedWriteOnly> chainedChanged =\n        changed.flatMap(\n            (value) -> {\n              System.out.println(\"Flatmap called\");\n              return flatMapPending;\n            });\n    chainedChanged.whenSet(value -> chainedValue = value);\n\n    DeferredChanged<ChangedWriteOnly> mappedDeferred =\n        changed.map(value -> new ChangedWriteOnly(false, true, null));\n    mappedDeferred.ifPresent(v -> mappedValue = v);\n\n    Assertions.assertFalse(whenSet.isPresent());\n    Assertions.assertFalse(chainedValue.isPresent());\n    Assertions.assertNull(mappedValue);\n\n    changed.setValue(Optional.of(new ChangedReadOnly(false, true, null)));\n    Assertions.assertTrue(whenSet.isPresent());\n    Assertions.assertNotNull(mappedValue);\n    Assertions.assertFalse(chainedValue.isPresent());\n\n    flatMapPending.setValue(Optional.of(new ChangedWriteOnly(false, true, null)));\n    Assertions.assertTrue(whenSet.isPresent());\n    Assertions.assertTrue(chainedValue.isPresent());\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFlatMap", "params": [], "body": "                            {\n    PendingChanged<ChangedWriteOnly> flatMapPending = new PendingChanged<>();\n\n    changed.whenSet((value) -> this.whenSet = value);\n\n    DeferredChanged<ChangedWriteOnly> chainedChanged =\n        changed.flatMap(\n            (value) -> {\n              System.out.println(\"Flatmap called\");\n              return flatMapPending;\n            });\n    chainedChanged.whenSet(value -> chainedValue = value);\n\n    DeferredChanged<ChangedWriteOnly> mappedDeferred =\n        changed.map(value -> new ChangedWriteOnly(false, true, null));\n    mappedDeferred.ifPresent(v -> mappedValue = v);\n\n    Assertions.assertFalse(whenSet.isPresent());\n    Assertions.assertFalse(chainedValue.isPresent());\n    Assertions.assertNull(mappedValue);\n\n    changed.setValue(Optional.of(new ChangedReadOnly(false, true, null)));\n    Assertions.assertTrue(whenSet.isPresent());\n    Assertions.assertNotNull(mappedValue);\n    Assertions.assertFalse(chainedValue.isPresent());\n\n    flatMapPending.setValue(Optional.of(new ChangedWriteOnly(false, true, null)));\n    Assertions.assertTrue(whenSet.isPresent());\n    Assertions.assertTrue(chainedValue.isPresent());\n  }", "signature": "@Test\n  public void testFlatMap()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDeferredBuilderEmpty() {\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertSet(false);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeferredBuilderEmpty", "params": [], "body": "                                         {\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertSet(false);\n  }", "signature": "@Test\n  public void testDeferredBuilderEmpty()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDeferredBuilderAllRealized() {\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    builder.add(new RealizedChanged<>(\"hello\"));\n    builder.add(new RealizedChanged<>(\"bye\"));\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertSet(true);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeferredBuilderAllRealized", "params": [], "body": "                                               {\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    builder.add(new RealizedChanged<>(\"hello\"));\n    builder.add(new RealizedChanged<>(\"bye\"));\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertSet(true);\n  }", "signature": "@Test\n  public void testDeferredBuilderAllRealized()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testDeferredBuilderPending() {\n    PendingChanged<String> changed = new PendingChanged<>();\n\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    builder.add(new RealizedChanged<>(\"hello\"));\n    builder.add(changed);\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertNotSet();\n\n    changed.setValue(Optional.of(\"hello\"));\n    builderAssertion.assertSet(true);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testDeferredBuilderPending", "params": [], "body": "                                           {\n    PendingChanged<String> changed = new PendingChanged<>();\n\n    DeferredBuilder<String> builder = new DeferredBuilder<>();\n    builder.add(new RealizedChanged<>(\"hello\"));\n    builder.add(changed);\n    ChangedAssertion builderAssertion = new ChangedAssertion(builder.build());\n    builderAssertion.assertNotSet();\n\n    changed.setValue(Optional.of(\"hello\"));\n    builderAssertion.assertSet(true);\n  }", "signature": "@Test\n  public void testDeferredBuilderPending()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/model/deferred/DeferredBuilder_buildTest.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n\nimport java.util.List;\nimport java.util.Optional;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\npublic class DeferredBuilder_buildTest {\n\n  private DeferredBuilder<String> builder;\n\n  @Mock private DeferredChanged<String> deferred1;\n\n  @Mock private DeferredChanged<String> deferred2;\n\n  @Mock private PendingChanged<List<Optional<? super String>>> pendingChanged;\n\n  @BeforeEach\n  public void setUp() {\n    builder = new DeferredBuilder<>();\n  }\n\n  @Test\n  public void testBuild_WithEmptyDeferredValues() {\n    DeferredChanged<List<Optional<? super String>>> result = builder.build();\n    assertEquals(DeferredChanged.empty(), result);\n  }\n\n  @Test\n  public void testBuild_WithNonEmptyDeferredValues() {\n    builder.add(deferred1);\n    builder.add(deferred2);\n\n    DeferredChanged<List<Optional<? super String>>> result = builder.build();\n\n    verify(deferred1).whenSet(any());\n    verify(deferred2).whenSet(any());\n  }\n}\n", "file_hash": "3050fe8140db37a617db464b2f2c32ba000bdd343721f0421f01d09d5e1fd241", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import static org.junit.jupiter.api.Assertions.assertEquals;", "import static org.mockito.Mockito.*;", "import java.util.List;", "import java.util.Optional;", "import org.junit.jupiter.api.BeforeEach;", "import org.junit.jupiter.api.Test;", "import org.junit.jupiter.api.extension.ExtendWith;", "import org.mockito.Mock;", "import org.mockito.junit.jupiter.MockitoExtension;"], "methods": [], "classes": [{"original_string": "@ExtendWith(MockitoExtension.class)\npublic class DeferredBuilder_buildTest {\n\n  private DeferredBuilder<String> builder;\n\n  @Mock private DeferredChanged<String> deferred1;\n\n  @Mock private DeferredChanged<String> deferred2;\n\n  @Mock private PendingChanged<List<Optional<? super String>>> pendingChanged;\n\n  @BeforeEach\n  public void setUp() {\n    builder = new DeferredBuilder<>();\n  }\n\n  @Test\n  public void testBuild_WithEmptyDeferredValues() {\n    DeferredChanged<List<Optional<? super String>>> result = builder.build();\n    assertEquals(DeferredChanged.empty(), result);\n  }\n\n  @Test\n  public void testBuild_WithNonEmptyDeferredValues() {\n    builder.add(deferred1);\n    builder.add(deferred2);\n\n    DeferredChanged<List<Optional<? super String>>> result = builder.build();\n\n    verify(deferred1).whenSet(any());\n    verify(deferred2).whenSet(any());\n  }\n}", "definition": "@ExtendWith(MockitoExtension.class)\npublic class DeferredBuilder_buildTest", "class_docstring": "", "name": "DeferredBuilder_buildTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@ExtendWith(MockitoExtension.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@ExtendWith(MockitoExtension.class)", "public"], "comments": [], "fields": [{"attribute_expression": "private DeferredBuilder<String> builder;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DeferredBuilder<String>", "name": "builder", "syntax_pass": true}, {"attribute_expression": "@Mock private DeferredChanged<String> deferred1;", "docstring": "", "modifiers": "@Mock private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "DeferredChanged<String>", "name": "deferred1", "syntax_pass": true}, {"attribute_expression": "@Mock private DeferredChanged<String> deferred2;", "docstring": "", "modifiers": "@Mock private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "DeferredChanged<String>", "name": "deferred2", "syntax_pass": true}, {"attribute_expression": "@Mock private PendingChanged<List<Optional<? super String>>> pendingChanged;", "docstring": "", "modifiers": "@Mock private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "PendingChanged<List<Optional<? super String>>>", "name": "pendingChanged", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @BeforeEach\n  public void setUp() {\n    builder = new DeferredBuilder<>();\n  }", "docstring": "", "attributes": {"modifiers": "@BeforeEach\n  public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                      {\n    builder = new DeferredBuilder<>();\n  }", "signature": "@BeforeEach\n  public void setUp()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testBuild_WithEmptyDeferredValues() {\n    DeferredChanged<List<Optional<? super String>>> result = builder.build();\n    assertEquals(DeferredChanged.empty(), result);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuild_WithEmptyDeferredValues", "params": [], "body": "                                                  {\n    DeferredChanged<List<Optional<? super String>>> result = builder.build();\n    assertEquals(DeferredChanged.empty(), result);\n  }", "signature": "@Test\n  public void testBuild_WithEmptyDeferredValues()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void testBuild_WithNonEmptyDeferredValues() {\n    builder.add(deferred1);\n    builder.add(deferred2);\n\n    DeferredChanged<List<Optional<? super String>>> result = builder.build();\n\n    verify(deferred1).whenSet(any());\n    verify(deferred2).whenSet(any());\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuild_WithNonEmptyDeferredValues", "params": [], "body": "                                                     {\n    builder.add(deferred1);\n    builder.add(deferred2);\n\n    DeferredChanged<List<Optional<? super String>>> result = builder.build();\n\n    verify(deferred1).whenSet(any());\n    verify(deferred2).whenSet(any());\n  }", "signature": "@Test\n  public void testBuild_WithNonEmptyDeferredValues()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/NumericRangeBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_NUMERIC_RANGE_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_NUMERIC_RANGE_INCREASED;\n\nimport org.junit.jupiter.api.Test;\n\npublic class NumericRangeBCTest {\n  private final String BASE = \"bc_numericrange_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_numericrange_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestExclusiveMaxCreated() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_max_created.yaml\");\n  }\n\n  @Test\n  public void requestExclusiveMaxSet() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_max_set.yaml\");\n  }\n\n  @Test\n  public void requestExclusiveMinCreated() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_min_created.yaml\");\n  }\n\n  @Test\n  public void requestExclusiveMinSet() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_min_set.yaml\");\n  }\n\n  @Test\n  public void requestMaxAdded() {\n    assertIncompatibleRequest(\"bc_request_numericrange_max_added.yaml\");\n  }\n\n  @Test\n  public void requestMaxDecreased() {\n    assertIncompatibleRequest(\"bc_request_numericrange_max_decreased.yaml\");\n  }\n\n  @Test\n  public void requestMinAdded() {\n    assertIncompatibleRequest(\"bc_request_numericrange_min_added.yaml\");\n  }\n\n  @Test\n  public void requestMinIncreased() {\n    assertIncompatibleRequest(\"bc_request_numericrange_min_increased.yaml\");\n  }\n\n  @Test\n  public void responseExclusiveMaxDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_max_deleted.yaml\");\n  }\n\n  @Test\n  public void responseExclusiveMaxUnset() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_max_unset.yaml\");\n  }\n\n  @Test\n  public void responseExclusiveMinDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_min_deleted.yaml\");\n  }\n\n  @Test\n  public void responseExclusiveMinUnset() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_min_unset.yaml\");\n  }\n\n  @Test\n  public void responseMaxDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_max_deleted.yaml\");\n  }\n\n  @Test\n  public void responseMaxIncreased() {\n    assertIncompatibleResponse(\"bc_response_numericrange_max_increased.yaml\");\n  }\n\n  @Test\n  public void responseMinDecreased() {\n    assertIncompatibleResponse(\"bc_response_numericrange_min_decreased.yaml\");\n  }\n\n  @Test\n  public void responseMinDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_min_deleted.yaml\");\n  }\n\n  private void assertIncompatibleRequest(String newSpec) {\n    assertSpecIncompatible(BASE, newSpec, REQUEST_NUMERIC_RANGE_DECREASED);\n  }\n\n  private void assertIncompatibleResponse(String newSpec) {\n    assertSpecIncompatible(BASE, newSpec, RESPONSE_NUMERIC_RANGE_INCREASED);\n  }\n}\n", "file_hash": "1b6ab858752a97c6dfe191cba8f184ab6ba1b356b78465682a307cdedef141c1", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_NUMERIC_RANGE_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_NUMERIC_RANGE_INCREASED;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class NumericRangeBCTest {\n  private final String BASE = \"bc_numericrange_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_numericrange_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestExclusiveMaxCreated() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_max_created.yaml\");\n  }\n\n  @Test\n  public void requestExclusiveMaxSet() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_max_set.yaml\");\n  }\n\n  @Test\n  public void requestExclusiveMinCreated() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_min_created.yaml\");\n  }\n\n  @Test\n  public void requestExclusiveMinSet() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_min_set.yaml\");\n  }\n\n  @Test\n  public void requestMaxAdded() {\n    assertIncompatibleRequest(\"bc_request_numericrange_max_added.yaml\");\n  }\n\n  @Test\n  public void requestMaxDecreased() {\n    assertIncompatibleRequest(\"bc_request_numericrange_max_decreased.yaml\");\n  }\n\n  @Test\n  public void requestMinAdded() {\n    assertIncompatibleRequest(\"bc_request_numericrange_min_added.yaml\");\n  }\n\n  @Test\n  public void requestMinIncreased() {\n    assertIncompatibleRequest(\"bc_request_numericrange_min_increased.yaml\");\n  }\n\n  @Test\n  public void responseExclusiveMaxDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_max_deleted.yaml\");\n  }\n\n  @Test\n  public void responseExclusiveMaxUnset() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_max_unset.yaml\");\n  }\n\n  @Test\n  public void responseExclusiveMinDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_min_deleted.yaml\");\n  }\n\n  @Test\n  public void responseExclusiveMinUnset() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_min_unset.yaml\");\n  }\n\n  @Test\n  public void responseMaxDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_max_deleted.yaml\");\n  }\n\n  @Test\n  public void responseMaxIncreased() {\n    assertIncompatibleResponse(\"bc_response_numericrange_max_increased.yaml\");\n  }\n\n  @Test\n  public void responseMinDecreased() {\n    assertIncompatibleResponse(\"bc_response_numericrange_min_decreased.yaml\");\n  }\n\n  @Test\n  public void responseMinDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_min_deleted.yaml\");\n  }\n\n  private void assertIncompatibleRequest(String newSpec) {\n    assertSpecIncompatible(BASE, newSpec, REQUEST_NUMERIC_RANGE_DECREASED);\n  }\n\n  private void assertIncompatibleResponse(String newSpec) {\n    assertSpecIncompatible(BASE, newSpec, RESPONSE_NUMERIC_RANGE_INCREASED);\n  }\n}", "definition": "public class NumericRangeBCTest", "class_docstring": "", "name": "NumericRangeBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_numericrange_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_numericrange_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_numericrange_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_numericrange_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestExclusiveMaxCreated() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_max_created.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestExclusiveMaxCreated", "params": [], "body": "                                           {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_max_created.yaml\");\n  }", "signature": "@Test\n  public void requestExclusiveMaxCreated()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestExclusiveMaxSet() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_max_set.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestExclusiveMaxSet", "params": [], "body": "                                       {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_max_set.yaml\");\n  }", "signature": "@Test\n  public void requestExclusiveMaxSet()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestExclusiveMinCreated() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_min_created.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestExclusiveMinCreated", "params": [], "body": "                                           {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_min_created.yaml\");\n  }", "signature": "@Test\n  public void requestExclusiveMinCreated()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestExclusiveMinSet() {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_min_set.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestExclusiveMinSet", "params": [], "body": "                                       {\n    assertIncompatibleRequest(\"bc_request_numericrange_exclusive_min_set.yaml\");\n  }", "signature": "@Test\n  public void requestExclusiveMinSet()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestMaxAdded() {\n    assertIncompatibleRequest(\"bc_request_numericrange_max_added.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestMaxAdded", "params": [], "body": "                                {\n    assertIncompatibleRequest(\"bc_request_numericrange_max_added.yaml\");\n  }", "signature": "@Test\n  public void requestMaxAdded()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestMaxDecreased() {\n    assertIncompatibleRequest(\"bc_request_numericrange_max_decreased.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestMaxDecreased", "params": [], "body": "                                    {\n    assertIncompatibleRequest(\"bc_request_numericrange_max_decreased.yaml\");\n  }", "signature": "@Test\n  public void requestMaxDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestMinAdded() {\n    assertIncompatibleRequest(\"bc_request_numericrange_min_added.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestMinAdded", "params": [], "body": "                                {\n    assertIncompatibleRequest(\"bc_request_numericrange_min_added.yaml\");\n  }", "signature": "@Test\n  public void requestMinAdded()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestMinIncreased() {\n    assertIncompatibleRequest(\"bc_request_numericrange_min_increased.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestMinIncreased", "params": [], "body": "                                    {\n    assertIncompatibleRequest(\"bc_request_numericrange_min_increased.yaml\");\n  }", "signature": "@Test\n  public void requestMinIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseExclusiveMaxDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_max_deleted.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseExclusiveMaxDeleted", "params": [], "body": "                                            {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_max_deleted.yaml\");\n  }", "signature": "@Test\n  public void responseExclusiveMaxDeleted()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseExclusiveMaxUnset() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_max_unset.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseExclusiveMaxUnset", "params": [], "body": "                                          {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_max_unset.yaml\");\n  }", "signature": "@Test\n  public void responseExclusiveMaxUnset()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseExclusiveMinDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_min_deleted.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseExclusiveMinDeleted", "params": [], "body": "                                            {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_min_deleted.yaml\");\n  }", "signature": "@Test\n  public void responseExclusiveMinDeleted()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseExclusiveMinUnset() {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_min_unset.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseExclusiveMinUnset", "params": [], "body": "                                          {\n    assertIncompatibleResponse(\"bc_response_numericrange_exclusive_min_unset.yaml\");\n  }", "signature": "@Test\n  public void responseExclusiveMinUnset()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseMaxDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_max_deleted.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseMaxDeleted", "params": [], "body": "                                   {\n    assertIncompatibleResponse(\"bc_response_numericrange_max_deleted.yaml\");\n  }", "signature": "@Test\n  public void responseMaxDeleted()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseMaxIncreased() {\n    assertIncompatibleResponse(\"bc_response_numericrange_max_increased.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseMaxIncreased", "params": [], "body": "                                     {\n    assertIncompatibleResponse(\"bc_response_numericrange_max_increased.yaml\");\n  }", "signature": "@Test\n  public void responseMaxIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseMinDecreased() {\n    assertIncompatibleResponse(\"bc_response_numericrange_min_decreased.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseMinDecreased", "params": [], "body": "                                     {\n    assertIncompatibleResponse(\"bc_response_numericrange_min_decreased.yaml\");\n  }", "signature": "@Test\n  public void responseMinDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseMinDeleted() {\n    assertIncompatibleResponse(\"bc_response_numericrange_min_deleted.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseMinDeleted", "params": [], "body": "                                   {\n    assertIncompatibleResponse(\"bc_response_numericrange_min_deleted.yaml\");\n  }", "signature": "@Test\n  public void responseMinDeleted()"}, {"syntax_pass": true, "original_string": "  private void assertIncompatibleRequest(String newSpec) {\n    assertSpecIncompatible(BASE, newSpec, REQUEST_NUMERIC_RANGE_DECREASED);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertIncompatibleRequest", "params": [{"name": "newSpec", "type": "String"}], "body": "                                                         {\n    assertSpecIncompatible(BASE, newSpec, REQUEST_NUMERIC_RANGE_DECREASED);\n  }", "signature": "private void assertIncompatibleRequest(String newSpec)"}, {"syntax_pass": true, "original_string": "  private void assertIncompatibleResponse(String newSpec) {\n    assertSpecIncompatible(BASE, newSpec, RESPONSE_NUMERIC_RANGE_INCREASED);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "assertIncompatibleResponse", "params": [{"name": "newSpec", "type": "String"}], "body": "                                                          {\n    assertSpecIncompatible(BASE, newSpec, RESPONSE_NUMERIC_RANGE_INCREASED);\n  }", "signature": "private void assertIncompatibleResponse(String newSpec)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/SecuritySchemeBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.*;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.*;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class SecuritySchemeBCTest {\n  private final String BASE = \"bc_security_scheme_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_security_scheme_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void bearerFormatChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_BEARER_FORMAT_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_bearer_format_changed.yaml\", prop);\n  }\n\n  @Test\n  public void inChanged() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_scheme_in_changed.yaml\");\n  }\n\n  @Test\n  public void openIdConnectUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OPENIDCONNECT_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_open_id_connect_url_changed.yaml\", prop);\n  }\n\n  @Test\n  public void schemeChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_SCHEME_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_scheme_changed.yaml\", prop);\n  }\n\n  @Test\n  public void typeChanged() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_scheme_type_changed.yaml\");\n  }\n\n  @Test\n  public void scopesIncreased() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_SCOPES_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_scopes_increased.yaml\", prop);\n  }\n}\n", "file_hash": "4e975f840596d9f0bbf3014966c52ada7638b85eb6e8b0e7099a5ad5fcc2164f", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.*;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.*;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class SecuritySchemeBCTest {\n  private final String BASE = \"bc_security_scheme_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_security_scheme_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void bearerFormatChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_BEARER_FORMAT_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_bearer_format_changed.yaml\", prop);\n  }\n\n  @Test\n  public void inChanged() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_scheme_in_changed.yaml\");\n  }\n\n  @Test\n  public void openIdConnectUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OPENIDCONNECT_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_open_id_connect_url_changed.yaml\", prop);\n  }\n\n  @Test\n  public void schemeChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_SCHEME_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_scheme_changed.yaml\", prop);\n  }\n\n  @Test\n  public void typeChanged() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_scheme_type_changed.yaml\");\n  }\n\n  @Test\n  public void scopesIncreased() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_SCOPES_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_scopes_increased.yaml\", prop);\n  }\n}", "definition": "public class SecuritySchemeBCTest", "class_docstring": "", "name": "SecuritySchemeBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_security_scheme_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_security_scheme_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_security_scheme_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_security_scheme_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void bearerFormatChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_BEARER_FORMAT_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_bearer_format_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "bearerFormatChanged", "params": [], "body": "                                    {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_BEARER_FORMAT_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_bearer_format_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void bearerFormatChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void inChanged() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_scheme_in_changed.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "inChanged", "params": [], "body": "                          {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_scheme_in_changed.yaml\");\n  }", "signature": "@Test\n  public void inChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void openIdConnectUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OPENIDCONNECT_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_open_id_connect_url_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "openIdConnectUrlChanged", "params": [], "body": "                                        {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OPENIDCONNECT_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_open_id_connect_url_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void openIdConnectUrlChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void schemeChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_SCHEME_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_scheme_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "schemeChanged", "params": [], "body": "                              {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_SCHEME_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_scheme_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void schemeChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void typeChanged() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_scheme_type_changed.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "typeChanged", "params": [], "body": "                            {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_scheme_type_changed.yaml\");\n  }", "signature": "@Test\n  public void typeChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void scopesIncreased() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_SCOPES_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_scopes_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "scopesIncreased", "params": [], "body": "                                {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_SCOPES_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_security_scheme_scopes_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void scopesIncreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/ReadOnlyBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_READONLY_INCREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_READONLY_REQUIRED_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class ReadOnlyBCTest {\n  private final String BASE = \"bc_readonly_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_readonly_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestReadOnlyIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_READONLY_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_readonly_increased.yaml\", prop);\n  }\n\n  @Test\n  public void requestReadOnlyRequiredDecreased() {\n    // Incompatible because a prev RO prop (invalid) is now not RO and required\n    BackwardIncompatibleProp prop = REQUEST_READONLY_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_readonly_required_decreased.yaml\", prop);\n  }\n}\n", "file_hash": "a6f338e644ed65d1e80929f74d8352c692d8f9f33b7d42c2961ae9c7364bf31c", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_READONLY_INCREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_READONLY_REQUIRED_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class ReadOnlyBCTest {\n  private final String BASE = \"bc_readonly_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_readonly_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestReadOnlyIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_READONLY_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_readonly_increased.yaml\", prop);\n  }\n\n  @Test\n  public void requestReadOnlyRequiredDecreased() {\n    // Incompatible because a prev RO prop (invalid) is now not RO and required\n    BackwardIncompatibleProp prop = REQUEST_READONLY_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_readonly_required_decreased.yaml\", prop);\n  }\n}", "definition": "public class ReadOnlyBCTest", "class_docstring": "", "name": "ReadOnlyBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_readonly_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_readonly_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_readonly_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_readonly_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestReadOnlyIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_READONLY_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_readonly_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestReadOnlyIncreased", "params": [], "body": "                                         {\n    BackwardIncompatibleProp prop = REQUEST_READONLY_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_readonly_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void requestReadOnlyIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestReadOnlyRequiredDecreased() {\n    // Incompatible because a prev RO prop (invalid) is now not RO and required\n    BackwardIncompatibleProp prop = REQUEST_READONLY_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_readonly_required_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestReadOnlyRequiredDecreased", "params": [], "body": "                                                 {\n    // Incompatible because a prev RO prop (invalid) is now not RO and required\n    BackwardIncompatibleProp prop = REQUEST_READONLY_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_readonly_required_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void requestReadOnlyRequiredDecreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/PathsBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class PathsBCTest {\n  private final String BASE = \"bc_paths_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_paths_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_paths_decreased.yaml\", prop);\n  }\n}\n", "file_hash": "0c856f98c303308e2f792e1b50449db03e9420909d41958bd821bf4d0ae61c37", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class PathsBCTest {\n  private final String BASE = \"bc_paths_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_paths_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_paths_decreased.yaml\", prop);\n  }\n}", "definition": "public class PathsBCTest", "class_docstring": "", "name": "PathsBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_paths_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_paths_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_paths_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_paths_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_paths_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "decreased", "params": [], "body": "                          {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_paths_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void decreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/ApiResponseBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_RESPONSES_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class ApiResponseBCTest {\n  private final String BASE = \"bc_response_apiresponse_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_response_apiresponse_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = RESPONSE_RESPONSES_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_apiresponse_decreased.yaml\", prop);\n  }\n}\n", "file_hash": "d205f0d391347a40f8940b33e06404dc5d1943a4bcd88e654c393721913bb000", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_RESPONSES_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class ApiResponseBCTest {\n  private final String BASE = \"bc_response_apiresponse_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_response_apiresponse_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = RESPONSE_RESPONSES_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_apiresponse_decreased.yaml\", prop);\n  }\n}", "definition": "public class ApiResponseBCTest", "class_docstring": "", "name": "ApiResponseBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_response_apiresponse_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_response_apiresponse_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_response_apiresponse_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_response_apiresponse_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = RESPONSE_RESPONSES_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_apiresponse_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "decreased", "params": [], "body": "                          {\n    BackwardIncompatibleProp prop = RESPONSE_RESPONSES_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_apiresponse_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void decreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/SchemaBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_REQUIRED_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SCHEMA_DISCRIMINATOR_CHANGED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SCHEMA_TYPE_CHANGED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class SchemaBCTest {\n  private final String BASE = \"bc_schema_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_schema_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void discriminatorChanged() {\n    BackwardIncompatibleProp prop = SCHEMA_DISCRIMINATOR_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_schema_discriminator_changed.yaml\", prop);\n  }\n\n  @Test\n  public void requestFormatDecreased() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_request_schema_format_decreased.yaml\");\n  }\n\n  @Test\n  public void requestFormatIncreased() {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertOpenApiBackwardIncompatible(BASE, \"bc_request_schema_format_increased.yaml\");\n  }\n\n  @Test\n  public void requestPropsPutIncreased() {\n    // See https://github.com/OpenAPITools/openapi-diff/issues/537\n    assertSpecChangedButCompatible(BASE, \"bc_request_schema_props_put_increased.yaml\");\n  }\n\n  @Test\n  public void responseFormatDecreased() {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertOpenApiBackwardIncompatible(BASE, \"bc_response_schema_format_decreased.yaml\");\n  }\n\n  @Test\n  public void responseFormatIncreased() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_response_schema_format_increased.yaml\");\n  }\n\n  @Test\n  public void responsePropsRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_schema_props_required_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void typeChanged() {\n    BackwardIncompatibleProp prop = SCHEMA_TYPE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_schema_type_changed.yaml\", prop);\n  }\n}\n", "file_hash": "b09a154606489e55da17627999f6469e49db7118cccb1efc6139f57a6ad7a62c", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertOpenApiBackwardIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_REQUIRED_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SCHEMA_DISCRIMINATOR_CHANGED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SCHEMA_TYPE_CHANGED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class SchemaBCTest {\n  private final String BASE = \"bc_schema_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_schema_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void discriminatorChanged() {\n    BackwardIncompatibleProp prop = SCHEMA_DISCRIMINATOR_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_schema_discriminator_changed.yaml\", prop);\n  }\n\n  @Test\n  public void requestFormatDecreased() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_request_schema_format_decreased.yaml\");\n  }\n\n  @Test\n  public void requestFormatIncreased() {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertOpenApiBackwardIncompatible(BASE, \"bc_request_schema_format_increased.yaml\");\n  }\n\n  @Test\n  public void requestPropsPutIncreased() {\n    // See https://github.com/OpenAPITools/openapi-diff/issues/537\n    assertSpecChangedButCompatible(BASE, \"bc_request_schema_props_put_increased.yaml\");\n  }\n\n  @Test\n  public void responseFormatDecreased() {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertOpenApiBackwardIncompatible(BASE, \"bc_response_schema_format_decreased.yaml\");\n  }\n\n  @Test\n  public void responseFormatIncreased() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_response_schema_format_increased.yaml\");\n  }\n\n  @Test\n  public void responsePropsRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_schema_props_required_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void typeChanged() {\n    BackwardIncompatibleProp prop = SCHEMA_TYPE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_schema_type_changed.yaml\", prop);\n  }\n}", "definition": "public class SchemaBCTest", "class_docstring": "", "name": "SchemaBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_schema_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_schema_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_schema_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_schema_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void discriminatorChanged() {\n    BackwardIncompatibleProp prop = SCHEMA_DISCRIMINATOR_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_schema_discriminator_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "discriminatorChanged", "params": [], "body": "                                     {\n    BackwardIncompatibleProp prop = SCHEMA_DISCRIMINATOR_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_schema_discriminator_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void discriminatorChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestFormatDecreased() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_request_schema_format_decreased.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestFormatDecreased", "params": [], "body": "                                       {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_request_schema_format_decreased.yaml\");\n  }", "signature": "@Test\n  public void requestFormatDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestFormatIncreased() {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertOpenApiBackwardIncompatible(BASE, \"bc_request_schema_format_increased.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestFormatIncreased", "params": [], "body": "                                       {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertOpenApiBackwardIncompatible(BASE, \"bc_request_schema_format_increased.yaml\");\n  }", "signature": "@Test\n  public void requestFormatIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestPropsPutIncreased() {\n    // See https://github.com/OpenAPITools/openapi-diff/issues/537\n    assertSpecChangedButCompatible(BASE, \"bc_request_schema_props_put_increased.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestPropsPutIncreased", "params": [], "body": "                                         {\n    // See https://github.com/OpenAPITools/openapi-diff/issues/537\n    assertSpecChangedButCompatible(BASE, \"bc_request_schema_props_put_increased.yaml\");\n  }", "signature": "@Test\n  public void requestPropsPutIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseFormatDecreased() {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertOpenApiBackwardIncompatible(BASE, \"bc_response_schema_format_decreased.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseFormatDecreased", "params": [], "body": "                                        {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertOpenApiBackwardIncompatible(BASE, \"bc_response_schema_format_decreased.yaml\");\n  }", "signature": "@Test\n  public void responseFormatDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseFormatIncreased() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_response_schema_format_increased.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseFormatIncreased", "params": [], "body": "                                        {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_response_schema_format_increased.yaml\");\n  }", "signature": "@Test\n  public void responseFormatIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responsePropsRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_schema_props_required_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responsePropsRequiredDecreased", "params": [], "body": "                                               {\n    BackwardIncompatibleProp prop = RESPONSE_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_schema_props_required_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void responsePropsRequiredDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void typeChanged() {\n    BackwardIncompatibleProp prop = SCHEMA_TYPE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_schema_type_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "typeChanged", "params": [], "body": "                            {\n    BackwardIncompatibleProp prop = SCHEMA_TYPE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_schema_type_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void typeChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/ContentBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_CONTENT_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_CONTENT_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class ContentBCTest {\n  private final String BASE = \"bc_content_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_content_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_CONTENT_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_content_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_CONTENT_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_content_decreased.yaml\", prop);\n  }\n}\n", "file_hash": "1b6ef2ba06814aa74988a07cc7e2b2a286b26aec8c750cf6cb1631035c9d9fd0", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_CONTENT_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_CONTENT_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class ContentBCTest {\n  private final String BASE = \"bc_content_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_content_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_CONTENT_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_content_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_CONTENT_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_content_decreased.yaml\", prop);\n  }\n}", "definition": "public class ContentBCTest", "class_docstring": "", "name": "ContentBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_content_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_content_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_content_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_content_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_CONTENT_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_content_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestDecreased", "params": [], "body": "                                 {\n    BackwardIncompatibleProp prop = REQUEST_CONTENT_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_content_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void requestDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_CONTENT_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_content_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseDecreased", "params": [], "body": "                                  {\n    BackwardIncompatibleProp prop = RESPONSE_CONTENT_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_content_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseDecreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/MaxLengthBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_MAX_LENGTH_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_MAX_LENGTH_INCREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class MaxLengthBCTest {\n  private final String BASE = \"bc_maxlength_base.yaml\";\n\n  @Test\n  public void maxLengthUnchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void requestMaxLengthDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_MAX_LENGTH_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_maxlength_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseMaxLengthIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_MAX_LENGTH_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_maxlength_increased.yaml\", prop);\n  }\n}\n", "file_hash": "bc2f57f63252d0439f694bfbc586020141d371d74fb775ad85e2669b664cc35a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_MAX_LENGTH_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_MAX_LENGTH_INCREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class MaxLengthBCTest {\n  private final String BASE = \"bc_maxlength_base.yaml\";\n\n  @Test\n  public void maxLengthUnchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void requestMaxLengthDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_MAX_LENGTH_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_maxlength_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseMaxLengthIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_MAX_LENGTH_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_maxlength_increased.yaml\", prop);\n  }\n}", "definition": "public class MaxLengthBCTest", "class_docstring": "", "name": "MaxLengthBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_maxlength_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_maxlength_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void maxLengthUnchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "maxLengthUnchanged", "params": [], "body": "                                   {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void maxLengthUnchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestMaxLengthDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_MAX_LENGTH_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_maxlength_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestMaxLengthDecreased", "params": [], "body": "                                          {\n    BackwardIncompatibleProp prop = REQUEST_MAX_LENGTH_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_maxlength_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void requestMaxLengthDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseMaxLengthIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_MAX_LENGTH_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_maxlength_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseMaxLengthIncreased", "params": [], "body": "                                           {\n    BackwardIncompatibleProp prop = RESPONSE_MAX_LENGTH_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_maxlength_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseMaxLengthIncreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/HeadersBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADERS_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class HeadersBCTest {\n  private final String BASE = \"bc_response_headers_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_response_headers_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void responseDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_HEADERS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_headers_decreased.yaml\", prop);\n  }\n}\n", "file_hash": "cd430b6066563cb71a87f321911786b63691f8770727d4bfc0404e5a6c7b8b22", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADERS_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class HeadersBCTest {\n  private final String BASE = \"bc_response_headers_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_response_headers_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void responseDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_HEADERS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_headers_decreased.yaml\", prop);\n  }\n}", "definition": "public class HeadersBCTest", "class_docstring": "", "name": "HeadersBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_response_headers_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_response_headers_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_response_headers_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_response_headers_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_HEADERS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_headers_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseDecreased", "params": [], "body": "                                  {\n    BackwardIncompatibleProp prop = RESPONSE_HEADERS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_headers_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseDecreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/OperationBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\n\nimport org.junit.jupiter.api.Test;\n\npublic class OperationBCTest {\n  private final String BASE = \"bc_operation_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_operation_changed_but_compatible.yaml\");\n  }\n}\n", "file_hash": "b6763a90c069596288a08ccf802e5be9f4ea2861eaefed917e9f1a6e48ac767a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import org.junit.jupiter.api.Test;"], "methods": [], "classes": [{"original_string": "public class OperationBCTest {\n  private final String BASE = \"bc_operation_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_operation_changed_but_compatible.yaml\");\n  }\n}", "definition": "public class OperationBCTest", "class_docstring": "", "name": "OperationBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_operation_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_operation_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_operation_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_operation_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/ParametersBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_REQUIRED_INCREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class ParametersBCTest {\n  private final String BASE = \"bc_request_params_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_request_params_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_params_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void requiredIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_params_required_increased.yaml\", prop);\n  }\n}\n", "file_hash": "d4c7ee7639c5c61d586b96da70a4c3cd1622d615f4aa7bd26d408878c8501a53", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_REQUIRED_INCREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class ParametersBCTest {\n  private final String BASE = \"bc_request_params_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_request_params_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_params_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void requiredIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_params_required_increased.yaml\", prop);\n  }\n}", "definition": "public class ParametersBCTest", "class_docstring": "", "name": "ParametersBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_request_params_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_request_params_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_request_params_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_request_params_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_params_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "decreased", "params": [], "body": "                          {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_params_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void decreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requiredIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_params_required_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requiredIncreased", "params": [], "body": "                                  {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_params_required_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void requiredIncreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/RequestBodyBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class RequestBodyBCTest {\n  private final String BASE = \"bc_request_body_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void requiredChanged() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_body_required_changed.yaml\", prop);\n  }\n}\n", "file_hash": "ccbdec44b1f93c2483364fe0b49b56714d87cccad659c02c1c74baf6a0d3f276", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class RequestBodyBCTest {\n  private final String BASE = \"bc_request_body_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void requiredChanged() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_body_required_changed.yaml\", prop);\n  }\n}", "definition": "public class RequestBodyBCTest", "class_docstring": "", "name": "RequestBodyBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_request_body_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_request_body_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requiredChanged() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_body_required_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requiredChanged", "params": [], "body": "                                {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_body_required_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void requiredChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/OneOfBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_ONEOF_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_ONEOF_INCREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class OneOfBCTest {\n  private final String BASE = \"bc_oneof_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_oneof_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_ONEOF_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_oneof_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_ONEOF_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_oneof_increased.yaml\", prop);\n  }\n}\n", "file_hash": "ef4c4ecee3669ee41e13890de7027a41d3dc9b7c5a97fca98a242e774bf825fd", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_ONEOF_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_ONEOF_INCREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class OneOfBCTest {\n  private final String BASE = \"bc_oneof_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_oneof_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_ONEOF_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_oneof_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_ONEOF_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_oneof_increased.yaml\", prop);\n  }\n}", "definition": "public class OneOfBCTest", "class_docstring": "", "name": "OneOfBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_oneof_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_oneof_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_oneof_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_oneof_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_ONEOF_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_oneof_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestDecreased", "params": [], "body": "                                 {\n    BackwardIncompatibleProp prop = REQUEST_ONEOF_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_oneof_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void requestDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_ONEOF_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_oneof_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseIncreased", "params": [], "body": "                                  {\n    BackwardIncompatibleProp prop = RESPONSE_ONEOF_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_oneof_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseIncreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/SecurityRequirementBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.*;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_REQUIREMENT_SCHEMES_INCREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class SecurityRequirementBCTest {\n  private final String BASE = \"bc_security_requirement_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_security_requirement_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void schemesIncreased() {\n    BackwardIncompatibleProp prop = SECURITY_REQUIREMENT_SCHEMES_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_security_requirement_schemes_increased.yaml\", prop);\n  }\n}\n", "file_hash": "d21b7073c760eb6260f96d96dfbca218e69e3288dadf0404fd6f7a4580aa450a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.*;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_REQUIREMENT_SCHEMES_INCREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class SecurityRequirementBCTest {\n  private final String BASE = \"bc_security_requirement_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_security_requirement_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void schemesIncreased() {\n    BackwardIncompatibleProp prop = SECURITY_REQUIREMENT_SCHEMES_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_security_requirement_schemes_increased.yaml\", prop);\n  }\n}", "definition": "public class SecurityRequirementBCTest", "class_docstring": "", "name": "SecurityRequirementBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_security_requirement_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_security_requirement_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_security_requirement_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_security_requirement_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void schemesIncreased() {\n    BackwardIncompatibleProp prop = SECURITY_REQUIREMENT_SCHEMES_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_security_requirement_schemes_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "schemesIncreased", "params": [], "body": "                                 {\n    BackwardIncompatibleProp prop = SECURITY_REQUIREMENT_SCHEMES_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_security_requirement_schemes_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void schemesIncreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/HeaderBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_EXPLODE_CHANGED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_REQUIRED_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_REQUIRED_INCREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class HeaderBCTest {\n  private final String BASE = \"bc_response_header_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_response_header_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void responseExplodeChanged() {\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_EXPLODE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_response_header_explode_changed.yaml\", prop);\n  }\n\n  @Test\n  public void responseRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_header_required_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseRequiredIncreased() {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_header_required_increased.yaml\", prop);\n  }\n}\n", "file_hash": "1a50062cc0d593faca6e45e6a5b82ff6d98fe4fa25379c10319e7da3ea8292c5", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_EXPLODE_CHANGED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_REQUIRED_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_REQUIRED_INCREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class HeaderBCTest {\n  private final String BASE = \"bc_response_header_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_response_header_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void responseExplodeChanged() {\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_EXPLODE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_response_header_explode_changed.yaml\", prop);\n  }\n\n  @Test\n  public void responseRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_header_required_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseRequiredIncreased() {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_header_required_increased.yaml\", prop);\n  }\n}", "definition": "public class HeaderBCTest", "class_docstring": "", "name": "HeaderBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_response_header_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_response_header_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_response_header_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_response_header_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseExplodeChanged() {\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_EXPLODE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_response_header_explode_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseExplodeChanged", "params": [], "body": "                                       {\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_EXPLODE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_response_header_explode_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void responseExplodeChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_header_required_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseRequiredDecreased", "params": [], "body": "                                          {\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_header_required_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseRequiredDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseRequiredIncreased() {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_header_required_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseRequiredIncreased", "params": [], "body": "                                          {\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    BackwardIncompatibleProp prop = RESPONSE_HEADER_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_header_required_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseRequiredIncreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/EnumBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_ENUM_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_ENUM_INCREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class EnumBCTest {\n  private final String BASE = \"bc_enum_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_enum_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_ENUM_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_enum_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_ENUM_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_enum_increased.yaml\", prop);\n  }\n}\n", "file_hash": "a9bcd2160004938781178c93f25ad8e935b1e5b9ef2d24bd4de74e98ce5232e6", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_ENUM_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_ENUM_INCREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class EnumBCTest {\n  private final String BASE = \"bc_enum_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_enum_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_ENUM_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_enum_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void responseIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_ENUM_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_enum_increased.yaml\", prop);\n  }\n}", "definition": "public class EnumBCTest", "class_docstring": "", "name": "EnumBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_enum_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_enum_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_enum_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_enum_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_ENUM_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_enum_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestDecreased", "params": [], "body": "                                 {\n    BackwardIncompatibleProp prop = REQUEST_ENUM_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_enum_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void requestDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_ENUM_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_enum_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseIncreased", "params": [], "body": "                                  {\n    BackwardIncompatibleProp prop = RESPONSE_ENUM_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_enum_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseIncreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/OAuthFlowBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class OAuthFlowBCTest {\n  private final String BASE = \"bc_oauthflow_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void authorizationUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_authorization_url_changed.yaml\", prop);\n  }\n\n  @Test\n  public void refreshUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_refresh_url_changed.yaml\", prop);\n  }\n\n  @Test\n  public void tokenUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_token_url_changed.yaml\", prop);\n  }\n}\n", "file_hash": "a3bef581b0d2dd3871b8c49f408204020a54ec819d9630be5a4f8efdee303d9f", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class OAuthFlowBCTest {\n  private final String BASE = \"bc_oauthflow_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void authorizationUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_authorization_url_changed.yaml\", prop);\n  }\n\n  @Test\n  public void refreshUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_refresh_url_changed.yaml\", prop);\n  }\n\n  @Test\n  public void tokenUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_token_url_changed.yaml\", prop);\n  }\n}", "definition": "public class OAuthFlowBCTest", "class_docstring": "", "name": "OAuthFlowBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_oauthflow_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_oauthflow_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void authorizationUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_authorization_url_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "authorizationUrlChanged", "params": [], "body": "                                        {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_authorization_url_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void authorizationUrlChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void refreshUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_refresh_url_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "refreshUrlChanged", "params": [], "body": "                                  {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_refresh_url_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void refreshUrlChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void tokenUrlChanged() {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_token_url_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tokenUrlChanged", "params": [], "body": "                                {\n    BackwardIncompatibleProp prop = SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_oauthflow_token_url_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void tokenUrlChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/WriteOnlyBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_WRITEONLY_INCREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_WRITEONLY_REQUIRED_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class WriteOnlyBCTest {\n  private final String BASE = \"bc_writeonly_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_writeonly_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void responseWriteOnlyIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_WRITEONLY_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_writeonly_increased.yaml\", prop);\n  }\n\n  @Test\n  public void responseWriteOnlyRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_WRITEONLY_REQUIRED_DECREASED;\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertSpecIncompatible(BASE, \"bc_response_writeonly_required_decreased.yaml\", prop);\n  }\n}\n", "file_hash": "1139a38cf56866da6464eccfa0fb99fd6792c6c03ffc2dfebe4fd89e5465f0cf", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_WRITEONLY_INCREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_WRITEONLY_REQUIRED_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class WriteOnlyBCTest {\n  private final String BASE = \"bc_writeonly_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_writeonly_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void responseWriteOnlyIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_WRITEONLY_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_writeonly_increased.yaml\", prop);\n  }\n\n  @Test\n  public void responseWriteOnlyRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_WRITEONLY_REQUIRED_DECREASED;\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertSpecIncompatible(BASE, \"bc_response_writeonly_required_decreased.yaml\", prop);\n  }\n}", "definition": "public class WriteOnlyBCTest", "class_docstring": "", "name": "WriteOnlyBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_writeonly_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_writeonly_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_writeonly_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_writeonly_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseWriteOnlyIncreased() {\n    BackwardIncompatibleProp prop = RESPONSE_WRITEONLY_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_writeonly_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseWriteOnlyIncreased", "params": [], "body": "                                           {\n    BackwardIncompatibleProp prop = RESPONSE_WRITEONLY_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_response_writeonly_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseWriteOnlyIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseWriteOnlyRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_WRITEONLY_REQUIRED_DECREASED;\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertSpecIncompatible(BASE, \"bc_response_writeonly_required_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseWriteOnlyRequiredDecreased", "params": [], "body": "                                                   {\n    BackwardIncompatibleProp prop = RESPONSE_WRITEONLY_REQUIRED_DECREASED;\n    // TODO: Document why desired or remove support (test added to avoid unintentional regression)\n    assertSpecIncompatible(BASE, \"bc_response_writeonly_required_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseWriteOnlyRequiredDecreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/OpenApiBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class OpenApiBCTest {\n  private final String BASE = \"bc_openapi_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_openapi_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void endpointsDecreased() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_openapi_endpoints_decreased.yaml\", prop);\n  }\n}\n", "file_hash": "5c8991501963b5485814fcb9d39ebb98ce5ec03305a0021c94e72fa1b9f1a9b9", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class OpenApiBCTest {\n  private final String BASE = \"bc_openapi_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_openapi_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void endpointsDecreased() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_openapi_endpoints_decreased.yaml\", prop);\n  }\n}", "definition": "public class OpenApiBCTest", "class_docstring": "", "name": "OpenApiBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_openapi_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_openapi_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_openapi_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_openapi_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void endpointsDecreased() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_openapi_endpoints_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "endpointsDecreased", "params": [], "body": "                                   {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_openapi_endpoints_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void endpointsDecreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/ParameterBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_REQUIRED_INCREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAM_ALLOWEMPTY_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAM_EXPLODE_CHANGED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAM_STYLE_CHANGED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class ParameterBCTest {\n  private final String BASE = \"bc_request_param_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_request_param_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void allowEmptyValueDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_ALLOWEMPTY_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_param_allowemptyvalue_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void explodeChanged() {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_EXPLODE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_request_param_explode_changed.yaml\", prop);\n  }\n\n  @Test\n  public void requiredIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_param_required_increased.yaml\", prop);\n  }\n\n  @Test\n  public void styleChanged() {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_STYLE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_request_param_style_changed.yaml\", prop);\n  }\n}\n", "file_hash": "038523257c027a9d7eca61d5f22f321915b94e7215d7afa6b58022c7cca5b0ab", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_REQUIRED_INCREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAM_ALLOWEMPTY_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAM_EXPLODE_CHANGED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAM_STYLE_CHANGED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class ParameterBCTest {\n  private final String BASE = \"bc_request_param_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_request_param_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void allowEmptyValueDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_ALLOWEMPTY_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_param_allowemptyvalue_decreased.yaml\", prop);\n  }\n\n  @Test\n  public void explodeChanged() {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_EXPLODE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_request_param_explode_changed.yaml\", prop);\n  }\n\n  @Test\n  public void requiredIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_param_required_increased.yaml\", prop);\n  }\n\n  @Test\n  public void styleChanged() {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_STYLE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_request_param_style_changed.yaml\", prop);\n  }\n}", "definition": "public class ParameterBCTest", "class_docstring": "", "name": "ParameterBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_request_param_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_request_param_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_request_param_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_request_param_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void allowEmptyValueDecreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_ALLOWEMPTY_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_param_allowemptyvalue_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "allowEmptyValueDecreased", "params": [], "body": "                                         {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_ALLOWEMPTY_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_request_param_allowemptyvalue_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void allowEmptyValueDecreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void explodeChanged() {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_EXPLODE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_request_param_explode_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "explodeChanged", "params": [], "body": "                               {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_EXPLODE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_request_param_explode_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void explodeChanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requiredIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_param_required_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requiredIncreased", "params": [], "body": "                                  {\n    BackwardIncompatibleProp prop = REQUEST_PARAMS_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_param_required_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void requiredIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void styleChanged() {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_STYLE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_request_param_style_changed.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "styleChanged", "params": [], "body": "                             {\n    BackwardIncompatibleProp prop = REQUEST_PARAM_STYLE_CHANGED;\n    assertSpecIncompatible(BASE, \"bc_request_param_style_changed.yaml\", prop);\n  }", "signature": "@Test\n  public void styleChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/SecurityRequirementsBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.*;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_REQUIREMENTS_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class SecurityRequirementsBCTest {\n  private final String BASE = \"bc_security_requirements_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_security_requirements_changed_but_compatible.yaml\");\n  }\n\n  // TODO: Dropping *all* security requirements should be compatible. Refactor or document\n  // reasoning. Context: OAS spec is clear that only one of the security requirement objects\n  // need to be satisfied so it makes sense why dropping one could break a client that may\n  // not yet support one of the remaining referenced security schemes. But dropping all\n  // requirements should be compatible.\n  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = SECURITY_REQUIREMENTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_security_requirements_decreased.yaml\", prop);\n  }\n\n  // TODO: A missing incompatible check seems to be if requirements increase from zero to 1 or more\n\n  @Test\n  public void schemeTypeChanged() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_requirements_scheme_type_changed.yaml\");\n  }\n}\n", "file_hash": "1f0c538b304f112b34613a92485d9a3c55aacc5614c77cac22b110be4a6433ba", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.*;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_REQUIREMENTS_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class SecurityRequirementsBCTest {\n  private final String BASE = \"bc_security_requirements_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_security_requirements_changed_but_compatible.yaml\");\n  }\n\n  // TODO: Dropping *all* security requirements should be compatible. Refactor or document\n  // reasoning. Context: OAS spec is clear that only one of the security requirement objects\n  // need to be satisfied so it makes sense why dropping one could break a client that may\n  // not yet support one of the remaining referenced security schemes. But dropping all\n  // requirements should be compatible.\n  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = SECURITY_REQUIREMENTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_security_requirements_decreased.yaml\", prop);\n  }\n\n  // TODO: A missing incompatible check seems to be if requirements increase from zero to 1 or more\n\n  @Test\n  public void schemeTypeChanged() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_requirements_scheme_type_changed.yaml\");\n  }\n}", "definition": "public class SecurityRequirementsBCTest", "class_docstring": "", "name": "SecurityRequirementsBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_security_requirements_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_security_requirements_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_security_requirements_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_security_requirements_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void decreased() {\n    BackwardIncompatibleProp prop = SECURITY_REQUIREMENTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_security_requirements_decreased.yaml\", prop);\n  }", "docstring": " requirements should be compatible.", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "decreased", "params": [], "body": "                          {\n    BackwardIncompatibleProp prop = SECURITY_REQUIREMENTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_security_requirements_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void decreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void schemeTypeChanged() {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_requirements_scheme_type_changed.yaml\");\n  }", "docstring": " TODO: A missing incompatible check seems to be if requirements increase from zero to 1 or more", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "schemeTypeChanged", "params": [], "body": "                                  {\n    assertOpenApiBackwardIncompatible(BASE, \"bc_security_requirements_scheme_type_changed.yaml\");\n  }", "signature": "@Test\n  public void schemeTypeChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/RequiredBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_REQUIRED_INCREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_REQUIRED_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class RequiredBCTest {\n\n  private final String BASE = \"bc_required_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_required_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestRequiredIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_required_increased.yaml\", prop);\n  }\n\n  @Test\n  public void responseRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_required_decreased.yaml\", prop);\n  }\n}\n", "file_hash": "623bc4078e3eaef30a41f530e61501c65a82a5bbafabd2605a9552d6714e0d40", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_REQUIRED_INCREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_REQUIRED_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class RequiredBCTest {\n\n  private final String BASE = \"bc_required_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_required_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void requestRequiredIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_required_increased.yaml\", prop);\n  }\n\n  @Test\n  public void responseRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_required_decreased.yaml\", prop);\n  }\n}", "definition": "public class RequiredBCTest", "class_docstring": "", "name": "RequiredBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_required_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_required_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_required_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_required_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void requestRequiredIncreased() {\n    BackwardIncompatibleProp prop = REQUEST_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_required_increased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "requestRequiredIncreased", "params": [], "body": "                                         {\n    BackwardIncompatibleProp prop = REQUEST_REQUIRED_INCREASED;\n    assertSpecIncompatible(BASE, \"bc_request_required_increased.yaml\", prop);\n  }", "signature": "@Test\n  public void requestRequiredIncreased()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void responseRequiredDecreased() {\n    BackwardIncompatibleProp prop = RESPONSE_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_required_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "responseRequiredDecreased", "params": [], "body": "                                          {\n    BackwardIncompatibleProp prop = RESPONSE_REQUIRED_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_response_required_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void responseRequiredDecreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/openapitools/openapidiff/core/backcompat/PathBCTest.java", "original_string": "package org.openapitools.openapidiff.core.backcompat;\n\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;\nimport static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;\n\nimport org.junit.jupiter.api.Test;\nimport org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;\n\npublic class PathBCTest {\n  private final String BASE = \"bc_path_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_path_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void opsDecreased() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_path_ops_decreased.yaml\", prop);\n  }\n}\n", "file_hash": "a87f58fb1795c7bf753d18778f92f18d18d7a5afc9e7da08933c8d3edfdf3e45", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.backcompat;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecChangedButCompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecIncompatible;", "import static org.openapitools.openapidiff.core.TestUtils.assertSpecUnchanged;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;", "import org.junit.jupiter.api.Test;", "import org.openapitools.openapidiff.core.model.BackwardIncompatibleProp;"], "methods": [], "classes": [{"original_string": "public class PathBCTest {\n  private final String BASE = \"bc_path_base.yaml\";\n\n  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }\n\n  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_path_changed_but_compatible.yaml\");\n  }\n\n  @Test\n  public void opsDecreased() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_path_ops_decreased.yaml\", prop);\n  }\n}", "definition": "public class PathBCTest", "class_docstring": "", "name": "PathBCTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String BASE = \"bc_path_base.yaml\";", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "BASE = \"bc_path_base.yaml\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Test\n  public void unchanged() {\n    assertSpecUnchanged(BASE, BASE);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "unchanged", "params": [], "body": "                          {\n    assertSpecUnchanged(BASE, BASE);\n  }", "signature": "@Test\n  public void unchanged()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void changedButCompatible() {\n    assertSpecChangedButCompatible(BASE, \"bc_path_changed_but_compatible.yaml\");\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "changedButCompatible", "params": [], "body": "                                     {\n    assertSpecChangedButCompatible(BASE, \"bc_path_changed_but_compatible.yaml\");\n  }", "signature": "@Test\n  public void changedButCompatible()"}, {"syntax_pass": true, "original_string": "  @Test\n  public void opsDecreased() {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_path_ops_decreased.yaml\", prop);\n  }", "docstring": "", "attributes": {"modifiers": "@Test\n  public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "opsDecreased", "params": [], "body": "                             {\n    BackwardIncompatibleProp prop = OPENAPI_ENDPOINTS_DECREASED;\n    assertSpecIncompatible(BASE, \"bc_path_ops_decreased.yaml\", prop);\n  }", "signature": "@Test\n  public void opsDecreased()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/OpenApiCompare.java", "original_string": "package org.openapitools.openapidiff.core;\n\nimport io.swagger.parser.OpenAPIParser;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.parser.core.models.AuthorizationValue;\nimport io.swagger.v3.parser.core.models.ParseOptions;\nimport java.io.File;\nimport java.util.List;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiff;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\n\npublic class OpenApiCompare {\n  private static final OpenAPIParser PARSER = new OpenAPIParser();\n  private static final ParseOptions OPTIONS = new ParseOptions();\n\n  static {\n    OPTIONS.setResolve(true);\n  }\n\n  private OpenApiCompare() {}\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldContent old api-doc location:Json or Http\n   * @param newContent new api-doc location:Json or Http\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromContents(String oldContent, String newContent) {\n    return fromContents(oldContent, newContent, null);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldContent old api-doc location:Json or Http\n   * @param newContent new api-doc location:Json or Http\n   * @param auths\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromContents(\n      String oldContent, String newContent, List<AuthorizationValue> auths) {\n    return fromContents(oldContent, newContent, auths, OpenApiDiffOptions.builder().build());\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldContent old api-doc location:Json or Http\n   * @param newContent new api-doc location:Json or Http\n   * @param auths\n   * @param options\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromContents(\n      String oldContent,\n      String newContent,\n      List<AuthorizationValue> auths,\n      OpenApiDiffOptions options) {\n    return fromSpecifications(\n        readContent(oldContent, auths), readContent(newContent, auths), options);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldFile old api-doc file\n   * @param newFile new api-doc file\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromFiles(File oldFile, File newFile) {\n    return fromFiles(oldFile, newFile, null);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldFile old api-doc file\n   * @param newFile new api-doc file\n   * @param auths\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromFiles(\n      File oldFile, File newFile, List<AuthorizationValue> auths) {\n    return fromFiles(oldFile, newFile, auths, OpenApiDiffOptions.builder().build());\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldFile old api-doc file\n   * @param newFile new api-doc file\n   * @param auths\n   * @param options\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromFiles(\n      File oldFile, File newFile, List<AuthorizationValue> auths, OpenApiDiffOptions options) {\n    return fromLocations(oldFile.getAbsolutePath(), newFile.getAbsolutePath(), auths, options);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldLocation old api-doc location (local or http)\n   * @param newLocation new api-doc location (local or http)\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromLocations(String oldLocation, String newLocation) {\n    return fromLocations(oldLocation, newLocation, null);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldLocation old api-doc location (local or http)\n   * @param newLocation new api-doc location (local or http)\n   * @param auths\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromLocations(\n      String oldLocation, String newLocation, List<AuthorizationValue> auths) {\n    return fromLocations(oldLocation, newLocation, auths, OpenApiDiffOptions.builder().build());\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldLocation old api-doc location (local or http)\n   * @param newLocation new api-doc location (local or http)\n   * @param auths\n   * @param options\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromLocations(\n      String oldLocation,\n      String newLocation,\n      List<AuthorizationValue> auths,\n      OpenApiDiffOptions options) {\n    return fromSpecifications(\n        readLocation(oldLocation, auths), readLocation(newLocation, auths), options);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldSpec old api-doc specification\n   * @param newSpec new api-doc specification\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromSpecifications(OpenAPI oldSpec, OpenAPI newSpec) {\n    return fromSpecifications(oldSpec, newSpec, OpenApiDiffOptions.builder().build());\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldSpec old api-doc specification\n   * @param newSpec new api-doc specification\n   * @param options\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromSpecifications(\n      OpenAPI oldSpec, OpenAPI newSpec, OpenApiDiffOptions options) {\n    return OpenApiDiff.compare(notNull(oldSpec, \"old\"), notNull(newSpec, \"new\"), options);\n  }\n\n  private static OpenAPI notNull(OpenAPI spec, String type) {\n    if (spec == null) {\n      throw new RuntimeException(String.format(\"Cannot read %s OpenAPI spec\", type));\n    }\n    return spec;\n  }\n\n  private static OpenAPI readContent(String content, List<AuthorizationValue> auths) {\n    return PARSER.readContents(content, auths, OPTIONS).getOpenAPI();\n  }\n\n  private static OpenAPI readLocation(String location, List<AuthorizationValue> auths) {\n    return PARSER.readLocation(location, auths, OPTIONS).getOpenAPI();\n  }\n}\n", "file_hash": "6a5a8bb0edd71d37e0131241810f299b96cfd1682acb5716c52f56f27d5cd29d", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core;", "import io.swagger.parser.OpenAPIParser;", "import io.swagger.v3.oas.models.OpenAPI;", "import io.swagger.v3.parser.core.models.AuthorizationValue;", "import io.swagger.v3.parser.core.models.ParseOptions;", "import java.io.File;", "import java.util.List;", "import org.openapitools.openapidiff.core.compare.OpenApiDiff;", "import org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;"], "methods": [], "classes": [{"original_string": "public class OpenApiCompare {\n  private static final OpenAPIParser PARSER = new OpenAPIParser();\n  private static final ParseOptions OPTIONS = new ParseOptions();\n\n  static {\n    OPTIONS.setResolve(true);\n  }\n\n  private OpenApiCompare() {}\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldContent old api-doc location:Json or Http\n   * @param newContent new api-doc location:Json or Http\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromContents(String oldContent, String newContent) {\n    return fromContents(oldContent, newContent, null);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldContent old api-doc location:Json or Http\n   * @param newContent new api-doc location:Json or Http\n   * @param auths\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromContents(\n      String oldContent, String newContent, List<AuthorizationValue> auths) {\n    return fromContents(oldContent, newContent, auths, OpenApiDiffOptions.builder().build());\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldContent old api-doc location:Json or Http\n   * @param newContent new api-doc location:Json or Http\n   * @param auths\n   * @param options\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromContents(\n      String oldContent,\n      String newContent,\n      List<AuthorizationValue> auths,\n      OpenApiDiffOptions options) {\n    return fromSpecifications(\n        readContent(oldContent, auths), readContent(newContent, auths), options);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldFile old api-doc file\n   * @param newFile new api-doc file\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromFiles(File oldFile, File newFile) {\n    return fromFiles(oldFile, newFile, null);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldFile old api-doc file\n   * @param newFile new api-doc file\n   * @param auths\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromFiles(\n      File oldFile, File newFile, List<AuthorizationValue> auths) {\n    return fromFiles(oldFile, newFile, auths, OpenApiDiffOptions.builder().build());\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldFile old api-doc file\n   * @param newFile new api-doc file\n   * @param auths\n   * @param options\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromFiles(\n      File oldFile, File newFile, List<AuthorizationValue> auths, OpenApiDiffOptions options) {\n    return fromLocations(oldFile.getAbsolutePath(), newFile.getAbsolutePath(), auths, options);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldLocation old api-doc location (local or http)\n   * @param newLocation new api-doc location (local or http)\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromLocations(String oldLocation, String newLocation) {\n    return fromLocations(oldLocation, newLocation, null);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldLocation old api-doc location (local or http)\n   * @param newLocation new api-doc location (local or http)\n   * @param auths\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromLocations(\n      String oldLocation, String newLocation, List<AuthorizationValue> auths) {\n    return fromLocations(oldLocation, newLocation, auths, OpenApiDiffOptions.builder().build());\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldLocation old api-doc location (local or http)\n   * @param newLocation new api-doc location (local or http)\n   * @param auths\n   * @param options\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromLocations(\n      String oldLocation,\n      String newLocation,\n      List<AuthorizationValue> auths,\n      OpenApiDiffOptions options) {\n    return fromSpecifications(\n        readLocation(oldLocation, auths), readLocation(newLocation, auths), options);\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldSpec old api-doc specification\n   * @param newSpec new api-doc specification\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromSpecifications(OpenAPI oldSpec, OpenAPI newSpec) {\n    return fromSpecifications(oldSpec, newSpec, OpenApiDiffOptions.builder().build());\n  }\n\n  /**\n   * compare two openapi doc\n   *\n   * @param oldSpec old api-doc specification\n   * @param newSpec new api-doc specification\n   * @param options\n   * @return Comparison result\n   */\n  public static ChangedOpenApi fromSpecifications(\n      OpenAPI oldSpec, OpenAPI newSpec, OpenApiDiffOptions options) {\n    return OpenApiDiff.compare(notNull(oldSpec, \"old\"), notNull(newSpec, \"new\"), options);\n  }\n\n  private static OpenAPI notNull(OpenAPI spec, String type) {\n    if (spec == null) {\n      throw new RuntimeException(String.format(\"Cannot read %s OpenAPI spec\", type));\n    }\n    return spec;\n  }\n\n  private static OpenAPI readContent(String content, List<AuthorizationValue> auths) {\n    return PARSER.readContents(content, auths, OPTIONS).getOpenAPI();\n  }\n\n  private static OpenAPI readLocation(String location, List<AuthorizationValue> auths) {\n    return PARSER.readLocation(location, auths, OPTIONS).getOpenAPI();\n  }\n}", "definition": "public class OpenApiCompare", "class_docstring": "", "name": "OpenApiCompare", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final OpenAPIParser PARSER = new OpenAPIParser();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "OpenAPIParser", "name": "PARSER = new OpenAPIParser()", "syntax_pass": true}, {"attribute_expression": "private static final ParseOptions OPTIONS = new ParseOptions();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ParseOptions", "name": "OPTIONS = new ParseOptions()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private OpenApiCompare() {}", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "OpenApiCompare", "params": [], "body": "                           {}", "signature": "private OpenApiCompare()"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromContents(String oldContent, String newContent) {\n    return fromContents(oldContent, newContent, null);\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldContent old api-doc location:Json or Http\n@param newContent new api-doc location:Json or Http\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromContents", "params": [{"name": "oldContent", "type": "String"}, {"name": "newContent", "type": "String"}], "body": "                                                                                  {\n    return fromContents(oldContent, newContent, null);\n  }", "signature": "public static ChangedOpenApi fromContents(String oldContent, String newContent)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromContents(\n      String oldContent, String newContent, List<AuthorizationValue> auths) {\n    return fromContents(oldContent, newContent, auths, OpenApiDiffOptions.builder().build());\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldContent old api-doc location:Json or Http\n@param newContent new api-doc location:Json or Http\n@param auths\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromContents", "params": [{"name": "oldContent", "type": "String"}, {"name": "newContent", "type": "String"}, {"name": "auths", "type": "List<AuthorizationValue>"}], "body": "                                                                            {\n    return fromContents(oldContent, newContent, auths, OpenApiDiffOptions.builder().build());\n  }", "signature": "public static ChangedOpenApi fromContents(\n      String oldContent, String newContent, List<AuthorizationValue> auths)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromContents(\n      String oldContent,\n      String newContent,\n      List<AuthorizationValue> auths,\n      OpenApiDiffOptions options) {\n    return fromSpecifications(\n        readContent(oldContent, auths), readContent(newContent, auths), options);\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldContent old api-doc location:Json or Http\n@param newContent new api-doc location:Json or Http\n@param auths\n@param options\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromContents", "params": [{"name": "oldContent", "type": "String"}, {"name": "newContent", "type": "String"}, {"name": "auths", "type": "List<AuthorizationValue>"}, {"name": "options", "type": "OpenApiDiffOptions"}], "body": "                                  {\n    return fromSpecifications(\n        readContent(oldContent, auths), readContent(newContent, auths), options);\n  }", "signature": "public static ChangedOpenApi fromContents(\n      String oldContent,\n      String newContent,\n      List<AuthorizationValue> auths,\n      OpenApiDiffOptions options)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromFiles(File oldFile, File newFile) {\n    return fromFiles(oldFile, newFile, null);\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldFile old api-doc file\n@param newFile new api-doc file\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromFiles", "params": [{"name": "oldFile", "type": "File"}, {"name": "newFile", "type": "File"}], "body": "                                                                     {\n    return fromFiles(oldFile, newFile, null);\n  }", "signature": "public static ChangedOpenApi fromFiles(File oldFile, File newFile)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromFiles(\n      File oldFile, File newFile, List<AuthorizationValue> auths) {\n    return fromFiles(oldFile, newFile, auths, OpenApiDiffOptions.builder().build());\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldFile old api-doc file\n@param newFile new api-doc file\n@param auths\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromFiles", "params": [{"name": "oldFile", "type": "File"}, {"name": "newFile", "type": "File"}, {"name": "auths", "type": "List<AuthorizationValue>"}], "body": "                                                                  {\n    return fromFiles(oldFile, newFile, auths, OpenApiDiffOptions.builder().build());\n  }", "signature": "public static ChangedOpenApi fromFiles(\n      File oldFile, File newFile, List<AuthorizationValue> auths)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromFiles(\n      File oldFile, File newFile, List<AuthorizationValue> auths, OpenApiDiffOptions options) {\n    return fromLocations(oldFile.getAbsolutePath(), newFile.getAbsolutePath(), auths, options);\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldFile old api-doc file\n@param newFile new api-doc file\n@param auths\n@param options\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromFiles", "params": [{"name": "oldFile", "type": "File"}, {"name": "newFile", "type": "File"}, {"name": "auths", "type": "List<AuthorizationValue>"}, {"name": "options", "type": "OpenApiDiffOptions"}], "body": "                                                                                              {\n    return fromLocations(oldFile.getAbsolutePath(), newFile.getAbsolutePath(), auths, options);\n  }", "signature": "public static ChangedOpenApi fromFiles(\n      File oldFile, File newFile, List<AuthorizationValue> auths, OpenApiDiffOptions options)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromLocations(String oldLocation, String newLocation) {\n    return fromLocations(oldLocation, newLocation, null);\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldLocation old api-doc location (local or http)\n@param newLocation new api-doc location (local or http)\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromLocations", "params": [{"name": "oldLocation", "type": "String"}, {"name": "newLocation", "type": "String"}], "body": "                                                                                     {\n    return fromLocations(oldLocation, newLocation, null);\n  }", "signature": "public static ChangedOpenApi fromLocations(String oldLocation, String newLocation)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromLocations(\n      String oldLocation, String newLocation, List<AuthorizationValue> auths) {\n    return fromLocations(oldLocation, newLocation, auths, OpenApiDiffOptions.builder().build());\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldLocation old api-doc location (local or http)\n@param newLocation new api-doc location (local or http)\n@param auths\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromLocations", "params": [{"name": "oldLocation", "type": "String"}, {"name": "newLocation", "type": "String"}, {"name": "auths", "type": "List<AuthorizationValue>"}], "body": "                                                                              {\n    return fromLocations(oldLocation, newLocation, auths, OpenApiDiffOptions.builder().build());\n  }", "signature": "public static ChangedOpenApi fromLocations(\n      String oldLocation, String newLocation, List<AuthorizationValue> auths)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromLocations(\n      String oldLocation,\n      String newLocation,\n      List<AuthorizationValue> auths,\n      OpenApiDiffOptions options) {\n    return fromSpecifications(\n        readLocation(oldLocation, auths), readLocation(newLocation, auths), options);\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldLocation old api-doc location (local or http)\n@param newLocation new api-doc location (local or http)\n@param auths\n@param options\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromLocations", "params": [{"name": "oldLocation", "type": "String"}, {"name": "newLocation", "type": "String"}, {"name": "auths", "type": "List<AuthorizationValue>"}, {"name": "options", "type": "OpenApiDiffOptions"}], "body": "                                  {\n    return fromSpecifications(\n        readLocation(oldLocation, auths), readLocation(newLocation, auths), options);\n  }", "signature": "public static ChangedOpenApi fromLocations(\n      String oldLocation,\n      String newLocation,\n      List<AuthorizationValue> auths,\n      OpenApiDiffOptions options)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromSpecifications(OpenAPI oldSpec, OpenAPI newSpec) {\n    return fromSpecifications(oldSpec, newSpec, OpenApiDiffOptions.builder().build());\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldSpec old api-doc specification\n@param newSpec new api-doc specification\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromSpecifications", "params": [{"name": "oldSpec", "type": "OpenAPI"}, {"name": "newSpec", "type": "OpenAPI"}], "body": "                                                                                    {\n    return fromSpecifications(oldSpec, newSpec, OpenApiDiffOptions.builder().build());\n  }", "signature": "public static ChangedOpenApi fromSpecifications(OpenAPI oldSpec, OpenAPI newSpec)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi fromSpecifications(\n      OpenAPI oldSpec, OpenAPI newSpec, OpenApiDiffOptions options) {\n    return OpenApiDiff.compare(notNull(oldSpec, \"old\"), notNull(newSpec, \"new\"), options);\n  }", "docstring": "\ncompare two openapi doc\n\n@param oldSpec old api-doc specification\n@param newSpec new api-doc specification\n@param options\n@return Comparison result\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "fromSpecifications", "params": [{"name": "oldSpec", "type": "OpenAPI"}, {"name": "newSpec", "type": "OpenAPI"}, {"name": "options", "type": "OpenApiDiffOptions"}], "body": "                                                                    {\n    return OpenApiDiff.compare(notNull(oldSpec, \"old\"), notNull(newSpec, \"new\"), options);\n  }", "signature": "public static ChangedOpenApi fromSpecifications(\n      OpenAPI oldSpec, OpenAPI newSpec, OpenApiDiffOptions options)"}, {"syntax_pass": true, "original_string": "  private static OpenAPI notNull(OpenAPI spec, String type) {\n    if (spec == null) {\n      throw new RuntimeException(String.format(\"Cannot read %s OpenAPI spec\", type));\n    }\n    return spec;\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "OpenAPI", "classes": []}, "name": "notNull", "params": [{"name": "spec", "type": "OpenAPI"}, {"name": "type", "type": "String"}], "body": "                                                            {\n    if (spec == null) {\n      throw new RuntimeException(String.format(\"Cannot read %s OpenAPI spec\", type));\n    }\n    return spec;\n  }", "signature": "private static OpenAPI notNull(OpenAPI spec, String type)"}, {"syntax_pass": true, "original_string": "  private static OpenAPI readContent(String content, List<AuthorizationValue> auths) {\n    return PARSER.readContents(content, auths, OPTIONS).getOpenAPI();\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "OpenAPI", "classes": []}, "name": "readContent", "params": [{"name": "content", "type": "String"}, {"name": "auths", "type": "List<AuthorizationValue>"}], "body": "                                                                                     {\n    return PARSER.readContents(content, auths, OPTIONS).getOpenAPI();\n  }", "signature": "private static OpenAPI readContent(String content, List<AuthorizationValue> auths)"}, {"syntax_pass": true, "original_string": "  private static OpenAPI readLocation(String location, List<AuthorizationValue> auths) {\n    return PARSER.readLocation(location, auths, OPTIONS).getOpenAPI();\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "OpenAPI", "classes": []}, "name": "readLocation", "params": [{"name": "location", "type": "String"}, {"name": "auths", "type": "List<AuthorizationValue>"}], "body": "                                                                                       {\n    return PARSER.readLocation(location, auths, OPTIONS).getOpenAPI();\n  }", "signature": "private static OpenAPI readLocation(String location, List<AuthorizationValue> auths)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/output/MarkdownRender.java", "original_string": "package org.openapitools.openapidiff.core.output;\n\nimport static java.lang.String.format;\nimport static org.openapitools.openapidiff.core.model.Changed.result;\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isUnchanged;\n\nimport io.swagger.v3.oas.models.headers.Header;\nimport io.swagger.v3.oas.models.media.ArraySchema;\nimport io.swagger.v3.oas.models.media.ComposedSchema;\nimport io.swagger.v3.oas.models.media.MediaType;\nimport io.swagger.v3.oas.models.media.Schema;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.commons.lang3.StringUtils;\nimport org.openapitools.openapidiff.core.exception.RendererException;\nimport org.openapitools.openapidiff.core.model.*;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class MarkdownRender implements Render {\n  private static final Logger LOGGER = LoggerFactory.getLogger(MarkdownRender.class);\n  private static final String H3 = \"### \";\n  private static final String H4 = \"#### \";\n  private static final String H5 = \"##### \";\n  private static final String H6 = \"###### \";\n  private static final String BLOCKQUOTE = \"> \";\n  private static final String CODE = \"`\";\n  private static final String PRE_CODE = \"    \";\n  private static final String PRE_LI = \"    \";\n  private static final String LI = \"* \";\n  private static final String HR = \"---\\n\";\n\n  protected RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  protected ChangedOpenApi diff;\n  protected Set<Schema<?>> handledSchemas = new HashSet<>();\n  /**\n   * A parameter which indicates whether or not metadata (summary and metadata) changes should be\n   * logged in the changelog file.\n   */\n  protected boolean showChangedMetadata;\n\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n    this.handledSchemas.clear();\n    listEndpoints(\"What's New\", diff.getNewEndpoints(), outputStreamWriter);\n    listEndpoints(\"What's Deleted\", diff.getMissingEndpoints(), outputStreamWriter);\n    listEndpoints(\"What's Deprecated\", diff.getDeprecatedEndpoints(), outputStreamWriter);\n    listEndpoints(diff.getChangedOperations(), outputStreamWriter);\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }\n\n  protected String sectionTitle(String title) {\n    return H4 + title + '\\n' + HR + '\\n';\n  }\n\n  protected void listEndpoints(\n      String title, List<Endpoint> endpoints, OutputStreamWriter outputStreamWriter) {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, sectionTitle(title));\n    endpoints.stream()\n        .map(e -> itemEndpoint(e.getMethod().toString(), e.getPathUrl(), e.getSummary()))\n        .forEach(csq -> safelyAppend(outputStreamWriter, csq));\n  }\n\n  protected String itemEndpoint(String method, String path, String summary) {\n    return H5 + CODE + method + CODE + \" \" + path + \"\\n\\n\" + metadata(summary) + \"\\n\";\n  }\n\n  protected String itemEndpoint(String method, String path, ChangedMetadata summary) {\n    return H5 + CODE + method + CODE + \" \" + path + \"\\n\\n\" + metadata(\"summary\", summary) + \"\\n\";\n  }\n\n  protected String titleH5(String title) {\n    return H6 + title + '\\n';\n  }\n\n  protected void listEndpoints(\n      List<ChangedOperation> changedOperations, OutputStreamWriter outputStreamWriter) {\n    if (null == changedOperations || changedOperations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, sectionTitle(\"What's Changed\"));\n    changedOperations.forEach(\n        operation -> {\n          safelyAppend(\n              outputStreamWriter,\n              itemEndpoint(\n                  operation.getHttpMethod().toString(),\n                  operation.getPathUrl(),\n                  operation.getSummary()));\n          if (result(operation.getParameters()).isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Parameters:\"));\n            safelyAppend(outputStreamWriter, parameters(operation.getParameters()));\n          }\n          if (operation.resultRequestBody().isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Request:\"));\n            safelyAppend(\n                outputStreamWriter,\n                metadata(\"Description\", operation.getRequestBody().getDescription()));\n            safelyAppend(outputStreamWriter, bodyContent(operation.getRequestBody().getContent()));\n          }\n          if (operation.resultApiResponses().isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Return Type:\"));\n            safelyAppend(outputStreamWriter, responses(operation.getApiResponses()));\n          }\n        });\n  }\n\n  protected String responses(ChangedApiResponse changedApiResponse) {\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listResponse(\"New response\", changedApiResponse.getIncreased()));\n    sb.append(listResponse(\"Deleted response\", changedApiResponse.getMissing()));\n    changedApiResponse.getChanged().entrySet().stream()\n        .map(e -> this.itemResponse(e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String listResponse(String title, Map<String, ApiResponse> responses) {\n    StringBuilder sb = new StringBuilder();\n    responses.entrySet().stream()\n        .map(e -> this.itemResponse(title, e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String itemResponse(String title, String code, ApiResponse response) {\n    return this.itemResponse(title, code, response.getDescription());\n  }\n\n  protected String itemResponse(String code, ChangedResponse response) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\n        this.itemResponse(\n            \"Changed response\",\n            code,\n            null == response.getNewApiResponse()\n                ? \"\"\n                : response.getNewApiResponse().getDescription()));\n    sb.append(headers(response.getHeaders()));\n    if (response.getContent() != null) {\n      sb.append(this.bodyContent(LI, response.getContent()));\n    }\n    return sb.toString();\n  }\n\n  protected String itemResponse(String title, String code, String description) {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(format(\"%s : **%s %s**\\n\", title, code, status));\n    sb.append(metadata(description));\n    return sb.toString();\n  }\n\n  protected String headers(ChangedHeaders headers) {\n    StringBuilder sb = new StringBuilder();\n    if (headers != null) {\n      sb.append(listHeader(\"New header\", headers.getIncreased()))\n          .append(listHeader(\"Deleted header\", headers.getMissing()));\n      headers.getChanged().entrySet().stream()\n          .map(e -> this.itemHeader(e.getKey(), e.getValue()))\n          .forEach(sb::append);\n    }\n    return sb.toString();\n  }\n\n  protected String listHeader(String title, Map<String, Header> headers) {\n    StringBuilder sb = new StringBuilder();\n    headers.entrySet().stream()\n        .map(e -> this.itemHeader(title, e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String itemHeader(String title, String name, Header header) {\n    return this.itemHeader(title, name, header.getDescription());\n  }\n\n  protected String itemHeader(String code, ChangedHeader header) {\n    return this.itemHeader(\n        \"Changed header\",\n        code,\n        null == header.getNewHeader() ? \"\" : header.getNewHeader().getDescription());\n  }\n\n  protected String itemHeader(String title, String mediaType, String description) {\n    return format(\"%s : `%s`\\n\\n\", title, mediaType) + metadata(description) + '\\n';\n  }\n\n  protected String bodyContent(String prefix, ChangedContent changedContent) {\n    if (changedContent == null) {\n      return \"\";\n    }\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listContent(prefix, \"New content type\", changedContent.getIncreased()));\n    sb.append(listContent(prefix, \"Deleted content type\", changedContent.getMissing()));\n    final int deepness;\n    if (StringUtils.isNotBlank(prefix)) {\n      deepness = 1;\n    } else {\n      deepness = 0;\n    }\n    changedContent.getChanged().entrySet().stream()\n        .map(e -> this.itemContent(deepness, e.getKey(), e.getValue()))\n        .forEach(e -> sb.append(prefix).append(e));\n    return sb.toString();\n  }\n\n  protected String bodyContent(ChangedContent changedContent) {\n    return bodyContent(\"\", changedContent);\n  }\n\n  protected String listContent(String prefix, String title, Map<String, MediaType> mediaTypes) {\n    StringBuilder sb = new StringBuilder();\n    mediaTypes.entrySet().stream()\n        .map(e -> this.itemContent(title, e.getKey(), e.getValue()))\n        .forEach(e -> sb.append(prefix).append(e));\n    return sb.toString();\n  }\n\n  protected String itemContent(String title, String mediaType) {\n    return format(\"%s : `%s`\\n\\n\", title, mediaType);\n  }\n\n  protected String itemContent(String title, String mediaType, MediaType content) {\n    return itemContent(title, mediaType);\n  }\n\n  protected String itemContent(int deepness, String mediaType, ChangedMediaType content) {\n    return itemContent(\"Changed content type\", mediaType) + schema(deepness, content.getSchema());\n  }\n\n  protected String schema(ChangedSchema schema) {\n    return schema(1, schema);\n  }\n\n  protected String oneOfSchema(int deepness, ChangedOneOfSchema schema, String discriminator) {\n    StringBuilder sb = new StringBuilder();\n    schema\n        .getMissing()\n        .keySet()\n        .forEach(\n            key -> sb.append(format(\"%sDeleted '%s' %s\\n\", indent(deepness), key, discriminator)));\n    schema\n        .getIncreased()\n        .forEach(\n            (key, sub) ->\n                sb.append(format(\"%sAdded '%s' %s:\\n\", indent(deepness), key, discriminator))\n                    .append(schema(deepness, sub, schema.getContext())));\n    schema\n        .getChanged()\n        .forEach(\n            (key, sub) ->\n                sb.append(format(\"%sUpdated `%s` %s:\\n\", indent(deepness), key, discriminator))\n                    .append(schema(deepness, sub)));\n    return sb.toString();\n  }\n\n  protected String required(int deepness, String title, List<String> required) {\n    StringBuilder sb = new StringBuilder();\n    if (!required.isEmpty()) {\n      sb.append(format(\"%s%s:\\n\", indent(deepness), title));\n      required.forEach(s -> sb.append(format(\"%s- `%s`\\n\", indent(deepness), s)));\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }\n\n  protected String schema(int deepness, ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.isDiscriminatorPropertyChanged()) {\n      LOGGER.debug(\"Discriminator property changed\");\n    }\n    if (schema.getOneOfSchema() != null) {\n      String discriminator =\n          schema.getNewSchema().getDiscriminator() != null\n              ? schema.getNewSchema().getDiscriminator().getPropertyName()\n              : \"\";\n      sb.append(oneOfSchema(deepness, schema.getOneOfSchema(), discriminator));\n    }\n    if (schema.getRequired() != null) {\n      sb.append(required(deepness, \"New required properties\", schema.getRequired().getIncreased()));\n      sb.append(required(deepness, \"New optional properties\", schema.getRequired().getMissing()));\n    }\n    if (schema.getItems() != null) {\n      sb.append(items(deepness, schema.getItems()));\n    }\n    sb.append(listDiff(deepness, \"enum\", schema.getEnumeration()));\n    sb.append(\n        properties(\n            deepness,\n            \"Added property\",\n            schema.getIncreasedProperties(),\n            true,\n            schema.getContext()));\n    sb.append(\n        properties(\n            deepness,\n            \"Deleted property\",\n            schema.getMissingProperties(),\n            false,\n            schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(property(deepness, name, property)));\n    return sb.toString();\n  }\n\n  protected String schema(int deepness, ComposedSchema schema, DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getAllOf() != null) {\n      LOGGER.debug(\"All of schema\");\n      schema.getAllOf().stream()\n          .map(this::resolve)\n          .forEach(composedChild -> sb.append(schema(deepness, composedChild, context)));\n    }\n    if (schema.getOneOf() != null) {\n      LOGGER.debug(\"One of schema\");\n      sb.append(format(\"%sOne of:\\n\\n\", indent(deepness)));\n      schema.getOneOf().stream()\n          .map(this::resolve)\n          .forEach(composedChild -> sb.append(schema(deepness + 1, composedChild, context)));\n    }\n    return sb.toString();\n  }\n\n  protected String schema(int deepness, Schema schema, DiffContext context) {\n    if (handledSchemas.contains(schema)) return \"\";\n    handledSchemas.add(schema);\n    StringBuilder sb = new StringBuilder();\n    sb.append(listItem(deepness, \"Enum\", schema.getEnum()));\n    sb.append(properties(deepness, \"Property\", schema.getProperties(), true, context));\n    if (schema instanceof ComposedSchema) {\n      sb.append(schema(deepness, (ComposedSchema) schema, context));\n    } else if (schema instanceof ArraySchema) {\n      sb.append(items(deepness, resolve(((ArraySchema) schema).getItems()), context));\n    }\n    return sb.toString();\n  }\n\n  protected String items(int deepness, ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    String type = type(schema.getNewSchema());\n    if (schema.isChangedType()) {\n      type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n    }\n    sb.append(items(deepness, \"Changed items\", type, schema.getNewSchema().getDescription()));\n    sb.append(schema(deepness, schema));\n    return sb.toString();\n  }\n\n  protected String items(int deepness, Schema<?> schema, DiffContext context) {\n    return items(deepness, \"Items\", type(schema), schema.getDescription())\n        + schema(deepness, schema, context);\n  }\n\n  protected String items(int deepness, String title, String type, String description) {\n    return format(\n        \"%s%s (%s):\" + \"\\n%s\\n\",\n        indent(deepness), title, type, metadata(indent(deepness + 1), description));\n  }\n\n  protected String properties(\n      final int deepness,\n      String title,\n      Map<String, Schema<?>> properties,\n      boolean showContent,\n      DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach(\n          (key, value) -> {\n            sb.append(resolveProperty(deepness, value, key, title));\n            if (showContent) {\n              sb.append(schema(deepness + 1, resolve(value), context));\n            }\n          });\n    }\n    return sb.toString();\n  }\n\n  private String resolveProperty(int deepness, Schema<?> value, String key, String title) {\n    try {\n      return property(deepness, title, key, resolve(value));\n    } catch (Exception e) {\n      return property(deepness, title, key, type(value), \"\");\n    }\n  }\n\n  protected String property(int deepness, String name, ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    String type = type(schema.getNewSchema());\n    if (schema.isChangedType()) {\n      type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n    }\n    sb.append(\n        property(deepness, \"Changed property\", name, type, schema.getNewSchema().getDescription()));\n    sb.append(schema(++deepness, schema));\n    return sb.toString();\n  }\n\n  protected String property(int deepness, String title, String name, Schema<?> schema) {\n    return property(deepness, title, name, type(schema), schema.getDescription());\n  }\n\n  protected String property(\n      int deepness, String title, String name, String type, String description) {\n    return format(\n        \"%s* %s `%s` (%s)\\n%s\\n\",\n        indent(deepness), title, name, type, metadata(indent(deepness + 1), description));\n  }\n\n  protected String listDiff(int deepness, String name, ChangedList<?> listDiff) {\n    if (listDiff == null) {\n      return \"\";\n    }\n    return listItem(deepness, \"Added \" + name, listDiff.getIncreased())\n        + listItem(deepness, \"Removed \" + name, listDiff.getMissing());\n  }\n\n  protected <T> String listItem(int deepness, String name, List<T> list) {\n    StringBuilder sb = new StringBuilder();\n    if (list != null && !list.isEmpty()) {\n      sb.append(format(\"%s%s value%s:\\n\\n\", indent(deepness), name, list.size() > 1 ? \"s\" : \"\"));\n      list.forEach(p -> sb.append(format(\"%s* `%s`\\n\", indent(deepness), p)));\n    }\n    return sb.toString();\n  }\n\n  protected String parameters(ChangedParameters changedParameters) {\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listParameter(\"Added\", changedParameters.getIncreased()))\n        .append(listParameter(\"Deleted\", changedParameters.getMissing()));\n    changed.stream().map(this::itemParameter).forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String listParameter(String title, List<Parameter> parameters) {\n    StringBuilder sb = new StringBuilder();\n    parameters.stream().map(p -> itemParameter(title, p)).forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String itemParameter(String title, Parameter parameter) {\n    return this.itemParameter(\n        title, parameter.getName(), parameter.getIn(), parameter.getDescription());\n  }\n\n  protected String itemParameter(String title, String name, String in, String description) {\n    return format(\"%s: \", title)\n        + code(name)\n        + \" in \"\n        + code(in)\n        + '\\n'\n        + metadata(description)\n        + '\\n';\n  }\n\n  protected String itemParameter(ChangedParameter param) {\n    Parameter rightParam = param.getNewParameter();\n    if (param.isDeprecated()) {\n      return itemParameter(\n          \"Deprecated\", rightParam.getName(), rightParam.getIn(), rightParam.getDescription());\n    }\n    return itemParameter(\n        \"Changed\", rightParam.getName(), rightParam.getIn(), rightParam.getDescription());\n  }\n\n  protected String code(String string) {\n    return CODE + string + CODE;\n  }\n\n  protected String metadata(String name, ChangedMetadata changedMetadata) {\n    return metadata(\"\", name, changedMetadata);\n  }\n\n  protected String metadata(String beginning, String name, ChangedMetadata changedMetadata) {\n    if (changedMetadata == null) {\n      return \"\";\n    }\n    if (!isUnchanged(changedMetadata) && showChangedMetadata) {\n      return format(\n          \"Changed %s:\\n%s\\nto:\\n%s\\n\\n\",\n          name,\n          metadata(beginning, changedMetadata.getLeft()),\n          metadata(beginning, changedMetadata.getRight()));\n    } else {\n      return metadata(beginning, name, changedMetadata.getRight());\n    }\n  }\n\n  protected String metadata(String metadata) {\n    return metadata(\"\", metadata);\n  }\n\n  protected String metadata(String beginning, String name, String metadata) {\n    if (StringUtils.isBlank(metadata)) {\n      return \"\";\n    }\n    return blockquote(beginning, metadata);\n  }\n\n  protected String metadata(String beginning, String metadata) {\n    if (StringUtils.isBlank(metadata)) {\n      return \"\";\n    }\n    return blockquote(beginning, metadata);\n  }\n\n  protected String blockquote(String beginning) {\n    return beginning + BLOCKQUOTE;\n  }\n\n  protected String blockquote(String beginning, String text) {\n    String blockquote = blockquote(beginning);\n    return blockquote + text.trim().replace(\"\\n\", \"\\n\" + blockquote) + \"\\n\\n\";\n  }\n\n  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }\n\n  protected String indent(int deepness) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < deepness; i++) {\n      sb.append(PRE_LI);\n    }\n    return sb.toString();\n  }\n\n  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }\n\n  /**\n   * A parameter which indicates whether or not metadata (summary and metadata) changes should be\n   * logged in the changelog file.\n   */\n  public boolean isShowChangedMetadata() {\n    return this.showChangedMetadata;\n  }\n\n  /**\n   * A parameter which indicates whether or not metadata (summary and metadata) changes should be\n   * logged in the changelog file.\n   */\n  public void setShowChangedMetadata(final boolean showChangedMetadata) {\n    this.showChangedMetadata = showChangedMetadata;\n  }\n}\n", "file_hash": "aa28e85a5bab6b5b2b868884c02d7e599c3d707885a844cfcfc801cd9c1043c9", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.output;", "import static java.lang.String.format;", "import static org.openapitools.openapidiff.core.model.Changed.result;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isUnchanged;", "import io.swagger.v3.oas.models.headers.Header;", "import io.swagger.v3.oas.models.media.ArraySchema;", "import io.swagger.v3.oas.models.media.ComposedSchema;", "import io.swagger.v3.oas.models.media.MediaType;", "import io.swagger.v3.oas.models.media.Schema;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import java.io.IOException;", "import java.io.OutputStreamWriter;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import org.apache.commons.lang3.StringUtils;", "import org.openapitools.openapidiff.core.exception.RendererException;", "import org.openapitools.openapidiff.core.model.*;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;", "import org.slf4j.Logger;", "import org.slf4j.LoggerFactory;"], "methods": [], "classes": [{"original_string": "public class MarkdownRender implements Render {\n  private static final Logger LOGGER = LoggerFactory.getLogger(MarkdownRender.class);\n  private static final String H3 = \"### \";\n  private static final String H4 = \"#### \";\n  private static final String H5 = \"##### \";\n  private static final String H6 = \"###### \";\n  private static final String BLOCKQUOTE = \"> \";\n  private static final String CODE = \"`\";\n  private static final String PRE_CODE = \"    \";\n  private static final String PRE_LI = \"    \";\n  private static final String LI = \"* \";\n  private static final String HR = \"---\\n\";\n\n  protected RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  protected ChangedOpenApi diff;\n  protected Set<Schema<?>> handledSchemas = new HashSet<>();\n  /**\n   * A parameter which indicates whether or not metadata (summary and metadata) changes should be\n   * logged in the changelog file.\n   */\n  protected boolean showChangedMetadata;\n\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n    this.handledSchemas.clear();\n    listEndpoints(\"What's New\", diff.getNewEndpoints(), outputStreamWriter);\n    listEndpoints(\"What's Deleted\", diff.getMissingEndpoints(), outputStreamWriter);\n    listEndpoints(\"What's Deprecated\", diff.getDeprecatedEndpoints(), outputStreamWriter);\n    listEndpoints(diff.getChangedOperations(), outputStreamWriter);\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }\n\n  protected String sectionTitle(String title) {\n    return H4 + title + '\\n' + HR + '\\n';\n  }\n\n  protected void listEndpoints(\n      String title, List<Endpoint> endpoints, OutputStreamWriter outputStreamWriter) {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, sectionTitle(title));\n    endpoints.stream()\n        .map(e -> itemEndpoint(e.getMethod().toString(), e.getPathUrl(), e.getSummary()))\n        .forEach(csq -> safelyAppend(outputStreamWriter, csq));\n  }\n\n  protected String itemEndpoint(String method, String path, String summary) {\n    return H5 + CODE + method + CODE + \" \" + path + \"\\n\\n\" + metadata(summary) + \"\\n\";\n  }\n\n  protected String itemEndpoint(String method, String path, ChangedMetadata summary) {\n    return H5 + CODE + method + CODE + \" \" + path + \"\\n\\n\" + metadata(\"summary\", summary) + \"\\n\";\n  }\n\n  protected String titleH5(String title) {\n    return H6 + title + '\\n';\n  }\n\n  protected void listEndpoints(\n      List<ChangedOperation> changedOperations, OutputStreamWriter outputStreamWriter) {\n    if (null == changedOperations || changedOperations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, sectionTitle(\"What's Changed\"));\n    changedOperations.forEach(\n        operation -> {\n          safelyAppend(\n              outputStreamWriter,\n              itemEndpoint(\n                  operation.getHttpMethod().toString(),\n                  operation.getPathUrl(),\n                  operation.getSummary()));\n          if (result(operation.getParameters()).isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Parameters:\"));\n            safelyAppend(outputStreamWriter, parameters(operation.getParameters()));\n          }\n          if (operation.resultRequestBody().isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Request:\"));\n            safelyAppend(\n                outputStreamWriter,\n                metadata(\"Description\", operation.getRequestBody().getDescription()));\n            safelyAppend(outputStreamWriter, bodyContent(operation.getRequestBody().getContent()));\n          }\n          if (operation.resultApiResponses().isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Return Type:\"));\n            safelyAppend(outputStreamWriter, responses(operation.getApiResponses()));\n          }\n        });\n  }\n\n  protected String responses(ChangedApiResponse changedApiResponse) {\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listResponse(\"New response\", changedApiResponse.getIncreased()));\n    sb.append(listResponse(\"Deleted response\", changedApiResponse.getMissing()));\n    changedApiResponse.getChanged().entrySet().stream()\n        .map(e -> this.itemResponse(e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String listResponse(String title, Map<String, ApiResponse> responses) {\n    StringBuilder sb = new StringBuilder();\n    responses.entrySet().stream()\n        .map(e -> this.itemResponse(title, e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String itemResponse(String title, String code, ApiResponse response) {\n    return this.itemResponse(title, code, response.getDescription());\n  }\n\n  protected String itemResponse(String code, ChangedResponse response) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\n        this.itemResponse(\n            \"Changed response\",\n            code,\n            null == response.getNewApiResponse()\n                ? \"\"\n                : response.getNewApiResponse().getDescription()));\n    sb.append(headers(response.getHeaders()));\n    if (response.getContent() != null) {\n      sb.append(this.bodyContent(LI, response.getContent()));\n    }\n    return sb.toString();\n  }\n\n  protected String itemResponse(String title, String code, String description) {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(format(\"%s : **%s %s**\\n\", title, code, status));\n    sb.append(metadata(description));\n    return sb.toString();\n  }\n\n  protected String headers(ChangedHeaders headers) {\n    StringBuilder sb = new StringBuilder();\n    if (headers != null) {\n      sb.append(listHeader(\"New header\", headers.getIncreased()))\n          .append(listHeader(\"Deleted header\", headers.getMissing()));\n      headers.getChanged().entrySet().stream()\n          .map(e -> this.itemHeader(e.getKey(), e.getValue()))\n          .forEach(sb::append);\n    }\n    return sb.toString();\n  }\n\n  protected String listHeader(String title, Map<String, Header> headers) {\n    StringBuilder sb = new StringBuilder();\n    headers.entrySet().stream()\n        .map(e -> this.itemHeader(title, e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String itemHeader(String title, String name, Header header) {\n    return this.itemHeader(title, name, header.getDescription());\n  }\n\n  protected String itemHeader(String code, ChangedHeader header) {\n    return this.itemHeader(\n        \"Changed header\",\n        code,\n        null == header.getNewHeader() ? \"\" : header.getNewHeader().getDescription());\n  }\n\n  protected String itemHeader(String title, String mediaType, String description) {\n    return format(\"%s : `%s`\\n\\n\", title, mediaType) + metadata(description) + '\\n';\n  }\n\n  protected String bodyContent(String prefix, ChangedContent changedContent) {\n    if (changedContent == null) {\n      return \"\";\n    }\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listContent(prefix, \"New content type\", changedContent.getIncreased()));\n    sb.append(listContent(prefix, \"Deleted content type\", changedContent.getMissing()));\n    final int deepness;\n    if (StringUtils.isNotBlank(prefix)) {\n      deepness = 1;\n    } else {\n      deepness = 0;\n    }\n    changedContent.getChanged().entrySet().stream()\n        .map(e -> this.itemContent(deepness, e.getKey(), e.getValue()))\n        .forEach(e -> sb.append(prefix).append(e));\n    return sb.toString();\n  }\n\n  protected String bodyContent(ChangedContent changedContent) {\n    return bodyContent(\"\", changedContent);\n  }\n\n  protected String listContent(String prefix, String title, Map<String, MediaType> mediaTypes) {\n    StringBuilder sb = new StringBuilder();\n    mediaTypes.entrySet().stream()\n        .map(e -> this.itemContent(title, e.getKey(), e.getValue()))\n        .forEach(e -> sb.append(prefix).append(e));\n    return sb.toString();\n  }\n\n  protected String itemContent(String title, String mediaType) {\n    return format(\"%s : `%s`\\n\\n\", title, mediaType);\n  }\n\n  protected String itemContent(String title, String mediaType, MediaType content) {\n    return itemContent(title, mediaType);\n  }\n\n  protected String itemContent(int deepness, String mediaType, ChangedMediaType content) {\n    return itemContent(\"Changed content type\", mediaType) + schema(deepness, content.getSchema());\n  }\n\n  protected String schema(ChangedSchema schema) {\n    return schema(1, schema);\n  }\n\n  protected String oneOfSchema(int deepness, ChangedOneOfSchema schema, String discriminator) {\n    StringBuilder sb = new StringBuilder();\n    schema\n        .getMissing()\n        .keySet()\n        .forEach(\n            key -> sb.append(format(\"%sDeleted '%s' %s\\n\", indent(deepness), key, discriminator)));\n    schema\n        .getIncreased()\n        .forEach(\n            (key, sub) ->\n                sb.append(format(\"%sAdded '%s' %s:\\n\", indent(deepness), key, discriminator))\n                    .append(schema(deepness, sub, schema.getContext())));\n    schema\n        .getChanged()\n        .forEach(\n            (key, sub) ->\n                sb.append(format(\"%sUpdated `%s` %s:\\n\", indent(deepness), key, discriminator))\n                    .append(schema(deepness, sub)));\n    return sb.toString();\n  }\n\n  protected String required(int deepness, String title, List<String> required) {\n    StringBuilder sb = new StringBuilder();\n    if (!required.isEmpty()) {\n      sb.append(format(\"%s%s:\\n\", indent(deepness), title));\n      required.forEach(s -> sb.append(format(\"%s- `%s`\\n\", indent(deepness), s)));\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }\n\n  protected String schema(int deepness, ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.isDiscriminatorPropertyChanged()) {\n      LOGGER.debug(\"Discriminator property changed\");\n    }\n    if (schema.getOneOfSchema() != null) {\n      String discriminator =\n          schema.getNewSchema().getDiscriminator() != null\n              ? schema.getNewSchema().getDiscriminator().getPropertyName()\n              : \"\";\n      sb.append(oneOfSchema(deepness, schema.getOneOfSchema(), discriminator));\n    }\n    if (schema.getRequired() != null) {\n      sb.append(required(deepness, \"New required properties\", schema.getRequired().getIncreased()));\n      sb.append(required(deepness, \"New optional properties\", schema.getRequired().getMissing()));\n    }\n    if (schema.getItems() != null) {\n      sb.append(items(deepness, schema.getItems()));\n    }\n    sb.append(listDiff(deepness, \"enum\", schema.getEnumeration()));\n    sb.append(\n        properties(\n            deepness,\n            \"Added property\",\n            schema.getIncreasedProperties(),\n            true,\n            schema.getContext()));\n    sb.append(\n        properties(\n            deepness,\n            \"Deleted property\",\n            schema.getMissingProperties(),\n            false,\n            schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(property(deepness, name, property)));\n    return sb.toString();\n  }\n\n  protected String schema(int deepness, ComposedSchema schema, DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getAllOf() != null) {\n      LOGGER.debug(\"All of schema\");\n      schema.getAllOf().stream()\n          .map(this::resolve)\n          .forEach(composedChild -> sb.append(schema(deepness, composedChild, context)));\n    }\n    if (schema.getOneOf() != null) {\n      LOGGER.debug(\"One of schema\");\n      sb.append(format(\"%sOne of:\\n\\n\", indent(deepness)));\n      schema.getOneOf().stream()\n          .map(this::resolve)\n          .forEach(composedChild -> sb.append(schema(deepness + 1, composedChild, context)));\n    }\n    return sb.toString();\n  }\n\n  protected String schema(int deepness, Schema schema, DiffContext context) {\n    if (handledSchemas.contains(schema)) return \"\";\n    handledSchemas.add(schema);\n    StringBuilder sb = new StringBuilder();\n    sb.append(listItem(deepness, \"Enum\", schema.getEnum()));\n    sb.append(properties(deepness, \"Property\", schema.getProperties(), true, context));\n    if (schema instanceof ComposedSchema) {\n      sb.append(schema(deepness, (ComposedSchema) schema, context));\n    } else if (schema instanceof ArraySchema) {\n      sb.append(items(deepness, resolve(((ArraySchema) schema).getItems()), context));\n    }\n    return sb.toString();\n  }\n\n  protected String items(int deepness, ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    String type = type(schema.getNewSchema());\n    if (schema.isChangedType()) {\n      type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n    }\n    sb.append(items(deepness, \"Changed items\", type, schema.getNewSchema().getDescription()));\n    sb.append(schema(deepness, schema));\n    return sb.toString();\n  }\n\n  protected String items(int deepness, Schema<?> schema, DiffContext context) {\n    return items(deepness, \"Items\", type(schema), schema.getDescription())\n        + schema(deepness, schema, context);\n  }\n\n  protected String items(int deepness, String title, String type, String description) {\n    return format(\n        \"%s%s (%s):\" + \"\\n%s\\n\",\n        indent(deepness), title, type, metadata(indent(deepness + 1), description));\n  }\n\n  protected String properties(\n      final int deepness,\n      String title,\n      Map<String, Schema<?>> properties,\n      boolean showContent,\n      DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach(\n          (key, value) -> {\n            sb.append(resolveProperty(deepness, value, key, title));\n            if (showContent) {\n              sb.append(schema(deepness + 1, resolve(value), context));\n            }\n          });\n    }\n    return sb.toString();\n  }\n\n  private String resolveProperty(int deepness, Schema<?> value, String key, String title) {\n    try {\n      return property(deepness, title, key, resolve(value));\n    } catch (Exception e) {\n      return property(deepness, title, key, type(value), \"\");\n    }\n  }\n\n  protected String property(int deepness, String name, ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    String type = type(schema.getNewSchema());\n    if (schema.isChangedType()) {\n      type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n    }\n    sb.append(\n        property(deepness, \"Changed property\", name, type, schema.getNewSchema().getDescription()));\n    sb.append(schema(++deepness, schema));\n    return sb.toString();\n  }\n\n  protected String property(int deepness, String title, String name, Schema<?> schema) {\n    return property(deepness, title, name, type(schema), schema.getDescription());\n  }\n\n  protected String property(\n      int deepness, String title, String name, String type, String description) {\n    return format(\n        \"%s* %s `%s` (%s)\\n%s\\n\",\n        indent(deepness), title, name, type, metadata(indent(deepness + 1), description));\n  }\n\n  protected String listDiff(int deepness, String name, ChangedList<?> listDiff) {\n    if (listDiff == null) {\n      return \"\";\n    }\n    return listItem(deepness, \"Added \" + name, listDiff.getIncreased())\n        + listItem(deepness, \"Removed \" + name, listDiff.getMissing());\n  }\n\n  protected <T> String listItem(int deepness, String name, List<T> list) {\n    StringBuilder sb = new StringBuilder();\n    if (list != null && !list.isEmpty()) {\n      sb.append(format(\"%s%s value%s:\\n\\n\", indent(deepness), name, list.size() > 1 ? \"s\" : \"\"));\n      list.forEach(p -> sb.append(format(\"%s* `%s`\\n\", indent(deepness), p)));\n    }\n    return sb.toString();\n  }\n\n  protected String parameters(ChangedParameters changedParameters) {\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listParameter(\"Added\", changedParameters.getIncreased()))\n        .append(listParameter(\"Deleted\", changedParameters.getMissing()));\n    changed.stream().map(this::itemParameter).forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String listParameter(String title, List<Parameter> parameters) {\n    StringBuilder sb = new StringBuilder();\n    parameters.stream().map(p -> itemParameter(title, p)).forEach(sb::append);\n    return sb.toString();\n  }\n\n  protected String itemParameter(String title, Parameter parameter) {\n    return this.itemParameter(\n        title, parameter.getName(), parameter.getIn(), parameter.getDescription());\n  }\n\n  protected String itemParameter(String title, String name, String in, String description) {\n    return format(\"%s: \", title)\n        + code(name)\n        + \" in \"\n        + code(in)\n        + '\\n'\n        + metadata(description)\n        + '\\n';\n  }\n\n  protected String itemParameter(ChangedParameter param) {\n    Parameter rightParam = param.getNewParameter();\n    if (param.isDeprecated()) {\n      return itemParameter(\n          \"Deprecated\", rightParam.getName(), rightParam.getIn(), rightParam.getDescription());\n    }\n    return itemParameter(\n        \"Changed\", rightParam.getName(), rightParam.getIn(), rightParam.getDescription());\n  }\n\n  protected String code(String string) {\n    return CODE + string + CODE;\n  }\n\n  protected String metadata(String name, ChangedMetadata changedMetadata) {\n    return metadata(\"\", name, changedMetadata);\n  }\n\n  protected String metadata(String beginning, String name, ChangedMetadata changedMetadata) {\n    if (changedMetadata == null) {\n      return \"\";\n    }\n    if (!isUnchanged(changedMetadata) && showChangedMetadata) {\n      return format(\n          \"Changed %s:\\n%s\\nto:\\n%s\\n\\n\",\n          name,\n          metadata(beginning, changedMetadata.getLeft()),\n          metadata(beginning, changedMetadata.getRight()));\n    } else {\n      return metadata(beginning, name, changedMetadata.getRight());\n    }\n  }\n\n  protected String metadata(String metadata) {\n    return metadata(\"\", metadata);\n  }\n\n  protected String metadata(String beginning, String name, String metadata) {\n    if (StringUtils.isBlank(metadata)) {\n      return \"\";\n    }\n    return blockquote(beginning, metadata);\n  }\n\n  protected String metadata(String beginning, String metadata) {\n    if (StringUtils.isBlank(metadata)) {\n      return \"\";\n    }\n    return blockquote(beginning, metadata);\n  }\n\n  protected String blockquote(String beginning) {\n    return beginning + BLOCKQUOTE;\n  }\n\n  protected String blockquote(String beginning, String text) {\n    String blockquote = blockquote(beginning);\n    return blockquote + text.trim().replace(\"\\n\", \"\\n\" + blockquote) + \"\\n\\n\";\n  }\n\n  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }\n\n  protected String indent(int deepness) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < deepness; i++) {\n      sb.append(PRE_LI);\n    }\n    return sb.toString();\n  }\n\n  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }\n\n  /**\n   * A parameter which indicates whether or not metadata (summary and metadata) changes should be\n   * logged in the changelog file.\n   */\n  public boolean isShowChangedMetadata() {\n    return this.showChangedMetadata;\n  }\n\n  /**\n   * A parameter which indicates whether or not metadata (summary and metadata) changes should be\n   * logged in the changelog file.\n   */\n  public void setShowChangedMetadata(final boolean showChangedMetadata) {\n    this.showChangedMetadata = showChangedMetadata;\n  }\n}", "definition": "public class MarkdownRender implements Render", "class_docstring": "", "name": "MarkdownRender", "super_interfaces": ["Render"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Logger LOGGER = LoggerFactory.getLogger(MarkdownRender.class);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "LOGGER = LoggerFactory.getLogger(MarkdownRender.class)", "syntax_pass": true}, {"attribute_expression": "private static final String H3 = \"### \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "H3 = \"### \"", "syntax_pass": true}, {"attribute_expression": "private static final String H4 = \"#### \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "H4 = \"#### \"", "syntax_pass": true}, {"attribute_expression": "private static final String H5 = \"##### \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "H5 = \"##### \"", "syntax_pass": true}, {"attribute_expression": "private static final String H6 = \"###### \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "H6 = \"###### \"", "syntax_pass": true}, {"attribute_expression": "private static final String BLOCKQUOTE = \"> \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "BLOCKQUOTE = \"> \"", "syntax_pass": true}, {"attribute_expression": "private static final String CODE = \"`\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CODE = \"`\"", "syntax_pass": true}, {"attribute_expression": "private static final String PRE_CODE = \"    \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PRE_CODE = \"    \"", "syntax_pass": true}, {"attribute_expression": "private static final String PRE_LI = \"    \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PRE_LI = \"    \"", "syntax_pass": true}, {"attribute_expression": "private static final String LI = \"* \";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LI = \"* \"", "syntax_pass": true}, {"attribute_expression": "private static final String HR = \"---\\n\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "HR = \"---\\n\"", "syntax_pass": true}, {"attribute_expression": "protected RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "RefPointer<Schema<?>>", "name": "refPointer = new RefPointer<>(RefType.SCHEMAS)", "syntax_pass": true}, {"attribute_expression": "protected ChangedOpenApi diff;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedOpenApi", "name": "diff", "syntax_pass": true}, {"attribute_expression": "protected Set<Schema<?>> handledSchemas = new HashSet<>();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Set<Schema<?>>", "name": "handledSchemas = new HashSet<>()", "syntax_pass": true}, {"attribute_expression": "protected boolean showChangedMetadata;", "docstring": "\nA parameter which indicates whether or not metadata (summary and metadata) changes should be\nlogged in the changelog file.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "showChangedMetadata", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n    this.handledSchemas.clear();\n    listEndpoints(\"What's New\", diff.getNewEndpoints(), outputStreamWriter);\n    listEndpoints(\"What's Deleted\", diff.getMissingEndpoints(), outputStreamWriter);\n    listEndpoints(\"What's Deprecated\", diff.getDeprecatedEndpoints(), outputStreamWriter);\n    listEndpoints(diff.getChangedOperations(), outputStreamWriter);\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "render", "params": [{"name": "diff", "type": "ChangedOpenApi"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                 {\n    this.diff = diff;\n    this.handledSchemas.clear();\n    listEndpoints(\"What's New\", diff.getNewEndpoints(), outputStreamWriter);\n    listEndpoints(\"What's Deleted\", diff.getMissingEndpoints(), outputStreamWriter);\n    listEndpoints(\"What's Deprecated\", diff.getDeprecatedEndpoints(), outputStreamWriter);\n    listEndpoints(diff.getChangedOperations(), outputStreamWriter);\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }", "signature": "public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  protected String sectionTitle(String title) {\n    return H4 + title + '\\n' + HR + '\\n';\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "sectionTitle", "params": [{"name": "title", "type": "String"}], "body": "                                              {\n    return H4 + title + '\\n' + HR + '\\n';\n  }", "signature": "protected String sectionTitle(String title)"}, {"syntax_pass": true, "original_string": "  protected void listEndpoints(\n      String title, List<Endpoint> endpoints, OutputStreamWriter outputStreamWriter) {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, sectionTitle(title));\n    endpoints.stream()\n        .map(e -> itemEndpoint(e.getMethod().toString(), e.getPathUrl(), e.getSummary()))\n        .forEach(csq -> safelyAppend(outputStreamWriter, csq));\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "listEndpoints", "params": [{"name": "title", "type": "String"}, {"name": "endpoints", "type": "List<Endpoint>"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                     {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, sectionTitle(title));\n    endpoints.stream()\n        .map(e -> itemEndpoint(e.getMethod().toString(), e.getPathUrl(), e.getSummary()))\n        .forEach(csq -> safelyAppend(outputStreamWriter, csq));\n  }", "signature": "protected void listEndpoints(\n      String title, List<Endpoint> endpoints, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  protected String itemEndpoint(String method, String path, String summary) {\n    return H5 + CODE + method + CODE + \" \" + path + \"\\n\\n\" + metadata(summary) + \"\\n\";\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemEndpoint", "params": [{"name": "method", "type": "String"}, {"name": "path", "type": "String"}, {"name": "summary", "type": "String"}], "body": "                                                                            {\n    return H5 + CODE + method + CODE + \" \" + path + \"\\n\\n\" + metadata(summary) + \"\\n\";\n  }", "signature": "protected String itemEndpoint(String method, String path, String summary)"}, {"syntax_pass": true, "original_string": "  protected String itemEndpoint(String method, String path, ChangedMetadata summary) {\n    return H5 + CODE + method + CODE + \" \" + path + \"\\n\\n\" + metadata(\"summary\", summary) + \"\\n\";\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemEndpoint", "params": [{"name": "method", "type": "String"}, {"name": "path", "type": "String"}, {"name": "summary", "type": "ChangedMetadata"}], "body": "                                                                                     {\n    return H5 + CODE + method + CODE + \" \" + path + \"\\n\\n\" + metadata(\"summary\", summary) + \"\\n\";\n  }", "signature": "protected String itemEndpoint(String method, String path, ChangedMetadata summary)"}, {"syntax_pass": true, "original_string": "  protected String titleH5(String title) {\n    return H6 + title + '\\n';\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "titleH5", "params": [{"name": "title", "type": "String"}], "body": "                                         {\n    return H6 + title + '\\n';\n  }", "signature": "protected String titleH5(String title)"}, {"syntax_pass": true, "original_string": "  protected void listEndpoints(\n      List<ChangedOperation> changedOperations, OutputStreamWriter outputStreamWriter) {\n    if (null == changedOperations || changedOperations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, sectionTitle(\"What's Changed\"));\n    changedOperations.forEach(\n        operation -> {\n          safelyAppend(\n              outputStreamWriter,\n              itemEndpoint(\n                  operation.getHttpMethod().toString(),\n                  operation.getPathUrl(),\n                  operation.getSummary()));\n          if (result(operation.getParameters()).isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Parameters:\"));\n            safelyAppend(outputStreamWriter, parameters(operation.getParameters()));\n          }\n          if (operation.resultRequestBody().isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Request:\"));\n            safelyAppend(\n                outputStreamWriter,\n                metadata(\"Description\", operation.getRequestBody().getDescription()));\n            safelyAppend(outputStreamWriter, bodyContent(operation.getRequestBody().getContent()));\n          }\n          if (operation.resultApiResponses().isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Return Type:\"));\n            safelyAppend(outputStreamWriter, responses(operation.getApiResponses()));\n          }\n        });\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "listEndpoints", "params": [{"name": "changedOperations", "type": "List<ChangedOperation>"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                       {\n    if (null == changedOperations || changedOperations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, sectionTitle(\"What's Changed\"));\n    changedOperations.forEach(\n        operation -> {\n          safelyAppend(\n              outputStreamWriter,\n              itemEndpoint(\n                  operation.getHttpMethod().toString(),\n                  operation.getPathUrl(),\n                  operation.getSummary()));\n          if (result(operation.getParameters()).isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Parameters:\"));\n            safelyAppend(outputStreamWriter, parameters(operation.getParameters()));\n          }\n          if (operation.resultRequestBody().isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Request:\"));\n            safelyAppend(\n                outputStreamWriter,\n                metadata(\"Description\", operation.getRequestBody().getDescription()));\n            safelyAppend(outputStreamWriter, bodyContent(operation.getRequestBody().getContent()));\n          }\n          if (operation.resultApiResponses().isDifferent()) {\n            safelyAppend(outputStreamWriter, titleH5(\"Return Type:\"));\n            safelyAppend(outputStreamWriter, responses(operation.getApiResponses()));\n          }\n        });\n  }", "signature": "protected void listEndpoints(\n      List<ChangedOperation> changedOperations, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  protected String responses(ChangedApiResponse changedApiResponse) {\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listResponse(\"New response\", changedApiResponse.getIncreased()));\n    sb.append(listResponse(\"Deleted response\", changedApiResponse.getMissing()));\n    changedApiResponse.getChanged().entrySet().stream()\n        .map(e -> this.itemResponse(e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "responses", "params": [{"name": "changedApiResponse", "type": "ChangedApiResponse"}], "body": "                                                                    {\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listResponse(\"New response\", changedApiResponse.getIncreased()));\n    sb.append(listResponse(\"Deleted response\", changedApiResponse.getMissing()));\n    changedApiResponse.getChanged().entrySet().stream()\n        .map(e -> this.itemResponse(e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }", "signature": "protected String responses(ChangedApiResponse changedApiResponse)"}, {"syntax_pass": true, "original_string": "  protected String listResponse(String title, Map<String, ApiResponse> responses) {\n    StringBuilder sb = new StringBuilder();\n    responses.entrySet().stream()\n        .map(e -> this.itemResponse(title, e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "listResponse", "params": [{"name": "title", "type": "String"}, {"name": "responses", "type": "Map<String, ApiResponse>"}], "body": "                                                                                  {\n    StringBuilder sb = new StringBuilder();\n    responses.entrySet().stream()\n        .map(e -> this.itemResponse(title, e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }", "signature": "protected String listResponse(String title, Map<String, ApiResponse> responses)"}, {"syntax_pass": true, "original_string": "  protected String itemResponse(String title, String code, ApiResponse response) {\n    return this.itemResponse(title, code, response.getDescription());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemResponse", "params": [{"name": "title", "type": "String"}, {"name": "code", "type": "String"}, {"name": "response", "type": "ApiResponse"}], "body": "                                                                                 {\n    return this.itemResponse(title, code, response.getDescription());\n  }", "signature": "protected String itemResponse(String title, String code, ApiResponse response)"}, {"syntax_pass": true, "original_string": "  protected String itemResponse(String code, ChangedResponse response) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\n        this.itemResponse(\n            \"Changed response\",\n            code,\n            null == response.getNewApiResponse()\n                ? \"\"\n                : response.getNewApiResponse().getDescription()));\n    sb.append(headers(response.getHeaders()));\n    if (response.getContent() != null) {\n      sb.append(this.bodyContent(LI, response.getContent()));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemResponse", "params": [{"name": "code", "type": "String"}, {"name": "response", "type": "ChangedResponse"}], "body": "                                                                       {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\n        this.itemResponse(\n            \"Changed response\",\n            code,\n            null == response.getNewApiResponse()\n                ? \"\"\n                : response.getNewApiResponse().getDescription()));\n    sb.append(headers(response.getHeaders()));\n    if (response.getContent() != null) {\n      sb.append(this.bodyContent(LI, response.getContent()));\n    }\n    return sb.toString();\n  }", "signature": "protected String itemResponse(String code, ChangedResponse response)"}, {"syntax_pass": true, "original_string": "  protected String itemResponse(String title, String code, String description) {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(format(\"%s : **%s %s**\\n\", title, code, status));\n    sb.append(metadata(description));\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemResponse", "params": [{"name": "title", "type": "String"}, {"name": "code", "type": "String"}, {"name": "description", "type": "String"}], "body": "                                                                               {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(format(\"%s : **%s %s**\\n\", title, code, status));\n    sb.append(metadata(description));\n    return sb.toString();\n  }", "signature": "protected String itemResponse(String title, String code, String description)"}, {"syntax_pass": true, "original_string": "  protected String headers(ChangedHeaders headers) {\n    StringBuilder sb = new StringBuilder();\n    if (headers != null) {\n      sb.append(listHeader(\"New header\", headers.getIncreased()))\n          .append(listHeader(\"Deleted header\", headers.getMissing()));\n      headers.getChanged().entrySet().stream()\n          .map(e -> this.itemHeader(e.getKey(), e.getValue()))\n          .forEach(sb::append);\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "headers", "params": [{"name": "headers", "type": "ChangedHeaders"}], "body": "                                                   {\n    StringBuilder sb = new StringBuilder();\n    if (headers != null) {\n      sb.append(listHeader(\"New header\", headers.getIncreased()))\n          .append(listHeader(\"Deleted header\", headers.getMissing()));\n      headers.getChanged().entrySet().stream()\n          .map(e -> this.itemHeader(e.getKey(), e.getValue()))\n          .forEach(sb::append);\n    }\n    return sb.toString();\n  }", "signature": "protected String headers(ChangedHeaders headers)"}, {"syntax_pass": true, "original_string": "  protected String listHeader(String title, Map<String, Header> headers) {\n    StringBuilder sb = new StringBuilder();\n    headers.entrySet().stream()\n        .map(e -> this.itemHeader(title, e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "listHeader", "params": [{"name": "title", "type": "String"}, {"name": "headers", "type": "Map<String, Header>"}], "body": "                                                                         {\n    StringBuilder sb = new StringBuilder();\n    headers.entrySet().stream()\n        .map(e -> this.itemHeader(title, e.getKey(), e.getValue()))\n        .forEach(sb::append);\n    return sb.toString();\n  }", "signature": "protected String listHeader(String title, Map<String, Header> headers)"}, {"syntax_pass": true, "original_string": "  protected String itemHeader(String title, String name, Header header) {\n    return this.itemHeader(title, name, header.getDescription());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemHeader", "params": [{"name": "title", "type": "String"}, {"name": "name", "type": "String"}, {"name": "header", "type": "Header"}], "body": "                                                                        {\n    return this.itemHeader(title, name, header.getDescription());\n  }", "signature": "protected String itemHeader(String title, String name, Header header)"}, {"syntax_pass": true, "original_string": "  protected String itemHeader(String code, ChangedHeader header) {\n    return this.itemHeader(\n        \"Changed header\",\n        code,\n        null == header.getNewHeader() ? \"\" : header.getNewHeader().getDescription());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemHeader", "params": [{"name": "code", "type": "String"}, {"name": "header", "type": "ChangedHeader"}], "body": "                                                                 {\n    return this.itemHeader(\n        \"Changed header\",\n        code,\n        null == header.getNewHeader() ? \"\" : header.getNewHeader().getDescription());\n  }", "signature": "protected String itemHeader(String code, ChangedHeader header)"}, {"syntax_pass": true, "original_string": "  protected String itemHeader(String title, String mediaType, String description) {\n    return format(\"%s : `%s`\\n\\n\", title, mediaType) + metadata(description) + '\\n';\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemHeader", "params": [{"name": "title", "type": "String"}, {"name": "mediaType", "type": "String"}, {"name": "description", "type": "String"}], "body": "                                                                                  {\n    return format(\"%s : `%s`\\n\\n\", title, mediaType) + metadata(description) + '\\n';\n  }", "signature": "protected String itemHeader(String title, String mediaType, String description)"}, {"syntax_pass": true, "original_string": "  protected String bodyContent(String prefix, ChangedContent changedContent) {\n    if (changedContent == null) {\n      return \"\";\n    }\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listContent(prefix, \"New content type\", changedContent.getIncreased()));\n    sb.append(listContent(prefix, \"Deleted content type\", changedContent.getMissing()));\n    final int deepness;\n    if (StringUtils.isNotBlank(prefix)) {\n      deepness = 1;\n    } else {\n      deepness = 0;\n    }\n    changedContent.getChanged().entrySet().stream()\n        .map(e -> this.itemContent(deepness, e.getKey(), e.getValue()))\n        .forEach(e -> sb.append(prefix).append(e));\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "bodyContent", "params": [{"name": "prefix", "type": "String"}, {"name": "changedContent", "type": "ChangedContent"}], "body": "                                                                             {\n    if (changedContent == null) {\n      return \"\";\n    }\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listContent(prefix, \"New content type\", changedContent.getIncreased()));\n    sb.append(listContent(prefix, \"Deleted content type\", changedContent.getMissing()));\n    final int deepness;\n    if (StringUtils.isNotBlank(prefix)) {\n      deepness = 1;\n    } else {\n      deepness = 0;\n    }\n    changedContent.getChanged().entrySet().stream()\n        .map(e -> this.itemContent(deepness, e.getKey(), e.getValue()))\n        .forEach(e -> sb.append(prefix).append(e));\n    return sb.toString();\n  }", "signature": "protected String bodyContent(String prefix, ChangedContent changedContent)"}, {"syntax_pass": true, "original_string": "  protected String bodyContent(ChangedContent changedContent) {\n    return bodyContent(\"\", changedContent);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "bodyContent", "params": [{"name": "changedContent", "type": "ChangedContent"}], "body": "                                                              {\n    return bodyContent(\"\", changedContent);\n  }", "signature": "protected String bodyContent(ChangedContent changedContent)"}, {"syntax_pass": true, "original_string": "  protected String listContent(String prefix, String title, Map<String, MediaType> mediaTypes) {\n    StringBuilder sb = new StringBuilder();\n    mediaTypes.entrySet().stream()\n        .map(e -> this.itemContent(title, e.getKey(), e.getValue()))\n        .forEach(e -> sb.append(prefix).append(e));\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "listContent", "params": [{"name": "prefix", "type": "String"}, {"name": "title", "type": "String"}, {"name": "mediaTypes", "type": "Map<String, MediaType>"}], "body": "                                                                                               {\n    StringBuilder sb = new StringBuilder();\n    mediaTypes.entrySet().stream()\n        .map(e -> this.itemContent(title, e.getKey(), e.getValue()))\n        .forEach(e -> sb.append(prefix).append(e));\n    return sb.toString();\n  }", "signature": "protected String listContent(String prefix, String title, Map<String, MediaType> mediaTypes)"}, {"syntax_pass": true, "original_string": "  protected String itemContent(String title, String mediaType) {\n    return format(\"%s : `%s`\\n\\n\", title, mediaType);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemContent", "params": [{"name": "title", "type": "String"}, {"name": "mediaType", "type": "String"}], "body": "                                                               {\n    return format(\"%s : `%s`\\n\\n\", title, mediaType);\n  }", "signature": "protected String itemContent(String title, String mediaType)"}, {"syntax_pass": true, "original_string": "  protected String itemContent(String title, String mediaType, MediaType content) {\n    return itemContent(title, mediaType);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemContent", "params": [{"name": "title", "type": "String"}, {"name": "mediaType", "type": "String"}, {"name": "content", "type": "MediaType"}], "body": "                                                                                  {\n    return itemContent(title, mediaType);\n  }", "signature": "protected String itemContent(String title, String mediaType, MediaType content)"}, {"syntax_pass": true, "original_string": "  protected String itemContent(int deepness, String mediaType, ChangedMediaType content) {\n    return itemContent(\"Changed content type\", mediaType) + schema(deepness, content.getSchema());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemContent", "params": [{"name": "deepness", "type": "int"}, {"name": "mediaType", "type": "String"}, {"name": "content", "type": "ChangedMediaType"}], "body": "                                                                                         {\n    return itemContent(\"Changed content type\", mediaType) + schema(deepness, content.getSchema());\n  }", "signature": "protected String itemContent(int deepness, String mediaType, ChangedMediaType content)"}, {"syntax_pass": true, "original_string": "  protected String schema(ChangedSchema schema) {\n    return schema(1, schema);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "schema", "params": [{"name": "schema", "type": "ChangedSchema"}], "body": "                                                {\n    return schema(1, schema);\n  }", "signature": "protected String schema(ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  protected String oneOfSchema(int deepness, ChangedOneOfSchema schema, String discriminator) {\n    StringBuilder sb = new StringBuilder();\n    schema\n        .getMissing()\n        .keySet()\n        .forEach(\n            key -> sb.append(format(\"%sDeleted '%s' %s\\n\", indent(deepness), key, discriminator)));\n    schema\n        .getIncreased()\n        .forEach(\n            (key, sub) ->\n                sb.append(format(\"%sAdded '%s' %s:\\n\", indent(deepness), key, discriminator))\n                    .append(schema(deepness, sub, schema.getContext())));\n    schema\n        .getChanged()\n        .forEach(\n            (key, sub) ->\n                sb.append(format(\"%sUpdated `%s` %s:\\n\", indent(deepness), key, discriminator))\n                    .append(schema(deepness, sub)));\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "oneOfSchema", "params": [{"name": "deepness", "type": "int"}, {"name": "schema", "type": "ChangedOneOfSchema"}, {"name": "discriminator", "type": "String"}], "body": "                                                                                              {\n    StringBuilder sb = new StringBuilder();\n    schema\n        .getMissing()\n        .keySet()\n        .forEach(\n            key -> sb.append(format(\"%sDeleted '%s' %s\\n\", indent(deepness), key, discriminator)));\n    schema\n        .getIncreased()\n        .forEach(\n            (key, sub) ->\n                sb.append(format(\"%sAdded '%s' %s:\\n\", indent(deepness), key, discriminator))\n                    .append(schema(deepness, sub, schema.getContext())));\n    schema\n        .getChanged()\n        .forEach(\n            (key, sub) ->\n                sb.append(format(\"%sUpdated `%s` %s:\\n\", indent(deepness), key, discriminator))\n                    .append(schema(deepness, sub)));\n    return sb.toString();\n  }", "signature": "protected String oneOfSchema(int deepness, ChangedOneOfSchema schema, String discriminator)"}, {"syntax_pass": true, "original_string": "  protected String required(int deepness, String title, List<String> required) {\n    StringBuilder sb = new StringBuilder();\n    if (!required.isEmpty()) {\n      sb.append(format(\"%s%s:\\n\", indent(deepness), title));\n      required.forEach(s -> sb.append(format(\"%s- `%s`\\n\", indent(deepness), s)));\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "required", "params": [{"name": "deepness", "type": "int"}, {"name": "title", "type": "String"}, {"name": "required", "type": "List<String>"}], "body": "                                                                               {\n    StringBuilder sb = new StringBuilder();\n    if (!required.isEmpty()) {\n      sb.append(format(\"%s%s:\\n\", indent(deepness), title));\n      required.forEach(s -> sb.append(format(\"%s- `%s`\\n\", indent(deepness), s)));\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }", "signature": "protected String required(int deepness, String title, List<String> required)"}, {"syntax_pass": true, "original_string": "  protected String schema(int deepness, ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.isDiscriminatorPropertyChanged()) {\n      LOGGER.debug(\"Discriminator property changed\");\n    }\n    if (schema.getOneOfSchema() != null) {\n      String discriminator =\n          schema.getNewSchema().getDiscriminator() != null\n              ? schema.getNewSchema().getDiscriminator().getPropertyName()\n              : \"\";\n      sb.append(oneOfSchema(deepness, schema.getOneOfSchema(), discriminator));\n    }\n    if (schema.getRequired() != null) {\n      sb.append(required(deepness, \"New required properties\", schema.getRequired().getIncreased()));\n      sb.append(required(deepness, \"New optional properties\", schema.getRequired().getMissing()));\n    }\n    if (schema.getItems() != null) {\n      sb.append(items(deepness, schema.getItems()));\n    }\n    sb.append(listDiff(deepness, \"enum\", schema.getEnumeration()));\n    sb.append(\n        properties(\n            deepness,\n            \"Added property\",\n            schema.getIncreasedProperties(),\n            true,\n            schema.getContext()));\n    sb.append(\n        properties(\n            deepness,\n            \"Deleted property\",\n            schema.getMissingProperties(),\n            false,\n            schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(property(deepness, name, property)));\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "schema", "params": [{"name": "deepness", "type": "int"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                              {\n    StringBuilder sb = new StringBuilder();\n    if (schema.isDiscriminatorPropertyChanged()) {\n      LOGGER.debug(\"Discriminator property changed\");\n    }\n    if (schema.getOneOfSchema() != null) {\n      String discriminator =\n          schema.getNewSchema().getDiscriminator() != null\n              ? schema.getNewSchema().getDiscriminator().getPropertyName()\n              : \"\";\n      sb.append(oneOfSchema(deepness, schema.getOneOfSchema(), discriminator));\n    }\n    if (schema.getRequired() != null) {\n      sb.append(required(deepness, \"New required properties\", schema.getRequired().getIncreased()));\n      sb.append(required(deepness, \"New optional properties\", schema.getRequired().getMissing()));\n    }\n    if (schema.getItems() != null) {\n      sb.append(items(deepness, schema.getItems()));\n    }\n    sb.append(listDiff(deepness, \"enum\", schema.getEnumeration()));\n    sb.append(\n        properties(\n            deepness,\n            \"Added property\",\n            schema.getIncreasedProperties(),\n            true,\n            schema.getContext()));\n    sb.append(\n        properties(\n            deepness,\n            \"Deleted property\",\n            schema.getMissingProperties(),\n            false,\n            schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(property(deepness, name, property)));\n    return sb.toString();\n  }", "signature": "protected String schema(int deepness, ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  protected String schema(int deepness, ComposedSchema schema, DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getAllOf() != null) {\n      LOGGER.debug(\"All of schema\");\n      schema.getAllOf().stream()\n          .map(this::resolve)\n          .forEach(composedChild -> sb.append(schema(deepness, composedChild, context)));\n    }\n    if (schema.getOneOf() != null) {\n      LOGGER.debug(\"One of schema\");\n      sb.append(format(\"%sOne of:\\n\\n\", indent(deepness)));\n      schema.getOneOf().stream()\n          .map(this::resolve)\n          .forEach(composedChild -> sb.append(schema(deepness + 1, composedChild, context)));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "schema", "params": [{"name": "deepness", "type": "int"}, {"name": "schema", "type": "ComposedSchema"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                    {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getAllOf() != null) {\n      LOGGER.debug(\"All of schema\");\n      schema.getAllOf().stream()\n          .map(this::resolve)\n          .forEach(composedChild -> sb.append(schema(deepness, composedChild, context)));\n    }\n    if (schema.getOneOf() != null) {\n      LOGGER.debug(\"One of schema\");\n      sb.append(format(\"%sOne of:\\n\\n\", indent(deepness)));\n      schema.getOneOf().stream()\n          .map(this::resolve)\n          .forEach(composedChild -> sb.append(schema(deepness + 1, composedChild, context)));\n    }\n    return sb.toString();\n  }", "signature": "protected String schema(int deepness, ComposedSchema schema, DiffContext context)"}, {"syntax_pass": true, "original_string": "  protected String schema(int deepness, Schema schema, DiffContext context) {\n    if (handledSchemas.contains(schema)) return \"\";\n    handledSchemas.add(schema);\n    StringBuilder sb = new StringBuilder();\n    sb.append(listItem(deepness, \"Enum\", schema.getEnum()));\n    sb.append(properties(deepness, \"Property\", schema.getProperties(), true, context));\n    if (schema instanceof ComposedSchema) {\n      sb.append(schema(deepness, (ComposedSchema) schema, context));\n    } else if (schema instanceof ArraySchema) {\n      sb.append(items(deepness, resolve(((ArraySchema) schema).getItems()), context));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "schema", "params": [{"name": "deepness", "type": "int"}, {"name": "schema", "type": "Schema"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                            {\n    if (handledSchemas.contains(schema)) return \"\";\n    handledSchemas.add(schema);\n    StringBuilder sb = new StringBuilder();\n    sb.append(listItem(deepness, \"Enum\", schema.getEnum()));\n    sb.append(properties(deepness, \"Property\", schema.getProperties(), true, context));\n    if (schema instanceof ComposedSchema) {\n      sb.append(schema(deepness, (ComposedSchema) schema, context));\n    } else if (schema instanceof ArraySchema) {\n      sb.append(items(deepness, resolve(((ArraySchema) schema).getItems()), context));\n    }\n    return sb.toString();\n  }", "signature": "protected String schema(int deepness, Schema schema, DiffContext context)"}, {"syntax_pass": true, "original_string": "  protected String items(int deepness, ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    String type = type(schema.getNewSchema());\n    if (schema.isChangedType()) {\n      type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n    }\n    sb.append(items(deepness, \"Changed items\", type, schema.getNewSchema().getDescription()));\n    sb.append(schema(deepness, schema));\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "items", "params": [{"name": "deepness", "type": "int"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                             {\n    StringBuilder sb = new StringBuilder();\n    String type = type(schema.getNewSchema());\n    if (schema.isChangedType()) {\n      type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n    }\n    sb.append(items(deepness, \"Changed items\", type, schema.getNewSchema().getDescription()));\n    sb.append(schema(deepness, schema));\n    return sb.toString();\n  }", "signature": "protected String items(int deepness, ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  protected String items(int deepness, Schema<?> schema, DiffContext context) {\n    return items(deepness, \"Items\", type(schema), schema.getDescription())\n        + schema(deepness, schema, context);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "items", "params": [{"name": "deepness", "type": "int"}, {"name": "schema", "type": "Schema<?>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                              {\n    return items(deepness, \"Items\", type(schema), schema.getDescription())\n        + schema(deepness, schema, context);\n  }", "signature": "protected String items(int deepness, Schema<?> schema, DiffContext context)"}, {"syntax_pass": true, "original_string": "  protected String items(int deepness, String title, String type, String description) {\n    return format(\n        \"%s%s (%s):\" + \"\\n%s\\n\",\n        indent(deepness), title, type, metadata(indent(deepness + 1), description));\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "items", "params": [{"name": "deepness", "type": "int"}, {"name": "title", "type": "String"}, {"name": "type", "type": "String"}, {"name": "description", "type": "String"}], "body": "                                                                                      {\n    return format(\n        \"%s%s (%s):\" + \"\\n%s\\n\",\n        indent(deepness), title, type, metadata(indent(deepness + 1), description));\n  }", "signature": "protected String items(int deepness, String title, String type, String description)"}, {"syntax_pass": true, "original_string": "  protected String properties(\n      final int deepness,\n      String title,\n      Map<String, Schema<?>> properties,\n      boolean showContent,\n      DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach(\n          (key, value) -> {\n            sb.append(resolveProperty(deepness, value, key, title));\n            if (showContent) {\n              sb.append(schema(deepness + 1, resolve(value), context));\n            }\n          });\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "properties", "params": [{"name": "deepness", "type": "int"}, {"name": "title", "type": "String"}, {"name": "properties", "type": "Map<String, Schema<?>>"}, {"name": "showContent", "type": "boolean"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach(\n          (key, value) -> {\n            sb.append(resolveProperty(deepness, value, key, title));\n            if (showContent) {\n              sb.append(schema(deepness + 1, resolve(value), context));\n            }\n          });\n    }\n    return sb.toString();\n  }", "signature": "protected String properties(\n      final int deepness,\n      String title,\n      Map<String, Schema<?>> properties,\n      boolean showContent,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  private String resolveProperty(int deepness, Schema<?> value, String key, String title) {\n    try {\n      return property(deepness, title, key, resolve(value));\n    } catch (Exception e) {\n      return property(deepness, title, key, type(value), \"\");\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "resolveProperty", "params": [{"name": "deepness", "type": "int"}, {"name": "value", "type": "Schema<?>"}, {"name": "key", "type": "String"}, {"name": "title", "type": "String"}], "body": "                                                                                          {\n    try {\n      return property(deepness, title, key, resolve(value));\n    } catch (Exception e) {\n      return property(deepness, title, key, type(value), \"\");\n    }\n  }", "signature": "private String resolveProperty(int deepness, Schema<?> value, String key, String title)"}, {"syntax_pass": true, "original_string": "  protected String property(int deepness, String name, ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    String type = type(schema.getNewSchema());\n    if (schema.isChangedType()) {\n      type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n    }\n    sb.append(\n        property(deepness, \"Changed property\", name, type, schema.getNewSchema().getDescription()));\n    sb.append(schema(++deepness, schema));\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "property", "params": [{"name": "deepness", "type": "int"}, {"name": "name", "type": "String"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                                             {\n    StringBuilder sb = new StringBuilder();\n    String type = type(schema.getNewSchema());\n    if (schema.isChangedType()) {\n      type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n    }\n    sb.append(\n        property(deepness, \"Changed property\", name, type, schema.getNewSchema().getDescription()));\n    sb.append(schema(++deepness, schema));\n    return sb.toString();\n  }", "signature": "protected String property(int deepness, String name, ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  protected String property(int deepness, String title, String name, Schema<?> schema) {\n    return property(deepness, title, name, type(schema), schema.getDescription());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "property", "params": [{"name": "deepness", "type": "int"}, {"name": "title", "type": "String"}, {"name": "name", "type": "String"}, {"name": "schema", "type": "Schema<?>"}], "body": "                                                                                       {\n    return property(deepness, title, name, type(schema), schema.getDescription());\n  }", "signature": "protected String property(int deepness, String title, String name, Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  protected String property(\n      int deepness, String title, String name, String type, String description) {\n    return format(\n        \"%s* %s `%s` (%s)\\n%s\\n\",\n        indent(deepness), title, name, type, metadata(indent(deepness + 1), description));\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "property", "params": [{"name": "deepness", "type": "int"}, {"name": "title", "type": "String"}, {"name": "name", "type": "String"}, {"name": "type", "type": "String"}, {"name": "description", "type": "String"}], "body": "                                                                                {\n    return format(\n        \"%s* %s `%s` (%s)\\n%s\\n\",\n        indent(deepness), title, name, type, metadata(indent(deepness + 1), description));\n  }", "signature": "protected String property(\n      int deepness, String title, String name, String type, String description)"}, {"syntax_pass": true, "original_string": "  protected String listDiff(int deepness, String name, ChangedList<?> listDiff) {\n    if (listDiff == null) {\n      return \"\";\n    }\n    return listItem(deepness, \"Added \" + name, listDiff.getIncreased())\n        + listItem(deepness, \"Removed \" + name, listDiff.getMissing());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "listDiff", "params": [{"name": "deepness", "type": "int"}, {"name": "name", "type": "String"}, {"name": "listDiff", "type": "ChangedList<?>"}], "body": "                                                                                {\n    if (listDiff == null) {\n      return \"\";\n    }\n    return listItem(deepness, \"Added \" + name, listDiff.getIncreased())\n        + listItem(deepness, \"Removed \" + name, listDiff.getMissing());\n  }", "signature": "protected String listDiff(int deepness, String name, ChangedList<?> listDiff)"}, {"syntax_pass": true, "original_string": "  protected <T> String listItem(int deepness, String name, List<T> list) {\n    StringBuilder sb = new StringBuilder();\n    if (list != null && !list.isEmpty()) {\n      sb.append(format(\"%s%s value%s:\\n\\n\", indent(deepness), name, list.size() > 1 ? \"s\" : \"\"));\n      list.forEach(p -> sb.append(format(\"%s* `%s`\\n\", indent(deepness), p)));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "listItem", "params": [{"name": "deepness", "type": "int"}, {"name": "name", "type": "String"}, {"name": "list", "type": "List<T>"}], "body": "                                                                         {\n    StringBuilder sb = new StringBuilder();\n    if (list != null && !list.isEmpty()) {\n      sb.append(format(\"%s%s value%s:\\n\\n\", indent(deepness), name, list.size() > 1 ? \"s\" : \"\"));\n      list.forEach(p -> sb.append(format(\"%s* `%s`\\n\", indent(deepness), p)));\n    }\n    return sb.toString();\n  }", "signature": "protected <T> String listItem(int deepness, String name, List<T> list)"}, {"syntax_pass": true, "original_string": "  protected String parameters(ChangedParameters changedParameters) {\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listParameter(\"Added\", changedParameters.getIncreased()))\n        .append(listParameter(\"Deleted\", changedParameters.getMissing()));\n    changed.stream().map(this::itemParameter).forEach(sb::append);\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "parameters", "params": [{"name": "changedParameters", "type": "ChangedParameters"}], "body": "                                                                   {\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder(\"\\n\");\n    sb.append(listParameter(\"Added\", changedParameters.getIncreased()))\n        .append(listParameter(\"Deleted\", changedParameters.getMissing()));\n    changed.stream().map(this::itemParameter).forEach(sb::append);\n    return sb.toString();\n  }", "signature": "protected String parameters(ChangedParameters changedParameters)"}, {"syntax_pass": true, "original_string": "  protected String listParameter(String title, List<Parameter> parameters) {\n    StringBuilder sb = new StringBuilder();\n    parameters.stream().map(p -> itemParameter(title, p)).forEach(sb::append);\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "listParameter", "params": [{"name": "title", "type": "String"}, {"name": "parameters", "type": "List<Parameter>"}], "body": "                                                                           {\n    StringBuilder sb = new StringBuilder();\n    parameters.stream().map(p -> itemParameter(title, p)).forEach(sb::append);\n    return sb.toString();\n  }", "signature": "protected String listParameter(String title, List<Parameter> parameters)"}, {"syntax_pass": true, "original_string": "  protected String itemParameter(String title, Parameter parameter) {\n    return this.itemParameter(\n        title, parameter.getName(), parameter.getIn(), parameter.getDescription());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemParameter", "params": [{"name": "title", "type": "String"}, {"name": "parameter", "type": "Parameter"}], "body": "                                                                    {\n    return this.itemParameter(\n        title, parameter.getName(), parameter.getIn(), parameter.getDescription());\n  }", "signature": "protected String itemParameter(String title, Parameter parameter)"}, {"syntax_pass": true, "original_string": "  protected String itemParameter(String title, String name, String in, String description) {\n    return format(\"%s: \", title)\n        + code(name)\n        + \" in \"\n        + code(in)\n        + '\\n'\n        + metadata(description)\n        + '\\n';\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemParameter", "params": [{"name": "title", "type": "String"}, {"name": "name", "type": "String"}, {"name": "in", "type": "String"}, {"name": "description", "type": "String"}], "body": "                                                                                           {\n    return format(\"%s: \", title)\n        + code(name)\n        + \" in \"\n        + code(in)\n        + '\\n'\n        + metadata(description)\n        + '\\n';\n  }", "signature": "protected String itemParameter(String title, String name, String in, String description)"}, {"syntax_pass": true, "original_string": "  protected String itemParameter(ChangedParameter param) {\n    Parameter rightParam = param.getNewParameter();\n    if (param.isDeprecated()) {\n      return itemParameter(\n          \"Deprecated\", rightParam.getName(), rightParam.getIn(), rightParam.getDescription());\n    }\n    return itemParameter(\n        \"Changed\", rightParam.getName(), rightParam.getIn(), rightParam.getDescription());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "itemParameter", "params": [{"name": "param", "type": "ChangedParameter"}], "body": "                                                         {\n    Parameter rightParam = param.getNewParameter();\n    if (param.isDeprecated()) {\n      return itemParameter(\n          \"Deprecated\", rightParam.getName(), rightParam.getIn(), rightParam.getDescription());\n    }\n    return itemParameter(\n        \"Changed\", rightParam.getName(), rightParam.getIn(), rightParam.getDescription());\n  }", "signature": "protected String itemParameter(ChangedParameter param)"}, {"syntax_pass": true, "original_string": "  protected String code(String string) {\n    return CODE + string + CODE;\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "code", "params": [{"name": "string", "type": "String"}], "body": "                                       {\n    return CODE + string + CODE;\n  }", "signature": "protected String code(String string)"}, {"syntax_pass": true, "original_string": "  protected String metadata(String name, ChangedMetadata changedMetadata) {\n    return metadata(\"\", name, changedMetadata);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "metadata", "params": [{"name": "name", "type": "String"}, {"name": "changedMetadata", "type": "ChangedMetadata"}], "body": "                                                                          {\n    return metadata(\"\", name, changedMetadata);\n  }", "signature": "protected String metadata(String name, ChangedMetadata changedMetadata)"}, {"syntax_pass": true, "original_string": "  protected String metadata(String beginning, String name, ChangedMetadata changedMetadata) {\n    if (changedMetadata == null) {\n      return \"\";\n    }\n    if (!isUnchanged(changedMetadata) && showChangedMetadata) {\n      return format(\n          \"Changed %s:\\n%s\\nto:\\n%s\\n\\n\",\n          name,\n          metadata(beginning, changedMetadata.getLeft()),\n          metadata(beginning, changedMetadata.getRight()));\n    } else {\n      return metadata(beginning, name, changedMetadata.getRight());\n    }\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "metadata", "params": [{"name": "beginning", "type": "String"}, {"name": "name", "type": "String"}, {"name": "changedMetadata", "type": "ChangedMetadata"}], "body": "                                                                                            {\n    if (changedMetadata == null) {\n      return \"\";\n    }\n    if (!isUnchanged(changedMetadata) && showChangedMetadata) {\n      return format(\n          \"Changed %s:\\n%s\\nto:\\n%s\\n\\n\",\n          name,\n          metadata(beginning, changedMetadata.getLeft()),\n          metadata(beginning, changedMetadata.getRight()));\n    } else {\n      return metadata(beginning, name, changedMetadata.getRight());\n    }\n  }", "signature": "protected String metadata(String beginning, String name, ChangedMetadata changedMetadata)"}, {"syntax_pass": true, "original_string": "  protected String metadata(String metadata) {\n    return metadata(\"\", metadata);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "metadata", "params": [{"name": "metadata", "type": "String"}], "body": "                                             {\n    return metadata(\"\", metadata);\n  }", "signature": "protected String metadata(String metadata)"}, {"syntax_pass": true, "original_string": "  protected String metadata(String beginning, String name, String metadata) {\n    if (StringUtils.isBlank(metadata)) {\n      return \"\";\n    }\n    return blockquote(beginning, metadata);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "metadata", "params": [{"name": "beginning", "type": "String"}, {"name": "name", "type": "String"}, {"name": "metadata", "type": "String"}], "body": "                                                                            {\n    if (StringUtils.isBlank(metadata)) {\n      return \"\";\n    }\n    return blockquote(beginning, metadata);\n  }", "signature": "protected String metadata(String beginning, String name, String metadata)"}, {"syntax_pass": true, "original_string": "  protected String metadata(String beginning, String metadata) {\n    if (StringUtils.isBlank(metadata)) {\n      return \"\";\n    }\n    return blockquote(beginning, metadata);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "metadata", "params": [{"name": "beginning", "type": "String"}, {"name": "metadata", "type": "String"}], "body": "                                                               {\n    if (StringUtils.isBlank(metadata)) {\n      return \"\";\n    }\n    return blockquote(beginning, metadata);\n  }", "signature": "protected String metadata(String beginning, String metadata)"}, {"syntax_pass": true, "original_string": "  protected String blockquote(String beginning) {\n    return beginning + BLOCKQUOTE;\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "blockquote", "params": [{"name": "beginning", "type": "String"}], "body": "                                                {\n    return beginning + BLOCKQUOTE;\n  }", "signature": "protected String blockquote(String beginning)"}, {"syntax_pass": true, "original_string": "  protected String blockquote(String beginning, String text) {\n    String blockquote = blockquote(beginning);\n    return blockquote + text.trim().replace(\"\\n\", \"\\n\" + blockquote) + \"\\n\\n\";\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "blockquote", "params": [{"name": "beginning", "type": "String"}, {"name": "text", "type": "String"}], "body": "                                                             {\n    String blockquote = blockquote(beginning);\n    return blockquote + text.trim().replace(\"\\n\", \"\\n\" + blockquote) + \"\\n\\n\";\n  }", "signature": "protected String blockquote(String beginning, String text)"}, {"syntax_pass": true, "original_string": "  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "type", "params": [{"name": "schema", "type": "Schema<?>"}], "body": "                                          {\n    String result = \"object\";\n    if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }", "signature": "protected String type(Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  protected String indent(int deepness) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < deepness; i++) {\n      sb.append(PRE_LI);\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "indent", "params": [{"name": "deepness", "type": "int"}], "body": "                                        {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < deepness; i++) {\n      sb.append(PRE_LI);\n    }\n    return sb.toString();\n  }", "signature": "protected String indent(int deepness)"}, {"syntax_pass": true, "original_string": "  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Schema<?>", "classes": []}, "name": "resolve", "params": [{"name": "schema", "type": "Schema<?>"}], "body": "                                                {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }", "signature": "protected Schema<?> resolve(Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  public boolean isShowChangedMetadata() {\n    return this.showChangedMetadata;\n  }", "docstring": "\nA parameter which indicates whether or not metadata (summary and metadata) changes should be\nlogged in the changelog file.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isShowChangedMetadata", "params": [], "body": "                                         {\n    return this.showChangedMetadata;\n  }", "signature": "public boolean isShowChangedMetadata()"}, {"syntax_pass": true, "original_string": "  public void setShowChangedMetadata(final boolean showChangedMetadata) {\n    this.showChangedMetadata = showChangedMetadata;\n  }", "docstring": "\nA parameter which indicates whether or not metadata (summary and metadata) changes should be\nlogged in the changelog file.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setShowChangedMetadata", "params": [{"name": "showChangedMetadata", "type": "boolean"}], "body": "                                                                        {\n    this.showChangedMetadata = showChangedMetadata;\n  }", "signature": "public void setShowChangedMetadata(final boolean showChangedMetadata)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/output/Render.java", "original_string": "package org.openapitools.openapidiff.core.output;\n\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport org.openapitools.openapidiff.core.exception.RendererException;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\n\npublic interface Render {\n\n  void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter);\n\n  default void safelyAppend(OutputStreamWriter outputStreamWriter, String csq) {\n    try {\n      outputStreamWriter.append(csq);\n    } catch (IOException ex) {\n      throw new RendererException(ex);\n    }\n  }\n}\n", "file_hash": "ee35f6bad6c1c9f952e0834e16b887929df001798c2b4ffa2fa10e645bbb4c70", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.output;", "import java.io.IOException;", "import java.io.OutputStreamWriter;", "import org.openapitools.openapidiff.core.exception.RendererException;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Render {\n\n  void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter);\n\n  default void safelyAppend(OutputStreamWriter outputStreamWriter, String csq) {\n    try {\n      outputStreamWriter.append(csq);\n    } catch (IOException ex) {\n      throw new RendererException(ex);\n    }\n  }\n}", "definition": "public interface Render", "interface_docstring": "", "name": "Render", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "render", "params": [{"name": "diff", "type": "ChangedOpenApi"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "", "signature": "void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  default void safelyAppend(OutputStreamWriter outputStreamWriter, String csq) {\n    try {\n      outputStreamWriter.append(csq);\n    } catch (IOException ex) {\n      throw new RendererException(ex);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "void", "classes": []}, "name": "safelyAppend", "params": [{"name": "outputStreamWriter", "type": "OutputStreamWriter"}, {"name": "csq", "type": "String"}], "body": "                                                                               {\n    try {\n      outputStreamWriter.append(csq);\n    } catch (IOException ex) {\n      throw new RendererException(ex);\n    }\n  }", "signature": "default void safelyAppend(OutputStreamWriter outputStreamWriter, String csq)"}]}], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/output/HttpStatus.java", "original_string": "/*\n * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//httpclient/src/java/org/apache/commons/httpclient/HttpStatus.java,v 1.18 2004/05/02 11:21:13 olegk Exp $\n * $Revision: 480424 $\n * $Date: 2006-11-29 06:56:49 +0100 (Wed, 29 Nov 2006) $\n *\n * ====================================================================\n *\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\npackage org.openapitools.openapidiff.core.output;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Constants enumerating the HTTP status codes. All status codes defined in RFC1945 (HTTP/1.0,\n * RFC2616 (HTTP/1.1), and RFC2518 (WebDAV) are supported.\n */\npublic final class HttpStatus {\n\n  private static final Map<Integer, String> REASON_PHRASES = new HashMap<>();\n\n  static {\n    REASON_PHRASES.put(100, \"Continue\");\n    REASON_PHRASES.put(101, \"Switching Protocols\");\n    REASON_PHRASES.put(102, \"Processing\");\n    REASON_PHRASES.put(200, \"OK\");\n    REASON_PHRASES.put(201, \"Created\");\n    REASON_PHRASES.put(202, \"Accepted\");\n    REASON_PHRASES.put(203, \"Non Authoritative Information\");\n    REASON_PHRASES.put(204, \"No Content\");\n    REASON_PHRASES.put(205, \"Reset Content\");\n    REASON_PHRASES.put(206, \"Partial Content\");\n    REASON_PHRASES.put(207, \"Multi-Status\");\n    REASON_PHRASES.put(300, \"Multiple Choices\");\n    REASON_PHRASES.put(301, \"Moved Permanently\");\n    REASON_PHRASES.put(302, \"Moved Temporarily\");\n    REASON_PHRASES.put(303, \"See Other\");\n    REASON_PHRASES.put(304, \"Not Modified\");\n    REASON_PHRASES.put(305, \"Use Proxy\");\n    REASON_PHRASES.put(307, \"Temporary Redirect\");\n    REASON_PHRASES.put(400, \"Bad Request\");\n    REASON_PHRASES.put(401, \"Unauthorized\");\n    REASON_PHRASES.put(402, \"Payment Required\");\n    REASON_PHRASES.put(403, \"Forbidden\");\n    REASON_PHRASES.put(404, \"Not Found\");\n    REASON_PHRASES.put(405, \"Method Not Allowed\");\n    REASON_PHRASES.put(406, \"Not Acceptable\");\n    REASON_PHRASES.put(407, \"Proxy Authentication Required\");\n    REASON_PHRASES.put(408, \"Request Timeout\");\n    REASON_PHRASES.put(409, \"Conflict\");\n    REASON_PHRASES.put(410, \"Gone\");\n    REASON_PHRASES.put(411, \"Length Required\");\n    REASON_PHRASES.put(412, \"Precondition Failed\");\n    REASON_PHRASES.put(413, \"Request Too Long\");\n    REASON_PHRASES.put(414, \"Request-URI Too Long\");\n    REASON_PHRASES.put(415, \"Unsupported Media Type\");\n    REASON_PHRASES.put(416, \"Requested Range Not Satisfiable\");\n    REASON_PHRASES.put(417, \"Expectation Failed\");\n    REASON_PHRASES.put(419, \"Insufficient Space On Resource\");\n    REASON_PHRASES.put(420, \"Method Failure\");\n    REASON_PHRASES.put(422, \"Unprocessable Entity\");\n    REASON_PHRASES.put(423, \"Locked\");\n    REASON_PHRASES.put(424, \"Failed Dependency\");\n    REASON_PHRASES.put(500, \"Internal Server Error\");\n    REASON_PHRASES.put(501, \"Not Implemented\");\n    REASON_PHRASES.put(502, \"Bad Gateway\");\n    REASON_PHRASES.put(503, \"Service Unavailable\");\n    REASON_PHRASES.put(504, \"Gateway Timeout\");\n    REASON_PHRASES.put(505, \"Http Version Not Supported\");\n    REASON_PHRASES.put(507, \"Insufficient Storage\");\n  }\n\n  /**\n   * Get the reason phrase for a particular status code.\n   *\n   * <p>This method always returns the English text as specified in the relevant RFCs and is not\n   * internationalized.\n   *\n   * @param statusCode the numeric status code\n   * @return the reason phrase associated with the given status code or null if the status code is\n   *     not recognized.\n   */\n  public static String getReasonPhrase(int statusCode) {\n    if (statusCode < 0) {\n      throw new IllegalArgumentException(\"status code may not be negative\");\n    }\n    return REASON_PHRASES.get(statusCode);\n  }\n\n  private HttpStatus() {}\n}\n", "file_hash": "3b276a00791231c0557f6fa7be6a662675b6659beaa2b0f660faf92c03b3df8b", "file_docstring": "\n$Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//httpclient/src/java/org/apache/commons/httpclient/HttpStatus.java,v 1.18 2004/05/02 11:21:13 olegk Exp $\n$Revision: 480424 $\n$Date: 2006-11-29 06:56:49 +0100 (Wed, 29 Nov 2006) $\n\n====================================================================\n\n Licensed to the Apache Software Foundation (ASF) under one or more\n contributor license agreements.  See the NOTICE file distributed with\n this work for additional information regarding copyright ownership.\n The ASF licenses this file to You under the Apache License, Version 2.0\n (the \"License\"); you may not use this file except in compliance with\n the License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n====================================================================\n\nThis software consists of voluntary contributions made by many\nindividuals on behalf of the Apache Software Foundation.  For more\ninformation on the Apache Software Foundation, please see\n<http://www.apache.org/>.\n\n", "contexts": ["package org.openapitools.openapidiff.core.output;", "import java.util.HashMap;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public final class HttpStatus {\n\n  private static final Map<Integer, String> REASON_PHRASES = new HashMap<>();\n\n  static {\n    REASON_PHRASES.put(100, \"Continue\");\n    REASON_PHRASES.put(101, \"Switching Protocols\");\n    REASON_PHRASES.put(102, \"Processing\");\n    REASON_PHRASES.put(200, \"OK\");\n    REASON_PHRASES.put(201, \"Created\");\n    REASON_PHRASES.put(202, \"Accepted\");\n    REASON_PHRASES.put(203, \"Non Authoritative Information\");\n    REASON_PHRASES.put(204, \"No Content\");\n    REASON_PHRASES.put(205, \"Reset Content\");\n    REASON_PHRASES.put(206, \"Partial Content\");\n    REASON_PHRASES.put(207, \"Multi-Status\");\n    REASON_PHRASES.put(300, \"Multiple Choices\");\n    REASON_PHRASES.put(301, \"Moved Permanently\");\n    REASON_PHRASES.put(302, \"Moved Temporarily\");\n    REASON_PHRASES.put(303, \"See Other\");\n    REASON_PHRASES.put(304, \"Not Modified\");\n    REASON_PHRASES.put(305, \"Use Proxy\");\n    REASON_PHRASES.put(307, \"Temporary Redirect\");\n    REASON_PHRASES.put(400, \"Bad Request\");\n    REASON_PHRASES.put(401, \"Unauthorized\");\n    REASON_PHRASES.put(402, \"Payment Required\");\n    REASON_PHRASES.put(403, \"Forbidden\");\n    REASON_PHRASES.put(404, \"Not Found\");\n    REASON_PHRASES.put(405, \"Method Not Allowed\");\n    REASON_PHRASES.put(406, \"Not Acceptable\");\n    REASON_PHRASES.put(407, \"Proxy Authentication Required\");\n    REASON_PHRASES.put(408, \"Request Timeout\");\n    REASON_PHRASES.put(409, \"Conflict\");\n    REASON_PHRASES.put(410, \"Gone\");\n    REASON_PHRASES.put(411, \"Length Required\");\n    REASON_PHRASES.put(412, \"Precondition Failed\");\n    REASON_PHRASES.put(413, \"Request Too Long\");\n    REASON_PHRASES.put(414, \"Request-URI Too Long\");\n    REASON_PHRASES.put(415, \"Unsupported Media Type\");\n    REASON_PHRASES.put(416, \"Requested Range Not Satisfiable\");\n    REASON_PHRASES.put(417, \"Expectation Failed\");\n    REASON_PHRASES.put(419, \"Insufficient Space On Resource\");\n    REASON_PHRASES.put(420, \"Method Failure\");\n    REASON_PHRASES.put(422, \"Unprocessable Entity\");\n    REASON_PHRASES.put(423, \"Locked\");\n    REASON_PHRASES.put(424, \"Failed Dependency\");\n    REASON_PHRASES.put(500, \"Internal Server Error\");\n    REASON_PHRASES.put(501, \"Not Implemented\");\n    REASON_PHRASES.put(502, \"Bad Gateway\");\n    REASON_PHRASES.put(503, \"Service Unavailable\");\n    REASON_PHRASES.put(504, \"Gateway Timeout\");\n    REASON_PHRASES.put(505, \"Http Version Not Supported\");\n    REASON_PHRASES.put(507, \"Insufficient Storage\");\n  }\n\n  /**\n   * Get the reason phrase for a particular status code.\n   *\n   * <p>This method always returns the English text as specified in the relevant RFCs and is not\n   * internationalized.\n   *\n   * @param statusCode the numeric status code\n   * @return the reason phrase associated with the given status code or null if the status code is\n   *     not recognized.\n   */\n  public static String getReasonPhrase(int statusCode) {\n    if (statusCode < 0) {\n      throw new IllegalArgumentException(\"status code may not be negative\");\n    }\n    return REASON_PHRASES.get(statusCode);\n  }\n\n  private HttpStatus() {}\n}", "definition": "public final class HttpStatus", "class_docstring": "\nConstants enumerating the HTTP status codes. All status codes defined in RFC1945 (HTTP/1.0,\nRFC2616 (HTTP/1.1), and RFC2518 (WebDAV) are supported.\n", "name": "HttpStatus", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private static final Map<Integer, String> REASON_PHRASES = new HashMap<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<Integer, String>", "name": "REASON_PHRASES = new HashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public static String getReasonPhrase(int statusCode) {\n    if (statusCode < 0) {\n      throw new IllegalArgumentException(\"status code may not be negative\");\n    }\n    return REASON_PHRASES.get(statusCode);\n  }", "docstring": "\nGet the reason phrase for a particular status code.\n\n<p>This method always returns the English text as specified in the relevant RFCs and is not\ninternationalized.\n\n@param statusCode the numeric status code\n@return the reason phrase associated with the given status code or null if the status code is\n    not recognized.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "getReasonPhrase", "params": [{"name": "statusCode", "type": "int"}], "body": "                                                       {\n    if (statusCode < 0) {\n      throw new IllegalArgumentException(\"status code may not be negative\");\n    }\n    return REASON_PHRASES.get(statusCode);\n  }", "signature": "public static String getReasonPhrase(int statusCode)"}, {"syntax_pass": true, "original_string": "  private HttpStatus() {}", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "HttpStatus", "params": [], "body": "                       {}", "signature": "private HttpStatus()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/output/HtmlRender.java", "original_string": "package org.openapitools.openapidiff.core.output;\n\nimport static j2html.TagCreator.body;\nimport static j2html.TagCreator.del;\nimport static j2html.TagCreator.div;\nimport static j2html.TagCreator.document;\nimport static j2html.TagCreator.h1;\nimport static j2html.TagCreator.h2;\nimport static j2html.TagCreator.h3;\nimport static j2html.TagCreator.head;\nimport static j2html.TagCreator.header;\nimport static j2html.TagCreator.hr;\nimport static j2html.TagCreator.html;\nimport static j2html.TagCreator.li;\nimport static j2html.TagCreator.link;\nimport static j2html.TagCreator.meta;\nimport static j2html.TagCreator.ol;\nimport static j2html.TagCreator.p;\nimport static j2html.TagCreator.span;\nimport static j2html.TagCreator.title;\nimport static j2html.TagCreator.ul;\nimport static org.openapitools.openapidiff.core.model.Changed.result;\n\nimport io.swagger.v3.oas.models.media.ArraySchema;\nimport io.swagger.v3.oas.models.media.MediaType;\nimport io.swagger.v3.oas.models.media.Schema;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport io.swagger.v3.oas.models.security.SecurityRequirement;\nimport j2html.rendering.FlatHtml;\nimport j2html.tags.ContainerTag;\nimport j2html.tags.specialized.DivTag;\nimport j2html.tags.specialized.HtmlTag;\nimport j2html.tags.specialized.LiTag;\nimport j2html.tags.specialized.OlTag;\nimport j2html.tags.specialized.UlTag;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.exception.RendererException;\nimport org.openapitools.openapidiff.core.model.ChangedApiResponse;\nimport org.openapitools.openapidiff.core.model.ChangedContent;\nimport org.openapitools.openapidiff.core.model.ChangedMediaType;\nimport org.openapitools.openapidiff.core.model.ChangedMetadata;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.model.ChangedOperation;\nimport org.openapitools.openapidiff.core.model.ChangedParameter;\nimport org.openapitools.openapidiff.core.model.ChangedParameters;\nimport org.openapitools.openapidiff.core.model.ChangedResponse;\nimport org.openapitools.openapidiff.core.model.ChangedSchema;\nimport org.openapitools.openapidiff.core.model.ChangedSecurityRequirement;\nimport org.openapitools.openapidiff.core.model.ChangedSecurityRequirements;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.DiffResult;\nimport org.openapitools.openapidiff.core.model.Endpoint;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\npublic class HtmlRender implements Render {\n\n  private static final RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  public static final String COMMENT = \"comment\";\n  public static final String MISSING = \"missing\";\n\n  private final String title;\n  private final String linkCss;\n  private final boolean showAllChanges;\n  protected ChangedOpenApi diff;\n\n  public HtmlRender() {\n    this(\"Api Change Log\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n  }\n\n  public HtmlRender(boolean showAllChanges) {\n    this(\"Api Change Log\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\", showAllChanges);\n  }\n\n  public HtmlRender(String title, String linkCss) {\n    this.title = title;\n    this.linkCss = linkCss;\n    this.showAllChanges = false;\n  }\n\n  public HtmlRender(String title, String linkCss, boolean showAllChanges) {\n    this.title = title;\n    this.linkCss = linkCss;\n    this.showAllChanges = showAllChanges;\n  }\n\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n\n    List<Endpoint> newEndpoints = diff.getNewEndpoints();\n    OlTag ol_newEndpoint = ol_newEndpoint(newEndpoints);\n\n    List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n    OlTag ol_missingEndpoint = ol_missingEndpoint(missingEndpoints);\n\n    List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n    OlTag ol_deprecatedEndpoint = ol_deprecatedEndpoint(deprecatedEndpoints);\n\n    List<ChangedOperation> changedOperations = diff.getChangedOperations();\n    OlTag ol_changed = ol_changed(changedOperations);\n\n    renderHtml(\n        ol_newEndpoint, ol_missingEndpoint, ol_deprecatedEndpoint, ol_changed, outputStreamWriter);\n  }\n\n  public void renderHtml(\n      OlTag ol_new,\n      OlTag ol_miss,\n      OlTag ol_deprec,\n      OlTag ol_changed,\n      OutputStreamWriter outputStreamWriter) {\n    HtmlTag html =\n        html()\n            .attr(\"lang\", \"en\")\n            .with(\n                head()\n                    .with(\n                        meta().withCharset(\"utf-8\"),\n                        title(title),\n                        link().withRel(\"stylesheet\").withHref(linkCss)),\n                body()\n                    .with(\n                        header().with(h1(title)),\n                        div()\n                            .withClass(\"article\")\n                            .with(\n                                div().with(h2(\"What's New\"), hr(), ol_new),\n                                div().with(h2(\"What's Deleted\"), hr(), ol_miss),\n                                div().with(h2(\"What's Deprecated\"), hr(), ol_deprec),\n                                div().with(h2(\"What's Changed\"), hr(), ol_changed))));\n\n    try {\n      FlatHtml<OutputStreamWriter> flatHtml = FlatHtml.into(outputStreamWriter);\n      document().render(flatHtml);\n      html.render(flatHtml);\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(\"Problem rendering html document.\", e);\n    }\n  }\n\n  private OlTag ol_newEndpoint(List<Endpoint> endpoints) {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_newEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }\n\n  private LiTag li_newEndpoint(String method, String path, String desc) {\n    return li().with(span(method).withClass(method)).withText(path + \" \").with(span(desc));\n  }\n\n  private OlTag ol_missingEndpoint(List<Endpoint> endpoints) {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_missingEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }\n\n  private LiTag li_missingEndpoint(String method, String path, String desc) {\n    return li().with(span(method).withClass(method), del().withText(path)).with(span(\" \" + desc));\n  }\n\n  private OlTag ol_deprecatedEndpoint(List<Endpoint> endpoints) {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_deprecatedEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }\n\n  private LiTag li_deprecatedEndpoint(String method, String path, String desc) {\n    return li().with(span(method).withClass(method), del().withText(path)).with(span(\" \" + desc));\n  }\n\n  private OlTag ol_changed(List<ChangedOperation> changedOperations) {\n    if (null == changedOperations) return ol();\n    OlTag ol = ol();\n    for (ChangedOperation changedOperation : changedOperations) {\n      String pathUrl = changedOperation.getPathUrl();\n      String method = changedOperation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(changedOperation.getSummary())\n              .map(ChangedMetadata::getRight)\n              .orElse(\"\");\n\n      UlTag ul_detail = ul().withClass(\"detail\");\n      if (result(changedOperation.getParameters()).isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Parameters\")).with(ul_param(changedOperation.getParameters())));\n      }\n      if (changedOperation.resultRequestBody().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Request\"))\n                .with(ul_request(changedOperation.getRequestBody().getContent())));\n      }\n      if (changedOperation.resultApiResponses().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Response\")).with(ul_response(changedOperation.getApiResponses())));\n      }\n      if (showAllChanges && changedOperation.resultSecurityRequirements().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Security Requirements\"))\n                .with(ul_securityRequirements(changedOperation.getSecurityRequirements())));\n      }\n      ol.with(\n          li().with(span(method).withClass(method))\n              .withText(pathUrl + \" \")\n              .with(span(desc))\n              .with(ul_detail));\n    }\n    return ol;\n  }\n\n  private UlTag ul_securityRequirements(ChangedSecurityRequirements changedSecurityRequirements) {\n    List<SecurityRequirement> addRequirements = changedSecurityRequirements.getIncreased();\n    List<SecurityRequirement> delRequirements = changedSecurityRequirements.getMissing();\n    List<ChangedSecurityRequirement> changedRequirements = changedSecurityRequirements.getChanged();\n    UlTag ul = ul().withClass(\"change security requirements\");\n    if (addRequirements != null) {\n      for (SecurityRequirement addRequirement : addRequirements) {\n        ul.with(li_addSecurityRequirement(addRequirement));\n      }\n    }\n    if (delRequirements != null) {\n      for (SecurityRequirement delRequirement : delRequirements) {\n        ul.with(li_missingSecurityRequirement(delRequirement));\n      }\n    }\n    if (changedRequirements != null) {\n      for (ChangedSecurityRequirement changedRequirement : changedRequirements) {\n        ul.with(li_changedSecurityRequirement(changedRequirement));\n      }\n    }\n\n    return ul;\n  }\n\n  private LiTag li_addSecurityRequirement(SecurityRequirement securityRequirement) {\n    return li().withText(\"New security requirement : \")\n        .with(span(null == securityRequirement.toString() ? \"\" : (securityRequirement.toString())));\n  }\n\n  private LiTag li_missingSecurityRequirement(SecurityRequirement securityRequirement) {\n    return li().withText(\"Deleted security requirement : \")\n        .with(span(null == securityRequirement.toString() ? \"\" : (securityRequirement.toString())));\n  }\n\n  private LiTag li_changedSecurityRequirement(\n      ChangedSecurityRequirement changedSecurityRequirement) {\n    return li().withText(String.format(\"Changed security requirement : \"))\n        .with(\n            span(\n                (null == changedSecurityRequirement.getNewSecurityRequirement()\n                        || null\n                            == changedSecurityRequirement.getNewSecurityRequirement().toString())\n                    ? \"\"\n                    : (changedSecurityRequirement.getNewSecurityRequirement().toString())));\n  }\n\n  private UlTag ul_response(ChangedApiResponse changedApiResponse) {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    UlTag ul = ul().withClass(\"change response\");\n    for (Entry<String, ApiResponse> prop : addResponses.entrySet()) {\n      ul.with(li_addResponse(prop.getKey(), prop.getValue()));\n    }\n    for (Entry<String, ApiResponse> prop : delResponses.entrySet()) {\n      ul.with(li_missingResponse(prop.getKey(), prop.getValue()));\n    }\n    for (Entry<String, ChangedResponse> prop : changedResponses.entrySet()) {\n      ul.with(li_changedResponse(prop.getKey(), prop.getValue()));\n    }\n    return ul;\n  }\n\n  private LiTag li_addResponse(String name, ApiResponse response) {\n    return li().withText(String.format(\"New response : [%s]\", name))\n        .with(\n            span(null == response.getDescription() ? \"\" : (\"//\" + response.getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_missingResponse(String name, ApiResponse response) {\n    return li().withText(String.format(\"Deleted response : [%s]\", name))\n        .with(\n            span(null == response.getDescription() ? \"\" : (\"//\" + response.getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_changedResponse(String name, ChangedResponse response) {\n    return li().withText(String.format(\"Changed response : [%s]\", name))\n        .with(\n            span((null == response.getNewApiResponse()\n                        || null == response.getNewApiResponse().getDescription())\n                    ? \"\"\n                    : (\"//\" + response.getNewApiResponse().getDescription()))\n                .withClass(COMMENT))\n        .with(ul_request(response.getContent()));\n  }\n\n  private UlTag ul_request(ChangedContent changedContent) {\n    UlTag ul = ul().withClass(\"change request-body\");\n    if (changedContent != null) {\n      for (String propName : changedContent.getIncreased().keySet()) {\n        ul.with(li_addRequest(propName, changedContent.getIncreased().get(propName)));\n      }\n      for (String propName : changedContent.getMissing().keySet()) {\n        ul.with(li_missingRequest(propName, changedContent.getMissing().get(propName)));\n      }\n      for (String propName : changedContent.getChanged().keySet()) {\n        ul.with(li_changedRequest(propName, changedContent.getChanged().get(propName)));\n      }\n    }\n    return ul;\n  }\n\n  private LiTag li_addRequest(String name, MediaType request) {\n    return li().withText(String.format(\"New body: '%s'\", name));\n  }\n\n  private LiTag li_missingRequest(String name, MediaType request) {\n    return li().withText(String.format(\"Deleted body: '%s'\", name));\n  }\n\n  private LiTag li_changedRequest(String name, ChangedMediaType request) {\n    LiTag li =\n        li().with(div_changedSchema(request.getSchema()))\n            .withText(String.format(\"Changed body: '%s'\", name));\n    if (request.isIncompatible() && !showAllChanges) {\n      incompatibilities(li, request.getSchema());\n    } else if (showAllChanges) {\n      allChanges(li, request.getSchema());\n    }\n    return li;\n  }\n\n  private DivTag div_changedSchema(ChangedSchema schema) {\n    DivTag div = div();\n    div.with(h3(\"Schema\" + (schema.isIncompatible() ? \" incompatible\" : \"\")));\n    return div;\n  }\n\n  private void allChanges(final LiTag output, final ChangedSchema schema) {\n    allChanges(output, \"\", schema);\n  }\n\n  private void allChanges(\n      final ContainerTag<?> output, String propName, final ChangedSchema schema) {\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    properties(\n        output, prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext());\n    properties(\n        output, prefix, \"Added property\", schema.getIncreasedProperties(), schema.getContext());\n\n    propertiesChanged(\n        output, prefix, \"Changed property\", schema.getChangedProperties(), schema.getContext());\n    if (schema.getItems() != null) {\n      itemsAllChanges(output, propName, schema.getItems());\n    }\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> allChanges(output, prefix + name, property));\n  }\n\n  private void incompatibilities(final LiTag output, final ChangedSchema schema) {\n    incompatibilities(output, \"\", schema);\n  }\n\n  private void incompatibilities(\n      final ContainerTag<?> output, String propName, final ChangedSchema schema) {\n    if (schema.getItems() != null) {\n      items(output, propName, schema.getItems());\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      property(output, propName, \"Changed property type\", type);\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    properties(\n        output, prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext());\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> incompatibilities(output, prefix + name, property));\n  }\n\n  private void items(ContainerTag<?> output, String propName, ChangedSchema schema) {\n    incompatibilities(output, propName + \"[n]\", schema);\n  }\n\n  private void itemsAllChanges(ContainerTag<?> output, String propName, ChangedSchema schema) {\n    allChanges(output, propName + \"[n]\", schema);\n  }\n\n  private void properties(\n      ContainerTag<?> output,\n      String propPrefix,\n      String title,\n      Map<String, Schema<?>> properties,\n      DiffContext context) {\n    if (properties != null) {\n      properties.forEach((key, value) -> resolveProperty(output, propPrefix, key, value, title));\n    }\n  }\n\n  private void propertiesChanged(\n      ContainerTag<?> output,\n      String propPrefix,\n      String title,\n      Map<String, ChangedSchema> properties,\n      DiffContext context) {\n    if (properties != null) {\n      properties.forEach((key, value) -> resolveProperty(output, propPrefix, key, value, title));\n    }\n  }\n\n  private void resolveProperty(\n      ContainerTag<?> output, String propPrefix, String key, Schema<?> value, String title) {\n    try {\n      property(output, propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      property(output, propPrefix + key, title, type(value));\n    }\n  }\n\n  private void resolveProperty(\n      ContainerTag<?> output, String propPrefix, String key, ChangedSchema value, String title) {\n    try {\n      property(output, propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      property(output, propPrefix + key, title, type(value));\n    }\n  }\n\n  protected void property(ContainerTag<?> output, String name, String title, Schema<?> schema) {\n    property(output, name, title, type(schema));\n  }\n\n  protected void property(ContainerTag<?> output, String name, String title, String type) {\n    output.with(p(String.format(\"%s: %s (%s)\", title, name, type)).withClass(MISSING));\n  }\n\n  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }\n\n  protected Schema<?> resolve(ChangedSchema schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(),\n        schema.getNewSchema(),\n        schema.getNewSchema().get$ref());\n  }\n\n  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }\n\n  protected String type(ChangedSchema schema) {\n    return type(schema.getNewSchema());\n  }\n\n  private UlTag ul_param(ChangedParameters changedParameters) {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    UlTag ul = ul().withClass(\"change param\");\n    for (Parameter param : addParameters) {\n      ul.with(li_addParam(param));\n    }\n    for (ChangedParameter param : changed) {\n      ul.with(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      ul.with(li_missingParam(param));\n    }\n    return ul;\n  }\n\n  private LiTag li_addParam(Parameter param) {\n    return li().withText(\"Add \" + param.getName() + \" in \" + param.getIn())\n        .with(\n            span(null == param.getDescription() ? \"\" : (\"//\" + param.getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_missingParam(Parameter param) {\n    return li().withClass(MISSING)\n        .with(span(\"Delete\"))\n        .with(del(param.getName()))\n        .with(span(\"in \").withText(param.getIn()))\n        .with(\n            span(null == param.getDescription() ? \"\" : (\"//\" + param.getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_deprecatedParam(ChangedParameter param) {\n    return li().withClass(MISSING)\n        .with(span(\"Deprecated\"))\n        .with(del(param.getName()))\n        .with(span(\"in \").withText(param.getIn()))\n        .with(\n            span(null == param.getNewParameter().getDescription()\n                    ? \"\"\n                    : (\"//\" + param.getNewParameter().getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_changedParam(ChangedParameter changeParam) {\n    if (changeParam.isDeprecated()) {\n      return li_deprecatedParam(changeParam);\n    }\n    boolean changeRequired = changeParam.isChangeRequired();\n    boolean changeDescription =\n        Optional.ofNullable(changeParam.getDescription())\n            .map(ChangedMetadata::isDifferent)\n            .orElse(false);\n    Parameter rightParam = changeParam.getNewParameter();\n    Parameter leftParam = changeParam.getOldParameter();\n    LiTag li = li().withText(changeParam.getName() + \" in \" + changeParam.getIn());\n    if (changeRequired) {\n      li.withText(\n          \" change into \"\n              + (rightParam.getRequired() != null && rightParam.getRequired()\n                  ? \"required\"\n                  : \"not required\"));\n    }\n    if (changeDescription) {\n      li.withText(\" Notes \")\n          .with(del(leftParam.getDescription()).withClass(COMMENT))\n          .withText(\" change into \")\n          .with(span(rightParam.getDescription()).withClass(COMMENT));\n    }\n    return li;\n  }\n}\n", "file_hash": "100e973b7167caf65d78c9f0017ae3666d73c34bf34cf08bdcbda9d3f2389aa4", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.output;", "import static j2html.TagCreator.body;", "import static j2html.TagCreator.del;", "import static j2html.TagCreator.div;", "import static j2html.TagCreator.document;", "import static j2html.TagCreator.h1;", "import static j2html.TagCreator.h2;", "import static j2html.TagCreator.h3;", "import static j2html.TagCreator.head;", "import static j2html.TagCreator.header;", "import static j2html.TagCreator.hr;", "import static j2html.TagCreator.html;", "import static j2html.TagCreator.li;", "import static j2html.TagCreator.link;", "import static j2html.TagCreator.meta;", "import static j2html.TagCreator.ol;", "import static j2html.TagCreator.p;", "import static j2html.TagCreator.span;", "import static j2html.TagCreator.title;", "import static j2html.TagCreator.ul;", "import static org.openapitools.openapidiff.core.model.Changed.result;", "import io.swagger.v3.oas.models.media.ArraySchema;", "import io.swagger.v3.oas.models.media.MediaType;", "import io.swagger.v3.oas.models.media.Schema;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import io.swagger.v3.oas.models.security.SecurityRequirement;", "import j2html.rendering.FlatHtml;", "import j2html.tags.ContainerTag;", "import j2html.tags.specialized.DivTag;", "import j2html.tags.specialized.HtmlTag;", "import j2html.tags.specialized.LiTag;", "import j2html.tags.specialized.OlTag;", "import j2html.tags.specialized.UlTag;", "import java.io.IOException;", "import java.io.OutputStreamWriter;", "import java.util.List;", "import java.util.Map;", "import java.util.Map.Entry;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.exception.RendererException;", "import org.openapitools.openapidiff.core.model.ChangedApiResponse;", "import org.openapitools.openapidiff.core.model.ChangedContent;", "import org.openapitools.openapidiff.core.model.ChangedMediaType;", "import org.openapitools.openapidiff.core.model.ChangedMetadata;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.model.ChangedOperation;", "import org.openapitools.openapidiff.core.model.ChangedParameter;", "import org.openapitools.openapidiff.core.model.ChangedParameters;", "import org.openapitools.openapidiff.core.model.ChangedResponse;", "import org.openapitools.openapidiff.core.model.ChangedSchema;", "import org.openapitools.openapidiff.core.model.ChangedSecurityRequirement;", "import org.openapitools.openapidiff.core.model.ChangedSecurityRequirements;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.DiffResult;", "import org.openapitools.openapidiff.core.model.Endpoint;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "public class HtmlRender implements Render {\n\n  private static final RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  public static final String COMMENT = \"comment\";\n  public static final String MISSING = \"missing\";\n\n  private final String title;\n  private final String linkCss;\n  private final boolean showAllChanges;\n  protected ChangedOpenApi diff;\n\n  public HtmlRender() {\n    this(\"Api Change Log\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n  }\n\n  public HtmlRender(boolean showAllChanges) {\n    this(\"Api Change Log\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\", showAllChanges);\n  }\n\n  public HtmlRender(String title, String linkCss) {\n    this.title = title;\n    this.linkCss = linkCss;\n    this.showAllChanges = false;\n  }\n\n  public HtmlRender(String title, String linkCss, boolean showAllChanges) {\n    this.title = title;\n    this.linkCss = linkCss;\n    this.showAllChanges = showAllChanges;\n  }\n\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n\n    List<Endpoint> newEndpoints = diff.getNewEndpoints();\n    OlTag ol_newEndpoint = ol_newEndpoint(newEndpoints);\n\n    List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n    OlTag ol_missingEndpoint = ol_missingEndpoint(missingEndpoints);\n\n    List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n    OlTag ol_deprecatedEndpoint = ol_deprecatedEndpoint(deprecatedEndpoints);\n\n    List<ChangedOperation> changedOperations = diff.getChangedOperations();\n    OlTag ol_changed = ol_changed(changedOperations);\n\n    renderHtml(\n        ol_newEndpoint, ol_missingEndpoint, ol_deprecatedEndpoint, ol_changed, outputStreamWriter);\n  }\n\n  public void renderHtml(\n      OlTag ol_new,\n      OlTag ol_miss,\n      OlTag ol_deprec,\n      OlTag ol_changed,\n      OutputStreamWriter outputStreamWriter) {\n    HtmlTag html =\n        html()\n            .attr(\"lang\", \"en\")\n            .with(\n                head()\n                    .with(\n                        meta().withCharset(\"utf-8\"),\n                        title(title),\n                        link().withRel(\"stylesheet\").withHref(linkCss)),\n                body()\n                    .with(\n                        header().with(h1(title)),\n                        div()\n                            .withClass(\"article\")\n                            .with(\n                                div().with(h2(\"What's New\"), hr(), ol_new),\n                                div().with(h2(\"What's Deleted\"), hr(), ol_miss),\n                                div().with(h2(\"What's Deprecated\"), hr(), ol_deprec),\n                                div().with(h2(\"What's Changed\"), hr(), ol_changed))));\n\n    try {\n      FlatHtml<OutputStreamWriter> flatHtml = FlatHtml.into(outputStreamWriter);\n      document().render(flatHtml);\n      html.render(flatHtml);\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(\"Problem rendering html document.\", e);\n    }\n  }\n\n  private OlTag ol_newEndpoint(List<Endpoint> endpoints) {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_newEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }\n\n  private LiTag li_newEndpoint(String method, String path, String desc) {\n    return li().with(span(method).withClass(method)).withText(path + \" \").with(span(desc));\n  }\n\n  private OlTag ol_missingEndpoint(List<Endpoint> endpoints) {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_missingEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }\n\n  private LiTag li_missingEndpoint(String method, String path, String desc) {\n    return li().with(span(method).withClass(method), del().withText(path)).with(span(\" \" + desc));\n  }\n\n  private OlTag ol_deprecatedEndpoint(List<Endpoint> endpoints) {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_deprecatedEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }\n\n  private LiTag li_deprecatedEndpoint(String method, String path, String desc) {\n    return li().with(span(method).withClass(method), del().withText(path)).with(span(\" \" + desc));\n  }\n\n  private OlTag ol_changed(List<ChangedOperation> changedOperations) {\n    if (null == changedOperations) return ol();\n    OlTag ol = ol();\n    for (ChangedOperation changedOperation : changedOperations) {\n      String pathUrl = changedOperation.getPathUrl();\n      String method = changedOperation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(changedOperation.getSummary())\n              .map(ChangedMetadata::getRight)\n              .orElse(\"\");\n\n      UlTag ul_detail = ul().withClass(\"detail\");\n      if (result(changedOperation.getParameters()).isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Parameters\")).with(ul_param(changedOperation.getParameters())));\n      }\n      if (changedOperation.resultRequestBody().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Request\"))\n                .with(ul_request(changedOperation.getRequestBody().getContent())));\n      }\n      if (changedOperation.resultApiResponses().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Response\")).with(ul_response(changedOperation.getApiResponses())));\n      }\n      if (showAllChanges && changedOperation.resultSecurityRequirements().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Security Requirements\"))\n                .with(ul_securityRequirements(changedOperation.getSecurityRequirements())));\n      }\n      ol.with(\n          li().with(span(method).withClass(method))\n              .withText(pathUrl + \" \")\n              .with(span(desc))\n              .with(ul_detail));\n    }\n    return ol;\n  }\n\n  private UlTag ul_securityRequirements(ChangedSecurityRequirements changedSecurityRequirements) {\n    List<SecurityRequirement> addRequirements = changedSecurityRequirements.getIncreased();\n    List<SecurityRequirement> delRequirements = changedSecurityRequirements.getMissing();\n    List<ChangedSecurityRequirement> changedRequirements = changedSecurityRequirements.getChanged();\n    UlTag ul = ul().withClass(\"change security requirements\");\n    if (addRequirements != null) {\n      for (SecurityRequirement addRequirement : addRequirements) {\n        ul.with(li_addSecurityRequirement(addRequirement));\n      }\n    }\n    if (delRequirements != null) {\n      for (SecurityRequirement delRequirement : delRequirements) {\n        ul.with(li_missingSecurityRequirement(delRequirement));\n      }\n    }\n    if (changedRequirements != null) {\n      for (ChangedSecurityRequirement changedRequirement : changedRequirements) {\n        ul.with(li_changedSecurityRequirement(changedRequirement));\n      }\n    }\n\n    return ul;\n  }\n\n  private LiTag li_addSecurityRequirement(SecurityRequirement securityRequirement) {\n    return li().withText(\"New security requirement : \")\n        .with(span(null == securityRequirement.toString() ? \"\" : (securityRequirement.toString())));\n  }\n\n  private LiTag li_missingSecurityRequirement(SecurityRequirement securityRequirement) {\n    return li().withText(\"Deleted security requirement : \")\n        .with(span(null == securityRequirement.toString() ? \"\" : (securityRequirement.toString())));\n  }\n\n  private LiTag li_changedSecurityRequirement(\n      ChangedSecurityRequirement changedSecurityRequirement) {\n    return li().withText(String.format(\"Changed security requirement : \"))\n        .with(\n            span(\n                (null == changedSecurityRequirement.getNewSecurityRequirement()\n                        || null\n                            == changedSecurityRequirement.getNewSecurityRequirement().toString())\n                    ? \"\"\n                    : (changedSecurityRequirement.getNewSecurityRequirement().toString())));\n  }\n\n  private UlTag ul_response(ChangedApiResponse changedApiResponse) {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    UlTag ul = ul().withClass(\"change response\");\n    for (Entry<String, ApiResponse> prop : addResponses.entrySet()) {\n      ul.with(li_addResponse(prop.getKey(), prop.getValue()));\n    }\n    for (Entry<String, ApiResponse> prop : delResponses.entrySet()) {\n      ul.with(li_missingResponse(prop.getKey(), prop.getValue()));\n    }\n    for (Entry<String, ChangedResponse> prop : changedResponses.entrySet()) {\n      ul.with(li_changedResponse(prop.getKey(), prop.getValue()));\n    }\n    return ul;\n  }\n\n  private LiTag li_addResponse(String name, ApiResponse response) {\n    return li().withText(String.format(\"New response : [%s]\", name))\n        .with(\n            span(null == response.getDescription() ? \"\" : (\"//\" + response.getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_missingResponse(String name, ApiResponse response) {\n    return li().withText(String.format(\"Deleted response : [%s]\", name))\n        .with(\n            span(null == response.getDescription() ? \"\" : (\"//\" + response.getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_changedResponse(String name, ChangedResponse response) {\n    return li().withText(String.format(\"Changed response : [%s]\", name))\n        .with(\n            span((null == response.getNewApiResponse()\n                        || null == response.getNewApiResponse().getDescription())\n                    ? \"\"\n                    : (\"//\" + response.getNewApiResponse().getDescription()))\n                .withClass(COMMENT))\n        .with(ul_request(response.getContent()));\n  }\n\n  private UlTag ul_request(ChangedContent changedContent) {\n    UlTag ul = ul().withClass(\"change request-body\");\n    if (changedContent != null) {\n      for (String propName : changedContent.getIncreased().keySet()) {\n        ul.with(li_addRequest(propName, changedContent.getIncreased().get(propName)));\n      }\n      for (String propName : changedContent.getMissing().keySet()) {\n        ul.with(li_missingRequest(propName, changedContent.getMissing().get(propName)));\n      }\n      for (String propName : changedContent.getChanged().keySet()) {\n        ul.with(li_changedRequest(propName, changedContent.getChanged().get(propName)));\n      }\n    }\n    return ul;\n  }\n\n  private LiTag li_addRequest(String name, MediaType request) {\n    return li().withText(String.format(\"New body: '%s'\", name));\n  }\n\n  private LiTag li_missingRequest(String name, MediaType request) {\n    return li().withText(String.format(\"Deleted body: '%s'\", name));\n  }\n\n  private LiTag li_changedRequest(String name, ChangedMediaType request) {\n    LiTag li =\n        li().with(div_changedSchema(request.getSchema()))\n            .withText(String.format(\"Changed body: '%s'\", name));\n    if (request.isIncompatible() && !showAllChanges) {\n      incompatibilities(li, request.getSchema());\n    } else if (showAllChanges) {\n      allChanges(li, request.getSchema());\n    }\n    return li;\n  }\n\n  private DivTag div_changedSchema(ChangedSchema schema) {\n    DivTag div = div();\n    div.with(h3(\"Schema\" + (schema.isIncompatible() ? \" incompatible\" : \"\")));\n    return div;\n  }\n\n  private void allChanges(final LiTag output, final ChangedSchema schema) {\n    allChanges(output, \"\", schema);\n  }\n\n  private void allChanges(\n      final ContainerTag<?> output, String propName, final ChangedSchema schema) {\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    properties(\n        output, prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext());\n    properties(\n        output, prefix, \"Added property\", schema.getIncreasedProperties(), schema.getContext());\n\n    propertiesChanged(\n        output, prefix, \"Changed property\", schema.getChangedProperties(), schema.getContext());\n    if (schema.getItems() != null) {\n      itemsAllChanges(output, propName, schema.getItems());\n    }\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> allChanges(output, prefix + name, property));\n  }\n\n  private void incompatibilities(final LiTag output, final ChangedSchema schema) {\n    incompatibilities(output, \"\", schema);\n  }\n\n  private void incompatibilities(\n      final ContainerTag<?> output, String propName, final ChangedSchema schema) {\n    if (schema.getItems() != null) {\n      items(output, propName, schema.getItems());\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      property(output, propName, \"Changed property type\", type);\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    properties(\n        output, prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext());\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> incompatibilities(output, prefix + name, property));\n  }\n\n  private void items(ContainerTag<?> output, String propName, ChangedSchema schema) {\n    incompatibilities(output, propName + \"[n]\", schema);\n  }\n\n  private void itemsAllChanges(ContainerTag<?> output, String propName, ChangedSchema schema) {\n    allChanges(output, propName + \"[n]\", schema);\n  }\n\n  private void properties(\n      ContainerTag<?> output,\n      String propPrefix,\n      String title,\n      Map<String, Schema<?>> properties,\n      DiffContext context) {\n    if (properties != null) {\n      properties.forEach((key, value) -> resolveProperty(output, propPrefix, key, value, title));\n    }\n  }\n\n  private void propertiesChanged(\n      ContainerTag<?> output,\n      String propPrefix,\n      String title,\n      Map<String, ChangedSchema> properties,\n      DiffContext context) {\n    if (properties != null) {\n      properties.forEach((key, value) -> resolveProperty(output, propPrefix, key, value, title));\n    }\n  }\n\n  private void resolveProperty(\n      ContainerTag<?> output, String propPrefix, String key, Schema<?> value, String title) {\n    try {\n      property(output, propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      property(output, propPrefix + key, title, type(value));\n    }\n  }\n\n  private void resolveProperty(\n      ContainerTag<?> output, String propPrefix, String key, ChangedSchema value, String title) {\n    try {\n      property(output, propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      property(output, propPrefix + key, title, type(value));\n    }\n  }\n\n  protected void property(ContainerTag<?> output, String name, String title, Schema<?> schema) {\n    property(output, name, title, type(schema));\n  }\n\n  protected void property(ContainerTag<?> output, String name, String title, String type) {\n    output.with(p(String.format(\"%s: %s (%s)\", title, name, type)).withClass(MISSING));\n  }\n\n  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }\n\n  protected Schema<?> resolve(ChangedSchema schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(),\n        schema.getNewSchema(),\n        schema.getNewSchema().get$ref());\n  }\n\n  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }\n\n  protected String type(ChangedSchema schema) {\n    return type(schema.getNewSchema());\n  }\n\n  private UlTag ul_param(ChangedParameters changedParameters) {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    UlTag ul = ul().withClass(\"change param\");\n    for (Parameter param : addParameters) {\n      ul.with(li_addParam(param));\n    }\n    for (ChangedParameter param : changed) {\n      ul.with(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      ul.with(li_missingParam(param));\n    }\n    return ul;\n  }\n\n  private LiTag li_addParam(Parameter param) {\n    return li().withText(\"Add \" + param.getName() + \" in \" + param.getIn())\n        .with(\n            span(null == param.getDescription() ? \"\" : (\"//\" + param.getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_missingParam(Parameter param) {\n    return li().withClass(MISSING)\n        .with(span(\"Delete\"))\n        .with(del(param.getName()))\n        .with(span(\"in \").withText(param.getIn()))\n        .with(\n            span(null == param.getDescription() ? \"\" : (\"//\" + param.getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_deprecatedParam(ChangedParameter param) {\n    return li().withClass(MISSING)\n        .with(span(\"Deprecated\"))\n        .with(del(param.getName()))\n        .with(span(\"in \").withText(param.getIn()))\n        .with(\n            span(null == param.getNewParameter().getDescription()\n                    ? \"\"\n                    : (\"//\" + param.getNewParameter().getDescription()))\n                .withClass(COMMENT));\n  }\n\n  private LiTag li_changedParam(ChangedParameter changeParam) {\n    if (changeParam.isDeprecated()) {\n      return li_deprecatedParam(changeParam);\n    }\n    boolean changeRequired = changeParam.isChangeRequired();\n    boolean changeDescription =\n        Optional.ofNullable(changeParam.getDescription())\n            .map(ChangedMetadata::isDifferent)\n            .orElse(false);\n    Parameter rightParam = changeParam.getNewParameter();\n    Parameter leftParam = changeParam.getOldParameter();\n    LiTag li = li().withText(changeParam.getName() + \" in \" + changeParam.getIn());\n    if (changeRequired) {\n      li.withText(\n          \" change into \"\n              + (rightParam.getRequired() != null && rightParam.getRequired()\n                  ? \"required\"\n                  : \"not required\"));\n    }\n    if (changeDescription) {\n      li.withText(\" Notes \")\n          .with(del(leftParam.getDescription()).withClass(COMMENT))\n          .withText(\" change into \")\n          .with(span(rightParam.getDescription()).withClass(COMMENT));\n    }\n    return li;\n  }\n}", "definition": "public class HtmlRender implements Render", "class_docstring": "", "name": "HtmlRender", "super_interfaces": ["Render"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RefPointer<Schema<?>>", "name": "refPointer = new RefPointer<>(RefType.SCHEMAS)", "syntax_pass": true}, {"attribute_expression": "public static final String COMMENT = \"comment\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "COMMENT = \"comment\"", "syntax_pass": true}, {"attribute_expression": "public static final String MISSING = \"missing\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "MISSING = \"missing\"", "syntax_pass": true}, {"attribute_expression": "private final String title;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "title", "syntax_pass": true}, {"attribute_expression": "private final String linkCss;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "linkCss", "syntax_pass": true}, {"attribute_expression": "private final boolean showAllChanges;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "showAllChanges", "syntax_pass": true}, {"attribute_expression": "protected ChangedOpenApi diff;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedOpenApi", "name": "diff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public HtmlRender() {\n    this(\"Api Change Log\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "HtmlRender", "params": [], "body": "                      {\n    this(\"Api Change Log\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\");\n  }", "signature": "public HtmlRender()"}, {"syntax_pass": true, "original_string": "  public HtmlRender(boolean showAllChanges) {\n    this(\"Api Change Log\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\", showAllChanges);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "HtmlRender", "params": [{"name": "showAllChanges", "type": "boolean"}], "body": "                                            {\n    this(\"Api Change Log\", \"http://deepoove.com/swagger-diff/stylesheets/demo.css\", showAllChanges);\n  }", "signature": "public HtmlRender(boolean showAllChanges)"}, {"syntax_pass": true, "original_string": "  public HtmlRender(String title, String linkCss) {\n    this.title = title;\n    this.linkCss = linkCss;\n    this.showAllChanges = false;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "HtmlRender", "params": [{"name": "title", "type": "String"}, {"name": "linkCss", "type": "String"}], "body": "                                                  {\n    this.title = title;\n    this.linkCss = linkCss;\n    this.showAllChanges = false;\n  }", "signature": "public HtmlRender(String title, String linkCss)"}, {"syntax_pass": true, "original_string": "  public HtmlRender(String title, String linkCss, boolean showAllChanges) {\n    this.title = title;\n    this.linkCss = linkCss;\n    this.showAllChanges = showAllChanges;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "HtmlRender", "params": [{"name": "title", "type": "String"}, {"name": "linkCss", "type": "String"}, {"name": "showAllChanges", "type": "boolean"}], "body": "                                                                          {\n    this.title = title;\n    this.linkCss = linkCss;\n    this.showAllChanges = showAllChanges;\n  }", "signature": "public HtmlRender(String title, String linkCss, boolean showAllChanges)"}, {"syntax_pass": true, "original_string": "  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n\n    List<Endpoint> newEndpoints = diff.getNewEndpoints();\n    OlTag ol_newEndpoint = ol_newEndpoint(newEndpoints);\n\n    List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n    OlTag ol_missingEndpoint = ol_missingEndpoint(missingEndpoints);\n\n    List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n    OlTag ol_deprecatedEndpoint = ol_deprecatedEndpoint(deprecatedEndpoints);\n\n    List<ChangedOperation> changedOperations = diff.getChangedOperations();\n    OlTag ol_changed = ol_changed(changedOperations);\n\n    renderHtml(\n        ol_newEndpoint, ol_missingEndpoint, ol_deprecatedEndpoint, ol_changed, outputStreamWriter);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "render", "params": [{"name": "diff", "type": "ChangedOpenApi"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                 {\n    this.diff = diff;\n\n    List<Endpoint> newEndpoints = diff.getNewEndpoints();\n    OlTag ol_newEndpoint = ol_newEndpoint(newEndpoints);\n\n    List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n    OlTag ol_missingEndpoint = ol_missingEndpoint(missingEndpoints);\n\n    List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n    OlTag ol_deprecatedEndpoint = ol_deprecatedEndpoint(deprecatedEndpoints);\n\n    List<ChangedOperation> changedOperations = diff.getChangedOperations();\n    OlTag ol_changed = ol_changed(changedOperations);\n\n    renderHtml(\n        ol_newEndpoint, ol_missingEndpoint, ol_deprecatedEndpoint, ol_changed, outputStreamWriter);\n  }", "signature": "public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  public void renderHtml(\n      OlTag ol_new,\n      OlTag ol_miss,\n      OlTag ol_deprec,\n      OlTag ol_changed,\n      OutputStreamWriter outputStreamWriter) {\n    HtmlTag html =\n        html()\n            .attr(\"lang\", \"en\")\n            .with(\n                head()\n                    .with(\n                        meta().withCharset(\"utf-8\"),\n                        title(title),\n                        link().withRel(\"stylesheet\").withHref(linkCss)),\n                body()\n                    .with(\n                        header().with(h1(title)),\n                        div()\n                            .withClass(\"article\")\n                            .with(\n                                div().with(h2(\"What's New\"), hr(), ol_new),\n                                div().with(h2(\"What's Deleted\"), hr(), ol_miss),\n                                div().with(h2(\"What's Deprecated\"), hr(), ol_deprec),\n                                div().with(h2(\"What's Changed\"), hr(), ol_changed))));\n\n    try {\n      FlatHtml<OutputStreamWriter> flatHtml = FlatHtml.into(outputStreamWriter);\n      document().render(flatHtml);\n      html.render(flatHtml);\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(\"Problem rendering html document.\", e);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "renderHtml", "params": [{"name": "ol_new", "type": "OlTag"}, {"name": "ol_miss", "type": "OlTag"}, {"name": "ol_deprec", "type": "OlTag"}, {"name": "ol_changed", "type": "OlTag"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                             {\n    HtmlTag html =\n        html()\n            .attr(\"lang\", \"en\")\n            .with(\n                head()\n                    .with(\n                        meta().withCharset(\"utf-8\"),\n                        title(title),\n                        link().withRel(\"stylesheet\").withHref(linkCss)),\n                body()\n                    .with(\n                        header().with(h1(title)),\n                        div()\n                            .withClass(\"article\")\n                            .with(\n                                div().with(h2(\"What's New\"), hr(), ol_new),\n                                div().with(h2(\"What's Deleted\"), hr(), ol_miss),\n                                div().with(h2(\"What's Deprecated\"), hr(), ol_deprec),\n                                div().with(h2(\"What's Changed\"), hr(), ol_changed))));\n\n    try {\n      FlatHtml<OutputStreamWriter> flatHtml = FlatHtml.into(outputStreamWriter);\n      document().render(flatHtml);\n      html.render(flatHtml);\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(\"Problem rendering html document.\", e);\n    }\n  }", "signature": "public void renderHtml(\n      OlTag ol_new,\n      OlTag ol_miss,\n      OlTag ol_deprec,\n      OlTag ol_changed,\n      OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  private OlTag ol_newEndpoint(List<Endpoint> endpoints) {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_newEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "OlTag", "classes": []}, "name": "ol_newEndpoint", "params": [{"name": "endpoints", "type": "List<Endpoint>"}], "body": "                                                         {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_newEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }", "signature": "private OlTag ol_newEndpoint(List<Endpoint> endpoints)"}, {"syntax_pass": true, "original_string": "  private LiTag li_newEndpoint(String method, String path, String desc) {\n    return li().with(span(method).withClass(method)).withText(path + \" \").with(span(desc));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_newEndpoint", "params": [{"name": "method", "type": "String"}, {"name": "path", "type": "String"}, {"name": "desc", "type": "String"}], "body": "                                                                        {\n    return li().with(span(method).withClass(method)).withText(path + \" \").with(span(desc));\n  }", "signature": "private LiTag li_newEndpoint(String method, String path, String desc)"}, {"syntax_pass": true, "original_string": "  private OlTag ol_missingEndpoint(List<Endpoint> endpoints) {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_missingEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "OlTag", "classes": []}, "name": "ol_missingEndpoint", "params": [{"name": "endpoints", "type": "List<Endpoint>"}], "body": "                                                             {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_missingEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }", "signature": "private OlTag ol_missingEndpoint(List<Endpoint> endpoints)"}, {"syntax_pass": true, "original_string": "  private LiTag li_missingEndpoint(String method, String path, String desc) {\n    return li().with(span(method).withClass(method), del().withText(path)).with(span(\" \" + desc));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_missingEndpoint", "params": [{"name": "method", "type": "String"}, {"name": "path", "type": "String"}, {"name": "desc", "type": "String"}], "body": "                                                                            {\n    return li().with(span(method).withClass(method), del().withText(path)).with(span(\" \" + desc));\n  }", "signature": "private LiTag li_missingEndpoint(String method, String path, String desc)"}, {"syntax_pass": true, "original_string": "  private OlTag ol_deprecatedEndpoint(List<Endpoint> endpoints) {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_deprecatedEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "OlTag", "classes": []}, "name": "ol_deprecatedEndpoint", "params": [{"name": "endpoints", "type": "List<Endpoint>"}], "body": "                                                                {\n    if (null == endpoints) return ol();\n    OlTag ol = ol();\n    for (Endpoint endpoint : endpoints) {\n      ol.with(\n          li_deprecatedEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return ol;\n  }", "signature": "private OlTag ol_deprecatedEndpoint(List<Endpoint> endpoints)"}, {"syntax_pass": true, "original_string": "  private LiTag li_deprecatedEndpoint(String method, String path, String desc) {\n    return li().with(span(method).withClass(method), del().withText(path)).with(span(\" \" + desc));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_deprecatedEndpoint", "params": [{"name": "method", "type": "String"}, {"name": "path", "type": "String"}, {"name": "desc", "type": "String"}], "body": "                                                                               {\n    return li().with(span(method).withClass(method), del().withText(path)).with(span(\" \" + desc));\n  }", "signature": "private LiTag li_deprecatedEndpoint(String method, String path, String desc)"}, {"syntax_pass": true, "original_string": "  private OlTag ol_changed(List<ChangedOperation> changedOperations) {\n    if (null == changedOperations) return ol();\n    OlTag ol = ol();\n    for (ChangedOperation changedOperation : changedOperations) {\n      String pathUrl = changedOperation.getPathUrl();\n      String method = changedOperation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(changedOperation.getSummary())\n              .map(ChangedMetadata::getRight)\n              .orElse(\"\");\n\n      UlTag ul_detail = ul().withClass(\"detail\");\n      if (result(changedOperation.getParameters()).isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Parameters\")).with(ul_param(changedOperation.getParameters())));\n      }\n      if (changedOperation.resultRequestBody().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Request\"))\n                .with(ul_request(changedOperation.getRequestBody().getContent())));\n      }\n      if (changedOperation.resultApiResponses().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Response\")).with(ul_response(changedOperation.getApiResponses())));\n      }\n      if (showAllChanges && changedOperation.resultSecurityRequirements().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Security Requirements\"))\n                .with(ul_securityRequirements(changedOperation.getSecurityRequirements())));\n      }\n      ol.with(\n          li().with(span(method).withClass(method))\n              .withText(pathUrl + \" \")\n              .with(span(desc))\n              .with(ul_detail));\n    }\n    return ol;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "OlTag", "classes": []}, "name": "ol_changed", "params": [{"name": "changedOperations", "type": "List<ChangedOperation>"}], "body": "                                                                     {\n    if (null == changedOperations) return ol();\n    OlTag ol = ol();\n    for (ChangedOperation changedOperation : changedOperations) {\n      String pathUrl = changedOperation.getPathUrl();\n      String method = changedOperation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(changedOperation.getSummary())\n              .map(ChangedMetadata::getRight)\n              .orElse(\"\");\n\n      UlTag ul_detail = ul().withClass(\"detail\");\n      if (result(changedOperation.getParameters()).isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Parameters\")).with(ul_param(changedOperation.getParameters())));\n      }\n      if (changedOperation.resultRequestBody().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Request\"))\n                .with(ul_request(changedOperation.getRequestBody().getContent())));\n      }\n      if (changedOperation.resultApiResponses().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Response\")).with(ul_response(changedOperation.getApiResponses())));\n      }\n      if (showAllChanges && changedOperation.resultSecurityRequirements().isDifferent()) {\n        ul_detail.with(\n            li().with(h3(\"Security Requirements\"))\n                .with(ul_securityRequirements(changedOperation.getSecurityRequirements())));\n      }\n      ol.with(\n          li().with(span(method).withClass(method))\n              .withText(pathUrl + \" \")\n              .with(span(desc))\n              .with(ul_detail));\n    }\n    return ol;\n  }", "signature": "private OlTag ol_changed(List<ChangedOperation> changedOperations)"}, {"syntax_pass": true, "original_string": "  private UlTag ul_securityRequirements(ChangedSecurityRequirements changedSecurityRequirements) {\n    List<SecurityRequirement> addRequirements = changedSecurityRequirements.getIncreased();\n    List<SecurityRequirement> delRequirements = changedSecurityRequirements.getMissing();\n    List<ChangedSecurityRequirement> changedRequirements = changedSecurityRequirements.getChanged();\n    UlTag ul = ul().withClass(\"change security requirements\");\n    if (addRequirements != null) {\n      for (SecurityRequirement addRequirement : addRequirements) {\n        ul.with(li_addSecurityRequirement(addRequirement));\n      }\n    }\n    if (delRequirements != null) {\n      for (SecurityRequirement delRequirement : delRequirements) {\n        ul.with(li_missingSecurityRequirement(delRequirement));\n      }\n    }\n    if (changedRequirements != null) {\n      for (ChangedSecurityRequirement changedRequirement : changedRequirements) {\n        ul.with(li_changedSecurityRequirement(changedRequirement));\n      }\n    }\n\n    return ul;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "UlTag", "classes": []}, "name": "ul_securityRequirements", "params": [{"name": "changedSecurityRequirements", "type": "ChangedSecurityRequirements"}], "body": "                                                                                                 {\n    List<SecurityRequirement> addRequirements = changedSecurityRequirements.getIncreased();\n    List<SecurityRequirement> delRequirements = changedSecurityRequirements.getMissing();\n    List<ChangedSecurityRequirement> changedRequirements = changedSecurityRequirements.getChanged();\n    UlTag ul = ul().withClass(\"change security requirements\");\n    if (addRequirements != null) {\n      for (SecurityRequirement addRequirement : addRequirements) {\n        ul.with(li_addSecurityRequirement(addRequirement));\n      }\n    }\n    if (delRequirements != null) {\n      for (SecurityRequirement delRequirement : delRequirements) {\n        ul.with(li_missingSecurityRequirement(delRequirement));\n      }\n    }\n    if (changedRequirements != null) {\n      for (ChangedSecurityRequirement changedRequirement : changedRequirements) {\n        ul.with(li_changedSecurityRequirement(changedRequirement));\n      }\n    }\n\n    return ul;\n  }", "signature": "private UlTag ul_securityRequirements(ChangedSecurityRequirements changedSecurityRequirements)"}, {"syntax_pass": true, "original_string": "  private LiTag li_addSecurityRequirement(SecurityRequirement securityRequirement) {\n    return li().withText(\"New security requirement : \")\n        .with(span(null == securityRequirement.toString() ? \"\" : (securityRequirement.toString())));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_addSecurityRequirement", "params": [{"name": "securityRequirement", "type": "SecurityRequirement"}], "body": "                                                                                   {\n    return li().withText(\"New security requirement : \")\n        .with(span(null == securityRequirement.toString() ? \"\" : (securityRequirement.toString())));\n  }", "signature": "private LiTag li_addSecurityRequirement(SecurityRequirement securityRequirement)"}, {"syntax_pass": true, "original_string": "  private LiTag li_missingSecurityRequirement(SecurityRequirement securityRequirement) {\n    return li().withText(\"Deleted security requirement : \")\n        .with(span(null == securityRequirement.toString() ? \"\" : (securityRequirement.toString())));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_missingSecurityRequirement", "params": [{"name": "securityRequirement", "type": "SecurityRequirement"}], "body": "                                                                                       {\n    return li().withText(\"Deleted security requirement : \")\n        .with(span(null == securityRequirement.toString() ? \"\" : (securityRequirement.toString())));\n  }", "signature": "private LiTag li_missingSecurityRequirement(SecurityRequirement securityRequirement)"}, {"syntax_pass": true, "original_string": "  private LiTag li_changedSecurityRequirement(\n      ChangedSecurityRequirement changedSecurityRequirement) {\n    return li().withText(String.format(\"Changed security requirement : \"))\n        .with(\n            span(\n                (null == changedSecurityRequirement.getNewSecurityRequirement()\n                        || null\n                            == changedSecurityRequirement.getNewSecurityRequirement().toString())\n                    ? \"\"\n                    : (changedSecurityRequirement.getNewSecurityRequirement().toString())));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_changedSecurityRequirement", "params": [{"name": "changedSecurityRequirement", "type": "ChangedSecurityRequirement"}], "body": "                                                             {\n    return li().withText(String.format(\"Changed security requirement : \"))\n        .with(\n            span(\n                (null == changedSecurityRequirement.getNewSecurityRequirement()\n                        || null\n                            == changedSecurityRequirement.getNewSecurityRequirement().toString())\n                    ? \"\"\n                    : (changedSecurityRequirement.getNewSecurityRequirement().toString())));\n  }", "signature": "private LiTag li_changedSecurityRequirement(\n      ChangedSecurityRequirement changedSecurityRequirement)"}, {"syntax_pass": true, "original_string": "  private UlTag ul_response(ChangedApiResponse changedApiResponse) {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    UlTag ul = ul().withClass(\"change response\");\n    for (Entry<String, ApiResponse> prop : addResponses.entrySet()) {\n      ul.with(li_addResponse(prop.getKey(), prop.getValue()));\n    }\n    for (Entry<String, ApiResponse> prop : delResponses.entrySet()) {\n      ul.with(li_missingResponse(prop.getKey(), prop.getValue()));\n    }\n    for (Entry<String, ChangedResponse> prop : changedResponses.entrySet()) {\n      ul.with(li_changedResponse(prop.getKey(), prop.getValue()));\n    }\n    return ul;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "UlTag", "classes": []}, "name": "ul_response", "params": [{"name": "changedApiResponse", "type": "ChangedApiResponse"}], "body": "                                                                   {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    UlTag ul = ul().withClass(\"change response\");\n    for (Entry<String, ApiResponse> prop : addResponses.entrySet()) {\n      ul.with(li_addResponse(prop.getKey(), prop.getValue()));\n    }\n    for (Entry<String, ApiResponse> prop : delResponses.entrySet()) {\n      ul.with(li_missingResponse(prop.getKey(), prop.getValue()));\n    }\n    for (Entry<String, ChangedResponse> prop : changedResponses.entrySet()) {\n      ul.with(li_changedResponse(prop.getKey(), prop.getValue()));\n    }\n    return ul;\n  }", "signature": "private UlTag ul_response(ChangedApiResponse changedApiResponse)"}, {"syntax_pass": true, "original_string": "  private LiTag li_addResponse(String name, ApiResponse response) {\n    return li().withText(String.format(\"New response : [%s]\", name))\n        .with(\n            span(null == response.getDescription() ? \"\" : (\"//\" + response.getDescription()))\n                .withClass(COMMENT));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_addResponse", "params": [{"name": "name", "type": "String"}, {"name": "response", "type": "ApiResponse"}], "body": "                                                                  {\n    return li().withText(String.format(\"New response : [%s]\", name))\n        .with(\n            span(null == response.getDescription() ? \"\" : (\"//\" + response.getDescription()))\n                .withClass(COMMENT));\n  }", "signature": "private LiTag li_addResponse(String name, ApiResponse response)"}, {"syntax_pass": true, "original_string": "  private LiTag li_missingResponse(String name, ApiResponse response) {\n    return li().withText(String.format(\"Deleted response : [%s]\", name))\n        .with(\n            span(null == response.getDescription() ? \"\" : (\"//\" + response.getDescription()))\n                .withClass(COMMENT));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_missingResponse", "params": [{"name": "name", "type": "String"}, {"name": "response", "type": "ApiResponse"}], "body": "                                                                      {\n    return li().withText(String.format(\"Deleted response : [%s]\", name))\n        .with(\n            span(null == response.getDescription() ? \"\" : (\"//\" + response.getDescription()))\n                .withClass(COMMENT));\n  }", "signature": "private LiTag li_missingResponse(String name, ApiResponse response)"}, {"syntax_pass": true, "original_string": "  private LiTag li_changedResponse(String name, ChangedResponse response) {\n    return li().withText(String.format(\"Changed response : [%s]\", name))\n        .with(\n            span((null == response.getNewApiResponse()\n                        || null == response.getNewApiResponse().getDescription())\n                    ? \"\"\n                    : (\"//\" + response.getNewApiResponse().getDescription()))\n                .withClass(COMMENT))\n        .with(ul_request(response.getContent()));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_changedResponse", "params": [{"name": "name", "type": "String"}, {"name": "response", "type": "ChangedResponse"}], "body": "                                                                          {\n    return li().withText(String.format(\"Changed response : [%s]\", name))\n        .with(\n            span((null == response.getNewApiResponse()\n                        || null == response.getNewApiResponse().getDescription())\n                    ? \"\"\n                    : (\"//\" + response.getNewApiResponse().getDescription()))\n                .withClass(COMMENT))\n        .with(ul_request(response.getContent()));\n  }", "signature": "private LiTag li_changedResponse(String name, ChangedResponse response)"}, {"syntax_pass": true, "original_string": "  private UlTag ul_request(ChangedContent changedContent) {\n    UlTag ul = ul().withClass(\"change request-body\");\n    if (changedContent != null) {\n      for (String propName : changedContent.getIncreased().keySet()) {\n        ul.with(li_addRequest(propName, changedContent.getIncreased().get(propName)));\n      }\n      for (String propName : changedContent.getMissing().keySet()) {\n        ul.with(li_missingRequest(propName, changedContent.getMissing().get(propName)));\n      }\n      for (String propName : changedContent.getChanged().keySet()) {\n        ul.with(li_changedRequest(propName, changedContent.getChanged().get(propName)));\n      }\n    }\n    return ul;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "UlTag", "classes": []}, "name": "ul_request", "params": [{"name": "changedContent", "type": "ChangedContent"}], "body": "                                                          {\n    UlTag ul = ul().withClass(\"change request-body\");\n    if (changedContent != null) {\n      for (String propName : changedContent.getIncreased().keySet()) {\n        ul.with(li_addRequest(propName, changedContent.getIncreased().get(propName)));\n      }\n      for (String propName : changedContent.getMissing().keySet()) {\n        ul.with(li_missingRequest(propName, changedContent.getMissing().get(propName)));\n      }\n      for (String propName : changedContent.getChanged().keySet()) {\n        ul.with(li_changedRequest(propName, changedContent.getChanged().get(propName)));\n      }\n    }\n    return ul;\n  }", "signature": "private UlTag ul_request(ChangedContent changedContent)"}, {"syntax_pass": true, "original_string": "  private LiTag li_addRequest(String name, MediaType request) {\n    return li().withText(String.format(\"New body: '%s'\", name));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_addRequest", "params": [{"name": "name", "type": "String"}, {"name": "request", "type": "MediaType"}], "body": "                                                              {\n    return li().withText(String.format(\"New body: '%s'\", name));\n  }", "signature": "private LiTag li_addRequest(String name, MediaType request)"}, {"syntax_pass": true, "original_string": "  private LiTag li_missingRequest(String name, MediaType request) {\n    return li().withText(String.format(\"Deleted body: '%s'\", name));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_missingRequest", "params": [{"name": "name", "type": "String"}, {"name": "request", "type": "MediaType"}], "body": "                                                                  {\n    return li().withText(String.format(\"Deleted body: '%s'\", name));\n  }", "signature": "private LiTag li_missingRequest(String name, MediaType request)"}, {"syntax_pass": true, "original_string": "  private LiTag li_changedRequest(String name, ChangedMediaType request) {\n    LiTag li =\n        li().with(div_changedSchema(request.getSchema()))\n            .withText(String.format(\"Changed body: '%s'\", name));\n    if (request.isIncompatible() && !showAllChanges) {\n      incompatibilities(li, request.getSchema());\n    } else if (showAllChanges) {\n      allChanges(li, request.getSchema());\n    }\n    return li;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_changedRequest", "params": [{"name": "name", "type": "String"}, {"name": "request", "type": "ChangedMediaType"}], "body": "                                                                         {\n    LiTag li =\n        li().with(div_changedSchema(request.getSchema()))\n            .withText(String.format(\"Changed body: '%s'\", name));\n    if (request.isIncompatible() && !showAllChanges) {\n      incompatibilities(li, request.getSchema());\n    } else if (showAllChanges) {\n      allChanges(li, request.getSchema());\n    }\n    return li;\n  }", "signature": "private LiTag li_changedRequest(String name, ChangedMediaType request)"}, {"syntax_pass": true, "original_string": "  private DivTag div_changedSchema(ChangedSchema schema) {\n    DivTag div = div();\n    div.with(h3(\"Schema\" + (schema.isIncompatible() ? \" incompatible\" : \"\")));\n    return div;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DivTag", "classes": []}, "name": "div_changedSchema", "params": [{"name": "schema", "type": "ChangedSchema"}], "body": "                                                         {\n    DivTag div = div();\n    div.with(h3(\"Schema\" + (schema.isIncompatible() ? \" incompatible\" : \"\")));\n    return div;\n  }", "signature": "private DivTag div_changedSchema(ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private void allChanges(final LiTag output, final ChangedSchema schema) {\n    allChanges(output, \"\", schema);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "allChanges", "params": [{"name": "output", "type": "LiTag"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                                          {\n    allChanges(output, \"\", schema);\n  }", "signature": "private void allChanges(final LiTag output, final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private void allChanges(\n      final ContainerTag<?> output, String propName, final ChangedSchema schema) {\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    properties(\n        output, prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext());\n    properties(\n        output, prefix, \"Added property\", schema.getIncreasedProperties(), schema.getContext());\n\n    propertiesChanged(\n        output, prefix, \"Changed property\", schema.getChangedProperties(), schema.getContext());\n    if (schema.getItems() != null) {\n      itemsAllChanges(output, propName, schema.getItems());\n    }\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> allChanges(output, prefix + name, property));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "allChanges", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "propName", "type": "String"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                                                 {\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    properties(\n        output, prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext());\n    properties(\n        output, prefix, \"Added property\", schema.getIncreasedProperties(), schema.getContext());\n\n    propertiesChanged(\n        output, prefix, \"Changed property\", schema.getChangedProperties(), schema.getContext());\n    if (schema.getItems() != null) {\n      itemsAllChanges(output, propName, schema.getItems());\n    }\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> allChanges(output, prefix + name, property));\n  }", "signature": "private void allChanges(\n      final ContainerTag<?> output, String propName, final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private void incompatibilities(final LiTag output, final ChangedSchema schema) {\n    incompatibilities(output, \"\", schema);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "incompatibilities", "params": [{"name": "output", "type": "LiTag"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                                                 {\n    incompatibilities(output, \"\", schema);\n  }", "signature": "private void incompatibilities(final LiTag output, final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private void incompatibilities(\n      final ContainerTag<?> output, String propName, final ChangedSchema schema) {\n    if (schema.getItems() != null) {\n      items(output, propName, schema.getItems());\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      property(output, propName, \"Changed property type\", type);\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    properties(\n        output, prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext());\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> incompatibilities(output, prefix + name, property));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "incompatibilities", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "propName", "type": "String"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                                                 {\n    if (schema.getItems() != null) {\n      items(output, propName, schema.getItems());\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      property(output, propName, \"Changed property type\", type);\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    properties(\n        output, prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext());\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> incompatibilities(output, prefix + name, property));\n  }", "signature": "private void incompatibilities(\n      final ContainerTag<?> output, String propName, final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private void items(ContainerTag<?> output, String propName, ChangedSchema schema) {\n    incompatibilities(output, propName + \"[n]\", schema);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "items", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "propName", "type": "String"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                                                    {\n    incompatibilities(output, propName + \"[n]\", schema);\n  }", "signature": "private void items(ContainerTag<?> output, String propName, ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private void itemsAllChanges(ContainerTag<?> output, String propName, ChangedSchema schema) {\n    allChanges(output, propName + \"[n]\", schema);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "itemsAllChanges", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "propName", "type": "String"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                                                              {\n    allChanges(output, propName + \"[n]\", schema);\n  }", "signature": "private void itemsAllChanges(ContainerTag<?> output, String propName, ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private void properties(\n      ContainerTag<?> output,\n      String propPrefix,\n      String title,\n      Map<String, Schema<?>> properties,\n      DiffContext context) {\n    if (properties != null) {\n      properties.forEach((key, value) -> resolveProperty(output, propPrefix, key, value, title));\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "properties", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "propPrefix", "type": "String"}, {"name": "title", "type": "String"}, {"name": "properties", "type": "Map<String, Schema<?>>"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n    if (properties != null) {\n      properties.forEach((key, value) -> resolveProperty(output, propPrefix, key, value, title));\n    }\n  }", "signature": "private void properties(\n      ContainerTag<?> output,\n      String propPrefix,\n      String title,\n      Map<String, Schema<?>> properties,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  private void propertiesChanged(\n      ContainerTag<?> output,\n      String propPrefix,\n      String title,\n      Map<String, ChangedSchema> properties,\n      DiffContext context) {\n    if (properties != null) {\n      properties.forEach((key, value) -> resolveProperty(output, propPrefix, key, value, title));\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "propertiesChanged", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "propPrefix", "type": "String"}, {"name": "title", "type": "String"}, {"name": "properties", "type": "Map<String, ChangedSchema>"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n    if (properties != null) {\n      properties.forEach((key, value) -> resolveProperty(output, propPrefix, key, value, title));\n    }\n  }", "signature": "private void propertiesChanged(\n      ContainerTag<?> output,\n      String propPrefix,\n      String title,\n      Map<String, ChangedSchema> properties,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  private void resolveProperty(\n      ContainerTag<?> output, String propPrefix, String key, Schema<?> value, String title) {\n    try {\n      property(output, propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      property(output, propPrefix + key, title, type(value));\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "resolveProperty", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "propPrefix", "type": "String"}, {"name": "key", "type": "String"}, {"name": "value", "type": "Schema<?>"}, {"name": "title", "type": "String"}], "body": "                                                                                            {\n    try {\n      property(output, propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      property(output, propPrefix + key, title, type(value));\n    }\n  }", "signature": "private void resolveProperty(\n      ContainerTag<?> output, String propPrefix, String key, Schema<?> value, String title)"}, {"syntax_pass": true, "original_string": "  private void resolveProperty(\n      ContainerTag<?> output, String propPrefix, String key, ChangedSchema value, String title) {\n    try {\n      property(output, propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      property(output, propPrefix + key, title, type(value));\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "resolveProperty", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "propPrefix", "type": "String"}, {"name": "key", "type": "String"}, {"name": "value", "type": "ChangedSchema"}, {"name": "title", "type": "String"}], "body": "                                                                                                {\n    try {\n      property(output, propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      property(output, propPrefix + key, title, type(value));\n    }\n  }", "signature": "private void resolveProperty(\n      ContainerTag<?> output, String propPrefix, String key, ChangedSchema value, String title)"}, {"syntax_pass": true, "original_string": "  protected void property(ContainerTag<?> output, String name, String title, Schema<?> schema) {\n    property(output, name, title, type(schema));\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "property", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "name", "type": "String"}, {"name": "title", "type": "String"}, {"name": "schema", "type": "Schema<?>"}], "body": "                                                                                               {\n    property(output, name, title, type(schema));\n  }", "signature": "protected void property(ContainerTag<?> output, String name, String title, Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  protected void property(ContainerTag<?> output, String name, String title, String type) {\n    output.with(p(String.format(\"%s: %s (%s)\", title, name, type)).withClass(MISSING));\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "property", "params": [{"name": "output", "type": "ContainerTag<?>"}, {"name": "name", "type": "String"}, {"name": "title", "type": "String"}, {"name": "type", "type": "String"}], "body": "                                                                                          {\n    output.with(p(String.format(\"%s: %s (%s)\", title, name, type)).withClass(MISSING));\n  }", "signature": "protected void property(ContainerTag<?> output, String name, String title, String type)"}, {"syntax_pass": true, "original_string": "  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Schema<?>", "classes": []}, "name": "resolve", "params": [{"name": "schema", "type": "Schema<?>"}], "body": "                                                {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }", "signature": "protected Schema<?> resolve(Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  protected Schema<?> resolve(ChangedSchema schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(),\n        schema.getNewSchema(),\n        schema.getNewSchema().get$ref());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Schema<?>", "classes": []}, "name": "resolve", "params": [{"name": "schema", "type": "ChangedSchema"}], "body": "                                                    {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(),\n        schema.getNewSchema(),\n        schema.getNewSchema().get$ref());\n  }", "signature": "protected Schema<?> resolve(ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "type", "params": [{"name": "schema", "type": "Schema<?>"}], "body": "                                          {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }", "signature": "protected String type(Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  protected String type(ChangedSchema schema) {\n    return type(schema.getNewSchema());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "type", "params": [{"name": "schema", "type": "ChangedSchema"}], "body": "                                              {\n    return type(schema.getNewSchema());\n  }", "signature": "protected String type(ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private UlTag ul_param(ChangedParameters changedParameters) {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    UlTag ul = ul().withClass(\"change param\");\n    for (Parameter param : addParameters) {\n      ul.with(li_addParam(param));\n    }\n    for (ChangedParameter param : changed) {\n      ul.with(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      ul.with(li_missingParam(param));\n    }\n    return ul;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "UlTag", "classes": []}, "name": "ul_param", "params": [{"name": "changedParameters", "type": "ChangedParameters"}], "body": "                                                              {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    UlTag ul = ul().withClass(\"change param\");\n    for (Parameter param : addParameters) {\n      ul.with(li_addParam(param));\n    }\n    for (ChangedParameter param : changed) {\n      ul.with(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      ul.with(li_missingParam(param));\n    }\n    return ul;\n  }", "signature": "private UlTag ul_param(ChangedParameters changedParameters)"}, {"syntax_pass": true, "original_string": "  private LiTag li_addParam(Parameter param) {\n    return li().withText(\"Add \" + param.getName() + \" in \" + param.getIn())\n        .with(\n            span(null == param.getDescription() ? \"\" : (\"//\" + param.getDescription()))\n                .withClass(COMMENT));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_addParam", "params": [{"name": "param", "type": "Parameter"}], "body": "                                             {\n    return li().withText(\"Add \" + param.getName() + \" in \" + param.getIn())\n        .with(\n            span(null == param.getDescription() ? \"\" : (\"//\" + param.getDescription()))\n                .withClass(COMMENT));\n  }", "signature": "private LiTag li_addParam(Parameter param)"}, {"syntax_pass": true, "original_string": "  private LiTag li_missingParam(Parameter param) {\n    return li().withClass(MISSING)\n        .with(span(\"Delete\"))\n        .with(del(param.getName()))\n        .with(span(\"in \").withText(param.getIn()))\n        .with(\n            span(null == param.getDescription() ? \"\" : (\"//\" + param.getDescription()))\n                .withClass(COMMENT));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_missingParam", "params": [{"name": "param", "type": "Parameter"}], "body": "                                                 {\n    return li().withClass(MISSING)\n        .with(span(\"Delete\"))\n        .with(del(param.getName()))\n        .with(span(\"in \").withText(param.getIn()))\n        .with(\n            span(null == param.getDescription() ? \"\" : (\"//\" + param.getDescription()))\n                .withClass(COMMENT));\n  }", "signature": "private LiTag li_missingParam(Parameter param)"}, {"syntax_pass": true, "original_string": "  private LiTag li_deprecatedParam(ChangedParameter param) {\n    return li().withClass(MISSING)\n        .with(span(\"Deprecated\"))\n        .with(del(param.getName()))\n        .with(span(\"in \").withText(param.getIn()))\n        .with(\n            span(null == param.getNewParameter().getDescription()\n                    ? \"\"\n                    : (\"//\" + param.getNewParameter().getDescription()))\n                .withClass(COMMENT));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_deprecatedParam", "params": [{"name": "param", "type": "ChangedParameter"}], "body": "                                                           {\n    return li().withClass(MISSING)\n        .with(span(\"Deprecated\"))\n        .with(del(param.getName()))\n        .with(span(\"in \").withText(param.getIn()))\n        .with(\n            span(null == param.getNewParameter().getDescription()\n                    ? \"\"\n                    : (\"//\" + param.getNewParameter().getDescription()))\n                .withClass(COMMENT));\n  }", "signature": "private LiTag li_deprecatedParam(ChangedParameter param)"}, {"syntax_pass": true, "original_string": "  private LiTag li_changedParam(ChangedParameter changeParam) {\n    if (changeParam.isDeprecated()) {\n      return li_deprecatedParam(changeParam);\n    }\n    boolean changeRequired = changeParam.isChangeRequired();\n    boolean changeDescription =\n        Optional.ofNullable(changeParam.getDescription())\n            .map(ChangedMetadata::isDifferent)\n            .orElse(false);\n    Parameter rightParam = changeParam.getNewParameter();\n    Parameter leftParam = changeParam.getOldParameter();\n    LiTag li = li().withText(changeParam.getName() + \" in \" + changeParam.getIn());\n    if (changeRequired) {\n      li.withText(\n          \" change into \"\n              + (rightParam.getRequired() != null && rightParam.getRequired()\n                  ? \"required\"\n                  : \"not required\"));\n    }\n    if (changeDescription) {\n      li.withText(\" Notes \")\n          .with(del(leftParam.getDescription()).withClass(COMMENT))\n          .withText(\" change into \")\n          .with(span(rightParam.getDescription()).withClass(COMMENT));\n    }\n    return li;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LiTag", "classes": []}, "name": "li_changedParam", "params": [{"name": "changeParam", "type": "ChangedParameter"}], "body": "                                                              {\n    if (changeParam.isDeprecated()) {\n      return li_deprecatedParam(changeParam);\n    }\n    boolean changeRequired = changeParam.isChangeRequired();\n    boolean changeDescription =\n        Optional.ofNullable(changeParam.getDescription())\n            .map(ChangedMetadata::isDifferent)\n            .orElse(false);\n    Parameter rightParam = changeParam.getNewParameter();\n    Parameter leftParam = changeParam.getOldParameter();\n    LiTag li = li().withText(changeParam.getName() + \" in \" + changeParam.getIn());\n    if (changeRequired) {\n      li.withText(\n          \" change into \"\n              + (rightParam.getRequired() != null && rightParam.getRequired()\n                  ? \"required\"\n                  : \"not required\"));\n    }\n    if (changeDescription) {\n      li.withText(\" Notes \")\n          .with(del(leftParam.getDescription()).withClass(COMMENT))\n          .withText(\" change into \")\n          .with(span(rightParam.getDescription()).withClass(COMMENT));\n    }\n    return li;\n  }", "signature": "private LiTag li_changedParam(ChangedParameter changeParam)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/output/ConsoleRender.java", "original_string": "package org.openapitools.openapidiff.core.output;\n\nimport static org.openapitools.openapidiff.core.model.Changed.result;\n\nimport io.swagger.v3.oas.models.media.ArraySchema;\nimport io.swagger.v3.oas.models.media.Schema;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Optional;\nimport org.apache.commons.lang3.StringUtils;\nimport org.openapitools.openapidiff.core.exception.RendererException;\nimport org.openapitools.openapidiff.core.model.*;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\npublic class ConsoleRender implements Render {\n  private static final int LINE_LENGTH = 74;\n  protected static RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  protected ChangedOpenApi diff;\n\n  @Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n    if (diff.isUnchanged()) {\n      safelyAppend(outputStreamWriter, \"No differences. Specifications are equivalents\");\n    } else {\n      safelyAppend(outputStreamWriter, bigTitle(\"Api Change Log\"));\n      safelyAppend(\n          outputStreamWriter,\n          StringUtils.center(diff.getNewSpecOpenApi().getInfo().getTitle(), LINE_LENGTH));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n\n      List<Endpoint> newEndpoints = diff.getNewEndpoints();\n      listEndpoints(newEndpoints, \"What's New\", outputStreamWriter);\n\n      List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n      listEndpoints(missingEndpoints, \"What's Deleted\", outputStreamWriter);\n\n      List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n      listEndpoints(deprecatedEndpoints, \"What's Deprecated\", outputStreamWriter);\n\n      List<ChangedOperation> changedOperations = diff.getChangedOperations();\n      ol_changed(changedOperations, outputStreamWriter);\n\n      safelyAppend(outputStreamWriter, title(\"Result\"));\n      safelyAppend(\n          outputStreamWriter,\n          StringUtils.center(\n              diff.isCompatible()\n                  ? \"API changes are backward compatible\"\n                  : \"API changes broke backward compatibility\",\n              LINE_LENGTH));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, separator('-'));\n    }\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }\n\n  private void ol_changed(\n      List<ChangedOperation> operations, OutputStreamWriter outputStreamWriter) {\n    if (null == operations || operations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, title(\"What's Changed\"));\n    for (ChangedOperation operation : operations) {\n      String pathUrl = operation.getPathUrl();\n      String method = operation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(operation.getSummary()).map(ChangedMetadata::getRight).orElse(\"\");\n\n      safelyAppend(outputStreamWriter, itemEndpoint(method, pathUrl, desc));\n\n      if (result(operation.getParameters()).isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Parameter:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_param(operation.getParameters()));\n      }\n      if (operation.resultRequestBody().isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Request:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_content(operation.getRequestBody().getContent(), true));\n      }\n      if (operation.resultApiResponses().isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Return Type:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_response(operation.getApiResponses()));\n      }\n    }\n  }\n\n  private String ul_response(ChangedApiResponse changedApiResponse) {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (String propName : addResponses.keySet()) {\n      sb.append(itemResponse(\"Add \", propName));\n    }\n    for (String propName : delResponses.keySet()) {\n      sb.append(itemResponse(\"Deleted \", propName));\n    }\n    for (Entry<String, ChangedResponse> entry : changedResponses.entrySet()) {\n      sb.append(itemChangedResponse(\"Changed \", entry.getKey(), entry.getValue()));\n    }\n    return sb.toString();\n  }\n\n  private String itemResponse(String title, String code) {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(StringUtils.repeat(' ', 4))\n        .append(\"- \")\n        .append(title)\n        .append(code)\n        .append(' ')\n        .append(status)\n        .append(System.lineSeparator());\n    return sb.toString();\n  }\n\n  private String itemChangedResponse(String title, String contentType, ChangedResponse response) {\n    return itemResponse(title, contentType)\n        + StringUtils.repeat(' ', 6)\n        + \"Media types:\"\n        + System.lineSeparator()\n        + ul_content(response.getContent(), false);\n  }\n\n  private String ul_content(ChangedContent changedContent, boolean isRequest) {\n    StringBuilder sb = new StringBuilder();\n    if (changedContent == null) {\n      return sb.toString();\n    }\n    for (String propName : changedContent.getIncreased().keySet()) {\n      sb.append(itemContent(\"Added \", propName));\n    }\n    for (String propName : changedContent.getMissing().keySet()) {\n      sb.append(itemContent(\"Deleted \", propName));\n    }\n    for (String propName : changedContent.getChanged().keySet()) {\n      sb.append(\n          itemContent(\"Changed \", propName, changedContent.getChanged().get(propName), isRequest));\n    }\n    return sb.toString();\n  }\n\n  private String itemContent(String title, String contentType) {\n    return StringUtils.repeat(' ', 8) + \"- \" + title + contentType + System.lineSeparator();\n  }\n\n  private String itemContent(\n      String title, String contentType, ChangedMediaType changedMediaType, boolean isRequest) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(itemContent(title, contentType))\n        .append(StringUtils.repeat(' ', 10))\n        .append(\"Schema: \")\n        .append(changedMediaType.isCompatible() ? \"Backward compatible\" : \"Broken compatibility\")\n        .append(System.lineSeparator());\n    if (!changedMediaType.isCompatible()) {\n      sb.append(incompatibilities(changedMediaType.getSchema()));\n    }\n    return sb.toString();\n  }\n\n  private String incompatibilities(final ChangedSchema schema) {\n    return incompatibilities(\"\", schema);\n  }\n\n  private String incompatibilities(String propName, final ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getItems() != null) {\n      sb.append(items(propName, schema.getItems()));\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      sb.append(property(propName, \"Changed property type\", type));\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    sb.append(\n        properties(prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(incompatibilities(prefix + name, property)));\n    return sb.toString();\n  }\n\n  private String items(String propName, ChangedSchema schema) {\n    return incompatibilities(propName + \"[n]\", schema);\n  }\n\n  private String properties(\n      String propPrefix, String title, Map<String, Schema<?>> properties, DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach((key, value) -> sb.append(resolveProperty(propPrefix, value, key, title)));\n    }\n    return sb.toString();\n  }\n\n  private String resolveProperty(String propPrefix, Schema<?> value, String key, String title) {\n    try {\n      return property(propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      return property(propPrefix + key, title, type(value));\n    }\n  }\n\n  protected String property(String name, String title, Schema<?> schema) {\n    return property(name, title, type(schema));\n  }\n\n  protected String property(String name, String title, String type) {\n    return String.format(\"%s%s: %s (%s)%n\", StringUtils.repeat(' ', 10), title, name, type);\n  }\n\n  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }\n\n  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }\n\n  private String ul_param(ChangedParameters changedParameters) {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (Parameter param : addParameters) {\n      sb.append(itemParam(\"Add \", param));\n    }\n    for (ChangedParameter param : changed) {\n      sb.append(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      sb.append(itemParam(\"Delete \", param));\n    }\n    return sb.toString();\n  }\n\n  private String itemParam(String title, Parameter param) {\n    return \"\"\n        + StringUtils.repeat(' ', 4)\n        + \"- \"\n        + title\n        + param.getName()\n        + \" in \"\n        + param.getIn()\n        + System.lineSeparator();\n  }\n\n  private String li_changedParam(ChangedParameter changeParam) {\n    if (changeParam.isDeprecated()) {\n      return itemParam(\"Deprecated \", changeParam.getNewParameter());\n    } else {\n      return itemParam(\"Changed \", changeParam.getNewParameter());\n    }\n  }\n\n  private void listEndpoints(\n      List<Endpoint> endpoints, String title, OutputStreamWriter outputStreamWriter) {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return;\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(title(title));\n    for (Endpoint endpoint : endpoints) {\n      sb.append(\n          itemEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n\n    safelyAppend(outputStreamWriter, sb.append(System.lineSeparator()).toString());\n  }\n\n  private String itemEndpoint(String method, String path, String desc) {\n    return String.format(\"- %s %s%n\", StringUtils.rightPad(method, 6), path);\n  }\n\n  public String renderBody(String ol_new, String ol_miss, String ol_deprec, String ol_changed) {\n    return ol_new + ol_miss + ol_deprec + ol_changed;\n  }\n\n  public String bigTitle(String title) {\n    char ch = '=';\n    return this.title(title.toUpperCase(), ch);\n  }\n\n  public String title(String title) {\n    return this.title(title, '-');\n  }\n\n  public String title(String title, char ch) {\n    String little = StringUtils.repeat(ch, 2);\n    return String.format(\n        \"%s%s%s%s%n%s\",\n        separator(ch), little, StringUtils.center(title, LINE_LENGTH - 4), little, separator(ch));\n  }\n\n  public String separator(char ch) {\n    return StringUtils.repeat(ch, LINE_LENGTH) + System.lineSeparator();\n  }\n}\n", "file_hash": "c597ac060210348a3b76181dfb8860e58d6a6889d108ef88b88abe126e5b9ddf", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.output;", "import static org.openapitools.openapidiff.core.model.Changed.result;", "import io.swagger.v3.oas.models.media.ArraySchema;", "import io.swagger.v3.oas.models.media.Schema;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import java.io.IOException;", "import java.io.OutputStreamWriter;", "import java.util.List;", "import java.util.Map;", "import java.util.Map.Entry;", "import java.util.Optional;", "import org.apache.commons.lang3.StringUtils;", "import org.openapitools.openapidiff.core.exception.RendererException;", "import org.openapitools.openapidiff.core.model.*;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "public class ConsoleRender implements Render {\n  private static final int LINE_LENGTH = 74;\n  protected static RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  protected ChangedOpenApi diff;\n\n  @Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n    if (diff.isUnchanged()) {\n      safelyAppend(outputStreamWriter, \"No differences. Specifications are equivalents\");\n    } else {\n      safelyAppend(outputStreamWriter, bigTitle(\"Api Change Log\"));\n      safelyAppend(\n          outputStreamWriter,\n          StringUtils.center(diff.getNewSpecOpenApi().getInfo().getTitle(), LINE_LENGTH));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n\n      List<Endpoint> newEndpoints = diff.getNewEndpoints();\n      listEndpoints(newEndpoints, \"What's New\", outputStreamWriter);\n\n      List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n      listEndpoints(missingEndpoints, \"What's Deleted\", outputStreamWriter);\n\n      List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n      listEndpoints(deprecatedEndpoints, \"What's Deprecated\", outputStreamWriter);\n\n      List<ChangedOperation> changedOperations = diff.getChangedOperations();\n      ol_changed(changedOperations, outputStreamWriter);\n\n      safelyAppend(outputStreamWriter, title(\"Result\"));\n      safelyAppend(\n          outputStreamWriter,\n          StringUtils.center(\n              diff.isCompatible()\n                  ? \"API changes are backward compatible\"\n                  : \"API changes broke backward compatibility\",\n              LINE_LENGTH));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, separator('-'));\n    }\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }\n\n  private void ol_changed(\n      List<ChangedOperation> operations, OutputStreamWriter outputStreamWriter) {\n    if (null == operations || operations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, title(\"What's Changed\"));\n    for (ChangedOperation operation : operations) {\n      String pathUrl = operation.getPathUrl();\n      String method = operation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(operation.getSummary()).map(ChangedMetadata::getRight).orElse(\"\");\n\n      safelyAppend(outputStreamWriter, itemEndpoint(method, pathUrl, desc));\n\n      if (result(operation.getParameters()).isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Parameter:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_param(operation.getParameters()));\n      }\n      if (operation.resultRequestBody().isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Request:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_content(operation.getRequestBody().getContent(), true));\n      }\n      if (operation.resultApiResponses().isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Return Type:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_response(operation.getApiResponses()));\n      }\n    }\n  }\n\n  private String ul_response(ChangedApiResponse changedApiResponse) {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (String propName : addResponses.keySet()) {\n      sb.append(itemResponse(\"Add \", propName));\n    }\n    for (String propName : delResponses.keySet()) {\n      sb.append(itemResponse(\"Deleted \", propName));\n    }\n    for (Entry<String, ChangedResponse> entry : changedResponses.entrySet()) {\n      sb.append(itemChangedResponse(\"Changed \", entry.getKey(), entry.getValue()));\n    }\n    return sb.toString();\n  }\n\n  private String itemResponse(String title, String code) {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(StringUtils.repeat(' ', 4))\n        .append(\"- \")\n        .append(title)\n        .append(code)\n        .append(' ')\n        .append(status)\n        .append(System.lineSeparator());\n    return sb.toString();\n  }\n\n  private String itemChangedResponse(String title, String contentType, ChangedResponse response) {\n    return itemResponse(title, contentType)\n        + StringUtils.repeat(' ', 6)\n        + \"Media types:\"\n        + System.lineSeparator()\n        + ul_content(response.getContent(), false);\n  }\n\n  private String ul_content(ChangedContent changedContent, boolean isRequest) {\n    StringBuilder sb = new StringBuilder();\n    if (changedContent == null) {\n      return sb.toString();\n    }\n    for (String propName : changedContent.getIncreased().keySet()) {\n      sb.append(itemContent(\"Added \", propName));\n    }\n    for (String propName : changedContent.getMissing().keySet()) {\n      sb.append(itemContent(\"Deleted \", propName));\n    }\n    for (String propName : changedContent.getChanged().keySet()) {\n      sb.append(\n          itemContent(\"Changed \", propName, changedContent.getChanged().get(propName), isRequest));\n    }\n    return sb.toString();\n  }\n\n  private String itemContent(String title, String contentType) {\n    return StringUtils.repeat(' ', 8) + \"- \" + title + contentType + System.lineSeparator();\n  }\n\n  private String itemContent(\n      String title, String contentType, ChangedMediaType changedMediaType, boolean isRequest) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(itemContent(title, contentType))\n        .append(StringUtils.repeat(' ', 10))\n        .append(\"Schema: \")\n        .append(changedMediaType.isCompatible() ? \"Backward compatible\" : \"Broken compatibility\")\n        .append(System.lineSeparator());\n    if (!changedMediaType.isCompatible()) {\n      sb.append(incompatibilities(changedMediaType.getSchema()));\n    }\n    return sb.toString();\n  }\n\n  private String incompatibilities(final ChangedSchema schema) {\n    return incompatibilities(\"\", schema);\n  }\n\n  private String incompatibilities(String propName, final ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getItems() != null) {\n      sb.append(items(propName, schema.getItems()));\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      sb.append(property(propName, \"Changed property type\", type));\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    sb.append(\n        properties(prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(incompatibilities(prefix + name, property)));\n    return sb.toString();\n  }\n\n  private String items(String propName, ChangedSchema schema) {\n    return incompatibilities(propName + \"[n]\", schema);\n  }\n\n  private String properties(\n      String propPrefix, String title, Map<String, Schema<?>> properties, DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach((key, value) -> sb.append(resolveProperty(propPrefix, value, key, title)));\n    }\n    return sb.toString();\n  }\n\n  private String resolveProperty(String propPrefix, Schema<?> value, String key, String title) {\n    try {\n      return property(propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      return property(propPrefix + key, title, type(value));\n    }\n  }\n\n  protected String property(String name, String title, Schema<?> schema) {\n    return property(name, title, type(schema));\n  }\n\n  protected String property(String name, String title, String type) {\n    return String.format(\"%s%s: %s (%s)%n\", StringUtils.repeat(' ', 10), title, name, type);\n  }\n\n  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }\n\n  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }\n\n  private String ul_param(ChangedParameters changedParameters) {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (Parameter param : addParameters) {\n      sb.append(itemParam(\"Add \", param));\n    }\n    for (ChangedParameter param : changed) {\n      sb.append(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      sb.append(itemParam(\"Delete \", param));\n    }\n    return sb.toString();\n  }\n\n  private String itemParam(String title, Parameter param) {\n    return \"\"\n        + StringUtils.repeat(' ', 4)\n        + \"- \"\n        + title\n        + param.getName()\n        + \" in \"\n        + param.getIn()\n        + System.lineSeparator();\n  }\n\n  private String li_changedParam(ChangedParameter changeParam) {\n    if (changeParam.isDeprecated()) {\n      return itemParam(\"Deprecated \", changeParam.getNewParameter());\n    } else {\n      return itemParam(\"Changed \", changeParam.getNewParameter());\n    }\n  }\n\n  private void listEndpoints(\n      List<Endpoint> endpoints, String title, OutputStreamWriter outputStreamWriter) {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return;\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(title(title));\n    for (Endpoint endpoint : endpoints) {\n      sb.append(\n          itemEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n\n    safelyAppend(outputStreamWriter, sb.append(System.lineSeparator()).toString());\n  }\n\n  private String itemEndpoint(String method, String path, String desc) {\n    return String.format(\"- %s %s%n\", StringUtils.rightPad(method, 6), path);\n  }\n\n  public String renderBody(String ol_new, String ol_miss, String ol_deprec, String ol_changed) {\n    return ol_new + ol_miss + ol_deprec + ol_changed;\n  }\n\n  public String bigTitle(String title) {\n    char ch = '=';\n    return this.title(title.toUpperCase(), ch);\n  }\n\n  public String title(String title) {\n    return this.title(title, '-');\n  }\n\n  public String title(String title, char ch) {\n    String little = StringUtils.repeat(ch, 2);\n    return String.format(\n        \"%s%s%s%s%n%s\",\n        separator(ch), little, StringUtils.center(title, LINE_LENGTH - 4), little, separator(ch));\n  }\n\n  public String separator(char ch) {\n    return StringUtils.repeat(ch, LINE_LENGTH) + System.lineSeparator();\n  }\n}", "definition": "public class ConsoleRender implements Render", "class_docstring": "", "name": "ConsoleRender", "super_interfaces": ["Render"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final int LINE_LENGTH = 74;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "LINE_LENGTH = 74", "syntax_pass": true}, {"attribute_expression": "protected static RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);", "docstring": "", "modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "type": "RefPointer<Schema<?>>", "name": "refPointer = new RefPointer<>(RefType.SCHEMAS)", "syntax_pass": true}, {"attribute_expression": "protected ChangedOpenApi diff;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedOpenApi", "name": "diff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n    if (diff.isUnchanged()) {\n      safelyAppend(outputStreamWriter, \"No differences. Specifications are equivalents\");\n    } else {\n      safelyAppend(outputStreamWriter, bigTitle(\"Api Change Log\"));\n      safelyAppend(\n          outputStreamWriter,\n          StringUtils.center(diff.getNewSpecOpenApi().getInfo().getTitle(), LINE_LENGTH));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n\n      List<Endpoint> newEndpoints = diff.getNewEndpoints();\n      listEndpoints(newEndpoints, \"What's New\", outputStreamWriter);\n\n      List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n      listEndpoints(missingEndpoints, \"What's Deleted\", outputStreamWriter);\n\n      List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n      listEndpoints(deprecatedEndpoints, \"What's Deprecated\", outputStreamWriter);\n\n      List<ChangedOperation> changedOperations = diff.getChangedOperations();\n      ol_changed(changedOperations, outputStreamWriter);\n\n      safelyAppend(outputStreamWriter, title(\"Result\"));\n      safelyAppend(\n          outputStreamWriter,\n          StringUtils.center(\n              diff.isCompatible()\n                  ? \"API changes are backward compatible\"\n                  : \"API changes broke backward compatibility\",\n              LINE_LENGTH));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, separator('-'));\n    }\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "render", "params": [{"name": "diff", "type": "ChangedOpenApi"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                 {\n    this.diff = diff;\n    if (diff.isUnchanged()) {\n      safelyAppend(outputStreamWriter, \"No differences. Specifications are equivalents\");\n    } else {\n      safelyAppend(outputStreamWriter, bigTitle(\"Api Change Log\"));\n      safelyAppend(\n          outputStreamWriter,\n          StringUtils.center(diff.getNewSpecOpenApi().getInfo().getTitle(), LINE_LENGTH));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n\n      List<Endpoint> newEndpoints = diff.getNewEndpoints();\n      listEndpoints(newEndpoints, \"What's New\", outputStreamWriter);\n\n      List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n      listEndpoints(missingEndpoints, \"What's Deleted\", outputStreamWriter);\n\n      List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n      listEndpoints(deprecatedEndpoints, \"What's Deprecated\", outputStreamWriter);\n\n      List<ChangedOperation> changedOperations = diff.getChangedOperations();\n      ol_changed(changedOperations, outputStreamWriter);\n\n      safelyAppend(outputStreamWriter, title(\"Result\"));\n      safelyAppend(\n          outputStreamWriter,\n          StringUtils.center(\n              diff.isCompatible()\n                  ? \"API changes are backward compatible\"\n                  : \"API changes broke backward compatibility\",\n              LINE_LENGTH));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, separator('-'));\n    }\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }", "signature": "@Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  private void ol_changed(\n      List<ChangedOperation> operations, OutputStreamWriter outputStreamWriter) {\n    if (null == operations || operations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, title(\"What's Changed\"));\n    for (ChangedOperation operation : operations) {\n      String pathUrl = operation.getPathUrl();\n      String method = operation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(operation.getSummary()).map(ChangedMetadata::getRight).orElse(\"\");\n\n      safelyAppend(outputStreamWriter, itemEndpoint(method, pathUrl, desc));\n\n      if (result(operation.getParameters()).isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Parameter:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_param(operation.getParameters()));\n      }\n      if (operation.resultRequestBody().isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Request:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_content(operation.getRequestBody().getContent(), true));\n      }\n      if (operation.resultApiResponses().isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Return Type:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_response(operation.getApiResponses()));\n      }\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "ol_changed", "params": [{"name": "operations", "type": "List<ChangedOperation>"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                {\n    if (null == operations || operations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, title(\"What's Changed\"));\n    for (ChangedOperation operation : operations) {\n      String pathUrl = operation.getPathUrl();\n      String method = operation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(operation.getSummary()).map(ChangedMetadata::getRight).orElse(\"\");\n\n      safelyAppend(outputStreamWriter, itemEndpoint(method, pathUrl, desc));\n\n      if (result(operation.getParameters()).isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Parameter:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_param(operation.getParameters()));\n      }\n      if (operation.resultRequestBody().isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Request:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_content(operation.getRequestBody().getContent(), true));\n      }\n      if (operation.resultApiResponses().isDifferent()) {\n        safelyAppend(outputStreamWriter, StringUtils.repeat(' ', 2));\n        safelyAppend(outputStreamWriter, \"Return Type:\");\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n        safelyAppend(outputStreamWriter, ul_response(operation.getApiResponses()));\n      }\n    }\n  }", "signature": "private void ol_changed(\n      List<ChangedOperation> operations, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  private String ul_response(ChangedApiResponse changedApiResponse) {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (String propName : addResponses.keySet()) {\n      sb.append(itemResponse(\"Add \", propName));\n    }\n    for (String propName : delResponses.keySet()) {\n      sb.append(itemResponse(\"Deleted \", propName));\n    }\n    for (Entry<String, ChangedResponse> entry : changedResponses.entrySet()) {\n      sb.append(itemChangedResponse(\"Changed \", entry.getKey(), entry.getValue()));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "ul_response", "params": [{"name": "changedApiResponse", "type": "ChangedApiResponse"}], "body": "                                                                    {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (String propName : addResponses.keySet()) {\n      sb.append(itemResponse(\"Add \", propName));\n    }\n    for (String propName : delResponses.keySet()) {\n      sb.append(itemResponse(\"Deleted \", propName));\n    }\n    for (Entry<String, ChangedResponse> entry : changedResponses.entrySet()) {\n      sb.append(itemChangedResponse(\"Changed \", entry.getKey(), entry.getValue()));\n    }\n    return sb.toString();\n  }", "signature": "private String ul_response(ChangedApiResponse changedApiResponse)"}, {"syntax_pass": true, "original_string": "  private String itemResponse(String title, String code) {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(StringUtils.repeat(' ', 4))\n        .append(\"- \")\n        .append(title)\n        .append(code)\n        .append(' ')\n        .append(status)\n        .append(System.lineSeparator());\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemResponse", "params": [{"name": "title", "type": "String"}, {"name": "code", "type": "String"}], "body": "                                                         {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(StringUtils.repeat(' ', 4))\n        .append(\"- \")\n        .append(title)\n        .append(code)\n        .append(' ')\n        .append(status)\n        .append(System.lineSeparator());\n    return sb.toString();\n  }", "signature": "private String itemResponse(String title, String code)"}, {"syntax_pass": true, "original_string": "  private String itemChangedResponse(String title, String contentType, ChangedResponse response) {\n    return itemResponse(title, contentType)\n        + StringUtils.repeat(' ', 6)\n        + \"Media types:\"\n        + System.lineSeparator()\n        + ul_content(response.getContent(), false);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemChangedResponse", "params": [{"name": "title", "type": "String"}, {"name": "contentType", "type": "String"}, {"name": "response", "type": "ChangedResponse"}], "body": "                                                                                                 {\n    return itemResponse(title, contentType)\n        + StringUtils.repeat(' ', 6)\n        + \"Media types:\"\n        + System.lineSeparator()\n        + ul_content(response.getContent(), false);\n  }", "signature": "private String itemChangedResponse(String title, String contentType, ChangedResponse response)"}, {"syntax_pass": true, "original_string": "  private String ul_content(ChangedContent changedContent, boolean isRequest) {\n    StringBuilder sb = new StringBuilder();\n    if (changedContent == null) {\n      return sb.toString();\n    }\n    for (String propName : changedContent.getIncreased().keySet()) {\n      sb.append(itemContent(\"Added \", propName));\n    }\n    for (String propName : changedContent.getMissing().keySet()) {\n      sb.append(itemContent(\"Deleted \", propName));\n    }\n    for (String propName : changedContent.getChanged().keySet()) {\n      sb.append(\n          itemContent(\"Changed \", propName, changedContent.getChanged().get(propName), isRequest));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "ul_content", "params": [{"name": "changedContent", "type": "ChangedContent"}, {"name": "isRequest", "type": "boolean"}], "body": "                                                                              {\n    StringBuilder sb = new StringBuilder();\n    if (changedContent == null) {\n      return sb.toString();\n    }\n    for (String propName : changedContent.getIncreased().keySet()) {\n      sb.append(itemContent(\"Added \", propName));\n    }\n    for (String propName : changedContent.getMissing().keySet()) {\n      sb.append(itemContent(\"Deleted \", propName));\n    }\n    for (String propName : changedContent.getChanged().keySet()) {\n      sb.append(\n          itemContent(\"Changed \", propName, changedContent.getChanged().get(propName), isRequest));\n    }\n    return sb.toString();\n  }", "signature": "private String ul_content(ChangedContent changedContent, boolean isRequest)"}, {"syntax_pass": true, "original_string": "  private String itemContent(String title, String contentType) {\n    return StringUtils.repeat(' ', 8) + \"- \" + title + contentType + System.lineSeparator();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemContent", "params": [{"name": "title", "type": "String"}, {"name": "contentType", "type": "String"}], "body": "                                                               {\n    return StringUtils.repeat(' ', 8) + \"- \" + title + contentType + System.lineSeparator();\n  }", "signature": "private String itemContent(String title, String contentType)"}, {"syntax_pass": true, "original_string": "  private String itemContent(\n      String title, String contentType, ChangedMediaType changedMediaType, boolean isRequest) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(itemContent(title, contentType))\n        .append(StringUtils.repeat(' ', 10))\n        .append(\"Schema: \")\n        .append(changedMediaType.isCompatible() ? \"Backward compatible\" : \"Broken compatibility\")\n        .append(System.lineSeparator());\n    if (!changedMediaType.isCompatible()) {\n      sb.append(incompatibilities(changedMediaType.getSchema()));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemContent", "params": [{"name": "title", "type": "String"}, {"name": "contentType", "type": "String"}, {"name": "changedMediaType", "type": "ChangedMediaType"}, {"name": "isRequest", "type": "boolean"}], "body": "                                                                                              {\n    StringBuilder sb = new StringBuilder();\n    sb.append(itemContent(title, contentType))\n        .append(StringUtils.repeat(' ', 10))\n        .append(\"Schema: \")\n        .append(changedMediaType.isCompatible() ? \"Backward compatible\" : \"Broken compatibility\")\n        .append(System.lineSeparator());\n    if (!changedMediaType.isCompatible()) {\n      sb.append(incompatibilities(changedMediaType.getSchema()));\n    }\n    return sb.toString();\n  }", "signature": "private String itemContent(\n      String title, String contentType, ChangedMediaType changedMediaType, boolean isRequest)"}, {"syntax_pass": true, "original_string": "  private String incompatibilities(final ChangedSchema schema) {\n    return incompatibilities(\"\", schema);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "incompatibilities", "params": [{"name": "schema", "type": "ChangedSchema"}], "body": "                                                               {\n    return incompatibilities(\"\", schema);\n  }", "signature": "private String incompatibilities(final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private String incompatibilities(String propName, final ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getItems() != null) {\n      sb.append(items(propName, schema.getItems()));\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      sb.append(property(propName, \"Changed property type\", type));\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    sb.append(\n        properties(prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(incompatibilities(prefix + name, property)));\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "incompatibilities", "params": [{"name": "propName", "type": "String"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                                                {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getItems() != null) {\n      sb.append(items(propName, schema.getItems()));\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      sb.append(property(propName, \"Changed property type\", type));\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    sb.append(\n        properties(prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(incompatibilities(prefix + name, property)));\n    return sb.toString();\n  }", "signature": "private String incompatibilities(String propName, final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private String items(String propName, ChangedSchema schema) {\n    return incompatibilities(propName + \"[n]\", schema);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "items", "params": [{"name": "propName", "type": "String"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                              {\n    return incompatibilities(propName + \"[n]\", schema);\n  }", "signature": "private String items(String propName, ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private String properties(\n      String propPrefix, String title, Map<String, Schema<?>> properties, DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach((key, value) -> sb.append(resolveProperty(propPrefix, value, key, title)));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "properties", "params": [{"name": "propPrefix", "type": "String"}, {"name": "title", "type": "String"}, {"name": "properties", "type": "Map<String, Schema<?>>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                               {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach((key, value) -> sb.append(resolveProperty(propPrefix, value, key, title)));\n    }\n    return sb.toString();\n  }", "signature": "private String properties(\n      String propPrefix, String title, Map<String, Schema<?>> properties, DiffContext context)"}, {"syntax_pass": true, "original_string": "  private String resolveProperty(String propPrefix, Schema<?> value, String key, String title) {\n    try {\n      return property(propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      return property(propPrefix + key, title, type(value));\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "resolveProperty", "params": [{"name": "propPrefix", "type": "String"}, {"name": "value", "type": "Schema<?>"}, {"name": "key", "type": "String"}, {"name": "title", "type": "String"}], "body": "                                                                                               {\n    try {\n      return property(propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      return property(propPrefix + key, title, type(value));\n    }\n  }", "signature": "private String resolveProperty(String propPrefix, Schema<?> value, String key, String title)"}, {"syntax_pass": true, "original_string": "  protected String property(String name, String title, Schema<?> schema) {\n    return property(name, title, type(schema));\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "property", "params": [{"name": "name", "type": "String"}, {"name": "title", "type": "String"}, {"name": "schema", "type": "Schema<?>"}], "body": "                                                                         {\n    return property(name, title, type(schema));\n  }", "signature": "protected String property(String name, String title, Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  protected String property(String name, String title, String type) {\n    return String.format(\"%s%s: %s (%s)%n\", StringUtils.repeat(' ', 10), title, name, type);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "property", "params": [{"name": "name", "type": "String"}, {"name": "title", "type": "String"}, {"name": "type", "type": "String"}], "body": "                                                                    {\n    return String.format(\"%s%s: %s (%s)%n\", StringUtils.repeat(' ', 10), title, name, type);\n  }", "signature": "protected String property(String name, String title, String type)"}, {"syntax_pass": true, "original_string": "  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Schema<?>", "classes": []}, "name": "resolve", "params": [{"name": "schema", "type": "Schema<?>"}], "body": "                                                {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }", "signature": "protected Schema<?> resolve(Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "type", "params": [{"name": "schema", "type": "Schema<?>"}], "body": "                                          {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }", "signature": "protected String type(Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  private String ul_param(ChangedParameters changedParameters) {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (Parameter param : addParameters) {\n      sb.append(itemParam(\"Add \", param));\n    }\n    for (ChangedParameter param : changed) {\n      sb.append(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      sb.append(itemParam(\"Delete \", param));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "ul_param", "params": [{"name": "changedParameters", "type": "ChangedParameters"}], "body": "                                                               {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (Parameter param : addParameters) {\n      sb.append(itemParam(\"Add \", param));\n    }\n    for (ChangedParameter param : changed) {\n      sb.append(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      sb.append(itemParam(\"Delete \", param));\n    }\n    return sb.toString();\n  }", "signature": "private String ul_param(ChangedParameters changedParameters)"}, {"syntax_pass": true, "original_string": "  private String itemParam(String title, Parameter param) {\n    return \"\"\n        + StringUtils.repeat(' ', 4)\n        + \"- \"\n        + title\n        + param.getName()\n        + \" in \"\n        + param.getIn()\n        + System.lineSeparator();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemParam", "params": [{"name": "title", "type": "String"}, {"name": "param", "type": "Parameter"}], "body": "                                                          {\n    return \"\"\n        + StringUtils.repeat(' ', 4)\n        + \"- \"\n        + title\n        + param.getName()\n        + \" in \"\n        + param.getIn()\n        + System.lineSeparator();\n  }", "signature": "private String itemParam(String title, Parameter param)"}, {"syntax_pass": true, "original_string": "  private String li_changedParam(ChangedParameter changeParam) {\n    if (changeParam.isDeprecated()) {\n      return itemParam(\"Deprecated \", changeParam.getNewParameter());\n    } else {\n      return itemParam(\"Changed \", changeParam.getNewParameter());\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "li_changedParam", "params": [{"name": "changeParam", "type": "ChangedParameter"}], "body": "                                                               {\n    if (changeParam.isDeprecated()) {\n      return itemParam(\"Deprecated \", changeParam.getNewParameter());\n    } else {\n      return itemParam(\"Changed \", changeParam.getNewParameter());\n    }\n  }", "signature": "private String li_changedParam(ChangedParameter changeParam)"}, {"syntax_pass": true, "original_string": "  private void listEndpoints(\n      List<Endpoint> endpoints, String title, OutputStreamWriter outputStreamWriter) {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return;\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(title(title));\n    for (Endpoint endpoint : endpoints) {\n      sb.append(\n          itemEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n\n    safelyAppend(outputStreamWriter, sb.append(System.lineSeparator()).toString());\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "listEndpoints", "params": [{"name": "endpoints", "type": "List<Endpoint>"}, {"name": "title", "type": "String"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                     {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return;\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(title(title));\n    for (Endpoint endpoint : endpoints) {\n      sb.append(\n          itemEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n\n    safelyAppend(outputStreamWriter, sb.append(System.lineSeparator()).toString());\n  }", "signature": "private void listEndpoints(\n      List<Endpoint> endpoints, String title, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  private String itemEndpoint(String method, String path, String desc) {\n    return String.format(\"- %s %s%n\", StringUtils.rightPad(method, 6), path);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemEndpoint", "params": [{"name": "method", "type": "String"}, {"name": "path", "type": "String"}, {"name": "desc", "type": "String"}], "body": "                                                                       {\n    return String.format(\"- %s %s%n\", StringUtils.rightPad(method, 6), path);\n  }", "signature": "private String itemEndpoint(String method, String path, String desc)"}, {"syntax_pass": true, "original_string": "  public String renderBody(String ol_new, String ol_miss, String ol_deprec, String ol_changed) {\n    return ol_new + ol_miss + ol_deprec + ol_changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "renderBody", "params": [{"name": "ol_new", "type": "String"}, {"name": "ol_miss", "type": "String"}, {"name": "ol_deprec", "type": "String"}, {"name": "ol_changed", "type": "String"}], "body": "                                                                                               {\n    return ol_new + ol_miss + ol_deprec + ol_changed;\n  }", "signature": "public String renderBody(String ol_new, String ol_miss, String ol_deprec, String ol_changed)"}, {"syntax_pass": true, "original_string": "  public String bigTitle(String title) {\n    char ch = '=';\n    return this.title(title.toUpperCase(), ch);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "bigTitle", "params": [{"name": "title", "type": "String"}], "body": "                                       {\n    char ch = '=';\n    return this.title(title.toUpperCase(), ch);\n  }", "signature": "public String bigTitle(String title)"}, {"syntax_pass": true, "original_string": "  public String title(String title) {\n    return this.title(title, '-');\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "title", "params": [{"name": "title", "type": "String"}], "body": "                                    {\n    return this.title(title, '-');\n  }", "signature": "public String title(String title)"}, {"syntax_pass": true, "original_string": "  public String title(String title, char ch) {\n    String little = StringUtils.repeat(ch, 2);\n    return String.format(\n        \"%s%s%s%s%n%s\",\n        separator(ch), little, StringUtils.center(title, LINE_LENGTH - 4), little, separator(ch));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "title", "params": [{"name": "title", "type": "String"}, {"name": "ch", "type": "char"}], "body": "                                             {\n    String little = StringUtils.repeat(ch, 2);\n    return String.format(\n        \"%s%s%s%s%n%s\",\n        separator(ch), little, StringUtils.center(title, LINE_LENGTH - 4), little, separator(ch));\n  }", "signature": "public String title(String title, char ch)"}, {"syntax_pass": true, "original_string": "  public String separator(char ch) {\n    return StringUtils.repeat(ch, LINE_LENGTH) + System.lineSeparator();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "separator", "params": [{"name": "ch", "type": "char"}], "body": "                                   {\n    return StringUtils.repeat(ch, LINE_LENGTH) + System.lineSeparator();\n  }", "signature": "public String separator(char ch)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/output/JsonRender.java", "original_string": "package org.openapitools.openapidiff.core.output;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport org.openapitools.openapidiff.core.exception.RendererException;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\n\npublic class JsonRender implements Render {\n  private final ObjectMapper objectMapper;\n\n  public JsonRender() {\n    objectMapper = new ObjectMapper();\n    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n    objectMapper.findAndRegisterModules();\n  }\n\n  @Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    try {\n      objectMapper.writeValue(outputStreamWriter, diff);\n      outputStreamWriter.close();\n    } catch (JsonProcessingException e) {\n      throw new RendererException(\"Could not serialize diff as JSON\", e);\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }\n}\n", "file_hash": "200ce60189d320d8bec340fe8e907a54974fe952b48a2500a8340e830727068c", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.output;", "import com.fasterxml.jackson.annotation.JsonInclude;", "import com.fasterxml.jackson.core.JsonProcessingException;", "import com.fasterxml.jackson.databind.ObjectMapper;", "import java.io.IOException;", "import java.io.OutputStreamWriter;", "import org.openapitools.openapidiff.core.exception.RendererException;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;"], "methods": [], "classes": [{"original_string": "public class JsonRender implements Render {\n  private final ObjectMapper objectMapper;\n\n  public JsonRender() {\n    objectMapper = new ObjectMapper();\n    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n    objectMapper.findAndRegisterModules();\n  }\n\n  @Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    try {\n      objectMapper.writeValue(outputStreamWriter, diff);\n      outputStreamWriter.close();\n    } catch (JsonProcessingException e) {\n      throw new RendererException(\"Could not serialize diff as JSON\", e);\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }\n}", "definition": "public class JsonRender implements Render", "class_docstring": "", "name": "JsonRender", "super_interfaces": ["Render"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final ObjectMapper objectMapper;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ObjectMapper", "name": "objectMapper", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public JsonRender() {\n    objectMapper = new ObjectMapper();\n    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n    objectMapper.findAndRegisterModules();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "JsonRender", "params": [], "body": "                      {\n    objectMapper = new ObjectMapper();\n    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n    objectMapper.findAndRegisterModules();\n  }", "signature": "public JsonRender()"}, {"syntax_pass": true, "original_string": "  @Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    try {\n      objectMapper.writeValue(outputStreamWriter, diff);\n      outputStreamWriter.close();\n    } catch (JsonProcessingException e) {\n      throw new RendererException(\"Could not serialize diff as JSON\", e);\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "render", "params": [{"name": "diff", "type": "ChangedOpenApi"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                 {\n    try {\n      objectMapper.writeValue(outputStreamWriter, diff);\n      outputStreamWriter.close();\n    } catch (JsonProcessingException e) {\n      throw new RendererException(\"Could not serialize diff as JSON\", e);\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }", "signature": "@Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/output/AsciidocRender.java", "original_string": "package org.openapitools.openapidiff.core.output;\n\nimport static org.openapitools.openapidiff.core.model.Changed.result;\n\nimport io.swagger.v3.oas.models.media.ArraySchema;\nimport io.swagger.v3.oas.models.media.Schema;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Optional;\nimport org.apache.commons.lang3.StringUtils;\nimport org.openapitools.openapidiff.core.exception.RendererException;\nimport org.openapitools.openapidiff.core.model.*;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\npublic class AsciidocRender implements Render {\n  private static final int LINE_LENGTH = 74;\n  protected static RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  protected ChangedOpenApi diff;\n\n  @Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n    if (diff.isUnchanged()) {\n      safelyAppend(\n          outputStreamWriter,\n          bigTitle(\n              diff.getNewSpecOpenApi().getInfo().getTitle(),\n              diff.getNewSpecOpenApi().getInfo().getVersion()));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, \"NOTE: No differences. Specifications are equivalents\");\n    } else {\n      safelyAppend(\n          outputStreamWriter,\n          bigTitle(\n              diff.getNewSpecOpenApi().getInfo().getTitle(),\n              diff.getNewSpecOpenApi().getInfo().getVersion()));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, \":reproducible:\\n:sectlinks:\\n:toc:\\n\");\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n\n      List<Endpoint> newEndpoints = diff.getNewEndpoints();\n      listEndpoints(newEndpoints, \"What's New\", outputStreamWriter);\n\n      List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n      listEndpoints(missingEndpoints, \"What's Deleted\", outputStreamWriter);\n\n      List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n      listEndpoints(deprecatedEndpoints, \"What's Deprecated\", outputStreamWriter);\n\n      List<ChangedOperation> changedOperations = diff.getChangedOperations();\n      ol_changed(changedOperations, outputStreamWriter);\n\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(\n          outputStreamWriter,\n          diff.isCompatible()\n              ? \"NOTE: API changes are backward compatible\"\n              : \"WARNING: API changes broke backward compatibility\");\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n    }\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }\n\n  private void ol_changed(\n      List<ChangedOperation> operations, OutputStreamWriter outputStreamWriter) {\n    if (null == operations || operations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, title(\"What's Changed\", 2));\n    safelyAppend(outputStreamWriter, System.lineSeparator());\n    for (ChangedOperation operation : operations) {\n      String pathUrl = operation.getPathUrl();\n      String method = operation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(operation.getSummary()).map(ChangedMetadata::getRight).orElse(\"\");\n\n      safelyAppend(outputStreamWriter, itemEndpoint(method, pathUrl, desc));\n      if (result(operation.getParameters()).isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Parameter:\\n\");\n        safelyAppend(outputStreamWriter, ul_param(operation.getParameters()));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n      if (operation.resultRequestBody().isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Request:\\n\");\n        safelyAppend(\n            outputStreamWriter, ul_content(operation.getRequestBody().getContent(), true, 2));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n      if (operation.resultApiResponses().isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Return Type:\\n\");\n        safelyAppend(outputStreamWriter, ul_response(operation.getApiResponses()));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n    }\n  }\n\n  private String ul_response(ChangedApiResponse changedApiResponse) {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (String propName : addResponses.keySet()) {\n      sb.append(itemResponse(\"** Add \", propName));\n    }\n    for (String propName : delResponses.keySet()) {\n      sb.append(itemResponse(\"** Deleted \", propName));\n    }\n    for (Entry<String, ChangedResponse> entry : changedResponses.entrySet()) {\n      sb.append(itemChangedResponse(\"** Changed \", entry.getKey(), entry.getValue()));\n    }\n    return sb.toString();\n  }\n\n  private String itemResponse(String title, String code) {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(title).append(code).append(' ').append(status).append(\"\\n\");\n    return sb.toString();\n  }\n\n  private String itemChangedResponse(String title, String contentType, ChangedResponse response) {\n    return itemResponse(title, contentType)\n        + \"** Media types:\\n\"\n        + ul_content(response.getContent(), false, 3);\n  }\n\n  private String ul_content(ChangedContent changedContent, boolean isRequest, int indent) {\n    StringBuilder sb = new StringBuilder();\n    if (changedContent == null) {\n      return sb.toString();\n    }\n    for (String propName : changedContent.getIncreased().keySet()) {\n      sb.append(itemContent(\"Added \", propName, indent));\n    }\n    for (String propName : changedContent.getMissing().keySet()) {\n      sb.append(itemContent(\"Deleted \", propName, indent));\n    }\n    for (String propName : changedContent.getChanged().keySet()) {\n      sb.append(\n          itemContent(\n              \"Changed \", propName, indent, changedContent.getChanged().get(propName), isRequest));\n    }\n    return sb.toString();\n  }\n\n  private String itemContent(String title, String contentType, int indent) {\n    return StringUtils.repeat('*', indent) + \" \" + title + contentType + \"\\n\";\n  }\n\n  private String itemContent(\n      String title,\n      String contentType,\n      int indent,\n      ChangedMediaType changedMediaType,\n      boolean isRequest) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(itemContent(title, contentType, indent))\n        .append(itemContent(\"Schema:\", \"\", indent))\n        .append(changedMediaType.isCompatible() ? \"Backward compatible\" : \"Broken compatibility\")\n        .append(\"\\n\");\n    if (!changedMediaType.isCompatible()) {\n      sb.append(incompatibilities(changedMediaType.getSchema()));\n    }\n    return sb.toString();\n  }\n\n  private String incompatibilities(final ChangedSchema schema) {\n    return incompatibilities(\"\", schema);\n  }\n\n  private String incompatibilities(String propName, final ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getItems() != null) {\n      sb.append(items(propName, schema.getItems()));\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      sb.append(property(propName, \"Changed property type\", type));\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    sb.append(\n        properties(prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(incompatibilities(prefix + name, property)));\n    return sb.toString();\n  }\n\n  private String items(String propName, ChangedSchema schema) {\n    return incompatibilities(propName + \"[n]\", schema);\n  }\n\n  private String properties(\n      String propPrefix, String title, Map<String, Schema<?>> properties, DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach((key, value) -> sb.append(resolveProperty(propPrefix, value, key, title)));\n    }\n    return sb.toString();\n  }\n\n  private String resolveProperty(String propPrefix, Schema<?> value, String key, String title) {\n    try {\n      return property(propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      return property(propPrefix + key, title, type(value));\n    }\n  }\n\n  protected String property(String name, String title, Schema<?> schema) {\n    return property(name, title, type(schema));\n  }\n\n  protected String property(String name, String title, String type) {\n    return String.format(\"*** %s: %s (%s)%n\\n\", title, name, type);\n  }\n\n  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }\n\n  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }\n\n  private String ul_param(ChangedParameters changedParameters) {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (Parameter param : addParameters) {\n      sb.append(itemParam(\"** Add \", param));\n    }\n    for (ChangedParameter param : changed) {\n      sb.append(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      sb.append(itemParam(\"** Delete \", param));\n    }\n    return sb.toString();\n  }\n\n  private String itemParam(String title, Parameter param) {\n    return title + param.getName() + \" in \" + param.getIn() + System.lineSeparator();\n  }\n\n  private String li_changedParam(ChangedParameter changeParam) {\n    if (changeParam.isDeprecated()) {\n      return itemParam(\"** Deprecated \", changeParam.getNewParameter());\n    } else {\n      return itemParam(\"** Changed \", changeParam.getNewParameter());\n    }\n  }\n\n  private String listEndpoints(\n      List<Endpoint> endpoints, String title, OutputStreamWriter outputStreamWriter) {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(title(title));\n    for (Endpoint endpoint : endpoints) {\n      sb.append(\n          itemEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return sb.append(System.lineSeparator()).toString();\n  }\n\n  private String itemEndpoint(String method, String path, String desc) {\n    return String.format(\"=== %s%s%n\", StringUtils.rightPad(method, 6), path);\n  }\n\n  public String bigTitle(String title, String version) {\n    char ch = '=';\n\n    return String.format(\"= %s (v %s)\", title.toUpperCase(), version);\n  }\n\n  public String title(String title) {\n    return this.title(title, '-');\n  }\n\n  public String title(String title, int level) {\n    String little = StringUtils.repeat(\"=\", level);\n    return String.format(\"%s %s\", little, title);\n  }\n}\n", "file_hash": "5e1cb647318d79dbdd4df27ccfb1e7ab15caf4670e5c6b66e910ae9af905f73b", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.output;", "import static org.openapitools.openapidiff.core.model.Changed.result;", "import io.swagger.v3.oas.models.media.ArraySchema;", "import io.swagger.v3.oas.models.media.Schema;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import java.io.IOException;", "import java.io.OutputStreamWriter;", "import java.util.List;", "import java.util.Map;", "import java.util.Map.Entry;", "import java.util.Optional;", "import org.apache.commons.lang3.StringUtils;", "import org.openapitools.openapidiff.core.exception.RendererException;", "import org.openapitools.openapidiff.core.model.*;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "public class AsciidocRender implements Render {\n  private static final int LINE_LENGTH = 74;\n  protected static RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  protected ChangedOpenApi diff;\n\n  @Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n    if (diff.isUnchanged()) {\n      safelyAppend(\n          outputStreamWriter,\n          bigTitle(\n              diff.getNewSpecOpenApi().getInfo().getTitle(),\n              diff.getNewSpecOpenApi().getInfo().getVersion()));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, \"NOTE: No differences. Specifications are equivalents\");\n    } else {\n      safelyAppend(\n          outputStreamWriter,\n          bigTitle(\n              diff.getNewSpecOpenApi().getInfo().getTitle(),\n              diff.getNewSpecOpenApi().getInfo().getVersion()));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, \":reproducible:\\n:sectlinks:\\n:toc:\\n\");\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n\n      List<Endpoint> newEndpoints = diff.getNewEndpoints();\n      listEndpoints(newEndpoints, \"What's New\", outputStreamWriter);\n\n      List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n      listEndpoints(missingEndpoints, \"What's Deleted\", outputStreamWriter);\n\n      List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n      listEndpoints(deprecatedEndpoints, \"What's Deprecated\", outputStreamWriter);\n\n      List<ChangedOperation> changedOperations = diff.getChangedOperations();\n      ol_changed(changedOperations, outputStreamWriter);\n\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(\n          outputStreamWriter,\n          diff.isCompatible()\n              ? \"NOTE: API changes are backward compatible\"\n              : \"WARNING: API changes broke backward compatibility\");\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n    }\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }\n\n  private void ol_changed(\n      List<ChangedOperation> operations, OutputStreamWriter outputStreamWriter) {\n    if (null == operations || operations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, title(\"What's Changed\", 2));\n    safelyAppend(outputStreamWriter, System.lineSeparator());\n    for (ChangedOperation operation : operations) {\n      String pathUrl = operation.getPathUrl();\n      String method = operation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(operation.getSummary()).map(ChangedMetadata::getRight).orElse(\"\");\n\n      safelyAppend(outputStreamWriter, itemEndpoint(method, pathUrl, desc));\n      if (result(operation.getParameters()).isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Parameter:\\n\");\n        safelyAppend(outputStreamWriter, ul_param(operation.getParameters()));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n      if (operation.resultRequestBody().isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Request:\\n\");\n        safelyAppend(\n            outputStreamWriter, ul_content(operation.getRequestBody().getContent(), true, 2));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n      if (operation.resultApiResponses().isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Return Type:\\n\");\n        safelyAppend(outputStreamWriter, ul_response(operation.getApiResponses()));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n    }\n  }\n\n  private String ul_response(ChangedApiResponse changedApiResponse) {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (String propName : addResponses.keySet()) {\n      sb.append(itemResponse(\"** Add \", propName));\n    }\n    for (String propName : delResponses.keySet()) {\n      sb.append(itemResponse(\"** Deleted \", propName));\n    }\n    for (Entry<String, ChangedResponse> entry : changedResponses.entrySet()) {\n      sb.append(itemChangedResponse(\"** Changed \", entry.getKey(), entry.getValue()));\n    }\n    return sb.toString();\n  }\n\n  private String itemResponse(String title, String code) {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(title).append(code).append(' ').append(status).append(\"\\n\");\n    return sb.toString();\n  }\n\n  private String itemChangedResponse(String title, String contentType, ChangedResponse response) {\n    return itemResponse(title, contentType)\n        + \"** Media types:\\n\"\n        + ul_content(response.getContent(), false, 3);\n  }\n\n  private String ul_content(ChangedContent changedContent, boolean isRequest, int indent) {\n    StringBuilder sb = new StringBuilder();\n    if (changedContent == null) {\n      return sb.toString();\n    }\n    for (String propName : changedContent.getIncreased().keySet()) {\n      sb.append(itemContent(\"Added \", propName, indent));\n    }\n    for (String propName : changedContent.getMissing().keySet()) {\n      sb.append(itemContent(\"Deleted \", propName, indent));\n    }\n    for (String propName : changedContent.getChanged().keySet()) {\n      sb.append(\n          itemContent(\n              \"Changed \", propName, indent, changedContent.getChanged().get(propName), isRequest));\n    }\n    return sb.toString();\n  }\n\n  private String itemContent(String title, String contentType, int indent) {\n    return StringUtils.repeat('*', indent) + \" \" + title + contentType + \"\\n\";\n  }\n\n  private String itemContent(\n      String title,\n      String contentType,\n      int indent,\n      ChangedMediaType changedMediaType,\n      boolean isRequest) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(itemContent(title, contentType, indent))\n        .append(itemContent(\"Schema:\", \"\", indent))\n        .append(changedMediaType.isCompatible() ? \"Backward compatible\" : \"Broken compatibility\")\n        .append(\"\\n\");\n    if (!changedMediaType.isCompatible()) {\n      sb.append(incompatibilities(changedMediaType.getSchema()));\n    }\n    return sb.toString();\n  }\n\n  private String incompatibilities(final ChangedSchema schema) {\n    return incompatibilities(\"\", schema);\n  }\n\n  private String incompatibilities(String propName, final ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getItems() != null) {\n      sb.append(items(propName, schema.getItems()));\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      sb.append(property(propName, \"Changed property type\", type));\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    sb.append(\n        properties(prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(incompatibilities(prefix + name, property)));\n    return sb.toString();\n  }\n\n  private String items(String propName, ChangedSchema schema) {\n    return incompatibilities(propName + \"[n]\", schema);\n  }\n\n  private String properties(\n      String propPrefix, String title, Map<String, Schema<?>> properties, DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach((key, value) -> sb.append(resolveProperty(propPrefix, value, key, title)));\n    }\n    return sb.toString();\n  }\n\n  private String resolveProperty(String propPrefix, Schema<?> value, String key, String title) {\n    try {\n      return property(propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      return property(propPrefix + key, title, type(value));\n    }\n  }\n\n  protected String property(String name, String title, Schema<?> schema) {\n    return property(name, title, type(schema));\n  }\n\n  protected String property(String name, String title, String type) {\n    return String.format(\"*** %s: %s (%s)%n\\n\", title, name, type);\n  }\n\n  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }\n\n  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }\n\n  private String ul_param(ChangedParameters changedParameters) {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (Parameter param : addParameters) {\n      sb.append(itemParam(\"** Add \", param));\n    }\n    for (ChangedParameter param : changed) {\n      sb.append(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      sb.append(itemParam(\"** Delete \", param));\n    }\n    return sb.toString();\n  }\n\n  private String itemParam(String title, Parameter param) {\n    return title + param.getName() + \" in \" + param.getIn() + System.lineSeparator();\n  }\n\n  private String li_changedParam(ChangedParameter changeParam) {\n    if (changeParam.isDeprecated()) {\n      return itemParam(\"** Deprecated \", changeParam.getNewParameter());\n    } else {\n      return itemParam(\"** Changed \", changeParam.getNewParameter());\n    }\n  }\n\n  private String listEndpoints(\n      List<Endpoint> endpoints, String title, OutputStreamWriter outputStreamWriter) {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(title(title));\n    for (Endpoint endpoint : endpoints) {\n      sb.append(\n          itemEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return sb.append(System.lineSeparator()).toString();\n  }\n\n  private String itemEndpoint(String method, String path, String desc) {\n    return String.format(\"=== %s%s%n\", StringUtils.rightPad(method, 6), path);\n  }\n\n  public String bigTitle(String title, String version) {\n    char ch = '=';\n\n    return String.format(\"= %s (v %s)\", title.toUpperCase(), version);\n  }\n\n  public String title(String title) {\n    return this.title(title, '-');\n  }\n\n  public String title(String title, int level) {\n    String little = StringUtils.repeat(\"=\", level);\n    return String.format(\"%s %s\", little, title);\n  }\n}", "definition": "public class AsciidocRender implements Render", "class_docstring": "", "name": "AsciidocRender", "super_interfaces": ["Render"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final int LINE_LENGTH = 74;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "LINE_LENGTH = 74", "syntax_pass": true}, {"attribute_expression": "protected static RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);", "docstring": "", "modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "type": "RefPointer<Schema<?>>", "name": "refPointer = new RefPointer<>(RefType.SCHEMAS)", "syntax_pass": true}, {"attribute_expression": "protected ChangedOpenApi diff;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedOpenApi", "name": "diff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter) {\n    this.diff = diff;\n    if (diff.isUnchanged()) {\n      safelyAppend(\n          outputStreamWriter,\n          bigTitle(\n              diff.getNewSpecOpenApi().getInfo().getTitle(),\n              diff.getNewSpecOpenApi().getInfo().getVersion()));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, \"NOTE: No differences. Specifications are equivalents\");\n    } else {\n      safelyAppend(\n          outputStreamWriter,\n          bigTitle(\n              diff.getNewSpecOpenApi().getInfo().getTitle(),\n              diff.getNewSpecOpenApi().getInfo().getVersion()));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, \":reproducible:\\n:sectlinks:\\n:toc:\\n\");\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n\n      List<Endpoint> newEndpoints = diff.getNewEndpoints();\n      listEndpoints(newEndpoints, \"What's New\", outputStreamWriter);\n\n      List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n      listEndpoints(missingEndpoints, \"What's Deleted\", outputStreamWriter);\n\n      List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n      listEndpoints(deprecatedEndpoints, \"What's Deprecated\", outputStreamWriter);\n\n      List<ChangedOperation> changedOperations = diff.getChangedOperations();\n      ol_changed(changedOperations, outputStreamWriter);\n\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(\n          outputStreamWriter,\n          diff.isCompatible()\n              ? \"NOTE: API changes are backward compatible\"\n              : \"WARNING: API changes broke backward compatibility\");\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n    }\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "render", "params": [{"name": "diff", "type": "ChangedOpenApi"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                 {\n    this.diff = diff;\n    if (diff.isUnchanged()) {\n      safelyAppend(\n          outputStreamWriter,\n          bigTitle(\n              diff.getNewSpecOpenApi().getInfo().getTitle(),\n              diff.getNewSpecOpenApi().getInfo().getVersion()));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, \"NOTE: No differences. Specifications are equivalents\");\n    } else {\n      safelyAppend(\n          outputStreamWriter,\n          bigTitle(\n              diff.getNewSpecOpenApi().getInfo().getTitle(),\n              diff.getNewSpecOpenApi().getInfo().getVersion()));\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(outputStreamWriter, \":reproducible:\\n:sectlinks:\\n:toc:\\n\");\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n\n      List<Endpoint> newEndpoints = diff.getNewEndpoints();\n      listEndpoints(newEndpoints, \"What's New\", outputStreamWriter);\n\n      List<Endpoint> missingEndpoints = diff.getMissingEndpoints();\n      listEndpoints(missingEndpoints, \"What's Deleted\", outputStreamWriter);\n\n      List<Endpoint> deprecatedEndpoints = diff.getDeprecatedEndpoints();\n      listEndpoints(deprecatedEndpoints, \"What's Deprecated\", outputStreamWriter);\n\n      List<ChangedOperation> changedOperations = diff.getChangedOperations();\n      ol_changed(changedOperations, outputStreamWriter);\n\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n      safelyAppend(\n          outputStreamWriter,\n          diff.isCompatible()\n              ? \"NOTE: API changes are backward compatible\"\n              : \"WARNING: API changes broke backward compatibility\");\n      safelyAppend(outputStreamWriter, System.lineSeparator());\n    }\n    try {\n      outputStreamWriter.close();\n    } catch (IOException e) {\n      throw new RendererException(e);\n    }\n  }", "signature": "@Override\n  public void render(ChangedOpenApi diff, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  private void ol_changed(\n      List<ChangedOperation> operations, OutputStreamWriter outputStreamWriter) {\n    if (null == operations || operations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, title(\"What's Changed\", 2));\n    safelyAppend(outputStreamWriter, System.lineSeparator());\n    for (ChangedOperation operation : operations) {\n      String pathUrl = operation.getPathUrl();\n      String method = operation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(operation.getSummary()).map(ChangedMetadata::getRight).orElse(\"\");\n\n      safelyAppend(outputStreamWriter, itemEndpoint(method, pathUrl, desc));\n      if (result(operation.getParameters()).isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Parameter:\\n\");\n        safelyAppend(outputStreamWriter, ul_param(operation.getParameters()));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n      if (operation.resultRequestBody().isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Request:\\n\");\n        safelyAppend(\n            outputStreamWriter, ul_content(operation.getRequestBody().getContent(), true, 2));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n      if (operation.resultApiResponses().isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Return Type:\\n\");\n        safelyAppend(outputStreamWriter, ul_response(operation.getApiResponses()));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "ol_changed", "params": [{"name": "operations", "type": "List<ChangedOperation>"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                {\n    if (null == operations || operations.isEmpty()) {\n      return;\n    }\n    safelyAppend(outputStreamWriter, title(\"What's Changed\", 2));\n    safelyAppend(outputStreamWriter, System.lineSeparator());\n    for (ChangedOperation operation : operations) {\n      String pathUrl = operation.getPathUrl();\n      String method = operation.getHttpMethod().toString();\n      String desc =\n          Optional.ofNullable(operation.getSummary()).map(ChangedMetadata::getRight).orElse(\"\");\n\n      safelyAppend(outputStreamWriter, itemEndpoint(method, pathUrl, desc));\n      if (result(operation.getParameters()).isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Parameter:\\n\");\n        safelyAppend(outputStreamWriter, ul_param(operation.getParameters()));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n      if (operation.resultRequestBody().isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Request:\\n\");\n        safelyAppend(\n            outputStreamWriter, ul_content(operation.getRequestBody().getContent(), true, 2));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n      if (operation.resultApiResponses().isDifferent()) {\n        safelyAppend(outputStreamWriter, \"* Return Type:\\n\");\n        safelyAppend(outputStreamWriter, ul_response(operation.getApiResponses()));\n        safelyAppend(outputStreamWriter, System.lineSeparator());\n      }\n    }\n  }", "signature": "private void ol_changed(\n      List<ChangedOperation> operations, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  private String ul_response(ChangedApiResponse changedApiResponse) {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (String propName : addResponses.keySet()) {\n      sb.append(itemResponse(\"** Add \", propName));\n    }\n    for (String propName : delResponses.keySet()) {\n      sb.append(itemResponse(\"** Deleted \", propName));\n    }\n    for (Entry<String, ChangedResponse> entry : changedResponses.entrySet()) {\n      sb.append(itemChangedResponse(\"** Changed \", entry.getKey(), entry.getValue()));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "ul_response", "params": [{"name": "changedApiResponse", "type": "ChangedApiResponse"}], "body": "                                                                    {\n    Map<String, ApiResponse> addResponses = changedApiResponse.getIncreased();\n    Map<String, ApiResponse> delResponses = changedApiResponse.getMissing();\n    Map<String, ChangedResponse> changedResponses = changedApiResponse.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (String propName : addResponses.keySet()) {\n      sb.append(itemResponse(\"** Add \", propName));\n    }\n    for (String propName : delResponses.keySet()) {\n      sb.append(itemResponse(\"** Deleted \", propName));\n    }\n    for (Entry<String, ChangedResponse> entry : changedResponses.entrySet()) {\n      sb.append(itemChangedResponse(\"** Changed \", entry.getKey(), entry.getValue()));\n    }\n    return sb.toString();\n  }", "signature": "private String ul_response(ChangedApiResponse changedApiResponse)"}, {"syntax_pass": true, "original_string": "  private String itemResponse(String title, String code) {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(title).append(code).append(' ').append(status).append(\"\\n\");\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemResponse", "params": [{"name": "title", "type": "String"}, {"name": "code", "type": "String"}], "body": "                                                         {\n    StringBuilder sb = new StringBuilder();\n    String status = \"\";\n    if (!code.equals(\"default\") && !code.matches(\"[1-5]XX\")) {\n      status = HttpStatus.getReasonPhrase(Integer.parseInt(code));\n    }\n    sb.append(title).append(code).append(' ').append(status).append(\"\\n\");\n    return sb.toString();\n  }", "signature": "private String itemResponse(String title, String code)"}, {"syntax_pass": true, "original_string": "  private String itemChangedResponse(String title, String contentType, ChangedResponse response) {\n    return itemResponse(title, contentType)\n        + \"** Media types:\\n\"\n        + ul_content(response.getContent(), false, 3);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemChangedResponse", "params": [{"name": "title", "type": "String"}, {"name": "contentType", "type": "String"}, {"name": "response", "type": "ChangedResponse"}], "body": "                                                                                                 {\n    return itemResponse(title, contentType)\n        + \"** Media types:\\n\"\n        + ul_content(response.getContent(), false, 3);\n  }", "signature": "private String itemChangedResponse(String title, String contentType, ChangedResponse response)"}, {"syntax_pass": true, "original_string": "  private String ul_content(ChangedContent changedContent, boolean isRequest, int indent) {\n    StringBuilder sb = new StringBuilder();\n    if (changedContent == null) {\n      return sb.toString();\n    }\n    for (String propName : changedContent.getIncreased().keySet()) {\n      sb.append(itemContent(\"Added \", propName, indent));\n    }\n    for (String propName : changedContent.getMissing().keySet()) {\n      sb.append(itemContent(\"Deleted \", propName, indent));\n    }\n    for (String propName : changedContent.getChanged().keySet()) {\n      sb.append(\n          itemContent(\n              \"Changed \", propName, indent, changedContent.getChanged().get(propName), isRequest));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "ul_content", "params": [{"name": "changedContent", "type": "ChangedContent"}, {"name": "isRequest", "type": "boolean"}, {"name": "indent", "type": "int"}], "body": "                                                                                          {\n    StringBuilder sb = new StringBuilder();\n    if (changedContent == null) {\n      return sb.toString();\n    }\n    for (String propName : changedContent.getIncreased().keySet()) {\n      sb.append(itemContent(\"Added \", propName, indent));\n    }\n    for (String propName : changedContent.getMissing().keySet()) {\n      sb.append(itemContent(\"Deleted \", propName, indent));\n    }\n    for (String propName : changedContent.getChanged().keySet()) {\n      sb.append(\n          itemContent(\n              \"Changed \", propName, indent, changedContent.getChanged().get(propName), isRequest));\n    }\n    return sb.toString();\n  }", "signature": "private String ul_content(ChangedContent changedContent, boolean isRequest, int indent)"}, {"syntax_pass": true, "original_string": "  private String itemContent(String title, String contentType, int indent) {\n    return StringUtils.repeat('*', indent) + \" \" + title + contentType + \"\\n\";\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemContent", "params": [{"name": "title", "type": "String"}, {"name": "contentType", "type": "String"}, {"name": "indent", "type": "int"}], "body": "                                                                           {\n    return StringUtils.repeat('*', indent) + \" \" + title + contentType + \"\\n\";\n  }", "signature": "private String itemContent(String title, String contentType, int indent)"}, {"syntax_pass": true, "original_string": "  private String itemContent(\n      String title,\n      String contentType,\n      int indent,\n      ChangedMediaType changedMediaType,\n      boolean isRequest) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(itemContent(title, contentType, indent))\n        .append(itemContent(\"Schema:\", \"\", indent))\n        .append(changedMediaType.isCompatible() ? \"Backward compatible\" : \"Broken compatibility\")\n        .append(\"\\n\");\n    if (!changedMediaType.isCompatible()) {\n      sb.append(incompatibilities(changedMediaType.getSchema()));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemContent", "params": [{"name": "title", "type": "String"}, {"name": "contentType", "type": "String"}, {"name": "indent", "type": "int"}, {"name": "changedMediaType", "type": "ChangedMediaType"}, {"name": "isRequest", "type": "boolean"}], "body": "                         {\n    StringBuilder sb = new StringBuilder();\n    sb.append(itemContent(title, contentType, indent))\n        .append(itemContent(\"Schema:\", \"\", indent))\n        .append(changedMediaType.isCompatible() ? \"Backward compatible\" : \"Broken compatibility\")\n        .append(\"\\n\");\n    if (!changedMediaType.isCompatible()) {\n      sb.append(incompatibilities(changedMediaType.getSchema()));\n    }\n    return sb.toString();\n  }", "signature": "private String itemContent(\n      String title,\n      String contentType,\n      int indent,\n      ChangedMediaType changedMediaType,\n      boolean isRequest)"}, {"syntax_pass": true, "original_string": "  private String incompatibilities(final ChangedSchema schema) {\n    return incompatibilities(\"\", schema);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "incompatibilities", "params": [{"name": "schema", "type": "ChangedSchema"}], "body": "                                                               {\n    return incompatibilities(\"\", schema);\n  }", "signature": "private String incompatibilities(final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private String incompatibilities(String propName, final ChangedSchema schema) {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getItems() != null) {\n      sb.append(items(propName, schema.getItems()));\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      sb.append(property(propName, \"Changed property type\", type));\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    sb.append(\n        properties(prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(incompatibilities(prefix + name, property)));\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "incompatibilities", "params": [{"name": "propName", "type": "String"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                                                {\n    StringBuilder sb = new StringBuilder();\n    if (schema.getItems() != null) {\n      sb.append(items(propName, schema.getItems()));\n    }\n    if (schema.isCoreChanged() == DiffResult.INCOMPATIBLE && schema.isChangedType()) {\n      String type = type(schema.getOldSchema()) + \" -> \" + type(schema.getNewSchema());\n      sb.append(property(propName, \"Changed property type\", type));\n    }\n    String prefix = propName.isEmpty() ? \"\" : propName + \".\";\n    sb.append(\n        properties(prefix, \"Missing property\", schema.getMissingProperties(), schema.getContext()));\n    schema\n        .getChangedProperties()\n        .forEach((name, property) -> sb.append(incompatibilities(prefix + name, property)));\n    return sb.toString();\n  }", "signature": "private String incompatibilities(String propName, final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private String items(String propName, ChangedSchema schema) {\n    return incompatibilities(propName + \"[n]\", schema);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "items", "params": [{"name": "propName", "type": "String"}, {"name": "schema", "type": "ChangedSchema"}], "body": "                                                              {\n    return incompatibilities(propName + \"[n]\", schema);\n  }", "signature": "private String items(String propName, ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  private String properties(\n      String propPrefix, String title, Map<String, Schema<?>> properties, DiffContext context) {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach((key, value) -> sb.append(resolveProperty(propPrefix, value, key, title)));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "properties", "params": [{"name": "propPrefix", "type": "String"}, {"name": "title", "type": "String"}, {"name": "properties", "type": "Map<String, Schema<?>>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                               {\n    StringBuilder sb = new StringBuilder();\n    if (properties != null) {\n      properties.forEach((key, value) -> sb.append(resolveProperty(propPrefix, value, key, title)));\n    }\n    return sb.toString();\n  }", "signature": "private String properties(\n      String propPrefix, String title, Map<String, Schema<?>> properties, DiffContext context)"}, {"syntax_pass": true, "original_string": "  private String resolveProperty(String propPrefix, Schema<?> value, String key, String title) {\n    try {\n      return property(propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      return property(propPrefix + key, title, type(value));\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "resolveProperty", "params": [{"name": "propPrefix", "type": "String"}, {"name": "value", "type": "Schema<?>"}, {"name": "key", "type": "String"}, {"name": "title", "type": "String"}], "body": "                                                                                               {\n    try {\n      return property(propPrefix + key, title, resolve(value));\n    } catch (Exception e) {\n      return property(propPrefix + key, title, type(value));\n    }\n  }", "signature": "private String resolveProperty(String propPrefix, Schema<?> value, String key, String title)"}, {"syntax_pass": true, "original_string": "  protected String property(String name, String title, Schema<?> schema) {\n    return property(name, title, type(schema));\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "property", "params": [{"name": "name", "type": "String"}, {"name": "title", "type": "String"}, {"name": "schema", "type": "Schema<?>"}], "body": "                                                                         {\n    return property(name, title, type(schema));\n  }", "signature": "protected String property(String name, String title, Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  protected String property(String name, String title, String type) {\n    return String.format(\"*** %s: %s (%s)%n\\n\", title, name, type);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "property", "params": [{"name": "name", "type": "String"}, {"name": "title", "type": "String"}, {"name": "type", "type": "String"}], "body": "                                                                    {\n    return String.format(\"*** %s: %s (%s)%n\\n\", title, name, type);\n  }", "signature": "protected String property(String name, String title, String type)"}, {"syntax_pass": true, "original_string": "  protected Schema<?> resolve(Schema<?> schema) {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Schema<?>", "classes": []}, "name": "resolve", "params": [{"name": "schema", "type": "Schema<?>"}], "body": "                                                {\n    return refPointer.resolveRef(\n        diff.getNewSpecOpenApi().getComponents(), schema, schema.get$ref());\n  }", "signature": "protected Schema<?> resolve(Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  protected String type(Schema<?> schema) {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "type", "params": [{"name": "schema", "type": "Schema<?>"}], "body": "                                          {\n    String result = \"object\";\n    if (schema == null) {\n      result = \"no schema\";\n    } else if (schema instanceof ArraySchema) {\n      result = \"array\";\n    } else if (schema.getType() != null) {\n      result = schema.getType();\n    }\n    return result;\n  }", "signature": "protected String type(Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  private String ul_param(ChangedParameters changedParameters) {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (Parameter param : addParameters) {\n      sb.append(itemParam(\"** Add \", param));\n    }\n    for (ChangedParameter param : changed) {\n      sb.append(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      sb.append(itemParam(\"** Delete \", param));\n    }\n    return sb.toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "ul_param", "params": [{"name": "changedParameters", "type": "ChangedParameters"}], "body": "                                                               {\n    List<Parameter> addParameters = changedParameters.getIncreased();\n    List<Parameter> delParameters = changedParameters.getMissing();\n    List<ChangedParameter> changed = changedParameters.getChanged();\n    StringBuilder sb = new StringBuilder();\n    for (Parameter param : addParameters) {\n      sb.append(itemParam(\"** Add \", param));\n    }\n    for (ChangedParameter param : changed) {\n      sb.append(li_changedParam(param));\n    }\n    for (Parameter param : delParameters) {\n      sb.append(itemParam(\"** Delete \", param));\n    }\n    return sb.toString();\n  }", "signature": "private String ul_param(ChangedParameters changedParameters)"}, {"syntax_pass": true, "original_string": "  private String itemParam(String title, Parameter param) {\n    return title + param.getName() + \" in \" + param.getIn() + System.lineSeparator();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemParam", "params": [{"name": "title", "type": "String"}, {"name": "param", "type": "Parameter"}], "body": "                                                          {\n    return title + param.getName() + \" in \" + param.getIn() + System.lineSeparator();\n  }", "signature": "private String itemParam(String title, Parameter param)"}, {"syntax_pass": true, "original_string": "  private String li_changedParam(ChangedParameter changeParam) {\n    if (changeParam.isDeprecated()) {\n      return itemParam(\"** Deprecated \", changeParam.getNewParameter());\n    } else {\n      return itemParam(\"** Changed \", changeParam.getNewParameter());\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "li_changedParam", "params": [{"name": "changeParam", "type": "ChangedParameter"}], "body": "                                                               {\n    if (changeParam.isDeprecated()) {\n      return itemParam(\"** Deprecated \", changeParam.getNewParameter());\n    } else {\n      return itemParam(\"** Changed \", changeParam.getNewParameter());\n    }\n  }", "signature": "private String li_changedParam(ChangedParameter changeParam)"}, {"syntax_pass": true, "original_string": "  private String listEndpoints(\n      List<Endpoint> endpoints, String title, OutputStreamWriter outputStreamWriter) {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(title(title));\n    for (Endpoint endpoint : endpoints) {\n      sb.append(\n          itemEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return sb.append(System.lineSeparator()).toString();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "listEndpoints", "params": [{"name": "endpoints", "type": "List<Endpoint>"}, {"name": "title", "type": "String"}, {"name": "outputStreamWriter", "type": "OutputStreamWriter"}], "body": "                                                                                     {\n    if (null == endpoints || endpoints.isEmpty()) {\n      return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(title(title));\n    for (Endpoint endpoint : endpoints) {\n      sb.append(\n          itemEndpoint(\n              endpoint.getMethod().toString(), endpoint.getPathUrl(), endpoint.getSummary()));\n    }\n    return sb.append(System.lineSeparator()).toString();\n  }", "signature": "private String listEndpoints(\n      List<Endpoint> endpoints, String title, OutputStreamWriter outputStreamWriter)"}, {"syntax_pass": true, "original_string": "  private String itemEndpoint(String method, String path, String desc) {\n    return String.format(\"=== %s%s%n\", StringUtils.rightPad(method, 6), path);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "itemEndpoint", "params": [{"name": "method", "type": "String"}, {"name": "path", "type": "String"}, {"name": "desc", "type": "String"}], "body": "                                                                       {\n    return String.format(\"=== %s%s%n\", StringUtils.rightPad(method, 6), path);\n  }", "signature": "private String itemEndpoint(String method, String path, String desc)"}, {"syntax_pass": true, "original_string": "  public String bigTitle(String title, String version) {\n    char ch = '=';\n\n    return String.format(\"= %s (v %s)\", title.toUpperCase(), version);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "bigTitle", "params": [{"name": "title", "type": "String"}, {"name": "version", "type": "String"}], "body": "                                                       {\n    char ch = '=';\n\n    return String.format(\"= %s (v %s)\", title.toUpperCase(), version);\n  }", "signature": "public String bigTitle(String title, String version)"}, {"syntax_pass": true, "original_string": "  public String title(String title) {\n    return this.title(title, '-');\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "title", "params": [{"name": "title", "type": "String"}], "body": "                                    {\n    return this.title(title, '-');\n  }", "signature": "public String title(String title)"}, {"syntax_pass": true, "original_string": "  public String title(String title, int level) {\n    String little = StringUtils.repeat(\"=\", level);\n    return String.format(\"%s %s\", little, title);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "title", "params": [{"name": "title", "type": "String"}, {"name": "level", "type": "int"}], "body": "                                               {\n    String little = StringUtils.repeat(\"=\", level);\n    return String.format(\"%s %s\", little, title);\n  }", "signature": "public String title(String title, int level)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/utils/Copy.java", "original_string": "package org.openapitools.openapidiff.core.utils;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Copy {\n\n  private Copy() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }\n\n  public static <K, V> Map<K, V> copyMap(Map<K, V> map) {\n    if (map == null) {\n      return new LinkedHashMap<>();\n    } else {\n      return new LinkedHashMap<>(map);\n    }\n  }\n}\n", "file_hash": "08142fc430d3a4ee44ec8a4cdb597eb910d11088732a70f142b7b542aae6335e", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.utils;", "import java.util.LinkedHashMap;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public class Copy {\n\n  private Copy() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }\n\n  public static <K, V> Map<K, V> copyMap(Map<K, V> map) {\n    if (map == null) {\n      return new LinkedHashMap<>();\n    } else {\n      return new LinkedHashMap<>(map);\n    }\n  }\n}", "definition": "public class Copy", "class_docstring": "", "name": "Copy", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private Copy() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Copy", "params": [], "body": "                 {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }", "signature": "private Copy()"}, {"syntax_pass": true, "original_string": "  public static <K, V> Map<K, V> copyMap(Map<K, V> map) {\n    if (map == null) {\n      return new LinkedHashMap<>();\n    } else {\n      return new LinkedHashMap<>(map);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "copyMap", "params": [{"name": "map", "type": "Map<K, V>"}], "body": "                                                        {\n    if (map == null) {\n      return new LinkedHashMap<>();\n    } else {\n      return new LinkedHashMap<>(map);\n    }\n  }", "signature": "public static <K, V> Map<K, V> copyMap(Map<K, V> map)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/utils/EndpointUtils.java", "original_string": "package org.openapitools.openapidiff.core.utils;\n\nimport io.swagger.v3.oas.models.Operation;\nimport io.swagger.v3.oas.models.PathItem;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport org.openapitools.openapidiff.core.model.Endpoint;\n\npublic class EndpointUtils {\n\n  private EndpointUtils() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }\n\n  public static Collection<Endpoint> convert2Endpoints(\n      String pathUrl, Map<PathItem.HttpMethod, Operation> map) {\n    List<Endpoint> endpoints = new ArrayList<>();\n    if (null == map) {\n      return endpoints;\n    }\n    for (Map.Entry<PathItem.HttpMethod, Operation> entry : map.entrySet()) {\n      PathItem.HttpMethod httpMethod = entry.getKey();\n      Operation operation = entry.getValue();\n      Endpoint endpoint = convert2Endpoint(pathUrl, httpMethod, operation);\n      endpoints.add(endpoint);\n    }\n    return endpoints;\n  }\n\n  public static Endpoint convert2Endpoint(\n      String pathUrl, PathItem.HttpMethod httpMethod, Operation operation) {\n    Endpoint endpoint = new Endpoint();\n    endpoint.setPathUrl(pathUrl);\n    endpoint.setMethod(httpMethod);\n    endpoint.setSummary(operation.getSummary());\n    endpoint.setOperation(operation);\n    return endpoint;\n  }\n\n  public static List<Endpoint> convert2EndpointList(Map<String, PathItem> map) {\n    List<Endpoint> endpoints = new ArrayList<>();\n    if (null == map) {\n      return endpoints;\n    }\n    for (Map.Entry<String, PathItem> entry : map.entrySet()) {\n      String url = entry.getKey();\n      PathItem path = entry.getValue();\n\n      Map<PathItem.HttpMethod, Operation> operationMap = path.readOperationsMap();\n      for (Map.Entry<PathItem.HttpMethod, Operation> entryOper : operationMap.entrySet()) {\n        PathItem.HttpMethod httpMethod = entryOper.getKey();\n        Operation operation = entryOper.getValue();\n\n        Endpoint endpoint = new Endpoint();\n        endpoint.setPathUrl(url);\n        endpoint.setMethod(httpMethod);\n        endpoint.setSummary(operation.getSummary());\n        endpoint.setPath(path);\n        endpoint.setOperation(operation);\n        endpoints.add(endpoint);\n      }\n    }\n    return endpoints;\n  }\n}\n", "file_hash": "1cd9303ec52be507b97c09f83e1a876373952c8d896b035bf19676dd575b856a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.utils;", "import io.swagger.v3.oas.models.Operation;", "import io.swagger.v3.oas.models.PathItem;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.List;", "import java.util.Map;", "import org.openapitools.openapidiff.core.model.Endpoint;"], "methods": [], "classes": [{"original_string": "public class EndpointUtils {\n\n  private EndpointUtils() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }\n\n  public static Collection<Endpoint> convert2Endpoints(\n      String pathUrl, Map<PathItem.HttpMethod, Operation> map) {\n    List<Endpoint> endpoints = new ArrayList<>();\n    if (null == map) {\n      return endpoints;\n    }\n    for (Map.Entry<PathItem.HttpMethod, Operation> entry : map.entrySet()) {\n      PathItem.HttpMethod httpMethod = entry.getKey();\n      Operation operation = entry.getValue();\n      Endpoint endpoint = convert2Endpoint(pathUrl, httpMethod, operation);\n      endpoints.add(endpoint);\n    }\n    return endpoints;\n  }\n\n  public static Endpoint convert2Endpoint(\n      String pathUrl, PathItem.HttpMethod httpMethod, Operation operation) {\n    Endpoint endpoint = new Endpoint();\n    endpoint.setPathUrl(pathUrl);\n    endpoint.setMethod(httpMethod);\n    endpoint.setSummary(operation.getSummary());\n    endpoint.setOperation(operation);\n    return endpoint;\n  }\n\n  public static List<Endpoint> convert2EndpointList(Map<String, PathItem> map) {\n    List<Endpoint> endpoints = new ArrayList<>();\n    if (null == map) {\n      return endpoints;\n    }\n    for (Map.Entry<String, PathItem> entry : map.entrySet()) {\n      String url = entry.getKey();\n      PathItem path = entry.getValue();\n\n      Map<PathItem.HttpMethod, Operation> operationMap = path.readOperationsMap();\n      for (Map.Entry<PathItem.HttpMethod, Operation> entryOper : operationMap.entrySet()) {\n        PathItem.HttpMethod httpMethod = entryOper.getKey();\n        Operation operation = entryOper.getValue();\n\n        Endpoint endpoint = new Endpoint();\n        endpoint.setPathUrl(url);\n        endpoint.setMethod(httpMethod);\n        endpoint.setSummary(operation.getSummary());\n        endpoint.setPath(path);\n        endpoint.setOperation(operation);\n        endpoints.add(endpoint);\n      }\n    }\n    return endpoints;\n  }\n}", "definition": "public class EndpointUtils", "class_docstring": "", "name": "EndpointUtils", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private EndpointUtils() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "EndpointUtils", "params": [], "body": "                          {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }", "signature": "private EndpointUtils()"}, {"syntax_pass": true, "original_string": "  public static Collection<Endpoint> convert2Endpoints(\n      String pathUrl, Map<PathItem.HttpMethod, Operation> map) {\n    List<Endpoint> endpoints = new ArrayList<>();\n    if (null == map) {\n      return endpoints;\n    }\n    for (Map.Entry<PathItem.HttpMethod, Operation> entry : map.entrySet()) {\n      PathItem.HttpMethod httpMethod = entry.getKey();\n      Operation operation = entry.getValue();\n      Endpoint endpoint = convert2Endpoint(pathUrl, httpMethod, operation);\n      endpoints.add(endpoint);\n    }\n    return endpoints;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Collection<Endpoint>", "classes": []}, "name": "convert2Endpoints", "params": [{"name": "pathUrl", "type": "String"}, {"name": "map", "type": "Map<PathItem.HttpMethod, Operation>"}], "body": "                                                               {\n    List<Endpoint> endpoints = new ArrayList<>();\n    if (null == map) {\n      return endpoints;\n    }\n    for (Map.Entry<PathItem.HttpMethod, Operation> entry : map.entrySet()) {\n      PathItem.HttpMethod httpMethod = entry.getKey();\n      Operation operation = entry.getValue();\n      Endpoint endpoint = convert2Endpoint(pathUrl, httpMethod, operation);\n      endpoints.add(endpoint);\n    }\n    return endpoints;\n  }", "signature": "public static Collection<Endpoint> convert2Endpoints(\n      String pathUrl, Map<PathItem.HttpMethod, Operation> map)"}, {"syntax_pass": true, "original_string": "  public static Endpoint convert2Endpoint(\n      String pathUrl, PathItem.HttpMethod httpMethod, Operation operation) {\n    Endpoint endpoint = new Endpoint();\n    endpoint.setPathUrl(pathUrl);\n    endpoint.setMethod(httpMethod);\n    endpoint.setSummary(operation.getSummary());\n    endpoint.setOperation(operation);\n    return endpoint;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Endpoint", "classes": []}, "name": "convert2Endpoint", "params": [{"name": "pathUrl", "type": "String"}, {"name": "httpMethod", "type": "PathItem.HttpMethod"}, {"name": "operation", "type": "Operation"}], "body": "                                                                           {\n    Endpoint endpoint = new Endpoint();\n    endpoint.setPathUrl(pathUrl);\n    endpoint.setMethod(httpMethod);\n    endpoint.setSummary(operation.getSummary());\n    endpoint.setOperation(operation);\n    return endpoint;\n  }", "signature": "public static Endpoint convert2Endpoint(\n      String pathUrl, PathItem.HttpMethod httpMethod, Operation operation)"}, {"syntax_pass": true, "original_string": "  public static List<Endpoint> convert2EndpointList(Map<String, PathItem> map) {\n    List<Endpoint> endpoints = new ArrayList<>();\n    if (null == map) {\n      return endpoints;\n    }\n    for (Map.Entry<String, PathItem> entry : map.entrySet()) {\n      String url = entry.getKey();\n      PathItem path = entry.getValue();\n\n      Map<PathItem.HttpMethod, Operation> operationMap = path.readOperationsMap();\n      for (Map.Entry<PathItem.HttpMethod, Operation> entryOper : operationMap.entrySet()) {\n        PathItem.HttpMethod httpMethod = entryOper.getKey();\n        Operation operation = entryOper.getValue();\n\n        Endpoint endpoint = new Endpoint();\n        endpoint.setPathUrl(url);\n        endpoint.setMethod(httpMethod);\n        endpoint.setSummary(operation.getSummary());\n        endpoint.setPath(path);\n        endpoint.setOperation(operation);\n        endpoints.add(endpoint);\n      }\n    }\n    return endpoints;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Endpoint>", "classes": []}, "name": "convert2EndpointList", "params": [{"name": "map", "type": "Map<String, PathItem>"}], "body": "                                                                               {\n    List<Endpoint> endpoints = new ArrayList<>();\n    if (null == map) {\n      return endpoints;\n    }\n    for (Map.Entry<String, PathItem> entry : map.entrySet()) {\n      String url = entry.getKey();\n      PathItem path = entry.getValue();\n\n      Map<PathItem.HttpMethod, Operation> operationMap = path.readOperationsMap();\n      for (Map.Entry<PathItem.HttpMethod, Operation> entryOper : operationMap.entrySet()) {\n        PathItem.HttpMethod httpMethod = entryOper.getKey();\n        Operation operation = entryOper.getValue();\n\n        Endpoint endpoint = new Endpoint();\n        endpoint.setPathUrl(url);\n        endpoint.setMethod(httpMethod);\n        endpoint.setSummary(operation.getSummary());\n        endpoint.setPath(path);\n        endpoint.setOperation(operation);\n        endpoints.add(endpoint);\n      }\n    }\n    return endpoints;\n  }", "signature": "public static List<Endpoint> convert2EndpointList(Map<String, PathItem> map)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/utils/ChangedUtils.java", "original_string": "package org.openapitools.openapidiff.core.utils;\n\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.Changed;\n\npublic class ChangedUtils {\n\n  private ChangedUtils() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }\n\n  public static boolean isUnchanged(Changed changed) {\n    return changed == null || changed.isUnchanged();\n  }\n\n  public static boolean isCompatible(Changed changed) {\n    return changed == null || changed.isCompatible();\n  }\n\n  public static <T extends Changed> Optional<T> isChanged(T changed) {\n    if (isUnchanged(changed)) {\n      return Optional.empty();\n    }\n    return Optional.of(changed);\n  }\n}\n", "file_hash": "05c65b4d51b0aaa1479cae913a87a36e3de7c2d1526dfced4cd72a1cd9a1b6bd", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.utils;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.Changed;"], "methods": [], "classes": [{"original_string": "public class ChangedUtils {\n\n  private ChangedUtils() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }\n\n  public static boolean isUnchanged(Changed changed) {\n    return changed == null || changed.isUnchanged();\n  }\n\n  public static boolean isCompatible(Changed changed) {\n    return changed == null || changed.isCompatible();\n  }\n\n  public static <T extends Changed> Optional<T> isChanged(T changed) {\n    if (isUnchanged(changed)) {\n      return Optional.empty();\n    }\n    return Optional.of(changed);\n  }\n}", "definition": "public class ChangedUtils", "class_docstring": "", "name": "ChangedUtils", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private ChangedUtils() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedUtils", "params": [], "body": "                         {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }", "signature": "private ChangedUtils()"}, {"syntax_pass": true, "original_string": "  public static boolean isUnchanged(Changed changed) {\n    return changed == null || changed.isUnchanged();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isUnchanged", "params": [{"name": "changed", "type": "Changed"}], "body": "                                                     {\n    return changed == null || changed.isUnchanged();\n  }", "signature": "public static boolean isUnchanged(Changed changed)"}, {"syntax_pass": true, "original_string": "  public static boolean isCompatible(Changed changed) {\n    return changed == null || changed.isCompatible();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isCompatible", "params": [{"name": "changed", "type": "Changed"}], "body": "                                                      {\n    return changed == null || changed.isCompatible();\n  }", "signature": "public static boolean isCompatible(Changed changed)"}, {"syntax_pass": true, "original_string": "  public static <T extends Changed> Optional<T> isChanged(T changed) {\n    if (isUnchanged(changed)) {\n      return Optional.empty();\n    }\n    return Optional.of(changed);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Optional<T>", "classes": []}, "name": "isChanged", "params": [{"name": "changed", "type": "T"}], "body": "                                                                     {\n    if (isUnchanged(changed)) {\n      return Optional.empty();\n    }\n    return Optional.of(changed);\n  }", "signature": "public static <T extends Changed> Optional<T> isChanged(T changed)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/utils/FileUtils.java", "original_string": "package org.openapitools.openapidiff.core.utils;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.output.Render;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic final class FileUtils {\n  private static final Logger logger = LoggerFactory.getLogger(FileUtils.class);\n\n  private FileUtils() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }\n\n  public static void writeToFile(\n      final Render render, final ChangedOpenApi diff, final String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      logger.debug(\"File name cannot be null or empty.\");\n      return;\n    }\n\n    final Path filePath = Paths.get(fileName);\n    try (final FileOutputStream outputStream = new FileOutputStream(filePath.toFile());\n        final OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream)) {\n      render.render(diff, outputStreamWriter);\n    } catch (final IOException e) {\n      logger.error(\"Exception while writing to file {}\", fileName, e);\n    }\n  }\n}\n", "file_hash": "c834d3f9f659a4e0875a8aa02c91b3b55cf7e5a5d54530c01bd7660030724fbb", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.utils;", "import java.io.FileOutputStream;", "import java.io.IOException;", "import java.io.OutputStreamWriter;", "import java.nio.file.Path;", "import java.nio.file.Paths;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.output.Render;", "import org.slf4j.Logger;", "import org.slf4j.LoggerFactory;"], "methods": [], "classes": [{"original_string": "public final class FileUtils {\n  private static final Logger logger = LoggerFactory.getLogger(FileUtils.class);\n\n  private FileUtils() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }\n\n  public static void writeToFile(\n      final Render render, final ChangedOpenApi diff, final String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      logger.debug(\"File name cannot be null or empty.\");\n      return;\n    }\n\n    final Path filePath = Paths.get(fileName);\n    try (final FileOutputStream outputStream = new FileOutputStream(filePath.toFile());\n        final OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream)) {\n      render.render(diff, outputStreamWriter);\n    } catch (final IOException e) {\n      logger.error(\"Exception while writing to file {}\", fileName, e);\n    }\n  }\n}", "definition": "public final class FileUtils", "class_docstring": "", "name": "FileUtils", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private static final Logger logger = LoggerFactory.getLogger(FileUtils.class);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger = LoggerFactory.getLogger(FileUtils.class)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private FileUtils() {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "FileUtils", "params": [], "body": "                      {\n    throw new UnsupportedOperationException(\"Utility class. Do not instantiate\");\n  }", "signature": "private FileUtils()"}, {"syntax_pass": true, "original_string": "  public static void writeToFile(\n      final Render render, final ChangedOpenApi diff, final String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      logger.debug(\"File name cannot be null or empty.\");\n      return;\n    }\n\n    final Path filePath = Paths.get(fileName);\n    try (final FileOutputStream outputStream = new FileOutputStream(filePath.toFile());\n        final OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream)) {\n      render.render(diff, outputStreamWriter);\n    } catch (final IOException e) {\n      logger.error(\"Exception while writing to file {}\", fileName, e);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "writeToFile", "params": [{"name": "render", "type": "Render"}, {"name": "diff", "type": "ChangedOpenApi"}, {"name": "fileName", "type": "String"}], "body": "                                                                             {\n    if (fileName == null || fileName.isEmpty()) {\n      logger.debug(\"File name cannot be null or empty.\");\n      return;\n    }\n\n    final Path filePath = Paths.get(fileName);\n    try (final FileOutputStream outputStream = new FileOutputStream(filePath.toFile());\n        final OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream)) {\n      render.render(diff, outputStreamWriter);\n    } catch (final IOException e) {\n      logger.error(\"Exception while writing to file {}\", fileName, e);\n    }\n  }", "signature": "public static void writeToFile(\n      final Render render, final ChangedOpenApi diff, final String fileName)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/utils/RefPointer.java", "original_string": "package org.openapitools.openapidiff.core.utils;\n\nimport io.swagger.v3.oas.models.Components;\nimport java.util.Map;\n\npublic class RefPointer<T> {\n  public static final String BASE_REF = \"#/components/\";\n  private final RefType refType;\n\n  public RefPointer(RefType refType) {\n    this.refType = refType;\n  }\n\n  public T resolveRef(Components components, T t, String ref) {\n    if (ref != null) {\n      String refName = getRefName(ref);\n      T result = getMap(components).get(refName);\n      if (result == null) {\n        throw new IllegalArgumentException(String.format(\"ref '%s' doesn't exist.\", ref));\n      }\n      return result;\n    }\n    return t;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private Map<String, T> getMap(Components components) {\n    switch (refType) {\n      case REQUEST_BODIES:\n        return (Map<String, T>) components.getRequestBodies();\n      case RESPONSES:\n        return (Map<String, T>) components.getResponses();\n      case PARAMETERS:\n        return (Map<String, T>) components.getParameters();\n      case SCHEMAS:\n        return (Map<String, T>) components.getSchemas();\n      case HEADERS:\n        return (Map<String, T>) components.getHeaders();\n      case SECURITY_SCHEMES:\n        return (Map<String, T>) components.getSecuritySchemes();\n      default:\n        throw new IllegalArgumentException(\"Not mapped for refType: \" + refType);\n    }\n  }\n\n  private String getBaseRefForType(String type) {\n    return String.format(\"%s%s/\", BASE_REF, type);\n  }\n\n  public String getRefName(String ref) {\n    if (ref == null) {\n      return null;\n    }\n    if (refType == RefType.SECURITY_SCHEMES) {\n      return ref;\n    }\n\n    final String baseRef = getBaseRefForType(refType.getName());\n    if (!ref.startsWith(baseRef)) {\n      throw new IllegalArgumentException(\"Invalid ref: \" + ref);\n    }\n    return ref.substring(baseRef.length());\n  }\n}\n", "file_hash": "746b255975d8015f90246b150b083583f593f51f5d2b0fb41a735fcb7cd66165", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.utils;", "import io.swagger.v3.oas.models.Components;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public class RefPointer<T> {\n  public static final String BASE_REF = \"#/components/\";\n  private final RefType refType;\n\n  public RefPointer(RefType refType) {\n    this.refType = refType;\n  }\n\n  public T resolveRef(Components components, T t, String ref) {\n    if (ref != null) {\n      String refName = getRefName(ref);\n      T result = getMap(components).get(refName);\n      if (result == null) {\n        throw new IllegalArgumentException(String.format(\"ref '%s' doesn't exist.\", ref));\n      }\n      return result;\n    }\n    return t;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private Map<String, T> getMap(Components components) {\n    switch (refType) {\n      case REQUEST_BODIES:\n        return (Map<String, T>) components.getRequestBodies();\n      case RESPONSES:\n        return (Map<String, T>) components.getResponses();\n      case PARAMETERS:\n        return (Map<String, T>) components.getParameters();\n      case SCHEMAS:\n        return (Map<String, T>) components.getSchemas();\n      case HEADERS:\n        return (Map<String, T>) components.getHeaders();\n      case SECURITY_SCHEMES:\n        return (Map<String, T>) components.getSecuritySchemes();\n      default:\n        throw new IllegalArgumentException(\"Not mapped for refType: \" + refType);\n    }\n  }\n\n  private String getBaseRefForType(String type) {\n    return String.format(\"%s%s/\", BASE_REF, type);\n  }\n\n  public String getRefName(String ref) {\n    if (ref == null) {\n      return null;\n    }\n    if (refType == RefType.SECURITY_SCHEMES) {\n      return ref;\n    }\n\n    final String baseRef = getBaseRefForType(refType.getName());\n    if (!ref.startsWith(baseRef)) {\n      throw new IllegalArgumentException(\"Invalid ref: \" + ref);\n    }\n    return ref.substring(baseRef.length());\n  }\n}", "definition": "public class RefPointer<T>", "class_docstring": "", "name": "RefPointer", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "public static final String BASE_REF = \"#/components/\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "BASE_REF = \"#/components/\"", "syntax_pass": true}, {"attribute_expression": "private final RefType refType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RefType", "name": "refType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public RefPointer(RefType refType) {\n    this.refType = refType;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "RefPointer", "params": [{"name": "refType", "type": "RefType"}], "body": "                                     {\n    this.refType = refType;\n  }", "signature": "public RefPointer(RefType refType)"}, {"syntax_pass": true, "original_string": "  public T resolveRef(Components components, T t, String ref) {\n    if (ref != null) {\n      String refName = getRefName(ref);\n      T result = getMap(components).get(refName);\n      if (result == null) {\n        throw new IllegalArgumentException(String.format(\"ref '%s' doesn't exist.\", ref));\n      }\n      return result;\n    }\n    return t;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "resolveRef", "params": [{"name": "components", "type": "Components"}, {"name": "t", "type": "T"}, {"name": "ref", "type": "String"}], "body": "                                                              {\n    if (ref != null) {\n      String refName = getRefName(ref);\n      T result = getMap(components).get(refName);\n      if (result == null) {\n        throw new IllegalArgumentException(String.format(\"ref '%s' doesn't exist.\", ref));\n      }\n      return result;\n    }\n    return t;\n  }", "signature": "public T resolveRef(Components components, T t, String ref)"}, {"syntax_pass": true, "original_string": "  @SuppressWarnings(\"unchecked\")\n  private Map<String, T> getMap(Components components) {\n    switch (refType) {\n      case REQUEST_BODIES:\n        return (Map<String, T>) components.getRequestBodies();\n      case RESPONSES:\n        return (Map<String, T>) components.getResponses();\n      case PARAMETERS:\n        return (Map<String, T>) components.getParameters();\n      case SCHEMAS:\n        return (Map<String, T>) components.getSchemas();\n      case HEADERS:\n        return (Map<String, T>) components.getHeaders();\n      case SECURITY_SCHEMES:\n        return (Map<String, T>) components.getSecuritySchemes();\n      default:\n        throw new IllegalArgumentException(\"Not mapped for refType: \" + refType);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "private"], "comments": [], "return_type": "Map<String, T>", "classes": []}, "name": "getMap", "params": [{"name": "components", "type": "Components"}], "body": "                                                       {\n    switch (refType) {\n      case REQUEST_BODIES:\n        return (Map<String, T>) components.getRequestBodies();\n      case RESPONSES:\n        return (Map<String, T>) components.getResponses();\n      case PARAMETERS:\n        return (Map<String, T>) components.getParameters();\n      case SCHEMAS:\n        return (Map<String, T>) components.getSchemas();\n      case HEADERS:\n        return (Map<String, T>) components.getHeaders();\n      case SECURITY_SCHEMES:\n        return (Map<String, T>) components.getSecuritySchemes();\n      default:\n        throw new IllegalArgumentException(\"Not mapped for refType: \" + refType);\n    }\n  }", "signature": "@SuppressWarnings(\"unchecked\")\n  private Map<String, T> getMap(Components components)"}, {"syntax_pass": true, "original_string": "  private String getBaseRefForType(String type) {\n    return String.format(\"%s%s/\", BASE_REF, type);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "name": "getBaseRefForType", "params": [{"name": "type", "type": "String"}], "body": "                                                {\n    return String.format(\"%s%s/\", BASE_REF, type);\n  }", "signature": "private String getBaseRefForType(String type)"}, {"syntax_pass": true, "original_string": "  public String getRefName(String ref) {\n    if (ref == null) {\n      return null;\n    }\n    if (refType == RefType.SECURITY_SCHEMES) {\n      return ref;\n    }\n\n    final String baseRef = getBaseRefForType(refType.getName());\n    if (!ref.startsWith(baseRef)) {\n      throw new IllegalArgumentException(\"Invalid ref: \" + ref);\n    }\n    return ref.substring(baseRef.length());\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getRefName", "params": [{"name": "ref", "type": "String"}], "body": "                                       {\n    if (ref == null) {\n      return null;\n    }\n    if (refType == RefType.SECURITY_SCHEMES) {\n      return ref;\n    }\n\n    final String baseRef = getBaseRefForType(refType.getName());\n    if (!ref.startsWith(baseRef)) {\n      throw new IllegalArgumentException(\"Invalid ref: \" + ref);\n    }\n    return ref.substring(baseRef.length());\n  }", "signature": "public String getRefName(String ref)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/utils/RefType.java", "original_string": "package org.openapitools.openapidiff.core.utils;\n\npublic enum RefType {\n  REQUEST_BODIES(\"requestBodies\"),\n  RESPONSES(\"responses\"),\n  PARAMETERS(\"parameters\"),\n  SCHEMAS(\"schemas\"),\n  HEADERS(\"headers\"),\n  SECURITY_SCHEMES(\"securitySchemes\");\n\n  RefType(String name) {\n    this.name = name;\n  }\n\n  private final String name;\n\n  public String getName() {\n    return this.name;\n  }\n}\n", "file_hash": "a3b25269ae62cf265c308a089e7a6fc1965fada8a6e9fc8b624b7f6237d43fa6", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.utils;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedMediaType.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport io.swagger.v3.oas.models.media.Schema;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedMediaType implements ComposedChanged {\n  private final Schema oldSchema;\n  private final Schema newSchema;\n  private final DiffContext context;\n  private ChangedSchema schema;\n\n  public ChangedMediaType(Schema oldSchema, Schema newSchema, DiffContext context) {\n    this.oldSchema = oldSchema;\n    this.newSchema = newSchema;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Collections.singletonList(schema);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    return DiffResult.NO_CHANGES;\n  }\n\n  public Schema getOldSchema() {\n    return this.oldSchema;\n  }\n\n  public Schema getNewSchema() {\n    return this.newSchema;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public ChangedSchema getSchema() {\n    return this.schema;\n  }\n\n  public ChangedMediaType setSchema(final ChangedSchema schema) {\n    this.schema = schema;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMediaType that = (ChangedMediaType) o;\n    return Objects.equals(oldSchema, that.oldSchema)\n        && Objects.equals(newSchema, that.newSchema)\n        && Objects.equals(context, that.context)\n        && Objects.equals(schema, that.schema);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldSchema, newSchema, context, schema);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedMediaType(oldSchema=\"\n        + this.getOldSchema()\n        + \", newSchema=\"\n        + this.getNewSchema()\n        + \", context=\"\n        + this.getContext()\n        + \", schema=\"\n        + this.getSchema()\n        + \")\";\n  }\n}\n", "file_hash": "d218a083a793b811b80f2d1eae6cb09a626f3969de6d7a233945a276971247e7", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import io.swagger.v3.oas.models.media.Schema;", "import java.util.Collections;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedMediaType implements ComposedChanged {\n  private final Schema oldSchema;\n  private final Schema newSchema;\n  private final DiffContext context;\n  private ChangedSchema schema;\n\n  public ChangedMediaType(Schema oldSchema, Schema newSchema, DiffContext context) {\n    this.oldSchema = oldSchema;\n    this.newSchema = newSchema;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Collections.singletonList(schema);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    return DiffResult.NO_CHANGES;\n  }\n\n  public Schema getOldSchema() {\n    return this.oldSchema;\n  }\n\n  public Schema getNewSchema() {\n    return this.newSchema;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public ChangedSchema getSchema() {\n    return this.schema;\n  }\n\n  public ChangedMediaType setSchema(final ChangedSchema schema) {\n    this.schema = schema;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMediaType that = (ChangedMediaType) o;\n    return Objects.equals(oldSchema, that.oldSchema)\n        && Objects.equals(newSchema, that.newSchema)\n        && Objects.equals(context, that.context)\n        && Objects.equals(schema, that.schema);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldSchema, newSchema, context, schema);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedMediaType(oldSchema=\"\n        + this.getOldSchema()\n        + \", newSchema=\"\n        + this.getNewSchema()\n        + \", context=\"\n        + this.getContext()\n        + \", schema=\"\n        + this.getSchema()\n        + \")\";\n  }\n}", "definition": "public class ChangedMediaType implements ComposedChanged", "class_docstring": "", "name": "ChangedMediaType", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Schema oldSchema;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Schema", "name": "oldSchema", "syntax_pass": true}, {"attribute_expression": "private final Schema newSchema;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Schema", "name": "newSchema", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private ChangedSchema schema;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedSchema", "name": "schema", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedMediaType(Schema oldSchema, Schema newSchema, DiffContext context) {\n    this.oldSchema = oldSchema;\n    this.newSchema = newSchema;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedMediaType", "params": [{"name": "oldSchema", "type": "Schema"}, {"name": "newSchema", "type": "Schema"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                   {\n    this.oldSchema = oldSchema;\n    this.newSchema = newSchema;\n    this.context = context;\n  }", "signature": "public ChangedMediaType(Schema oldSchema, Schema newSchema, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Collections.singletonList(schema);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Collections.singletonList(schema);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    return DiffResult.NO_CHANGES;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    return DiffResult.NO_CHANGES;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public Schema getOldSchema() {\n    return this.oldSchema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Schema", "classes": []}, "name": "getOldSchema", "params": [], "body": "                               {\n    return this.oldSchema;\n  }", "signature": "public Schema getOldSchema()"}, {"syntax_pass": true, "original_string": "  public Schema getNewSchema() {\n    return this.newSchema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Schema", "classes": []}, "name": "getNewSchema", "params": [], "body": "                               {\n    return this.newSchema;\n  }", "signature": "public Schema getNewSchema()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public ChangedSchema getSchema() {\n    return this.schema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "getSchema", "params": [], "body": "                                   {\n    return this.schema;\n  }", "signature": "public ChangedSchema getSchema()"}, {"syntax_pass": true, "original_string": "  public ChangedMediaType setSchema(final ChangedSchema schema) {\n    this.schema = schema;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMediaType", "classes": []}, "name": "setSchema", "params": [{"name": "schema", "type": "ChangedSchema"}], "body": "                                                                {\n    this.schema = schema;\n    return this;\n  }", "signature": "public ChangedMediaType setSchema(final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMediaType that = (ChangedMediaType) o;\n    return Objects.equals(oldSchema, that.oldSchema)\n        && Objects.equals(newSchema, that.newSchema)\n        && Objects.equals(context, that.context)\n        && Objects.equals(schema, that.schema);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMediaType that = (ChangedMediaType) o;\n    return Objects.equals(oldSchema, that.oldSchema)\n        && Objects.equals(newSchema, that.newSchema)\n        && Objects.equals(context, that.context)\n        && Objects.equals(schema, that.schema);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(oldSchema, newSchema, context, schema);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(oldSchema, newSchema, context, schema);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedMediaType(oldSchema=\"\n        + this.getOldSchema()\n        + \", newSchema=\"\n        + this.getNewSchema()\n        + \", context=\"\n        + this.getContext()\n        + \", schema=\"\n        + this.getSchema()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedMediaType(oldSchema=\"\n        + this.getOldSchema()\n        + \", newSchema=\"\n        + this.getNewSchema()\n        + \", context=\"\n        + this.getContext()\n        + \", schema=\"\n        + this.getSchema()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedSecurityRequirements.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_REQUIREMENTS_DECREASED;\n\nimport io.swagger.v3.oas.models.security.SecurityRequirement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport org.apache.commons.collections4.CollectionUtils;\n\npublic class ChangedSecurityRequirements implements ComposedChanged {\n  private List<SecurityRequirement> oldSecurityRequirements;\n  private List<SecurityRequirement> newSecurityRequirements;\n  private final DiffContext context;\n  private List<SecurityRequirement> missing;\n  private List<SecurityRequirement> increased;\n  private List<ChangedSecurityRequirement> changed;\n\n  public ChangedSecurityRequirements(\n      List<SecurityRequirement> oldSecurityRequirements,\n      List<SecurityRequirement> newSecurityRequirements,\n      DiffContext context) {\n    this.oldSecurityRequirements = oldSecurityRequirements;\n    this.newSecurityRequirements = newSecurityRequirements;\n    this.context = context;\n    this.changed = new ArrayList<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (CollectionUtils.isEmpty(missing) && CollectionUtils.isEmpty(increased)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (CollectionUtils.isNotEmpty(missing)) {\n      if (SECURITY_REQUIREMENTS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public void addMissing(SecurityRequirement securityRequirement) {\n    if (this.missing == null) {\n      this.missing = new ArrayList<>();\n    }\n    this.missing.add(securityRequirement);\n  }\n\n  public void addIncreased(SecurityRequirement securityRequirement) {\n    if (this.increased == null) {\n      this.increased = new ArrayList<>();\n    }\n    this.increased.add(securityRequirement);\n  }\n\n  public void addChanged(ChangedSecurityRequirement changedSecurityRequirement) {\n    if (this.changed == null) {\n      this.changed = new ArrayList<>();\n    }\n    this.changed.add(changedSecurityRequirement);\n  }\n\n  public List<SecurityRequirement> getOldSecurityRequirements() {\n    return this.oldSecurityRequirements;\n  }\n\n  public List<SecurityRequirement> getNewSecurityRequirements() {\n    return this.newSecurityRequirements;\n  }\n\n  public List<SecurityRequirement> getMissing() {\n    return this.missing;\n  }\n\n  public List<SecurityRequirement> getIncreased() {\n    return this.increased;\n  }\n\n  public List<ChangedSecurityRequirement> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedSecurityRequirements setOldSecurityRequirements(\n      final List<SecurityRequirement> oldSecurityRequirements) {\n    this.oldSecurityRequirements = oldSecurityRequirements;\n    return this;\n  }\n\n  public ChangedSecurityRequirements setNewSecurityRequirements(\n      final List<SecurityRequirement> newSecurityRequirements) {\n    this.newSecurityRequirements = newSecurityRequirements;\n    return this;\n  }\n\n  public ChangedSecurityRequirements setMissing(final List<SecurityRequirement> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedSecurityRequirements setIncreased(final List<SecurityRequirement> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedSecurityRequirements setChanged(final List<ChangedSecurityRequirement> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityRequirements that = (ChangedSecurityRequirements) o;\n    return Objects.equals(oldSecurityRequirements, that.oldSecurityRequirements)\n        && Objects.equals(newSecurityRequirements, that.newSecurityRequirements)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSecurityRequirements, newSecurityRequirements, missing, increased, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSecurityRequirements(oldSecurityRequirements=\"\n        + this.getOldSecurityRequirements()\n        + \", newSecurityRequirements=\"\n        + this.getNewSecurityRequirements()\n        + \", missing=\"\n        + this.getMissing()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}\n", "file_hash": "d52739a4c148efa7b03e6cb10b04a33480046440d239cdcaaa9e2867355231f2", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_REQUIREMENTS_DECREASED;", "import io.swagger.v3.oas.models.security.SecurityRequirement;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Objects;", "import org.apache.commons.collections4.CollectionUtils;"], "methods": [], "classes": [{"original_string": "public class ChangedSecurityRequirements implements ComposedChanged {\n  private List<SecurityRequirement> oldSecurityRequirements;\n  private List<SecurityRequirement> newSecurityRequirements;\n  private final DiffContext context;\n  private List<SecurityRequirement> missing;\n  private List<SecurityRequirement> increased;\n  private List<ChangedSecurityRequirement> changed;\n\n  public ChangedSecurityRequirements(\n      List<SecurityRequirement> oldSecurityRequirements,\n      List<SecurityRequirement> newSecurityRequirements,\n      DiffContext context) {\n    this.oldSecurityRequirements = oldSecurityRequirements;\n    this.newSecurityRequirements = newSecurityRequirements;\n    this.context = context;\n    this.changed = new ArrayList<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (CollectionUtils.isEmpty(missing) && CollectionUtils.isEmpty(increased)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (CollectionUtils.isNotEmpty(missing)) {\n      if (SECURITY_REQUIREMENTS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public void addMissing(SecurityRequirement securityRequirement) {\n    if (this.missing == null) {\n      this.missing = new ArrayList<>();\n    }\n    this.missing.add(securityRequirement);\n  }\n\n  public void addIncreased(SecurityRequirement securityRequirement) {\n    if (this.increased == null) {\n      this.increased = new ArrayList<>();\n    }\n    this.increased.add(securityRequirement);\n  }\n\n  public void addChanged(ChangedSecurityRequirement changedSecurityRequirement) {\n    if (this.changed == null) {\n      this.changed = new ArrayList<>();\n    }\n    this.changed.add(changedSecurityRequirement);\n  }\n\n  public List<SecurityRequirement> getOldSecurityRequirements() {\n    return this.oldSecurityRequirements;\n  }\n\n  public List<SecurityRequirement> getNewSecurityRequirements() {\n    return this.newSecurityRequirements;\n  }\n\n  public List<SecurityRequirement> getMissing() {\n    return this.missing;\n  }\n\n  public List<SecurityRequirement> getIncreased() {\n    return this.increased;\n  }\n\n  public List<ChangedSecurityRequirement> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedSecurityRequirements setOldSecurityRequirements(\n      final List<SecurityRequirement> oldSecurityRequirements) {\n    this.oldSecurityRequirements = oldSecurityRequirements;\n    return this;\n  }\n\n  public ChangedSecurityRequirements setNewSecurityRequirements(\n      final List<SecurityRequirement> newSecurityRequirements) {\n    this.newSecurityRequirements = newSecurityRequirements;\n    return this;\n  }\n\n  public ChangedSecurityRequirements setMissing(final List<SecurityRequirement> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedSecurityRequirements setIncreased(final List<SecurityRequirement> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedSecurityRequirements setChanged(final List<ChangedSecurityRequirement> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityRequirements that = (ChangedSecurityRequirements) o;\n    return Objects.equals(oldSecurityRequirements, that.oldSecurityRequirements)\n        && Objects.equals(newSecurityRequirements, that.newSecurityRequirements)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSecurityRequirements, newSecurityRequirements, missing, increased, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSecurityRequirements(oldSecurityRequirements=\"\n        + this.getOldSecurityRequirements()\n        + \", newSecurityRequirements=\"\n        + this.getNewSecurityRequirements()\n        + \", missing=\"\n        + this.getMissing()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}", "definition": "public class ChangedSecurityRequirements implements ComposedChanged", "class_docstring": "", "name": "ChangedSecurityRequirements", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private List<SecurityRequirement> oldSecurityRequirements;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<SecurityRequirement>", "name": "oldSecurityRequirements", "syntax_pass": true}, {"attribute_expression": "private List<SecurityRequirement> newSecurityRequirements;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<SecurityRequirement>", "name": "newSecurityRequirements", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private List<SecurityRequirement> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<SecurityRequirement>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private List<SecurityRequirement> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<SecurityRequirement>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private List<ChangedSecurityRequirement> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<ChangedSecurityRequirement>", "name": "changed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedSecurityRequirements(\n      List<SecurityRequirement> oldSecurityRequirements,\n      List<SecurityRequirement> newSecurityRequirements,\n      DiffContext context) {\n    this.oldSecurityRequirements = oldSecurityRequirements;\n    this.newSecurityRequirements = newSecurityRequirements;\n    this.context = context;\n    this.changed = new ArrayList<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedSecurityRequirements", "params": [{"name": "oldSecurityRequirements", "type": "List<SecurityRequirement>"}, {"name": "newSecurityRequirements", "type": "List<SecurityRequirement>"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n    this.oldSecurityRequirements = oldSecurityRequirements;\n    this.newSecurityRequirements = newSecurityRequirements;\n    this.context = context;\n    this.changed = new ArrayList<>();\n  }", "signature": "public ChangedSecurityRequirements(\n      List<SecurityRequirement> oldSecurityRequirements,\n      List<SecurityRequirement> newSecurityRequirements,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return new ArrayList<>(changed);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (CollectionUtils.isEmpty(missing) && CollectionUtils.isEmpty(increased)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (CollectionUtils.isNotEmpty(missing)) {\n      if (SECURITY_REQUIREMENTS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (CollectionUtils.isEmpty(missing) && CollectionUtils.isEmpty(increased)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (CollectionUtils.isNotEmpty(missing)) {\n      if (SECURITY_REQUIREMENTS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public void addMissing(SecurityRequirement securityRequirement) {\n    if (this.missing == null) {\n      this.missing = new ArrayList<>();\n    }\n    this.missing.add(securityRequirement);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "addMissing", "params": [{"name": "securityRequirement", "type": "SecurityRequirement"}], "body": "                                                                  {\n    if (this.missing == null) {\n      this.missing = new ArrayList<>();\n    }\n    this.missing.add(securityRequirement);\n  }", "signature": "public void addMissing(SecurityRequirement securityRequirement)"}, {"syntax_pass": true, "original_string": "  public void addIncreased(SecurityRequirement securityRequirement) {\n    if (this.increased == null) {\n      this.increased = new ArrayList<>();\n    }\n    this.increased.add(securityRequirement);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "addIncreased", "params": [{"name": "securityRequirement", "type": "SecurityRequirement"}], "body": "                                                                    {\n    if (this.increased == null) {\n      this.increased = new ArrayList<>();\n    }\n    this.increased.add(securityRequirement);\n  }", "signature": "public void addIncreased(SecurityRequirement securityRequirement)"}, {"syntax_pass": true, "original_string": "  public void addChanged(ChangedSecurityRequirement changedSecurityRequirement) {\n    if (this.changed == null) {\n      this.changed = new ArrayList<>();\n    }\n    this.changed.add(changedSecurityRequirement);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "addChanged", "params": [{"name": "changedSecurityRequirement", "type": "ChangedSecurityRequirement"}], "body": "                                                                                {\n    if (this.changed == null) {\n      this.changed = new ArrayList<>();\n    }\n    this.changed.add(changedSecurityRequirement);\n  }", "signature": "public void addChanged(ChangedSecurityRequirement changedSecurityRequirement)"}, {"syntax_pass": true, "original_string": "  public List<SecurityRequirement> getOldSecurityRequirements() {\n    return this.oldSecurityRequirements;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<SecurityRequirement>", "classes": []}, "name": "getOldSecurityRequirements", "params": [], "body": "                                                                {\n    return this.oldSecurityRequirements;\n  }", "signature": "public List<SecurityRequirement> getOldSecurityRequirements()"}, {"syntax_pass": true, "original_string": "  public List<SecurityRequirement> getNewSecurityRequirements() {\n    return this.newSecurityRequirements;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<SecurityRequirement>", "classes": []}, "name": "getNewSecurityRequirements", "params": [], "body": "                                                                {\n    return this.newSecurityRequirements;\n  }", "signature": "public List<SecurityRequirement> getNewSecurityRequirements()"}, {"syntax_pass": true, "original_string": "  public List<SecurityRequirement> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<SecurityRequirement>", "classes": []}, "name": "getMissing", "params": [], "body": "                                                {\n    return this.missing;\n  }", "signature": "public List<SecurityRequirement> getMissing()"}, {"syntax_pass": true, "original_string": "  public List<SecurityRequirement> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<SecurityRequirement>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                                  {\n    return this.increased;\n  }", "signature": "public List<SecurityRequirement> getIncreased()"}, {"syntax_pass": true, "original_string": "  public List<ChangedSecurityRequirement> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ChangedSecurityRequirement>", "classes": []}, "name": "getChanged", "params": [], "body": "                                                       {\n    return this.changed;\n  }", "signature": "public List<ChangedSecurityRequirement> getChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirements setOldSecurityRequirements(\n      final List<SecurityRequirement> oldSecurityRequirements) {\n    this.oldSecurityRequirements = oldSecurityRequirements;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirements", "classes": []}, "name": "setOldSecurityRequirements", "params": [{"name": "oldSecurityRequirements", "type": "List<SecurityRequirement>"}], "body": "                                                               {\n    this.oldSecurityRequirements = oldSecurityRequirements;\n    return this;\n  }", "signature": "public ChangedSecurityRequirements setOldSecurityRequirements(\n      final List<SecurityRequirement> oldSecurityRequirements)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirements setNewSecurityRequirements(\n      final List<SecurityRequirement> newSecurityRequirements) {\n    this.newSecurityRequirements = newSecurityRequirements;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirements", "classes": []}, "name": "setNewSecurityRequirements", "params": [{"name": "newSecurityRequirements", "type": "List<SecurityRequirement>"}], "body": "                                                               {\n    this.newSecurityRequirements = newSecurityRequirements;\n    return this;\n  }", "signature": "public ChangedSecurityRequirements setNewSecurityRequirements(\n      final List<SecurityRequirement> newSecurityRequirements)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirements setMissing(final List<SecurityRequirement> missing) {\n    this.missing = missing;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirements", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "List<SecurityRequirement>"}], "body": "                                                                                         {\n    this.missing = missing;\n    return this;\n  }", "signature": "public ChangedSecurityRequirements setMissing(final List<SecurityRequirement> missing)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirements setIncreased(final List<SecurityRequirement> increased) {\n    this.increased = increased;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirements", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "List<SecurityRequirement>"}], "body": "                                                                                             {\n    this.increased = increased;\n    return this;\n  }", "signature": "public ChangedSecurityRequirements setIncreased(final List<SecurityRequirement> increased)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirements setChanged(final List<ChangedSecurityRequirement> changed) {\n    this.changed = changed;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirements", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "List<ChangedSecurityRequirement>"}], "body": "                                                                                                {\n    this.changed = changed;\n    return this;\n  }", "signature": "public ChangedSecurityRequirements setChanged(final List<ChangedSecurityRequirement> changed)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityRequirements that = (ChangedSecurityRequirements) o;\n    return Objects.equals(oldSecurityRequirements, that.oldSecurityRequirements)\n        && Objects.equals(newSecurityRequirements, that.newSecurityRequirements)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(changed, that.changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityRequirements that = (ChangedSecurityRequirements) o;\n    return Objects.equals(oldSecurityRequirements, that.oldSecurityRequirements)\n        && Objects.equals(newSecurityRequirements, that.newSecurityRequirements)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(changed, that.changed);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSecurityRequirements, newSecurityRequirements, missing, increased, changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldSecurityRequirements, newSecurityRequirements, missing, increased, changed);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSecurityRequirements(oldSecurityRequirements=\"\n        + this.getOldSecurityRequirements()\n        + \", newSecurityRequirements=\"\n        + this.getNewSecurityRequirements()\n        + \", missing=\"\n        + this.getMissing()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedSecurityRequirements(oldSecurityRequirements=\"\n        + this.getOldSecurityRequirements()\n        + \", newSecurityRequirements=\"\n        + this.getNewSecurityRequirements()\n        + \", missing=\"\n        + this.getMissing()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedPaths.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;\n\nimport io.swagger.v3.oas.models.PathItem;\nimport java.util.*;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;\n\npublic class ChangedPaths implements ComposedChanged {\n  private final OpenApiDiffOptions options;\n  private final Map<String, PathItem> oldPathMap;\n  private final Map<String, PathItem> newPathMap;\n  private Map<String, PathItem> increased;\n  private Map<String, PathItem> missing;\n  private Map<String, ChangedPath> changed;\n\n  public ChangedPaths(\n      Map<String, PathItem> oldPathMap,\n      Map<String, PathItem> newPathMap,\n      OpenApiDiffOptions options) {\n    this.options = options;\n    this.oldPathMap = oldPathMap;\n    this.newPathMap = newPathMap;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(options.getConfig())) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Map<String, PathItem> getOldPathMap() {\n    return this.oldPathMap;\n  }\n\n  public Map<String, PathItem> getNewPathMap() {\n    return this.newPathMap;\n  }\n\n  public Map<String, PathItem> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, PathItem> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedPath> getChanged() {\n    return this.changed;\n  }\n\n  public void setIncreased(final Map<String, PathItem> increased) {\n    this.increased = increased;\n  }\n\n  public void setMissing(final Map<String, PathItem> missing) {\n    this.missing = missing;\n  }\n\n  public void setChanged(final Map<String, ChangedPath> changed) {\n    this.changed = changed;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedPaths that = (ChangedPaths) o;\n    return Objects.equals(oldPathMap, that.oldPathMap)\n        && Objects.equals(newPathMap, that.newPathMap)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldPathMap, newPathMap, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedPaths(oldPathMap=\"\n        + this.getOldPathMap()\n        + \", newPathMap=\"\n        + this.getNewPathMap()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}\n", "file_hash": "20fcdab7a75d8b8bc323865ec692d59e3691a9e711c5908a313f809afae8e653", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;", "import io.swagger.v3.oas.models.PathItem;", "import java.util.*;", "import org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;"], "methods": [], "classes": [{"original_string": "public class ChangedPaths implements ComposedChanged {\n  private final OpenApiDiffOptions options;\n  private final Map<String, PathItem> oldPathMap;\n  private final Map<String, PathItem> newPathMap;\n  private Map<String, PathItem> increased;\n  private Map<String, PathItem> missing;\n  private Map<String, ChangedPath> changed;\n\n  public ChangedPaths(\n      Map<String, PathItem> oldPathMap,\n      Map<String, PathItem> newPathMap,\n      OpenApiDiffOptions options) {\n    this.options = options;\n    this.oldPathMap = oldPathMap;\n    this.newPathMap = newPathMap;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(options.getConfig())) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Map<String, PathItem> getOldPathMap() {\n    return this.oldPathMap;\n  }\n\n  public Map<String, PathItem> getNewPathMap() {\n    return this.newPathMap;\n  }\n\n  public Map<String, PathItem> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, PathItem> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedPath> getChanged() {\n    return this.changed;\n  }\n\n  public void setIncreased(final Map<String, PathItem> increased) {\n    this.increased = increased;\n  }\n\n  public void setMissing(final Map<String, PathItem> missing) {\n    this.missing = missing;\n  }\n\n  public void setChanged(final Map<String, ChangedPath> changed) {\n    this.changed = changed;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedPaths that = (ChangedPaths) o;\n    return Objects.equals(oldPathMap, that.oldPathMap)\n        && Objects.equals(newPathMap, that.newPathMap)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldPathMap, newPathMap, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedPaths(oldPathMap=\"\n        + this.getOldPathMap()\n        + \", newPathMap=\"\n        + this.getNewPathMap()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}", "definition": "public class ChangedPaths implements ComposedChanged", "class_docstring": "", "name": "ChangedPaths", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiffOptions options;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiffOptions", "name": "options", "syntax_pass": true}, {"attribute_expression": "private final Map<String, PathItem> oldPathMap;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, PathItem>", "name": "oldPathMap", "syntax_pass": true}, {"attribute_expression": "private final Map<String, PathItem> newPathMap;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, PathItem>", "name": "newPathMap", "syntax_pass": true}, {"attribute_expression": "private Map<String, PathItem> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, PathItem>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private Map<String, PathItem> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, PathItem>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private Map<String, ChangedPath> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, ChangedPath>", "name": "changed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedPaths(\n      Map<String, PathItem> oldPathMap,\n      Map<String, PathItem> newPathMap,\n      OpenApiDiffOptions options) {\n    this.options = options;\n    this.oldPathMap = oldPathMap;\n    this.newPathMap = newPathMap;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedPaths", "params": [{"name": "oldPathMap", "type": "Map<String, PathItem>"}, {"name": "newPathMap", "type": "Map<String, PathItem>"}, {"name": "options", "type": "OpenApiDiffOptions"}], "body": "                                  {\n    this.options = options;\n    this.oldPathMap = oldPathMap;\n    this.newPathMap = newPathMap;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }", "signature": "public ChangedPaths(\n      Map<String, PathItem> oldPathMap,\n      Map<String, PathItem> newPathMap,\n      OpenApiDiffOptions options)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return new ArrayList<>(changed.values());\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(options.getConfig())) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(options.getConfig())) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public Map<String, PathItem> getOldPathMap() {\n    return this.oldPathMap;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, PathItem>", "classes": []}, "name": "getOldPathMap", "params": [], "body": "                                               {\n    return this.oldPathMap;\n  }", "signature": "public Map<String, PathItem> getOldPathMap()"}, {"syntax_pass": true, "original_string": "  public Map<String, PathItem> getNewPathMap() {\n    return this.newPathMap;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, PathItem>", "classes": []}, "name": "getNewPathMap", "params": [], "body": "                                               {\n    return this.newPathMap;\n  }", "signature": "public Map<String, PathItem> getNewPathMap()"}, {"syntax_pass": true, "original_string": "  public Map<String, PathItem> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, PathItem>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                              {\n    return this.increased;\n  }", "signature": "public Map<String, PathItem> getIncreased()"}, {"syntax_pass": true, "original_string": "  public Map<String, PathItem> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, PathItem>", "classes": []}, "name": "getMissing", "params": [], "body": "                                            {\n    return this.missing;\n  }", "signature": "public Map<String, PathItem> getMissing()"}, {"syntax_pass": true, "original_string": "  public Map<String, ChangedPath> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ChangedPath>", "classes": []}, "name": "getChanged", "params": [], "body": "                                               {\n    return this.changed;\n  }", "signature": "public Map<String, ChangedPath> getChanged()"}, {"syntax_pass": true, "original_string": "  public void setIncreased(final Map<String, PathItem> increased) {\n    this.increased = increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "Map<String, PathItem>"}], "body": "                                                                  {\n    this.increased = increased;\n  }", "signature": "public void setIncreased(final Map<String, PathItem> increased)"}, {"syntax_pass": true, "original_string": "  public void setMissing(final Map<String, PathItem> missing) {\n    this.missing = missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "Map<String, PathItem>"}], "body": "                                                              {\n    this.missing = missing;\n  }", "signature": "public void setMissing(final Map<String, PathItem> missing)"}, {"syntax_pass": true, "original_string": "  public void setChanged(final Map<String, ChangedPath> changed) {\n    this.changed = changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "Map<String, ChangedPath>"}], "body": "                                                                 {\n    this.changed = changed;\n  }", "signature": "public void setChanged(final Map<String, ChangedPath> changed)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedPaths that = (ChangedPaths) o;\n    return Objects.equals(oldPathMap, that.oldPathMap)\n        && Objects.equals(newPathMap, that.newPathMap)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedPaths that = (ChangedPaths) o;\n    return Objects.equals(oldPathMap, that.oldPathMap)\n        && Objects.equals(newPathMap, that.newPathMap)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(oldPathMap, newPathMap, increased, missing, changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(oldPathMap, newPathMap, increased, missing, changed);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedPaths(oldPathMap=\"\n        + this.getOldPathMap()\n        + \", newPathMap=\"\n        + this.getNewPathMap()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedPaths(oldPathMap=\"\n        + this.getOldPathMap()\n        + \", newPathMap=\"\n        + this.getNewPathMap()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedResponse.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedResponse implements ComposedChanged {\n  private final ApiResponse oldApiResponse;\n  private final ApiResponse newApiResponse;\n  private final DiffContext context;\n  private ChangedMetadata description;\n  private ChangedHeaders headers;\n  private ChangedContent content;\n  private ChangedExtensions extensions;\n\n  public ChangedResponse(\n      ApiResponse oldApiResponse, ApiResponse newApiResponse, DiffContext context) {\n    this.oldApiResponse = oldApiResponse;\n    this.newApiResponse = newApiResponse;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, headers, content, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    return DiffResult.NO_CHANGES;\n  }\n\n  public ApiResponse getOldApiResponse() {\n    return this.oldApiResponse;\n  }\n\n  public ApiResponse getNewApiResponse() {\n    return this.newApiResponse;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedHeaders getHeaders() {\n    return this.headers;\n  }\n\n  public ChangedContent getContent() {\n    return this.content;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedResponse setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedResponse setHeaders(final ChangedHeaders headers) {\n    this.headers = headers;\n    return this;\n  }\n\n  public ChangedResponse setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }\n\n  public ChangedResponse setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedResponse that = (ChangedResponse) o;\n    return Objects.equals(oldApiResponse, that.oldApiResponse)\n        && Objects.equals(newApiResponse, that.newApiResponse)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(headers, that.headers)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldApiResponse, newApiResponse, context, description, headers, content, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedResponse(oldApiResponse=\"\n        + this.getOldApiResponse()\n        + \", newApiResponse=\"\n        + this.getNewApiResponse()\n        + \", context=\"\n        + this.getContext()\n        + \", description=\"\n        + this.getDescription()\n        + \", headers=\"\n        + this.getHeaders()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "5791a802a1b7595b62072aad8a19f167082716b6827563e46d677fecf9226573", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedResponse implements ComposedChanged {\n  private final ApiResponse oldApiResponse;\n  private final ApiResponse newApiResponse;\n  private final DiffContext context;\n  private ChangedMetadata description;\n  private ChangedHeaders headers;\n  private ChangedContent content;\n  private ChangedExtensions extensions;\n\n  public ChangedResponse(\n      ApiResponse oldApiResponse, ApiResponse newApiResponse, DiffContext context) {\n    this.oldApiResponse = oldApiResponse;\n    this.newApiResponse = newApiResponse;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, headers, content, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    return DiffResult.NO_CHANGES;\n  }\n\n  public ApiResponse getOldApiResponse() {\n    return this.oldApiResponse;\n  }\n\n  public ApiResponse getNewApiResponse() {\n    return this.newApiResponse;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedHeaders getHeaders() {\n    return this.headers;\n  }\n\n  public ChangedContent getContent() {\n    return this.content;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedResponse setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedResponse setHeaders(final ChangedHeaders headers) {\n    this.headers = headers;\n    return this;\n  }\n\n  public ChangedResponse setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }\n\n  public ChangedResponse setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedResponse that = (ChangedResponse) o;\n    return Objects.equals(oldApiResponse, that.oldApiResponse)\n        && Objects.equals(newApiResponse, that.newApiResponse)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(headers, that.headers)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldApiResponse, newApiResponse, context, description, headers, content, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedResponse(oldApiResponse=\"\n        + this.getOldApiResponse()\n        + \", newApiResponse=\"\n        + this.getNewApiResponse()\n        + \", context=\"\n        + this.getContext()\n        + \", description=\"\n        + this.getDescription()\n        + \", headers=\"\n        + this.getHeaders()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedResponse implements ComposedChanged", "class_docstring": "", "name": "ChangedResponse", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final ApiResponse oldApiResponse;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ApiResponse", "name": "oldApiResponse", "syntax_pass": true}, {"attribute_expression": "private final ApiResponse newApiResponse;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ApiResponse", "name": "newApiResponse", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private ChangedMetadata description;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedMetadata", "name": "description", "syntax_pass": true}, {"attribute_expression": "private ChangedHeaders headers;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedHeaders", "name": "headers", "syntax_pass": true}, {"attribute_expression": "private ChangedContent content;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedContent", "name": "content", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedResponse(\n      ApiResponse oldApiResponse, ApiResponse newApiResponse, DiffContext context) {\n    this.oldApiResponse = oldApiResponse;\n    this.newApiResponse = newApiResponse;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedResponse", "params": [{"name": "oldApiResponse", "type": "ApiResponse"}, {"name": "newApiResponse", "type": "ApiResponse"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                   {\n    this.oldApiResponse = oldApiResponse;\n    this.newApiResponse = newApiResponse;\n    this.context = context;\n  }", "signature": "public ChangedResponse(\n      ApiResponse oldApiResponse, ApiResponse newApiResponse, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, headers, content, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Arrays.asList(description, headers, content, extensions);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    return DiffResult.NO_CHANGES;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    return DiffResult.NO_CHANGES;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public ApiResponse getOldApiResponse() {\n    return this.oldApiResponse;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ApiResponse", "classes": []}, "name": "getOldApiResponse", "params": [], "body": "                                         {\n    return this.oldApiResponse;\n  }", "signature": "public ApiResponse getOldApiResponse()"}, {"syntax_pass": true, "original_string": "  public ApiResponse getNewApiResponse() {\n    return this.newApiResponse;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ApiResponse", "classes": []}, "name": "getNewApiResponse", "params": [], "body": "                                         {\n    return this.newApiResponse;\n  }", "signature": "public ApiResponse getNewApiResponse()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata getDescription() {\n    return this.description;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "getDescription", "params": [], "body": "                                          {\n    return this.description;\n  }", "signature": "public ChangedMetadata getDescription()"}, {"syntax_pass": true, "original_string": "  public ChangedHeaders getHeaders() {\n    return this.headers;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeaders", "classes": []}, "name": "getHeaders", "params": [], "body": "                                     {\n    return this.headers;\n  }", "signature": "public ChangedHeaders getHeaders()"}, {"syntax_pass": true, "original_string": "  public ChangedContent getContent() {\n    return this.content;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedContent", "classes": []}, "name": "getContent", "params": [], "body": "                                     {\n    return this.content;\n  }", "signature": "public ChangedContent getContent()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedResponse setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedResponse", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "ChangedMetadata"}], "body": "                                                                           {\n    this.description = description;\n    return this;\n  }", "signature": "public ChangedResponse setDescription(final ChangedMetadata description)"}, {"syntax_pass": true, "original_string": "  public ChangedResponse setHeaders(final ChangedHeaders headers) {\n    this.headers = headers;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedResponse", "classes": []}, "name": "setHeaders", "params": [{"name": "headers", "type": "ChangedHeaders"}], "body": "                                                                  {\n    this.headers = headers;\n    return this;\n  }", "signature": "public ChangedResponse setHeaders(final ChangedHeaders headers)"}, {"syntax_pass": true, "original_string": "  public ChangedResponse setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedResponse", "classes": []}, "name": "setContent", "params": [{"name": "content", "type": "ChangedContent"}], "body": "                                                                  {\n    this.content = content;\n    return this;\n  }", "signature": "public ChangedResponse setContent(final ChangedContent content)"}, {"syntax_pass": true, "original_string": "  public ChangedResponse setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedResponse", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                           {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedResponse setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedResponse that = (ChangedResponse) o;\n    return Objects.equals(oldApiResponse, that.oldApiResponse)\n        && Objects.equals(newApiResponse, that.newApiResponse)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(headers, that.headers)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedResponse that = (ChangedResponse) o;\n    return Objects.equals(oldApiResponse, that.oldApiResponse)\n        && Objects.equals(newApiResponse, that.newApiResponse)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(headers, that.headers)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldApiResponse, newApiResponse, context, description, headers, content, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldApiResponse, newApiResponse, context, description, headers, content, extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedResponse(oldApiResponse=\"\n        + this.getOldApiResponse()\n        + \", newApiResponse=\"\n        + this.getNewApiResponse()\n        + \", context=\"\n        + this.getContext()\n        + \", description=\"\n        + this.getDescription()\n        + \", headers=\"\n        + this.getHeaders()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedResponse(oldApiResponse=\"\n        + this.getOldApiResponse()\n        + \", newApiResponse=\"\n        + this.getNewApiResponse()\n        + \", context=\"\n        + this.getContext()\n        + \", description=\"\n        + this.getDescription()\n        + \", headers=\"\n        + this.getHeaders()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/Endpoint.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport io.swagger.v3.oas.models.Operation;\nimport io.swagger.v3.oas.models.PathItem;\nimport java.util.Objects;\n\npublic class Endpoint {\n  private String pathUrl;\n  private PathItem.HttpMethod method;\n  private String summary;\n  private PathItem path;\n  private Operation operation;\n\n  @Override\n  public String toString() {\n    return method + \" \" + pathUrl;\n  }\n\n  public String getPathUrl() {\n    return this.pathUrl;\n  }\n\n  public PathItem.HttpMethod getMethod() {\n    return this.method;\n  }\n\n  public String getSummary() {\n    return this.summary;\n  }\n\n  public PathItem getPath() {\n    return this.path;\n  }\n\n  public Operation getOperation() {\n    return this.operation;\n  }\n\n  public void setPathUrl(final String pathUrl) {\n    this.pathUrl = pathUrl;\n  }\n\n  public void setMethod(final PathItem.HttpMethod method) {\n    this.method = method;\n  }\n\n  public void setSummary(final String summary) {\n    this.summary = summary;\n  }\n\n  public void setPath(final PathItem path) {\n    this.path = path;\n  }\n\n  public void setOperation(final Operation operation) {\n    this.operation = operation;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Endpoint endpoint = (Endpoint) o;\n    return Objects.equals(pathUrl, endpoint.pathUrl)\n        && method == endpoint.method\n        && Objects.equals(summary, endpoint.summary)\n        && Objects.equals(path, endpoint.path)\n        && Objects.equals(operation, endpoint.operation);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(pathUrl, method, summary, path, operation);\n  }\n}\n", "file_hash": "da1e6f0472285b8b01195017f81f27023b06c8adb31a7b64f3242e429dd4b584", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import io.swagger.v3.oas.models.Operation;", "import io.swagger.v3.oas.models.PathItem;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class Endpoint {\n  private String pathUrl;\n  private PathItem.HttpMethod method;\n  private String summary;\n  private PathItem path;\n  private Operation operation;\n\n  @Override\n  public String toString() {\n    return method + \" \" + pathUrl;\n  }\n\n  public String getPathUrl() {\n    return this.pathUrl;\n  }\n\n  public PathItem.HttpMethod getMethod() {\n    return this.method;\n  }\n\n  public String getSummary() {\n    return this.summary;\n  }\n\n  public PathItem getPath() {\n    return this.path;\n  }\n\n  public Operation getOperation() {\n    return this.operation;\n  }\n\n  public void setPathUrl(final String pathUrl) {\n    this.pathUrl = pathUrl;\n  }\n\n  public void setMethod(final PathItem.HttpMethod method) {\n    this.method = method;\n  }\n\n  public void setSummary(final String summary) {\n    this.summary = summary;\n  }\n\n  public void setPath(final PathItem path) {\n    this.path = path;\n  }\n\n  public void setOperation(final Operation operation) {\n    this.operation = operation;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Endpoint endpoint = (Endpoint) o;\n    return Objects.equals(pathUrl, endpoint.pathUrl)\n        && method == endpoint.method\n        && Objects.equals(summary, endpoint.summary)\n        && Objects.equals(path, endpoint.path)\n        && Objects.equals(operation, endpoint.operation);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(pathUrl, method, summary, path, operation);\n  }\n}", "definition": "public class Endpoint", "class_docstring": "", "name": "Endpoint", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private String pathUrl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "pathUrl", "syntax_pass": true}, {"attribute_expression": "private PathItem.HttpMethod method;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PathItem.HttpMethod", "name": "method", "syntax_pass": true}, {"attribute_expression": "private String summary;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "summary", "syntax_pass": true}, {"attribute_expression": "private PathItem path;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PathItem", "name": "path", "syntax_pass": true}, {"attribute_expression": "private Operation operation;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Operation", "name": "operation", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n  public String toString() {\n    return method + \" \" + pathUrl;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                           {\n    return method + \" \" + pathUrl;\n  }", "signature": "@Override\n  public String toString()"}, {"syntax_pass": true, "original_string": "  public String getPathUrl() {\n    return this.pathUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getPathUrl", "params": [], "body": "                             {\n    return this.pathUrl;\n  }", "signature": "public String getPathUrl()"}, {"syntax_pass": true, "original_string": "  public PathItem.HttpMethod getMethod() {\n    return this.method;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PathItem.HttpMethod", "classes": []}, "name": "getMethod", "params": [], "body": "                                         {\n    return this.method;\n  }", "signature": "public PathItem.HttpMethod getMethod()"}, {"syntax_pass": true, "original_string": "  public String getSummary() {\n    return this.summary;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSummary", "params": [], "body": "                             {\n    return this.summary;\n  }", "signature": "public String getSummary()"}, {"syntax_pass": true, "original_string": "  public PathItem getPath() {\n    return this.path;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PathItem", "classes": []}, "name": "getPath", "params": [], "body": "                            {\n    return this.path;\n  }", "signature": "public PathItem getPath()"}, {"syntax_pass": true, "original_string": "  public Operation getOperation() {\n    return this.operation;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Operation", "classes": []}, "name": "getOperation", "params": [], "body": "                                  {\n    return this.operation;\n  }", "signature": "public Operation getOperation()"}, {"syntax_pass": true, "original_string": "  public void setPathUrl(final String pathUrl) {\n    this.pathUrl = pathUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setPathUrl", "params": [{"name": "pathUrl", "type": "String"}], "body": "                                               {\n    this.pathUrl = pathUrl;\n  }", "signature": "public void setPathUrl(final String pathUrl)"}, {"syntax_pass": true, "original_string": "  public void setMethod(final PathItem.HttpMethod method) {\n    this.method = method;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setMethod", "params": [{"name": "method", "type": "PathItem.HttpMethod"}], "body": "                                                          {\n    this.method = method;\n  }", "signature": "public void setMethod(final PathItem.HttpMethod method)"}, {"syntax_pass": true, "original_string": "  public void setSummary(final String summary) {\n    this.summary = summary;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setSummary", "params": [{"name": "summary", "type": "String"}], "body": "                                               {\n    this.summary = summary;\n  }", "signature": "public void setSummary(final String summary)"}, {"syntax_pass": true, "original_string": "  public void setPath(final PathItem path) {\n    this.path = path;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setPath", "params": [{"name": "path", "type": "PathItem"}], "body": "                                           {\n    this.path = path;\n  }", "signature": "public void setPath(final PathItem path)"}, {"syntax_pass": true, "original_string": "  public void setOperation(final Operation operation) {\n    this.operation = operation;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOperation", "params": [{"name": "operation", "type": "Operation"}], "body": "                                                      {\n    this.operation = operation;\n  }", "signature": "public void setOperation(final Operation operation)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Endpoint endpoint = (Endpoint) o;\n    return Objects.equals(pathUrl, endpoint.pathUrl)\n        && method == endpoint.method\n        && Objects.equals(summary, endpoint.summary)\n        && Objects.equals(path, endpoint.path)\n        && Objects.equals(operation, endpoint.operation);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Endpoint endpoint = (Endpoint) o;\n    return Objects.equals(pathUrl, endpoint.pathUrl)\n        && method == endpoint.method\n        && Objects.equals(summary, endpoint.summary)\n        && Objects.equals(path, endpoint.path)\n        && Objects.equals(operation, endpoint.operation);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(pathUrl, method, summary, path, operation);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(pathUrl, method, summary, path, operation);\n  }", "signature": "@Override\n  public int hashCode()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedExtensions.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.EXTENSION_CONTENT_TYPES_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.EXTENSION_CONTENT_TYPE_DELETED;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class ChangedExtensions implements ComposedChanged {\n  private final Map<String, Object> oldExtensions;\n  private final Map<String, Object> newExtensions;\n  private final DiffContext context;\n  private Map<String, Changed> increased;\n  private Map<String, Changed> missing;\n  private Map<String, Changed> changed;\n\n  public ChangedExtensions(\n      Map<String, Object> oldExtensions, Map<String, Object> newExtensions, DiffContext context) {\n    this.oldExtensions = oldExtensions;\n    this.newExtensions = newExtensions;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.of(increased, missing, changed)\n        .map(Map::values)\n        .flatMap(Collection::stream)\n        .collect(Collectors.toList());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (EXTENSION_CONTENT_TYPES_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      for (String key : missing.keySet()) {\n        if (EXTENSION_CONTENT_TYPE_DELETED.enabled(context, key)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Map<String, Object> getOldExtensions() {\n    return this.oldExtensions;\n  }\n\n  public Map<String, Object> getNewExtensions() {\n    return this.newExtensions;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, Changed> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, Changed> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, Changed> getChanged() {\n    return this.changed;\n  }\n\n  public void setIncreased(final Map<String, Changed> increased) {\n    this.increased = increased;\n  }\n\n  public void setMissing(final Map<String, Changed> missing) {\n    this.missing = missing;\n  }\n\n  public void setChanged(final Map<String, Changed> changed) {\n    this.changed = changed;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedExtensions that = (ChangedExtensions) o;\n    return Objects.equals(oldExtensions, that.oldExtensions)\n        && Objects.equals(newExtensions, that.newExtensions)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldExtensions, newExtensions, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedExtensions(oldExtensions=\"\n        + this.getOldExtensions()\n        + \", newExtensions=\"\n        + this.getNewExtensions()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}\n", "file_hash": "c708c4a974d86682047f27efe049d153aba382a5d8cb3c5d2e71b011a4c9cac6", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.EXTENSION_CONTENT_TYPES_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.EXTENSION_CONTENT_TYPE_DELETED;", "import java.util.*;", "import java.util.stream.Collectors;", "import java.util.stream.Stream;"], "methods": [], "classes": [{"original_string": "public class ChangedExtensions implements ComposedChanged {\n  private final Map<String, Object> oldExtensions;\n  private final Map<String, Object> newExtensions;\n  private final DiffContext context;\n  private Map<String, Changed> increased;\n  private Map<String, Changed> missing;\n  private Map<String, Changed> changed;\n\n  public ChangedExtensions(\n      Map<String, Object> oldExtensions, Map<String, Object> newExtensions, DiffContext context) {\n    this.oldExtensions = oldExtensions;\n    this.newExtensions = newExtensions;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.of(increased, missing, changed)\n        .map(Map::values)\n        .flatMap(Collection::stream)\n        .collect(Collectors.toList());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (EXTENSION_CONTENT_TYPES_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      for (String key : missing.keySet()) {\n        if (EXTENSION_CONTENT_TYPE_DELETED.enabled(context, key)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Map<String, Object> getOldExtensions() {\n    return this.oldExtensions;\n  }\n\n  public Map<String, Object> getNewExtensions() {\n    return this.newExtensions;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, Changed> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, Changed> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, Changed> getChanged() {\n    return this.changed;\n  }\n\n  public void setIncreased(final Map<String, Changed> increased) {\n    this.increased = increased;\n  }\n\n  public void setMissing(final Map<String, Changed> missing) {\n    this.missing = missing;\n  }\n\n  public void setChanged(final Map<String, Changed> changed) {\n    this.changed = changed;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedExtensions that = (ChangedExtensions) o;\n    return Objects.equals(oldExtensions, that.oldExtensions)\n        && Objects.equals(newExtensions, that.newExtensions)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldExtensions, newExtensions, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedExtensions(oldExtensions=\"\n        + this.getOldExtensions()\n        + \", newExtensions=\"\n        + this.getNewExtensions()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}", "definition": "public class ChangedExtensions implements ComposedChanged", "class_docstring": "", "name": "ChangedExtensions", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Map<String, Object> oldExtensions;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Object>", "name": "oldExtensions", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Object> newExtensions;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Object>", "name": "newExtensions", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private Map<String, Changed> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, Changed>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private Map<String, Changed> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, Changed>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private Map<String, Changed> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, Changed>", "name": "changed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedExtensions(\n      Map<String, Object> oldExtensions, Map<String, Object> newExtensions, DiffContext context) {\n    this.oldExtensions = oldExtensions;\n    this.newExtensions = newExtensions;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedExtensions", "params": [{"name": "oldExtensions", "type": "Map<String, Object>"}, {"name": "newExtensions", "type": "Map<String, Object>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                                 {\n    this.oldExtensions = oldExtensions;\n    this.newExtensions = newExtensions;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }", "signature": "public ChangedExtensions(\n      Map<String, Object> oldExtensions, Map<String, Object> newExtensions, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.of(increased, missing, changed)\n        .map(Map::values)\n        .flatMap(Collection::stream)\n        .collect(Collectors.toList());\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Stream.of(increased, missing, changed)\n        .map(Map::values)\n        .flatMap(Collection::stream)\n        .collect(Collectors.toList());\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (EXTENSION_CONTENT_TYPES_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      for (String key : missing.keySet()) {\n        if (EXTENSION_CONTENT_TYPE_DELETED.enabled(context, key)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (EXTENSION_CONTENT_TYPES_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      for (String key : missing.keySet()) {\n        if (EXTENSION_CONTENT_TYPE_DELETED.enabled(context, key)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public Map<String, Object> getOldExtensions() {\n    return this.oldExtensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "getOldExtensions", "params": [], "body": "                                                {\n    return this.oldExtensions;\n  }", "signature": "public Map<String, Object> getOldExtensions()"}, {"syntax_pass": true, "original_string": "  public Map<String, Object> getNewExtensions() {\n    return this.newExtensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "getNewExtensions", "params": [], "body": "                                                {\n    return this.newExtensions;\n  }", "signature": "public Map<String, Object> getNewExtensions()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public Map<String, Changed> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Changed>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                             {\n    return this.increased;\n  }", "signature": "public Map<String, Changed> getIncreased()"}, {"syntax_pass": true, "original_string": "  public Map<String, Changed> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Changed>", "classes": []}, "name": "getMissing", "params": [], "body": "                                           {\n    return this.missing;\n  }", "signature": "public Map<String, Changed> getMissing()"}, {"syntax_pass": true, "original_string": "  public Map<String, Changed> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Changed>", "classes": []}, "name": "getChanged", "params": [], "body": "                                           {\n    return this.changed;\n  }", "signature": "public Map<String, Changed> getChanged()"}, {"syntax_pass": true, "original_string": "  public void setIncreased(final Map<String, Changed> increased) {\n    this.increased = increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "Map<String, Changed>"}], "body": "                                                                 {\n    this.increased = increased;\n  }", "signature": "public void setIncreased(final Map<String, Changed> increased)"}, {"syntax_pass": true, "original_string": "  public void setMissing(final Map<String, Changed> missing) {\n    this.missing = missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "Map<String, Changed>"}], "body": "                                                             {\n    this.missing = missing;\n  }", "signature": "public void setMissing(final Map<String, Changed> missing)"}, {"syntax_pass": true, "original_string": "  public void setChanged(final Map<String, Changed> changed) {\n    this.changed = changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "Map<String, Changed>"}], "body": "                                                             {\n    this.changed = changed;\n  }", "signature": "public void setChanged(final Map<String, Changed> changed)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedExtensions that = (ChangedExtensions) o;\n    return Objects.equals(oldExtensions, that.oldExtensions)\n        && Objects.equals(newExtensions, that.newExtensions)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedExtensions that = (ChangedExtensions) o;\n    return Objects.equals(oldExtensions, that.oldExtensions)\n        && Objects.equals(newExtensions, that.newExtensions)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(oldExtensions, newExtensions, context, increased, missing, changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(oldExtensions, newExtensions, context, increased, missing, changed);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedExtensions(oldExtensions=\"\n        + this.getOldExtensions()\n        + \", newExtensions=\"\n        + this.getNewExtensions()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedExtensions(oldExtensions=\"\n        + this.getOldExtensions()\n        + \", newExtensions=\"\n        + this.getNewExtensions()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/DiffContext.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport io.swagger.v3.oas.models.PathItem;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.configuration2.Configuration;\nimport org.apache.commons.lang3.builder.EqualsBuilder;\nimport org.apache.commons.lang3.builder.HashCodeBuilder;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;\n\npublic class DiffContext {\n\n  @JsonIgnore private final OpenApiDiffOptions options;\n  private String url;\n  private Map<String, String> parameters;\n  private PathItem.HttpMethod method;\n  private boolean response;\n  private boolean request;\n  private Boolean required;\n  private String leftUrl;\n  private String rightUrl;\n\n  public DiffContext(OpenApiDiffOptions options) {\n    this.options = options;\n    parameters = new HashMap<>();\n    response = false;\n    request = true;\n  }\n\n  public DiffContext copyWithMethod(PathItem.HttpMethod method) {\n    return copy().setMethod(method);\n  }\n\n  public DiffContext copyWithRequired(boolean required) {\n    return copy().setRequired(required);\n  }\n\n  public DiffContext copyAsRequest() {\n    return copy().setRequest();\n  }\n\n  public DiffContext copyAsResponse() {\n    return copy().setResponse();\n  }\n\n  public DiffContext copyWithLeftRightUrls(String leftUrl, String rightUrl) {\n    return copy().setLeftAndRightUrls(leftUrl, rightUrl);\n  }\n\n  @JsonIgnore\n  public OpenApiDiffOptions getOptions() {\n    return options;\n  }\n\n  @JsonIgnore\n  public Configuration getConfig() {\n    return options.getConfig();\n  }\n\n  private DiffContext setRequest() {\n    this.request = true;\n    this.response = false;\n    return this;\n  }\n\n  private DiffContext setResponse() {\n    this.response = true;\n    this.request = false;\n    return this;\n  }\n\n  public boolean isResponse() {\n    return this.response;\n  }\n\n  public boolean isRequest() {\n    return this.request;\n  }\n\n  public String getUrl() {\n    return url;\n  }\n\n  public DiffContext setUrl(String url) {\n    this.url = url;\n    return this;\n  }\n\n  public PathItem.HttpMethod getMethod() {\n    return method;\n  }\n\n  private DiffContext setMethod(PathItem.HttpMethod method) {\n    this.method = method;\n    return this;\n  }\n\n  private DiffContext copy() {\n    DiffContext context = new DiffContext(options);\n    context.url = this.url;\n    context.parameters = this.parameters;\n    context.method = this.method;\n    context.response = this.response;\n    context.request = this.request;\n    context.required = this.required;\n    return context;\n  }\n\n  public Map<String, String> getParameters() {\n    return parameters;\n  }\n\n  public DiffContext setParameters(Map<String, String> parameters) {\n    this.parameters = parameters;\n    return this;\n  }\n\n  public Boolean isRequired() {\n    return required;\n  }\n\n  private DiffContext setRequired(boolean required) {\n    this.required = required;\n    return this;\n  }\n\n  public DiffContext setLeftAndRightUrls(String leftUrl, String rightUrl) {\n    this.leftUrl = leftUrl;\n    this.rightUrl = rightUrl;\n    return this;\n  }\n\n  public String getLeftUrl() {\n    return this.leftUrl;\n  }\n\n  public String getRightUrl() {\n    return this.rightUrl;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n    DiffContext that = (DiffContext) o;\n\n    return new EqualsBuilder()\n        .append(response, that.response)\n        .append(request, that.request)\n        .append(url, that.url)\n        .append(parameters, that.parameters)\n        .append(method, that.method)\n        .append(required, that.required)\n        .isEquals();\n  }\n\n  @Override\n  public int hashCode() {\n    return new HashCodeBuilder(17, 37)\n        .append(url)\n        .append(parameters)\n        .append(method)\n        .append(response)\n        .append(request)\n        .append(required)\n        .append(leftUrl)\n        .append(rightUrl)\n        .toHashCode();\n  }\n}\n", "file_hash": "7b975c4ba6a240a16fb6378354e809fdcadd3e4b3e5a0798caf7ad0d1011bcfa", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import com.fasterxml.jackson.annotation.JsonIgnore;", "import io.swagger.v3.oas.models.PathItem;", "import java.util.HashMap;", "import java.util.Map;", "import org.apache.commons.configuration2.Configuration;", "import org.apache.commons.lang3.builder.EqualsBuilder;", "import org.apache.commons.lang3.builder.HashCodeBuilder;", "import org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;"], "methods": [], "classes": [{"original_string": "public class DiffContext {\n\n  @JsonIgnore private final OpenApiDiffOptions options;\n  private String url;\n  private Map<String, String> parameters;\n  private PathItem.HttpMethod method;\n  private boolean response;\n  private boolean request;\n  private Boolean required;\n  private String leftUrl;\n  private String rightUrl;\n\n  public DiffContext(OpenApiDiffOptions options) {\n    this.options = options;\n    parameters = new HashMap<>();\n    response = false;\n    request = true;\n  }\n\n  public DiffContext copyWithMethod(PathItem.HttpMethod method) {\n    return copy().setMethod(method);\n  }\n\n  public DiffContext copyWithRequired(boolean required) {\n    return copy().setRequired(required);\n  }\n\n  public DiffContext copyAsRequest() {\n    return copy().setRequest();\n  }\n\n  public DiffContext copyAsResponse() {\n    return copy().setResponse();\n  }\n\n  public DiffContext copyWithLeftRightUrls(String leftUrl, String rightUrl) {\n    return copy().setLeftAndRightUrls(leftUrl, rightUrl);\n  }\n\n  @JsonIgnore\n  public OpenApiDiffOptions getOptions() {\n    return options;\n  }\n\n  @JsonIgnore\n  public Configuration getConfig() {\n    return options.getConfig();\n  }\n\n  private DiffContext setRequest() {\n    this.request = true;\n    this.response = false;\n    return this;\n  }\n\n  private DiffContext setResponse() {\n    this.response = true;\n    this.request = false;\n    return this;\n  }\n\n  public boolean isResponse() {\n    return this.response;\n  }\n\n  public boolean isRequest() {\n    return this.request;\n  }\n\n  public String getUrl() {\n    return url;\n  }\n\n  public DiffContext setUrl(String url) {\n    this.url = url;\n    return this;\n  }\n\n  public PathItem.HttpMethod getMethod() {\n    return method;\n  }\n\n  private DiffContext setMethod(PathItem.HttpMethod method) {\n    this.method = method;\n    return this;\n  }\n\n  private DiffContext copy() {\n    DiffContext context = new DiffContext(options);\n    context.url = this.url;\n    context.parameters = this.parameters;\n    context.method = this.method;\n    context.response = this.response;\n    context.request = this.request;\n    context.required = this.required;\n    return context;\n  }\n\n  public Map<String, String> getParameters() {\n    return parameters;\n  }\n\n  public DiffContext setParameters(Map<String, String> parameters) {\n    this.parameters = parameters;\n    return this;\n  }\n\n  public Boolean isRequired() {\n    return required;\n  }\n\n  private DiffContext setRequired(boolean required) {\n    this.required = required;\n    return this;\n  }\n\n  public DiffContext setLeftAndRightUrls(String leftUrl, String rightUrl) {\n    this.leftUrl = leftUrl;\n    this.rightUrl = rightUrl;\n    return this;\n  }\n\n  public String getLeftUrl() {\n    return this.leftUrl;\n  }\n\n  public String getRightUrl() {\n    return this.rightUrl;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n    DiffContext that = (DiffContext) o;\n\n    return new EqualsBuilder()\n        .append(response, that.response)\n        .append(request, that.request)\n        .append(url, that.url)\n        .append(parameters, that.parameters)\n        .append(method, that.method)\n        .append(required, that.required)\n        .isEquals();\n  }\n\n  @Override\n  public int hashCode() {\n    return new HashCodeBuilder(17, 37)\n        .append(url)\n        .append(parameters)\n        .append(method)\n        .append(response)\n        .append(request)\n        .append(required)\n        .append(leftUrl)\n        .append(rightUrl)\n        .toHashCode();\n  }\n}", "definition": "public class DiffContext", "class_docstring": "", "name": "DiffContext", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "@JsonIgnore private final OpenApiDiffOptions options;", "docstring": "", "modifiers": "@JsonIgnore private final", "marker_annotations": ["@JsonIgnore"], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiffOptions", "name": "options", "syntax_pass": true}, {"attribute_expression": "private String url;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "url", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> parameters;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "parameters", "syntax_pass": true}, {"attribute_expression": "private PathItem.HttpMethod method;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PathItem.HttpMethod", "name": "method", "syntax_pass": true}, {"attribute_expression": "private boolean response;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "response", "syntax_pass": true}, {"attribute_expression": "private boolean request;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "request", "syntax_pass": true}, {"attribute_expression": "private Boolean required;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Boolean", "name": "required", "syntax_pass": true}, {"attribute_expression": "private String leftUrl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "leftUrl", "syntax_pass": true}, {"attribute_expression": "private String rightUrl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "rightUrl", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public DiffContext(OpenApiDiffOptions options) {\n    this.options = options;\n    parameters = new HashMap<>();\n    response = false;\n    request = true;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "DiffContext", "params": [{"name": "options", "type": "OpenApiDiffOptions"}], "body": "                                                 {\n    this.options = options;\n    parameters = new HashMap<>();\n    response = false;\n    request = true;\n  }", "signature": "public DiffContext(OpenApiDiffOptions options)"}, {"syntax_pass": true, "original_string": "  public DiffContext copyWithMethod(PathItem.HttpMethod method) {\n    return copy().setMethod(method);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "copyWithMethod", "params": [{"name": "method", "type": "PathItem.HttpMethod"}], "body": "                                                                {\n    return copy().setMethod(method);\n  }", "signature": "public DiffContext copyWithMethod(PathItem.HttpMethod method)"}, {"syntax_pass": true, "original_string": "  public DiffContext copyWithRequired(boolean required) {\n    return copy().setRequired(required);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "copyWithRequired", "params": [{"name": "required", "type": "boolean"}], "body": "                                                        {\n    return copy().setRequired(required);\n  }", "signature": "public DiffContext copyWithRequired(boolean required)"}, {"syntax_pass": true, "original_string": "  public DiffContext copyAsRequest() {\n    return copy().setRequest();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "copyAsRequest", "params": [], "body": "                                     {\n    return copy().setRequest();\n  }", "signature": "public DiffContext copyAsRequest()"}, {"syntax_pass": true, "original_string": "  public DiffContext copyAsResponse() {\n    return copy().setResponse();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "copyAsResponse", "params": [], "body": "                                      {\n    return copy().setResponse();\n  }", "signature": "public DiffContext copyAsResponse()"}, {"syntax_pass": true, "original_string": "  public DiffContext copyWithLeftRightUrls(String leftUrl, String rightUrl) {\n    return copy().setLeftAndRightUrls(leftUrl, rightUrl);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "copyWithLeftRightUrls", "params": [{"name": "leftUrl", "type": "String"}, {"name": "rightUrl", "type": "String"}], "body": "                                                                            {\n    return copy().setLeftAndRightUrls(leftUrl, rightUrl);\n  }", "signature": "public DiffContext copyWithLeftRightUrls(String leftUrl, String rightUrl)"}, {"syntax_pass": true, "original_string": "  @JsonIgnore\n  public OpenApiDiffOptions getOptions() {\n    return options;\n  }", "docstring": "", "attributes": {"modifiers": "@JsonIgnore\n  public", "marker_annotations": ["@JsonIgnore"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OpenApiDiffOptions", "classes": []}, "name": "getOptions", "params": [], "body": "                                         {\n    return options;\n  }", "signature": "@JsonIgnore\n  public OpenApiDiffOptions getOptions()"}, {"syntax_pass": true, "original_string": "  @JsonIgnore\n  public Configuration getConfig() {\n    return options.getConfig();\n  }", "docstring": "", "attributes": {"modifiers": "@JsonIgnore\n  public", "marker_annotations": ["@JsonIgnore"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Configuration", "classes": []}, "name": "getConfig", "params": [], "body": "                                   {\n    return options.getConfig();\n  }", "signature": "@JsonIgnore\n  public Configuration getConfig()"}, {"syntax_pass": true, "original_string": "  private DiffContext setRequest() {\n    this.request = true;\n    this.response = false;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "setRequest", "params": [], "body": "                                   {\n    this.request = true;\n    this.response = false;\n    return this;\n  }", "signature": "private DiffContext setRequest()"}, {"syntax_pass": true, "original_string": "  private DiffContext setResponse() {\n    this.response = true;\n    this.request = false;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "setResponse", "params": [], "body": "                                    {\n    this.response = true;\n    this.request = false;\n    return this;\n  }", "signature": "private DiffContext setResponse()"}, {"syntax_pass": true, "original_string": "  public boolean isResponse() {\n    return this.response;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isResponse", "params": [], "body": "                              {\n    return this.response;\n  }", "signature": "public boolean isResponse()"}, {"syntax_pass": true, "original_string": "  public boolean isRequest() {\n    return this.request;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRequest", "params": [], "body": "                             {\n    return this.request;\n  }", "signature": "public boolean isRequest()"}, {"syntax_pass": true, "original_string": "  public String getUrl() {\n    return url;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getUrl", "params": [], "body": "                         {\n    return url;\n  }", "signature": "public String getUrl()"}, {"syntax_pass": true, "original_string": "  public DiffContext setUrl(String url) {\n    this.url = url;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "setUrl", "params": [{"name": "url", "type": "String"}], "body": "                                        {\n    this.url = url;\n    return this;\n  }", "signature": "public DiffContext setUrl(String url)"}, {"syntax_pass": true, "original_string": "  public PathItem.HttpMethod getMethod() {\n    return method;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PathItem.HttpMethod", "classes": []}, "name": "getMethod", "params": [], "body": "                                         {\n    return method;\n  }", "signature": "public PathItem.HttpMethod getMethod()"}, {"syntax_pass": true, "original_string": "  private DiffContext setMethod(PathItem.HttpMethod method) {\n    this.method = method;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "setMethod", "params": [{"name": "method", "type": "PathItem.HttpMethod"}], "body": "                                                            {\n    this.method = method;\n    return this;\n  }", "signature": "private DiffContext setMethod(PathItem.HttpMethod method)"}, {"syntax_pass": true, "original_string": "  private DiffContext copy() {\n    DiffContext context = new DiffContext(options);\n    context.url = this.url;\n    context.parameters = this.parameters;\n    context.method = this.method;\n    context.response = this.response;\n    context.request = this.request;\n    context.required = this.required;\n    return context;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "copy", "params": [], "body": "                             {\n    DiffContext context = new DiffContext(options);\n    context.url = this.url;\n    context.parameters = this.parameters;\n    context.method = this.method;\n    context.response = this.response;\n    context.request = this.request;\n    context.required = this.required;\n    return context;\n  }", "signature": "private DiffContext copy()"}, {"syntax_pass": true, "original_string": "  public Map<String, String> getParameters() {\n    return parameters;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, String>", "classes": []}, "name": "getParameters", "params": [], "body": "                                             {\n    return parameters;\n  }", "signature": "public Map<String, String> getParameters()"}, {"syntax_pass": true, "original_string": "  public DiffContext setParameters(Map<String, String> parameters) {\n    this.parameters = parameters;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "setParameters", "params": [{"name": "parameters", "type": "Map<String, String>"}], "body": "                                                                   {\n    this.parameters = parameters;\n    return this;\n  }", "signature": "public DiffContext setParameters(Map<String, String> parameters)"}, {"syntax_pass": true, "original_string": "  public Boolean isRequired() {\n    return required;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Boolean", "classes": []}, "name": "isRequired", "params": [], "body": "                              {\n    return required;\n  }", "signature": "public Boolean isRequired()"}, {"syntax_pass": true, "original_string": "  private DiffContext setRequired(boolean required) {\n    this.required = required;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "setRequired", "params": [{"name": "required", "type": "boolean"}], "body": "                                                    {\n    this.required = required;\n    return this;\n  }", "signature": "private DiffContext setRequired(boolean required)"}, {"syntax_pass": true, "original_string": "  public DiffContext setLeftAndRightUrls(String leftUrl, String rightUrl) {\n    this.leftUrl = leftUrl;\n    this.rightUrl = rightUrl;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "setLeftAndRightUrls", "params": [{"name": "leftUrl", "type": "String"}, {"name": "rightUrl", "type": "String"}], "body": "                                                                          {\n    this.leftUrl = leftUrl;\n    this.rightUrl = rightUrl;\n    return this;\n  }", "signature": "public DiffContext setLeftAndRightUrls(String leftUrl, String rightUrl)"}, {"syntax_pass": true, "original_string": "  public String getLeftUrl() {\n    return this.leftUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getLeftUrl", "params": [], "body": "                             {\n    return this.leftUrl;\n  }", "signature": "public String getLeftUrl()"}, {"syntax_pass": true, "original_string": "  public String getRightUrl() {\n    return this.rightUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getRightUrl", "params": [], "body": "                              {\n    return this.rightUrl;\n  }", "signature": "public String getRightUrl()"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n    DiffContext that = (DiffContext) o;\n\n    return new EqualsBuilder()\n        .append(response, that.response)\n        .append(request, that.request)\n        .append(url, that.url)\n        .append(parameters, that.parameters)\n        .append(method, that.method)\n        .append(required, that.required)\n        .isEquals();\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n\n    if (o == null || getClass() != o.getClass()) return false;\n\n    DiffContext that = (DiffContext) o;\n\n    return new EqualsBuilder()\n        .append(response, that.response)\n        .append(request, that.request)\n        .append(url, that.url)\n        .append(parameters, that.parameters)\n        .append(method, that.method)\n        .append(required, that.required)\n        .isEquals();\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return new HashCodeBuilder(17, 37)\n        .append(url)\n        .append(parameters)\n        .append(method)\n        .append(response)\n        .append(request)\n        .append(required)\n        .append(leftUrl)\n        .append(rightUrl)\n        .toHashCode();\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return new HashCodeBuilder(17, 37)\n        .append(url)\n        .append(parameters)\n        .append(method)\n        .append(response)\n        .append(request)\n        .append(required)\n        .append(leftUrl)\n        .append(rightUrl)\n        .toHashCode();\n  }", "signature": "@Override\n  public int hashCode()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedOAuthFlow.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED;\n\nimport io.swagger.v3.oas.models.security.OAuthFlow;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedOAuthFlow implements ComposedChanged {\n  private OAuthFlow oldOAuthFlow;\n  private OAuthFlow newOAuthFlow;\n  private final DiffContext context;\n  private boolean authorizationUrl;\n  private boolean tokenUrl;\n  private boolean refreshUrl;\n  private ChangedExtensions extensions;\n\n  public ChangedOAuthFlow(OAuthFlow oldOAuthFlow, OAuthFlow newOAuthFlow, DiffContext context) {\n    this.oldOAuthFlow = oldOAuthFlow;\n    this.newOAuthFlow = newOAuthFlow;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Collections.singletonList(extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!authorizationUrl && !tokenUrl && !refreshUrl) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (authorizationUrl) {\n      if (SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (refreshUrl) {\n      if (SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (tokenUrl) {\n      if (SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public OAuthFlow getOldOAuthFlow() {\n    return this.oldOAuthFlow;\n  }\n\n  public OAuthFlow getNewOAuthFlow() {\n    return this.newOAuthFlow;\n  }\n\n  public boolean isAuthorizationUrl() {\n    return this.authorizationUrl;\n  }\n\n  public boolean isTokenUrl() {\n    return this.tokenUrl;\n  }\n\n  public boolean isRefreshUrl() {\n    return this.refreshUrl;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedOAuthFlow setOldOAuthFlow(final OAuthFlow oldOAuthFlow) {\n    this.oldOAuthFlow = oldOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlow setNewOAuthFlow(final OAuthFlow newOAuthFlow) {\n    this.newOAuthFlow = newOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlow setAuthorizationUrl(final boolean authorizationUrl) {\n    this.authorizationUrl = authorizationUrl;\n    return this;\n  }\n\n  public ChangedOAuthFlow setTokenUrl(final boolean tokenUrl) {\n    this.tokenUrl = tokenUrl;\n    return this;\n  }\n\n  public ChangedOAuthFlow setRefreshUrl(final boolean refreshUrl) {\n    this.refreshUrl = refreshUrl;\n    return this;\n  }\n\n  public ChangedOAuthFlow setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOAuthFlow that = (ChangedOAuthFlow) o;\n    return authorizationUrl == that.authorizationUrl\n        && tokenUrl == that.tokenUrl\n        && refreshUrl == that.refreshUrl\n        && Objects.equals(oldOAuthFlow, that.oldOAuthFlow)\n        && Objects.equals(newOAuthFlow, that.newOAuthFlow)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldOAuthFlow, newOAuthFlow, authorizationUrl, tokenUrl, refreshUrl, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOAuthFlow(oldOAuthFlow=\"\n        + this.getOldOAuthFlow()\n        + \", newOAuthFlow=\"\n        + this.getNewOAuthFlow()\n        + \", authorizationUrl=\"\n        + this.isAuthorizationUrl()\n        + \", tokenUrl=\"\n        + this.isTokenUrl()\n        + \", refreshUrl=\"\n        + this.isRefreshUrl()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "8666d048a87d7115c579d7d599e3140fd995320fcf00e6878bf399305bdb6a84", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED;", "import io.swagger.v3.oas.models.security.OAuthFlow;", "import java.util.Collections;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedOAuthFlow implements ComposedChanged {\n  private OAuthFlow oldOAuthFlow;\n  private OAuthFlow newOAuthFlow;\n  private final DiffContext context;\n  private boolean authorizationUrl;\n  private boolean tokenUrl;\n  private boolean refreshUrl;\n  private ChangedExtensions extensions;\n\n  public ChangedOAuthFlow(OAuthFlow oldOAuthFlow, OAuthFlow newOAuthFlow, DiffContext context) {\n    this.oldOAuthFlow = oldOAuthFlow;\n    this.newOAuthFlow = newOAuthFlow;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Collections.singletonList(extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!authorizationUrl && !tokenUrl && !refreshUrl) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (authorizationUrl) {\n      if (SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (refreshUrl) {\n      if (SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (tokenUrl) {\n      if (SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public OAuthFlow getOldOAuthFlow() {\n    return this.oldOAuthFlow;\n  }\n\n  public OAuthFlow getNewOAuthFlow() {\n    return this.newOAuthFlow;\n  }\n\n  public boolean isAuthorizationUrl() {\n    return this.authorizationUrl;\n  }\n\n  public boolean isTokenUrl() {\n    return this.tokenUrl;\n  }\n\n  public boolean isRefreshUrl() {\n    return this.refreshUrl;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedOAuthFlow setOldOAuthFlow(final OAuthFlow oldOAuthFlow) {\n    this.oldOAuthFlow = oldOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlow setNewOAuthFlow(final OAuthFlow newOAuthFlow) {\n    this.newOAuthFlow = newOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlow setAuthorizationUrl(final boolean authorizationUrl) {\n    this.authorizationUrl = authorizationUrl;\n    return this;\n  }\n\n  public ChangedOAuthFlow setTokenUrl(final boolean tokenUrl) {\n    this.tokenUrl = tokenUrl;\n    return this;\n  }\n\n  public ChangedOAuthFlow setRefreshUrl(final boolean refreshUrl) {\n    this.refreshUrl = refreshUrl;\n    return this;\n  }\n\n  public ChangedOAuthFlow setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOAuthFlow that = (ChangedOAuthFlow) o;\n    return authorizationUrl == that.authorizationUrl\n        && tokenUrl == that.tokenUrl\n        && refreshUrl == that.refreshUrl\n        && Objects.equals(oldOAuthFlow, that.oldOAuthFlow)\n        && Objects.equals(newOAuthFlow, that.newOAuthFlow)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldOAuthFlow, newOAuthFlow, authorizationUrl, tokenUrl, refreshUrl, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOAuthFlow(oldOAuthFlow=\"\n        + this.getOldOAuthFlow()\n        + \", newOAuthFlow=\"\n        + this.getNewOAuthFlow()\n        + \", authorizationUrl=\"\n        + this.isAuthorizationUrl()\n        + \", tokenUrl=\"\n        + this.isTokenUrl()\n        + \", refreshUrl=\"\n        + this.isRefreshUrl()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedOAuthFlow implements ComposedChanged", "class_docstring": "", "name": "ChangedOAuthFlow", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private OAuthFlow oldOAuthFlow;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OAuthFlow", "name": "oldOAuthFlow", "syntax_pass": true}, {"attribute_expression": "private OAuthFlow newOAuthFlow;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OAuthFlow", "name": "newOAuthFlow", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private boolean authorizationUrl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "authorizationUrl", "syntax_pass": true}, {"attribute_expression": "private boolean tokenUrl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "tokenUrl", "syntax_pass": true}, {"attribute_expression": "private boolean refreshUrl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "refreshUrl", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedOAuthFlow(OAuthFlow oldOAuthFlow, OAuthFlow newOAuthFlow, DiffContext context) {\n    this.oldOAuthFlow = oldOAuthFlow;\n    this.newOAuthFlow = newOAuthFlow;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedOAuthFlow", "params": [{"name": "oldOAuthFlow", "type": "OAuthFlow"}, {"name": "newOAuthFlow", "type": "OAuthFlow"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                               {\n    this.oldOAuthFlow = oldOAuthFlow;\n    this.newOAuthFlow = newOAuthFlow;\n    this.context = context;\n  }", "signature": "public ChangedOAuthFlow(OAuthFlow oldOAuthFlow, OAuthFlow newOAuthFlow, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Collections.singletonList(extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Collections.singletonList(extensions);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (!authorizationUrl && !tokenUrl && !refreshUrl) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (authorizationUrl) {\n      if (SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (refreshUrl) {\n      if (SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (tokenUrl) {\n      if (SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (!authorizationUrl && !tokenUrl && !refreshUrl) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (authorizationUrl) {\n      if (SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (refreshUrl) {\n      if (SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (tokenUrl) {\n      if (SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public OAuthFlow getOldOAuthFlow() {\n    return this.oldOAuthFlow;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OAuthFlow", "classes": []}, "name": "getOldOAuthFlow", "params": [], "body": "                                     {\n    return this.oldOAuthFlow;\n  }", "signature": "public OAuthFlow getOldOAuthFlow()"}, {"syntax_pass": true, "original_string": "  public OAuthFlow getNewOAuthFlow() {\n    return this.newOAuthFlow;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OAuthFlow", "classes": []}, "name": "getNewOAuthFlow", "params": [], "body": "                                     {\n    return this.newOAuthFlow;\n  }", "signature": "public OAuthFlow getNewOAuthFlow()"}, {"syntax_pass": true, "original_string": "  public boolean isAuthorizationUrl() {\n    return this.authorizationUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAuthorizationUrl", "params": [], "body": "                                      {\n    return this.authorizationUrl;\n  }", "signature": "public boolean isAuthorizationUrl()"}, {"syntax_pass": true, "original_string": "  public boolean isTokenUrl() {\n    return this.tokenUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTokenUrl", "params": [], "body": "                              {\n    return this.tokenUrl;\n  }", "signature": "public boolean isTokenUrl()"}, {"syntax_pass": true, "original_string": "  public boolean isRefreshUrl() {\n    return this.refreshUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRefreshUrl", "params": [], "body": "                                {\n    return this.refreshUrl;\n  }", "signature": "public boolean isRefreshUrl()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow setOldOAuthFlow(final OAuthFlow oldOAuthFlow) {\n    this.oldOAuthFlow = oldOAuthFlow;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "setOldOAuthFlow", "params": [{"name": "oldOAuthFlow", "type": "OAuthFlow"}], "body": "                                                                        {\n    this.oldOAuthFlow = oldOAuthFlow;\n    return this;\n  }", "signature": "public ChangedOAuthFlow setOldOAuthFlow(final OAuthFlow oldOAuthFlow)"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow setNewOAuthFlow(final OAuthFlow newOAuthFlow) {\n    this.newOAuthFlow = newOAuthFlow;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "setNewOAuthFlow", "params": [{"name": "newOAuthFlow", "type": "OAuthFlow"}], "body": "                                                                        {\n    this.newOAuthFlow = newOAuthFlow;\n    return this;\n  }", "signature": "public ChangedOAuthFlow setNewOAuthFlow(final OAuthFlow newOAuthFlow)"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow setAuthorizationUrl(final boolean authorizationUrl) {\n    this.authorizationUrl = authorizationUrl;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "setAuthorizationUrl", "params": [{"name": "authorizationUrl", "type": "boolean"}], "body": "                                                                              {\n    this.authorizationUrl = authorizationUrl;\n    return this;\n  }", "signature": "public ChangedOAuthFlow setAuthorizationUrl(final boolean authorizationUrl)"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow setTokenUrl(final boolean tokenUrl) {\n    this.tokenUrl = tokenUrl;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "setTokenUrl", "params": [{"name": "tokenUrl", "type": "boolean"}], "body": "                                                              {\n    this.tokenUrl = tokenUrl;\n    return this;\n  }", "signature": "public ChangedOAuthFlow setTokenUrl(final boolean tokenUrl)"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow setRefreshUrl(final boolean refreshUrl) {\n    this.refreshUrl = refreshUrl;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "setRefreshUrl", "params": [{"name": "refreshUrl", "type": "boolean"}], "body": "                                                                  {\n    this.refreshUrl = refreshUrl;\n    return this;\n  }", "signature": "public ChangedOAuthFlow setRefreshUrl(final boolean refreshUrl)"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                            {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedOAuthFlow setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOAuthFlow that = (ChangedOAuthFlow) o;\n    return authorizationUrl == that.authorizationUrl\n        && tokenUrl == that.tokenUrl\n        && refreshUrl == that.refreshUrl\n        && Objects.equals(oldOAuthFlow, that.oldOAuthFlow)\n        && Objects.equals(newOAuthFlow, that.newOAuthFlow)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOAuthFlow that = (ChangedOAuthFlow) o;\n    return authorizationUrl == that.authorizationUrl\n        && tokenUrl == that.tokenUrl\n        && refreshUrl == that.refreshUrl\n        && Objects.equals(oldOAuthFlow, that.oldOAuthFlow)\n        && Objects.equals(newOAuthFlow, that.newOAuthFlow)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldOAuthFlow, newOAuthFlow, authorizationUrl, tokenUrl, refreshUrl, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldOAuthFlow, newOAuthFlow, authorizationUrl, tokenUrl, refreshUrl, extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOAuthFlow(oldOAuthFlow=\"\n        + this.getOldOAuthFlow()\n        + \", newOAuthFlow=\"\n        + this.getNewOAuthFlow()\n        + \", authorizationUrl=\"\n        + this.isAuthorizationUrl()\n        + \", tokenUrl=\"\n        + this.isTokenUrl()\n        + \", refreshUrl=\"\n        + this.isRefreshUrl()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedOAuthFlow(oldOAuthFlow=\"\n        + this.getOldOAuthFlow()\n        + \", newOAuthFlow=\"\n        + this.getNewOAuthFlow()\n        + \", authorizationUrl=\"\n        + this.isAuthorizationUrl()\n        + \", tokenUrl=\"\n        + this.isTokenUrl()\n        + \", refreshUrl=\"\n        + this.isRefreshUrl()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/BackwardIncompatibleProp.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.apache.commons.lang3.ArrayUtils.isEmpty;\n\nimport org.apache.commons.configuration2.Configuration;\n\n// Properties to enable/disable backward incompatibility checks\n// Note: order is not programmatically significant but keep alphabetical for maintainability\npublic enum BackwardIncompatibleProp {\n  EXTENSION_CONTENT_TYPES_DECREASED(\"incompatible.extension.content.types.decreased\", false),\n  EXTENSION_CONTENT_TYPE_DELETED(\"incompatible.extension.content.type.%s.deleted\", false),\n  OPENAPI_ENDPOINTS_DECREASED(\"incompatible.openapi.endpoints.decreased\", true),\n  REQUEST_BODY_REQUIRED_INCREASED(\"incompatible.request.body.increased\", true),\n  REQUEST_CONTENT_DECREASED(\"incompatible.request.content.decreased\", true),\n  REQUEST_ENUM_DECREASED(\"incompatible.request.enum.decreased\", true),\n  REQUEST_MAX_LENGTH_DECREASED(\"incompatible.request.max.length.decreased\", true),\n  REQUEST_NUMERIC_RANGE_DECREASED(\"incompatible.request.numeric.range.decreased\", true),\n  REQUEST_ONEOF_DECREASED(\"incompatible.request.oneof.decreased\", true),\n  REQUEST_PARAM_ALLOWEMPTY_DECREASED(\"incompatible.request.param.allowempty.decreased\", true),\n  REQUEST_PARAM_EXPLODE_CHANGED(\"incompatible.request.param.explode.changed\", true),\n  REQUEST_PARAM_STYLE_CHANGED(\"incompatible.request.param.style.changed\", true),\n  REQUEST_PARAMS_DECREASED(\"incompatible.request.params.decreased\", true),\n  REQUEST_PARAMS_REQUIRED_INCREASED(\"incompatible.request.params.required.increased\", true),\n  REQUEST_READONLY_INCREASED(\"incompatible.request.readonly.increased\", true),\n  REQUEST_READONLY_REQUIRED_DECREASED(\"incompatible.request.readonly.required.decreased\", true),\n  REQUEST_REQUIRED_INCREASED(\"incompatible.request.required.increased\", true),\n  RESPONSE_CONTENT_DECREASED(\"incompatible.response.content.decreased\", true),\n  RESPONSE_ENUM_INCREASED(\"incompatible.response.enum.increased\", true),\n  RESPONSE_HEADER_EXPLODE_CHANGED(\"incompatible.response.header.explode.changed\", true),\n  RESPONSE_HEADER_REQUIRED_DECREASED(\"incompatible.response.header.required.decreased\", true),\n  RESPONSE_HEADER_REQUIRED_INCREASED(\"incompatible.response.header.required.increased\", true),\n  RESPONSE_HEADERS_DECREASED(\"incompatible.response.headers.decreased\", true),\n  RESPONSE_MAX_LENGTH_INCREASED(\"incompatible.response.max.length.increased\", true),\n  RESPONSE_NUMERIC_RANGE_INCREASED(\"incompatible.response.numeric.range.increased\", false),\n  RESPONSE_ONEOF_INCREASED(\"incompatible.response.oneof.increased\", true),\n  RESPONSE_REQUIRED_DECREASED(\"incompatible.response.required.decreased\", true),\n  RESPONSE_RESPONSES_DECREASED(\"incompatible.response.responses.decreased\", true),\n  RESPONSE_WRITEONLY_INCREASED(\"incompatible.response.writeonly.increased\", true),\n  RESPONSE_WRITEONLY_REQUIRED_DECREASED(\"incompatible.response.writeonly.required.decreased\", true),\n  SECURITY_REQUIREMENT_SCHEMES_INCREASED(\n      \"incompatible.security.requirement.schemes.increased\", true),\n  SECURITY_REQUIREMENTS_DECREASED(\"incompatible.security.requirements.decreased\", true),\n  SECURITY_SCHEME_BEARER_FORMAT_CHANGED(\"incompatible.security.scheme.bearer.format.changed\", true),\n  SECURITY_SCHEME_OAUTH2_AUTH_URL_CHANGED(\n      \"incompatible.security.scheme.oauth2.auth.url.changed\", true),\n  SECURITY_SCHEME_OAUTH2_REFRESH_URL_CHANGED(\n      \"incompatible.security.scheme.oauth2.refresh.url.changed\", true),\n  SECURITY_SCHEME_OAUTH2_TOKEN_URL_CHANGED(\n      \"incompatible.security.scheme.oauth2.token.url.changed\", true),\n  SECURITY_SCHEME_OPENIDCONNECT_URL_CHANGED(\n      \"incompatible.security.scheme.openidconnect.url.changed\", true),\n  SECURITY_SCHEME_SCHEME_CHANGED(\"incompatible.security.scheme.scheme.changed\", true),\n  SECURITY_SCHEME_SCOPES_INCREASED(\"incompatible.security.scheme.scopes.increased\", true),\n  SCHEMA_DISCRIMINATOR_CHANGED(\"incompatible.schema.discriminator.changed\", true),\n  SCHEMA_TYPE_CHANGED(\"incompatible.schema.type.changed\", true),\n  ;\n\n  private final String propertyName;\n  private final boolean enabledByDefault;\n\n  BackwardIncompatibleProp(String propertyName, boolean enabledByDefault) {\n    this.propertyName = propertyName;\n    this.enabledByDefault = enabledByDefault;\n  }\n\n  public String getPropertyName() {\n    return propertyName;\n  }\n\n  public boolean isEnabledByDefault() {\n    return enabledByDefault;\n  }\n\n  public boolean enabled(DiffContext context, Object... formatArgs) {\n    return enabled(context.getConfig(), formatArgs);\n  }\n\n  public boolean enabled(Configuration cfg, Object... formatArgs) {\n    String propName = isEmpty(formatArgs) ? propertyName : String.format(propertyName, formatArgs);\n    return cfg.getBoolean(propName, enabledByDefault);\n  }\n}\n", "file_hash": "d5fee9126b8cd19b8819e2b9c153225c2772f8d1acdc00556b46054ccb72c5f5", "file_docstring": " Properties to enable/disable backward incompatibility checks", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.apache.commons.lang3.ArrayUtils.isEmpty;", "import org.apache.commons.configuration2.Configuration;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedOpenApi.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport io.swagger.v3.oas.models.OpenAPI;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;\nimport org.openapitools.openapidiff.core.utils.EndpointUtils;\n\npublic class ChangedOpenApi implements ComposedChanged {\n  private final OpenApiDiffOptions options;\n  @JsonIgnore private OpenAPI oldSpecOpenApi;\n  @JsonIgnore private OpenAPI newSpecOpenApi;\n  private List<Endpoint> newEndpoints;\n  private List<Endpoint> missingEndpoints;\n  private List<ChangedOperation> changedOperations;\n  private List<ChangedSchema> changedSchemas;\n  private ChangedExtensions changedExtensions;\n\n  public ChangedOpenApi(OpenApiDiffOptions options) {\n    this.options = options;\n  }\n\n  public List<Endpoint> getDeprecatedEndpoints() {\n    return changedOperations.stream()\n        .filter(ChangedOperation::isDeprecated)\n        .map(\n            c ->\n                EndpointUtils.convert2Endpoint(\n                    c.getPathUrl(), c.getHttpMethod(), c.getNewOperation()))\n        .collect(Collectors.toList());\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.concat(\n            Stream.concat(changedOperations.stream(), Stream.of(changedExtensions)),\n            changedSchemas.stream())\n        .collect(Collectors.toList());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (newEndpoints.isEmpty() && missingEndpoints.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missingEndpoints.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(options.getConfig())) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public OpenAPI getOldSpecOpenApi() {\n    return this.oldSpecOpenApi;\n  }\n\n  public OpenAPI getNewSpecOpenApi() {\n    return this.newSpecOpenApi;\n  }\n\n  public List<Endpoint> getNewEndpoints() {\n    return this.newEndpoints;\n  }\n\n  public List<Endpoint> getMissingEndpoints() {\n    return this.missingEndpoints;\n  }\n\n  public List<ChangedOperation> getChangedOperations() {\n    return this.changedOperations;\n  }\n\n  public ChangedExtensions getChangedExtensions() {\n    return this.changedExtensions;\n  }\n\n  public List<ChangedSchema> getChangedSchemas() {\n    return changedSchemas;\n  }\n\n  public ChangedOpenApi setOldSpecOpenApi(final OpenAPI oldSpecOpenApi) {\n    this.oldSpecOpenApi = oldSpecOpenApi;\n    return this;\n  }\n\n  public ChangedOpenApi setNewSpecOpenApi(final OpenAPI newSpecOpenApi) {\n    this.newSpecOpenApi = newSpecOpenApi;\n    return this;\n  }\n\n  public ChangedOpenApi setNewEndpoints(final List<Endpoint> newEndpoints) {\n    this.newEndpoints = newEndpoints;\n    return this;\n  }\n\n  public ChangedOpenApi setMissingEndpoints(final List<Endpoint> missingEndpoints) {\n    this.missingEndpoints = missingEndpoints;\n    return this;\n  }\n\n  public ChangedOpenApi setChangedOperations(final List<ChangedOperation> changedOperations) {\n    this.changedOperations = changedOperations;\n    return this;\n  }\n\n  public ChangedOpenApi setChangedExtensions(final ChangedExtensions changedExtensions) {\n    this.changedExtensions = changedExtensions;\n    return this;\n  }\n\n  public ChangedOpenApi setChangedSchemas(final List<ChangedSchema> changedSchemas) {\n    this.changedSchemas = changedSchemas;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOpenApi that = (ChangedOpenApi) o;\n    return Objects.equals(oldSpecOpenApi, that.oldSpecOpenApi)\n        && Objects.equals(newSpecOpenApi, that.newSpecOpenApi)\n        && Objects.equals(newEndpoints, that.newEndpoints)\n        && Objects.equals(missingEndpoints, that.missingEndpoints)\n        && Objects.equals(changedOperations, that.changedOperations)\n        && Objects.equals(changedExtensions, that.changedExtensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSpecOpenApi,\n        newSpecOpenApi,\n        newEndpoints,\n        missingEndpoints,\n        changedOperations,\n        changedExtensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOpenApi(oldSpecOpenApi=\"\n        + this.getOldSpecOpenApi()\n        + \", newSpecOpenApi=\"\n        + this.getNewSpecOpenApi()\n        + \", newEndpoints=\"\n        + this.getNewEndpoints()\n        + \", missingEndpoints=\"\n        + this.getMissingEndpoints()\n        + \", changedOperations=\"\n        + this.getChangedOperations()\n        + \", changedExtensions=\"\n        + this.getChangedExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "efa5b798452d10315810928fec894feba74d955c0a1ee8fb9b5c87b87b0c8c79", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;", "import com.fasterxml.jackson.annotation.JsonIgnore;", "import io.swagger.v3.oas.models.OpenAPI;", "import java.util.List;", "import java.util.Objects;", "import java.util.stream.Collectors;", "import java.util.stream.Stream;", "import org.openapitools.openapidiff.core.compare.OpenApiDiffOptions;", "import org.openapitools.openapidiff.core.utils.EndpointUtils;"], "methods": [], "classes": [{"original_string": "public class ChangedOpenApi implements ComposedChanged {\n  private final OpenApiDiffOptions options;\n  @JsonIgnore private OpenAPI oldSpecOpenApi;\n  @JsonIgnore private OpenAPI newSpecOpenApi;\n  private List<Endpoint> newEndpoints;\n  private List<Endpoint> missingEndpoints;\n  private List<ChangedOperation> changedOperations;\n  private List<ChangedSchema> changedSchemas;\n  private ChangedExtensions changedExtensions;\n\n  public ChangedOpenApi(OpenApiDiffOptions options) {\n    this.options = options;\n  }\n\n  public List<Endpoint> getDeprecatedEndpoints() {\n    return changedOperations.stream()\n        .filter(ChangedOperation::isDeprecated)\n        .map(\n            c ->\n                EndpointUtils.convert2Endpoint(\n                    c.getPathUrl(), c.getHttpMethod(), c.getNewOperation()))\n        .collect(Collectors.toList());\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.concat(\n            Stream.concat(changedOperations.stream(), Stream.of(changedExtensions)),\n            changedSchemas.stream())\n        .collect(Collectors.toList());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (newEndpoints.isEmpty() && missingEndpoints.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missingEndpoints.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(options.getConfig())) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public OpenAPI getOldSpecOpenApi() {\n    return this.oldSpecOpenApi;\n  }\n\n  public OpenAPI getNewSpecOpenApi() {\n    return this.newSpecOpenApi;\n  }\n\n  public List<Endpoint> getNewEndpoints() {\n    return this.newEndpoints;\n  }\n\n  public List<Endpoint> getMissingEndpoints() {\n    return this.missingEndpoints;\n  }\n\n  public List<ChangedOperation> getChangedOperations() {\n    return this.changedOperations;\n  }\n\n  public ChangedExtensions getChangedExtensions() {\n    return this.changedExtensions;\n  }\n\n  public List<ChangedSchema> getChangedSchemas() {\n    return changedSchemas;\n  }\n\n  public ChangedOpenApi setOldSpecOpenApi(final OpenAPI oldSpecOpenApi) {\n    this.oldSpecOpenApi = oldSpecOpenApi;\n    return this;\n  }\n\n  public ChangedOpenApi setNewSpecOpenApi(final OpenAPI newSpecOpenApi) {\n    this.newSpecOpenApi = newSpecOpenApi;\n    return this;\n  }\n\n  public ChangedOpenApi setNewEndpoints(final List<Endpoint> newEndpoints) {\n    this.newEndpoints = newEndpoints;\n    return this;\n  }\n\n  public ChangedOpenApi setMissingEndpoints(final List<Endpoint> missingEndpoints) {\n    this.missingEndpoints = missingEndpoints;\n    return this;\n  }\n\n  public ChangedOpenApi setChangedOperations(final List<ChangedOperation> changedOperations) {\n    this.changedOperations = changedOperations;\n    return this;\n  }\n\n  public ChangedOpenApi setChangedExtensions(final ChangedExtensions changedExtensions) {\n    this.changedExtensions = changedExtensions;\n    return this;\n  }\n\n  public ChangedOpenApi setChangedSchemas(final List<ChangedSchema> changedSchemas) {\n    this.changedSchemas = changedSchemas;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOpenApi that = (ChangedOpenApi) o;\n    return Objects.equals(oldSpecOpenApi, that.oldSpecOpenApi)\n        && Objects.equals(newSpecOpenApi, that.newSpecOpenApi)\n        && Objects.equals(newEndpoints, that.newEndpoints)\n        && Objects.equals(missingEndpoints, that.missingEndpoints)\n        && Objects.equals(changedOperations, that.changedOperations)\n        && Objects.equals(changedExtensions, that.changedExtensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSpecOpenApi,\n        newSpecOpenApi,\n        newEndpoints,\n        missingEndpoints,\n        changedOperations,\n        changedExtensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOpenApi(oldSpecOpenApi=\"\n        + this.getOldSpecOpenApi()\n        + \", newSpecOpenApi=\"\n        + this.getNewSpecOpenApi()\n        + \", newEndpoints=\"\n        + this.getNewEndpoints()\n        + \", missingEndpoints=\"\n        + this.getMissingEndpoints()\n        + \", changedOperations=\"\n        + this.getChangedOperations()\n        + \", changedExtensions=\"\n        + this.getChangedExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedOpenApi implements ComposedChanged", "class_docstring": "", "name": "ChangedOpenApi", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiffOptions options;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiffOptions", "name": "options", "syntax_pass": true}, {"attribute_expression": "@JsonIgnore private OpenAPI oldSpecOpenApi;", "docstring": "", "modifiers": "@JsonIgnore private", "marker_annotations": ["@JsonIgnore"], "non_marker_annotations": ["private"], "comments": [], "type": "OpenAPI", "name": "oldSpecOpenApi", "syntax_pass": true}, {"attribute_expression": "@JsonIgnore private OpenAPI newSpecOpenApi;", "docstring": "", "modifiers": "@JsonIgnore private", "marker_annotations": ["@JsonIgnore"], "non_marker_annotations": ["private"], "comments": [], "type": "OpenAPI", "name": "newSpecOpenApi", "syntax_pass": true}, {"attribute_expression": "private List<Endpoint> newEndpoints;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Endpoint>", "name": "newEndpoints", "syntax_pass": true}, {"attribute_expression": "private List<Endpoint> missingEndpoints;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Endpoint>", "name": "missingEndpoints", "syntax_pass": true}, {"attribute_expression": "private List<ChangedOperation> changedOperations;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<ChangedOperation>", "name": "changedOperations", "syntax_pass": true}, {"attribute_expression": "private List<ChangedSchema> changedSchemas;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<ChangedSchema>", "name": "changedSchemas", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions changedExtensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "changedExtensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedOpenApi(OpenApiDiffOptions options) {\n    this.options = options;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedOpenApi", "params": [{"name": "options", "type": "OpenApiDiffOptions"}], "body": "                                                    {\n    this.options = options;\n  }", "signature": "public ChangedOpenApi(OpenApiDiffOptions options)"}, {"syntax_pass": true, "original_string": "  public List<Endpoint> getDeprecatedEndpoints() {\n    return changedOperations.stream()\n        .filter(ChangedOperation::isDeprecated)\n        .map(\n            c ->\n                EndpointUtils.convert2Endpoint(\n                    c.getPathUrl(), c.getHttpMethod(), c.getNewOperation()))\n        .collect(Collectors.toList());\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Endpoint>", "classes": []}, "name": "getDeprecatedEndpoints", "params": [], "body": "                                                 {\n    return changedOperations.stream()\n        .filter(ChangedOperation::isDeprecated)\n        .map(\n            c ->\n                EndpointUtils.convert2Endpoint(\n                    c.getPathUrl(), c.getHttpMethod(), c.getNewOperation()))\n        .collect(Collectors.toList());\n  }", "signature": "public List<Endpoint> getDeprecatedEndpoints()"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.concat(\n            Stream.concat(changedOperations.stream(), Stream.of(changedExtensions)),\n            changedSchemas.stream())\n        .collect(Collectors.toList());\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Stream.concat(\n            Stream.concat(changedOperations.stream(), Stream.of(changedExtensions)),\n            changedSchemas.stream())\n        .collect(Collectors.toList());\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (newEndpoints.isEmpty() && missingEndpoints.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missingEndpoints.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(options.getConfig())) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (newEndpoints.isEmpty() && missingEndpoints.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missingEndpoints.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(options.getConfig())) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public OpenAPI getOldSpecOpenApi() {\n    return this.oldSpecOpenApi;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OpenAPI", "classes": []}, "name": "getOldSpecOpenApi", "params": [], "body": "                                     {\n    return this.oldSpecOpenApi;\n  }", "signature": "public OpenAPI getOldSpecOpenApi()"}, {"syntax_pass": true, "original_string": "  public OpenAPI getNewSpecOpenApi() {\n    return this.newSpecOpenApi;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OpenAPI", "classes": []}, "name": "getNewSpecOpenApi", "params": [], "body": "                                     {\n    return this.newSpecOpenApi;\n  }", "signature": "public OpenAPI getNewSpecOpenApi()"}, {"syntax_pass": true, "original_string": "  public List<Endpoint> getNewEndpoints() {\n    return this.newEndpoints;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Endpoint>", "classes": []}, "name": "getNewEndpoints", "params": [], "body": "                                          {\n    return this.newEndpoints;\n  }", "signature": "public List<Endpoint> getNewEndpoints()"}, {"syntax_pass": true, "original_string": "  public List<Endpoint> getMissingEndpoints() {\n    return this.missingEndpoints;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Endpoint>", "classes": []}, "name": "getMissingEndpoints", "params": [], "body": "                                              {\n    return this.missingEndpoints;\n  }", "signature": "public List<Endpoint> getMissingEndpoints()"}, {"syntax_pass": true, "original_string": "  public List<ChangedOperation> getChangedOperations() {\n    return this.changedOperations;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ChangedOperation>", "classes": []}, "name": "getChangedOperations", "params": [], "body": "                                                       {\n    return this.changedOperations;\n  }", "signature": "public List<ChangedOperation> getChangedOperations()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getChangedExtensions() {\n    return this.changedExtensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getChangedExtensions", "params": [], "body": "                                                  {\n    return this.changedExtensions;\n  }", "signature": "public ChangedExtensions getChangedExtensions()"}, {"syntax_pass": true, "original_string": "  public List<ChangedSchema> getChangedSchemas() {\n    return changedSchemas;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ChangedSchema>", "classes": []}, "name": "getChangedSchemas", "params": [], "body": "                                                 {\n    return changedSchemas;\n  }", "signature": "public List<ChangedSchema> getChangedSchemas()"}, {"syntax_pass": true, "original_string": "  public ChangedOpenApi setOldSpecOpenApi(final OpenAPI oldSpecOpenApi) {\n    this.oldSpecOpenApi = oldSpecOpenApi;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "setOldSpecOpenApi", "params": [{"name": "oldSpecOpenApi", "type": "OpenAPI"}], "body": "                                                                        {\n    this.oldSpecOpenApi = oldSpecOpenApi;\n    return this;\n  }", "signature": "public ChangedOpenApi setOldSpecOpenApi(final OpenAPI oldSpecOpenApi)"}, {"syntax_pass": true, "original_string": "  public ChangedOpenApi setNewSpecOpenApi(final OpenAPI newSpecOpenApi) {\n    this.newSpecOpenApi = newSpecOpenApi;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "setNewSpecOpenApi", "params": [{"name": "newSpecOpenApi", "type": "OpenAPI"}], "body": "                                                                        {\n    this.newSpecOpenApi = newSpecOpenApi;\n    return this;\n  }", "signature": "public ChangedOpenApi setNewSpecOpenApi(final OpenAPI newSpecOpenApi)"}, {"syntax_pass": true, "original_string": "  public ChangedOpenApi setNewEndpoints(final List<Endpoint> newEndpoints) {\n    this.newEndpoints = newEndpoints;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "setNewEndpoints", "params": [{"name": "newEndpoints", "type": "List<Endpoint>"}], "body": "                                                                           {\n    this.newEndpoints = newEndpoints;\n    return this;\n  }", "signature": "public ChangedOpenApi setNewEndpoints(final List<Endpoint> newEndpoints)"}, {"syntax_pass": true, "original_string": "  public ChangedOpenApi setMissingEndpoints(final List<Endpoint> missingEndpoints) {\n    this.missingEndpoints = missingEndpoints;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "setMissingEndpoints", "params": [{"name": "missingEndpoints", "type": "List<Endpoint>"}], "body": "                                                                                   {\n    this.missingEndpoints = missingEndpoints;\n    return this;\n  }", "signature": "public ChangedOpenApi setMissingEndpoints(final List<Endpoint> missingEndpoints)"}, {"syntax_pass": true, "original_string": "  public ChangedOpenApi setChangedOperations(final List<ChangedOperation> changedOperations) {\n    this.changedOperations = changedOperations;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "setChangedOperations", "params": [{"name": "changedOperations", "type": "List<ChangedOperation>"}], "body": "                                                                                             {\n    this.changedOperations = changedOperations;\n    return this;\n  }", "signature": "public ChangedOpenApi setChangedOperations(final List<ChangedOperation> changedOperations)"}, {"syntax_pass": true, "original_string": "  public ChangedOpenApi setChangedExtensions(final ChangedExtensions changedExtensions) {\n    this.changedExtensions = changedExtensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "setChangedExtensions", "params": [{"name": "changedExtensions", "type": "ChangedExtensions"}], "body": "                                                                                        {\n    this.changedExtensions = changedExtensions;\n    return this;\n  }", "signature": "public ChangedOpenApi setChangedExtensions(final ChangedExtensions changedExtensions)"}, {"syntax_pass": true, "original_string": "  public ChangedOpenApi setChangedSchemas(final List<ChangedSchema> changedSchemas) {\n    this.changedSchemas = changedSchemas;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "setChangedSchemas", "params": [{"name": "changedSchemas", "type": "List<ChangedSchema>"}], "body": "                                                                                    {\n    this.changedSchemas = changedSchemas;\n    return this;\n  }", "signature": "public ChangedOpenApi setChangedSchemas(final List<ChangedSchema> changedSchemas)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOpenApi that = (ChangedOpenApi) o;\n    return Objects.equals(oldSpecOpenApi, that.oldSpecOpenApi)\n        && Objects.equals(newSpecOpenApi, that.newSpecOpenApi)\n        && Objects.equals(newEndpoints, that.newEndpoints)\n        && Objects.equals(missingEndpoints, that.missingEndpoints)\n        && Objects.equals(changedOperations, that.changedOperations)\n        && Objects.equals(changedExtensions, that.changedExtensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOpenApi that = (ChangedOpenApi) o;\n    return Objects.equals(oldSpecOpenApi, that.oldSpecOpenApi)\n        && Objects.equals(newSpecOpenApi, that.newSpecOpenApi)\n        && Objects.equals(newEndpoints, that.newEndpoints)\n        && Objects.equals(missingEndpoints, that.missingEndpoints)\n        && Objects.equals(changedOperations, that.changedOperations)\n        && Objects.equals(changedExtensions, that.changedExtensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSpecOpenApi,\n        newSpecOpenApi,\n        newEndpoints,\n        missingEndpoints,\n        changedOperations,\n        changedExtensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldSpecOpenApi,\n        newSpecOpenApi,\n        newEndpoints,\n        missingEndpoints,\n        changedOperations,\n        changedExtensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOpenApi(oldSpecOpenApi=\"\n        + this.getOldSpecOpenApi()\n        + \", newSpecOpenApi=\"\n        + this.getNewSpecOpenApi()\n        + \", newEndpoints=\"\n        + this.getNewEndpoints()\n        + \", missingEndpoints=\"\n        + this.getMissingEndpoints()\n        + \", changedOperations=\"\n        + this.getChangedOperations()\n        + \", changedExtensions=\"\n        + this.getChangedExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedOpenApi(oldSpecOpenApi=\"\n        + this.getOldSpecOpenApi()\n        + \", newSpecOpenApi=\"\n        + this.getNewSpecOpenApi()\n        + \", newEndpoints=\"\n        + this.getNewEndpoints()\n        + \", missingEndpoints=\"\n        + this.getMissingEndpoints()\n        + \", changedOperations=\"\n        + this.getChangedOperations()\n        + \", changedExtensions=\"\n        + this.getChangedExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedRequestBody.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;\n\nimport io.swagger.v3.oas.models.parameters.RequestBody;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedRequestBody implements ComposedChanged {\n  private final RequestBody oldRequestBody;\n  private final RequestBody newRequestBody;\n  private final DiffContext context;\n  private boolean changeRequired;\n  private ChangedMetadata description;\n  private ChangedContent content;\n  private ChangedExtensions extensions;\n\n  public ChangedRequestBody(\n      RequestBody oldRequestBody, RequestBody newRequestBody, DiffContext context) {\n    this.oldRequestBody = oldRequestBody;\n    this.newRequestBody = newRequestBody;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, content, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!changeRequired) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (OPENAPI_ENDPOINTS_DECREASED.enabled(context)) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public RequestBody getOldRequestBody() {\n    return this.oldRequestBody;\n  }\n\n  public RequestBody getNewRequestBody() {\n    return this.newRequestBody;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public boolean isChangeRequired() {\n    return this.changeRequired;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedContent getContent() {\n    return this.content;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedRequestBody setChangeRequired(final boolean changeRequired) {\n    this.changeRequired = changeRequired;\n    return this;\n  }\n\n  public ChangedRequestBody setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedRequestBody setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }\n\n  public ChangedRequestBody setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedRequestBody that = (ChangedRequestBody) o;\n    return changeRequired == that.changeRequired\n        && Objects.equals(oldRequestBody, that.oldRequestBody)\n        && Objects.equals(newRequestBody, that.newRequestBody)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldRequestBody, newRequestBody, context, changeRequired, description, content, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedRequestBody(oldRequestBody=\"\n        + this.getOldRequestBody()\n        + \", newRequestBody=\"\n        + this.getNewRequestBody()\n        + \", context=\"\n        + this.getContext()\n        + \", changeRequired=\"\n        + this.isChangeRequired()\n        + \", description=\"\n        + this.getDescription()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "a837cb781a452f26e99c67181e0f3c31ac91a1a6afda375c1608d25b7bcaecca", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;", "import io.swagger.v3.oas.models.parameters.RequestBody;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedRequestBody implements ComposedChanged {\n  private final RequestBody oldRequestBody;\n  private final RequestBody newRequestBody;\n  private final DiffContext context;\n  private boolean changeRequired;\n  private ChangedMetadata description;\n  private ChangedContent content;\n  private ChangedExtensions extensions;\n\n  public ChangedRequestBody(\n      RequestBody oldRequestBody, RequestBody newRequestBody, DiffContext context) {\n    this.oldRequestBody = oldRequestBody;\n    this.newRequestBody = newRequestBody;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, content, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!changeRequired) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (OPENAPI_ENDPOINTS_DECREASED.enabled(context)) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public RequestBody getOldRequestBody() {\n    return this.oldRequestBody;\n  }\n\n  public RequestBody getNewRequestBody() {\n    return this.newRequestBody;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public boolean isChangeRequired() {\n    return this.changeRequired;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedContent getContent() {\n    return this.content;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedRequestBody setChangeRequired(final boolean changeRequired) {\n    this.changeRequired = changeRequired;\n    return this;\n  }\n\n  public ChangedRequestBody setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedRequestBody setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }\n\n  public ChangedRequestBody setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedRequestBody that = (ChangedRequestBody) o;\n    return changeRequired == that.changeRequired\n        && Objects.equals(oldRequestBody, that.oldRequestBody)\n        && Objects.equals(newRequestBody, that.newRequestBody)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldRequestBody, newRequestBody, context, changeRequired, description, content, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedRequestBody(oldRequestBody=\"\n        + this.getOldRequestBody()\n        + \", newRequestBody=\"\n        + this.getNewRequestBody()\n        + \", context=\"\n        + this.getContext()\n        + \", changeRequired=\"\n        + this.isChangeRequired()\n        + \", description=\"\n        + this.getDescription()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedRequestBody implements ComposedChanged", "class_docstring": "", "name": "ChangedRequestBody", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final RequestBody oldRequestBody;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RequestBody", "name": "oldRequestBody", "syntax_pass": true}, {"attribute_expression": "private final RequestBody newRequestBody;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RequestBody", "name": "newRequestBody", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private boolean changeRequired;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changeRequired", "syntax_pass": true}, {"attribute_expression": "private ChangedMetadata description;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedMetadata", "name": "description", "syntax_pass": true}, {"attribute_expression": "private ChangedContent content;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedContent", "name": "content", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedRequestBody(\n      RequestBody oldRequestBody, RequestBody newRequestBody, DiffContext context) {\n    this.oldRequestBody = oldRequestBody;\n    this.newRequestBody = newRequestBody;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedRequestBody", "params": [{"name": "oldRequestBody", "type": "RequestBody"}, {"name": "newRequestBody", "type": "RequestBody"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                   {\n    this.oldRequestBody = oldRequestBody;\n    this.newRequestBody = newRequestBody;\n    this.context = context;\n  }", "signature": "public ChangedRequestBody(\n      RequestBody oldRequestBody, RequestBody newRequestBody, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, content, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Arrays.asList(description, content, extensions);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (!changeRequired) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (OPENAPI_ENDPOINTS_DECREASED.enabled(context)) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (!changeRequired) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (OPENAPI_ENDPOINTS_DECREASED.enabled(context)) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public RequestBody getOldRequestBody() {\n    return this.oldRequestBody;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RequestBody", "classes": []}, "name": "getOldRequestBody", "params": [], "body": "                                         {\n    return this.oldRequestBody;\n  }", "signature": "public RequestBody getOldRequestBody()"}, {"syntax_pass": true, "original_string": "  public RequestBody getNewRequestBody() {\n    return this.newRequestBody;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RequestBody", "classes": []}, "name": "getNewRequestBody", "params": [], "body": "                                         {\n    return this.newRequestBody;\n  }", "signature": "public RequestBody getNewRequestBody()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public boolean isChangeRequired() {\n    return this.changeRequired;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangeRequired", "params": [], "body": "                                    {\n    return this.changeRequired;\n  }", "signature": "public boolean isChangeRequired()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata getDescription() {\n    return this.description;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "getDescription", "params": [], "body": "                                          {\n    return this.description;\n  }", "signature": "public ChangedMetadata getDescription()"}, {"syntax_pass": true, "original_string": "  public ChangedContent getContent() {\n    return this.content;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedContent", "classes": []}, "name": "getContent", "params": [], "body": "                                     {\n    return this.content;\n  }", "signature": "public ChangedContent getContent()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedRequestBody setChangeRequired(final boolean changeRequired) {\n    this.changeRequired = changeRequired;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedRequestBody", "classes": []}, "name": "setChangeRequired", "params": [{"name": "changeRequired", "type": "boolean"}], "body": "                                                                            {\n    this.changeRequired = changeRequired;\n    return this;\n  }", "signature": "public ChangedRequestBody setChangeRequired(final boolean changeRequired)"}, {"syntax_pass": true, "original_string": "  public ChangedRequestBody setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedRequestBody", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "ChangedMetadata"}], "body": "                                                                              {\n    this.description = description;\n    return this;\n  }", "signature": "public ChangedRequestBody setDescription(final ChangedMetadata description)"}, {"syntax_pass": true, "original_string": "  public ChangedRequestBody setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedRequestBody", "classes": []}, "name": "setContent", "params": [{"name": "content", "type": "ChangedContent"}], "body": "                                                                     {\n    this.content = content;\n    return this;\n  }", "signature": "public ChangedRequestBody setContent(final ChangedContent content)"}, {"syntax_pass": true, "original_string": "  public ChangedRequestBody setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedRequestBody", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                              {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedRequestBody setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedRequestBody that = (ChangedRequestBody) o;\n    return changeRequired == that.changeRequired\n        && Objects.equals(oldRequestBody, that.oldRequestBody)\n        && Objects.equals(newRequestBody, that.newRequestBody)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedRequestBody that = (ChangedRequestBody) o;\n    return changeRequired == that.changeRequired\n        && Objects.equals(oldRequestBody, that.oldRequestBody)\n        && Objects.equals(newRequestBody, that.newRequestBody)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldRequestBody, newRequestBody, context, changeRequired, description, content, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldRequestBody, newRequestBody, context, changeRequired, description, content, extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedRequestBody(oldRequestBody=\"\n        + this.getOldRequestBody()\n        + \", newRequestBody=\"\n        + this.getNewRequestBody()\n        + \", context=\"\n        + this.getContext()\n        + \", changeRequired=\"\n        + this.isChangeRequired()\n        + \", description=\"\n        + this.getDescription()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedRequestBody(oldRequestBody=\"\n        + this.getOldRequestBody()\n        + \", newRequestBody=\"\n        + this.getNewRequestBody()\n        + \", context=\"\n        + this.getContext()\n        + \", changeRequired=\"\n        + this.isChangeRequired()\n        + \", description=\"\n        + this.getDescription()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/Changed.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport java.util.Optional;\n\npublic interface Changed {\n  static DiffResult result(Changed changed) {\n    return Optional.ofNullable(changed).map(Changed::isChanged).orElse(DiffResult.NO_CHANGES);\n  }\n\n  DiffResult isChanged();\n\n  default boolean isCompatible() {\n    return isChanged().isCompatible();\n  }\n\n  default boolean isIncompatible() {\n    return isChanged().isIncompatible();\n  }\n\n  default boolean isUnchanged() {\n    return isChanged().isUnchanged();\n  }\n\n  default boolean isDifferent() {\n    return isChanged().isDifferent();\n  }\n}\n", "file_hash": "1bd831f06c3a0c21cd302a8e6c0ec618a29e6c4933573d23463fd2199459aa4a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import java.util.Optional;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface Changed {\n  static DiffResult result(Changed changed) {\n    return Optional.ofNullable(changed).map(Changed::isChanged).orElse(DiffResult.NO_CHANGES);\n  }\n\n  DiffResult isChanged();\n\n  default boolean isCompatible() {\n    return isChanged().isCompatible();\n  }\n\n  default boolean isIncompatible() {\n    return isChanged().isIncompatible();\n  }\n\n  default boolean isUnchanged() {\n    return isChanged().isUnchanged();\n  }\n\n  default boolean isDifferent() {\n    return isChanged().isDifferent();\n  }\n}", "definition": "public interface Changed", "interface_docstring": "", "name": "Changed", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  static DiffResult result(Changed changed) {\n    return Optional.ofNullable(changed).map(Changed::isChanged).orElse(DiffResult.NO_CHANGES);\n  }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "result", "params": [{"name": "changed", "type": "Changed"}], "body": "                                            {\n    return Optional.ofNullable(changed).map(Changed::isChanged).orElse(DiffResult.NO_CHANGES);\n  }", "signature": "static DiffResult result(Changed changed)"}, {"syntax_pass": true, "original_string": "  DiffResult isChanged();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isChanged", "params": [], "body": "", "signature": "DiffResult isChanged()"}, {"syntax_pass": true, "original_string": "  default boolean isCompatible() {\n    return isChanged().isCompatible();\n  }", "docstring": "", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isCompatible", "params": [], "body": "                                 {\n    return isChanged().isCompatible();\n  }", "signature": "default boolean isCompatible()"}, {"syntax_pass": true, "original_string": "  default boolean isIncompatible() {\n    return isChanged().isIncompatible();\n  }", "docstring": "", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isIncompatible", "params": [], "body": "                                   {\n    return isChanged().isIncompatible();\n  }", "signature": "default boolean isIncompatible()"}, {"syntax_pass": true, "original_string": "  default boolean isUnchanged() {\n    return isChanged().isUnchanged();\n  }", "docstring": "", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isUnchanged", "params": [], "body": "                                {\n    return isChanged().isUnchanged();\n  }", "signature": "default boolean isUnchanged()"}, {"syntax_pass": true, "original_string": "  default boolean isDifferent() {\n    return isChanged().isDifferent();\n  }", "docstring": "", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDifferent", "params": [], "body": "                                {\n    return isChanged().isDifferent();\n  }", "signature": "default boolean isDifferent()"}]}], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedParameter.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.*;\n\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedParameter implements ComposedChanged {\n  private final DiffContext context;\n  private Parameter oldParameter;\n  private Parameter newParameter;\n  private String name;\n  private String in;\n  private boolean changeRequired;\n  private boolean deprecated;\n  private boolean changeStyle;\n  private boolean changeExplode;\n  private boolean changeAllowEmptyValue;\n  private ChangedMetadata description;\n  private ChangedSchema schema;\n  private ChangedContent content;\n  private ChangedExtensions extensions;\n\n  public ChangedParameter(String name, String in, DiffContext context) {\n    this.name = name;\n    this.in = in;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, schema, content, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!changeRequired\n        && !deprecated\n        && !changeAllowEmptyValue\n        && !changeStyle\n        && !changeExplode) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (changeAllowEmptyValue && !Boolean.TRUE.equals(newParameter.getAllowEmptyValue())) {\n      if (REQUEST_PARAM_ALLOWEMPTY_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeExplode) {\n      if (REQUEST_PARAM_EXPLODE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeRequired && !Boolean.TRUE.equals(oldParameter.getRequired())) {\n      if (REQUEST_PARAMS_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeStyle) {\n      if (REQUEST_PARAM_STYLE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Parameter getOldParameter() {\n    return this.oldParameter;\n  }\n\n  public Parameter getNewParameter() {\n    return this.newParameter;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getIn() {\n    return this.in;\n  }\n\n  public boolean isChangeRequired() {\n    return this.changeRequired;\n  }\n\n  public boolean isDeprecated() {\n    return this.deprecated;\n  }\n\n  public boolean isChangeStyle() {\n    return this.changeStyle;\n  }\n\n  public boolean isChangeExplode() {\n    return this.changeExplode;\n  }\n\n  public boolean isChangeAllowEmptyValue() {\n    return this.changeAllowEmptyValue;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedSchema getSchema() {\n    return this.schema;\n  }\n\n  public ChangedContent getContent() {\n    return this.content;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedParameter setOldParameter(final Parameter oldParameter) {\n    this.oldParameter = oldParameter;\n    return this;\n  }\n\n  public ChangedParameter setNewParameter(final Parameter newParameter) {\n    this.newParameter = newParameter;\n    return this;\n  }\n\n  public ChangedParameter setName(final String name) {\n    this.name = name;\n    return this;\n  }\n\n  public ChangedParameter setIn(final String in) {\n    this.in = in;\n    return this;\n  }\n\n  public ChangedParameter setChangeRequired(final boolean changeRequired) {\n    this.changeRequired = changeRequired;\n    return this;\n  }\n\n  public ChangedParameter setDeprecated(final boolean deprecated) {\n    this.deprecated = deprecated;\n    return this;\n  }\n\n  public ChangedParameter setChangeStyle(final boolean changeStyle) {\n    this.changeStyle = changeStyle;\n    return this;\n  }\n\n  public ChangedParameter setChangeExplode(final boolean changeExplode) {\n    this.changeExplode = changeExplode;\n    return this;\n  }\n\n  public ChangedParameter setChangeAllowEmptyValue(final boolean changeAllowEmptyValue) {\n    this.changeAllowEmptyValue = changeAllowEmptyValue;\n    return this;\n  }\n\n  public ChangedParameter setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedParameter setSchema(final ChangedSchema schema) {\n    this.schema = schema;\n    return this;\n  }\n\n  public ChangedParameter setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }\n\n  public ChangedParameter setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedParameter that = (ChangedParameter) o;\n    return changeRequired == that.changeRequired\n        && deprecated == that.deprecated\n        && changeStyle == that.changeStyle\n        && changeExplode == that.changeExplode\n        && changeAllowEmptyValue == that.changeAllowEmptyValue\n        && Objects.equals(context, that.context)\n        && Objects.equals(oldParameter, that.oldParameter)\n        && Objects.equals(newParameter, that.newParameter)\n        && Objects.equals(name, that.name)\n        && Objects.equals(in, that.in)\n        && Objects.equals(description, that.description)\n        && Objects.equals(schema, that.schema)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        context,\n        oldParameter,\n        newParameter,\n        name,\n        in,\n        changeRequired,\n        deprecated,\n        changeStyle,\n        changeExplode,\n        changeAllowEmptyValue,\n        description,\n        schema,\n        content,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedParameter(context=\"\n        + this.getContext()\n        + \", oldParameter=\"\n        + this.getOldParameter()\n        + \", newParameter=\"\n        + this.getNewParameter()\n        + \", name=\"\n        + this.getName()\n        + \", in=\"\n        + this.getIn()\n        + \", changeRequired=\"\n        + this.isChangeRequired()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", changeStyle=\"\n        + this.isChangeStyle()\n        + \", changeExplode=\"\n        + this.isChangeExplode()\n        + \", changeAllowEmptyValue=\"\n        + this.isChangeAllowEmptyValue()\n        + \", description=\"\n        + this.getDescription()\n        + \", schema=\"\n        + this.getSchema()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "b1241f773678b844cb0c682d1b99b20d99f68810c82c64bcf66735f54c722d57", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.*;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedParameter implements ComposedChanged {\n  private final DiffContext context;\n  private Parameter oldParameter;\n  private Parameter newParameter;\n  private String name;\n  private String in;\n  private boolean changeRequired;\n  private boolean deprecated;\n  private boolean changeStyle;\n  private boolean changeExplode;\n  private boolean changeAllowEmptyValue;\n  private ChangedMetadata description;\n  private ChangedSchema schema;\n  private ChangedContent content;\n  private ChangedExtensions extensions;\n\n  public ChangedParameter(String name, String in, DiffContext context) {\n    this.name = name;\n    this.in = in;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, schema, content, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!changeRequired\n        && !deprecated\n        && !changeAllowEmptyValue\n        && !changeStyle\n        && !changeExplode) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (changeAllowEmptyValue && !Boolean.TRUE.equals(newParameter.getAllowEmptyValue())) {\n      if (REQUEST_PARAM_ALLOWEMPTY_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeExplode) {\n      if (REQUEST_PARAM_EXPLODE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeRequired && !Boolean.TRUE.equals(oldParameter.getRequired())) {\n      if (REQUEST_PARAMS_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeStyle) {\n      if (REQUEST_PARAM_STYLE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Parameter getOldParameter() {\n    return this.oldParameter;\n  }\n\n  public Parameter getNewParameter() {\n    return this.newParameter;\n  }\n\n  public String getName() {\n    return this.name;\n  }\n\n  public String getIn() {\n    return this.in;\n  }\n\n  public boolean isChangeRequired() {\n    return this.changeRequired;\n  }\n\n  public boolean isDeprecated() {\n    return this.deprecated;\n  }\n\n  public boolean isChangeStyle() {\n    return this.changeStyle;\n  }\n\n  public boolean isChangeExplode() {\n    return this.changeExplode;\n  }\n\n  public boolean isChangeAllowEmptyValue() {\n    return this.changeAllowEmptyValue;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedSchema getSchema() {\n    return this.schema;\n  }\n\n  public ChangedContent getContent() {\n    return this.content;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedParameter setOldParameter(final Parameter oldParameter) {\n    this.oldParameter = oldParameter;\n    return this;\n  }\n\n  public ChangedParameter setNewParameter(final Parameter newParameter) {\n    this.newParameter = newParameter;\n    return this;\n  }\n\n  public ChangedParameter setName(final String name) {\n    this.name = name;\n    return this;\n  }\n\n  public ChangedParameter setIn(final String in) {\n    this.in = in;\n    return this;\n  }\n\n  public ChangedParameter setChangeRequired(final boolean changeRequired) {\n    this.changeRequired = changeRequired;\n    return this;\n  }\n\n  public ChangedParameter setDeprecated(final boolean deprecated) {\n    this.deprecated = deprecated;\n    return this;\n  }\n\n  public ChangedParameter setChangeStyle(final boolean changeStyle) {\n    this.changeStyle = changeStyle;\n    return this;\n  }\n\n  public ChangedParameter setChangeExplode(final boolean changeExplode) {\n    this.changeExplode = changeExplode;\n    return this;\n  }\n\n  public ChangedParameter setChangeAllowEmptyValue(final boolean changeAllowEmptyValue) {\n    this.changeAllowEmptyValue = changeAllowEmptyValue;\n    return this;\n  }\n\n  public ChangedParameter setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedParameter setSchema(final ChangedSchema schema) {\n    this.schema = schema;\n    return this;\n  }\n\n  public ChangedParameter setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }\n\n  public ChangedParameter setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedParameter that = (ChangedParameter) o;\n    return changeRequired == that.changeRequired\n        && deprecated == that.deprecated\n        && changeStyle == that.changeStyle\n        && changeExplode == that.changeExplode\n        && changeAllowEmptyValue == that.changeAllowEmptyValue\n        && Objects.equals(context, that.context)\n        && Objects.equals(oldParameter, that.oldParameter)\n        && Objects.equals(newParameter, that.newParameter)\n        && Objects.equals(name, that.name)\n        && Objects.equals(in, that.in)\n        && Objects.equals(description, that.description)\n        && Objects.equals(schema, that.schema)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        context,\n        oldParameter,\n        newParameter,\n        name,\n        in,\n        changeRequired,\n        deprecated,\n        changeStyle,\n        changeExplode,\n        changeAllowEmptyValue,\n        description,\n        schema,\n        content,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedParameter(context=\"\n        + this.getContext()\n        + \", oldParameter=\"\n        + this.getOldParameter()\n        + \", newParameter=\"\n        + this.getNewParameter()\n        + \", name=\"\n        + this.getName()\n        + \", in=\"\n        + this.getIn()\n        + \", changeRequired=\"\n        + this.isChangeRequired()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", changeStyle=\"\n        + this.isChangeStyle()\n        + \", changeExplode=\"\n        + this.isChangeExplode()\n        + \", changeAllowEmptyValue=\"\n        + this.isChangeAllowEmptyValue()\n        + \", description=\"\n        + this.getDescription()\n        + \", schema=\"\n        + this.getSchema()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedParameter implements ComposedChanged", "class_docstring": "", "name": "ChangedParameter", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private Parameter oldParameter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Parameter", "name": "oldParameter", "syntax_pass": true}, {"attribute_expression": "private Parameter newParameter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Parameter", "name": "newParameter", "syntax_pass": true}, {"attribute_expression": "private String name;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "private String in;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "in", "syntax_pass": true}, {"attribute_expression": "private boolean changeRequired;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changeRequired", "syntax_pass": true}, {"attribute_expression": "private boolean deprecated;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "deprecated", "syntax_pass": true}, {"attribute_expression": "private boolean changeStyle;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changeStyle", "syntax_pass": true}, {"attribute_expression": "private boolean changeExplode;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changeExplode", "syntax_pass": true}, {"attribute_expression": "private boolean changeAllowEmptyValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changeAllowEmptyValue", "syntax_pass": true}, {"attribute_expression": "private ChangedMetadata description;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedMetadata", "name": "description", "syntax_pass": true}, {"attribute_expression": "private ChangedSchema schema;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedSchema", "name": "schema", "syntax_pass": true}, {"attribute_expression": "private ChangedContent content;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedContent", "name": "content", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedParameter(String name, String in, DiffContext context) {\n    this.name = name;\n    this.in = in;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedParameter", "params": [{"name": "name", "type": "String"}, {"name": "in", "type": "String"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                       {\n    this.name = name;\n    this.in = in;\n    this.context = context;\n  }", "signature": "public ChangedParameter(String name, String in, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, schema, content, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Arrays.asList(description, schema, content, extensions);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (!changeRequired\n        && !deprecated\n        && !changeAllowEmptyValue\n        && !changeStyle\n        && !changeExplode) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (changeAllowEmptyValue && !Boolean.TRUE.equals(newParameter.getAllowEmptyValue())) {\n      if (REQUEST_PARAM_ALLOWEMPTY_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeExplode) {\n      if (REQUEST_PARAM_EXPLODE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeRequired && !Boolean.TRUE.equals(oldParameter.getRequired())) {\n      if (REQUEST_PARAMS_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeStyle) {\n      if (REQUEST_PARAM_STYLE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (!changeRequired\n        && !deprecated\n        && !changeAllowEmptyValue\n        && !changeStyle\n        && !changeExplode) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (changeAllowEmptyValue && !Boolean.TRUE.equals(newParameter.getAllowEmptyValue())) {\n      if (REQUEST_PARAM_ALLOWEMPTY_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeExplode) {\n      if (REQUEST_PARAM_EXPLODE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeRequired && !Boolean.TRUE.equals(oldParameter.getRequired())) {\n      if (REQUEST_PARAMS_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changeStyle) {\n      if (REQUEST_PARAM_STYLE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public Parameter getOldParameter() {\n    return this.oldParameter;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Parameter", "classes": []}, "name": "getOldParameter", "params": [], "body": "                                     {\n    return this.oldParameter;\n  }", "signature": "public Parameter getOldParameter()"}, {"syntax_pass": true, "original_string": "  public Parameter getNewParameter() {\n    return this.newParameter;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Parameter", "classes": []}, "name": "getNewParameter", "params": [], "body": "                                     {\n    return this.newParameter;\n  }", "signature": "public Parameter getNewParameter()"}, {"syntax_pass": true, "original_string": "  public String getName() {\n    return this.name;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getName", "params": [], "body": "                          {\n    return this.name;\n  }", "signature": "public String getName()"}, {"syntax_pass": true, "original_string": "  public String getIn() {\n    return this.in;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getIn", "params": [], "body": "                        {\n    return this.in;\n  }", "signature": "public String getIn()"}, {"syntax_pass": true, "original_string": "  public boolean isChangeRequired() {\n    return this.changeRequired;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangeRequired", "params": [], "body": "                                    {\n    return this.changeRequired;\n  }", "signature": "public boolean isChangeRequired()"}, {"syntax_pass": true, "original_string": "  public boolean isDeprecated() {\n    return this.deprecated;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDeprecated", "params": [], "body": "                                {\n    return this.deprecated;\n  }", "signature": "public boolean isDeprecated()"}, {"syntax_pass": true, "original_string": "  public boolean isChangeStyle() {\n    return this.changeStyle;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangeStyle", "params": [], "body": "                                 {\n    return this.changeStyle;\n  }", "signature": "public boolean isChangeStyle()"}, {"syntax_pass": true, "original_string": "  public boolean isChangeExplode() {\n    return this.changeExplode;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangeExplode", "params": [], "body": "                                   {\n    return this.changeExplode;\n  }", "signature": "public boolean isChangeExplode()"}, {"syntax_pass": true, "original_string": "  public boolean isChangeAllowEmptyValue() {\n    return this.changeAllowEmptyValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangeAllowEmptyValue", "params": [], "body": "                                           {\n    return this.changeAllowEmptyValue;\n  }", "signature": "public boolean isChangeAllowEmptyValue()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata getDescription() {\n    return this.description;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "getDescription", "params": [], "body": "                                          {\n    return this.description;\n  }", "signature": "public ChangedMetadata getDescription()"}, {"syntax_pass": true, "original_string": "  public ChangedSchema getSchema() {\n    return this.schema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "getSchema", "params": [], "body": "                                   {\n    return this.schema;\n  }", "signature": "public ChangedSchema getSchema()"}, {"syntax_pass": true, "original_string": "  public ChangedContent getContent() {\n    return this.content;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedContent", "classes": []}, "name": "getContent", "params": [], "body": "                                     {\n    return this.content;\n  }", "signature": "public ChangedContent getContent()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setOldParameter(final Parameter oldParameter) {\n    this.oldParameter = oldParameter;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setOldParameter", "params": [{"name": "oldParameter", "type": "Parameter"}], "body": "                                                                        {\n    this.oldParameter = oldParameter;\n    return this;\n  }", "signature": "public ChangedParameter setOldParameter(final Parameter oldParameter)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setNewParameter(final Parameter newParameter) {\n    this.newParameter = newParameter;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setNewParameter", "params": [{"name": "newParameter", "type": "Parameter"}], "body": "                                                                        {\n    this.newParameter = newParameter;\n    return this;\n  }", "signature": "public ChangedParameter setNewParameter(final Parameter newParameter)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setName(final String name) {\n    this.name = name;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setName", "params": [{"name": "name", "type": "String"}], "body": "                                                     {\n    this.name = name;\n    return this;\n  }", "signature": "public ChangedParameter setName(final String name)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setIn(final String in) {\n    this.in = in;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setIn", "params": [{"name": "in", "type": "String"}], "body": "                                                 {\n    this.in = in;\n    return this;\n  }", "signature": "public ChangedParameter setIn(final String in)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setChangeRequired(final boolean changeRequired) {\n    this.changeRequired = changeRequired;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setChangeRequired", "params": [{"name": "changeRequired", "type": "boolean"}], "body": "                                                                          {\n    this.changeRequired = changeRequired;\n    return this;\n  }", "signature": "public ChangedParameter setChangeRequired(final boolean changeRequired)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setDeprecated(final boolean deprecated) {\n    this.deprecated = deprecated;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setDeprecated", "params": [{"name": "deprecated", "type": "boolean"}], "body": "                                                                  {\n    this.deprecated = deprecated;\n    return this;\n  }", "signature": "public ChangedParameter setDeprecated(final boolean deprecated)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setChangeStyle(final boolean changeStyle) {\n    this.changeStyle = changeStyle;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setChangeStyle", "params": [{"name": "changeStyle", "type": "boolean"}], "body": "                                                                    {\n    this.changeStyle = changeStyle;\n    return this;\n  }", "signature": "public ChangedParameter setChangeStyle(final boolean changeStyle)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setChangeExplode(final boolean changeExplode) {\n    this.changeExplode = changeExplode;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setChangeExplode", "params": [{"name": "changeExplode", "type": "boolean"}], "body": "                                                                        {\n    this.changeExplode = changeExplode;\n    return this;\n  }", "signature": "public ChangedParameter setChangeExplode(final boolean changeExplode)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setChangeAllowEmptyValue(final boolean changeAllowEmptyValue) {\n    this.changeAllowEmptyValue = changeAllowEmptyValue;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setChangeAllowEmptyValue", "params": [{"name": "changeAllowEmptyValue", "type": "boolean"}], "body": "                                                                                        {\n    this.changeAllowEmptyValue = changeAllowEmptyValue;\n    return this;\n  }", "signature": "public ChangedParameter setChangeAllowEmptyValue(final boolean changeAllowEmptyValue)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "ChangedMetadata"}], "body": "                                                                            {\n    this.description = description;\n    return this;\n  }", "signature": "public ChangedParameter setDescription(final ChangedMetadata description)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setSchema(final ChangedSchema schema) {\n    this.schema = schema;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setSchema", "params": [{"name": "schema", "type": "ChangedSchema"}], "body": "                                                                {\n    this.schema = schema;\n    return this;\n  }", "signature": "public ChangedParameter setSchema(final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setContent", "params": [{"name": "content", "type": "ChangedContent"}], "body": "                                                                   {\n    this.content = content;\n    return this;\n  }", "signature": "public ChangedParameter setContent(final ChangedContent content)"}, {"syntax_pass": true, "original_string": "  public ChangedParameter setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameter", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                            {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedParameter setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedParameter that = (ChangedParameter) o;\n    return changeRequired == that.changeRequired\n        && deprecated == that.deprecated\n        && changeStyle == that.changeStyle\n        && changeExplode == that.changeExplode\n        && changeAllowEmptyValue == that.changeAllowEmptyValue\n        && Objects.equals(context, that.context)\n        && Objects.equals(oldParameter, that.oldParameter)\n        && Objects.equals(newParameter, that.newParameter)\n        && Objects.equals(name, that.name)\n        && Objects.equals(in, that.in)\n        && Objects.equals(description, that.description)\n        && Objects.equals(schema, that.schema)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedParameter that = (ChangedParameter) o;\n    return changeRequired == that.changeRequired\n        && deprecated == that.deprecated\n        && changeStyle == that.changeStyle\n        && changeExplode == that.changeExplode\n        && changeAllowEmptyValue == that.changeAllowEmptyValue\n        && Objects.equals(context, that.context)\n        && Objects.equals(oldParameter, that.oldParameter)\n        && Objects.equals(newParameter, that.newParameter)\n        && Objects.equals(name, that.name)\n        && Objects.equals(in, that.in)\n        && Objects.equals(description, that.description)\n        && Objects.equals(schema, that.schema)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        context,\n        oldParameter,\n        newParameter,\n        name,\n        in,\n        changeRequired,\n        deprecated,\n        changeStyle,\n        changeExplode,\n        changeAllowEmptyValue,\n        description,\n        schema,\n        content,\n        extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        context,\n        oldParameter,\n        newParameter,\n        name,\n        in,\n        changeRequired,\n        deprecated,\n        changeStyle,\n        changeExplode,\n        changeAllowEmptyValue,\n        description,\n        schema,\n        content,\n        extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedParameter(context=\"\n        + this.getContext()\n        + \", oldParameter=\"\n        + this.getOldParameter()\n        + \", newParameter=\"\n        + this.getNewParameter()\n        + \", name=\"\n        + this.getName()\n        + \", in=\"\n        + this.getIn()\n        + \", changeRequired=\"\n        + this.isChangeRequired()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", changeStyle=\"\n        + this.isChangeStyle()\n        + \", changeExplode=\"\n        + this.isChangeExplode()\n        + \", changeAllowEmptyValue=\"\n        + this.isChangeAllowEmptyValue()\n        + \", description=\"\n        + this.getDescription()\n        + \", schema=\"\n        + this.getSchema()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedParameter(context=\"\n        + this.getContext()\n        + \", oldParameter=\"\n        + this.getOldParameter()\n        + \", newParameter=\"\n        + this.getNewParameter()\n        + \", name=\"\n        + this.getName()\n        + \", in=\"\n        + this.getIn()\n        + \", changeRequired=\"\n        + this.isChangeRequired()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", changeStyle=\"\n        + this.isChangeStyle()\n        + \", changeExplode=\"\n        + this.isChangeExplode()\n        + \", changeAllowEmptyValue=\"\n        + this.isChangeAllowEmptyValue()\n        + \", description=\"\n        + this.getDescription()\n        + \", schema=\"\n        + this.getSchema()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/Change.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport java.util.Objects;\n\npublic final class Change<T> {\n  private final T oldValue;\n  private final T newValue;\n  private final Type type;\n\n  public static <T> Change<T> changed(T oldValue, T newValue) {\n    return new Change<>(oldValue, newValue, Type.CHANGED);\n  }\n\n  public static <T> Change<T> added(T newValue) {\n    return new Change<>(null, newValue, Type.ADDED);\n  }\n\n  public static <T> Change<T> removed(T oldValue) {\n    return new Change<>(oldValue, null, Type.REMOVED);\n  }\n\n  public enum Type {\n    ADDED,\n    CHANGED,\n    REMOVED\n  }\n\n  public Change(final T oldValue, final T newValue, final Type type) {\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.type = type;\n  }\n\n  public T getOldValue() {\n    return this.oldValue;\n  }\n\n  public T getNewValue() {\n    return this.newValue;\n  }\n\n  public Type getType() {\n    return this.type;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Change<?> change = (Change<?>) o;\n    return Objects.equals(oldValue, change.oldValue)\n        && Objects.equals(newValue, change.newValue)\n        && type == change.type;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldValue, newValue, type);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"Change(oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", type=\"\n        + this.getType()\n        + \")\";\n  }\n}\n", "file_hash": "a13eedbfb5d13f7539b5b535e7ad043f37fd7d8f63bc3faa98c9c964dffb7650", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public final class Change<T> {\n  private final T oldValue;\n  private final T newValue;\n  private final Type type;\n\n  public static <T> Change<T> changed(T oldValue, T newValue) {\n    return new Change<>(oldValue, newValue, Type.CHANGED);\n  }\n\n  public static <T> Change<T> added(T newValue) {\n    return new Change<>(null, newValue, Type.ADDED);\n  }\n\n  public static <T> Change<T> removed(T oldValue) {\n    return new Change<>(oldValue, null, Type.REMOVED);\n  }\n\n  public enum Type {\n    ADDED,\n    CHANGED,\n    REMOVED\n  }\n\n  public Change(final T oldValue, final T newValue, final Type type) {\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.type = type;\n  }\n\n  public T getOldValue() {\n    return this.oldValue;\n  }\n\n  public T getNewValue() {\n    return this.newValue;\n  }\n\n  public Type getType() {\n    return this.type;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Change<?> change = (Change<?>) o;\n    return Objects.equals(oldValue, change.oldValue)\n        && Objects.equals(newValue, change.newValue)\n        && type == change.type;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldValue, newValue, type);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"Change(oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", type=\"\n        + this.getType()\n        + \")\";\n  }\n}", "definition": "public final class Change<T>", "class_docstring": "", "name": "Change", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final T oldValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "oldValue", "syntax_pass": true}, {"attribute_expression": "private final T newValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "newValue", "syntax_pass": true}, {"attribute_expression": "private final Type type;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public static <T> Change<T> changed(T oldValue, T newValue) {\n    return new Change<>(oldValue, newValue, Type.CHANGED);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Change<T>", "classes": []}, "name": "changed", "params": [{"name": "oldValue", "type": "T"}, {"name": "newValue", "type": "T"}], "body": "                                                              {\n    return new Change<>(oldValue, newValue, Type.CHANGED);\n  }", "signature": "public static <T> Change<T> changed(T oldValue, T newValue)"}, {"syntax_pass": true, "original_string": "  public static <T> Change<T> added(T newValue) {\n    return new Change<>(null, newValue, Type.ADDED);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Change<T>", "classes": []}, "name": "added", "params": [{"name": "newValue", "type": "T"}], "body": "                                                {\n    return new Change<>(null, newValue, Type.ADDED);\n  }", "signature": "public static <T> Change<T> added(T newValue)"}, {"syntax_pass": true, "original_string": "  public static <T> Change<T> removed(T oldValue) {\n    return new Change<>(oldValue, null, Type.REMOVED);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Change<T>", "classes": []}, "name": "removed", "params": [{"name": "oldValue", "type": "T"}], "body": "                                                  {\n    return new Change<>(oldValue, null, Type.REMOVED);\n  }", "signature": "public static <T> Change<T> removed(T oldValue)"}, {"syntax_pass": true, "original_string": "  public Change(final T oldValue, final T newValue, final Type type) {\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.type = type;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Change", "params": [{"name": "oldValue", "type": "T"}, {"name": "newValue", "type": "T"}, {"name": "type", "type": "Type"}], "body": "                                                                     {\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.type = type;\n  }", "signature": "public Change(final T oldValue, final T newValue, final Type type)"}, {"syntax_pass": true, "original_string": "  public T getOldValue() {\n    return this.oldValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getOldValue", "params": [], "body": "                         {\n    return this.oldValue;\n  }", "signature": "public T getOldValue()"}, {"syntax_pass": true, "original_string": "  public T getNewValue() {\n    return this.newValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getNewValue", "params": [], "body": "                         {\n    return this.newValue;\n  }", "signature": "public T getNewValue()"}, {"syntax_pass": true, "original_string": "  public Type getType() {\n    return this.type;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "name": "getType", "params": [], "body": "                        {\n    return this.type;\n  }", "signature": "public Type getType()"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Change<?> change = (Change<?>) o;\n    return Objects.equals(oldValue, change.oldValue)\n        && Objects.equals(newValue, change.newValue)\n        && type == change.type;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Change<?> change = (Change<?>) o;\n    return Objects.equals(oldValue, change.oldValue)\n        && Objects.equals(newValue, change.newValue)\n        && type == change.type;\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(oldValue, newValue, type);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(oldValue, newValue, type);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"Change(oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", type=\"\n        + this.getType()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"Change(oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", type=\"\n        + this.getType()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedSecurityRequirement.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_REQUIREMENT_SCHEMES_INCREASED;\n\nimport io.swagger.v3.oas.models.security.SecurityRequirement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedSecurityRequirement implements ComposedChanged {\n  private SecurityRequirement oldSecurityRequirement;\n  private SecurityRequirement newSecurityRequirement;\n  private final DiffContext context;\n  private SecurityRequirement missing;\n  private SecurityRequirement increased;\n  private List<ChangedSecurityScheme> changed;\n\n  public ChangedSecurityRequirement(\n      SecurityRequirement oldSecurityRequirement,\n      SecurityRequirement newSecurityRequirement,\n      DiffContext context) {\n    this.oldSecurityRequirement = oldSecurityRequirement;\n    this.newSecurityRequirement = newSecurityRequirement;\n    this.context = context;\n    this.changed = new ArrayList<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased == null && missing == null) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (increased != null) {\n      if (SECURITY_REQUIREMENT_SCHEMES_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public void addMissing(String key, List<String> scopes) {\n    if (missing == null) {\n      missing = new SecurityRequirement();\n    }\n    missing.put(key, scopes);\n  }\n\n  public void addIncreased(String key, List<String> scopes) {\n    if (increased == null) {\n      increased = new SecurityRequirement();\n    }\n    increased.put(key, scopes);\n  }\n\n  public void addChanged(ChangedSecurityScheme changedSecurityScheme) {\n    changed.add(changedSecurityScheme);\n  }\n\n  public SecurityRequirement getOldSecurityRequirement() {\n    return this.oldSecurityRequirement;\n  }\n\n  public SecurityRequirement getNewSecurityRequirement() {\n    return this.newSecurityRequirement;\n  }\n\n  public SecurityRequirement getMissing() {\n    return this.missing;\n  }\n\n  public SecurityRequirement getIncreased() {\n    return this.increased;\n  }\n\n  public List<ChangedSecurityScheme> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedSecurityRequirement setOldSecurityRequirement(\n      final SecurityRequirement oldSecurityRequirement) {\n    this.oldSecurityRequirement = oldSecurityRequirement;\n    return this;\n  }\n\n  public ChangedSecurityRequirement setNewSecurityRequirement(\n      final SecurityRequirement newSecurityRequirement) {\n    this.newSecurityRequirement = newSecurityRequirement;\n    return this;\n  }\n\n  public ChangedSecurityRequirement setMissing(final SecurityRequirement missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedSecurityRequirement setIncreased(final SecurityRequirement increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedSecurityRequirement setChanged(final List<ChangedSecurityScheme> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityRequirement that = (ChangedSecurityRequirement) o;\n    return Objects.equals(oldSecurityRequirement, that.oldSecurityRequirement)\n        && Objects.equals(newSecurityRequirement, that.newSecurityRequirement)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSecurityRequirement, newSecurityRequirement, missing, increased, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSecurityRequirement(oldSecurityRequirement=\"\n        + this.getOldSecurityRequirement()\n        + \", newSecurityRequirement=\"\n        + this.getNewSecurityRequirement()\n        + \", missing=\"\n        + this.getMissing()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}\n", "file_hash": "c908768ca08c0e3a3ee616033e8796872799cff91bea035fbf8498e5c1e80dd3", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SECURITY_REQUIREMENT_SCHEMES_INCREASED;", "import io.swagger.v3.oas.models.security.SecurityRequirement;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedSecurityRequirement implements ComposedChanged {\n  private SecurityRequirement oldSecurityRequirement;\n  private SecurityRequirement newSecurityRequirement;\n  private final DiffContext context;\n  private SecurityRequirement missing;\n  private SecurityRequirement increased;\n  private List<ChangedSecurityScheme> changed;\n\n  public ChangedSecurityRequirement(\n      SecurityRequirement oldSecurityRequirement,\n      SecurityRequirement newSecurityRequirement,\n      DiffContext context) {\n    this.oldSecurityRequirement = oldSecurityRequirement;\n    this.newSecurityRequirement = newSecurityRequirement;\n    this.context = context;\n    this.changed = new ArrayList<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased == null && missing == null) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (increased != null) {\n      if (SECURITY_REQUIREMENT_SCHEMES_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public void addMissing(String key, List<String> scopes) {\n    if (missing == null) {\n      missing = new SecurityRequirement();\n    }\n    missing.put(key, scopes);\n  }\n\n  public void addIncreased(String key, List<String> scopes) {\n    if (increased == null) {\n      increased = new SecurityRequirement();\n    }\n    increased.put(key, scopes);\n  }\n\n  public void addChanged(ChangedSecurityScheme changedSecurityScheme) {\n    changed.add(changedSecurityScheme);\n  }\n\n  public SecurityRequirement getOldSecurityRequirement() {\n    return this.oldSecurityRequirement;\n  }\n\n  public SecurityRequirement getNewSecurityRequirement() {\n    return this.newSecurityRequirement;\n  }\n\n  public SecurityRequirement getMissing() {\n    return this.missing;\n  }\n\n  public SecurityRequirement getIncreased() {\n    return this.increased;\n  }\n\n  public List<ChangedSecurityScheme> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedSecurityRequirement setOldSecurityRequirement(\n      final SecurityRequirement oldSecurityRequirement) {\n    this.oldSecurityRequirement = oldSecurityRequirement;\n    return this;\n  }\n\n  public ChangedSecurityRequirement setNewSecurityRequirement(\n      final SecurityRequirement newSecurityRequirement) {\n    this.newSecurityRequirement = newSecurityRequirement;\n    return this;\n  }\n\n  public ChangedSecurityRequirement setMissing(final SecurityRequirement missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedSecurityRequirement setIncreased(final SecurityRequirement increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedSecurityRequirement setChanged(final List<ChangedSecurityScheme> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityRequirement that = (ChangedSecurityRequirement) o;\n    return Objects.equals(oldSecurityRequirement, that.oldSecurityRequirement)\n        && Objects.equals(newSecurityRequirement, that.newSecurityRequirement)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSecurityRequirement, newSecurityRequirement, missing, increased, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSecurityRequirement(oldSecurityRequirement=\"\n        + this.getOldSecurityRequirement()\n        + \", newSecurityRequirement=\"\n        + this.getNewSecurityRequirement()\n        + \", missing=\"\n        + this.getMissing()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}", "definition": "public class ChangedSecurityRequirement implements ComposedChanged", "class_docstring": "", "name": "ChangedSecurityRequirement", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private SecurityRequirement oldSecurityRequirement;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecurityRequirement", "name": "oldSecurityRequirement", "syntax_pass": true}, {"attribute_expression": "private SecurityRequirement newSecurityRequirement;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecurityRequirement", "name": "newSecurityRequirement", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private SecurityRequirement missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecurityRequirement", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private SecurityRequirement increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecurityRequirement", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private List<ChangedSecurityScheme> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<ChangedSecurityScheme>", "name": "changed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedSecurityRequirement(\n      SecurityRequirement oldSecurityRequirement,\n      SecurityRequirement newSecurityRequirement,\n      DiffContext context) {\n    this.oldSecurityRequirement = oldSecurityRequirement;\n    this.newSecurityRequirement = newSecurityRequirement;\n    this.context = context;\n    this.changed = new ArrayList<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedSecurityRequirement", "params": [{"name": "oldSecurityRequirement", "type": "SecurityRequirement"}, {"name": "newSecurityRequirement", "type": "SecurityRequirement"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n    this.oldSecurityRequirement = oldSecurityRequirement;\n    this.newSecurityRequirement = newSecurityRequirement;\n    this.context = context;\n    this.changed = new ArrayList<>();\n  }", "signature": "public ChangedSecurityRequirement(\n      SecurityRequirement oldSecurityRequirement,\n      SecurityRequirement newSecurityRequirement,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return new ArrayList<>(changed);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (increased == null && missing == null) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (increased != null) {\n      if (SECURITY_REQUIREMENT_SCHEMES_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (increased == null && missing == null) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (increased != null) {\n      if (SECURITY_REQUIREMENT_SCHEMES_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public void addMissing(String key, List<String> scopes) {\n    if (missing == null) {\n      missing = new SecurityRequirement();\n    }\n    missing.put(key, scopes);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "addMissing", "params": [{"name": "key", "type": "String"}, {"name": "scopes", "type": "List<String>"}], "body": "                                                          {\n    if (missing == null) {\n      missing = new SecurityRequirement();\n    }\n    missing.put(key, scopes);\n  }", "signature": "public void addMissing(String key, List<String> scopes)"}, {"syntax_pass": true, "original_string": "  public void addIncreased(String key, List<String> scopes) {\n    if (increased == null) {\n      increased = new SecurityRequirement();\n    }\n    increased.put(key, scopes);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "addIncreased", "params": [{"name": "key", "type": "String"}, {"name": "scopes", "type": "List<String>"}], "body": "                                                            {\n    if (increased == null) {\n      increased = new SecurityRequirement();\n    }\n    increased.put(key, scopes);\n  }", "signature": "public void addIncreased(String key, List<String> scopes)"}, {"syntax_pass": true, "original_string": "  public void addChanged(ChangedSecurityScheme changedSecurityScheme) {\n    changed.add(changedSecurityScheme);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "addChanged", "params": [{"name": "changedSecurityScheme", "type": "ChangedSecurityScheme"}], "body": "                                                                      {\n    changed.add(changedSecurityScheme);\n  }", "signature": "public void addChanged(ChangedSecurityScheme changedSecurityScheme)"}, {"syntax_pass": true, "original_string": "  public SecurityRequirement getOldSecurityRequirement() {\n    return this.oldSecurityRequirement;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecurityRequirement", "classes": []}, "name": "getOldSecurityRequirement", "params": [], "body": "                                                         {\n    return this.oldSecurityRequirement;\n  }", "signature": "public SecurityRequirement getOldSecurityRequirement()"}, {"syntax_pass": true, "original_string": "  public SecurityRequirement getNewSecurityRequirement() {\n    return this.newSecurityRequirement;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecurityRequirement", "classes": []}, "name": "getNewSecurityRequirement", "params": [], "body": "                                                         {\n    return this.newSecurityRequirement;\n  }", "signature": "public SecurityRequirement getNewSecurityRequirement()"}, {"syntax_pass": true, "original_string": "  public SecurityRequirement getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecurityRequirement", "classes": []}, "name": "getMissing", "params": [], "body": "                                          {\n    return this.missing;\n  }", "signature": "public SecurityRequirement getMissing()"}, {"syntax_pass": true, "original_string": "  public SecurityRequirement getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecurityRequirement", "classes": []}, "name": "getIncreased", "params": [], "body": "                                            {\n    return this.increased;\n  }", "signature": "public SecurityRequirement getIncreased()"}, {"syntax_pass": true, "original_string": "  public List<ChangedSecurityScheme> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ChangedSecurityScheme>", "classes": []}, "name": "getChanged", "params": [], "body": "                                                  {\n    return this.changed;\n  }", "signature": "public List<ChangedSecurityScheme> getChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirement setOldSecurityRequirement(\n      final SecurityRequirement oldSecurityRequirement) {\n    this.oldSecurityRequirement = oldSecurityRequirement;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirement", "classes": []}, "name": "setOldSecurityRequirement", "params": [{"name": "oldSecurityRequirement", "type": "SecurityRequirement"}], "body": "                                                        {\n    this.oldSecurityRequirement = oldSecurityRequirement;\n    return this;\n  }", "signature": "public ChangedSecurityRequirement setOldSecurityRequirement(\n      final SecurityRequirement oldSecurityRequirement)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirement setNewSecurityRequirement(\n      final SecurityRequirement newSecurityRequirement) {\n    this.newSecurityRequirement = newSecurityRequirement;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirement", "classes": []}, "name": "setNewSecurityRequirement", "params": [{"name": "newSecurityRequirement", "type": "SecurityRequirement"}], "body": "                                                        {\n    this.newSecurityRequirement = newSecurityRequirement;\n    return this;\n  }", "signature": "public ChangedSecurityRequirement setNewSecurityRequirement(\n      final SecurityRequirement newSecurityRequirement)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirement setMissing(final SecurityRequirement missing) {\n    this.missing = missing;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirement", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "SecurityRequirement"}], "body": "                                                                                  {\n    this.missing = missing;\n    return this;\n  }", "signature": "public ChangedSecurityRequirement setMissing(final SecurityRequirement missing)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirement setIncreased(final SecurityRequirement increased) {\n    this.increased = increased;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirement", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "SecurityRequirement"}], "body": "                                                                                      {\n    this.increased = increased;\n    return this;\n  }", "signature": "public ChangedSecurityRequirement setIncreased(final SecurityRequirement increased)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirement setChanged(final List<ChangedSecurityScheme> changed) {\n    this.changed = changed;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirement", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "List<ChangedSecurityScheme>"}], "body": "                                                                                          {\n    this.changed = changed;\n    return this;\n  }", "signature": "public ChangedSecurityRequirement setChanged(final List<ChangedSecurityScheme> changed)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityRequirement that = (ChangedSecurityRequirement) o;\n    return Objects.equals(oldSecurityRequirement, that.oldSecurityRequirement)\n        && Objects.equals(newSecurityRequirement, that.newSecurityRequirement)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(changed, that.changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityRequirement that = (ChangedSecurityRequirement) o;\n    return Objects.equals(oldSecurityRequirement, that.oldSecurityRequirement)\n        && Objects.equals(newSecurityRequirement, that.newSecurityRequirement)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(changed, that.changed);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSecurityRequirement, newSecurityRequirement, missing, increased, changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldSecurityRequirement, newSecurityRequirement, missing, increased, changed);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSecurityRequirement(oldSecurityRequirement=\"\n        + this.getOldSecurityRequirement()\n        + \", newSecurityRequirement=\"\n        + this.getNewSecurityRequirement()\n        + \", missing=\"\n        + this.getMissing()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedSecurityRequirement(oldSecurityRequirement=\"\n        + this.getOldSecurityRequirement()\n        + \", newSecurityRequirement=\"\n        + this.getNewSecurityRequirement()\n        + \", missing=\"\n        + this.getMissing()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedHeader.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_EXPLODE_CHANGED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_REQUIRED_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_REQUIRED_INCREASED;\n\nimport io.swagger.v3.oas.models.headers.Header;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedHeader implements ComposedChanged {\n  private final Header oldHeader;\n  private final Header newHeader;\n  private final DiffContext context;\n  private boolean required;\n  private boolean deprecated;\n  private boolean style;\n  private boolean explode;\n  private ChangedMetadata description;\n  private ChangedSchema schema;\n  private ChangedContent content;\n  private ChangedExtensions extensions;\n\n  public ChangedHeader(Header oldHeader, Header newHeader, DiffContext context) {\n    this.oldHeader = oldHeader;\n    this.newHeader = newHeader;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, schema, content, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!required && !deprecated && !style && !explode) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (explode) {\n      if (RESPONSE_HEADER_EXPLODE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (required) {\n      boolean requiredOld = oldHeader.getRequired() != null ? oldHeader.getRequired() : false;\n      boolean requiredNew = newHeader.getRequired() != null ? newHeader.getRequired() : false;\n      if (requiredOld && !requiredNew) {\n        if (RESPONSE_HEADER_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      if (!requiredOld && requiredNew) {\n        // TODO: Document why desired or remove support. Client will just ignore new header?\n        if (RESPONSE_HEADER_REQUIRED_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n    }\n    if (style) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Header getOldHeader() {\n    return this.oldHeader;\n  }\n\n  public Header getNewHeader() {\n    return this.newHeader;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public boolean isRequired() {\n    return this.required;\n  }\n\n  public boolean isDeprecated() {\n    return this.deprecated;\n  }\n\n  public boolean isStyle() {\n    return this.style;\n  }\n\n  public boolean isExplode() {\n    return this.explode;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedSchema getSchema() {\n    return this.schema;\n  }\n\n  public ChangedContent getContent() {\n    return this.content;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedHeader setRequired(final boolean required) {\n    this.required = required;\n    return this;\n  }\n\n  public ChangedHeader setDeprecated(final boolean deprecated) {\n    this.deprecated = deprecated;\n    return this;\n  }\n\n  public ChangedHeader setStyle(final boolean style) {\n    this.style = style;\n    return this;\n  }\n\n  public ChangedHeader setExplode(final boolean explode) {\n    this.explode = explode;\n    return this;\n  }\n\n  public ChangedHeader setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedHeader setSchema(final ChangedSchema schema) {\n    this.schema = schema;\n    return this;\n  }\n\n  public ChangedHeader setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }\n\n  public ChangedHeader setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedHeader that = (ChangedHeader) o;\n    return required == that.required\n        && deprecated == that.deprecated\n        && style == that.style\n        && explode == that.explode\n        && Objects.equals(oldHeader, that.oldHeader)\n        && Objects.equals(newHeader, that.newHeader)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(schema, that.schema)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldHeader,\n        newHeader,\n        context,\n        required,\n        deprecated,\n        style,\n        explode,\n        description,\n        schema,\n        content,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedHeader(oldHeader=\"\n        + this.getOldHeader()\n        + \", newHeader=\"\n        + this.getNewHeader()\n        + \", context=\"\n        + this.getContext()\n        + \", required=\"\n        + this.isRequired()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", style=\"\n        + this.isStyle()\n        + \", explode=\"\n        + this.isExplode()\n        + \", description=\"\n        + this.getDescription()\n        + \", schema=\"\n        + this.getSchema()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "47f184c3de540d60045b522ef1bfb951b6ccf2249834fc99c646305d22692212", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_EXPLODE_CHANGED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_REQUIRED_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADER_REQUIRED_INCREASED;", "import io.swagger.v3.oas.models.headers.Header;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedHeader implements ComposedChanged {\n  private final Header oldHeader;\n  private final Header newHeader;\n  private final DiffContext context;\n  private boolean required;\n  private boolean deprecated;\n  private boolean style;\n  private boolean explode;\n  private ChangedMetadata description;\n  private ChangedSchema schema;\n  private ChangedContent content;\n  private ChangedExtensions extensions;\n\n  public ChangedHeader(Header oldHeader, Header newHeader, DiffContext context) {\n    this.oldHeader = oldHeader;\n    this.newHeader = newHeader;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, schema, content, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!required && !deprecated && !style && !explode) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (explode) {\n      if (RESPONSE_HEADER_EXPLODE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (required) {\n      boolean requiredOld = oldHeader.getRequired() != null ? oldHeader.getRequired() : false;\n      boolean requiredNew = newHeader.getRequired() != null ? newHeader.getRequired() : false;\n      if (requiredOld && !requiredNew) {\n        if (RESPONSE_HEADER_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      if (!requiredOld && requiredNew) {\n        // TODO: Document why desired or remove support. Client will just ignore new header?\n        if (RESPONSE_HEADER_REQUIRED_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n    }\n    if (style) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Header getOldHeader() {\n    return this.oldHeader;\n  }\n\n  public Header getNewHeader() {\n    return this.newHeader;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public boolean isRequired() {\n    return this.required;\n  }\n\n  public boolean isDeprecated() {\n    return this.deprecated;\n  }\n\n  public boolean isStyle() {\n    return this.style;\n  }\n\n  public boolean isExplode() {\n    return this.explode;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedSchema getSchema() {\n    return this.schema;\n  }\n\n  public ChangedContent getContent() {\n    return this.content;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedHeader setRequired(final boolean required) {\n    this.required = required;\n    return this;\n  }\n\n  public ChangedHeader setDeprecated(final boolean deprecated) {\n    this.deprecated = deprecated;\n    return this;\n  }\n\n  public ChangedHeader setStyle(final boolean style) {\n    this.style = style;\n    return this;\n  }\n\n  public ChangedHeader setExplode(final boolean explode) {\n    this.explode = explode;\n    return this;\n  }\n\n  public ChangedHeader setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedHeader setSchema(final ChangedSchema schema) {\n    this.schema = schema;\n    return this;\n  }\n\n  public ChangedHeader setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }\n\n  public ChangedHeader setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedHeader that = (ChangedHeader) o;\n    return required == that.required\n        && deprecated == that.deprecated\n        && style == that.style\n        && explode == that.explode\n        && Objects.equals(oldHeader, that.oldHeader)\n        && Objects.equals(newHeader, that.newHeader)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(schema, that.schema)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldHeader,\n        newHeader,\n        context,\n        required,\n        deprecated,\n        style,\n        explode,\n        description,\n        schema,\n        content,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedHeader(oldHeader=\"\n        + this.getOldHeader()\n        + \", newHeader=\"\n        + this.getNewHeader()\n        + \", context=\"\n        + this.getContext()\n        + \", required=\"\n        + this.isRequired()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", style=\"\n        + this.isStyle()\n        + \", explode=\"\n        + this.isExplode()\n        + \", description=\"\n        + this.getDescription()\n        + \", schema=\"\n        + this.getSchema()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedHeader implements ComposedChanged", "class_docstring": "", "name": "ChangedHeader", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Header oldHeader;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Header", "name": "oldHeader", "syntax_pass": true}, {"attribute_expression": "private final Header newHeader;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Header", "name": "newHeader", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private boolean required;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "required", "syntax_pass": true}, {"attribute_expression": "private boolean deprecated;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "deprecated", "syntax_pass": true}, {"attribute_expression": "private boolean style;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "style", "syntax_pass": true}, {"attribute_expression": "private boolean explode;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "explode", "syntax_pass": true}, {"attribute_expression": "private ChangedMetadata description;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedMetadata", "name": "description", "syntax_pass": true}, {"attribute_expression": "private ChangedSchema schema;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedSchema", "name": "schema", "syntax_pass": true}, {"attribute_expression": "private ChangedContent content;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedContent", "name": "content", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedHeader(Header oldHeader, Header newHeader, DiffContext context) {\n    this.oldHeader = oldHeader;\n    this.newHeader = newHeader;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedHeader", "params": [{"name": "oldHeader", "type": "Header"}, {"name": "newHeader", "type": "Header"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                {\n    this.oldHeader = oldHeader;\n    this.newHeader = newHeader;\n    this.context = context;\n  }", "signature": "public ChangedHeader(Header oldHeader, Header newHeader, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, schema, content, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Arrays.asList(description, schema, content, extensions);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (!required && !deprecated && !style && !explode) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (explode) {\n      if (RESPONSE_HEADER_EXPLODE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (required) {\n      boolean requiredOld = oldHeader.getRequired() != null ? oldHeader.getRequired() : false;\n      boolean requiredNew = newHeader.getRequired() != null ? newHeader.getRequired() : false;\n      if (requiredOld && !requiredNew) {\n        if (RESPONSE_HEADER_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      if (!requiredOld && requiredNew) {\n        // TODO: Document why desired or remove support. Client will just ignore new header?\n        if (RESPONSE_HEADER_REQUIRED_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n    }\n    if (style) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (!required && !deprecated && !style && !explode) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (explode) {\n      if (RESPONSE_HEADER_EXPLODE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (required) {\n      boolean requiredOld = oldHeader.getRequired() != null ? oldHeader.getRequired() : false;\n      boolean requiredNew = newHeader.getRequired() != null ? newHeader.getRequired() : false;\n      if (requiredOld && !requiredNew) {\n        if (RESPONSE_HEADER_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      if (!requiredOld && requiredNew) {\n        // TODO: Document why desired or remove support. Client will just ignore new header?\n        if (RESPONSE_HEADER_REQUIRED_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n    }\n    if (style) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public Header getOldHeader() {\n    return this.oldHeader;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Header", "classes": []}, "name": "getOldHeader", "params": [], "body": "                               {\n    return this.oldHeader;\n  }", "signature": "public Header getOldHeader()"}, {"syntax_pass": true, "original_string": "  public Header getNewHeader() {\n    return this.newHeader;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Header", "classes": []}, "name": "getNewHeader", "params": [], "body": "                               {\n    return this.newHeader;\n  }", "signature": "public Header getNewHeader()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public boolean isRequired() {\n    return this.required;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRequired", "params": [], "body": "                              {\n    return this.required;\n  }", "signature": "public boolean isRequired()"}, {"syntax_pass": true, "original_string": "  public boolean isDeprecated() {\n    return this.deprecated;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDeprecated", "params": [], "body": "                                {\n    return this.deprecated;\n  }", "signature": "public boolean isDeprecated()"}, {"syntax_pass": true, "original_string": "  public boolean isStyle() {\n    return this.style;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isStyle", "params": [], "body": "                           {\n    return this.style;\n  }", "signature": "public boolean isStyle()"}, {"syntax_pass": true, "original_string": "  public boolean isExplode() {\n    return this.explode;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isExplode", "params": [], "body": "                             {\n    return this.explode;\n  }", "signature": "public boolean isExplode()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata getDescription() {\n    return this.description;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "getDescription", "params": [], "body": "                                          {\n    return this.description;\n  }", "signature": "public ChangedMetadata getDescription()"}, {"syntax_pass": true, "original_string": "  public ChangedSchema getSchema() {\n    return this.schema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "getSchema", "params": [], "body": "                                   {\n    return this.schema;\n  }", "signature": "public ChangedSchema getSchema()"}, {"syntax_pass": true, "original_string": "  public ChangedContent getContent() {\n    return this.content;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedContent", "classes": []}, "name": "getContent", "params": [], "body": "                                     {\n    return this.content;\n  }", "signature": "public ChangedContent getContent()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedHeader setRequired(final boolean required) {\n    this.required = required;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeader", "classes": []}, "name": "setRequired", "params": [{"name": "required", "type": "boolean"}], "body": "                                                           {\n    this.required = required;\n    return this;\n  }", "signature": "public ChangedHeader setRequired(final boolean required)"}, {"syntax_pass": true, "original_string": "  public ChangedHeader setDeprecated(final boolean deprecated) {\n    this.deprecated = deprecated;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeader", "classes": []}, "name": "setDeprecated", "params": [{"name": "deprecated", "type": "boolean"}], "body": "                                                               {\n    this.deprecated = deprecated;\n    return this;\n  }", "signature": "public ChangedHeader setDeprecated(final boolean deprecated)"}, {"syntax_pass": true, "original_string": "  public ChangedHeader setStyle(final boolean style) {\n    this.style = style;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeader", "classes": []}, "name": "setStyle", "params": [{"name": "style", "type": "boolean"}], "body": "                                                     {\n    this.style = style;\n    return this;\n  }", "signature": "public ChangedHeader setStyle(final boolean style)"}, {"syntax_pass": true, "original_string": "  public ChangedHeader setExplode(final boolean explode) {\n    this.explode = explode;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeader", "classes": []}, "name": "setExplode", "params": [{"name": "explode", "type": "boolean"}], "body": "                                                         {\n    this.explode = explode;\n    return this;\n  }", "signature": "public ChangedHeader setExplode(final boolean explode)"}, {"syntax_pass": true, "original_string": "  public ChangedHeader setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeader", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "ChangedMetadata"}], "body": "                                                                         {\n    this.description = description;\n    return this;\n  }", "signature": "public ChangedHeader setDescription(final ChangedMetadata description)"}, {"syntax_pass": true, "original_string": "  public ChangedHeader setSchema(final ChangedSchema schema) {\n    this.schema = schema;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeader", "classes": []}, "name": "setSchema", "params": [{"name": "schema", "type": "ChangedSchema"}], "body": "                                                             {\n    this.schema = schema;\n    return this;\n  }", "signature": "public ChangedHeader setSchema(final ChangedSchema schema)"}, {"syntax_pass": true, "original_string": "  public ChangedHeader setContent(final ChangedContent content) {\n    this.content = content;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeader", "classes": []}, "name": "setContent", "params": [{"name": "content", "type": "ChangedContent"}], "body": "                                                                {\n    this.content = content;\n    return this;\n  }", "signature": "public ChangedHeader setContent(final ChangedContent content)"}, {"syntax_pass": true, "original_string": "  public ChangedHeader setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeader", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                         {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedHeader setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedHeader that = (ChangedHeader) o;\n    return required == that.required\n        && deprecated == that.deprecated\n        && style == that.style\n        && explode == that.explode\n        && Objects.equals(oldHeader, that.oldHeader)\n        && Objects.equals(newHeader, that.newHeader)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(schema, that.schema)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedHeader that = (ChangedHeader) o;\n    return required == that.required\n        && deprecated == that.deprecated\n        && style == that.style\n        && explode == that.explode\n        && Objects.equals(oldHeader, that.oldHeader)\n        && Objects.equals(newHeader, that.newHeader)\n        && Objects.equals(context, that.context)\n        && Objects.equals(description, that.description)\n        && Objects.equals(schema, that.schema)\n        && Objects.equals(content, that.content)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldHeader,\n        newHeader,\n        context,\n        required,\n        deprecated,\n        style,\n        explode,\n        description,\n        schema,\n        content,\n        extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldHeader,\n        newHeader,\n        context,\n        required,\n        deprecated,\n        style,\n        explode,\n        description,\n        schema,\n        content,\n        extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedHeader(oldHeader=\"\n        + this.getOldHeader()\n        + \", newHeader=\"\n        + this.getNewHeader()\n        + \", context=\"\n        + this.getContext()\n        + \", required=\"\n        + this.isRequired()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", style=\"\n        + this.isStyle()\n        + \", explode=\"\n        + this.isExplode()\n        + \", description=\"\n        + this.getDescription()\n        + \", schema=\"\n        + this.getSchema()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedHeader(oldHeader=\"\n        + this.getOldHeader()\n        + \", newHeader=\"\n        + this.getNewHeader()\n        + \", context=\"\n        + this.getContext()\n        + \", required=\"\n        + this.isRequired()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", style=\"\n        + this.isStyle()\n        + \", explode=\"\n        + this.isExplode()\n        + \", description=\"\n        + this.getDescription()\n        + \", schema=\"\n        + this.getSchema()\n        + \", content=\"\n        + this.getContent()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedParameters.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_REQUIRED_INCREASED;\n\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedParameters implements ComposedChanged {\n  private final List<Parameter> oldParameterList;\n  private final List<Parameter> newParameterList;\n  private final DiffContext context;\n  private List<Parameter> increased;\n  private List<Parameter> missing;\n  private List<ChangedParameter> changed;\n\n  public ChangedParameters(\n      List<Parameter> oldParameterList, List<Parameter> newParameterList, DiffContext context) {\n    this.oldParameterList = oldParameterList;\n    this.newParameterList = newParameterList;\n    this.context = context;\n    this.increased = new ArrayList<>();\n    this.missing = new ArrayList<>();\n    this.changed = new ArrayList<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (REQUEST_PARAMS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (increased.stream().anyMatch(p -> p.getRequired() != null && p.getRequired())) {\n      if (REQUEST_PARAMS_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public List<Parameter> getOldParameterList() {\n    return this.oldParameterList;\n  }\n\n  public List<Parameter> getNewParameterList() {\n    return this.newParameterList;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public List<Parameter> getIncreased() {\n    return this.increased;\n  }\n\n  public List<Parameter> getMissing() {\n    return this.missing;\n  }\n\n  public List<ChangedParameter> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedParameters setIncreased(final List<Parameter> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedParameters setMissing(final List<Parameter> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedParameters setChanged(final List<ChangedParameter> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedParameters that = (ChangedParameters) o;\n    return Objects.equals(oldParameterList, that.oldParameterList)\n        && Objects.equals(newParameterList, that.newParameterList)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldParameterList, newParameterList, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedParameters(oldParameterList=\"\n        + this.getOldParameterList()\n        + \", newParameterList=\"\n        + this.getNewParameterList()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}\n", "file_hash": "7c699354b3e9f4aeda27ec3dcd9f55f3d808dc0dd453477f04b51deee9237d50", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_PARAMS_REQUIRED_INCREASED;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedParameters implements ComposedChanged {\n  private final List<Parameter> oldParameterList;\n  private final List<Parameter> newParameterList;\n  private final DiffContext context;\n  private List<Parameter> increased;\n  private List<Parameter> missing;\n  private List<ChangedParameter> changed;\n\n  public ChangedParameters(\n      List<Parameter> oldParameterList, List<Parameter> newParameterList, DiffContext context) {\n    this.oldParameterList = oldParameterList;\n    this.newParameterList = newParameterList;\n    this.context = context;\n    this.increased = new ArrayList<>();\n    this.missing = new ArrayList<>();\n    this.changed = new ArrayList<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (REQUEST_PARAMS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (increased.stream().anyMatch(p -> p.getRequired() != null && p.getRequired())) {\n      if (REQUEST_PARAMS_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public List<Parameter> getOldParameterList() {\n    return this.oldParameterList;\n  }\n\n  public List<Parameter> getNewParameterList() {\n    return this.newParameterList;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public List<Parameter> getIncreased() {\n    return this.increased;\n  }\n\n  public List<Parameter> getMissing() {\n    return this.missing;\n  }\n\n  public List<ChangedParameter> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedParameters setIncreased(final List<Parameter> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedParameters setMissing(final List<Parameter> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedParameters setChanged(final List<ChangedParameter> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedParameters that = (ChangedParameters) o;\n    return Objects.equals(oldParameterList, that.oldParameterList)\n        && Objects.equals(newParameterList, that.newParameterList)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldParameterList, newParameterList, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedParameters(oldParameterList=\"\n        + this.getOldParameterList()\n        + \", newParameterList=\"\n        + this.getNewParameterList()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}", "definition": "public class ChangedParameters implements ComposedChanged", "class_docstring": "", "name": "ChangedParameters", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final List<Parameter> oldParameterList;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Parameter>", "name": "oldParameterList", "syntax_pass": true}, {"attribute_expression": "private final List<Parameter> newParameterList;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Parameter>", "name": "newParameterList", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private List<Parameter> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Parameter>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private List<Parameter> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Parameter>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private List<ChangedParameter> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<ChangedParameter>", "name": "changed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedParameters(\n      List<Parameter> oldParameterList, List<Parameter> newParameterList, DiffContext context) {\n    this.oldParameterList = oldParameterList;\n    this.newParameterList = newParameterList;\n    this.context = context;\n    this.increased = new ArrayList<>();\n    this.missing = new ArrayList<>();\n    this.changed = new ArrayList<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedParameters", "params": [{"name": "oldParameterList", "type": "List<Parameter>"}, {"name": "newParameterList", "type": "List<Parameter>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                               {\n    this.oldParameterList = oldParameterList;\n    this.newParameterList = newParameterList;\n    this.context = context;\n    this.increased = new ArrayList<>();\n    this.missing = new ArrayList<>();\n    this.changed = new ArrayList<>();\n  }", "signature": "public ChangedParameters(\n      List<Parameter> oldParameterList, List<Parameter> newParameterList, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return new ArrayList<>(changed);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (REQUEST_PARAMS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (increased.stream().anyMatch(p -> p.getRequired() != null && p.getRequired())) {\n      if (REQUEST_PARAMS_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (REQUEST_PARAMS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (increased.stream().anyMatch(p -> p.getRequired() != null && p.getRequired())) {\n      if (REQUEST_PARAMS_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public List<Parameter> getOldParameterList() {\n    return this.oldParameterList;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Parameter>", "classes": []}, "name": "getOldParameterList", "params": [], "body": "                                               {\n    return this.oldParameterList;\n  }", "signature": "public List<Parameter> getOldParameterList()"}, {"syntax_pass": true, "original_string": "  public List<Parameter> getNewParameterList() {\n    return this.newParameterList;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Parameter>", "classes": []}, "name": "getNewParameterList", "params": [], "body": "                                               {\n    return this.newParameterList;\n  }", "signature": "public List<Parameter> getNewParameterList()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public List<Parameter> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Parameter>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                        {\n    return this.increased;\n  }", "signature": "public List<Parameter> getIncreased()"}, {"syntax_pass": true, "original_string": "  public List<Parameter> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Parameter>", "classes": []}, "name": "getMissing", "params": [], "body": "                                      {\n    return this.missing;\n  }", "signature": "public List<Parameter> getMissing()"}, {"syntax_pass": true, "original_string": "  public List<ChangedParameter> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ChangedParameter>", "classes": []}, "name": "getChanged", "params": [], "body": "                                             {\n    return this.changed;\n  }", "signature": "public List<ChangedParameter> getChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedParameters setIncreased(final List<Parameter> increased) {\n    this.increased = increased;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameters", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "List<Parameter>"}], "body": "                                                                         {\n    this.increased = increased;\n    return this;\n  }", "signature": "public ChangedParameters setIncreased(final List<Parameter> increased)"}, {"syntax_pass": true, "original_string": "  public ChangedParameters setMissing(final List<Parameter> missing) {\n    this.missing = missing;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameters", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "List<Parameter>"}], "body": "                                                                     {\n    this.missing = missing;\n    return this;\n  }", "signature": "public ChangedParameters setMissing(final List<Parameter> missing)"}, {"syntax_pass": true, "original_string": "  public ChangedParameters setChanged(final List<ChangedParameter> changed) {\n    this.changed = changed;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameters", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "List<ChangedParameter>"}], "body": "                                                                            {\n    this.changed = changed;\n    return this;\n  }", "signature": "public ChangedParameters setChanged(final List<ChangedParameter> changed)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedParameters that = (ChangedParameters) o;\n    return Objects.equals(oldParameterList, that.oldParameterList)\n        && Objects.equals(newParameterList, that.newParameterList)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedParameters that = (ChangedParameters) o;\n    return Objects.equals(oldParameterList, that.oldParameterList)\n        && Objects.equals(newParameterList, that.newParameterList)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(oldParameterList, newParameterList, context, increased, missing, changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(oldParameterList, newParameterList, context, increased, missing, changed);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedParameters(oldParameterList=\"\n        + this.getOldParameterList()\n        + \", newParameterList=\"\n        + this.getNewParameterList()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedParameters(oldParameterList=\"\n        + this.getOldParameterList()\n        + \", newParameterList=\"\n        + this.getNewParameterList()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/DiffResult.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static java.lang.String.format;\n\npublic enum DiffResult {\n  NO_CHANGES(\"no_changes\", 0),\n  METADATA(\"metadata\", 1),\n  COMPATIBLE(\"compatible\", 2),\n  UNKNOWN(\"unknown\", 3),\n  INCOMPATIBLE(\"incompatible\", 4);\n\n  private final String value;\n  private final int weight;\n\n  DiffResult(String value, int weight) {\n    this.value = value;\n    this.weight = weight;\n  }\n\n  public static DiffResult fromWeight(int weight) {\n    for (DiffResult result : DiffResult.values()) {\n      if (weight == result.getWeight()) {\n        return result;\n      }\n    }\n    throw new IllegalArgumentException(format(\"Invalid weight from DiffResult: %d\", weight));\n  }\n\n  public int getWeight() {\n    return this.weight;\n  }\n\n  public String getValue() {\n    return value;\n  }\n\n  public boolean isUnchanged() {\n    return this.weight == 0;\n  }\n\n  public boolean isDifferent() {\n    return this.weight > 0;\n  }\n\n  public boolean isIncompatible() {\n    return this.weight > 2;\n  }\n\n  public boolean isCompatible() {\n    return this.weight <= 2;\n  }\n\n  public boolean isMetaChanged() {\n    return this.weight == 1;\n  }\n}\n", "file_hash": "8d7b739d891eacb355ffb754a586c4e190257e3a065d97d58d0cbfe1bfe351e9", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static java.lang.String.format;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedApiResponse.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_RESPONSES_DECREASED;\n\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport io.swagger.v3.oas.models.responses.ApiResponses;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class ChangedApiResponse implements ComposedChanged {\n  private final ApiResponses oldApiResponses;\n  private final ApiResponses newApiResponses;\n  private final DiffContext context;\n  private Map<String, ApiResponse> increased;\n  private Map<String, ApiResponse> missing;\n  private Map<String, ChangedResponse> changed;\n  private ChangedExtensions extensions;\n\n  public ChangedApiResponse(\n      ApiResponses oldApiResponses, ApiResponses newApiResponses, DiffContext context) {\n    this.oldApiResponses = oldApiResponses;\n    this.newApiResponses = newApiResponses;\n    this.context = context;\n    this.missing = new LinkedHashMap<>();\n    this.increased = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.concat(changed.values().stream(), Stream.of(extensions))\n        .collect(Collectors.toList());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (RESPONSE_RESPONSES_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public ApiResponses getOldApiResponses() {\n    return this.oldApiResponses;\n  }\n\n  public ApiResponses getNewApiResponses() {\n    return this.newApiResponses;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, ApiResponse> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, ApiResponse> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedResponse> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedApiResponse setIncreased(final Map<String, ApiResponse> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedApiResponse setMissing(final Map<String, ApiResponse> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedApiResponse setChanged(final Map<String, ChangedResponse> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  public ChangedApiResponse setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedApiResponse that = (ChangedApiResponse) o;\n    return Objects.equals(oldApiResponses, that.oldApiResponses)\n        && Objects.equals(newApiResponses, that.newApiResponses)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldApiResponses, newApiResponses, context, increased, missing, changed, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedApiResponse(oldApiResponses=\"\n        + this.getOldApiResponses()\n        + \", newApiResponses=\"\n        + this.getNewApiResponses()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "d6d006799312168998ed0ceaf3b311a7ae73bdfe3464735013791bae83f61f42", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_RESPONSES_DECREASED;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import io.swagger.v3.oas.models.responses.ApiResponses;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Objects;", "import java.util.stream.Collectors;", "import java.util.stream.Stream;"], "methods": [], "classes": [{"original_string": "public class ChangedApiResponse implements ComposedChanged {\n  private final ApiResponses oldApiResponses;\n  private final ApiResponses newApiResponses;\n  private final DiffContext context;\n  private Map<String, ApiResponse> increased;\n  private Map<String, ApiResponse> missing;\n  private Map<String, ChangedResponse> changed;\n  private ChangedExtensions extensions;\n\n  public ChangedApiResponse(\n      ApiResponses oldApiResponses, ApiResponses newApiResponses, DiffContext context) {\n    this.oldApiResponses = oldApiResponses;\n    this.newApiResponses = newApiResponses;\n    this.context = context;\n    this.missing = new LinkedHashMap<>();\n    this.increased = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.concat(changed.values().stream(), Stream.of(extensions))\n        .collect(Collectors.toList());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (RESPONSE_RESPONSES_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public ApiResponses getOldApiResponses() {\n    return this.oldApiResponses;\n  }\n\n  public ApiResponses getNewApiResponses() {\n    return this.newApiResponses;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, ApiResponse> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, ApiResponse> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedResponse> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedApiResponse setIncreased(final Map<String, ApiResponse> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedApiResponse setMissing(final Map<String, ApiResponse> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedApiResponse setChanged(final Map<String, ChangedResponse> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  public ChangedApiResponse setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedApiResponse that = (ChangedApiResponse) o;\n    return Objects.equals(oldApiResponses, that.oldApiResponses)\n        && Objects.equals(newApiResponses, that.newApiResponses)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldApiResponses, newApiResponses, context, increased, missing, changed, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedApiResponse(oldApiResponses=\"\n        + this.getOldApiResponses()\n        + \", newApiResponses=\"\n        + this.getNewApiResponses()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedApiResponse implements ComposedChanged", "class_docstring": "", "name": "ChangedApiResponse", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final ApiResponses oldApiResponses;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ApiResponses", "name": "oldApiResponses", "syntax_pass": true}, {"attribute_expression": "private final ApiResponses newApiResponses;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ApiResponses", "name": "newApiResponses", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private Map<String, ApiResponse> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, ApiResponse>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private Map<String, ApiResponse> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, ApiResponse>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private Map<String, ChangedResponse> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, ChangedResponse>", "name": "changed", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedApiResponse(\n      ApiResponses oldApiResponses, ApiResponses newApiResponses, DiffContext context) {\n    this.oldApiResponses = oldApiResponses;\n    this.newApiResponses = newApiResponses;\n    this.context = context;\n    this.missing = new LinkedHashMap<>();\n    this.increased = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedApiResponse", "params": [{"name": "oldApiResponses", "type": "ApiResponses"}, {"name": "newApiResponses", "type": "ApiResponses"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                       {\n    this.oldApiResponses = oldApiResponses;\n    this.newApiResponses = newApiResponses;\n    this.context = context;\n    this.missing = new LinkedHashMap<>();\n    this.increased = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }", "signature": "public ChangedApiResponse(\n      ApiResponses oldApiResponses, ApiResponses newApiResponses, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.concat(changed.values().stream(), Stream.of(extensions))\n        .collect(Collectors.toList());\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Stream.concat(changed.values().stream(), Stream.of(extensions))\n        .collect(Collectors.toList());\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (RESPONSE_RESPONSES_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (RESPONSE_RESPONSES_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public ApiResponses getOldApiResponses() {\n    return this.oldApiResponses;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ApiResponses", "classes": []}, "name": "getOldApiResponses", "params": [], "body": "                                           {\n    return this.oldApiResponses;\n  }", "signature": "public ApiResponses getOldApiResponses()"}, {"syntax_pass": true, "original_string": "  public ApiResponses getNewApiResponses() {\n    return this.newApiResponses;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ApiResponses", "classes": []}, "name": "getNewApiResponses", "params": [], "body": "                                           {\n    return this.newApiResponses;\n  }", "signature": "public ApiResponses getNewApiResponses()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public Map<String, ApiResponse> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ApiResponse>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                                 {\n    return this.increased;\n  }", "signature": "public Map<String, ApiResponse> getIncreased()"}, {"syntax_pass": true, "original_string": "  public Map<String, ApiResponse> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ApiResponse>", "classes": []}, "name": "getMissing", "params": [], "body": "                                               {\n    return this.missing;\n  }", "signature": "public Map<String, ApiResponse> getMissing()"}, {"syntax_pass": true, "original_string": "  public Map<String, ChangedResponse> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ChangedResponse>", "classes": []}, "name": "getChanged", "params": [], "body": "                                                   {\n    return this.changed;\n  }", "signature": "public Map<String, ChangedResponse> getChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedApiResponse setIncreased(final Map<String, ApiResponse> increased) {\n    this.increased = increased;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedApiResponse", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "Map<String, ApiResponse>"}], "body": "                                                                                   {\n    this.increased = increased;\n    return this;\n  }", "signature": "public ChangedApiResponse setIncreased(final Map<String, ApiResponse> increased)"}, {"syntax_pass": true, "original_string": "  public ChangedApiResponse setMissing(final Map<String, ApiResponse> missing) {\n    this.missing = missing;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedApiResponse", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "Map<String, ApiResponse>"}], "body": "                                                                               {\n    this.missing = missing;\n    return this;\n  }", "signature": "public ChangedApiResponse setMissing(final Map<String, ApiResponse> missing)"}, {"syntax_pass": true, "original_string": "  public ChangedApiResponse setChanged(final Map<String, ChangedResponse> changed) {\n    this.changed = changed;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedApiResponse", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "Map<String, ChangedResponse>"}], "body": "                                                                                   {\n    this.changed = changed;\n    return this;\n  }", "signature": "public ChangedApiResponse setChanged(final Map<String, ChangedResponse> changed)"}, {"syntax_pass": true, "original_string": "  public ChangedApiResponse setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedApiResponse", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                              {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedApiResponse setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedApiResponse that = (ChangedApiResponse) o;\n    return Objects.equals(oldApiResponses, that.oldApiResponses)\n        && Objects.equals(newApiResponses, that.newApiResponses)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedApiResponse that = (ChangedApiResponse) o;\n    return Objects.equals(oldApiResponses, that.oldApiResponses)\n        && Objects.equals(newApiResponses, that.newApiResponses)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldApiResponses, newApiResponses, context, increased, missing, changed, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldApiResponses, newApiResponses, context, increased, missing, changed, extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedApiResponse(oldApiResponses=\"\n        + this.getOldApiResponses()\n        + \", newApiResponses=\"\n        + this.getNewApiResponses()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedApiResponse(oldApiResponses=\"\n        + this.getOldApiResponses()\n        + \", newApiResponses=\"\n        + this.getNewApiResponses()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedHeaders.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADERS_DECREASED;\n\nimport io.swagger.v3.oas.models.headers.Header;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ChangedHeaders implements ComposedChanged {\n  private final Map<String, Header> oldHeaders;\n  private final Map<String, Header> newHeaders;\n  private final DiffContext context;\n  private Map<String, Header> increased;\n  private Map<String, Header> missing;\n  private Map<String, ChangedHeader> changed;\n\n  public ChangedHeaders(\n      Map<String, Header> oldHeaders, Map<String, Header> newHeaders, DiffContext context) {\n    this.oldHeaders = oldHeaders;\n    this.newHeaders = newHeaders;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (RESPONSE_HEADERS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Map<String, Header> getOldHeaders() {\n    return this.oldHeaders;\n  }\n\n  public Map<String, Header> getNewHeaders() {\n    return this.newHeaders;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, Header> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, Header> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedHeader> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedHeaders setIncreased(final Map<String, Header> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedHeaders setMissing(final Map<String, Header> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedHeaders setChanged(final Map<String, ChangedHeader> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedHeaders that = (ChangedHeaders) o;\n    return Objects.equals(oldHeaders, that.oldHeaders)\n        && Objects.equals(newHeaders, that.newHeaders)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldHeaders, newHeaders, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedHeaders(oldHeaders=\"\n        + this.getOldHeaders()\n        + \", newHeaders=\"\n        + this.getNewHeaders()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}\n", "file_hash": "68abebc1aab0e161188ff2dc1470d235ce0dcf4533a09387967df305751a44a7", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_HEADERS_DECREASED;", "import io.swagger.v3.oas.models.headers.Header;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Map;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedHeaders implements ComposedChanged {\n  private final Map<String, Header> oldHeaders;\n  private final Map<String, Header> newHeaders;\n  private final DiffContext context;\n  private Map<String, Header> increased;\n  private Map<String, Header> missing;\n  private Map<String, ChangedHeader> changed;\n\n  public ChangedHeaders(\n      Map<String, Header> oldHeaders, Map<String, Header> newHeaders, DiffContext context) {\n    this.oldHeaders = oldHeaders;\n    this.newHeaders = newHeaders;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (RESPONSE_HEADERS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Map<String, Header> getOldHeaders() {\n    return this.oldHeaders;\n  }\n\n  public Map<String, Header> getNewHeaders() {\n    return this.newHeaders;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, Header> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, Header> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedHeader> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedHeaders setIncreased(final Map<String, Header> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedHeaders setMissing(final Map<String, Header> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedHeaders setChanged(final Map<String, ChangedHeader> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedHeaders that = (ChangedHeaders) o;\n    return Objects.equals(oldHeaders, that.oldHeaders)\n        && Objects.equals(newHeaders, that.newHeaders)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldHeaders, newHeaders, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedHeaders(oldHeaders=\"\n        + this.getOldHeaders()\n        + \", newHeaders=\"\n        + this.getNewHeaders()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}", "definition": "public class ChangedHeaders implements ComposedChanged", "class_docstring": "", "name": "ChangedHeaders", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Map<String, Header> oldHeaders;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Header>", "name": "oldHeaders", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Header> newHeaders;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Header>", "name": "newHeaders", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private Map<String, Header> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, Header>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private Map<String, Header> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, Header>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private Map<String, ChangedHeader> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, ChangedHeader>", "name": "changed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedHeaders(\n      Map<String, Header> oldHeaders, Map<String, Header> newHeaders, DiffContext context) {\n    this.oldHeaders = oldHeaders;\n    this.newHeaders = newHeaders;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedHeaders", "params": [{"name": "oldHeaders", "type": "Map<String, Header>"}, {"name": "newHeaders", "type": "Map<String, Header>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                           {\n    this.oldHeaders = oldHeaders;\n    this.newHeaders = newHeaders;\n    this.context = context;\n  }", "signature": "public ChangedHeaders(\n      Map<String, Header> oldHeaders, Map<String, Header> newHeaders, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return new ArrayList<>(changed.values());\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (RESPONSE_HEADERS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (RESPONSE_HEADERS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public Map<String, Header> getOldHeaders() {\n    return this.oldHeaders;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Header>", "classes": []}, "name": "getOldHeaders", "params": [], "body": "                                             {\n    return this.oldHeaders;\n  }", "signature": "public Map<String, Header> getOldHeaders()"}, {"syntax_pass": true, "original_string": "  public Map<String, Header> getNewHeaders() {\n    return this.newHeaders;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Header>", "classes": []}, "name": "getNewHeaders", "params": [], "body": "                                             {\n    return this.newHeaders;\n  }", "signature": "public Map<String, Header> getNewHeaders()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public Map<String, Header> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Header>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                            {\n    return this.increased;\n  }", "signature": "public Map<String, Header> getIncreased()"}, {"syntax_pass": true, "original_string": "  public Map<String, Header> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Header>", "classes": []}, "name": "getMissing", "params": [], "body": "                                          {\n    return this.missing;\n  }", "signature": "public Map<String, Header> getMissing()"}, {"syntax_pass": true, "original_string": "  public Map<String, ChangedHeader> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ChangedHeader>", "classes": []}, "name": "getChanged", "params": [], "body": "                                                 {\n    return this.changed;\n  }", "signature": "public Map<String, ChangedHeader> getChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedHeaders setIncreased(final Map<String, Header> increased) {\n    this.increased = increased;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeaders", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "Map<String, Header>"}], "body": "                                                                          {\n    this.increased = increased;\n    return this;\n  }", "signature": "public ChangedHeaders setIncreased(final Map<String, Header> increased)"}, {"syntax_pass": true, "original_string": "  public ChangedHeaders setMissing(final Map<String, Header> missing) {\n    this.missing = missing;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeaders", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "Map<String, Header>"}], "body": "                                                                      {\n    this.missing = missing;\n    return this;\n  }", "signature": "public ChangedHeaders setMissing(final Map<String, Header> missing)"}, {"syntax_pass": true, "original_string": "  public ChangedHeaders setChanged(final Map<String, ChangedHeader> changed) {\n    this.changed = changed;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedHeaders", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "Map<String, ChangedHeader>"}], "body": "                                                                             {\n    this.changed = changed;\n    return this;\n  }", "signature": "public ChangedHeaders setChanged(final Map<String, ChangedHeader> changed)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedHeaders that = (ChangedHeaders) o;\n    return Objects.equals(oldHeaders, that.oldHeaders)\n        && Objects.equals(newHeaders, that.newHeaders)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedHeaders that = (ChangedHeaders) o;\n    return Objects.equals(oldHeaders, that.oldHeaders)\n        && Objects.equals(newHeaders, that.newHeaders)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(oldHeaders, newHeaders, context, increased, missing, changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(oldHeaders, newHeaders, context, increased, missing, changed);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedHeaders(oldHeaders=\"\n        + this.getOldHeaders()\n        + \", newHeaders=\"\n        + this.getNewHeaders()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedHeaders(oldHeaders=\"\n        + this.getOldHeaders()\n        + \", newHeaders=\"\n        + this.getNewHeaders()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedOAuthFlows.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport io.swagger.v3.oas.models.security.OAuthFlows;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedOAuthFlows implements ComposedChanged {\n  private final OAuthFlows oldOAuthFlows;\n  private final OAuthFlows newOAuthFlows;\n  private ChangedOAuthFlow implicitOAuthFlow;\n  private ChangedOAuthFlow passwordOAuthFlow;\n  private ChangedOAuthFlow clientCredentialOAuthFlow;\n  private ChangedOAuthFlow authorizationCodeOAuthFlow;\n  private ChangedExtensions extensions;\n\n  public ChangedOAuthFlows(OAuthFlows oldOAuthFlows, OAuthFlows newOAuthFlows) {\n    this.oldOAuthFlows = oldOAuthFlows;\n    this.newOAuthFlows = newOAuthFlows;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(\n        implicitOAuthFlow,\n        passwordOAuthFlow,\n        clientCredentialOAuthFlow,\n        authorizationCodeOAuthFlow,\n        extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    return DiffResult.NO_CHANGES;\n  }\n\n  public OAuthFlows getOldOAuthFlows() {\n    return this.oldOAuthFlows;\n  }\n\n  public OAuthFlows getNewOAuthFlows() {\n    return this.newOAuthFlows;\n  }\n\n  public ChangedOAuthFlow getImplicitOAuthFlow() {\n    return this.implicitOAuthFlow;\n  }\n\n  public ChangedOAuthFlow getPasswordOAuthFlow() {\n    return this.passwordOAuthFlow;\n  }\n\n  public ChangedOAuthFlow getClientCredentialOAuthFlow() {\n    return this.clientCredentialOAuthFlow;\n  }\n\n  public ChangedOAuthFlow getAuthorizationCodeOAuthFlow() {\n    return this.authorizationCodeOAuthFlow;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedOAuthFlows setImplicitOAuthFlow(final ChangedOAuthFlow implicitOAuthFlow) {\n    this.implicitOAuthFlow = implicitOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlows setPasswordOAuthFlow(final ChangedOAuthFlow passwordOAuthFlow) {\n    this.passwordOAuthFlow = passwordOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlows setClientCredentialOAuthFlow(\n      final ChangedOAuthFlow clientCredentialOAuthFlow) {\n    this.clientCredentialOAuthFlow = clientCredentialOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlows setAuthorizationCodeOAuthFlow(\n      final ChangedOAuthFlow authorizationCodeOAuthFlow) {\n    this.authorizationCodeOAuthFlow = authorizationCodeOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlows setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOAuthFlows that = (ChangedOAuthFlows) o;\n    return Objects.equals(oldOAuthFlows, that.oldOAuthFlows)\n        && Objects.equals(newOAuthFlows, that.newOAuthFlows)\n        && Objects.equals(implicitOAuthFlow, that.implicitOAuthFlow)\n        && Objects.equals(passwordOAuthFlow, that.passwordOAuthFlow)\n        && Objects.equals(clientCredentialOAuthFlow, that.clientCredentialOAuthFlow)\n        && Objects.equals(authorizationCodeOAuthFlow, that.authorizationCodeOAuthFlow)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldOAuthFlows,\n        newOAuthFlows,\n        implicitOAuthFlow,\n        passwordOAuthFlow,\n        clientCredentialOAuthFlow,\n        authorizationCodeOAuthFlow,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOAuthFlows(oldOAuthFlows=\"\n        + this.getOldOAuthFlows()\n        + \", newOAuthFlows=\"\n        + this.getNewOAuthFlows()\n        + \", implicitOAuthFlow=\"\n        + this.getImplicitOAuthFlow()\n        + \", passwordOAuthFlow=\"\n        + this.getPasswordOAuthFlow()\n        + \", clientCredentialOAuthFlow=\"\n        + this.getClientCredentialOAuthFlow()\n        + \", authorizationCodeOAuthFlow=\"\n        + this.getAuthorizationCodeOAuthFlow()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "a63f3d17da57d68e51179c63bc338786d7a279950725f842778765f7f6e9f441", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import io.swagger.v3.oas.models.security.OAuthFlows;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedOAuthFlows implements ComposedChanged {\n  private final OAuthFlows oldOAuthFlows;\n  private final OAuthFlows newOAuthFlows;\n  private ChangedOAuthFlow implicitOAuthFlow;\n  private ChangedOAuthFlow passwordOAuthFlow;\n  private ChangedOAuthFlow clientCredentialOAuthFlow;\n  private ChangedOAuthFlow authorizationCodeOAuthFlow;\n  private ChangedExtensions extensions;\n\n  public ChangedOAuthFlows(OAuthFlows oldOAuthFlows, OAuthFlows newOAuthFlows) {\n    this.oldOAuthFlows = oldOAuthFlows;\n    this.newOAuthFlows = newOAuthFlows;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(\n        implicitOAuthFlow,\n        passwordOAuthFlow,\n        clientCredentialOAuthFlow,\n        authorizationCodeOAuthFlow,\n        extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    return DiffResult.NO_CHANGES;\n  }\n\n  public OAuthFlows getOldOAuthFlows() {\n    return this.oldOAuthFlows;\n  }\n\n  public OAuthFlows getNewOAuthFlows() {\n    return this.newOAuthFlows;\n  }\n\n  public ChangedOAuthFlow getImplicitOAuthFlow() {\n    return this.implicitOAuthFlow;\n  }\n\n  public ChangedOAuthFlow getPasswordOAuthFlow() {\n    return this.passwordOAuthFlow;\n  }\n\n  public ChangedOAuthFlow getClientCredentialOAuthFlow() {\n    return this.clientCredentialOAuthFlow;\n  }\n\n  public ChangedOAuthFlow getAuthorizationCodeOAuthFlow() {\n    return this.authorizationCodeOAuthFlow;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedOAuthFlows setImplicitOAuthFlow(final ChangedOAuthFlow implicitOAuthFlow) {\n    this.implicitOAuthFlow = implicitOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlows setPasswordOAuthFlow(final ChangedOAuthFlow passwordOAuthFlow) {\n    this.passwordOAuthFlow = passwordOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlows setClientCredentialOAuthFlow(\n      final ChangedOAuthFlow clientCredentialOAuthFlow) {\n    this.clientCredentialOAuthFlow = clientCredentialOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlows setAuthorizationCodeOAuthFlow(\n      final ChangedOAuthFlow authorizationCodeOAuthFlow) {\n    this.authorizationCodeOAuthFlow = authorizationCodeOAuthFlow;\n    return this;\n  }\n\n  public ChangedOAuthFlows setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOAuthFlows that = (ChangedOAuthFlows) o;\n    return Objects.equals(oldOAuthFlows, that.oldOAuthFlows)\n        && Objects.equals(newOAuthFlows, that.newOAuthFlows)\n        && Objects.equals(implicitOAuthFlow, that.implicitOAuthFlow)\n        && Objects.equals(passwordOAuthFlow, that.passwordOAuthFlow)\n        && Objects.equals(clientCredentialOAuthFlow, that.clientCredentialOAuthFlow)\n        && Objects.equals(authorizationCodeOAuthFlow, that.authorizationCodeOAuthFlow)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldOAuthFlows,\n        newOAuthFlows,\n        implicitOAuthFlow,\n        passwordOAuthFlow,\n        clientCredentialOAuthFlow,\n        authorizationCodeOAuthFlow,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOAuthFlows(oldOAuthFlows=\"\n        + this.getOldOAuthFlows()\n        + \", newOAuthFlows=\"\n        + this.getNewOAuthFlows()\n        + \", implicitOAuthFlow=\"\n        + this.getImplicitOAuthFlow()\n        + \", passwordOAuthFlow=\"\n        + this.getPasswordOAuthFlow()\n        + \", clientCredentialOAuthFlow=\"\n        + this.getClientCredentialOAuthFlow()\n        + \", authorizationCodeOAuthFlow=\"\n        + this.getAuthorizationCodeOAuthFlow()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedOAuthFlows implements ComposedChanged", "class_docstring": "", "name": "ChangedOAuthFlows", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OAuthFlows oldOAuthFlows;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OAuthFlows", "name": "oldOAuthFlows", "syntax_pass": true}, {"attribute_expression": "private final OAuthFlows newOAuthFlows;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OAuthFlows", "name": "newOAuthFlows", "syntax_pass": true}, {"attribute_expression": "private ChangedOAuthFlow implicitOAuthFlow;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedOAuthFlow", "name": "implicitOAuthFlow", "syntax_pass": true}, {"attribute_expression": "private ChangedOAuthFlow passwordOAuthFlow;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedOAuthFlow", "name": "passwordOAuthFlow", "syntax_pass": true}, {"attribute_expression": "private ChangedOAuthFlow clientCredentialOAuthFlow;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedOAuthFlow", "name": "clientCredentialOAuthFlow", "syntax_pass": true}, {"attribute_expression": "private ChangedOAuthFlow authorizationCodeOAuthFlow;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedOAuthFlow", "name": "authorizationCodeOAuthFlow", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedOAuthFlows(OAuthFlows oldOAuthFlows, OAuthFlows newOAuthFlows) {\n    this.oldOAuthFlows = oldOAuthFlows;\n    this.newOAuthFlows = newOAuthFlows;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedOAuthFlows", "params": [{"name": "oldOAuthFlows", "type": "OAuthFlows"}, {"name": "newOAuthFlows", "type": "OAuthFlows"}], "body": "                                                                               {\n    this.oldOAuthFlows = oldOAuthFlows;\n    this.newOAuthFlows = newOAuthFlows;\n  }", "signature": "public ChangedOAuthFlows(OAuthFlows oldOAuthFlows, OAuthFlows newOAuthFlows)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(\n        implicitOAuthFlow,\n        passwordOAuthFlow,\n        clientCredentialOAuthFlow,\n        authorizationCodeOAuthFlow,\n        extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Arrays.asList(\n        implicitOAuthFlow,\n        passwordOAuthFlow,\n        clientCredentialOAuthFlow,\n        authorizationCodeOAuthFlow,\n        extensions);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    return DiffResult.NO_CHANGES;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    return DiffResult.NO_CHANGES;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public OAuthFlows getOldOAuthFlows() {\n    return this.oldOAuthFlows;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OAuthFlows", "classes": []}, "name": "getOldOAuthFlows", "params": [], "body": "                                       {\n    return this.oldOAuthFlows;\n  }", "signature": "public OAuthFlows getOldOAuthFlows()"}, {"syntax_pass": true, "original_string": "  public OAuthFlows getNewOAuthFlows() {\n    return this.newOAuthFlows;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OAuthFlows", "classes": []}, "name": "getNewOAuthFlows", "params": [], "body": "                                       {\n    return this.newOAuthFlows;\n  }", "signature": "public OAuthFlows getNewOAuthFlows()"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow getImplicitOAuthFlow() {\n    return this.implicitOAuthFlow;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "getImplicitOAuthFlow", "params": [], "body": "                                                 {\n    return this.implicitOAuthFlow;\n  }", "signature": "public ChangedOAuthFlow getImplicitOAuthFlow()"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow getPasswordOAuthFlow() {\n    return this.passwordOAuthFlow;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "getPasswordOAuthFlow", "params": [], "body": "                                                 {\n    return this.passwordOAuthFlow;\n  }", "signature": "public ChangedOAuthFlow getPasswordOAuthFlow()"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow getClientCredentialOAuthFlow() {\n    return this.clientCredentialOAuthFlow;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "getClientCredentialOAuthFlow", "params": [], "body": "                                                         {\n    return this.clientCredentialOAuthFlow;\n  }", "signature": "public ChangedOAuthFlow getClientCredentialOAuthFlow()"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlow getAuthorizationCodeOAuthFlow() {\n    return this.authorizationCodeOAuthFlow;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlow", "classes": []}, "name": "getAuthorizationCodeOAuthFlow", "params": [], "body": "                                                          {\n    return this.authorizationCodeOAuthFlow;\n  }", "signature": "public ChangedOAuthFlow getAuthorizationCodeOAuthFlow()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlows setImplicitOAuthFlow(final ChangedOAuthFlow implicitOAuthFlow) {\n    this.implicitOAuthFlow = implicitOAuthFlow;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlows", "classes": []}, "name": "setImplicitOAuthFlow", "params": [{"name": "implicitOAuthFlow", "type": "ChangedOAuthFlow"}], "body": "                                                                                          {\n    this.implicitOAuthFlow = implicitOAuthFlow;\n    return this;\n  }", "signature": "public ChangedOAuthFlows setImplicitOAuthFlow(final ChangedOAuthFlow implicitOAuthFlow)"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlows setPasswordOAuthFlow(final ChangedOAuthFlow passwordOAuthFlow) {\n    this.passwordOAuthFlow = passwordOAuthFlow;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlows", "classes": []}, "name": "setPasswordOAuthFlow", "params": [{"name": "passwordOAuthFlow", "type": "ChangedOAuthFlow"}], "body": "                                                                                          {\n    this.passwordOAuthFlow = passwordOAuthFlow;\n    return this;\n  }", "signature": "public ChangedOAuthFlows setPasswordOAuthFlow(final ChangedOAuthFlow passwordOAuthFlow)"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlows setClientCredentialOAuthFlow(\n      final ChangedOAuthFlow clientCredentialOAuthFlow) {\n    this.clientCredentialOAuthFlow = clientCredentialOAuthFlow;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlows", "classes": []}, "name": "setClientCredentialOAuthFlow", "params": [{"name": "clientCredentialOAuthFlow", "type": "ChangedOAuthFlow"}], "body": "                                                        {\n    this.clientCredentialOAuthFlow = clientCredentialOAuthFlow;\n    return this;\n  }", "signature": "public ChangedOAuthFlows setClientCredentialOAuthFlow(\n      final ChangedOAuthFlow clientCredentialOAuthFlow)"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlows setAuthorizationCodeOAuthFlow(\n      final ChangedOAuthFlow authorizationCodeOAuthFlow) {\n    this.authorizationCodeOAuthFlow = authorizationCodeOAuthFlow;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlows", "classes": []}, "name": "setAuthorizationCodeOAuthFlow", "params": [{"name": "authorizationCodeOAuthFlow", "type": "ChangedOAuthFlow"}], "body": "                                                         {\n    this.authorizationCodeOAuthFlow = authorizationCodeOAuthFlow;\n    return this;\n  }", "signature": "public ChangedOAuthFlows setAuthorizationCodeOAuthFlow(\n      final ChangedOAuthFlow authorizationCodeOAuthFlow)"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlows setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlows", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                             {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedOAuthFlows setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOAuthFlows that = (ChangedOAuthFlows) o;\n    return Objects.equals(oldOAuthFlows, that.oldOAuthFlows)\n        && Objects.equals(newOAuthFlows, that.newOAuthFlows)\n        && Objects.equals(implicitOAuthFlow, that.implicitOAuthFlow)\n        && Objects.equals(passwordOAuthFlow, that.passwordOAuthFlow)\n        && Objects.equals(clientCredentialOAuthFlow, that.clientCredentialOAuthFlow)\n        && Objects.equals(authorizationCodeOAuthFlow, that.authorizationCodeOAuthFlow)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOAuthFlows that = (ChangedOAuthFlows) o;\n    return Objects.equals(oldOAuthFlows, that.oldOAuthFlows)\n        && Objects.equals(newOAuthFlows, that.newOAuthFlows)\n        && Objects.equals(implicitOAuthFlow, that.implicitOAuthFlow)\n        && Objects.equals(passwordOAuthFlow, that.passwordOAuthFlow)\n        && Objects.equals(clientCredentialOAuthFlow, that.clientCredentialOAuthFlow)\n        && Objects.equals(authorizationCodeOAuthFlow, that.authorizationCodeOAuthFlow)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldOAuthFlows,\n        newOAuthFlows,\n        implicitOAuthFlow,\n        passwordOAuthFlow,\n        clientCredentialOAuthFlow,\n        authorizationCodeOAuthFlow,\n        extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldOAuthFlows,\n        newOAuthFlows,\n        implicitOAuthFlow,\n        passwordOAuthFlow,\n        clientCredentialOAuthFlow,\n        authorizationCodeOAuthFlow,\n        extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOAuthFlows(oldOAuthFlows=\"\n        + this.getOldOAuthFlows()\n        + \", newOAuthFlows=\"\n        + this.getNewOAuthFlows()\n        + \", implicitOAuthFlow=\"\n        + this.getImplicitOAuthFlow()\n        + \", passwordOAuthFlow=\"\n        + this.getPasswordOAuthFlow()\n        + \", clientCredentialOAuthFlow=\"\n        + this.getClientCredentialOAuthFlow()\n        + \", authorizationCodeOAuthFlow=\"\n        + this.getAuthorizationCodeOAuthFlow()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedOAuthFlows(oldOAuthFlows=\"\n        + this.getOldOAuthFlows()\n        + \", newOAuthFlows=\"\n        + this.getNewOAuthFlows()\n        + \", implicitOAuthFlow=\"\n        + this.getImplicitOAuthFlow()\n        + \", passwordOAuthFlow=\"\n        + this.getPasswordOAuthFlow()\n        + \", clientCredentialOAuthFlow=\"\n        + this.getClientCredentialOAuthFlow()\n        + \", authorizationCodeOAuthFlow=\"\n        + this.getAuthorizationCodeOAuthFlow()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedSecuritySchemeScopes.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport java.util.List;\n\npublic class ChangedSecuritySchemeScopes extends ChangedList<String> {\n\n  public ChangedSecuritySchemeScopes(List<String> oldValue, List<String> newValue) {\n    super(oldValue, newValue, null);\n  }\n\n  @Override\n  public DiffResult isItemsChanged() {\n    return DiffResult.INCOMPATIBLE;\n  }\n}\n", "file_hash": "415315fd4c9400d347dacc72653a001af27f90b86cb7ea32ad69bd382d56a347", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import java.util.List;"], "methods": [], "classes": [{"original_string": "public class ChangedSecuritySchemeScopes extends ChangedList<String> {\n\n  public ChangedSecuritySchemeScopes(List<String> oldValue, List<String> newValue) {\n    super(oldValue, newValue, null);\n  }\n\n  @Override\n  public DiffResult isItemsChanged() {\n    return DiffResult.INCOMPATIBLE;\n  }\n}", "definition": "public class ChangedSecuritySchemeScopes extends ChangedList<String>", "class_docstring": "", "name": "ChangedSecuritySchemeScopes", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedSecuritySchemeScopes(List<String> oldValue, List<String> newValue) {\n    super(oldValue, newValue, null);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedSecuritySchemeScopes", "params": [{"name": "oldValue", "type": "List<String>"}, {"name": "newValue", "type": "List<String>"}], "body": "                                                                                   {\n    super(oldValue, newValue, null);\n  }", "signature": "public ChangedSecuritySchemeScopes(List<String> oldValue, List<String> newValue)"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isItemsChanged() {\n    return DiffResult.INCOMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isItemsChanged", "params": [], "body": "                                     {\n    return DiffResult.INCOMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isItemsChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedOperation.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.Changed.result;\n\nimport io.swagger.v3.oas.models.Operation;\nimport io.swagger.v3.oas.models.PathItem;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedOperation implements ComposedChanged {\n  private Operation oldOperation;\n  private Operation newOperation;\n  private String pathUrl;\n  private PathItem.HttpMethod httpMethod;\n  private ChangedMetadata summary;\n  private ChangedMetadata description;\n  private ChangedMetadata operationId;\n  private boolean deprecated;\n  private ChangedParameters parameters;\n  private ChangedRequestBody requestBody;\n  private ChangedApiResponse apiResponses;\n  private ChangedSecurityRequirements securityRequirements;\n  private ChangedExtensions extensions;\n\n  public ChangedOperation(\n      String pathUrl,\n      PathItem.HttpMethod httpMethod,\n      Operation oldOperation,\n      Operation newOperation) {\n    this.httpMethod = httpMethod;\n    this.pathUrl = pathUrl;\n    this.oldOperation = oldOperation;\n    this.newOperation = newOperation;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(\n        summary,\n        description,\n        operationId,\n        parameters,\n        requestBody,\n        apiResponses,\n        securityRequirements,\n        extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    // TODO BETTER HANDLING FOR DEPRECIATION\n    if (deprecated) {\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.NO_CHANGES;\n  }\n\n  public DiffResult resultApiResponses() {\n    return result(apiResponses);\n  }\n\n  public DiffResult resultRequestBody() {\n    return requestBody == null ? DiffResult.NO_CHANGES : requestBody.isChanged();\n  }\n\n  public DiffResult resultSecurityRequirements() {\n    return securityRequirements == null ? DiffResult.NO_CHANGES : securityRequirements.isChanged();\n  }\n\n  public Operation getOldOperation() {\n    return this.oldOperation;\n  }\n\n  public Operation getNewOperation() {\n    return this.newOperation;\n  }\n\n  public String getPathUrl() {\n    return this.pathUrl;\n  }\n\n  public PathItem.HttpMethod getHttpMethod() {\n    return this.httpMethod;\n  }\n\n  public ChangedMetadata getSummary() {\n    return this.summary;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedMetadata getOperationId() {\n    return this.operationId;\n  }\n\n  public boolean isDeprecated() {\n    return this.deprecated;\n  }\n\n  public ChangedParameters getParameters() {\n    return this.parameters;\n  }\n\n  public ChangedRequestBody getRequestBody() {\n    return this.requestBody;\n  }\n\n  public ChangedApiResponse getApiResponses() {\n    return this.apiResponses;\n  }\n\n  public ChangedSecurityRequirements getSecurityRequirements() {\n    return this.securityRequirements;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedOperation setOldOperation(final Operation oldOperation) {\n    this.oldOperation = oldOperation;\n    return this;\n  }\n\n  public ChangedOperation setNewOperation(final Operation newOperation) {\n    this.newOperation = newOperation;\n    return this;\n  }\n\n  public ChangedOperation setPathUrl(final String pathUrl) {\n    this.pathUrl = pathUrl;\n    return this;\n  }\n\n  public ChangedOperation setHttpMethod(final PathItem.HttpMethod httpMethod) {\n    this.httpMethod = httpMethod;\n    return this;\n  }\n\n  public ChangedOperation setSummary(final ChangedMetadata summary) {\n    this.summary = summary;\n    return this;\n  }\n\n  public ChangedOperation setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedOperation setOperationId(final ChangedMetadata operationId) {\n    this.operationId = operationId;\n    return this;\n  }\n\n  public ChangedOperation setDeprecated(final boolean deprecated) {\n    this.deprecated = deprecated;\n    return this;\n  }\n\n  public ChangedOperation setParameters(final ChangedParameters parameters) {\n    this.parameters = parameters;\n    return this;\n  }\n\n  public ChangedOperation setRequestBody(final ChangedRequestBody requestBody) {\n    this.requestBody = requestBody;\n    return this;\n  }\n\n  public ChangedOperation setApiResponses(final ChangedApiResponse apiResponses) {\n    this.apiResponses = apiResponses;\n    return this;\n  }\n\n  public ChangedOperation setSecurityRequirements(\n      final ChangedSecurityRequirements securityRequirements) {\n    this.securityRequirements = securityRequirements;\n    return this;\n  }\n\n  public ChangedOperation setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOperation that = (ChangedOperation) o;\n    return deprecated == that.deprecated\n        && Objects.equals(oldOperation, that.oldOperation)\n        && Objects.equals(newOperation, that.newOperation)\n        && Objects.equals(pathUrl, that.pathUrl)\n        && httpMethod == that.httpMethod\n        && Objects.equals(summary, that.summary)\n        && Objects.equals(description, that.description)\n        && Objects.equals(operationId, that.operationId)\n        && Objects.equals(parameters, that.parameters)\n        && Objects.equals(requestBody, that.requestBody)\n        && Objects.equals(apiResponses, that.apiResponses)\n        && Objects.equals(securityRequirements, that.securityRequirements)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldOperation,\n        newOperation,\n        pathUrl,\n        httpMethod,\n        summary,\n        description,\n        operationId,\n        deprecated,\n        parameters,\n        requestBody,\n        apiResponses,\n        securityRequirements,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOperation(oldOperation=\"\n        + this.getOldOperation()\n        + \", newOperation=\"\n        + this.getNewOperation()\n        + \", pathUrl=\"\n        + this.getPathUrl()\n        + \", httpMethod=\"\n        + this.getHttpMethod()\n        + \", summary=\"\n        + this.getSummary()\n        + \", description=\"\n        + this.getDescription()\n        + \", operationId=\"\n        + this.getOperationId()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", parameters=\"\n        + this.getParameters()\n        + \", requestBody=\"\n        + this.getRequestBody()\n        + \", apiResponses=\"\n        + this.getApiResponses()\n        + \", securityRequirements=\"\n        + this.getSecurityRequirements()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "ecf13c4948f93eda86ffa98e131358e103e6dc278b3daf2cdc418321d8d2f70d", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.Changed.result;", "import io.swagger.v3.oas.models.Operation;", "import io.swagger.v3.oas.models.PathItem;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedOperation implements ComposedChanged {\n  private Operation oldOperation;\n  private Operation newOperation;\n  private String pathUrl;\n  private PathItem.HttpMethod httpMethod;\n  private ChangedMetadata summary;\n  private ChangedMetadata description;\n  private ChangedMetadata operationId;\n  private boolean deprecated;\n  private ChangedParameters parameters;\n  private ChangedRequestBody requestBody;\n  private ChangedApiResponse apiResponses;\n  private ChangedSecurityRequirements securityRequirements;\n  private ChangedExtensions extensions;\n\n  public ChangedOperation(\n      String pathUrl,\n      PathItem.HttpMethod httpMethod,\n      Operation oldOperation,\n      Operation newOperation) {\n    this.httpMethod = httpMethod;\n    this.pathUrl = pathUrl;\n    this.oldOperation = oldOperation;\n    this.newOperation = newOperation;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(\n        summary,\n        description,\n        operationId,\n        parameters,\n        requestBody,\n        apiResponses,\n        securityRequirements,\n        extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    // TODO BETTER HANDLING FOR DEPRECIATION\n    if (deprecated) {\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.NO_CHANGES;\n  }\n\n  public DiffResult resultApiResponses() {\n    return result(apiResponses);\n  }\n\n  public DiffResult resultRequestBody() {\n    return requestBody == null ? DiffResult.NO_CHANGES : requestBody.isChanged();\n  }\n\n  public DiffResult resultSecurityRequirements() {\n    return securityRequirements == null ? DiffResult.NO_CHANGES : securityRequirements.isChanged();\n  }\n\n  public Operation getOldOperation() {\n    return this.oldOperation;\n  }\n\n  public Operation getNewOperation() {\n    return this.newOperation;\n  }\n\n  public String getPathUrl() {\n    return this.pathUrl;\n  }\n\n  public PathItem.HttpMethod getHttpMethod() {\n    return this.httpMethod;\n  }\n\n  public ChangedMetadata getSummary() {\n    return this.summary;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedMetadata getOperationId() {\n    return this.operationId;\n  }\n\n  public boolean isDeprecated() {\n    return this.deprecated;\n  }\n\n  public ChangedParameters getParameters() {\n    return this.parameters;\n  }\n\n  public ChangedRequestBody getRequestBody() {\n    return this.requestBody;\n  }\n\n  public ChangedApiResponse getApiResponses() {\n    return this.apiResponses;\n  }\n\n  public ChangedSecurityRequirements getSecurityRequirements() {\n    return this.securityRequirements;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedOperation setOldOperation(final Operation oldOperation) {\n    this.oldOperation = oldOperation;\n    return this;\n  }\n\n  public ChangedOperation setNewOperation(final Operation newOperation) {\n    this.newOperation = newOperation;\n    return this;\n  }\n\n  public ChangedOperation setPathUrl(final String pathUrl) {\n    this.pathUrl = pathUrl;\n    return this;\n  }\n\n  public ChangedOperation setHttpMethod(final PathItem.HttpMethod httpMethod) {\n    this.httpMethod = httpMethod;\n    return this;\n  }\n\n  public ChangedOperation setSummary(final ChangedMetadata summary) {\n    this.summary = summary;\n    return this;\n  }\n\n  public ChangedOperation setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedOperation setOperationId(final ChangedMetadata operationId) {\n    this.operationId = operationId;\n    return this;\n  }\n\n  public ChangedOperation setDeprecated(final boolean deprecated) {\n    this.deprecated = deprecated;\n    return this;\n  }\n\n  public ChangedOperation setParameters(final ChangedParameters parameters) {\n    this.parameters = parameters;\n    return this;\n  }\n\n  public ChangedOperation setRequestBody(final ChangedRequestBody requestBody) {\n    this.requestBody = requestBody;\n    return this;\n  }\n\n  public ChangedOperation setApiResponses(final ChangedApiResponse apiResponses) {\n    this.apiResponses = apiResponses;\n    return this;\n  }\n\n  public ChangedOperation setSecurityRequirements(\n      final ChangedSecurityRequirements securityRequirements) {\n    this.securityRequirements = securityRequirements;\n    return this;\n  }\n\n  public ChangedOperation setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOperation that = (ChangedOperation) o;\n    return deprecated == that.deprecated\n        && Objects.equals(oldOperation, that.oldOperation)\n        && Objects.equals(newOperation, that.newOperation)\n        && Objects.equals(pathUrl, that.pathUrl)\n        && httpMethod == that.httpMethod\n        && Objects.equals(summary, that.summary)\n        && Objects.equals(description, that.description)\n        && Objects.equals(operationId, that.operationId)\n        && Objects.equals(parameters, that.parameters)\n        && Objects.equals(requestBody, that.requestBody)\n        && Objects.equals(apiResponses, that.apiResponses)\n        && Objects.equals(securityRequirements, that.securityRequirements)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldOperation,\n        newOperation,\n        pathUrl,\n        httpMethod,\n        summary,\n        description,\n        operationId,\n        deprecated,\n        parameters,\n        requestBody,\n        apiResponses,\n        securityRequirements,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOperation(oldOperation=\"\n        + this.getOldOperation()\n        + \", newOperation=\"\n        + this.getNewOperation()\n        + \", pathUrl=\"\n        + this.getPathUrl()\n        + \", httpMethod=\"\n        + this.getHttpMethod()\n        + \", summary=\"\n        + this.getSummary()\n        + \", description=\"\n        + this.getDescription()\n        + \", operationId=\"\n        + this.getOperationId()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", parameters=\"\n        + this.getParameters()\n        + \", requestBody=\"\n        + this.getRequestBody()\n        + \", apiResponses=\"\n        + this.getApiResponses()\n        + \", securityRequirements=\"\n        + this.getSecurityRequirements()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedOperation implements ComposedChanged", "class_docstring": "", "name": "ChangedOperation", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Operation oldOperation;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Operation", "name": "oldOperation", "syntax_pass": true}, {"attribute_expression": "private Operation newOperation;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Operation", "name": "newOperation", "syntax_pass": true}, {"attribute_expression": "private String pathUrl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "pathUrl", "syntax_pass": true}, {"attribute_expression": "private PathItem.HttpMethod httpMethod;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PathItem.HttpMethod", "name": "httpMethod", "syntax_pass": true}, {"attribute_expression": "private ChangedMetadata summary;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedMetadata", "name": "summary", "syntax_pass": true}, {"attribute_expression": "private ChangedMetadata description;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedMetadata", "name": "description", "syntax_pass": true}, {"attribute_expression": "private ChangedMetadata operationId;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedMetadata", "name": "operationId", "syntax_pass": true}, {"attribute_expression": "private boolean deprecated;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "deprecated", "syntax_pass": true}, {"attribute_expression": "private ChangedParameters parameters;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedParameters", "name": "parameters", "syntax_pass": true}, {"attribute_expression": "private ChangedRequestBody requestBody;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedRequestBody", "name": "requestBody", "syntax_pass": true}, {"attribute_expression": "private ChangedApiResponse apiResponses;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedApiResponse", "name": "apiResponses", "syntax_pass": true}, {"attribute_expression": "private ChangedSecurityRequirements securityRequirements;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedSecurityRequirements", "name": "securityRequirements", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedOperation(\n      String pathUrl,\n      PathItem.HttpMethod httpMethod,\n      Operation oldOperation,\n      Operation newOperation) {\n    this.httpMethod = httpMethod;\n    this.pathUrl = pathUrl;\n    this.oldOperation = oldOperation;\n    this.newOperation = newOperation;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedOperation", "params": [{"name": "pathUrl", "type": "String"}, {"name": "httpMethod", "type": "PathItem.HttpMethod"}, {"name": "oldOperation", "type": "Operation"}, {"name": "newOperation", "type": "Operation"}], "body": "                              {\n    this.httpMethod = httpMethod;\n    this.pathUrl = pathUrl;\n    this.oldOperation = oldOperation;\n    this.newOperation = newOperation;\n  }", "signature": "public ChangedOperation(\n      String pathUrl,\n      PathItem.HttpMethod httpMethod,\n      Operation oldOperation,\n      Operation newOperation)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(\n        summary,\n        description,\n        operationId,\n        parameters,\n        requestBody,\n        apiResponses,\n        securityRequirements,\n        extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Arrays.asList(\n        summary,\n        description,\n        operationId,\n        parameters,\n        requestBody,\n        apiResponses,\n        securityRequirements,\n        extensions);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    // TODO BETTER HANDLING FOR DEPRECIATION\n    if (deprecated) {\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.NO_CHANGES;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    // TODO BETTER HANDLING FOR DEPRECIATION\n    if (deprecated) {\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.NO_CHANGES;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public DiffResult resultApiResponses() {\n    return result(apiResponses);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "resultApiResponses", "params": [], "body": "                                         {\n    return result(apiResponses);\n  }", "signature": "public DiffResult resultApiResponses()"}, {"syntax_pass": true, "original_string": "  public DiffResult resultRequestBody() {\n    return requestBody == null ? DiffResult.NO_CHANGES : requestBody.isChanged();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "resultRequestBody", "params": [], "body": "                                        {\n    return requestBody == null ? DiffResult.NO_CHANGES : requestBody.isChanged();\n  }", "signature": "public DiffResult resultRequestBody()"}, {"syntax_pass": true, "original_string": "  public DiffResult resultSecurityRequirements() {\n    return securityRequirements == null ? DiffResult.NO_CHANGES : securityRequirements.isChanged();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "resultSecurityRequirements", "params": [], "body": "                                                 {\n    return securityRequirements == null ? DiffResult.NO_CHANGES : securityRequirements.isChanged();\n  }", "signature": "public DiffResult resultSecurityRequirements()"}, {"syntax_pass": true, "original_string": "  public Operation getOldOperation() {\n    return this.oldOperation;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Operation", "classes": []}, "name": "getOldOperation", "params": [], "body": "                                     {\n    return this.oldOperation;\n  }", "signature": "public Operation getOldOperation()"}, {"syntax_pass": true, "original_string": "  public Operation getNewOperation() {\n    return this.newOperation;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Operation", "classes": []}, "name": "getNewOperation", "params": [], "body": "                                     {\n    return this.newOperation;\n  }", "signature": "public Operation getNewOperation()"}, {"syntax_pass": true, "original_string": "  public String getPathUrl() {\n    return this.pathUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getPathUrl", "params": [], "body": "                             {\n    return this.pathUrl;\n  }", "signature": "public String getPathUrl()"}, {"syntax_pass": true, "original_string": "  public PathItem.HttpMethod getHttpMethod() {\n    return this.httpMethod;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PathItem.HttpMethod", "classes": []}, "name": "getHttpMethod", "params": [], "body": "                                             {\n    return this.httpMethod;\n  }", "signature": "public PathItem.HttpMethod getHttpMethod()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata getSummary() {\n    return this.summary;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "getSummary", "params": [], "body": "                                      {\n    return this.summary;\n  }", "signature": "public ChangedMetadata getSummary()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata getDescription() {\n    return this.description;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "getDescription", "params": [], "body": "                                          {\n    return this.description;\n  }", "signature": "public ChangedMetadata getDescription()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata getOperationId() {\n    return this.operationId;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "getOperationId", "params": [], "body": "                                          {\n    return this.operationId;\n  }", "signature": "public ChangedMetadata getOperationId()"}, {"syntax_pass": true, "original_string": "  public boolean isDeprecated() {\n    return this.deprecated;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDeprecated", "params": [], "body": "                                {\n    return this.deprecated;\n  }", "signature": "public boolean isDeprecated()"}, {"syntax_pass": true, "original_string": "  public ChangedParameters getParameters() {\n    return this.parameters;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedParameters", "classes": []}, "name": "getParameters", "params": [], "body": "                                           {\n    return this.parameters;\n  }", "signature": "public ChangedParameters getParameters()"}, {"syntax_pass": true, "original_string": "  public ChangedRequestBody getRequestBody() {\n    return this.requestBody;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedRequestBody", "classes": []}, "name": "getRequestBody", "params": [], "body": "                                             {\n    return this.requestBody;\n  }", "signature": "public ChangedRequestBody getRequestBody()"}, {"syntax_pass": true, "original_string": "  public ChangedApiResponse getApiResponses() {\n    return this.apiResponses;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedApiResponse", "classes": []}, "name": "getApiResponses", "params": [], "body": "                                              {\n    return this.apiResponses;\n  }", "signature": "public ChangedApiResponse getApiResponses()"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityRequirements getSecurityRequirements() {\n    return this.securityRequirements;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityRequirements", "classes": []}, "name": "getSecurityRequirements", "params": [], "body": "                                                               {\n    return this.securityRequirements;\n  }", "signature": "public ChangedSecurityRequirements getSecurityRequirements()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setOldOperation(final Operation oldOperation) {\n    this.oldOperation = oldOperation;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setOldOperation", "params": [{"name": "oldOperation", "type": "Operation"}], "body": "                                                                        {\n    this.oldOperation = oldOperation;\n    return this;\n  }", "signature": "public ChangedOperation setOldOperation(final Operation oldOperation)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setNewOperation(final Operation newOperation) {\n    this.newOperation = newOperation;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setNewOperation", "params": [{"name": "newOperation", "type": "Operation"}], "body": "                                                                        {\n    this.newOperation = newOperation;\n    return this;\n  }", "signature": "public ChangedOperation setNewOperation(final Operation newOperation)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setPathUrl(final String pathUrl) {\n    this.pathUrl = pathUrl;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setPathUrl", "params": [{"name": "pathUrl", "type": "String"}], "body": "                                                           {\n    this.pathUrl = pathUrl;\n    return this;\n  }", "signature": "public ChangedOperation setPathUrl(final String pathUrl)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setHttpMethod(final PathItem.HttpMethod httpMethod) {\n    this.httpMethod = httpMethod;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setHttpMethod", "params": [{"name": "httpMethod", "type": "PathItem.HttpMethod"}], "body": "                                                                              {\n    this.httpMethod = httpMethod;\n    return this;\n  }", "signature": "public ChangedOperation setHttpMethod(final PathItem.HttpMethod httpMethod)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setSummary(final ChangedMetadata summary) {\n    this.summary = summary;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setSummary", "params": [{"name": "summary", "type": "ChangedMetadata"}], "body": "                                                                    {\n    this.summary = summary;\n    return this;\n  }", "signature": "public ChangedOperation setSummary(final ChangedMetadata summary)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "ChangedMetadata"}], "body": "                                                                            {\n    this.description = description;\n    return this;\n  }", "signature": "public ChangedOperation setDescription(final ChangedMetadata description)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setOperationId(final ChangedMetadata operationId) {\n    this.operationId = operationId;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setOperationId", "params": [{"name": "operationId", "type": "ChangedMetadata"}], "body": "                                                                            {\n    this.operationId = operationId;\n    return this;\n  }", "signature": "public ChangedOperation setOperationId(final ChangedMetadata operationId)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setDeprecated(final boolean deprecated) {\n    this.deprecated = deprecated;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setDeprecated", "params": [{"name": "deprecated", "type": "boolean"}], "body": "                                                                  {\n    this.deprecated = deprecated;\n    return this;\n  }", "signature": "public ChangedOperation setDeprecated(final boolean deprecated)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setParameters(final ChangedParameters parameters) {\n    this.parameters = parameters;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setParameters", "params": [{"name": "parameters", "type": "ChangedParameters"}], "body": "                                                                            {\n    this.parameters = parameters;\n    return this;\n  }", "signature": "public ChangedOperation setParameters(final ChangedParameters parameters)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setRequestBody(final ChangedRequestBody requestBody) {\n    this.requestBody = requestBody;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setRequestBody", "params": [{"name": "requestBody", "type": "ChangedRequestBody"}], "body": "                                                                               {\n    this.requestBody = requestBody;\n    return this;\n  }", "signature": "public ChangedOperation setRequestBody(final ChangedRequestBody requestBody)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setApiResponses(final ChangedApiResponse apiResponses) {\n    this.apiResponses = apiResponses;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setApiResponses", "params": [{"name": "apiResponses", "type": "ChangedApiResponse"}], "body": "                                                                                 {\n    this.apiResponses = apiResponses;\n    return this;\n  }", "signature": "public ChangedOperation setApiResponses(final ChangedApiResponse apiResponses)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setSecurityRequirements(\n      final ChangedSecurityRequirements securityRequirements) {\n    this.securityRequirements = securityRequirements;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setSecurityRequirements", "params": [{"name": "securityRequirements", "type": "ChangedSecurityRequirements"}], "body": "                                                              {\n    this.securityRequirements = securityRequirements;\n    return this;\n  }", "signature": "public ChangedOperation setSecurityRequirements(\n      final ChangedSecurityRequirements securityRequirements)"}, {"syntax_pass": true, "original_string": "  public ChangedOperation setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOperation", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                            {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedOperation setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOperation that = (ChangedOperation) o;\n    return deprecated == that.deprecated\n        && Objects.equals(oldOperation, that.oldOperation)\n        && Objects.equals(newOperation, that.newOperation)\n        && Objects.equals(pathUrl, that.pathUrl)\n        && httpMethod == that.httpMethod\n        && Objects.equals(summary, that.summary)\n        && Objects.equals(description, that.description)\n        && Objects.equals(operationId, that.operationId)\n        && Objects.equals(parameters, that.parameters)\n        && Objects.equals(requestBody, that.requestBody)\n        && Objects.equals(apiResponses, that.apiResponses)\n        && Objects.equals(securityRequirements, that.securityRequirements)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOperation that = (ChangedOperation) o;\n    return deprecated == that.deprecated\n        && Objects.equals(oldOperation, that.oldOperation)\n        && Objects.equals(newOperation, that.newOperation)\n        && Objects.equals(pathUrl, that.pathUrl)\n        && httpMethod == that.httpMethod\n        && Objects.equals(summary, that.summary)\n        && Objects.equals(description, that.description)\n        && Objects.equals(operationId, that.operationId)\n        && Objects.equals(parameters, that.parameters)\n        && Objects.equals(requestBody, that.requestBody)\n        && Objects.equals(apiResponses, that.apiResponses)\n        && Objects.equals(securityRequirements, that.securityRequirements)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldOperation,\n        newOperation,\n        pathUrl,\n        httpMethod,\n        summary,\n        description,\n        operationId,\n        deprecated,\n        parameters,\n        requestBody,\n        apiResponses,\n        securityRequirements,\n        extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldOperation,\n        newOperation,\n        pathUrl,\n        httpMethod,\n        summary,\n        description,\n        operationId,\n        deprecated,\n        parameters,\n        requestBody,\n        apiResponses,\n        securityRequirements,\n        extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOperation(oldOperation=\"\n        + this.getOldOperation()\n        + \", newOperation=\"\n        + this.getNewOperation()\n        + \", pathUrl=\"\n        + this.getPathUrl()\n        + \", httpMethod=\"\n        + this.getHttpMethod()\n        + \", summary=\"\n        + this.getSummary()\n        + \", description=\"\n        + this.getDescription()\n        + \", operationId=\"\n        + this.getOperationId()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", parameters=\"\n        + this.getParameters()\n        + \", requestBody=\"\n        + this.getRequestBody()\n        + \", apiResponses=\"\n        + this.getApiResponses()\n        + \", securityRequirements=\"\n        + this.getSecurityRequirements()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedOperation(oldOperation=\"\n        + this.getOldOperation()\n        + \", newOperation=\"\n        + this.getNewOperation()\n        + \", pathUrl=\"\n        + this.getPathUrl()\n        + \", httpMethod=\"\n        + this.getHttpMethod()\n        + \", summary=\"\n        + this.getSummary()\n        + \", description=\"\n        + this.getDescription()\n        + \", operationId=\"\n        + this.getOperationId()\n        + \", deprecated=\"\n        + this.isDeprecated()\n        + \", parameters=\"\n        + this.getParameters()\n        + \", requestBody=\"\n        + this.getRequestBody()\n        + \", apiResponses=\"\n        + this.getApiResponses()\n        + \", securityRequirements=\"\n        + this.getSecurityRequirements()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedList.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\n\npublic abstract class ChangedList<T> implements Changed {\n  protected DiffContext context;\n  protected List<T> oldValue;\n  protected List<T> newValue;\n  private List<T> increased;\n  private List<T> missing;\n  private List<T> shared;\n\n  protected ChangedList(List<T> oldValue, List<T> newValue, DiffContext context) {\n    this.oldValue = Optional.ofNullable(oldValue).orElse(new ArrayList<>());\n    this.newValue = Optional.ofNullable(newValue).orElse(new ArrayList<>());\n    this.context = context;\n    this.shared = new ArrayList<>();\n    this.increased = new ArrayList<>();\n    this.missing = new ArrayList<>();\n  }\n\n  @Override\n  public DiffResult isChanged() {\n    if (missing.isEmpty() && increased.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    return isItemsChanged();\n  }\n\n  public abstract DiffResult isItemsChanged();\n\n  public static class SimpleChangedList<T> extends ChangedList<T> {\n    public SimpleChangedList(List<T> oldValue, List<T> newValue) {\n      super(oldValue, newValue, null);\n    }\n\n    @Override\n    public DiffResult isItemsChanged() {\n      return DiffResult.UNKNOWN;\n    }\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public List<T> getOldValue() {\n    return this.oldValue;\n  }\n\n  public List<T> getNewValue() {\n    return this.newValue;\n  }\n\n  public List<T> getIncreased() {\n    return this.increased;\n  }\n\n  public List<T> getMissing() {\n    return this.missing;\n  }\n\n  public List<T> getShared() {\n    return this.shared;\n  }\n\n  public ChangedList<T> setContext(final DiffContext context) {\n    this.context = context;\n    return this;\n  }\n\n  public ChangedList<T> setOldValue(final List<T> oldValue) {\n    this.oldValue = oldValue;\n    return this;\n  }\n\n  public ChangedList<T> setNewValue(final List<T> newValue) {\n    this.newValue = newValue;\n    return this;\n  }\n\n  public ChangedList<T> setIncreased(final List<T> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedList<T> setMissing(final List<T> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedList<T> setShared(final List<T> shared) {\n    this.shared = shared;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedList<?> that = (ChangedList<?>) o;\n    return Objects.equals(context, that.context)\n        && Objects.equals(oldValue, that.oldValue)\n        && Objects.equals(newValue, that.newValue)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(shared, that.shared);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(context, oldValue, newValue, increased, missing, shared);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedList(context=\"\n        + this.getContext()\n        + \", oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", shared=\"\n        + this.getShared()\n        + \")\";\n  }\n}\n", "file_hash": "a6c8ab4d93bb1923287010a94fddadd316f9acd1760efd2aead897e4a5be72f3", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Objects;", "import java.util.Optional;"], "methods": [], "classes": [{"original_string": "public abstract class ChangedList<T> implements Changed {\n  protected DiffContext context;\n  protected List<T> oldValue;\n  protected List<T> newValue;\n  private List<T> increased;\n  private List<T> missing;\n  private List<T> shared;\n\n  protected ChangedList(List<T> oldValue, List<T> newValue, DiffContext context) {\n    this.oldValue = Optional.ofNullable(oldValue).orElse(new ArrayList<>());\n    this.newValue = Optional.ofNullable(newValue).orElse(new ArrayList<>());\n    this.context = context;\n    this.shared = new ArrayList<>();\n    this.increased = new ArrayList<>();\n    this.missing = new ArrayList<>();\n  }\n\n  @Override\n  public DiffResult isChanged() {\n    if (missing.isEmpty() && increased.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    return isItemsChanged();\n  }\n\n  public abstract DiffResult isItemsChanged();\n\n  public static class SimpleChangedList<T> extends ChangedList<T> {\n    public SimpleChangedList(List<T> oldValue, List<T> newValue) {\n      super(oldValue, newValue, null);\n    }\n\n    @Override\n    public DiffResult isItemsChanged() {\n      return DiffResult.UNKNOWN;\n    }\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public List<T> getOldValue() {\n    return this.oldValue;\n  }\n\n  public List<T> getNewValue() {\n    return this.newValue;\n  }\n\n  public List<T> getIncreased() {\n    return this.increased;\n  }\n\n  public List<T> getMissing() {\n    return this.missing;\n  }\n\n  public List<T> getShared() {\n    return this.shared;\n  }\n\n  public ChangedList<T> setContext(final DiffContext context) {\n    this.context = context;\n    return this;\n  }\n\n  public ChangedList<T> setOldValue(final List<T> oldValue) {\n    this.oldValue = oldValue;\n    return this;\n  }\n\n  public ChangedList<T> setNewValue(final List<T> newValue) {\n    this.newValue = newValue;\n    return this;\n  }\n\n  public ChangedList<T> setIncreased(final List<T> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedList<T> setMissing(final List<T> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedList<T> setShared(final List<T> shared) {\n    this.shared = shared;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedList<?> that = (ChangedList<?>) o;\n    return Objects.equals(context, that.context)\n        && Objects.equals(oldValue, that.oldValue)\n        && Objects.equals(newValue, that.newValue)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(shared, that.shared);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(context, oldValue, newValue, increased, missing, shared);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedList(context=\"\n        + this.getContext()\n        + \", oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", shared=\"\n        + this.getShared()\n        + \")\";\n  }\n}", "definition": "public abstract class ChangedList<T> implements Changed", "class_docstring": "", "name": "ChangedList", "super_interfaces": ["Changed"], "superclasses": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [{"attribute_expression": "protected DiffContext context;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "protected List<T> oldValue;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<T>", "name": "oldValue", "syntax_pass": true}, {"attribute_expression": "protected List<T> newValue;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<T>", "name": "newValue", "syntax_pass": true}, {"attribute_expression": "private List<T> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<T>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private List<T> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<T>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private List<T> shared;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<T>", "name": "shared", "syntax_pass": true}], "classes": [{"original_string": "  public static class SimpleChangedList<T> extends ChangedList<T> {\n    public SimpleChangedList(List<T> oldValue, List<T> newValue) {\n      super(oldValue, newValue, null);\n    }\n\n    @Override\n    public DiffResult isItemsChanged() {\n      return DiffResult.UNKNOWN;\n    }\n  }", "definition": "  public static class SimpleChangedList<T> extends ChangedList<T>", "class_docstring": "", "name": "SimpleChangedList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public SimpleChangedList(List<T> oldValue, List<T> newValue) {\n      super(oldValue, newValue, null);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SimpleChangedList", "params": [{"name": "oldValue", "type": "List<T>"}, {"name": "newValue", "type": "List<T>"}], "body": "                                                                 {\n      super(oldValue, newValue, null);\n    }", "signature": "public SimpleChangedList(List<T> oldValue, List<T> newValue)"}, {"syntax_pass": true, "original_string": "    @Override\n    public DiffResult isItemsChanged() {\n      return DiffResult.UNKNOWN;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isItemsChanged", "params": [], "body": "                                       {\n      return DiffResult.UNKNOWN;\n    }", "signature": "@Override\n    public DiffResult isItemsChanged()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  protected ChangedList(List<T> oldValue, List<T> newValue, DiffContext context) {\n    this.oldValue = Optional.ofNullable(oldValue).orElse(new ArrayList<>());\n    this.newValue = Optional.ofNullable(newValue).orElse(new ArrayList<>());\n    this.context = context;\n    this.shared = new ArrayList<>();\n    this.increased = new ArrayList<>();\n    this.missing = new ArrayList<>();\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedList", "params": [{"name": "oldValue", "type": "List<T>"}, {"name": "newValue", "type": "List<T>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                 {\n    this.oldValue = Optional.ofNullable(oldValue).orElse(new ArrayList<>());\n    this.newValue = Optional.ofNullable(newValue).orElse(new ArrayList<>());\n    this.context = context;\n    this.shared = new ArrayList<>();\n    this.increased = new ArrayList<>();\n    this.missing = new ArrayList<>();\n  }", "signature": "protected ChangedList(List<T> oldValue, List<T> newValue, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isChanged() {\n    if (missing.isEmpty() && increased.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    return isItemsChanged();\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isChanged", "params": [], "body": "                                {\n    if (missing.isEmpty() && increased.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    return isItemsChanged();\n  }", "signature": "@Override\n  public DiffResult isChanged()"}, {"syntax_pass": true, "original_string": "  public abstract DiffResult isItemsChanged();", "docstring": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isItemsChanged", "params": [], "body": "", "signature": "public abstract DiffResult isItemsChanged()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public List<T> getOldValue() {\n    return this.oldValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "getOldValue", "params": [], "body": "                               {\n    return this.oldValue;\n  }", "signature": "public List<T> getOldValue()"}, {"syntax_pass": true, "original_string": "  public List<T> getNewValue() {\n    return this.newValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "getNewValue", "params": [], "body": "                               {\n    return this.newValue;\n  }", "signature": "public List<T> getNewValue()"}, {"syntax_pass": true, "original_string": "  public List<T> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                {\n    return this.increased;\n  }", "signature": "public List<T> getIncreased()"}, {"syntax_pass": true, "original_string": "  public List<T> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "getMissing", "params": [], "body": "                              {\n    return this.missing;\n  }", "signature": "public List<T> getMissing()"}, {"syntax_pass": true, "original_string": "  public List<T> getShared() {\n    return this.shared;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "getShared", "params": [], "body": "                             {\n    return this.shared;\n  }", "signature": "public List<T> getShared()"}, {"syntax_pass": true, "original_string": "  public ChangedList<T> setContext(final DiffContext context) {\n    this.context = context;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedList<T>", "classes": []}, "name": "setContext", "params": [{"name": "context", "type": "DiffContext"}], "body": "                                                              {\n    this.context = context;\n    return this;\n  }", "signature": "public ChangedList<T> setContext(final DiffContext context)"}, {"syntax_pass": true, "original_string": "  public ChangedList<T> setOldValue(final List<T> oldValue) {\n    this.oldValue = oldValue;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedList<T>", "classes": []}, "name": "setOldValue", "params": [{"name": "oldValue", "type": "List<T>"}], "body": "                                                            {\n    this.oldValue = oldValue;\n    return this;\n  }", "signature": "public ChangedList<T> setOldValue(final List<T> oldValue)"}, {"syntax_pass": true, "original_string": "  public ChangedList<T> setNewValue(final List<T> newValue) {\n    this.newValue = newValue;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedList<T>", "classes": []}, "name": "setNewValue", "params": [{"name": "newValue", "type": "List<T>"}], "body": "                                                            {\n    this.newValue = newValue;\n    return this;\n  }", "signature": "public ChangedList<T> setNewValue(final List<T> newValue)"}, {"syntax_pass": true, "original_string": "  public ChangedList<T> setIncreased(final List<T> increased) {\n    this.increased = increased;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedList<T>", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "List<T>"}], "body": "                                                              {\n    this.increased = increased;\n    return this;\n  }", "signature": "public ChangedList<T> setIncreased(final List<T> increased)"}, {"syntax_pass": true, "original_string": "  public ChangedList<T> setMissing(final List<T> missing) {\n    this.missing = missing;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedList<T>", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "List<T>"}], "body": "                                                          {\n    this.missing = missing;\n    return this;\n  }", "signature": "public ChangedList<T> setMissing(final List<T> missing)"}, {"syntax_pass": true, "original_string": "  public ChangedList<T> setShared(final List<T> shared) {\n    this.shared = shared;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedList<T>", "classes": []}, "name": "setShared", "params": [{"name": "shared", "type": "List<T>"}], "body": "                                                        {\n    this.shared = shared;\n    return this;\n  }", "signature": "public ChangedList<T> setShared(final List<T> shared)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedList<?> that = (ChangedList<?>) o;\n    return Objects.equals(context, that.context)\n        && Objects.equals(oldValue, that.oldValue)\n        && Objects.equals(newValue, that.newValue)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(shared, that.shared);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedList<?> that = (ChangedList<?>) o;\n    return Objects.equals(context, that.context)\n        && Objects.equals(oldValue, that.oldValue)\n        && Objects.equals(newValue, that.newValue)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(shared, that.shared);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(context, oldValue, newValue, increased, missing, shared);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(context, oldValue, newValue, increased, missing, shared);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedList(context=\"\n        + this.getContext()\n        + \", oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", shared=\"\n        + this.getShared()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedList(context=\"\n        + this.getContext()\n        + \", oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", shared=\"\n        + this.getShared()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedMetadata.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport java.util.Objects;\n\npublic class ChangedMetadata implements Changed {\n  private String left;\n  private String right;\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(left, right)) {\n      return DiffResult.NO_CHANGES;\n    }\n    return DiffResult.METADATA;\n  }\n\n  public String getLeft() {\n    return this.left;\n  }\n\n  public String getRight() {\n    return this.right;\n  }\n\n  public ChangedMetadata setLeft(final String left) {\n    this.left = left;\n    return this;\n  }\n\n  public ChangedMetadata setRight(final String right) {\n    this.right = right;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMetadata that = (ChangedMetadata) o;\n    return Objects.equals(left, that.left) && Objects.equals(right, that.right);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(left, right);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedMetadata(left=\" + this.getLeft() + \", right=\" + this.getRight() + \")\";\n  }\n}\n", "file_hash": "787664ca6b08a6d5acf0a6eb19b2dbbafb2f08a644f1f367ebb9c7dc7e7cabb9", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedMetadata implements Changed {\n  private String left;\n  private String right;\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(left, right)) {\n      return DiffResult.NO_CHANGES;\n    }\n    return DiffResult.METADATA;\n  }\n\n  public String getLeft() {\n    return this.left;\n  }\n\n  public String getRight() {\n    return this.right;\n  }\n\n  public ChangedMetadata setLeft(final String left) {\n    this.left = left;\n    return this;\n  }\n\n  public ChangedMetadata setRight(final String right) {\n    this.right = right;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMetadata that = (ChangedMetadata) o;\n    return Objects.equals(left, that.left) && Objects.equals(right, that.right);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(left, right);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedMetadata(left=\" + this.getLeft() + \", right=\" + this.getRight() + \")\";\n  }\n}", "definition": "public class ChangedMetadata implements Changed", "class_docstring": "", "name": "ChangedMetadata", "super_interfaces": ["Changed"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private String left;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "left", "syntax_pass": true}, {"attribute_expression": "private String right;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "right", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(left, right)) {\n      return DiffResult.NO_CHANGES;\n    }\n    return DiffResult.METADATA;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isChanged", "params": [], "body": "                                {\n    if (Objects.equals(left, right)) {\n      return DiffResult.NO_CHANGES;\n    }\n    return DiffResult.METADATA;\n  }", "signature": "@Override\n  public DiffResult isChanged()"}, {"syntax_pass": true, "original_string": "  public String getLeft() {\n    return this.left;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getLeft", "params": [], "body": "                          {\n    return this.left;\n  }", "signature": "public String getLeft()"}, {"syntax_pass": true, "original_string": "  public String getRight() {\n    return this.right;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getRight", "params": [], "body": "                           {\n    return this.right;\n  }", "signature": "public String getRight()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata setLeft(final String left) {\n    this.left = left;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "setLeft", "params": [{"name": "left", "type": "String"}], "body": "                                                    {\n    this.left = left;\n    return this;\n  }", "signature": "public ChangedMetadata setLeft(final String left)"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata setRight(final String right) {\n    this.right = right;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "setRight", "params": [{"name": "right", "type": "String"}], "body": "                                                      {\n    this.right = right;\n    return this;\n  }", "signature": "public ChangedMetadata setRight(final String right)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMetadata that = (ChangedMetadata) o;\n    return Objects.equals(left, that.left) && Objects.equals(right, that.right);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMetadata that = (ChangedMetadata) o;\n    return Objects.equals(left, that.left) && Objects.equals(right, that.right);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(left, right);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(left, right);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedMetadata(left=\" + this.getLeft() + \", right=\" + this.getRight() + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedMetadata(left=\" + this.getLeft() + \", right=\" + this.getRight() + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedSecurityScheme.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.*;\n\nimport io.swagger.v3.oas.models.security.SecurityScheme;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class ChangedSecurityScheme implements ComposedChanged {\n  private SecurityScheme oldSecurityScheme;\n  private SecurityScheme newSecurityScheme;\n  private final DiffContext context;\n  private boolean changedType;\n  private boolean changedIn;\n  private boolean changedScheme;\n  private boolean changedBearerFormat;\n  private boolean changedOpenIdConnectUrl;\n  private ChangedSecuritySchemeScopes changedScopes;\n  private ChangedMetadata description;\n  private ChangedOAuthFlows oAuthFlows;\n  private ChangedExtensions extensions;\n\n  public ChangedSecurityScheme(\n      SecurityScheme oldSecurityScheme, SecurityScheme newSecurityScheme, DiffContext context) {\n    this.oldSecurityScheme = oldSecurityScheme;\n    this.newSecurityScheme = newSecurityScheme;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, oAuthFlows, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!changedType\n        && !changedIn\n        && !changedScheme\n        && !changedBearerFormat\n        && !changedOpenIdConnectUrl\n        && (changedScopes == null || changedScopes.isUnchanged())) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    if (changedBearerFormat) {\n      if (SECURITY_SCHEME_BEARER_FORMAT_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedOpenIdConnectUrl) {\n      if (SECURITY_SCHEME_OPENIDCONNECT_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedScheme) {\n      if (SECURITY_SCHEME_SCHEME_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedScopes != null && !changedScopes.getIncreased().isEmpty()) {\n      if (SECURITY_SCHEME_SCOPES_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedIn || changedType) {\n      // TODO: Dead code removal opportunity for changedType and changedIn. It appears that\n      // SecuritySchemaDiff will never be given the chance to detect differences TYPE and\n      // IN differences because that case has already been detected and filtered out by\n      // SecurityRequirementsDiff and recorded as a dropped requirement in\n      // ChangedSecurityRequirements.\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public SecurityScheme getOldSecurityScheme() {\n    return this.oldSecurityScheme;\n  }\n\n  public SecurityScheme getNewSecurityScheme() {\n    return this.newSecurityScheme;\n  }\n\n  public boolean isChangedType() {\n    return this.changedType;\n  }\n\n  public boolean isChangedIn() {\n    return this.changedIn;\n  }\n\n  public boolean isChangedScheme() {\n    return this.changedScheme;\n  }\n\n  public boolean isChangedBearerFormat() {\n    return this.changedBearerFormat;\n  }\n\n  public boolean isChangedOpenIdConnectUrl() {\n    return this.changedOpenIdConnectUrl;\n  }\n\n  public ChangedSecuritySchemeScopes getChangedScopes() {\n    return this.changedScopes;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedOAuthFlows getOAuthFlows() {\n    return this.oAuthFlows;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedSecurityScheme setOldSecurityScheme(final SecurityScheme oldSecurityScheme) {\n    this.oldSecurityScheme = oldSecurityScheme;\n    return this;\n  }\n\n  public ChangedSecurityScheme setNewSecurityScheme(final SecurityScheme newSecurityScheme) {\n    this.newSecurityScheme = newSecurityScheme;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedType(final boolean changedType) {\n    this.changedType = changedType;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedIn(final boolean changedIn) {\n    this.changedIn = changedIn;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedScheme(final boolean changedScheme) {\n    this.changedScheme = changedScheme;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedBearerFormat(final boolean changedBearerFormat) {\n    this.changedBearerFormat = changedBearerFormat;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedOpenIdConnectUrl(final boolean changedOpenIdConnectUrl) {\n    this.changedOpenIdConnectUrl = changedOpenIdConnectUrl;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedScopes(final ChangedSecuritySchemeScopes changedScopes) {\n    this.changedScopes = changedScopes;\n    return this;\n  }\n\n  public ChangedSecurityScheme setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedSecurityScheme setOAuthFlows(final ChangedOAuthFlows oAuthFlows) {\n    this.oAuthFlows = oAuthFlows;\n    return this;\n  }\n\n  public ChangedSecurityScheme setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityScheme that = (ChangedSecurityScheme) o;\n    return changedType == that.changedType\n        && changedIn == that.changedIn\n        && changedScheme == that.changedScheme\n        && changedBearerFormat == that.changedBearerFormat\n        && changedOpenIdConnectUrl == that.changedOpenIdConnectUrl\n        && Objects.equals(oldSecurityScheme, that.oldSecurityScheme)\n        && Objects.equals(newSecurityScheme, that.newSecurityScheme)\n        && Objects.equals(changedScopes, that.changedScopes)\n        && Objects.equals(description, that.description)\n        && Objects.equals(oAuthFlows, that.oAuthFlows)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSecurityScheme,\n        newSecurityScheme,\n        changedType,\n        changedIn,\n        changedScheme,\n        changedBearerFormat,\n        changedOpenIdConnectUrl,\n        changedScopes,\n        description,\n        oAuthFlows,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSecurityScheme(oldSecurityScheme=\"\n        + this.getOldSecurityScheme()\n        + \", newSecurityScheme=\"\n        + this.getNewSecurityScheme()\n        + \", changedType=\"\n        + this.isChangedType()\n        + \", changedIn=\"\n        + this.isChangedIn()\n        + \", changedScheme=\"\n        + this.isChangedScheme()\n        + \", changedBearerFormat=\"\n        + this.isChangedBearerFormat()\n        + \", changedOpenIdConnectUrl=\"\n        + this.isChangedOpenIdConnectUrl()\n        + \", changedScopes=\"\n        + this.getChangedScopes()\n        + \", description=\"\n        + this.getDescription()\n        + \", oAuthFlows=\"\n        + this.getOAuthFlows()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "462d58c9a12d2b00b593fd7bff2562e01b5f18b0a481cfb55ee0f0c87a9df922", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.*;", "import io.swagger.v3.oas.models.security.SecurityScheme;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedSecurityScheme implements ComposedChanged {\n  private SecurityScheme oldSecurityScheme;\n  private SecurityScheme newSecurityScheme;\n  private final DiffContext context;\n  private boolean changedType;\n  private boolean changedIn;\n  private boolean changedScheme;\n  private boolean changedBearerFormat;\n  private boolean changedOpenIdConnectUrl;\n  private ChangedSecuritySchemeScopes changedScopes;\n  private ChangedMetadata description;\n  private ChangedOAuthFlows oAuthFlows;\n  private ChangedExtensions extensions;\n\n  public ChangedSecurityScheme(\n      SecurityScheme oldSecurityScheme, SecurityScheme newSecurityScheme, DiffContext context) {\n    this.oldSecurityScheme = oldSecurityScheme;\n    this.newSecurityScheme = newSecurityScheme;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, oAuthFlows, extensions);\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (!changedType\n        && !changedIn\n        && !changedScheme\n        && !changedBearerFormat\n        && !changedOpenIdConnectUrl\n        && (changedScopes == null || changedScopes.isUnchanged())) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    if (changedBearerFormat) {\n      if (SECURITY_SCHEME_BEARER_FORMAT_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedOpenIdConnectUrl) {\n      if (SECURITY_SCHEME_OPENIDCONNECT_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedScheme) {\n      if (SECURITY_SCHEME_SCHEME_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedScopes != null && !changedScopes.getIncreased().isEmpty()) {\n      if (SECURITY_SCHEME_SCOPES_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedIn || changedType) {\n      // TODO: Dead code removal opportunity for changedType and changedIn. It appears that\n      // SecuritySchemaDiff will never be given the chance to detect differences TYPE and\n      // IN differences because that case has already been detected and filtered out by\n      // SecurityRequirementsDiff and recorded as a dropped requirement in\n      // ChangedSecurityRequirements.\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public SecurityScheme getOldSecurityScheme() {\n    return this.oldSecurityScheme;\n  }\n\n  public SecurityScheme getNewSecurityScheme() {\n    return this.newSecurityScheme;\n  }\n\n  public boolean isChangedType() {\n    return this.changedType;\n  }\n\n  public boolean isChangedIn() {\n    return this.changedIn;\n  }\n\n  public boolean isChangedScheme() {\n    return this.changedScheme;\n  }\n\n  public boolean isChangedBearerFormat() {\n    return this.changedBearerFormat;\n  }\n\n  public boolean isChangedOpenIdConnectUrl() {\n    return this.changedOpenIdConnectUrl;\n  }\n\n  public ChangedSecuritySchemeScopes getChangedScopes() {\n    return this.changedScopes;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public ChangedOAuthFlows getOAuthFlows() {\n    return this.oAuthFlows;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedSecurityScheme setOldSecurityScheme(final SecurityScheme oldSecurityScheme) {\n    this.oldSecurityScheme = oldSecurityScheme;\n    return this;\n  }\n\n  public ChangedSecurityScheme setNewSecurityScheme(final SecurityScheme newSecurityScheme) {\n    this.newSecurityScheme = newSecurityScheme;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedType(final boolean changedType) {\n    this.changedType = changedType;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedIn(final boolean changedIn) {\n    this.changedIn = changedIn;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedScheme(final boolean changedScheme) {\n    this.changedScheme = changedScheme;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedBearerFormat(final boolean changedBearerFormat) {\n    this.changedBearerFormat = changedBearerFormat;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedOpenIdConnectUrl(final boolean changedOpenIdConnectUrl) {\n    this.changedOpenIdConnectUrl = changedOpenIdConnectUrl;\n    return this;\n  }\n\n  public ChangedSecurityScheme setChangedScopes(final ChangedSecuritySchemeScopes changedScopes) {\n    this.changedScopes = changedScopes;\n    return this;\n  }\n\n  public ChangedSecurityScheme setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }\n\n  public ChangedSecurityScheme setOAuthFlows(final ChangedOAuthFlows oAuthFlows) {\n    this.oAuthFlows = oAuthFlows;\n    return this;\n  }\n\n  public ChangedSecurityScheme setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityScheme that = (ChangedSecurityScheme) o;\n    return changedType == that.changedType\n        && changedIn == that.changedIn\n        && changedScheme == that.changedScheme\n        && changedBearerFormat == that.changedBearerFormat\n        && changedOpenIdConnectUrl == that.changedOpenIdConnectUrl\n        && Objects.equals(oldSecurityScheme, that.oldSecurityScheme)\n        && Objects.equals(newSecurityScheme, that.newSecurityScheme)\n        && Objects.equals(changedScopes, that.changedScopes)\n        && Objects.equals(description, that.description)\n        && Objects.equals(oAuthFlows, that.oAuthFlows)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSecurityScheme,\n        newSecurityScheme,\n        changedType,\n        changedIn,\n        changedScheme,\n        changedBearerFormat,\n        changedOpenIdConnectUrl,\n        changedScopes,\n        description,\n        oAuthFlows,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSecurityScheme(oldSecurityScheme=\"\n        + this.getOldSecurityScheme()\n        + \", newSecurityScheme=\"\n        + this.getNewSecurityScheme()\n        + \", changedType=\"\n        + this.isChangedType()\n        + \", changedIn=\"\n        + this.isChangedIn()\n        + \", changedScheme=\"\n        + this.isChangedScheme()\n        + \", changedBearerFormat=\"\n        + this.isChangedBearerFormat()\n        + \", changedOpenIdConnectUrl=\"\n        + this.isChangedOpenIdConnectUrl()\n        + \", changedScopes=\"\n        + this.getChangedScopes()\n        + \", description=\"\n        + this.getDescription()\n        + \", oAuthFlows=\"\n        + this.getOAuthFlows()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedSecurityScheme implements ComposedChanged", "class_docstring": "", "name": "ChangedSecurityScheme", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private SecurityScheme oldSecurityScheme;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecurityScheme", "name": "oldSecurityScheme", "syntax_pass": true}, {"attribute_expression": "private SecurityScheme newSecurityScheme;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecurityScheme", "name": "newSecurityScheme", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private boolean changedType;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changedType", "syntax_pass": true}, {"attribute_expression": "private boolean changedIn;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changedIn", "syntax_pass": true}, {"attribute_expression": "private boolean changedScheme;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changedScheme", "syntax_pass": true}, {"attribute_expression": "private boolean changedBearerFormat;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changedBearerFormat", "syntax_pass": true}, {"attribute_expression": "private boolean changedOpenIdConnectUrl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changedOpenIdConnectUrl", "syntax_pass": true}, {"attribute_expression": "private ChangedSecuritySchemeScopes changedScopes;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedSecuritySchemeScopes", "name": "changedScopes", "syntax_pass": true}, {"attribute_expression": "private ChangedMetadata description;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedMetadata", "name": "description", "syntax_pass": true}, {"attribute_expression": "private ChangedOAuthFlows oAuthFlows;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedOAuthFlows", "name": "oAuthFlows", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedSecurityScheme(\n      SecurityScheme oldSecurityScheme, SecurityScheme newSecurityScheme, DiffContext context) {\n    this.oldSecurityScheme = oldSecurityScheme;\n    this.newSecurityScheme = newSecurityScheme;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedSecurityScheme", "params": [{"name": "oldSecurityScheme", "type": "SecurityScheme"}, {"name": "newSecurityScheme", "type": "SecurityScheme"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                               {\n    this.oldSecurityScheme = oldSecurityScheme;\n    this.newSecurityScheme = newSecurityScheme;\n    this.context = context;\n  }", "signature": "public ChangedSecurityScheme(\n      SecurityScheme oldSecurityScheme, SecurityScheme newSecurityScheme, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Arrays.asList(description, oAuthFlows, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Arrays.asList(description, oAuthFlows, extensions);\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (!changedType\n        && !changedIn\n        && !changedScheme\n        && !changedBearerFormat\n        && !changedOpenIdConnectUrl\n        && (changedScopes == null || changedScopes.isUnchanged())) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    if (changedBearerFormat) {\n      if (SECURITY_SCHEME_BEARER_FORMAT_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedOpenIdConnectUrl) {\n      if (SECURITY_SCHEME_OPENIDCONNECT_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedScheme) {\n      if (SECURITY_SCHEME_SCHEME_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedScopes != null && !changedScopes.getIncreased().isEmpty()) {\n      if (SECURITY_SCHEME_SCOPES_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedIn || changedType) {\n      // TODO: Dead code removal opportunity for changedType and changedIn. It appears that\n      // SecuritySchemaDiff will never be given the chance to detect differences TYPE and\n      // IN differences because that case has already been detected and filtered out by\n      // SecurityRequirementsDiff and recorded as a dropped requirement in\n      // ChangedSecurityRequirements.\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (!changedType\n        && !changedIn\n        && !changedScheme\n        && !changedBearerFormat\n        && !changedOpenIdConnectUrl\n        && (changedScopes == null || changedScopes.isUnchanged())) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    if (changedBearerFormat) {\n      if (SECURITY_SCHEME_BEARER_FORMAT_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedOpenIdConnectUrl) {\n      if (SECURITY_SCHEME_OPENIDCONNECT_URL_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedScheme) {\n      if (SECURITY_SCHEME_SCHEME_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedScopes != null && !changedScopes.getIncreased().isEmpty()) {\n      if (SECURITY_SCHEME_SCOPES_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (changedIn || changedType) {\n      // TODO: Dead code removal opportunity for changedType and changedIn. It appears that\n      // SecuritySchemaDiff will never be given the chance to detect differences TYPE and\n      // IN differences because that case has already been detected and filtered out by\n      // SecurityRequirementsDiff and recorded as a dropped requirement in\n      // ChangedSecurityRequirements.\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public SecurityScheme getOldSecurityScheme() {\n    return this.oldSecurityScheme;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecurityScheme", "classes": []}, "name": "getOldSecurityScheme", "params": [], "body": "                                               {\n    return this.oldSecurityScheme;\n  }", "signature": "public SecurityScheme getOldSecurityScheme()"}, {"syntax_pass": true, "original_string": "  public SecurityScheme getNewSecurityScheme() {\n    return this.newSecurityScheme;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecurityScheme", "classes": []}, "name": "getNewSecurityScheme", "params": [], "body": "                                               {\n    return this.newSecurityScheme;\n  }", "signature": "public SecurityScheme getNewSecurityScheme()"}, {"syntax_pass": true, "original_string": "  public boolean isChangedType() {\n    return this.changedType;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangedType", "params": [], "body": "                                 {\n    return this.changedType;\n  }", "signature": "public boolean isChangedType()"}, {"syntax_pass": true, "original_string": "  public boolean isChangedIn() {\n    return this.changedIn;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangedIn", "params": [], "body": "                               {\n    return this.changedIn;\n  }", "signature": "public boolean isChangedIn()"}, {"syntax_pass": true, "original_string": "  public boolean isChangedScheme() {\n    return this.changedScheme;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangedScheme", "params": [], "body": "                                   {\n    return this.changedScheme;\n  }", "signature": "public boolean isChangedScheme()"}, {"syntax_pass": true, "original_string": "  public boolean isChangedBearerFormat() {\n    return this.changedBearerFormat;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangedBearerFormat", "params": [], "body": "                                         {\n    return this.changedBearerFormat;\n  }", "signature": "public boolean isChangedBearerFormat()"}, {"syntax_pass": true, "original_string": "  public boolean isChangedOpenIdConnectUrl() {\n    return this.changedOpenIdConnectUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangedOpenIdConnectUrl", "params": [], "body": "                                             {\n    return this.changedOpenIdConnectUrl;\n  }", "signature": "public boolean isChangedOpenIdConnectUrl()"}, {"syntax_pass": true, "original_string": "  public ChangedSecuritySchemeScopes getChangedScopes() {\n    return this.changedScopes;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecuritySchemeScopes", "classes": []}, "name": "getChangedScopes", "params": [], "body": "                                                        {\n    return this.changedScopes;\n  }", "signature": "public ChangedSecuritySchemeScopes getChangedScopes()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata getDescription() {\n    return this.description;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "getDescription", "params": [], "body": "                                          {\n    return this.description;\n  }", "signature": "public ChangedMetadata getDescription()"}, {"syntax_pass": true, "original_string": "  public ChangedOAuthFlows getOAuthFlows() {\n    return this.oAuthFlows;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOAuthFlows", "classes": []}, "name": "getOAuthFlows", "params": [], "body": "                                           {\n    return this.oAuthFlows;\n  }", "signature": "public ChangedOAuthFlows getOAuthFlows()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setOldSecurityScheme(final SecurityScheme oldSecurityScheme) {\n    this.oldSecurityScheme = oldSecurityScheme;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setOldSecurityScheme", "params": [{"name": "oldSecurityScheme", "type": "SecurityScheme"}], "body": "                                                                                            {\n    this.oldSecurityScheme = oldSecurityScheme;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setOldSecurityScheme(final SecurityScheme oldSecurityScheme)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setNewSecurityScheme(final SecurityScheme newSecurityScheme) {\n    this.newSecurityScheme = newSecurityScheme;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setNewSecurityScheme", "params": [{"name": "newSecurityScheme", "type": "SecurityScheme"}], "body": "                                                                                            {\n    this.newSecurityScheme = newSecurityScheme;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setNewSecurityScheme(final SecurityScheme newSecurityScheme)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setChangedType(final boolean changedType) {\n    this.changedType = changedType;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setChangedType", "params": [{"name": "changedType", "type": "boolean"}], "body": "                                                                         {\n    this.changedType = changedType;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setChangedType(final boolean changedType)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setChangedIn(final boolean changedIn) {\n    this.changedIn = changedIn;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setChangedIn", "params": [{"name": "changedIn", "type": "boolean"}], "body": "                                                                     {\n    this.changedIn = changedIn;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setChangedIn(final boolean changedIn)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setChangedScheme(final boolean changedScheme) {\n    this.changedScheme = changedScheme;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setChangedScheme", "params": [{"name": "changedScheme", "type": "boolean"}], "body": "                                                                             {\n    this.changedScheme = changedScheme;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setChangedScheme(final boolean changedScheme)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setChangedBearerFormat(final boolean changedBearerFormat) {\n    this.changedBearerFormat = changedBearerFormat;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setChangedBearerFormat", "params": [{"name": "changedBearerFormat", "type": "boolean"}], "body": "                                                                                         {\n    this.changedBearerFormat = changedBearerFormat;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setChangedBearerFormat(final boolean changedBearerFormat)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setChangedOpenIdConnectUrl(final boolean changedOpenIdConnectUrl) {\n    this.changedOpenIdConnectUrl = changedOpenIdConnectUrl;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setChangedOpenIdConnectUrl", "params": [{"name": "changedOpenIdConnectUrl", "type": "boolean"}], "body": "                                                                                                 {\n    this.changedOpenIdConnectUrl = changedOpenIdConnectUrl;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setChangedOpenIdConnectUrl(final boolean changedOpenIdConnectUrl)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setChangedScopes(final ChangedSecuritySchemeScopes changedScopes) {\n    this.changedScopes = changedScopes;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setChangedScopes", "params": [{"name": "changedScopes", "type": "ChangedSecuritySchemeScopes"}], "body": "                                                                                                 {\n    this.changedScopes = changedScopes;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setChangedScopes(final ChangedSecuritySchemeScopes changedScopes)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setDescription(final ChangedMetadata description) {\n    this.description = description;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "ChangedMetadata"}], "body": "                                                                                 {\n    this.description = description;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setDescription(final ChangedMetadata description)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setOAuthFlows(final ChangedOAuthFlows oAuthFlows) {\n    this.oAuthFlows = oAuthFlows;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setOAuthFlows", "params": [{"name": "oAuthFlows", "type": "ChangedOAuthFlows"}], "body": "                                                                                 {\n    this.oAuthFlows = oAuthFlows;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setOAuthFlows(final ChangedOAuthFlows oAuthFlows)"}, {"syntax_pass": true, "original_string": "  public ChangedSecurityScheme setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                                 {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedSecurityScheme setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityScheme that = (ChangedSecurityScheme) o;\n    return changedType == that.changedType\n        && changedIn == that.changedIn\n        && changedScheme == that.changedScheme\n        && changedBearerFormat == that.changedBearerFormat\n        && changedOpenIdConnectUrl == that.changedOpenIdConnectUrl\n        && Objects.equals(oldSecurityScheme, that.oldSecurityScheme)\n        && Objects.equals(newSecurityScheme, that.newSecurityScheme)\n        && Objects.equals(changedScopes, that.changedScopes)\n        && Objects.equals(description, that.description)\n        && Objects.equals(oAuthFlows, that.oAuthFlows)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSecurityScheme that = (ChangedSecurityScheme) o;\n    return changedType == that.changedType\n        && changedIn == that.changedIn\n        && changedScheme == that.changedScheme\n        && changedBearerFormat == that.changedBearerFormat\n        && changedOpenIdConnectUrl == that.changedOpenIdConnectUrl\n        && Objects.equals(oldSecurityScheme, that.oldSecurityScheme)\n        && Objects.equals(newSecurityScheme, that.newSecurityScheme)\n        && Objects.equals(changedScopes, that.changedScopes)\n        && Objects.equals(description, that.description)\n        && Objects.equals(oAuthFlows, that.oAuthFlows)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldSecurityScheme,\n        newSecurityScheme,\n        changedType,\n        changedIn,\n        changedScheme,\n        changedBearerFormat,\n        changedOpenIdConnectUrl,\n        changedScopes,\n        description,\n        oAuthFlows,\n        extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldSecurityScheme,\n        newSecurityScheme,\n        changedType,\n        changedIn,\n        changedScheme,\n        changedBearerFormat,\n        changedOpenIdConnectUrl,\n        changedScopes,\n        description,\n        oAuthFlows,\n        extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSecurityScheme(oldSecurityScheme=\"\n        + this.getOldSecurityScheme()\n        + \", newSecurityScheme=\"\n        + this.getNewSecurityScheme()\n        + \", changedType=\"\n        + this.isChangedType()\n        + \", changedIn=\"\n        + this.isChangedIn()\n        + \", changedScheme=\"\n        + this.isChangedScheme()\n        + \", changedBearerFormat=\"\n        + this.isChangedBearerFormat()\n        + \", changedOpenIdConnectUrl=\"\n        + this.isChangedOpenIdConnectUrl()\n        + \", changedScopes=\"\n        + this.getChangedScopes()\n        + \", description=\"\n        + this.getDescription()\n        + \", oAuthFlows=\"\n        + this.getOAuthFlows()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedSecurityScheme(oldSecurityScheme=\"\n        + this.getOldSecurityScheme()\n        + \", newSecurityScheme=\"\n        + this.getNewSecurityScheme()\n        + \", changedType=\"\n        + this.isChangedType()\n        + \", changedIn=\"\n        + this.isChangedIn()\n        + \", changedScheme=\"\n        + this.isChangedScheme()\n        + \", changedBearerFormat=\"\n        + this.isChangedBearerFormat()\n        + \", changedOpenIdConnectUrl=\"\n        + this.isChangedOpenIdConnectUrl()\n        + \", changedScopes=\"\n        + this.getChangedScopes()\n        + \", description=\"\n        + this.getDescription()\n        + \", oAuthFlows=\"\n        + this.getOAuthFlows()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ComposedChanged.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport java.util.List;\nimport java.util.Objects;\nimport javax.validation.constraints.NotNull;\n\npublic interface ComposedChanged extends Changed {\n\n  @NotNull\n  List<Changed> getChangedElements();\n\n  @NotNull\n  DiffResult isCoreChanged();\n\n  @Override\n  default DiffResult isChanged() {\n    DiffResult elementsResult =\n        DiffResult.fromWeight(\n            getChangedElements().stream()\n                .filter(Objects::nonNull)\n                .map(Changed::isChanged)\n                .mapToInt(DiffResult::getWeight)\n                .max()\n                .orElse(0));\n    if (isCoreChanged().getWeight() > elementsResult.getWeight()) {\n      return isCoreChanged();\n    } else {\n      return elementsResult;\n    }\n  }\n}\n", "file_hash": "883cc5b94a164b1efee55fa279c7823297abf8c54ee9d3b591a7a90feca5add7", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import java.util.List;", "import java.util.Objects;", "import javax.validation.constraints.NotNull;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface ComposedChanged extends Changed {\n\n  @NotNull\n  List<Changed> getChangedElements();\n\n  @NotNull\n  DiffResult isCoreChanged();\n\n  @Override\n  default DiffResult isChanged() {\n    DiffResult elementsResult =\n        DiffResult.fromWeight(\n            getChangedElements().stream()\n                .filter(Objects::nonNull)\n                .map(Changed::isChanged)\n                .mapToInt(DiffResult::getWeight)\n                .max()\n                .orElse(0));\n    if (isCoreChanged().getWeight() > elementsResult.getWeight()) {\n      return isCoreChanged();\n    } else {\n      return elementsResult;\n    }\n  }\n}", "definition": "public interface ComposedChanged extends Changed", "interface_docstring": "", "name": "ComposedChanged", "extends_interfaces": ["Changed"], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @NotNull\n  List<Changed> getChangedElements();", "docstring": "", "attributes": {"modifiers": "@NotNull", "marker_annotations": ["@NotNull"], "non_marker_annotations": [], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "", "signature": "@NotNull\n  List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @NotNull\n  DiffResult isCoreChanged();", "docstring": "", "attributes": {"modifiers": "@NotNull", "marker_annotations": ["@NotNull"], "non_marker_annotations": [], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "", "signature": "@NotNull\n  DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  @Override\n  default DiffResult isChanged() {\n    DiffResult elementsResult =\n        DiffResult.fromWeight(\n            getChangedElements().stream()\n                .filter(Objects::nonNull)\n                .map(Changed::isChanged)\n                .mapToInt(DiffResult::getWeight)\n                .max()\n                .orElse(0));\n    if (isCoreChanged().getWeight() > elementsResult.getWeight()) {\n      return isCoreChanged();\n    } else {\n      return elementsResult;\n    }\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  default", "marker_annotations": ["@Override"], "non_marker_annotations": ["default"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isChanged", "params": [], "body": "                                 {\n    DiffResult elementsResult =\n        DiffResult.fromWeight(\n            getChangedElements().stream()\n                .filter(Objects::nonNull)\n                .map(Changed::isChanged)\n                .mapToInt(DiffResult::getWeight)\n                .max()\n                .orElse(0));\n    if (isCoreChanged().getWeight() > elementsResult.getWeight()) {\n      return isCoreChanged();\n    } else {\n      return elementsResult;\n    }\n  }", "signature": "@Override\n  default DiffResult isChanged()"}]}], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedPath.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;\n\nimport io.swagger.v3.oas.models.Operation;\nimport io.swagger.v3.oas.models.PathItem;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class ChangedPath implements ComposedChanged {\n  private final String pathUrl;\n  private final PathItem oldPath;\n  private final PathItem newPath;\n  private final DiffContext context;\n  Map<PathItem.HttpMethod, Operation> increased;\n  Map<PathItem.HttpMethod, Operation> missing;\n  List<ChangedOperation> changed;\n  private ChangedExtensions extensions;\n\n  public ChangedPath(String pathUrl, PathItem oldPath, PathItem newPath, DiffContext context) {\n    this.pathUrl = pathUrl;\n    this.oldPath = oldPath;\n    this.newPath = newPath;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new ArrayList<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.concat(changed.stream(), Stream.of(extensions)).collect(Collectors.toList());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public String getPathUrl() {\n    return this.pathUrl;\n  }\n\n  public PathItem getOldPath() {\n    return this.oldPath;\n  }\n\n  public PathItem getNewPath() {\n    return this.newPath;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<PathItem.HttpMethod, Operation> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<PathItem.HttpMethod, Operation> getMissing() {\n    return this.missing;\n  }\n\n  public List<ChangedOperation> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedPath setIncreased(final Map<PathItem.HttpMethod, Operation> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedPath setMissing(final Map<PathItem.HttpMethod, Operation> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedPath setChanged(final List<ChangedOperation> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  public ChangedPath setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedPath that = (ChangedPath) o;\n    return Objects.equals(pathUrl, that.pathUrl)\n        && Objects.equals(oldPath, that.oldPath)\n        && Objects.equals(newPath, that.newPath)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        pathUrl, oldPath, newPath, context, increased, missing, changed, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedPath(pathUrl=\"\n        + this.getPathUrl()\n        + \", oldPath=\"\n        + this.getOldPath()\n        + \", newPath=\"\n        + this.getNewPath()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "c35a75b2211706124e2aa098732ec0ad403d486d6b9df7e66ac053b5494bbe1b", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.OPENAPI_ENDPOINTS_DECREASED;", "import io.swagger.v3.oas.models.Operation;", "import io.swagger.v3.oas.models.PathItem;", "import java.util.*;", "import java.util.stream.Collectors;", "import java.util.stream.Stream;"], "methods": [], "classes": [{"original_string": "public class ChangedPath implements ComposedChanged {\n  private final String pathUrl;\n  private final PathItem oldPath;\n  private final PathItem newPath;\n  private final DiffContext context;\n  Map<PathItem.HttpMethod, Operation> increased;\n  Map<PathItem.HttpMethod, Operation> missing;\n  List<ChangedOperation> changed;\n  private ChangedExtensions extensions;\n\n  public ChangedPath(String pathUrl, PathItem oldPath, PathItem newPath, DiffContext context) {\n    this.pathUrl = pathUrl;\n    this.oldPath = oldPath;\n    this.newPath = newPath;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new ArrayList<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.concat(changed.stream(), Stream.of(extensions)).collect(Collectors.toList());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public String getPathUrl() {\n    return this.pathUrl;\n  }\n\n  public PathItem getOldPath() {\n    return this.oldPath;\n  }\n\n  public PathItem getNewPath() {\n    return this.newPath;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<PathItem.HttpMethod, Operation> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<PathItem.HttpMethod, Operation> getMissing() {\n    return this.missing;\n  }\n\n  public List<ChangedOperation> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedPath setIncreased(final Map<PathItem.HttpMethod, Operation> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedPath setMissing(final Map<PathItem.HttpMethod, Operation> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedPath setChanged(final List<ChangedOperation> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  public ChangedPath setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedPath that = (ChangedPath) o;\n    return Objects.equals(pathUrl, that.pathUrl)\n        && Objects.equals(oldPath, that.oldPath)\n        && Objects.equals(newPath, that.newPath)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        pathUrl, oldPath, newPath, context, increased, missing, changed, extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedPath(pathUrl=\"\n        + this.getPathUrl()\n        + \", oldPath=\"\n        + this.getOldPath()\n        + \", newPath=\"\n        + this.getNewPath()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedPath implements ComposedChanged", "class_docstring": "", "name": "ChangedPath", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String pathUrl;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "pathUrl", "syntax_pass": true}, {"attribute_expression": "private final PathItem oldPath;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PathItem", "name": "oldPath", "syntax_pass": true}, {"attribute_expression": "private final PathItem newPath;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PathItem", "name": "newPath", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "Map<PathItem.HttpMethod, Operation> increased;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Map<PathItem.HttpMethod, Operation>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "Map<PathItem.HttpMethod, Operation> missing;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Map<PathItem.HttpMethod, Operation>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "List<ChangedOperation> changed;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "List<ChangedOperation>", "name": "changed", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedPath(String pathUrl, PathItem oldPath, PathItem newPath, DiffContext context) {\n    this.pathUrl = pathUrl;\n    this.oldPath = oldPath;\n    this.newPath = newPath;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new ArrayList<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedPath", "params": [{"name": "pathUrl", "type": "String"}, {"name": "oldPath", "type": "PathItem"}, {"name": "newPath", "type": "PathItem"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                              {\n    this.pathUrl = pathUrl;\n    this.oldPath = oldPath;\n    this.newPath = newPath;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new ArrayList<>();\n  }", "signature": "public ChangedPath(String pathUrl, PathItem oldPath, PathItem newPath, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return Stream.concat(changed.stream(), Stream.of(extensions)).collect(Collectors.toList());\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return Stream.concat(changed.stream(), Stream.of(extensions)).collect(Collectors.toList());\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (OPENAPI_ENDPOINTS_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public String getPathUrl() {\n    return this.pathUrl;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getPathUrl", "params": [], "body": "                             {\n    return this.pathUrl;\n  }", "signature": "public String getPathUrl()"}, {"syntax_pass": true, "original_string": "  public PathItem getOldPath() {\n    return this.oldPath;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PathItem", "classes": []}, "name": "getOldPath", "params": [], "body": "                               {\n    return this.oldPath;\n  }", "signature": "public PathItem getOldPath()"}, {"syntax_pass": true, "original_string": "  public PathItem getNewPath() {\n    return this.newPath;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PathItem", "classes": []}, "name": "getNewPath", "params": [], "body": "                               {\n    return this.newPath;\n  }", "signature": "public PathItem getNewPath()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public Map<PathItem.HttpMethod, Operation> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<PathItem.HttpMethod, Operation>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                                            {\n    return this.increased;\n  }", "signature": "public Map<PathItem.HttpMethod, Operation> getIncreased()"}, {"syntax_pass": true, "original_string": "  public Map<PathItem.HttpMethod, Operation> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<PathItem.HttpMethod, Operation>", "classes": []}, "name": "getMissing", "params": [], "body": "                                                          {\n    return this.missing;\n  }", "signature": "public Map<PathItem.HttpMethod, Operation> getMissing()"}, {"syntax_pass": true, "original_string": "  public List<ChangedOperation> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ChangedOperation>", "classes": []}, "name": "getChanged", "params": [], "body": "                                             {\n    return this.changed;\n  }", "signature": "public List<ChangedOperation> getChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedPath setIncreased(final Map<PathItem.HttpMethod, Operation> increased) {\n    this.increased = increased;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedPath", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "Map<PathItem.HttpMethod, Operation>"}], "body": "                                                                                       {\n    this.increased = increased;\n    return this;\n  }", "signature": "public ChangedPath setIncreased(final Map<PathItem.HttpMethod, Operation> increased)"}, {"syntax_pass": true, "original_string": "  public ChangedPath setMissing(final Map<PathItem.HttpMethod, Operation> missing) {\n    this.missing = missing;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedPath", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "Map<PathItem.HttpMethod, Operation>"}], "body": "                                                                                   {\n    this.missing = missing;\n    return this;\n  }", "signature": "public ChangedPath setMissing(final Map<PathItem.HttpMethod, Operation> missing)"}, {"syntax_pass": true, "original_string": "  public ChangedPath setChanged(final List<ChangedOperation> changed) {\n    this.changed = changed;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedPath", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "List<ChangedOperation>"}], "body": "                                                                      {\n    this.changed = changed;\n    return this;\n  }", "signature": "public ChangedPath setChanged(final List<ChangedOperation> changed)"}, {"syntax_pass": true, "original_string": "  public ChangedPath setExtensions(final ChangedExtensions extensions) {\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedPath", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                       {\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedPath setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedPath that = (ChangedPath) o;\n    return Objects.equals(pathUrl, that.pathUrl)\n        && Objects.equals(oldPath, that.oldPath)\n        && Objects.equals(newPath, that.newPath)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedPath that = (ChangedPath) o;\n    return Objects.equals(pathUrl, that.pathUrl)\n        && Objects.equals(oldPath, that.oldPath)\n        && Objects.equals(newPath, that.newPath)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        pathUrl, oldPath, newPath, context, increased, missing, changed, extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        pathUrl, oldPath, newPath, context, increased, missing, changed, extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedPath(pathUrl=\"\n        + this.getPathUrl()\n        + \", oldPath=\"\n        + this.getOldPath()\n        + \", newPath=\"\n        + this.getNewPath()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedPath(pathUrl=\"\n        + this.getPathUrl()\n        + \", oldPath=\"\n        + this.getOldPath()\n        + \", newPath=\"\n        + this.getNewPath()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedSchema.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_REQUIRED_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SCHEMA_DISCRIMINATOR_CHANGED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SCHEMA_TYPE_CHANGED;\n\nimport io.swagger.v3.oas.models.media.Schema;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.openapitools.openapidiff.core.model.schema.ChangedEnum;\nimport org.openapitools.openapidiff.core.model.schema.ChangedMaxLength;\nimport org.openapitools.openapidiff.core.model.schema.ChangedNumericRange;\nimport org.openapitools.openapidiff.core.model.schema.ChangedReadOnly;\nimport org.openapitools.openapidiff.core.model.schema.ChangedRequired;\nimport org.openapitools.openapidiff.core.model.schema.ChangedWriteOnly;\n\npublic class ChangedSchema implements ComposedChanged {\n  protected DiffContext context;\n  protected Schema<?> oldSchema;\n  protected Schema<?> newSchema;\n  protected String type;\n  protected Map<String, ChangedSchema> changedProperties;\n  protected Map<String, Schema<?>> increasedProperties;\n  protected Map<String, Schema<?>> missingProperties;\n  protected boolean changeDeprecated;\n  protected ChangedMetadata description;\n  protected boolean changeTitle;\n  protected ChangedRequired required;\n  protected boolean changeDefault;\n  protected ChangedEnum<?> enumeration;\n  protected boolean changeFormat;\n  protected ChangedReadOnly readOnly;\n  protected ChangedWriteOnly writeOnly;\n  protected boolean changedType;\n  protected ChangedMaxLength maxLength;\n  protected ChangedNumericRange numericRange;\n  protected boolean discriminatorPropertyChanged;\n  protected ChangedSchema items;\n  protected ChangedOneOfSchema oneOfSchema;\n  protected ChangedSchema addProp;\n  private ChangedExtensions extensions;\n\n  // Flags to avoid recursive calls to isChanged() and getChangedElements()\n  private boolean gettingChangedElements = false;\n  private boolean gettingIsChanged = false;\n\n  // cached results for isChanged()\n  private DiffResult changed;\n  private DiffResult coreChanged;\n\n  // cached results for getChangedElements()\n  private List<Changed> changedElements;\n\n  public ChangedSchema() {\n    increasedProperties = new LinkedHashMap<>();\n    missingProperties = new LinkedHashMap<>();\n    changedProperties = new LinkedHashMap<>();\n  }\n\n  private void clearChangedCache() {\n    this.changed = null;\n    this.coreChanged = null;\n    this.changedElements = null;\n  }\n\n  @Override\n  public DiffResult isChanged() {\n    if (gettingIsChanged) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    gettingIsChanged = true;\n    if (this.changed == null) {\n      DiffResult elementsResult =\n          DiffResult.fromWeight(\n              getChangedElements().stream()\n                  .filter(Objects::nonNull)\n                  .map(Changed::isChanged)\n                  .mapToInt(DiffResult::getWeight)\n                  .max()\n                  .orElse(0));\n      DiffResult result;\n      if (isCoreChanged().getWeight() > elementsResult.getWeight()) {\n        result = isCoreChanged();\n      } else {\n        result = elementsResult;\n      }\n      this.changed = result;\n    }\n    gettingIsChanged = false;\n\n    return this.changed;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    if (gettingChangedElements) {\n      return Collections.emptyList();\n    }\n\n    gettingChangedElements = true;\n    if (changedElements == null) {\n      this.changedElements =\n          Stream.concat(\n                  changedProperties.values().stream(),\n                  Stream.of(\n                      description,\n                      readOnly,\n                      writeOnly,\n                      items,\n                      oneOfSchema,\n                      addProp,\n                      enumeration,\n                      required,\n                      maxLength,\n                      numericRange,\n                      extensions))\n              .collect(Collectors.toList());\n    }\n    gettingChangedElements = false;\n\n    return this.changedElements;\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (this.coreChanged == null) {\n      this.coreChanged = calculateCoreChanged();\n    }\n\n    return this.coreChanged;\n  }\n\n  private DiffResult calculateCoreChanged() {\n    if (!changedType\n        && (oldSchema == null && newSchema == null || oldSchema != null && newSchema != null)\n        && !changeFormat\n        && increasedProperties.isEmpty()\n        && missingProperties.isEmpty()\n        && changedProperties.values().isEmpty()\n        && !changeDeprecated\n        && !discriminatorPropertyChanged) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (changedType) {\n      if (SCHEMA_TYPE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (discriminatorPropertyChanged) {\n      if (SCHEMA_DISCRIMINATOR_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n\n    if (!compatibleForRequest() || !compatibleForResponse()) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  private boolean compatibleForRequest() {\n    if (context.isRequest()) {\n      if (oldSchema == null && newSchema != null) {\n        // TODO: dead code? If not, create test.\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean compatibleForResponse() {\n    if (context.isResponse()) {\n      if (oldSchema != null) {\n        if (newSchema == null) {\n          // TODO: dead code? If not, create test.\n          return false;\n        }\n        if (oldSchema.getRequired() != null\n            && missingProperties.keySet().stream()\n                .anyMatch(prop -> oldSchema.getRequired().contains(prop))) {\n          if (RESPONSE_REQUIRED_DECREASED.enabled(context)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Schema<?> getOldSchema() {\n    return this.oldSchema;\n  }\n\n  public Schema<?> getNewSchema() {\n    return this.newSchema;\n  }\n\n  public String getType() {\n    return this.type;\n  }\n\n  public Map<String, ChangedSchema> getChangedProperties() {\n    return this.changedProperties;\n  }\n\n  public Map<String, Schema<?>> getIncreasedProperties() {\n    return this.increasedProperties;\n  }\n\n  public Map<String, Schema<?>> getMissingProperties() {\n    return this.missingProperties;\n  }\n\n  public boolean isChangeDeprecated() {\n    return this.changeDeprecated;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public boolean isChangeTitle() {\n    return this.changeTitle;\n  }\n\n  public ChangedRequired getRequired() {\n    return this.required;\n  }\n\n  public boolean isChangeDefault() {\n    return this.changeDefault;\n  }\n\n  public ChangedEnum<?> getEnumeration() {\n    return this.enumeration;\n  }\n\n  public boolean isChangeFormat() {\n    return this.changeFormat;\n  }\n\n  public ChangedReadOnly getReadOnly() {\n    return this.readOnly;\n  }\n\n  public ChangedWriteOnly getWriteOnly() {\n    return this.writeOnly;\n  }\n\n  public boolean isChangedType() {\n    return this.changedType;\n  }\n\n  public ChangedMaxLength getMaxLength() {\n    return this.maxLength;\n  }\n\n  public boolean isDiscriminatorPropertyChanged() {\n    return this.discriminatorPropertyChanged;\n  }\n\n  public ChangedSchema getItems() {\n    return this.items;\n  }\n\n  public ChangedOneOfSchema getOneOfSchema() {\n    return this.oneOfSchema;\n  }\n\n  public ChangedSchema getAddProp() {\n    return this.addProp;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedSchema setContext(final DiffContext context) {\n    this.context = context;\n    return this;\n  }\n\n  public ChangedSchema setOldSchema(final Schema<?> oldSchema) {\n    this.oldSchema = oldSchema;\n    return this;\n  }\n\n  public ChangedSchema setNewSchema(final Schema<?> newSchema) {\n    this.newSchema = newSchema;\n    return this;\n  }\n\n  public ChangedSchema setType(final String type) {\n    this.type = type;\n    return this;\n  }\n\n  public ChangedSchema setChangedProperties(final Map<String, ChangedSchema> changedProperties) {\n    clearChangedCache();\n    this.changedProperties = changedProperties;\n    return this;\n  }\n\n  public ChangedSchema setIncreasedProperties(final Map<String, Schema<?>> increasedProperties) {\n    clearChangedCache();\n    this.increasedProperties = increasedProperties;\n    return this;\n  }\n\n  public ChangedSchema setMissingProperties(final Map<String, Schema<?>> missingProperties) {\n    clearChangedCache();\n    this.missingProperties = missingProperties;\n    return this;\n  }\n\n  public ChangedSchema setChangeDeprecated(final boolean changeDeprecated) {\n    clearChangedCache();\n    this.changeDeprecated = changeDeprecated;\n    return this;\n  }\n\n  public ChangedSchema setDescription(final ChangedMetadata description) {\n    clearChangedCache();\n    this.description = description;\n    return this;\n  }\n\n  public ChangedSchema setChangeTitle(final boolean changeTitle) {\n    clearChangedCache();\n    this.changeTitle = changeTitle;\n    return this;\n  }\n\n  public ChangedSchema setRequired(final ChangedRequired required) {\n    clearChangedCache();\n    this.required = required;\n    return this;\n  }\n\n  public ChangedSchema setChangeDefault(final boolean changeDefault) {\n    clearChangedCache();\n    this.changeDefault = changeDefault;\n    return this;\n  }\n\n  public ChangedSchema setEnumeration(final ChangedEnum<?> enumeration) {\n    clearChangedCache();\n    this.enumeration = enumeration;\n    return this;\n  }\n\n  public ChangedSchema setChangeFormat(final boolean changeFormat) {\n    clearChangedCache();\n    this.changeFormat = changeFormat;\n    return this;\n  }\n\n  public ChangedSchema setReadOnly(final ChangedReadOnly readOnly) {\n    clearChangedCache();\n    this.readOnly = readOnly;\n    return this;\n  }\n\n  public ChangedSchema setWriteOnly(final ChangedWriteOnly writeOnly) {\n    clearChangedCache();\n    this.writeOnly = writeOnly;\n    return this;\n  }\n\n  public ChangedSchema setChangedType(final boolean changedType) {\n    clearChangedCache();\n    this.changedType = changedType;\n    return this;\n  }\n\n  public ChangedSchema setMaxLength(final ChangedMaxLength maxLength) {\n    clearChangedCache();\n    this.maxLength = maxLength;\n    return this;\n  }\n\n  public ChangedSchema setNumericRange(final ChangedNumericRange numericRange) {\n    clearChangedCache();\n    this.numericRange = numericRange;\n    return this;\n  }\n\n  public ChangedSchema setDiscriminatorPropertyChanged(final boolean discriminatorPropertyChanged) {\n    clearChangedCache();\n    this.discriminatorPropertyChanged = discriminatorPropertyChanged;\n    return this;\n  }\n\n  public ChangedSchema setItems(final ChangedSchema items) {\n    clearChangedCache();\n    this.items = items;\n    return this;\n  }\n\n  public ChangedSchema setOneOfSchema(final ChangedOneOfSchema oneOfSchema) {\n    clearChangedCache();\n    this.oneOfSchema = oneOfSchema;\n    return this;\n  }\n\n  public ChangedSchema setAddProp(final ChangedSchema addProp) {\n    clearChangedCache();\n    this.addProp = addProp;\n    return this;\n  }\n\n  public ChangedSchema setExtensions(final ChangedExtensions extensions) {\n    clearChangedCache();\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSchema that = (ChangedSchema) o;\n    return changeDeprecated == that.changeDeprecated\n        && changeTitle == that.changeTitle\n        && changeDefault == that.changeDefault\n        && changeFormat == that.changeFormat\n        && changedType == that.changedType\n        && discriminatorPropertyChanged == that.discriminatorPropertyChanged\n        && Objects.equals(context, that.context)\n        && Objects.equals(oldSchema, that.oldSchema)\n        && Objects.equals(newSchema, that.newSchema)\n        && Objects.equals(type, that.type)\n        && Objects.equals(changedProperties, that.changedProperties)\n        && Objects.equals(increasedProperties, that.increasedProperties)\n        && Objects.equals(missingProperties, that.missingProperties)\n        && Objects.equals(description, that.description)\n        && Objects.equals(required, that.required)\n        && Objects.equals(enumeration, that.enumeration)\n        && Objects.equals(readOnly, that.readOnly)\n        && Objects.equals(writeOnly, that.writeOnly)\n        && Objects.equals(maxLength, that.maxLength)\n        && Objects.equals(numericRange, that.numericRange)\n        && Objects.equals(items, that.items)\n        && Objects.equals(oneOfSchema, that.oneOfSchema)\n        && Objects.equals(addProp, that.addProp)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        context,\n        oldSchema,\n        newSchema,\n        type,\n        changedProperties,\n        increasedProperties,\n        missingProperties,\n        changeDeprecated,\n        description,\n        changeTitle,\n        required,\n        changeDefault,\n        enumeration,\n        changeFormat,\n        readOnly,\n        writeOnly,\n        changedType,\n        maxLength,\n        numericRange,\n        discriminatorPropertyChanged,\n        items,\n        oneOfSchema,\n        addProp,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSchema(context=\"\n        + this.getContext()\n        + \", oldSchema=\"\n        + this.getOldSchema()\n        + \", newSchema=\"\n        + this.getNewSchema()\n        + \", type=\"\n        + this.getType()\n        + \", changedProperties=\"\n        + this.getChangedProperties()\n        + \", increasedProperties=\"\n        + this.getIncreasedProperties()\n        + \", missingProperties=\"\n        + this.getMissingProperties()\n        + \", changeDeprecated=\"\n        + this.isChangeDeprecated()\n        + \", description=\"\n        + this.getDescription()\n        + \", changeTitle=\"\n        + this.isChangeTitle()\n        + \", required=\"\n        + this.getRequired()\n        + \", changeDefault=\"\n        + this.isChangeDefault()\n        + \", enumeration=\"\n        + this.getEnumeration()\n        + \", changeFormat=\"\n        + this.isChangeFormat()\n        + \", readOnly=\"\n        + this.getReadOnly()\n        + \", writeOnly=\"\n        + this.getWriteOnly()\n        + \", changedType=\"\n        + this.isChangedType()\n        + \", maxLength=\"\n        + this.getMaxLength()\n        + \", discriminatorPropertyChanged=\"\n        + this.isDiscriminatorPropertyChanged()\n        + \", items=\"\n        + this.getItems()\n        + \", oneOfSchema=\"\n        + this.getOneOfSchema()\n        + \", addProp=\"\n        + this.getAddProp()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}\n", "file_hash": "ba9deddba2ba93cfea2e07dcd654a77823b1ccd52e23f90c5f4a150384eb0002", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_REQUIRED_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SCHEMA_DISCRIMINATOR_CHANGED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.SCHEMA_TYPE_CHANGED;", "import io.swagger.v3.oas.models.media.Schema;", "import java.util.*;", "import java.util.stream.Collectors;", "import java.util.stream.Stream;", "import org.openapitools.openapidiff.core.model.schema.ChangedEnum;", "import org.openapitools.openapidiff.core.model.schema.ChangedMaxLength;", "import org.openapitools.openapidiff.core.model.schema.ChangedNumericRange;", "import org.openapitools.openapidiff.core.model.schema.ChangedReadOnly;", "import org.openapitools.openapidiff.core.model.schema.ChangedRequired;", "import org.openapitools.openapidiff.core.model.schema.ChangedWriteOnly;"], "methods": [], "classes": [{"original_string": "public class ChangedSchema implements ComposedChanged {\n  protected DiffContext context;\n  protected Schema<?> oldSchema;\n  protected Schema<?> newSchema;\n  protected String type;\n  protected Map<String, ChangedSchema> changedProperties;\n  protected Map<String, Schema<?>> increasedProperties;\n  protected Map<String, Schema<?>> missingProperties;\n  protected boolean changeDeprecated;\n  protected ChangedMetadata description;\n  protected boolean changeTitle;\n  protected ChangedRequired required;\n  protected boolean changeDefault;\n  protected ChangedEnum<?> enumeration;\n  protected boolean changeFormat;\n  protected ChangedReadOnly readOnly;\n  protected ChangedWriteOnly writeOnly;\n  protected boolean changedType;\n  protected ChangedMaxLength maxLength;\n  protected ChangedNumericRange numericRange;\n  protected boolean discriminatorPropertyChanged;\n  protected ChangedSchema items;\n  protected ChangedOneOfSchema oneOfSchema;\n  protected ChangedSchema addProp;\n  private ChangedExtensions extensions;\n\n  // Flags to avoid recursive calls to isChanged() and getChangedElements()\n  private boolean gettingChangedElements = false;\n  private boolean gettingIsChanged = false;\n\n  // cached results for isChanged()\n  private DiffResult changed;\n  private DiffResult coreChanged;\n\n  // cached results for getChangedElements()\n  private List<Changed> changedElements;\n\n  public ChangedSchema() {\n    increasedProperties = new LinkedHashMap<>();\n    missingProperties = new LinkedHashMap<>();\n    changedProperties = new LinkedHashMap<>();\n  }\n\n  private void clearChangedCache() {\n    this.changed = null;\n    this.coreChanged = null;\n    this.changedElements = null;\n  }\n\n  @Override\n  public DiffResult isChanged() {\n    if (gettingIsChanged) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    gettingIsChanged = true;\n    if (this.changed == null) {\n      DiffResult elementsResult =\n          DiffResult.fromWeight(\n              getChangedElements().stream()\n                  .filter(Objects::nonNull)\n                  .map(Changed::isChanged)\n                  .mapToInt(DiffResult::getWeight)\n                  .max()\n                  .orElse(0));\n      DiffResult result;\n      if (isCoreChanged().getWeight() > elementsResult.getWeight()) {\n        result = isCoreChanged();\n      } else {\n        result = elementsResult;\n      }\n      this.changed = result;\n    }\n    gettingIsChanged = false;\n\n    return this.changed;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    if (gettingChangedElements) {\n      return Collections.emptyList();\n    }\n\n    gettingChangedElements = true;\n    if (changedElements == null) {\n      this.changedElements =\n          Stream.concat(\n                  changedProperties.values().stream(),\n                  Stream.of(\n                      description,\n                      readOnly,\n                      writeOnly,\n                      items,\n                      oneOfSchema,\n                      addProp,\n                      enumeration,\n                      required,\n                      maxLength,\n                      numericRange,\n                      extensions))\n              .collect(Collectors.toList());\n    }\n    gettingChangedElements = false;\n\n    return this.changedElements;\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (this.coreChanged == null) {\n      this.coreChanged = calculateCoreChanged();\n    }\n\n    return this.coreChanged;\n  }\n\n  private DiffResult calculateCoreChanged() {\n    if (!changedType\n        && (oldSchema == null && newSchema == null || oldSchema != null && newSchema != null)\n        && !changeFormat\n        && increasedProperties.isEmpty()\n        && missingProperties.isEmpty()\n        && changedProperties.values().isEmpty()\n        && !changeDeprecated\n        && !discriminatorPropertyChanged) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (changedType) {\n      if (SCHEMA_TYPE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (discriminatorPropertyChanged) {\n      if (SCHEMA_DISCRIMINATOR_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n\n    if (!compatibleForRequest() || !compatibleForResponse()) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  private boolean compatibleForRequest() {\n    if (context.isRequest()) {\n      if (oldSchema == null && newSchema != null) {\n        // TODO: dead code? If not, create test.\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean compatibleForResponse() {\n    if (context.isResponse()) {\n      if (oldSchema != null) {\n        if (newSchema == null) {\n          // TODO: dead code? If not, create test.\n          return false;\n        }\n        if (oldSchema.getRequired() != null\n            && missingProperties.keySet().stream()\n                .anyMatch(prop -> oldSchema.getRequired().contains(prop))) {\n          if (RESPONSE_REQUIRED_DECREASED.enabled(context)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Schema<?> getOldSchema() {\n    return this.oldSchema;\n  }\n\n  public Schema<?> getNewSchema() {\n    return this.newSchema;\n  }\n\n  public String getType() {\n    return this.type;\n  }\n\n  public Map<String, ChangedSchema> getChangedProperties() {\n    return this.changedProperties;\n  }\n\n  public Map<String, Schema<?>> getIncreasedProperties() {\n    return this.increasedProperties;\n  }\n\n  public Map<String, Schema<?>> getMissingProperties() {\n    return this.missingProperties;\n  }\n\n  public boolean isChangeDeprecated() {\n    return this.changeDeprecated;\n  }\n\n  public ChangedMetadata getDescription() {\n    return this.description;\n  }\n\n  public boolean isChangeTitle() {\n    return this.changeTitle;\n  }\n\n  public ChangedRequired getRequired() {\n    return this.required;\n  }\n\n  public boolean isChangeDefault() {\n    return this.changeDefault;\n  }\n\n  public ChangedEnum<?> getEnumeration() {\n    return this.enumeration;\n  }\n\n  public boolean isChangeFormat() {\n    return this.changeFormat;\n  }\n\n  public ChangedReadOnly getReadOnly() {\n    return this.readOnly;\n  }\n\n  public ChangedWriteOnly getWriteOnly() {\n    return this.writeOnly;\n  }\n\n  public boolean isChangedType() {\n    return this.changedType;\n  }\n\n  public ChangedMaxLength getMaxLength() {\n    return this.maxLength;\n  }\n\n  public boolean isDiscriminatorPropertyChanged() {\n    return this.discriminatorPropertyChanged;\n  }\n\n  public ChangedSchema getItems() {\n    return this.items;\n  }\n\n  public ChangedOneOfSchema getOneOfSchema() {\n    return this.oneOfSchema;\n  }\n\n  public ChangedSchema getAddProp() {\n    return this.addProp;\n  }\n\n  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }\n\n  public ChangedSchema setContext(final DiffContext context) {\n    this.context = context;\n    return this;\n  }\n\n  public ChangedSchema setOldSchema(final Schema<?> oldSchema) {\n    this.oldSchema = oldSchema;\n    return this;\n  }\n\n  public ChangedSchema setNewSchema(final Schema<?> newSchema) {\n    this.newSchema = newSchema;\n    return this;\n  }\n\n  public ChangedSchema setType(final String type) {\n    this.type = type;\n    return this;\n  }\n\n  public ChangedSchema setChangedProperties(final Map<String, ChangedSchema> changedProperties) {\n    clearChangedCache();\n    this.changedProperties = changedProperties;\n    return this;\n  }\n\n  public ChangedSchema setIncreasedProperties(final Map<String, Schema<?>> increasedProperties) {\n    clearChangedCache();\n    this.increasedProperties = increasedProperties;\n    return this;\n  }\n\n  public ChangedSchema setMissingProperties(final Map<String, Schema<?>> missingProperties) {\n    clearChangedCache();\n    this.missingProperties = missingProperties;\n    return this;\n  }\n\n  public ChangedSchema setChangeDeprecated(final boolean changeDeprecated) {\n    clearChangedCache();\n    this.changeDeprecated = changeDeprecated;\n    return this;\n  }\n\n  public ChangedSchema setDescription(final ChangedMetadata description) {\n    clearChangedCache();\n    this.description = description;\n    return this;\n  }\n\n  public ChangedSchema setChangeTitle(final boolean changeTitle) {\n    clearChangedCache();\n    this.changeTitle = changeTitle;\n    return this;\n  }\n\n  public ChangedSchema setRequired(final ChangedRequired required) {\n    clearChangedCache();\n    this.required = required;\n    return this;\n  }\n\n  public ChangedSchema setChangeDefault(final boolean changeDefault) {\n    clearChangedCache();\n    this.changeDefault = changeDefault;\n    return this;\n  }\n\n  public ChangedSchema setEnumeration(final ChangedEnum<?> enumeration) {\n    clearChangedCache();\n    this.enumeration = enumeration;\n    return this;\n  }\n\n  public ChangedSchema setChangeFormat(final boolean changeFormat) {\n    clearChangedCache();\n    this.changeFormat = changeFormat;\n    return this;\n  }\n\n  public ChangedSchema setReadOnly(final ChangedReadOnly readOnly) {\n    clearChangedCache();\n    this.readOnly = readOnly;\n    return this;\n  }\n\n  public ChangedSchema setWriteOnly(final ChangedWriteOnly writeOnly) {\n    clearChangedCache();\n    this.writeOnly = writeOnly;\n    return this;\n  }\n\n  public ChangedSchema setChangedType(final boolean changedType) {\n    clearChangedCache();\n    this.changedType = changedType;\n    return this;\n  }\n\n  public ChangedSchema setMaxLength(final ChangedMaxLength maxLength) {\n    clearChangedCache();\n    this.maxLength = maxLength;\n    return this;\n  }\n\n  public ChangedSchema setNumericRange(final ChangedNumericRange numericRange) {\n    clearChangedCache();\n    this.numericRange = numericRange;\n    return this;\n  }\n\n  public ChangedSchema setDiscriminatorPropertyChanged(final boolean discriminatorPropertyChanged) {\n    clearChangedCache();\n    this.discriminatorPropertyChanged = discriminatorPropertyChanged;\n    return this;\n  }\n\n  public ChangedSchema setItems(final ChangedSchema items) {\n    clearChangedCache();\n    this.items = items;\n    return this;\n  }\n\n  public ChangedSchema setOneOfSchema(final ChangedOneOfSchema oneOfSchema) {\n    clearChangedCache();\n    this.oneOfSchema = oneOfSchema;\n    return this;\n  }\n\n  public ChangedSchema setAddProp(final ChangedSchema addProp) {\n    clearChangedCache();\n    this.addProp = addProp;\n    return this;\n  }\n\n  public ChangedSchema setExtensions(final ChangedExtensions extensions) {\n    clearChangedCache();\n    this.extensions = extensions;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSchema that = (ChangedSchema) o;\n    return changeDeprecated == that.changeDeprecated\n        && changeTitle == that.changeTitle\n        && changeDefault == that.changeDefault\n        && changeFormat == that.changeFormat\n        && changedType == that.changedType\n        && discriminatorPropertyChanged == that.discriminatorPropertyChanged\n        && Objects.equals(context, that.context)\n        && Objects.equals(oldSchema, that.oldSchema)\n        && Objects.equals(newSchema, that.newSchema)\n        && Objects.equals(type, that.type)\n        && Objects.equals(changedProperties, that.changedProperties)\n        && Objects.equals(increasedProperties, that.increasedProperties)\n        && Objects.equals(missingProperties, that.missingProperties)\n        && Objects.equals(description, that.description)\n        && Objects.equals(required, that.required)\n        && Objects.equals(enumeration, that.enumeration)\n        && Objects.equals(readOnly, that.readOnly)\n        && Objects.equals(writeOnly, that.writeOnly)\n        && Objects.equals(maxLength, that.maxLength)\n        && Objects.equals(numericRange, that.numericRange)\n        && Objects.equals(items, that.items)\n        && Objects.equals(oneOfSchema, that.oneOfSchema)\n        && Objects.equals(addProp, that.addProp)\n        && Objects.equals(extensions, that.extensions);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        context,\n        oldSchema,\n        newSchema,\n        type,\n        changedProperties,\n        increasedProperties,\n        missingProperties,\n        changeDeprecated,\n        description,\n        changeTitle,\n        required,\n        changeDefault,\n        enumeration,\n        changeFormat,\n        readOnly,\n        writeOnly,\n        changedType,\n        maxLength,\n        numericRange,\n        discriminatorPropertyChanged,\n        items,\n        oneOfSchema,\n        addProp,\n        extensions);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSchema(context=\"\n        + this.getContext()\n        + \", oldSchema=\"\n        + this.getOldSchema()\n        + \", newSchema=\"\n        + this.getNewSchema()\n        + \", type=\"\n        + this.getType()\n        + \", changedProperties=\"\n        + this.getChangedProperties()\n        + \", increasedProperties=\"\n        + this.getIncreasedProperties()\n        + \", missingProperties=\"\n        + this.getMissingProperties()\n        + \", changeDeprecated=\"\n        + this.isChangeDeprecated()\n        + \", description=\"\n        + this.getDescription()\n        + \", changeTitle=\"\n        + this.isChangeTitle()\n        + \", required=\"\n        + this.getRequired()\n        + \", changeDefault=\"\n        + this.isChangeDefault()\n        + \", enumeration=\"\n        + this.getEnumeration()\n        + \", changeFormat=\"\n        + this.isChangeFormat()\n        + \", readOnly=\"\n        + this.getReadOnly()\n        + \", writeOnly=\"\n        + this.getWriteOnly()\n        + \", changedType=\"\n        + this.isChangedType()\n        + \", maxLength=\"\n        + this.getMaxLength()\n        + \", discriminatorPropertyChanged=\"\n        + this.isDiscriminatorPropertyChanged()\n        + \", items=\"\n        + this.getItems()\n        + \", oneOfSchema=\"\n        + this.getOneOfSchema()\n        + \", addProp=\"\n        + this.getAddProp()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }\n}", "definition": "public class ChangedSchema implements ComposedChanged", "class_docstring": "", "name": "ChangedSchema", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "protected DiffContext context;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "protected Schema<?> oldSchema;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Schema<?>", "name": "oldSchema", "syntax_pass": true}, {"attribute_expression": "protected Schema<?> newSchema;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Schema<?>", "name": "newSchema", "syntax_pass": true}, {"attribute_expression": "protected String type;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "type", "syntax_pass": true}, {"attribute_expression": "protected Map<String, ChangedSchema> changedProperties;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Map<String, ChangedSchema>", "name": "changedProperties", "syntax_pass": true}, {"attribute_expression": "protected Map<String, Schema<?>> increasedProperties;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Map<String, Schema<?>>", "name": "increasedProperties", "syntax_pass": true}, {"attribute_expression": "protected Map<String, Schema<?>> missingProperties;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Map<String, Schema<?>>", "name": "missingProperties", "syntax_pass": true}, {"attribute_expression": "protected boolean changeDeprecated;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "changeDeprecated", "syntax_pass": true}, {"attribute_expression": "protected ChangedMetadata description;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedMetadata", "name": "description", "syntax_pass": true}, {"attribute_expression": "protected boolean changeTitle;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "changeTitle", "syntax_pass": true}, {"attribute_expression": "protected ChangedRequired required;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedRequired", "name": "required", "syntax_pass": true}, {"attribute_expression": "protected boolean changeDefault;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "changeDefault", "syntax_pass": true}, {"attribute_expression": "protected ChangedEnum<?> enumeration;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedEnum<?>", "name": "enumeration", "syntax_pass": true}, {"attribute_expression": "protected boolean changeFormat;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "changeFormat", "syntax_pass": true}, {"attribute_expression": "protected ChangedReadOnly readOnly;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedReadOnly", "name": "readOnly", "syntax_pass": true}, {"attribute_expression": "protected ChangedWriteOnly writeOnly;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedWriteOnly", "name": "writeOnly", "syntax_pass": true}, {"attribute_expression": "protected boolean changedType;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "changedType", "syntax_pass": true}, {"attribute_expression": "protected ChangedMaxLength maxLength;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedMaxLength", "name": "maxLength", "syntax_pass": true}, {"attribute_expression": "protected ChangedNumericRange numericRange;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedNumericRange", "name": "numericRange", "syntax_pass": true}, {"attribute_expression": "protected boolean discriminatorPropertyChanged;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "discriminatorPropertyChanged", "syntax_pass": true}, {"attribute_expression": "protected ChangedSchema items;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedSchema", "name": "items", "syntax_pass": true}, {"attribute_expression": "protected ChangedOneOfSchema oneOfSchema;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedOneOfSchema", "name": "oneOfSchema", "syntax_pass": true}, {"attribute_expression": "protected ChangedSchema addProp;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedSchema", "name": "addProp", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions extensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "extensions", "syntax_pass": true}, {"attribute_expression": "private boolean gettingChangedElements = false;", "docstring": " Flags to avoid recursive calls to isChanged() and getChangedElements()", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "gettingChangedElements = false", "syntax_pass": true}, {"attribute_expression": "private boolean gettingIsChanged = false;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "gettingIsChanged = false", "syntax_pass": true}, {"attribute_expression": "private DiffResult changed;", "docstring": " cached results for isChanged()", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DiffResult", "name": "changed", "syntax_pass": true}, {"attribute_expression": "private DiffResult coreChanged;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DiffResult", "name": "coreChanged", "syntax_pass": true}, {"attribute_expression": "private List<Changed> changedElements;", "docstring": " cached results for getChangedElements()", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Changed>", "name": "changedElements", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedSchema() {\n    increasedProperties = new LinkedHashMap<>();\n    missingProperties = new LinkedHashMap<>();\n    changedProperties = new LinkedHashMap<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedSchema", "params": [], "body": "                         {\n    increasedProperties = new LinkedHashMap<>();\n    missingProperties = new LinkedHashMap<>();\n    changedProperties = new LinkedHashMap<>();\n  }", "signature": "public ChangedSchema()"}, {"syntax_pass": true, "original_string": "  private void clearChangedCache() {\n    this.changed = null;\n    this.coreChanged = null;\n    this.changedElements = null;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "clearChangedCache", "params": [], "body": "                                   {\n    this.changed = null;\n    this.coreChanged = null;\n    this.changedElements = null;\n  }", "signature": "private void clearChangedCache()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isChanged() {\n    if (gettingIsChanged) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    gettingIsChanged = true;\n    if (this.changed == null) {\n      DiffResult elementsResult =\n          DiffResult.fromWeight(\n              getChangedElements().stream()\n                  .filter(Objects::nonNull)\n                  .map(Changed::isChanged)\n                  .mapToInt(DiffResult::getWeight)\n                  .max()\n                  .orElse(0));\n      DiffResult result;\n      if (isCoreChanged().getWeight() > elementsResult.getWeight()) {\n        result = isCoreChanged();\n      } else {\n        result = elementsResult;\n      }\n      this.changed = result;\n    }\n    gettingIsChanged = false;\n\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isChanged", "params": [], "body": "                                {\n    if (gettingIsChanged) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    gettingIsChanged = true;\n    if (this.changed == null) {\n      DiffResult elementsResult =\n          DiffResult.fromWeight(\n              getChangedElements().stream()\n                  .filter(Objects::nonNull)\n                  .map(Changed::isChanged)\n                  .mapToInt(DiffResult::getWeight)\n                  .max()\n                  .orElse(0));\n      DiffResult result;\n      if (isCoreChanged().getWeight() > elementsResult.getWeight()) {\n        result = isCoreChanged();\n      } else {\n        result = elementsResult;\n      }\n      this.changed = result;\n    }\n    gettingIsChanged = false;\n\n    return this.changed;\n  }", "signature": "@Override\n  public DiffResult isChanged()"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    if (gettingChangedElements) {\n      return Collections.emptyList();\n    }\n\n    gettingChangedElements = true;\n    if (changedElements == null) {\n      this.changedElements =\n          Stream.concat(\n                  changedProperties.values().stream(),\n                  Stream.of(\n                      description,\n                      readOnly,\n                      writeOnly,\n                      items,\n                      oneOfSchema,\n                      addProp,\n                      enumeration,\n                      required,\n                      maxLength,\n                      numericRange,\n                      extensions))\n              .collect(Collectors.toList());\n    }\n    gettingChangedElements = false;\n\n    return this.changedElements;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    if (gettingChangedElements) {\n      return Collections.emptyList();\n    }\n\n    gettingChangedElements = true;\n    if (changedElements == null) {\n      this.changedElements =\n          Stream.concat(\n                  changedProperties.values().stream(),\n                  Stream.of(\n                      description,\n                      readOnly,\n                      writeOnly,\n                      items,\n                      oneOfSchema,\n                      addProp,\n                      enumeration,\n                      required,\n                      maxLength,\n                      numericRange,\n                      extensions))\n              .collect(Collectors.toList());\n    }\n    gettingChangedElements = false;\n\n    return this.changedElements;\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (this.coreChanged == null) {\n      this.coreChanged = calculateCoreChanged();\n    }\n\n    return this.coreChanged;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (this.coreChanged == null) {\n      this.coreChanged = calculateCoreChanged();\n    }\n\n    return this.coreChanged;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  private DiffResult calculateCoreChanged() {\n    if (!changedType\n        && (oldSchema == null && newSchema == null || oldSchema != null && newSchema != null)\n        && !changeFormat\n        && increasedProperties.isEmpty()\n        && missingProperties.isEmpty()\n        && changedProperties.values().isEmpty()\n        && !changeDeprecated\n        && !discriminatorPropertyChanged) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (changedType) {\n      if (SCHEMA_TYPE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (discriminatorPropertyChanged) {\n      if (SCHEMA_DISCRIMINATOR_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n\n    if (!compatibleForRequest() || !compatibleForResponse()) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "calculateCoreChanged", "params": [], "body": "                                            {\n    if (!changedType\n        && (oldSchema == null && newSchema == null || oldSchema != null && newSchema != null)\n        && !changeFormat\n        && increasedProperties.isEmpty()\n        && missingProperties.isEmpty()\n        && changedProperties.values().isEmpty()\n        && !changeDeprecated\n        && !discriminatorPropertyChanged) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (changedType) {\n      if (SCHEMA_TYPE_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (discriminatorPropertyChanged) {\n      if (SCHEMA_DISCRIMINATOR_CHANGED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n\n    if (!compatibleForRequest() || !compatibleForResponse()) {\n      return DiffResult.INCOMPATIBLE;\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "private DiffResult calculateCoreChanged()"}, {"syntax_pass": true, "original_string": "  private boolean compatibleForRequest() {\n    if (context.isRequest()) {\n      if (oldSchema == null && newSchema != null) {\n        // TODO: dead code? If not, create test.\n        return false;\n      }\n    }\n    return true;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "compatibleForRequest", "params": [], "body": "                                         {\n    if (context.isRequest()) {\n      if (oldSchema == null && newSchema != null) {\n        // TODO: dead code? If not, create test.\n        return false;\n      }\n    }\n    return true;\n  }", "signature": "private boolean compatibleForRequest()"}, {"syntax_pass": true, "original_string": "  private boolean compatibleForResponse() {\n    if (context.isResponse()) {\n      if (oldSchema != null) {\n        if (newSchema == null) {\n          // TODO: dead code? If not, create test.\n          return false;\n        }\n        if (oldSchema.getRequired() != null\n            && missingProperties.keySet().stream()\n                .anyMatch(prop -> oldSchema.getRequired().contains(prop))) {\n          if (RESPONSE_REQUIRED_DECREASED.enabled(context)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "compatibleForResponse", "params": [], "body": "                                          {\n    if (context.isResponse()) {\n      if (oldSchema != null) {\n        if (newSchema == null) {\n          // TODO: dead code? If not, create test.\n          return false;\n        }\n        if (oldSchema.getRequired() != null\n            && missingProperties.keySet().stream()\n                .anyMatch(prop -> oldSchema.getRequired().contains(prop))) {\n          if (RESPONSE_REQUIRED_DECREASED.enabled(context)) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }", "signature": "private boolean compatibleForResponse()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public Schema<?> getOldSchema() {\n    return this.oldSchema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Schema<?>", "classes": []}, "name": "getOldSchema", "params": [], "body": "                                  {\n    return this.oldSchema;\n  }", "signature": "public Schema<?> getOldSchema()"}, {"syntax_pass": true, "original_string": "  public Schema<?> getNewSchema() {\n    return this.newSchema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Schema<?>", "classes": []}, "name": "getNewSchema", "params": [], "body": "                                  {\n    return this.newSchema;\n  }", "signature": "public Schema<?> getNewSchema()"}, {"syntax_pass": true, "original_string": "  public String getType() {\n    return this.type;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getType", "params": [], "body": "                          {\n    return this.type;\n  }", "signature": "public String getType()"}, {"syntax_pass": true, "original_string": "  public Map<String, ChangedSchema> getChangedProperties() {\n    return this.changedProperties;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ChangedSchema>", "classes": []}, "name": "getChangedProperties", "params": [], "body": "                                                           {\n    return this.changedProperties;\n  }", "signature": "public Map<String, ChangedSchema> getChangedProperties()"}, {"syntax_pass": true, "original_string": "  public Map<String, Schema<?>> getIncreasedProperties() {\n    return this.increasedProperties;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Schema<?>>", "classes": []}, "name": "getIncreasedProperties", "params": [], "body": "                                                         {\n    return this.increasedProperties;\n  }", "signature": "public Map<String, Schema<?>> getIncreasedProperties()"}, {"syntax_pass": true, "original_string": "  public Map<String, Schema<?>> getMissingProperties() {\n    return this.missingProperties;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Schema<?>>", "classes": []}, "name": "getMissingProperties", "params": [], "body": "                                                       {\n    return this.missingProperties;\n  }", "signature": "public Map<String, Schema<?>> getMissingProperties()"}, {"syntax_pass": true, "original_string": "  public boolean isChangeDeprecated() {\n    return this.changeDeprecated;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangeDeprecated", "params": [], "body": "                                      {\n    return this.changeDeprecated;\n  }", "signature": "public boolean isChangeDeprecated()"}, {"syntax_pass": true, "original_string": "  public ChangedMetadata getDescription() {\n    return this.description;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMetadata", "classes": []}, "name": "getDescription", "params": [], "body": "                                          {\n    return this.description;\n  }", "signature": "public ChangedMetadata getDescription()"}, {"syntax_pass": true, "original_string": "  public boolean isChangeTitle() {\n    return this.changeTitle;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangeTitle", "params": [], "body": "                                 {\n    return this.changeTitle;\n  }", "signature": "public boolean isChangeTitle()"}, {"syntax_pass": true, "original_string": "  public ChangedRequired getRequired() {\n    return this.required;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedRequired", "classes": []}, "name": "getRequired", "params": [], "body": "                                       {\n    return this.required;\n  }", "signature": "public ChangedRequired getRequired()"}, {"syntax_pass": true, "original_string": "  public boolean isChangeDefault() {\n    return this.changeDefault;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangeDefault", "params": [], "body": "                                   {\n    return this.changeDefault;\n  }", "signature": "public boolean isChangeDefault()"}, {"syntax_pass": true, "original_string": "  public ChangedEnum<?> getEnumeration() {\n    return this.enumeration;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedEnum<?>", "classes": []}, "name": "getEnumeration", "params": [], "body": "                                         {\n    return this.enumeration;\n  }", "signature": "public ChangedEnum<?> getEnumeration()"}, {"syntax_pass": true, "original_string": "  public boolean isChangeFormat() {\n    return this.changeFormat;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangeFormat", "params": [], "body": "                                  {\n    return this.changeFormat;\n  }", "signature": "public boolean isChangeFormat()"}, {"syntax_pass": true, "original_string": "  public ChangedReadOnly getReadOnly() {\n    return this.readOnly;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedReadOnly", "classes": []}, "name": "getReadOnly", "params": [], "body": "                                       {\n    return this.readOnly;\n  }", "signature": "public ChangedReadOnly getReadOnly()"}, {"syntax_pass": true, "original_string": "  public ChangedWriteOnly getWriteOnly() {\n    return this.writeOnly;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedWriteOnly", "classes": []}, "name": "getWriteOnly", "params": [], "body": "                                         {\n    return this.writeOnly;\n  }", "signature": "public ChangedWriteOnly getWriteOnly()"}, {"syntax_pass": true, "original_string": "  public boolean isChangedType() {\n    return this.changedType;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isChangedType", "params": [], "body": "                                 {\n    return this.changedType;\n  }", "signature": "public boolean isChangedType()"}, {"syntax_pass": true, "original_string": "  public ChangedMaxLength getMaxLength() {\n    return this.maxLength;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedMaxLength", "classes": []}, "name": "getMaxLength", "params": [], "body": "                                         {\n    return this.maxLength;\n  }", "signature": "public ChangedMaxLength getMaxLength()"}, {"syntax_pass": true, "original_string": "  public boolean isDiscriminatorPropertyChanged() {\n    return this.discriminatorPropertyChanged;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isDiscriminatorPropertyChanged", "params": [], "body": "                                                  {\n    return this.discriminatorPropertyChanged;\n  }", "signature": "public boolean isDiscriminatorPropertyChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedSchema getItems() {\n    return this.items;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "getItems", "params": [], "body": "                                  {\n    return this.items;\n  }", "signature": "public ChangedSchema getItems()"}, {"syntax_pass": true, "original_string": "  public ChangedOneOfSchema getOneOfSchema() {\n    return this.oneOfSchema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOneOfSchema", "classes": []}, "name": "getOneOfSchema", "params": [], "body": "                                             {\n    return this.oneOfSchema;\n  }", "signature": "public ChangedOneOfSchema getOneOfSchema()"}, {"syntax_pass": true, "original_string": "  public ChangedSchema getAddProp() {\n    return this.addProp;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "getAddProp", "params": [], "body": "                                    {\n    return this.addProp;\n  }", "signature": "public ChangedSchema getAddProp()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getExtensions() {\n    return this.extensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getExtensions", "params": [], "body": "                                           {\n    return this.extensions;\n  }", "signature": "public ChangedExtensions getExtensions()"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setContext(final DiffContext context) {\n    this.context = context;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setContext", "params": [{"name": "context", "type": "DiffContext"}], "body": "                                                             {\n    this.context = context;\n    return this;\n  }", "signature": "public ChangedSchema setContext(final DiffContext context)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setOldSchema(final Schema<?> oldSchema) {\n    this.oldSchema = oldSchema;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setOldSchema", "params": [{"name": "oldSchema", "type": "Schema<?>"}], "body": "                                                               {\n    this.oldSchema = oldSchema;\n    return this;\n  }", "signature": "public ChangedSchema setOldSchema(final Schema<?> oldSchema)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setNewSchema(final Schema<?> newSchema) {\n    this.newSchema = newSchema;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setNewSchema", "params": [{"name": "newSchema", "type": "Schema<?>"}], "body": "                                                               {\n    this.newSchema = newSchema;\n    return this;\n  }", "signature": "public ChangedSchema setNewSchema(final Schema<?> newSchema)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setType(final String type) {\n    this.type = type;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setType", "params": [{"name": "type", "type": "String"}], "body": "                                                  {\n    this.type = type;\n    return this;\n  }", "signature": "public ChangedSchema setType(final String type)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setChangedProperties(final Map<String, ChangedSchema> changedProperties) {\n    clearChangedCache();\n    this.changedProperties = changedProperties;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setChangedProperties", "params": [{"name": "changedProperties", "type": "Map<String, ChangedSchema>"}], "body": "                                                                                                {\n    clearChangedCache();\n    this.changedProperties = changedProperties;\n    return this;\n  }", "signature": "public ChangedSchema setChangedProperties(final Map<String, ChangedSchema> changedProperties)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setIncreasedProperties(final Map<String, Schema<?>> increasedProperties) {\n    clearChangedCache();\n    this.increasedProperties = increasedProperties;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setIncreasedProperties", "params": [{"name": "increasedProperties", "type": "Map<String, Schema<?>>"}], "body": "                                                                                                {\n    clearChangedCache();\n    this.increasedProperties = increasedProperties;\n    return this;\n  }", "signature": "public ChangedSchema setIncreasedProperties(final Map<String, Schema<?>> increasedProperties)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setMissingProperties(final Map<String, Schema<?>> missingProperties) {\n    clearChangedCache();\n    this.missingProperties = missingProperties;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setMissingProperties", "params": [{"name": "missingProperties", "type": "Map<String, Schema<?>>"}], "body": "                                                                                            {\n    clearChangedCache();\n    this.missingProperties = missingProperties;\n    return this;\n  }", "signature": "public ChangedSchema setMissingProperties(final Map<String, Schema<?>> missingProperties)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setChangeDeprecated(final boolean changeDeprecated) {\n    clearChangedCache();\n    this.changeDeprecated = changeDeprecated;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setChangeDeprecated", "params": [{"name": "changeDeprecated", "type": "boolean"}], "body": "                                                                           {\n    clearChangedCache();\n    this.changeDeprecated = changeDeprecated;\n    return this;\n  }", "signature": "public ChangedSchema setChangeDeprecated(final boolean changeDeprecated)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setDescription(final ChangedMetadata description) {\n    clearChangedCache();\n    this.description = description;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "ChangedMetadata"}], "body": "                                                                         {\n    clearChangedCache();\n    this.description = description;\n    return this;\n  }", "signature": "public ChangedSchema setDescription(final ChangedMetadata description)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setChangeTitle(final boolean changeTitle) {\n    clearChangedCache();\n    this.changeTitle = changeTitle;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setChangeTitle", "params": [{"name": "changeTitle", "type": "boolean"}], "body": "                                                                 {\n    clearChangedCache();\n    this.changeTitle = changeTitle;\n    return this;\n  }", "signature": "public ChangedSchema setChangeTitle(final boolean changeTitle)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setRequired(final ChangedRequired required) {\n    clearChangedCache();\n    this.required = required;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setRequired", "params": [{"name": "required", "type": "ChangedRequired"}], "body": "                                                                   {\n    clearChangedCache();\n    this.required = required;\n    return this;\n  }", "signature": "public ChangedSchema setRequired(final ChangedRequired required)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setChangeDefault(final boolean changeDefault) {\n    clearChangedCache();\n    this.changeDefault = changeDefault;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setChangeDefault", "params": [{"name": "changeDefault", "type": "boolean"}], "body": "                                                                     {\n    clearChangedCache();\n    this.changeDefault = changeDefault;\n    return this;\n  }", "signature": "public ChangedSchema setChangeDefault(final boolean changeDefault)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setEnumeration(final ChangedEnum<?> enumeration) {\n    clearChangedCache();\n    this.enumeration = enumeration;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setEnumeration", "params": [{"name": "enumeration", "type": "ChangedEnum<?>"}], "body": "                                                                        {\n    clearChangedCache();\n    this.enumeration = enumeration;\n    return this;\n  }", "signature": "public ChangedSchema setEnumeration(final ChangedEnum<?> enumeration)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setChangeFormat(final boolean changeFormat) {\n    clearChangedCache();\n    this.changeFormat = changeFormat;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setChangeFormat", "params": [{"name": "changeFormat", "type": "boolean"}], "body": "                                                                   {\n    clearChangedCache();\n    this.changeFormat = changeFormat;\n    return this;\n  }", "signature": "public ChangedSchema setChangeFormat(final boolean changeFormat)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setReadOnly(final ChangedReadOnly readOnly) {\n    clearChangedCache();\n    this.readOnly = readOnly;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setReadOnly", "params": [{"name": "readOnly", "type": "ChangedReadOnly"}], "body": "                                                                   {\n    clearChangedCache();\n    this.readOnly = readOnly;\n    return this;\n  }", "signature": "public ChangedSchema setReadOnly(final ChangedReadOnly readOnly)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setWriteOnly(final ChangedWriteOnly writeOnly) {\n    clearChangedCache();\n    this.writeOnly = writeOnly;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setWriteOnly", "params": [{"name": "writeOnly", "type": "ChangedWriteOnly"}], "body": "                                                                      {\n    clearChangedCache();\n    this.writeOnly = writeOnly;\n    return this;\n  }", "signature": "public ChangedSchema setWriteOnly(final ChangedWriteOnly writeOnly)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setChangedType(final boolean changedType) {\n    clearChangedCache();\n    this.changedType = changedType;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setChangedType", "params": [{"name": "changedType", "type": "boolean"}], "body": "                                                                 {\n    clearChangedCache();\n    this.changedType = changedType;\n    return this;\n  }", "signature": "public ChangedSchema setChangedType(final boolean changedType)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setMaxLength(final ChangedMaxLength maxLength) {\n    clearChangedCache();\n    this.maxLength = maxLength;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setMaxLength", "params": [{"name": "maxLength", "type": "ChangedMaxLength"}], "body": "                                                                      {\n    clearChangedCache();\n    this.maxLength = maxLength;\n    return this;\n  }", "signature": "public ChangedSchema setMaxLength(final ChangedMaxLength maxLength)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setNumericRange(final ChangedNumericRange numericRange) {\n    clearChangedCache();\n    this.numericRange = numericRange;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setNumericRange", "params": [{"name": "numericRange", "type": "ChangedNumericRange"}], "body": "                                                                               {\n    clearChangedCache();\n    this.numericRange = numericRange;\n    return this;\n  }", "signature": "public ChangedSchema setNumericRange(final ChangedNumericRange numericRange)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setDiscriminatorPropertyChanged(final boolean discriminatorPropertyChanged) {\n    clearChangedCache();\n    this.discriminatorPropertyChanged = discriminatorPropertyChanged;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setDiscriminatorPropertyChanged", "params": [{"name": "discriminatorPropertyChanged", "type": "boolean"}], "body": "                                                                                                   {\n    clearChangedCache();\n    this.discriminatorPropertyChanged = discriminatorPropertyChanged;\n    return this;\n  }", "signature": "public ChangedSchema setDiscriminatorPropertyChanged(final boolean discriminatorPropertyChanged)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setItems(final ChangedSchema items) {\n    clearChangedCache();\n    this.items = items;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setItems", "params": [{"name": "items", "type": "ChangedSchema"}], "body": "                                                           {\n    clearChangedCache();\n    this.items = items;\n    return this;\n  }", "signature": "public ChangedSchema setItems(final ChangedSchema items)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setOneOfSchema(final ChangedOneOfSchema oneOfSchema) {\n    clearChangedCache();\n    this.oneOfSchema = oneOfSchema;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setOneOfSchema", "params": [{"name": "oneOfSchema", "type": "ChangedOneOfSchema"}], "body": "                                                                            {\n    clearChangedCache();\n    this.oneOfSchema = oneOfSchema;\n    return this;\n  }", "signature": "public ChangedSchema setOneOfSchema(final ChangedOneOfSchema oneOfSchema)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setAddProp(final ChangedSchema addProp) {\n    clearChangedCache();\n    this.addProp = addProp;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setAddProp", "params": [{"name": "addProp", "type": "ChangedSchema"}], "body": "                                                               {\n    clearChangedCache();\n    this.addProp = addProp;\n    return this;\n  }", "signature": "public ChangedSchema setAddProp(final ChangedSchema addProp)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema setExtensions(final ChangedExtensions extensions) {\n    clearChangedCache();\n    this.extensions = extensions;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "setExtensions", "params": [{"name": "extensions", "type": "ChangedExtensions"}], "body": "                                                                         {\n    clearChangedCache();\n    this.extensions = extensions;\n    return this;\n  }", "signature": "public ChangedSchema setExtensions(final ChangedExtensions extensions)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSchema that = (ChangedSchema) o;\n    return changeDeprecated == that.changeDeprecated\n        && changeTitle == that.changeTitle\n        && changeDefault == that.changeDefault\n        && changeFormat == that.changeFormat\n        && changedType == that.changedType\n        && discriminatorPropertyChanged == that.discriminatorPropertyChanged\n        && Objects.equals(context, that.context)\n        && Objects.equals(oldSchema, that.oldSchema)\n        && Objects.equals(newSchema, that.newSchema)\n        && Objects.equals(type, that.type)\n        && Objects.equals(changedProperties, that.changedProperties)\n        && Objects.equals(increasedProperties, that.increasedProperties)\n        && Objects.equals(missingProperties, that.missingProperties)\n        && Objects.equals(description, that.description)\n        && Objects.equals(required, that.required)\n        && Objects.equals(enumeration, that.enumeration)\n        && Objects.equals(readOnly, that.readOnly)\n        && Objects.equals(writeOnly, that.writeOnly)\n        && Objects.equals(maxLength, that.maxLength)\n        && Objects.equals(numericRange, that.numericRange)\n        && Objects.equals(items, that.items)\n        && Objects.equals(oneOfSchema, that.oneOfSchema)\n        && Objects.equals(addProp, that.addProp)\n        && Objects.equals(extensions, that.extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedSchema that = (ChangedSchema) o;\n    return changeDeprecated == that.changeDeprecated\n        && changeTitle == that.changeTitle\n        && changeDefault == that.changeDefault\n        && changeFormat == that.changeFormat\n        && changedType == that.changedType\n        && discriminatorPropertyChanged == that.discriminatorPropertyChanged\n        && Objects.equals(context, that.context)\n        && Objects.equals(oldSchema, that.oldSchema)\n        && Objects.equals(newSchema, that.newSchema)\n        && Objects.equals(type, that.type)\n        && Objects.equals(changedProperties, that.changedProperties)\n        && Objects.equals(increasedProperties, that.increasedProperties)\n        && Objects.equals(missingProperties, that.missingProperties)\n        && Objects.equals(description, that.description)\n        && Objects.equals(required, that.required)\n        && Objects.equals(enumeration, that.enumeration)\n        && Objects.equals(readOnly, that.readOnly)\n        && Objects.equals(writeOnly, that.writeOnly)\n        && Objects.equals(maxLength, that.maxLength)\n        && Objects.equals(numericRange, that.numericRange)\n        && Objects.equals(items, that.items)\n        && Objects.equals(oneOfSchema, that.oneOfSchema)\n        && Objects.equals(addProp, that.addProp)\n        && Objects.equals(extensions, that.extensions);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        context,\n        oldSchema,\n        newSchema,\n        type,\n        changedProperties,\n        increasedProperties,\n        missingProperties,\n        changeDeprecated,\n        description,\n        changeTitle,\n        required,\n        changeDefault,\n        enumeration,\n        changeFormat,\n        readOnly,\n        writeOnly,\n        changedType,\n        maxLength,\n        numericRange,\n        discriminatorPropertyChanged,\n        items,\n        oneOfSchema,\n        addProp,\n        extensions);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        context,\n        oldSchema,\n        newSchema,\n        type,\n        changedProperties,\n        increasedProperties,\n        missingProperties,\n        changeDeprecated,\n        description,\n        changeTitle,\n        required,\n        changeDefault,\n        enumeration,\n        changeFormat,\n        readOnly,\n        writeOnly,\n        changedType,\n        maxLength,\n        numericRange,\n        discriminatorPropertyChanged,\n        items,\n        oneOfSchema,\n        addProp,\n        extensions);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedSchema(context=\"\n        + this.getContext()\n        + \", oldSchema=\"\n        + this.getOldSchema()\n        + \", newSchema=\"\n        + this.getNewSchema()\n        + \", type=\"\n        + this.getType()\n        + \", changedProperties=\"\n        + this.getChangedProperties()\n        + \", increasedProperties=\"\n        + this.getIncreasedProperties()\n        + \", missingProperties=\"\n        + this.getMissingProperties()\n        + \", changeDeprecated=\"\n        + this.isChangeDeprecated()\n        + \", description=\"\n        + this.getDescription()\n        + \", changeTitle=\"\n        + this.isChangeTitle()\n        + \", required=\"\n        + this.getRequired()\n        + \", changeDefault=\"\n        + this.isChangeDefault()\n        + \", enumeration=\"\n        + this.getEnumeration()\n        + \", changeFormat=\"\n        + this.isChangeFormat()\n        + \", readOnly=\"\n        + this.getReadOnly()\n        + \", writeOnly=\"\n        + this.getWriteOnly()\n        + \", changedType=\"\n        + this.isChangedType()\n        + \", maxLength=\"\n        + this.getMaxLength()\n        + \", discriminatorPropertyChanged=\"\n        + this.isDiscriminatorPropertyChanged()\n        + \", items=\"\n        + this.getItems()\n        + \", oneOfSchema=\"\n        + this.getOneOfSchema()\n        + \", addProp=\"\n        + this.getAddProp()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedSchema(context=\"\n        + this.getContext()\n        + \", oldSchema=\"\n        + this.getOldSchema()\n        + \", newSchema=\"\n        + this.getNewSchema()\n        + \", type=\"\n        + this.getType()\n        + \", changedProperties=\"\n        + this.getChangedProperties()\n        + \", increasedProperties=\"\n        + this.getIncreasedProperties()\n        + \", missingProperties=\"\n        + this.getMissingProperties()\n        + \", changeDeprecated=\"\n        + this.isChangeDeprecated()\n        + \", description=\"\n        + this.getDescription()\n        + \", changeTitle=\"\n        + this.isChangeTitle()\n        + \", required=\"\n        + this.getRequired()\n        + \", changeDefault=\"\n        + this.isChangeDefault()\n        + \", enumeration=\"\n        + this.getEnumeration()\n        + \", changeFormat=\"\n        + this.isChangeFormat()\n        + \", readOnly=\"\n        + this.getReadOnly()\n        + \", writeOnly=\"\n        + this.getWriteOnly()\n        + \", changedType=\"\n        + this.isChangedType()\n        + \", maxLength=\"\n        + this.getMaxLength()\n        + \", discriminatorPropertyChanged=\"\n        + this.isDiscriminatorPropertyChanged()\n        + \", items=\"\n        + this.getItems()\n        + \", oneOfSchema=\"\n        + this.getOneOfSchema()\n        + \", addProp=\"\n        + this.getAddProp()\n        + \", extensions=\"\n        + this.getExtensions()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedOneOfSchema.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_ONEOF_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_ONEOF_INCREASED;\n\nimport io.swagger.v3.oas.models.media.Schema;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ChangedOneOfSchema implements ComposedChanged {\n  private final Map<String, String> oldMapping;\n  private final Map<String, String> newMapping;\n  private final DiffContext context;\n  private Map<String, Schema> increased;\n  private Map<String, Schema> missing;\n  private Map<String, ChangedSchema> changed;\n\n  public ChangedOneOfSchema(\n      Map<String, String> oldMapping, Map<String, String> newMapping, DiffContext context) {\n    this.oldMapping = oldMapping;\n    this.newMapping = newMapping;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest() && !missing.isEmpty()) {\n      if (REQUEST_ONEOF_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !increased.isEmpty()) {\n      if (RESPONSE_ONEOF_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Map<String, String> getOldMapping() {\n    return this.oldMapping;\n  }\n\n  public Map<String, String> getNewMapping() {\n    return this.newMapping;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, Schema> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, Schema> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedSchema> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedOneOfSchema setIncreased(final Map<String, Schema> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedOneOfSchema setMissing(final Map<String, Schema> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedOneOfSchema setChanged(final Map<String, ChangedSchema> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOneOfSchema that = (ChangedOneOfSchema) o;\n    return Objects.equals(oldMapping, that.oldMapping)\n        && Objects.equals(newMapping, that.newMapping)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldMapping, newMapping, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOneOfSchema(oldMapping=\"\n        + this.getOldMapping()\n        + \", newMapping=\"\n        + this.getNewMapping()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}\n", "file_hash": "3bb008d5a86f4968b023c5edb39f99e496beadfa55dcef4eb33b94f31dae149d", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_ONEOF_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_ONEOF_INCREASED;", "import io.swagger.v3.oas.models.media.Schema;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Map;", "import java.util.Objects;"], "methods": [], "classes": [{"original_string": "public class ChangedOneOfSchema implements ComposedChanged {\n  private final Map<String, String> oldMapping;\n  private final Map<String, String> newMapping;\n  private final DiffContext context;\n  private Map<String, Schema> increased;\n  private Map<String, Schema> missing;\n  private Map<String, ChangedSchema> changed;\n\n  public ChangedOneOfSchema(\n      Map<String, String> oldMapping, Map<String, String> newMapping, DiffContext context) {\n    this.oldMapping = oldMapping;\n    this.newMapping = newMapping;\n    this.context = context;\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest() && !missing.isEmpty()) {\n      if (REQUEST_ONEOF_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !increased.isEmpty()) {\n      if (RESPONSE_ONEOF_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Map<String, String> getOldMapping() {\n    return this.oldMapping;\n  }\n\n  public Map<String, String> getNewMapping() {\n    return this.newMapping;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, Schema> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, Schema> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedSchema> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedOneOfSchema setIncreased(final Map<String, Schema> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedOneOfSchema setMissing(final Map<String, Schema> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedOneOfSchema setChanged(final Map<String, ChangedSchema> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOneOfSchema that = (ChangedOneOfSchema) o;\n    return Objects.equals(oldMapping, that.oldMapping)\n        && Objects.equals(newMapping, that.newMapping)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldMapping, newMapping, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOneOfSchema(oldMapping=\"\n        + this.getOldMapping()\n        + \", newMapping=\"\n        + this.getNewMapping()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}", "definition": "public class ChangedOneOfSchema implements ComposedChanged", "class_docstring": "", "name": "ChangedOneOfSchema", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Map<String, String> oldMapping;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, String>", "name": "oldMapping", "syntax_pass": true}, {"attribute_expression": "private final Map<String, String> newMapping;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, String>", "name": "newMapping", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private Map<String, Schema> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, Schema>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private Map<String, Schema> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, Schema>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private Map<String, ChangedSchema> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, ChangedSchema>", "name": "changed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedOneOfSchema(\n      Map<String, String> oldMapping, Map<String, String> newMapping, DiffContext context) {\n    this.oldMapping = oldMapping;\n    this.newMapping = newMapping;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedOneOfSchema", "params": [{"name": "oldMapping", "type": "Map<String, String>"}, {"name": "newMapping", "type": "Map<String, String>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                           {\n    this.oldMapping = oldMapping;\n    this.newMapping = newMapping;\n    this.context = context;\n  }", "signature": "public ChangedOneOfSchema(\n      Map<String, String> oldMapping, Map<String, String> newMapping, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return new ArrayList<>(changed.values());\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest() && !missing.isEmpty()) {\n      if (REQUEST_ONEOF_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !increased.isEmpty()) {\n      if (RESPONSE_ONEOF_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest() && !missing.isEmpty()) {\n      if (REQUEST_ONEOF_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !increased.isEmpty()) {\n      if (RESPONSE_ONEOF_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public Map<String, String> getOldMapping() {\n    return this.oldMapping;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, String>", "classes": []}, "name": "getOldMapping", "params": [], "body": "                                             {\n    return this.oldMapping;\n  }", "signature": "public Map<String, String> getOldMapping()"}, {"syntax_pass": true, "original_string": "  public Map<String, String> getNewMapping() {\n    return this.newMapping;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, String>", "classes": []}, "name": "getNewMapping", "params": [], "body": "                                             {\n    return this.newMapping;\n  }", "signature": "public Map<String, String> getNewMapping()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public Map<String, Schema> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Schema>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                            {\n    return this.increased;\n  }", "signature": "public Map<String, Schema> getIncreased()"}, {"syntax_pass": true, "original_string": "  public Map<String, Schema> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Schema>", "classes": []}, "name": "getMissing", "params": [], "body": "                                          {\n    return this.missing;\n  }", "signature": "public Map<String, Schema> getMissing()"}, {"syntax_pass": true, "original_string": "  public Map<String, ChangedSchema> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ChangedSchema>", "classes": []}, "name": "getChanged", "params": [], "body": "                                                 {\n    return this.changed;\n  }", "signature": "public Map<String, ChangedSchema> getChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedOneOfSchema setIncreased(final Map<String, Schema> increased) {\n    this.increased = increased;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOneOfSchema", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "Map<String, Schema>"}], "body": "                                                                              {\n    this.increased = increased;\n    return this;\n  }", "signature": "public ChangedOneOfSchema setIncreased(final Map<String, Schema> increased)"}, {"syntax_pass": true, "original_string": "  public ChangedOneOfSchema setMissing(final Map<String, Schema> missing) {\n    this.missing = missing;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOneOfSchema", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "Map<String, Schema>"}], "body": "                                                                          {\n    this.missing = missing;\n    return this;\n  }", "signature": "public ChangedOneOfSchema setMissing(final Map<String, Schema> missing)"}, {"syntax_pass": true, "original_string": "  public ChangedOneOfSchema setChanged(final Map<String, ChangedSchema> changed) {\n    this.changed = changed;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedOneOfSchema", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "Map<String, ChangedSchema>"}], "body": "                                                                                 {\n    this.changed = changed;\n    return this;\n  }", "signature": "public ChangedOneOfSchema setChanged(final Map<String, ChangedSchema> changed)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOneOfSchema that = (ChangedOneOfSchema) o;\n    return Objects.equals(oldMapping, that.oldMapping)\n        && Objects.equals(newMapping, that.newMapping)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedOneOfSchema that = (ChangedOneOfSchema) o;\n    return Objects.equals(oldMapping, that.oldMapping)\n        && Objects.equals(newMapping, that.newMapping)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(oldMapping, newMapping, context, increased, missing, changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(oldMapping, newMapping, context, increased, missing, changed);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedOneOfSchema(oldMapping=\"\n        + this.getOldMapping()\n        + \", newMapping=\"\n        + this.getNewMapping()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedOneOfSchema(oldMapping=\"\n        + this.getOldMapping()\n        + \", newMapping=\"\n        + this.getNewMapping()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/ChangedContent.java", "original_string": "package org.openapitools.openapidiff.core.model;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_CONTENT_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_CONTENT_DECREASED;\n\nimport io.swagger.v3.oas.models.media.Content;\nimport io.swagger.v3.oas.models.media.MediaType;\nimport java.util.*;\n\npublic class ChangedContent implements ComposedChanged {\n  private final Content oldContent;\n  private final Content newContent;\n  private final DiffContext context;\n  private Map<String, MediaType> increased;\n  private Map<String, MediaType> missing;\n  private Map<String, ChangedMediaType> changed;\n\n  public ChangedContent(Content oldContent, Content newContent, DiffContext context) {\n    this.oldContent = oldContent;\n    this.newContent = newContent;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (context.isRequest() && REQUEST_CONTENT_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (context.isResponse() && RESPONSE_CONTENT_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Content getOldContent() {\n    return this.oldContent;\n  }\n\n  public Content getNewContent() {\n    return this.newContent;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, MediaType> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, MediaType> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedMediaType> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedContent setIncreased(final Map<String, MediaType> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedContent setMissing(final Map<String, MediaType> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedContent setChanged(final Map<String, ChangedMediaType> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedContent that = (ChangedContent) o;\n    return Objects.equals(oldContent, that.oldContent)\n        && Objects.equals(newContent, that.newContent)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldContent, newContent, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedContent(oldContent=\"\n        + this.getOldContent()\n        + \", newContent=\"\n        + this.getNewContent()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}\n", "file_hash": "9e1a25e6053086e5559034400f239fba5186e8742f5fdb6390e93c48b3fe22ef", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_CONTENT_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_CONTENT_DECREASED;", "import io.swagger.v3.oas.models.media.Content;", "import io.swagger.v3.oas.models.media.MediaType;", "import java.util.*;"], "methods": [], "classes": [{"original_string": "public class ChangedContent implements ComposedChanged {\n  private final Content oldContent;\n  private final Content newContent;\n  private final DiffContext context;\n  private Map<String, MediaType> increased;\n  private Map<String, MediaType> missing;\n  private Map<String, ChangedMediaType> changed;\n\n  public ChangedContent(Content oldContent, Content newContent, DiffContext context) {\n    this.oldContent = oldContent;\n    this.newContent = newContent;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }\n\n  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }\n\n  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (context.isRequest() && REQUEST_CONTENT_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (context.isResponse() && RESPONSE_CONTENT_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public Content getOldContent() {\n    return this.oldContent;\n  }\n\n  public Content getNewContent() {\n    return this.newContent;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  public Map<String, MediaType> getIncreased() {\n    return this.increased;\n  }\n\n  public Map<String, MediaType> getMissing() {\n    return this.missing;\n  }\n\n  public Map<String, ChangedMediaType> getChanged() {\n    return this.changed;\n  }\n\n  public ChangedContent setIncreased(final Map<String, MediaType> increased) {\n    this.increased = increased;\n    return this;\n  }\n\n  public ChangedContent setMissing(final Map<String, MediaType> missing) {\n    this.missing = missing;\n    return this;\n  }\n\n  public ChangedContent setChanged(final Map<String, ChangedMediaType> changed) {\n    this.changed = changed;\n    return this;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedContent that = (ChangedContent) o;\n    return Objects.equals(oldContent, that.oldContent)\n        && Objects.equals(newContent, that.newContent)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldContent, newContent, context, increased, missing, changed);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedContent(oldContent=\"\n        + this.getOldContent()\n        + \", newContent=\"\n        + this.getNewContent()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }\n}", "definition": "public class ChangedContent implements ComposedChanged", "class_docstring": "", "name": "ChangedContent", "super_interfaces": ["ComposedChanged"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Content oldContent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Content", "name": "oldContent", "syntax_pass": true}, {"attribute_expression": "private final Content newContent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Content", "name": "newContent", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private Map<String, MediaType> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, MediaType>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private Map<String, MediaType> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, MediaType>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private Map<String, ChangedMediaType> changed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, ChangedMediaType>", "name": "changed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedContent(Content oldContent, Content newContent, DiffContext context) {\n    this.oldContent = oldContent;\n    this.newContent = newContent;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedContent", "params": [{"name": "oldContent", "type": "Content"}, {"name": "newContent", "type": "Content"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                     {\n    this.oldContent = oldContent;\n    this.newContent = newContent;\n    this.context = context;\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n    this.changed = new LinkedHashMap<>();\n  }", "signature": "public ChangedContent(Content oldContent, Content newContent, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public List<Changed> getChangedElements() {\n    return new ArrayList<>(changed.values());\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Changed>", "classes": []}, "name": "getChangedElements", "params": [], "body": "                                            {\n    return new ArrayList<>(changed.values());\n  }", "signature": "@Override\n  public List<Changed> getChangedElements()"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isCoreChanged() {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (context.isRequest() && REQUEST_CONTENT_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (context.isResponse() && RESPONSE_CONTENT_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isCoreChanged", "params": [], "body": "                                    {\n    if (increased.isEmpty() && missing.isEmpty()) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (!missing.isEmpty()) {\n      if (context.isRequest() && REQUEST_CONTENT_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (context.isResponse() && RESPONSE_CONTENT_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isCoreChanged()"}, {"syntax_pass": true, "original_string": "  public Content getOldContent() {\n    return this.oldContent;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Content", "classes": []}, "name": "getOldContent", "params": [], "body": "                                 {\n    return this.oldContent;\n  }", "signature": "public Content getOldContent()"}, {"syntax_pass": true, "original_string": "  public Content getNewContent() {\n    return this.newContent;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Content", "classes": []}, "name": "getNewContent", "params": [], "body": "                                 {\n    return this.newContent;\n  }", "signature": "public Content getNewContent()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  public Map<String, MediaType> getIncreased() {\n    return this.increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, MediaType>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                               {\n    return this.increased;\n  }", "signature": "public Map<String, MediaType> getIncreased()"}, {"syntax_pass": true, "original_string": "  public Map<String, MediaType> getMissing() {\n    return this.missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, MediaType>", "classes": []}, "name": "getMissing", "params": [], "body": "                                             {\n    return this.missing;\n  }", "signature": "public Map<String, MediaType> getMissing()"}, {"syntax_pass": true, "original_string": "  public Map<String, ChangedMediaType> getChanged() {\n    return this.changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ChangedMediaType>", "classes": []}, "name": "getChanged", "params": [], "body": "                                                    {\n    return this.changed;\n  }", "signature": "public Map<String, ChangedMediaType> getChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedContent setIncreased(final Map<String, MediaType> increased) {\n    this.increased = increased;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedContent", "classes": []}, "name": "setIncreased", "params": [{"name": "increased", "type": "Map<String, MediaType>"}], "body": "                                                                             {\n    this.increased = increased;\n    return this;\n  }", "signature": "public ChangedContent setIncreased(final Map<String, MediaType> increased)"}, {"syntax_pass": true, "original_string": "  public ChangedContent setMissing(final Map<String, MediaType> missing) {\n    this.missing = missing;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedContent", "classes": []}, "name": "setMissing", "params": [{"name": "missing", "type": "Map<String, MediaType>"}], "body": "                                                                         {\n    this.missing = missing;\n    return this;\n  }", "signature": "public ChangedContent setMissing(final Map<String, MediaType> missing)"}, {"syntax_pass": true, "original_string": "  public ChangedContent setChanged(final Map<String, ChangedMediaType> changed) {\n    this.changed = changed;\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedContent", "classes": []}, "name": "setChanged", "params": [{"name": "changed", "type": "Map<String, ChangedMediaType>"}], "body": "                                                                                {\n    this.changed = changed;\n    return this;\n  }", "signature": "public ChangedContent setChanged(final Map<String, ChangedMediaType> changed)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedContent that = (ChangedContent) o;\n    return Objects.equals(oldContent, that.oldContent)\n        && Objects.equals(newContent, that.newContent)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedContent that = (ChangedContent) o;\n    return Objects.equals(oldContent, that.oldContent)\n        && Objects.equals(newContent, that.newContent)\n        && Objects.equals(context, that.context)\n        && Objects.equals(increased, that.increased)\n        && Objects.equals(missing, that.missing)\n        && Objects.equals(changed, that.changed);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(oldContent, newContent, context, increased, missing, changed);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(oldContent, newContent, context, increased, missing, changed);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedContent(oldContent=\"\n        + this.getOldContent()\n        + \", newContent=\"\n        + this.getNewContent()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedContent(oldContent=\"\n        + this.getOldContent()\n        + \", newContent=\"\n        + this.getNewContent()\n        + \", context=\"\n        + this.getContext()\n        + \", increased=\"\n        + this.getIncreased()\n        + \", missing=\"\n        + this.getMissing()\n        + \", changed=\"\n        + this.getChanged()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/deferred/PendingChanged.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport javax.annotation.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class PendingChanged<T> implements DeferredChanged<T> {\n  private static final Logger log = LoggerFactory.getLogger(PendingChanged.class);\n\n  private final List<Consumer<T>> ifPresentConsumers = new ArrayList<>();\n  private final List<Consumer<Optional<T>>> whenSetConsumers = new ArrayList<>();\n\n  @Nullable private T value;\n  private Optional<T> valueOptional = Optional.empty();\n  private boolean valueIsPresent;\n  private boolean valueSet;\n\n  private static final AtomicInteger deferredCounter = new AtomicInteger();\n  private static final AtomicInteger resolvedCounter = new AtomicInteger();\n\n  @Override\n  public void ifPresent(Consumer<T> consumer) {\n    if (valueSet) {\n      if (valueIsPresent) {\n        consumer.accept(value);\n      }\n    } else {\n      ifPresentConsumers.add(consumer);\n    }\n  }\n\n  public void setValue(Optional<T> value) {\n    if (!valueSet) {\n      this.valueSet = true;\n      this.valueIsPresent = value.isPresent();\n      this.value = value.orElse(null);\n      this.valueOptional = value;\n\n      log.debug(\"set {}\", DeferredLogger.logValue(this.value));\n\n      if (this.valueIsPresent) {\n        ifPresentConsumers.forEach(c -> c.accept(this.value));\n      }\n\n      whenSetConsumers.forEach(c -> c.accept(this.valueOptional));\n\n    } else {\n      throw new IllegalStateException(\n          \"PendingChanged may not be set more than once. Value was already set.\");\n    }\n  }\n\n  public boolean isPresent() {\n    return valueSet && valueIsPresent;\n  }\n\n  public T get() {\n    return valueOptional.get();\n  }\n\n  public boolean isValueSet() {\n    return valueSet;\n  }\n\n  public void whenSet(Consumer<Optional<T>> consumer) {\n    if (valueSet) {\n      consumer.accept(valueOptional);\n    } else {\n      whenSetConsumers.add(consumer);\n    }\n  }\n\n  public <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> function) {\n    return mapOptional(v -> Optional.ofNullable(function.apply(v)));\n  }\n\n  public <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> function) {\n    if (valueSet) {\n      Optional<Q> result = function.apply(this.valueOptional);\n      log.debug(\n          \"map resolved {} {} -> {}\",\n          function,\n          DeferredLogger.logValue(this.value),\n          DeferredLogger.logValue(result));\n      return new RealizedChanged<>(result);\n    } else {\n      final PendingChanged<Q> mappedChanged = new PendingChanged<>();\n      log.debug(\"map deferred {} ? -> ?\", function);\n      deferredCounter.incrementAndGet();\n      whenSet(\n          value -> {\n            Optional<Q> result = function.apply(this.valueOptional);\n            log.debug(\n                \"map resolved {} {} -> {}\",\n                function,\n                DeferredLogger.logValue(this.value),\n                DeferredLogger.logValue(result));\n            resolvedCounter.incrementAndGet();\n            mappedChanged.setValue(result);\n          });\n      return mappedChanged;\n    }\n  }\n\n  public <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> function) {\n    if (valueSet) {\n      DeferredChanged<Q> nextDeferred = function.apply(this.valueOptional);\n      log.debug(\"flat map deferred {} {} -> ?\", function, DeferredLogger.logValue(this.value));\n      deferredCounter.incrementAndGet();\n      nextDeferred.whenSet(\n          nextValue -> {\n            log.debug(\n                \"flat map resolved {} {} -> {}\",\n                function,\n                DeferredLogger.logValue(this.value),\n                DeferredLogger.logValue(nextValue));\n            resolvedCounter.incrementAndGet();\n          });\n      return nextDeferred;\n    } else {\n      final PendingChanged<Q> mappedChanged = new PendingChanged<>();\n      log.debug(\"flat map deferred {} ? -> ?\", function);\n      deferredCounter.incrementAndGet();\n      whenSet(\n          value -> {\n            DeferredChanged<Q> nextDeferred = function.apply(value);\n            nextDeferred.whenSet(\n                nextValue -> {\n                  log.debug(\n                      \"flat map deferred {} {} -> {}\",\n                      function,\n                      DeferredLogger.logValue(this.value),\n                      DeferredLogger.logValue(nextValue));\n                  resolvedCounter.incrementAndGet();\n                  mappedChanged.setValue(nextValue);\n                });\n            log.debug(\"flat map resolved {} {} -> ?\", function, DeferredLogger.logValue(value));\n          });\n      return mappedChanged;\n    }\n  }\n\n  @Override\n  public String toString() {\n    return \"PendingChanged{\"\n        + \"value=\"\n        + DeferredLogger.logValue(value)\n        + \", valueSet=\"\n        + valueSet\n        + \", ifPresentConsumers.size=\"\n        + ifPresentConsumers.size()\n        + \", whenSetConsumers.size=\"\n        + whenSetConsumers.size()\n        + '}';\n  }\n\n  public static void logResolved() {\n    int deferred = deferredCounter.get();\n    int resolved = resolvedCounter.get();\n    log.debug(\n        \"Outstanding: {}  Deferred: {}  Resolved {}\", deferred - resolved, deferred, resolved);\n  }\n}\n", "file_hash": "5393f6fd4b423339f556553bee12f204676325aa0b0a4395e4be2ef345da3377", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Optional;", "import java.util.concurrent.atomic.AtomicInteger;", "import java.util.function.Consumer;", "import java.util.function.Function;", "import javax.annotation.Nullable;", "import org.slf4j.Logger;", "import org.slf4j.LoggerFactory;"], "methods": [], "classes": [{"original_string": "public class PendingChanged<T> implements DeferredChanged<T> {\n  private static final Logger log = LoggerFactory.getLogger(PendingChanged.class);\n\n  private final List<Consumer<T>> ifPresentConsumers = new ArrayList<>();\n  private final List<Consumer<Optional<T>>> whenSetConsumers = new ArrayList<>();\n\n  @Nullable private T value;\n  private Optional<T> valueOptional = Optional.empty();\n  private boolean valueIsPresent;\n  private boolean valueSet;\n\n  private static final AtomicInteger deferredCounter = new AtomicInteger();\n  private static final AtomicInteger resolvedCounter = new AtomicInteger();\n\n  @Override\n  public void ifPresent(Consumer<T> consumer) {\n    if (valueSet) {\n      if (valueIsPresent) {\n        consumer.accept(value);\n      }\n    } else {\n      ifPresentConsumers.add(consumer);\n    }\n  }\n\n  public void setValue(Optional<T> value) {\n    if (!valueSet) {\n      this.valueSet = true;\n      this.valueIsPresent = value.isPresent();\n      this.value = value.orElse(null);\n      this.valueOptional = value;\n\n      log.debug(\"set {}\", DeferredLogger.logValue(this.value));\n\n      if (this.valueIsPresent) {\n        ifPresentConsumers.forEach(c -> c.accept(this.value));\n      }\n\n      whenSetConsumers.forEach(c -> c.accept(this.valueOptional));\n\n    } else {\n      throw new IllegalStateException(\n          \"PendingChanged may not be set more than once. Value was already set.\");\n    }\n  }\n\n  public boolean isPresent() {\n    return valueSet && valueIsPresent;\n  }\n\n  public T get() {\n    return valueOptional.get();\n  }\n\n  public boolean isValueSet() {\n    return valueSet;\n  }\n\n  public void whenSet(Consumer<Optional<T>> consumer) {\n    if (valueSet) {\n      consumer.accept(valueOptional);\n    } else {\n      whenSetConsumers.add(consumer);\n    }\n  }\n\n  public <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> function) {\n    return mapOptional(v -> Optional.ofNullable(function.apply(v)));\n  }\n\n  public <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> function) {\n    if (valueSet) {\n      Optional<Q> result = function.apply(this.valueOptional);\n      log.debug(\n          \"map resolved {} {} -> {}\",\n          function,\n          DeferredLogger.logValue(this.value),\n          DeferredLogger.logValue(result));\n      return new RealizedChanged<>(result);\n    } else {\n      final PendingChanged<Q> mappedChanged = new PendingChanged<>();\n      log.debug(\"map deferred {} ? -> ?\", function);\n      deferredCounter.incrementAndGet();\n      whenSet(\n          value -> {\n            Optional<Q> result = function.apply(this.valueOptional);\n            log.debug(\n                \"map resolved {} {} -> {}\",\n                function,\n                DeferredLogger.logValue(this.value),\n                DeferredLogger.logValue(result));\n            resolvedCounter.incrementAndGet();\n            mappedChanged.setValue(result);\n          });\n      return mappedChanged;\n    }\n  }\n\n  public <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> function) {\n    if (valueSet) {\n      DeferredChanged<Q> nextDeferred = function.apply(this.valueOptional);\n      log.debug(\"flat map deferred {} {} -> ?\", function, DeferredLogger.logValue(this.value));\n      deferredCounter.incrementAndGet();\n      nextDeferred.whenSet(\n          nextValue -> {\n            log.debug(\n                \"flat map resolved {} {} -> {}\",\n                function,\n                DeferredLogger.logValue(this.value),\n                DeferredLogger.logValue(nextValue));\n            resolvedCounter.incrementAndGet();\n          });\n      return nextDeferred;\n    } else {\n      final PendingChanged<Q> mappedChanged = new PendingChanged<>();\n      log.debug(\"flat map deferred {} ? -> ?\", function);\n      deferredCounter.incrementAndGet();\n      whenSet(\n          value -> {\n            DeferredChanged<Q> nextDeferred = function.apply(value);\n            nextDeferred.whenSet(\n                nextValue -> {\n                  log.debug(\n                      \"flat map deferred {} {} -> {}\",\n                      function,\n                      DeferredLogger.logValue(this.value),\n                      DeferredLogger.logValue(nextValue));\n                  resolvedCounter.incrementAndGet();\n                  mappedChanged.setValue(nextValue);\n                });\n            log.debug(\"flat map resolved {} {} -> ?\", function, DeferredLogger.logValue(value));\n          });\n      return mappedChanged;\n    }\n  }\n\n  @Override\n  public String toString() {\n    return \"PendingChanged{\"\n        + \"value=\"\n        + DeferredLogger.logValue(value)\n        + \", valueSet=\"\n        + valueSet\n        + \", ifPresentConsumers.size=\"\n        + ifPresentConsumers.size()\n        + \", whenSetConsumers.size=\"\n        + whenSetConsumers.size()\n        + '}';\n  }\n\n  public static void logResolved() {\n    int deferred = deferredCounter.get();\n    int resolved = resolvedCounter.get();\n    log.debug(\n        \"Outstanding: {}  Deferred: {}  Resolved {}\", deferred - resolved, deferred, resolved);\n  }\n}", "definition": "public class PendingChanged<T> implements DeferredChanged<T>", "class_docstring": "", "name": "PendingChanged", "super_interfaces": ["DeferredChanged<T>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Logger log = LoggerFactory.getLogger(PendingChanged.class);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "log = LoggerFactory.getLogger(PendingChanged.class)", "syntax_pass": true}, {"attribute_expression": "private final List<Consumer<T>> ifPresentConsumers = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Consumer<T>>", "name": "ifPresentConsumers = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<Consumer<Optional<T>>> whenSetConsumers = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Consumer<Optional<T>>>", "name": "whenSetConsumers = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "@Nullable private T value;", "docstring": "", "modifiers": "@Nullable private", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "type": "T", "name": "value", "syntax_pass": true}, {"attribute_expression": "private Optional<T> valueOptional = Optional.empty();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Optional<T>", "name": "valueOptional = Optional.empty()", "syntax_pass": true}, {"attribute_expression": "private boolean valueIsPresent;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "valueIsPresent", "syntax_pass": true}, {"attribute_expression": "private boolean valueSet;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "valueSet", "syntax_pass": true}, {"attribute_expression": "private static final AtomicInteger deferredCounter = new AtomicInteger();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "AtomicInteger", "name": "deferredCounter = new AtomicInteger()", "syntax_pass": true}, {"attribute_expression": "private static final AtomicInteger resolvedCounter = new AtomicInteger();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "AtomicInteger", "name": "resolvedCounter = new AtomicInteger()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n  public void ifPresent(Consumer<T> consumer) {\n    if (valueSet) {\n      if (valueIsPresent) {\n        consumer.accept(value);\n      }\n    } else {\n      ifPresentConsumers.add(consumer);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ifPresent", "params": [{"name": "consumer", "type": "Consumer<T>"}], "body": "                                              {\n    if (valueSet) {\n      if (valueIsPresent) {\n        consumer.accept(value);\n      }\n    } else {\n      ifPresentConsumers.add(consumer);\n    }\n  }", "signature": "@Override\n  public void ifPresent(Consumer<T> consumer)"}, {"syntax_pass": true, "original_string": "  public void setValue(Optional<T> value) {\n    if (!valueSet) {\n      this.valueSet = true;\n      this.valueIsPresent = value.isPresent();\n      this.value = value.orElse(null);\n      this.valueOptional = value;\n\n      log.debug(\"set {}\", DeferredLogger.logValue(this.value));\n\n      if (this.valueIsPresent) {\n        ifPresentConsumers.forEach(c -> c.accept(this.value));\n      }\n\n      whenSetConsumers.forEach(c -> c.accept(this.valueOptional));\n\n    } else {\n      throw new IllegalStateException(\n          \"PendingChanged may not be set more than once. Value was already set.\");\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "Optional<T>"}], "body": "                                          {\n    if (!valueSet) {\n      this.valueSet = true;\n      this.valueIsPresent = value.isPresent();\n      this.value = value.orElse(null);\n      this.valueOptional = value;\n\n      log.debug(\"set {}\", DeferredLogger.logValue(this.value));\n\n      if (this.valueIsPresent) {\n        ifPresentConsumers.forEach(c -> c.accept(this.value));\n      }\n\n      whenSetConsumers.forEach(c -> c.accept(this.valueOptional));\n\n    } else {\n      throw new IllegalStateException(\n          \"PendingChanged may not be set more than once. Value was already set.\");\n    }\n  }", "signature": "public void setValue(Optional<T> value)"}, {"syntax_pass": true, "original_string": "  public boolean isPresent() {\n    return valueSet && valueIsPresent;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPresent", "params": [], "body": "                             {\n    return valueSet && valueIsPresent;\n  }", "signature": "public boolean isPresent()"}, {"syntax_pass": true, "original_string": "  public T get() {\n    return valueOptional.get();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "get", "params": [], "body": "                 {\n    return valueOptional.get();\n  }", "signature": "public T get()"}, {"syntax_pass": true, "original_string": "  public boolean isValueSet() {\n    return valueSet;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isValueSet", "params": [], "body": "                              {\n    return valueSet;\n  }", "signature": "public boolean isValueSet()"}, {"syntax_pass": true, "original_string": "  public void whenSet(Consumer<Optional<T>> consumer) {\n    if (valueSet) {\n      consumer.accept(valueOptional);\n    } else {\n      whenSetConsumers.add(consumer);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "whenSet", "params": [{"name": "consumer", "type": "Consumer<Optional<T>>"}], "body": "                                                      {\n    if (valueSet) {\n      consumer.accept(valueOptional);\n    } else {\n      whenSetConsumers.add(consumer);\n    }\n  }", "signature": "public void whenSet(Consumer<Optional<T>> consumer)"}, {"syntax_pass": true, "original_string": "  public <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> function) {\n    return mapOptional(v -> Optional.ofNullable(function.apply(v)));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<Q>", "classes": []}, "name": "map", "params": [{"name": "function", "type": "Function<Optional<T>, Q>"}], "body": "                                                                       {\n    return mapOptional(v -> Optional.ofNullable(function.apply(v)));\n  }", "signature": "public <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> function)"}, {"syntax_pass": true, "original_string": "  public <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> function) {\n    if (valueSet) {\n      Optional<Q> result = function.apply(this.valueOptional);\n      log.debug(\n          \"map resolved {} {} -> {}\",\n          function,\n          DeferredLogger.logValue(this.value),\n          DeferredLogger.logValue(result));\n      return new RealizedChanged<>(result);\n    } else {\n      final PendingChanged<Q> mappedChanged = new PendingChanged<>();\n      log.debug(\"map deferred {} ? -> ?\", function);\n      deferredCounter.incrementAndGet();\n      whenSet(\n          value -> {\n            Optional<Q> result = function.apply(this.valueOptional);\n            log.debug(\n                \"map resolved {} {} -> {}\",\n                function,\n                DeferredLogger.logValue(this.value),\n                DeferredLogger.logValue(result));\n            resolvedCounter.incrementAndGet();\n            mappedChanged.setValue(result);\n          });\n      return mappedChanged;\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<Q>", "classes": []}, "name": "mapOptional", "params": [{"name": "function", "type": "Function<Optional<T>, Optional<Q>>"}], "body": "                                                                                         {\n    if (valueSet) {\n      Optional<Q> result = function.apply(this.valueOptional);\n      log.debug(\n          \"map resolved {} {} -> {}\",\n          function,\n          DeferredLogger.logValue(this.value),\n          DeferredLogger.logValue(result));\n      return new RealizedChanged<>(result);\n    } else {\n      final PendingChanged<Q> mappedChanged = new PendingChanged<>();\n      log.debug(\"map deferred {} ? -> ?\", function);\n      deferredCounter.incrementAndGet();\n      whenSet(\n          value -> {\n            Optional<Q> result = function.apply(this.valueOptional);\n            log.debug(\n                \"map resolved {} {} -> {}\",\n                function,\n                DeferredLogger.logValue(this.value),\n                DeferredLogger.logValue(result));\n            resolvedCounter.incrementAndGet();\n            mappedChanged.setValue(result);\n          });\n      return mappedChanged;\n    }\n  }", "signature": "public <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> function)"}, {"syntax_pass": true, "original_string": "  public <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> function) {\n    if (valueSet) {\n      DeferredChanged<Q> nextDeferred = function.apply(this.valueOptional);\n      log.debug(\"flat map deferred {} {} -> ?\", function, DeferredLogger.logValue(this.value));\n      deferredCounter.incrementAndGet();\n      nextDeferred.whenSet(\n          nextValue -> {\n            log.debug(\n                \"flat map resolved {} {} -> {}\",\n                function,\n                DeferredLogger.logValue(this.value),\n                DeferredLogger.logValue(nextValue));\n            resolvedCounter.incrementAndGet();\n          });\n      return nextDeferred;\n    } else {\n      final PendingChanged<Q> mappedChanged = new PendingChanged<>();\n      log.debug(\"flat map deferred {} ? -> ?\", function);\n      deferredCounter.incrementAndGet();\n      whenSet(\n          value -> {\n            DeferredChanged<Q> nextDeferred = function.apply(value);\n            nextDeferred.whenSet(\n                nextValue -> {\n                  log.debug(\n                      \"flat map deferred {} {} -> {}\",\n                      function,\n                      DeferredLogger.logValue(this.value),\n                      DeferredLogger.logValue(nextValue));\n                  resolvedCounter.incrementAndGet();\n                  mappedChanged.setValue(nextValue);\n                });\n            log.debug(\"flat map resolved {} {} -> ?\", function, DeferredLogger.logValue(value));\n          });\n      return mappedChanged;\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<Q>", "classes": []}, "name": "flatMap", "params": [{"name": "function", "type": "Function<Optional<T>, DeferredChanged<Q>>"}], "body": "                                                                                            {\n    if (valueSet) {\n      DeferredChanged<Q> nextDeferred = function.apply(this.valueOptional);\n      log.debug(\"flat map deferred {} {} -> ?\", function, DeferredLogger.logValue(this.value));\n      deferredCounter.incrementAndGet();\n      nextDeferred.whenSet(\n          nextValue -> {\n            log.debug(\n                \"flat map resolved {} {} -> {}\",\n                function,\n                DeferredLogger.logValue(this.value),\n                DeferredLogger.logValue(nextValue));\n            resolvedCounter.incrementAndGet();\n          });\n      return nextDeferred;\n    } else {\n      final PendingChanged<Q> mappedChanged = new PendingChanged<>();\n      log.debug(\"flat map deferred {} ? -> ?\", function);\n      deferredCounter.incrementAndGet();\n      whenSet(\n          value -> {\n            DeferredChanged<Q> nextDeferred = function.apply(value);\n            nextDeferred.whenSet(\n                nextValue -> {\n                  log.debug(\n                      \"flat map deferred {} {} -> {}\",\n                      function,\n                      DeferredLogger.logValue(this.value),\n                      DeferredLogger.logValue(nextValue));\n                  resolvedCounter.incrementAndGet();\n                  mappedChanged.setValue(nextValue);\n                });\n            log.debug(\"flat map resolved {} {} -> ?\", function, DeferredLogger.logValue(value));\n          });\n      return mappedChanged;\n    }\n  }", "signature": "public <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> function)"}, {"syntax_pass": true, "original_string": "  @Override\n  public String toString() {\n    return \"PendingChanged{\"\n        + \"value=\"\n        + DeferredLogger.logValue(value)\n        + \", valueSet=\"\n        + valueSet\n        + \", ifPresentConsumers.size=\"\n        + ifPresentConsumers.size()\n        + \", whenSetConsumers.size=\"\n        + whenSetConsumers.size()\n        + '}';\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                           {\n    return \"PendingChanged{\"\n        + \"value=\"\n        + DeferredLogger.logValue(value)\n        + \", valueSet=\"\n        + valueSet\n        + \", ifPresentConsumers.size=\"\n        + ifPresentConsumers.size()\n        + \", whenSetConsumers.size=\"\n        + whenSetConsumers.size()\n        + '}';\n  }", "signature": "@Override\n  public String toString()"}, {"syntax_pass": true, "original_string": "  public static void logResolved() {\n    int deferred = deferredCounter.get();\n    int resolved = resolvedCounter.get();\n    log.debug(\n        \"Outstanding: {}  Deferred: {}  Resolved {}\", deferred - resolved, deferred, resolved);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "logResolved", "params": [], "body": "                                   {\n    int deferred = deferredCounter.get();\n    int resolved = resolvedCounter.get();\n    log.debug(\n        \"Outstanding: {}  Deferred: {}  Resolved {}\", deferred - resolved, deferred, resolved);\n  }", "signature": "public static void logResolved()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/deferred/SchemaDiffOperation.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport io.swagger.v3.oas.models.media.Schema;\nimport org.openapitools.openapidiff.core.compare.CacheKey;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiff;\nimport org.openapitools.openapidiff.core.model.ChangedSchema;\n\npublic class SchemaDiffOperation {\n  final OpenApiDiff openApiDiff;\n  final RecursiveSchemaSet refSet;\n  final CacheKey key;\n  final Schema left;\n  final Schema right;\n  boolean processed;\n\n  PendingChanged<ChangedSchema> diffResult = new PendingChanged<>();\n\n  SchemaDiffOperation(\n      OpenApiDiff openApiDiff, RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    this.openApiDiff = openApiDiff;\n    this.refSet = refSet;\n    this.key = key;\n    this.left = left;\n    this.right = right;\n  }\n}\n", "file_hash": "634464493fcbfb11d74d46c18f9b9dea61a3188f93efe42b2875884f01f82b82", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import io.swagger.v3.oas.models.media.Schema;", "import org.openapitools.openapidiff.core.compare.CacheKey;", "import org.openapitools.openapidiff.core.compare.OpenApiDiff;", "import org.openapitools.openapidiff.core.model.ChangedSchema;"], "methods": [], "classes": [{"original_string": "public class SchemaDiffOperation {\n  final OpenApiDiff openApiDiff;\n  final RecursiveSchemaSet refSet;\n  final CacheKey key;\n  final Schema left;\n  final Schema right;\n  boolean processed;\n\n  PendingChanged<ChangedSchema> diffResult = new PendingChanged<>();\n\n  SchemaDiffOperation(\n      OpenApiDiff openApiDiff, RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    this.openApiDiff = openApiDiff;\n    this.refSet = refSet;\n    this.key = key;\n    this.left = left;\n    this.right = right;\n  }\n}", "definition": "public class SchemaDiffOperation", "class_docstring": "", "name": "SchemaDiffOperation", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}, {"attribute_expression": "final RecursiveSchemaSet refSet;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "RecursiveSchemaSet", "name": "refSet", "syntax_pass": true}, {"attribute_expression": "final CacheKey key;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "CacheKey", "name": "key", "syntax_pass": true}, {"attribute_expression": "final Schema left;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Schema", "name": "left", "syntax_pass": true}, {"attribute_expression": "final Schema right;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Schema", "name": "right", "syntax_pass": true}, {"attribute_expression": "boolean processed;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "processed", "syntax_pass": true}, {"attribute_expression": "PendingChanged<ChangedSchema> diffResult = new PendingChanged<>();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "PendingChanged<ChangedSchema>", "name": "diffResult = new PendingChanged<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  SchemaDiffOperation(\n      OpenApiDiff openApiDiff, RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    this.openApiDiff = openApiDiff;\n    this.refSet = refSet;\n    this.key = key;\n    this.left = left;\n    this.right = right;\n  }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SchemaDiffOperation", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}, {"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "key", "type": "CacheKey"}, {"name": "left", "type": "Schema"}, {"name": "right", "type": "Schema"}], "body": "                                                                                                   {\n    this.openApiDiff = openApiDiff;\n    this.refSet = refSet;\n    this.key = key;\n    this.left = left;\n    this.right = right;\n  }", "signature": "SchemaDiffOperation(\n      OpenApiDiff openApiDiff, RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/deferred/RealizedChanged.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\npublic class RealizedChanged<T> implements DeferredChanged<T> {\n  private final Optional<T> value;\n\n  public RealizedChanged(T value) {\n    this.value = Optional.ofNullable(value);\n  }\n\n  public RealizedChanged(Optional<T> value) {\n    this.value = value;\n  }\n\n  @Override\n  public void ifPresent(Consumer<T> consumer) {\n    value.ifPresent(consumer);\n  }\n\n  @Override\n  public void whenSet(Consumer<Optional<T>> consumer) {\n    consumer.accept(value);\n  }\n\n  public static <T> RealizedChanged<T> empty() {\n    return new RealizedChanged<>(Optional.empty());\n  }\n\n  @Override\n  public boolean isPresent() {\n    return value.isPresent();\n  }\n\n  @Override\n  public boolean isValueSet() {\n    return true;\n  }\n\n  @Override\n  public T get() {\n    return value.get();\n  }\n\n  public <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> function) {\n    return new RealizedChanged<>(function.apply(this.value));\n  }\n\n  @Override\n  public <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> consumer) {\n    return new RealizedChanged<>(consumer.apply(this.value));\n  }\n\n  public <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> function) {\n    return function.apply(this.value);\n  }\n\n  @Override\n  public String toString() {\n    return \"RealizedChanged{\" + \"value=\" + value + '}';\n  }\n}\n", "file_hash": "bd27e40e33db95b0688cbe8d770fbdce082c29e9365c54cb98789dbbfa683654", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import java.util.Optional;", "import java.util.function.Consumer;", "import java.util.function.Function;"], "methods": [], "classes": [{"original_string": "public class RealizedChanged<T> implements DeferredChanged<T> {\n  private final Optional<T> value;\n\n  public RealizedChanged(T value) {\n    this.value = Optional.ofNullable(value);\n  }\n\n  public RealizedChanged(Optional<T> value) {\n    this.value = value;\n  }\n\n  @Override\n  public void ifPresent(Consumer<T> consumer) {\n    value.ifPresent(consumer);\n  }\n\n  @Override\n  public void whenSet(Consumer<Optional<T>> consumer) {\n    consumer.accept(value);\n  }\n\n  public static <T> RealizedChanged<T> empty() {\n    return new RealizedChanged<>(Optional.empty());\n  }\n\n  @Override\n  public boolean isPresent() {\n    return value.isPresent();\n  }\n\n  @Override\n  public boolean isValueSet() {\n    return true;\n  }\n\n  @Override\n  public T get() {\n    return value.get();\n  }\n\n  public <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> function) {\n    return new RealizedChanged<>(function.apply(this.value));\n  }\n\n  @Override\n  public <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> consumer) {\n    return new RealizedChanged<>(consumer.apply(this.value));\n  }\n\n  public <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> function) {\n    return function.apply(this.value);\n  }\n\n  @Override\n  public String toString() {\n    return \"RealizedChanged{\" + \"value=\" + value + '}';\n  }\n}", "definition": "public class RealizedChanged<T> implements DeferredChanged<T>", "class_docstring": "", "name": "RealizedChanged", "super_interfaces": ["DeferredChanged<T>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Optional<T> value;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Optional<T>", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public RealizedChanged(T value) {\n    this.value = Optional.ofNullable(value);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "RealizedChanged", "params": [{"name": "value", "type": "T"}], "body": "                                  {\n    this.value = Optional.ofNullable(value);\n  }", "signature": "public RealizedChanged(T value)"}, {"syntax_pass": true, "original_string": "  public RealizedChanged(Optional<T> value) {\n    this.value = value;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "RealizedChanged", "params": [{"name": "value", "type": "Optional<T>"}], "body": "                                            {\n    this.value = value;\n  }", "signature": "public RealizedChanged(Optional<T> value)"}, {"syntax_pass": true, "original_string": "  @Override\n  public void ifPresent(Consumer<T> consumer) {\n    value.ifPresent(consumer);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "ifPresent", "params": [{"name": "consumer", "type": "Consumer<T>"}], "body": "                                              {\n    value.ifPresent(consumer);\n  }", "signature": "@Override\n  public void ifPresent(Consumer<T> consumer)"}, {"syntax_pass": true, "original_string": "  @Override\n  public void whenSet(Consumer<Optional<T>> consumer) {\n    consumer.accept(value);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "whenSet", "params": [{"name": "consumer", "type": "Consumer<Optional<T>>"}], "body": "                                                      {\n    consumer.accept(value);\n  }", "signature": "@Override\n  public void whenSet(Consumer<Optional<T>> consumer)"}, {"syntax_pass": true, "original_string": "  public static <T> RealizedChanged<T> empty() {\n    return new RealizedChanged<>(Optional.empty());\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RealizedChanged<T>", "classes": []}, "name": "empty", "params": [], "body": "                                               {\n    return new RealizedChanged<>(Optional.empty());\n  }", "signature": "public static <T> RealizedChanged<T> empty()"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean isPresent() {\n    return value.isPresent();\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPresent", "params": [], "body": "                             {\n    return value.isPresent();\n  }", "signature": "@Override\n  public boolean isPresent()"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean isValueSet() {\n    return true;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isValueSet", "params": [], "body": "                              {\n    return true;\n  }", "signature": "@Override\n  public boolean isValueSet()"}, {"syntax_pass": true, "original_string": "  @Override\n  public T get() {\n    return value.get();\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "get", "params": [], "body": "                 {\n    return value.get();\n  }", "signature": "@Override\n  public T get()"}, {"syntax_pass": true, "original_string": "  public <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> function) {\n    return new RealizedChanged<>(function.apply(this.value));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<Q>", "classes": []}, "name": "map", "params": [{"name": "function", "type": "Function<Optional<T>, Q>"}], "body": "                                                                       {\n    return new RealizedChanged<>(function.apply(this.value));\n  }", "signature": "public <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> function)"}, {"syntax_pass": true, "original_string": "  @Override\n  public <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> consumer) {\n    return new RealizedChanged<>(consumer.apply(this.value));\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<Q>", "classes": []}, "name": "mapOptional", "params": [{"name": "consumer", "type": "Function<Optional<T>, Optional<Q>>"}], "body": "                                                                                         {\n    return new RealizedChanged<>(consumer.apply(this.value));\n  }", "signature": "@Override\n  public <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> consumer)"}, {"syntax_pass": true, "original_string": "  public <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> function) {\n    return function.apply(this.value);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<Q>", "classes": []}, "name": "flatMap", "params": [{"name": "function", "type": "Function<Optional<T>, DeferredChanged<Q>>"}], "body": "                                                                                            {\n    return function.apply(this.value);\n  }", "signature": "public <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> function)"}, {"syntax_pass": true, "original_string": "  @Override\n  public String toString() {\n    return \"RealizedChanged{\" + \"value=\" + value + '}';\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                           {\n    return \"RealizedChanged{\" + \"value=\" + value + '}';\n  }", "signature": "@Override\n  public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/deferred/DeferredChanged.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport javax.annotation.Nullable;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedResponse;\n\npublic interface DeferredChanged<T> {\n\n  void ifPresent(Consumer<T> consumer);\n\n  void whenSet(Consumer<Optional<T>> consumer);\n\n  <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> consumer);\n\n  <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> consumer);\n\n  <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> consumer);\n\n  static <T> DeferredChanged<T> empty() {\n    return RealizedChanged.empty();\n  }\n\n  static <T> DeferredChanged<T> ofNullable(@Nullable T value) {\n    return new RealizedChanged<>(value);\n  }\n\n  static <T extends Changed> DeferredChanged<ChangedResponse> of(Optional<T> changed) {\n    return new RealizedChanged(changed);\n  }\n\n  boolean isPresent();\n\n  boolean isValueSet();\n\n  T get();\n}\n", "file_hash": "aac1fe9086c991aed47233bb44ec65a2b8a55483da2e7d9691e1f44e08eeca6a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import java.util.Optional;", "import java.util.function.Consumer;", "import java.util.function.Function;", "import javax.annotation.Nullable;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedResponse;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface DeferredChanged<T> {\n\n  void ifPresent(Consumer<T> consumer);\n\n  void whenSet(Consumer<Optional<T>> consumer);\n\n  <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> consumer);\n\n  <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> consumer);\n\n  <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> consumer);\n\n  static <T> DeferredChanged<T> empty() {\n    return RealizedChanged.empty();\n  }\n\n  static <T> DeferredChanged<T> ofNullable(@Nullable T value) {\n    return new RealizedChanged<>(value);\n  }\n\n  static <T extends Changed> DeferredChanged<ChangedResponse> of(Optional<T> changed) {\n    return new RealizedChanged(changed);\n  }\n\n  boolean isPresent();\n\n  boolean isValueSet();\n\n  T get();\n}", "definition": "public interface DeferredChanged<T>", "interface_docstring": "", "name": "DeferredChanged", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  void ifPresent(Consumer<T> consumer);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "ifPresent", "params": [{"name": "consumer", "type": "Consumer<T>"}], "body": "", "signature": "void ifPresent(Consumer<T> consumer)"}, {"syntax_pass": true, "original_string": "  void whenSet(Consumer<Optional<T>> consumer);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "whenSet", "params": [{"name": "consumer", "type": "Consumer<Optional<T>>"}], "body": "", "signature": "void whenSet(Consumer<Optional<T>> consumer)"}, {"syntax_pass": true, "original_string": "  <Q> DeferredChanged<Q> map(Function<Optional<T>, Q> consumer);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "DeferredChanged<Q>", "classes": []}, "name": "map", "params": [{"name": "consumer", "type": "Function<Optional<T>, Q>"}], "body": "", "signature": "<Q> DeferredChanged<Q> map(Function<Optional<T>, Q> consumer)"}, {"syntax_pass": true, "original_string": "  <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> consumer);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "DeferredChanged<Q>", "classes": []}, "name": "mapOptional", "params": [{"name": "consumer", "type": "Function<Optional<T>, Optional<Q>>"}], "body": "", "signature": "<Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> consumer)"}, {"syntax_pass": true, "original_string": "  <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> consumer);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "DeferredChanged<Q>", "classes": []}, "name": "flatMap", "params": [{"name": "consumer", "type": "Function<Optional<T>, DeferredChanged<Q>>"}], "body": "", "signature": "<Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> consumer)"}, {"syntax_pass": true, "original_string": "  static <T> DeferredChanged<T> empty() {\n    return RealizedChanged.empty();\n  }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "DeferredChanged<T>", "classes": []}, "name": "empty", "params": [], "body": "                                        {\n    return RealizedChanged.empty();\n  }", "signature": "static <T> DeferredChanged<T> empty()"}, {"syntax_pass": true, "original_string": "  static <T> DeferredChanged<T> ofNullable(@Nullable T value) {\n    return new RealizedChanged<>(value);\n  }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "DeferredChanged<T>", "classes": []}, "name": "ofNullable", "params": [{"name": "value", "type": "T"}], "body": "                                                              {\n    return new RealizedChanged<>(value);\n  }", "signature": "static <T> DeferredChanged<T> ofNullable(@Nullable T value)"}, {"syntax_pass": true, "original_string": "  static <T extends Changed> DeferredChanged<ChangedResponse> of(Optional<T> changed) {\n    return new RealizedChanged(changed);\n  }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "DeferredChanged<ChangedResponse>", "classes": []}, "name": "of", "params": [{"name": "changed", "type": "Optional<T>"}], "body": "                                                                                      {\n    return new RealizedChanged(changed);\n  }", "signature": "static <T extends Changed> DeferredChanged<ChangedResponse> of(Optional<T> changed)"}, {"syntax_pass": true, "original_string": "  boolean isPresent();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPresent", "params": [], "body": "", "signature": "boolean isPresent()"}, {"syntax_pass": true, "original_string": "  boolean isValueSet();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "isValueSet", "params": [], "body": "", "signature": "boolean isValueSet()"}, {"syntax_pass": true, "original_string": "  T get();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "get", "params": [], "body": "", "signature": "T get()"}]}], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/deferred/DeferredLogger.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ComposedChanged;\n\npublic class DeferredLogger {\n  private DeferredLogger() {}\n\n  public static Object logValue(Object value) {\n    return new Object() {\n      public String toString() {\n        return valueToString(value);\n      }\n    };\n  }\n\n  public static String optionalToString(Optional<?> value) {\n    return value.map(v -> \"Optional[\" + valueToString(v) + \"]\").orElse(\"Optional[empty]\");\n  }\n\n  public static String changedToString(Changed value) {\n    if (value instanceof ComposedChanged) {\n      return \"Changed: \" + value.getClass() + \" (composed) \";\n    } else {\n      return \"Changed: \" + value.getClass() + \" \" + value.isChanged();\n    }\n  }\n\n  public static String streamToString(Stream<?> values) {\n    return \"[\" + values.map(DeferredLogger::valueToString).collect(Collectors.joining(\", \")) + \"]\";\n  }\n\n  public static String deferredChangeToString(DeferredChanged<?> deferredChanged) {\n    if (deferredChanged.isValueSet()) {\n      if (deferredChanged.isPresent()) {\n        Object value = deferredChanged.get();\n        return valueToString(value);\n      } else {\n        return deferredChanged.toString();\n      }\n    } else {\n      return deferredChanged.toString();\n    }\n  }\n\n  public static String valueToString(Object value) {\n    if (value == null) {\n      return \"null\";\n    } else if (value instanceof Changed) {\n      return changedToString((Changed) value);\n    } else if (value instanceof Optional) {\n      return optionalToString((Optional<?>) value);\n    } else if (value instanceof DeferredChanged) {\n      return deferredChangeToString((DeferredChanged<?>) value);\n    } else if (value.getClass().isArray()) {\n      return streamToString(Arrays.stream((Object[]) value));\n    } else if (value instanceof Collection) {\n      return streamToString(((Collection<?>) value).stream());\n    } else {\n      return value.toString();\n    }\n  }\n}\n", "file_hash": "233591bd3a30c991b281cc8732d371f326538fd9b3716149b9d52ca55a84e7a1", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import java.util.Arrays;", "import java.util.Collection;", "import java.util.Optional;", "import java.util.stream.Collectors;", "import java.util.stream.Stream;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ComposedChanged;"], "methods": [], "classes": [{"original_string": "public class DeferredLogger {\n  private DeferredLogger() {}\n\n  public static Object logValue(Object value) {\n    return new Object() {\n      public String toString() {\n        return valueToString(value);\n      }\n    };\n  }\n\n  public static String optionalToString(Optional<?> value) {\n    return value.map(v -> \"Optional[\" + valueToString(v) + \"]\").orElse(\"Optional[empty]\");\n  }\n\n  public static String changedToString(Changed value) {\n    if (value instanceof ComposedChanged) {\n      return \"Changed: \" + value.getClass() + \" (composed) \";\n    } else {\n      return \"Changed: \" + value.getClass() + \" \" + value.isChanged();\n    }\n  }\n\n  public static String streamToString(Stream<?> values) {\n    return \"[\" + values.map(DeferredLogger::valueToString).collect(Collectors.joining(\", \")) + \"]\";\n  }\n\n  public static String deferredChangeToString(DeferredChanged<?> deferredChanged) {\n    if (deferredChanged.isValueSet()) {\n      if (deferredChanged.isPresent()) {\n        Object value = deferredChanged.get();\n        return valueToString(value);\n      } else {\n        return deferredChanged.toString();\n      }\n    } else {\n      return deferredChanged.toString();\n    }\n  }\n\n  public static String valueToString(Object value) {\n    if (value == null) {\n      return \"null\";\n    } else if (value instanceof Changed) {\n      return changedToString((Changed) value);\n    } else if (value instanceof Optional) {\n      return optionalToString((Optional<?>) value);\n    } else if (value instanceof DeferredChanged) {\n      return deferredChangeToString((DeferredChanged<?>) value);\n    } else if (value.getClass().isArray()) {\n      return streamToString(Arrays.stream((Object[]) value));\n    } else if (value instanceof Collection) {\n      return streamToString(((Collection<?>) value).stream());\n    } else {\n      return value.toString();\n    }\n  }\n}", "definition": "public class DeferredLogger", "class_docstring": "", "name": "DeferredLogger", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private DeferredLogger() {}", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "DeferredLogger", "params": [], "body": "                           {}", "signature": "private DeferredLogger()"}, {"syntax_pass": true, "original_string": "  public static Object logValue(Object value) {\n    return new Object() {\n      public String toString() {\n        return valueToString(value);\n      }\n    };\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Object", "classes": []}, "name": "logValue", "params": [{"name": "value", "type": "Object"}], "body": "                                              {\n    return new Object() {\n      public String toString() {\n        return valueToString(value);\n      }\n    };\n  }", "signature": "public static Object logValue(Object value)"}, {"syntax_pass": true, "original_string": "  public static String optionalToString(Optional<?> value) {\n    return value.map(v -> \"Optional[\" + valueToString(v) + \"]\").orElse(\"Optional[empty]\");\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "optionalToString", "params": [{"name": "value", "type": "Optional<?>"}], "body": "                                                           {\n    return value.map(v -> \"Optional[\" + valueToString(v) + \"]\").orElse(\"Optional[empty]\");\n  }", "signature": "public static String optionalToString(Optional<?> value)"}, {"syntax_pass": true, "original_string": "  public static String changedToString(Changed value) {\n    if (value instanceof ComposedChanged) {\n      return \"Changed: \" + value.getClass() + \" (composed) \";\n    } else {\n      return \"Changed: \" + value.getClass() + \" \" + value.isChanged();\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "changedToString", "params": [{"name": "value", "type": "Changed"}], "body": "                                                      {\n    if (value instanceof ComposedChanged) {\n      return \"Changed: \" + value.getClass() + \" (composed) \";\n    } else {\n      return \"Changed: \" + value.getClass() + \" \" + value.isChanged();\n    }\n  }", "signature": "public static String changedToString(Changed value)"}, {"syntax_pass": true, "original_string": "  public static String streamToString(Stream<?> values) {\n    return \"[\" + values.map(DeferredLogger::valueToString).collect(Collectors.joining(\", \")) + \"]\";\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "streamToString", "params": [{"name": "values", "type": "Stream<?>"}], "body": "                                                        {\n    return \"[\" + values.map(DeferredLogger::valueToString).collect(Collectors.joining(\", \")) + \"]\";\n  }", "signature": "public static String streamToString(Stream<?> values)"}, {"syntax_pass": true, "original_string": "  public static String deferredChangeToString(DeferredChanged<?> deferredChanged) {\n    if (deferredChanged.isValueSet()) {\n      if (deferredChanged.isPresent()) {\n        Object value = deferredChanged.get();\n        return valueToString(value);\n      } else {\n        return deferredChanged.toString();\n      }\n    } else {\n      return deferredChanged.toString();\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "deferredChangeToString", "params": [{"name": "deferredChanged", "type": "DeferredChanged<?>"}], "body": "                                                                                  {\n    if (deferredChanged.isValueSet()) {\n      if (deferredChanged.isPresent()) {\n        Object value = deferredChanged.get();\n        return valueToString(value);\n      } else {\n        return deferredChanged.toString();\n      }\n    } else {\n      return deferredChanged.toString();\n    }\n  }", "signature": "public static String deferredChangeToString(DeferredChanged<?> deferredChanged)"}, {"syntax_pass": true, "original_string": "  public static String valueToString(Object value) {\n    if (value == null) {\n      return \"null\";\n    } else if (value instanceof Changed) {\n      return changedToString((Changed) value);\n    } else if (value instanceof Optional) {\n      return optionalToString((Optional<?>) value);\n    } else if (value instanceof DeferredChanged) {\n      return deferredChangeToString((DeferredChanged<?>) value);\n    } else if (value.getClass().isArray()) {\n      return streamToString(Arrays.stream((Object[]) value));\n    } else if (value instanceof Collection) {\n      return streamToString(((Collection<?>) value).stream());\n    } else {\n      return value.toString();\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "valueToString", "params": [{"name": "value", "type": "Object"}], "body": "                                                   {\n    if (value == null) {\n      return \"null\";\n    } else if (value instanceof Changed) {\n      return changedToString((Changed) value);\n    } else if (value instanceof Optional) {\n      return optionalToString((Optional<?>) value);\n    } else if (value instanceof DeferredChanged) {\n      return deferredChangeToString((DeferredChanged<?>) value);\n    } else if (value.getClass().isArray()) {\n      return streamToString(Arrays.stream((Object[]) value));\n    } else if (value instanceof Collection) {\n      return streamToString(((Collection<?>) value).stream());\n    } else {\n      return value.toString();\n    }\n  }", "signature": "public static String valueToString(Object value)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/deferred/DeferredBuilder.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DeferredBuilder<T> implements Consumer<DeferredChanged<T>> {\n  private static final Logger log = LoggerFactory.getLogger(DeferredBuilder.class);\n\n  private final List<DeferredChanged<? extends T>> deferredValues = new ArrayList<>();\n  private final List<Consumer<Optional<List<Optional<? super T>>>>> whenSet = new ArrayList<>();\n\n  public <V extends T> Optional<V> with(Optional<V> value) {\n    return value;\n  }\n\n  public <V extends T> DeferredChanged<V> with(DeferredChanged<V> value) {\n    deferredValues.add(value);\n    return value;\n  }\n\n  public <V extends T> DeferredBuilder<T> add(DeferredChanged<V> value) {\n    deferredValues.add(value);\n    return this;\n  }\n\n  public <V extends T> DeferredBuilder<T> addAll(List<DeferredChanged<V>> values) {\n    deferredValues.addAll(values);\n    return this;\n  }\n\n  public <V extends T> DeferredBuilder<T> addAll(Stream<DeferredChanged<V>> values) {\n    deferredValues.addAll(values.collect(Collectors.toList()));\n    return this;\n  }\n\n  public DeferredBuilder<T> whenSet(Consumer<Optional<List<Optional<? super T>>>> consumer) {\n    whenSet.add(consumer);\n    return this;\n  }\n\n  @Override\n  public void accept(DeferredChanged<T> value) {\n    deferredValues.add(value);\n  }\n\n  public DeferredChanged<List<Optional<? super T>>> build() {\n    if (deferredValues.isEmpty()) {\n      return DeferredChanged.empty();\n    }\n\n    log.debug(\"Building collected deferred {}\", DeferredLogger.logValue(deferredValues));\n\n    final PendingChanged<List<Optional<? super T>>> changed = new PendingChanged<>();\n    whenSet.forEach(changed::whenSet);\n\n    Optional[] values = new Optional[deferredValues.size()];\n\n    IntStream.range(0, deferredValues.size())\n        .forEach(\n            i -> {\n              DeferredChanged<? extends T> deferredItem = deferredValues.get(i);\n              deferredItem.whenSet(\n                  value -> {\n                    values[i] = value;\n                    log.debug(\n                        \"Collected deferred item set this={}, item={}, values = {}\",\n                        this,\n                        DeferredLogger.logValue(value),\n                        DeferredLogger.logValue(values));\n                    if (isFull(values)) {\n                      log.debug(\n                          \"Collected deferred triggering complete this={}, values = {}\",\n                          this,\n                          DeferredLogger.logValue(values));\n                      changed.setValue(Optional.of(Arrays.asList(values)));\n                    }\n                  });\n            });\n\n    return changed;\n  }\n\n  public <V extends Changed> DeferredChanged<V> buildIsChanged(V changed) {\n    return build().flatMap(values -> (DeferredChanged<V>) DeferredChanged.of(isChanged(changed)));\n  }\n\n  private static boolean isFull(Object[] values) {\n    for (Object value : values) {\n      if (value == null) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n", "file_hash": "5810c8c009cc587d34194a585c03357d6356122bf4018f9ca0f5096231f4eaae", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.List;", "import java.util.Optional;", "import java.util.function.Consumer;", "import java.util.stream.Collectors;", "import java.util.stream.IntStream;", "import java.util.stream.Stream;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.slf4j.Logger;", "import org.slf4j.LoggerFactory;"], "methods": [], "classes": [{"original_string": "public class DeferredBuilder<T> implements Consumer<DeferredChanged<T>> {\n  private static final Logger log = LoggerFactory.getLogger(DeferredBuilder.class);\n\n  private final List<DeferredChanged<? extends T>> deferredValues = new ArrayList<>();\n  private final List<Consumer<Optional<List<Optional<? super T>>>>> whenSet = new ArrayList<>();\n\n  public <V extends T> Optional<V> with(Optional<V> value) {\n    return value;\n  }\n\n  public <V extends T> DeferredChanged<V> with(DeferredChanged<V> value) {\n    deferredValues.add(value);\n    return value;\n  }\n\n  public <V extends T> DeferredBuilder<T> add(DeferredChanged<V> value) {\n    deferredValues.add(value);\n    return this;\n  }\n\n  public <V extends T> DeferredBuilder<T> addAll(List<DeferredChanged<V>> values) {\n    deferredValues.addAll(values);\n    return this;\n  }\n\n  public <V extends T> DeferredBuilder<T> addAll(Stream<DeferredChanged<V>> values) {\n    deferredValues.addAll(values.collect(Collectors.toList()));\n    return this;\n  }\n\n  public DeferredBuilder<T> whenSet(Consumer<Optional<List<Optional<? super T>>>> consumer) {\n    whenSet.add(consumer);\n    return this;\n  }\n\n  @Override\n  public void accept(DeferredChanged<T> value) {\n    deferredValues.add(value);\n  }\n\n  public DeferredChanged<List<Optional<? super T>>> build() {\n    if (deferredValues.isEmpty()) {\n      return DeferredChanged.empty();\n    }\n\n    log.debug(\"Building collected deferred {}\", DeferredLogger.logValue(deferredValues));\n\n    final PendingChanged<List<Optional<? super T>>> changed = new PendingChanged<>();\n    whenSet.forEach(changed::whenSet);\n\n    Optional[] values = new Optional[deferredValues.size()];\n\n    IntStream.range(0, deferredValues.size())\n        .forEach(\n            i -> {\n              DeferredChanged<? extends T> deferredItem = deferredValues.get(i);\n              deferredItem.whenSet(\n                  value -> {\n                    values[i] = value;\n                    log.debug(\n                        \"Collected deferred item set this={}, item={}, values = {}\",\n                        this,\n                        DeferredLogger.logValue(value),\n                        DeferredLogger.logValue(values));\n                    if (isFull(values)) {\n                      log.debug(\n                          \"Collected deferred triggering complete this={}, values = {}\",\n                          this,\n                          DeferredLogger.logValue(values));\n                      changed.setValue(Optional.of(Arrays.asList(values)));\n                    }\n                  });\n            });\n\n    return changed;\n  }\n\n  public <V extends Changed> DeferredChanged<V> buildIsChanged(V changed) {\n    return build().flatMap(values -> (DeferredChanged<V>) DeferredChanged.of(isChanged(changed)));\n  }\n\n  private static boolean isFull(Object[] values) {\n    for (Object value : values) {\n      if (value == null) {\n        return false;\n      }\n    }\n    return true;\n  }\n}", "definition": "public class DeferredBuilder<T> implements Consumer<DeferredChanged<T>>", "class_docstring": "", "name": "DeferredBuilder", "super_interfaces": ["Consumer<DeferredChanged<T>>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Logger log = LoggerFactory.getLogger(DeferredBuilder.class);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "log = LoggerFactory.getLogger(DeferredBuilder.class)", "syntax_pass": true}, {"attribute_expression": "private final List<DeferredChanged<? extends T>> deferredValues = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<DeferredChanged<? extends T>>", "name": "deferredValues = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<Consumer<Optional<List<Optional<? super T>>>>> whenSet = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Consumer<Optional<List<Optional<? super T>>>>>", "name": "whenSet = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public <V extends T> Optional<V> with(Optional<V> value) {\n    return value;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<V>", "classes": []}, "name": "with", "params": [{"name": "value", "type": "Optional<V>"}], "body": "                                                           {\n    return value;\n  }", "signature": "public <V extends T> Optional<V> with(Optional<V> value)"}, {"syntax_pass": true, "original_string": "  public <V extends T> DeferredChanged<V> with(DeferredChanged<V> value) {\n    deferredValues.add(value);\n    return value;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<V>", "classes": []}, "name": "with", "params": [{"name": "value", "type": "DeferredChanged<V>"}], "body": "                                                                         {\n    deferredValues.add(value);\n    return value;\n  }", "signature": "public <V extends T> DeferredChanged<V> with(DeferredChanged<V> value)"}, {"syntax_pass": true, "original_string": "  public <V extends T> DeferredBuilder<T> add(DeferredChanged<V> value) {\n    deferredValues.add(value);\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredBuilder<T>", "classes": []}, "name": "add", "params": [{"name": "value", "type": "DeferredChanged<V>"}], "body": "                                                                        {\n    deferredValues.add(value);\n    return this;\n  }", "signature": "public <V extends T> DeferredBuilder<T> add(DeferredChanged<V> value)"}, {"syntax_pass": true, "original_string": "  public <V extends T> DeferredBuilder<T> addAll(List<DeferredChanged<V>> values) {\n    deferredValues.addAll(values);\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredBuilder<T>", "classes": []}, "name": "addAll", "params": [{"name": "values", "type": "List<DeferredChanged<V>>"}], "body": "                                                                                  {\n    deferredValues.addAll(values);\n    return this;\n  }", "signature": "public <V extends T> DeferredBuilder<T> addAll(List<DeferredChanged<V>> values)"}, {"syntax_pass": true, "original_string": "  public <V extends T> DeferredBuilder<T> addAll(Stream<DeferredChanged<V>> values) {\n    deferredValues.addAll(values.collect(Collectors.toList()));\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredBuilder<T>", "classes": []}, "name": "addAll", "params": [{"name": "values", "type": "Stream<DeferredChanged<V>>"}], "body": "                                                                                    {\n    deferredValues.addAll(values.collect(Collectors.toList()));\n    return this;\n  }", "signature": "public <V extends T> DeferredBuilder<T> addAll(Stream<DeferredChanged<V>> values)"}, {"syntax_pass": true, "original_string": "  public DeferredBuilder<T> whenSet(Consumer<Optional<List<Optional<? super T>>>> consumer) {\n    whenSet.add(consumer);\n    return this;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredBuilder<T>", "classes": []}, "name": "whenSet", "params": [{"name": "consumer", "type": "Consumer<Optional<List<Optional<? super T>>>>"}], "body": "                                                                                            {\n    whenSet.add(consumer);\n    return this;\n  }", "signature": "public DeferredBuilder<T> whenSet(Consumer<Optional<List<Optional<? super T>>>> consumer)"}, {"syntax_pass": true, "original_string": "  @Override\n  public void accept(DeferredChanged<T> value) {\n    deferredValues.add(value);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "accept", "params": [{"name": "value", "type": "DeferredChanged<T>"}], "body": "                                               {\n    deferredValues.add(value);\n  }", "signature": "@Override\n  public void accept(DeferredChanged<T> value)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<List<Optional<? super T>>> build() {\n    if (deferredValues.isEmpty()) {\n      return DeferredChanged.empty();\n    }\n\n    log.debug(\"Building collected deferred {}\", DeferredLogger.logValue(deferredValues));\n\n    final PendingChanged<List<Optional<? super T>>> changed = new PendingChanged<>();\n    whenSet.forEach(changed::whenSet);\n\n    Optional[] values = new Optional[deferredValues.size()];\n\n    IntStream.range(0, deferredValues.size())\n        .forEach(\n            i -> {\n              DeferredChanged<? extends T> deferredItem = deferredValues.get(i);\n              deferredItem.whenSet(\n                  value -> {\n                    values[i] = value;\n                    log.debug(\n                        \"Collected deferred item set this={}, item={}, values = {}\",\n                        this,\n                        DeferredLogger.logValue(value),\n                        DeferredLogger.logValue(values));\n                    if (isFull(values)) {\n                      log.debug(\n                          \"Collected deferred triggering complete this={}, values = {}\",\n                          this,\n                          DeferredLogger.logValue(values));\n                      changed.setValue(Optional.of(Arrays.asList(values)));\n                    }\n                  });\n            });\n\n    return changed;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<List<Optional<? super T>>>", "classes": []}, "name": "build", "params": [], "body": "                                                            {\n    if (deferredValues.isEmpty()) {\n      return DeferredChanged.empty();\n    }\n\n    log.debug(\"Building collected deferred {}\", DeferredLogger.logValue(deferredValues));\n\n    final PendingChanged<List<Optional<? super T>>> changed = new PendingChanged<>();\n    whenSet.forEach(changed::whenSet);\n\n    Optional[] values = new Optional[deferredValues.size()];\n\n    IntStream.range(0, deferredValues.size())\n        .forEach(\n            i -> {\n              DeferredChanged<? extends T> deferredItem = deferredValues.get(i);\n              deferredItem.whenSet(\n                  value -> {\n                    values[i] = value;\n                    log.debug(\n                        \"Collected deferred item set this={}, item={}, values = {}\",\n                        this,\n                        DeferredLogger.logValue(value),\n                        DeferredLogger.logValue(values));\n                    if (isFull(values)) {\n                      log.debug(\n                          \"Collected deferred triggering complete this={}, values = {}\",\n                          this,\n                          DeferredLogger.logValue(values));\n                      changed.setValue(Optional.of(Arrays.asList(values)));\n                    }\n                  });\n            });\n\n    return changed;\n  }", "signature": "public DeferredChanged<List<Optional<? super T>>> build()"}, {"syntax_pass": true, "original_string": "  public <V extends Changed> DeferredChanged<V> buildIsChanged(V changed) {\n    return build().flatMap(values -> (DeferredChanged<V>) DeferredChanged.of(isChanged(changed)));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<V>", "classes": []}, "name": "buildIsChanged", "params": [{"name": "changed", "type": "V"}], "body": "                                                                          {\n    return build().flatMap(values -> (DeferredChanged<V>) DeferredChanged.of(isChanged(changed)));\n  }", "signature": "public <V extends Changed> DeferredChanged<V> buildIsChanged(V changed)"}, {"syntax_pass": true, "original_string": "  private static boolean isFull(Object[] values) {\n    for (Object value : values) {\n      if (value == null) {\n        return false;\n      }\n    }\n    return true;\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isFull", "params": [{"name": "values", "type": "Object[]"}], "body": "                                                 {\n    for (Object value : values) {\n      if (value == null) {\n        return false;\n      }\n    }\n    return true;\n  }", "signature": "private static boolean isFull(Object[] values)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/deferred/RecursiveSchemaSet.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport java.util.HashSet;\nimport org.openapitools.openapidiff.core.compare.CacheKey;\n\npublic class RecursiveSchemaSet {\n  HashSet<String> leftKeys = new HashSet<>();\n  HashSet<String> rightKeys = new HashSet<>();\n\n  public boolean contains(CacheKey key) {\n    return leftKeys.contains(key.getLeft()) || rightKeys.contains(key.getRight());\n  }\n\n  public void put(CacheKey key) {\n    leftKeys.add(key.getLeft());\n    leftKeys.add(key.getRight());\n  }\n}\n", "file_hash": "d25455760b328bb58288d9ce83764d9b3aec5bb4d693f466e90851d585db1ef0", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import java.util.HashSet;", "import org.openapitools.openapidiff.core.compare.CacheKey;"], "methods": [], "classes": [{"original_string": "public class RecursiveSchemaSet {\n  HashSet<String> leftKeys = new HashSet<>();\n  HashSet<String> rightKeys = new HashSet<>();\n\n  public boolean contains(CacheKey key) {\n    return leftKeys.contains(key.getLeft()) || rightKeys.contains(key.getRight());\n  }\n\n  public void put(CacheKey key) {\n    leftKeys.add(key.getLeft());\n    leftKeys.add(key.getRight());\n  }\n}", "definition": "public class RecursiveSchemaSet", "class_docstring": "", "name": "RecursiveSchemaSet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "HashSet<String> leftKeys = new HashSet<>();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "HashSet<String>", "name": "leftKeys = new HashSet<>()", "syntax_pass": true}, {"attribute_expression": "HashSet<String> rightKeys = new HashSet<>();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "HashSet<String>", "name": "rightKeys = new HashSet<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public boolean contains(CacheKey key) {\n    return leftKeys.contains(key.getLeft()) || rightKeys.contains(key.getRight());\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "key", "type": "CacheKey"}], "body": "                                        {\n    return leftKeys.contains(key.getLeft()) || rightKeys.contains(key.getRight());\n  }", "signature": "public boolean contains(CacheKey key)"}, {"syntax_pass": true, "original_string": "  public void put(CacheKey key) {\n    leftKeys.add(key.getLeft());\n    leftKeys.add(key.getRight());\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "put", "params": [{"name": "key", "type": "CacheKey"}], "body": "                                {\n    leftKeys.add(key.getLeft());\n    leftKeys.add(key.getRight());\n  }", "signature": "public void put(CacheKey key)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/deferred/DeferredSchemaCache.java", "original_string": "package org.openapitools.openapidiff.core.model.deferred;\n\nimport io.swagger.v3.oas.models.media.Schema;\nimport java.util.ArrayDeque;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.stream.Collectors;\nimport org.openapitools.openapidiff.core.compare.CacheKey;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiff;\nimport org.openapitools.openapidiff.core.model.ChangedSchema;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class DeferredSchemaCache {\n  private static final Logger log = LoggerFactory.getLogger(DeferredSchemaCache.class);\n\n  private final Map<CacheKey, SchemaDiffOperation> cache = new LinkedHashMap<>();\n  private final Queue<CacheKey> processingQueue = new ArrayDeque<>();\n\n  private final OpenApiDiff openApiDiff;\n\n  public DeferredSchemaCache(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public SchemaDiffOperation addSchema(\n      RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    if (!cache.containsKey(key)) {\n      log.debug(\"Added schema cache {}\", key);\n      SchemaDiffOperation operation =\n          new SchemaDiffOperation(openApiDiff, refSet, key, left, right);\n      cache.put(key, operation);\n      processingQueue.add(key);\n      return operation;\n    } else {\n      return cache.get(key);\n    }\n  }\n\n  public DeferredChanged<ChangedSchema> getOrAddSchema(\n      RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    // don't allow recursive references to schemas\n    if (refSet.contains(key)) {\n      log.debug(\"getOrAddSchema recursive call aborted {} \", key);\n      return DeferredChanged.empty();\n    }\n\n    refSet.put(key);\n    SchemaDiffOperation operation;\n    if (cache.containsKey(key)) {\n      operation = cache.get(key);\n      log.debug(\"getOrAddSchema cached {} {}\", key, operation.diffResult);\n    } else {\n      operation = addSchema(refSet, key, left, right);\n      log.debug(\"getOrAddSchema added {} {}\", key, operation.diffResult);\n    }\n    return operation.diffResult;\n  }\n\n  public void process() {\n    processSchemaQueue();\n    //        while(! deferredOperations.isEmpty()) {\n    //            processSchemaQueue();\n    //            DeferredOperation op = deferredOperations.poll();\n    //            if(op != null) {\n    //                log.debug(\"Processing deferred {}\", op);\n    //                op.process();\n    //            }\n    //        }\n  }\n\n  public void processSchemaQueue() {\n    PendingChanged.logResolved();\n    while (!processingQueue.isEmpty()) {\n      CacheKey key = processingQueue.poll();\n      if (key != null) {\n        log.debug(\"Processing schema {}\", key);\n        SchemaDiffOperation operation = cache.get(key);\n        DeferredChanged<ChangedSchema> realValue =\n            operation\n                .openApiDiff\n                .getSchemaDiff()\n                .computeDiffForReal(\n                    operation.refSet, operation.left, operation.right, key.getContext());\n        operation.processed = true;\n        realValue.whenSet(\n            value -> {\n              log.debug(\"Schema processed {} {}\", key, DeferredLogger.logValue(value));\n              operation.diffResult.setValue(value);\n            });\n        log.debug(\"Processing schema started {}\", key);\n      }\n      PendingChanged.logResolved();\n    }\n  }\n\n  public Collection<SchemaDiffOperation> getOperations() {\n    return cache.values();\n  }\n\n  public List<ChangedSchema> getChangedSchemas() {\n    return cache.values().stream()\n        .filter(op -> op.processed && op.diffResult.isPresent())\n        .map(op -> op.diffResult.get())\n        .collect(Collectors.toList());\n  }\n}\n", "file_hash": "4c2e98d9131a74f2a285fa2ec4f6496fedb7ccdfff3a14bee1a13117687d0d1b", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.deferred;", "import io.swagger.v3.oas.models.media.Schema;", "import java.util.ArrayDeque;", "import java.util.Collection;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Queue;", "import java.util.stream.Collectors;", "import org.openapitools.openapidiff.core.compare.CacheKey;", "import org.openapitools.openapidiff.core.compare.OpenApiDiff;", "import org.openapitools.openapidiff.core.model.ChangedSchema;", "import org.slf4j.Logger;", "import org.slf4j.LoggerFactory;"], "methods": [], "classes": [{"original_string": "public class DeferredSchemaCache {\n  private static final Logger log = LoggerFactory.getLogger(DeferredSchemaCache.class);\n\n  private final Map<CacheKey, SchemaDiffOperation> cache = new LinkedHashMap<>();\n  private final Queue<CacheKey> processingQueue = new ArrayDeque<>();\n\n  private final OpenApiDiff openApiDiff;\n\n  public DeferredSchemaCache(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public SchemaDiffOperation addSchema(\n      RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    if (!cache.containsKey(key)) {\n      log.debug(\"Added schema cache {}\", key);\n      SchemaDiffOperation operation =\n          new SchemaDiffOperation(openApiDiff, refSet, key, left, right);\n      cache.put(key, operation);\n      processingQueue.add(key);\n      return operation;\n    } else {\n      return cache.get(key);\n    }\n  }\n\n  public DeferredChanged<ChangedSchema> getOrAddSchema(\n      RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    // don't allow recursive references to schemas\n    if (refSet.contains(key)) {\n      log.debug(\"getOrAddSchema recursive call aborted {} \", key);\n      return DeferredChanged.empty();\n    }\n\n    refSet.put(key);\n    SchemaDiffOperation operation;\n    if (cache.containsKey(key)) {\n      operation = cache.get(key);\n      log.debug(\"getOrAddSchema cached {} {}\", key, operation.diffResult);\n    } else {\n      operation = addSchema(refSet, key, left, right);\n      log.debug(\"getOrAddSchema added {} {}\", key, operation.diffResult);\n    }\n    return operation.diffResult;\n  }\n\n  public void process() {\n    processSchemaQueue();\n    //        while(! deferredOperations.isEmpty()) {\n    //            processSchemaQueue();\n    //            DeferredOperation op = deferredOperations.poll();\n    //            if(op != null) {\n    //                log.debug(\"Processing deferred {}\", op);\n    //                op.process();\n    //            }\n    //        }\n  }\n\n  public void processSchemaQueue() {\n    PendingChanged.logResolved();\n    while (!processingQueue.isEmpty()) {\n      CacheKey key = processingQueue.poll();\n      if (key != null) {\n        log.debug(\"Processing schema {}\", key);\n        SchemaDiffOperation operation = cache.get(key);\n        DeferredChanged<ChangedSchema> realValue =\n            operation\n                .openApiDiff\n                .getSchemaDiff()\n                .computeDiffForReal(\n                    operation.refSet, operation.left, operation.right, key.getContext());\n        operation.processed = true;\n        realValue.whenSet(\n            value -> {\n              log.debug(\"Schema processed {} {}\", key, DeferredLogger.logValue(value));\n              operation.diffResult.setValue(value);\n            });\n        log.debug(\"Processing schema started {}\", key);\n      }\n      PendingChanged.logResolved();\n    }\n  }\n\n  public Collection<SchemaDiffOperation> getOperations() {\n    return cache.values();\n  }\n\n  public List<ChangedSchema> getChangedSchemas() {\n    return cache.values().stream()\n        .filter(op -> op.processed && op.diffResult.isPresent())\n        .map(op -> op.diffResult.get())\n        .collect(Collectors.toList());\n  }\n}", "definition": "public class DeferredSchemaCache", "class_docstring": "", "name": "DeferredSchemaCache", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Logger log = LoggerFactory.getLogger(DeferredSchemaCache.class);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "log = LoggerFactory.getLogger(DeferredSchemaCache.class)", "syntax_pass": true}, {"attribute_expression": "private final Map<CacheKey, SchemaDiffOperation> cache = new LinkedHashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<CacheKey, SchemaDiffOperation>", "name": "cache = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Queue<CacheKey> processingQueue = new ArrayDeque<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Queue<CacheKey>", "name": "processingQueue = new ArrayDeque<>()", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public DeferredSchemaCache(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "DeferredSchemaCache", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                      {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public DeferredSchemaCache(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public SchemaDiffOperation addSchema(\n      RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    if (!cache.containsKey(key)) {\n      log.debug(\"Added schema cache {}\", key);\n      SchemaDiffOperation operation =\n          new SchemaDiffOperation(openApiDiff, refSet, key, left, right);\n      cache.put(key, operation);\n      processingQueue.add(key);\n      return operation;\n    } else {\n      return cache.get(key);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SchemaDiffOperation", "classes": []}, "name": "addSchema", "params": [{"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "key", "type": "CacheKey"}, {"name": "left", "type": "Schema"}, {"name": "right", "type": "Schema"}], "body": "                                                                          {\n    if (!cache.containsKey(key)) {\n      log.debug(\"Added schema cache {}\", key);\n      SchemaDiffOperation operation =\n          new SchemaDiffOperation(openApiDiff, refSet, key, left, right);\n      cache.put(key, operation);\n      processingQueue.add(key);\n      return operation;\n    } else {\n      return cache.get(key);\n    }\n  }", "signature": "public SchemaDiffOperation addSchema(\n      RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedSchema> getOrAddSchema(\n      RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    // don't allow recursive references to schemas\n    if (refSet.contains(key)) {\n      log.debug(\"getOrAddSchema recursive call aborted {} \", key);\n      return DeferredChanged.empty();\n    }\n\n    refSet.put(key);\n    SchemaDiffOperation operation;\n    if (cache.containsKey(key)) {\n      operation = cache.get(key);\n      log.debug(\"getOrAddSchema cached {} {}\", key, operation.diffResult);\n    } else {\n      operation = addSchema(refSet, key, left, right);\n      log.debug(\"getOrAddSchema added {} {}\", key, operation.diffResult);\n    }\n    return operation.diffResult;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSchema>", "classes": []}, "name": "getOrAddSchema", "params": [{"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "key", "type": "CacheKey"}, {"name": "left", "type": "Schema"}, {"name": "right", "type": "Schema"}], "body": "                                                                          {\n    // don't allow recursive references to schemas\n    if (refSet.contains(key)) {\n      log.debug(\"getOrAddSchema recursive call aborted {} \", key);\n      return DeferredChanged.empty();\n    }\n\n    refSet.put(key);\n    SchemaDiffOperation operation;\n    if (cache.containsKey(key)) {\n      operation = cache.get(key);\n      log.debug(\"getOrAddSchema cached {} {}\", key, operation.diffResult);\n    } else {\n      operation = addSchema(refSet, key, left, right);\n      log.debug(\"getOrAddSchema added {} {}\", key, operation.diffResult);\n    }\n    return operation.diffResult;\n  }", "signature": "public DeferredChanged<ChangedSchema> getOrAddSchema(\n      RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right)"}, {"syntax_pass": true, "original_string": "  public void process() {\n    processSchemaQueue();\n    //        while(! deferredOperations.isEmpty()) {\n    //            processSchemaQueue();\n    //            DeferredOperation op = deferredOperations.poll();\n    //            if(op != null) {\n    //                log.debug(\"Processing deferred {}\", op);\n    //                op.process();\n    //            }\n    //        }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "process", "params": [], "body": "                        {\n    processSchemaQueue();\n    //        while(! deferredOperations.isEmpty()) {\n    //            processSchemaQueue();\n    //            DeferredOperation op = deferredOperations.poll();\n    //            if(op != null) {\n    //                log.debug(\"Processing deferred {}\", op);\n    //                op.process();\n    //            }\n    //        }\n  }", "signature": "public void process()"}, {"syntax_pass": true, "original_string": "  public void processSchemaQueue() {\n    PendingChanged.logResolved();\n    while (!processingQueue.isEmpty()) {\n      CacheKey key = processingQueue.poll();\n      if (key != null) {\n        log.debug(\"Processing schema {}\", key);\n        SchemaDiffOperation operation = cache.get(key);\n        DeferredChanged<ChangedSchema> realValue =\n            operation\n                .openApiDiff\n                .getSchemaDiff()\n                .computeDiffForReal(\n                    operation.refSet, operation.left, operation.right, key.getContext());\n        operation.processed = true;\n        realValue.whenSet(\n            value -> {\n              log.debug(\"Schema processed {} {}\", key, DeferredLogger.logValue(value));\n              operation.diffResult.setValue(value);\n            });\n        log.debug(\"Processing schema started {}\", key);\n      }\n      PendingChanged.logResolved();\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "processSchemaQueue", "params": [], "body": "                                   {\n    PendingChanged.logResolved();\n    while (!processingQueue.isEmpty()) {\n      CacheKey key = processingQueue.poll();\n      if (key != null) {\n        log.debug(\"Processing schema {}\", key);\n        SchemaDiffOperation operation = cache.get(key);\n        DeferredChanged<ChangedSchema> realValue =\n            operation\n                .openApiDiff\n                .getSchemaDiff()\n                .computeDiffForReal(\n                    operation.refSet, operation.left, operation.right, key.getContext());\n        operation.processed = true;\n        realValue.whenSet(\n            value -> {\n              log.debug(\"Schema processed {} {}\", key, DeferredLogger.logValue(value));\n              operation.diffResult.setValue(value);\n            });\n        log.debug(\"Processing schema started {}\", key);\n      }\n      PendingChanged.logResolved();\n    }\n  }", "signature": "public void processSchemaQueue()"}, {"syntax_pass": true, "original_string": "  public Collection<SchemaDiffOperation> getOperations() {\n    return cache.values();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<SchemaDiffOperation>", "classes": []}, "name": "getOperations", "params": [], "body": "                                                         {\n    return cache.values();\n  }", "signature": "public Collection<SchemaDiffOperation> getOperations()"}, {"syntax_pass": true, "original_string": "  public List<ChangedSchema> getChangedSchemas() {\n    return cache.values().stream()\n        .filter(op -> op.processed && op.diffResult.isPresent())\n        .map(op -> op.diffResult.get())\n        .collect(Collectors.toList());\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ChangedSchema>", "classes": []}, "name": "getChangedSchemas", "params": [], "body": "                                                 {\n    return cache.values().stream()\n        .filter(op -> op.processed && op.diffResult.isPresent())\n        .map(op -> op.diffResult.get())\n        .collect(Collectors.toList());\n  }", "signature": "public List<ChangedSchema> getChangedSchemas()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/schema/ChangedReadOnly.java", "original_string": "package org.openapitools.openapidiff.core.model.schema;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_READONLY_INCREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_READONLY_REQUIRED_DECREASED;\n\nimport java.util.Objects;\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.DiffResult;\n\npublic class ChangedReadOnly implements Changed {\n  private final DiffContext context;\n  private final boolean oldValue;\n  private final boolean newValue;\n  //    private final boolean required;\n\n  public ChangedReadOnly(Boolean oldValue, Boolean newValue, DiffContext context) {\n    this.context = context;\n    this.oldValue = Optional.ofNullable(oldValue).orElse(false);\n    this.newValue = Optional.ofNullable(newValue).orElse(false);\n    //        this.required = required;\n  }\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isResponse()) {\n      return DiffResult.COMPATIBLE;\n    }\n    if (context.isRequest()) {\n      if (Boolean.TRUE.equals(newValue)) {\n        if (REQUEST_READONLY_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      } else if (context.isRequired()) {\n        // Incompatible because a prev RO prop (invalid) is now not RO and required\n        if (REQUEST_READONLY_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.UNKNOWN;\n  }\n}\n", "file_hash": "7202d16ba5e2de0115196c29c1e0cc244c7a0cf67c5caadea2fb4f3b028befb2", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.schema;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_READONLY_INCREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_READONLY_REQUIRED_DECREASED;", "import java.util.Objects;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.DiffResult;"], "methods": [], "classes": [{"original_string": "public class ChangedReadOnly implements Changed {\n  private final DiffContext context;\n  private final boolean oldValue;\n  private final boolean newValue;\n  //    private final boolean required;\n\n  public ChangedReadOnly(Boolean oldValue, Boolean newValue, DiffContext context) {\n    this.context = context;\n    this.oldValue = Optional.ofNullable(oldValue).orElse(false);\n    this.newValue = Optional.ofNullable(newValue).orElse(false);\n    //        this.required = required;\n  }\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isResponse()) {\n      return DiffResult.COMPATIBLE;\n    }\n    if (context.isRequest()) {\n      if (Boolean.TRUE.equals(newValue)) {\n        if (REQUEST_READONLY_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      } else if (context.isRequired()) {\n        // Incompatible because a prev RO prop (invalid) is now not RO and required\n        if (REQUEST_READONLY_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.UNKNOWN;\n  }\n}", "definition": "public class ChangedReadOnly implements Changed", "class_docstring": "", "name": "ChangedReadOnly", "super_interfaces": ["Changed"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private final boolean oldValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "oldValue", "syntax_pass": true}, {"attribute_expression": "private final boolean newValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "newValue", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedReadOnly(Boolean oldValue, Boolean newValue, DiffContext context) {\n    this.context = context;\n    this.oldValue = Optional.ofNullable(oldValue).orElse(false);\n    this.newValue = Optional.ofNullable(newValue).orElse(false);\n    //        this.required = required;\n  }", "docstring": "    private final boolean required;", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedReadOnly", "params": [{"name": "oldValue", "type": "Boolean"}, {"name": "newValue", "type": "Boolean"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                  {\n    this.context = context;\n    this.oldValue = Optional.ofNullable(oldValue).orElse(false);\n    this.newValue = Optional.ofNullable(newValue).orElse(false);\n    //        this.required = required;\n  }", "signature": "public ChangedReadOnly(Boolean oldValue, Boolean newValue, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isResponse()) {\n      return DiffResult.COMPATIBLE;\n    }\n    if (context.isRequest()) {\n      if (Boolean.TRUE.equals(newValue)) {\n        if (REQUEST_READONLY_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      } else if (context.isRequired()) {\n        // Incompatible because a prev RO prop (invalid) is now not RO and required\n        if (REQUEST_READONLY_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.UNKNOWN;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isChanged", "params": [], "body": "                                {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isResponse()) {\n      return DiffResult.COMPATIBLE;\n    }\n    if (context.isRequest()) {\n      if (Boolean.TRUE.equals(newValue)) {\n        if (REQUEST_READONLY_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      } else if (context.isRequired()) {\n        // Incompatible because a prev RO prop (invalid) is now not RO and required\n        if (REQUEST_READONLY_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.UNKNOWN;\n  }", "signature": "@Override\n  public DiffResult isChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/schema/ChangedWriteOnly.java", "original_string": "package org.openapitools.openapidiff.core.model.schema;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_WRITEONLY_INCREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_WRITEONLY_REQUIRED_DECREASED;\n\nimport java.util.Objects;\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.DiffResult;\n\npublic class ChangedWriteOnly implements Changed {\n  private final DiffContext context;\n  private final boolean oldValue;\n  private final boolean newValue;\n  //    private final boolean required;\n\n  public ChangedWriteOnly(Boolean oldValue, Boolean newValue, DiffContext context) {\n    this.context = context;\n    this.oldValue = Optional.ofNullable(oldValue).orElse(false);\n    this.newValue = Optional.ofNullable(newValue).orElse(false);\n    //        this.required = required;\n  }\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest()) {\n      return DiffResult.COMPATIBLE;\n    }\n    if (context.isResponse()) {\n      if (Boolean.TRUE.equals(newValue)) {\n        if (RESPONSE_WRITEONLY_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      } else if (context.isRequired()) {\n        if (RESPONSE_WRITEONLY_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.UNKNOWN;\n  }\n}\n", "file_hash": "3d302077ae47d5a3828929abdc491283278a76239b1b4695802bcf82691f7e07", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.schema;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_WRITEONLY_INCREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_WRITEONLY_REQUIRED_DECREASED;", "import java.util.Objects;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.DiffResult;"], "methods": [], "classes": [{"original_string": "public class ChangedWriteOnly implements Changed {\n  private final DiffContext context;\n  private final boolean oldValue;\n  private final boolean newValue;\n  //    private final boolean required;\n\n  public ChangedWriteOnly(Boolean oldValue, Boolean newValue, DiffContext context) {\n    this.context = context;\n    this.oldValue = Optional.ofNullable(oldValue).orElse(false);\n    this.newValue = Optional.ofNullable(newValue).orElse(false);\n    //        this.required = required;\n  }\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest()) {\n      return DiffResult.COMPATIBLE;\n    }\n    if (context.isResponse()) {\n      if (Boolean.TRUE.equals(newValue)) {\n        if (RESPONSE_WRITEONLY_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      } else if (context.isRequired()) {\n        if (RESPONSE_WRITEONLY_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.UNKNOWN;\n  }\n}", "definition": "public class ChangedWriteOnly implements Changed", "class_docstring": "", "name": "ChangedWriteOnly", "super_interfaces": ["Changed"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}, {"attribute_expression": "private final boolean oldValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "oldValue", "syntax_pass": true}, {"attribute_expression": "private final boolean newValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "newValue", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedWriteOnly(Boolean oldValue, Boolean newValue, DiffContext context) {\n    this.context = context;\n    this.oldValue = Optional.ofNullable(oldValue).orElse(false);\n    this.newValue = Optional.ofNullable(newValue).orElse(false);\n    //        this.required = required;\n  }", "docstring": "    private final boolean required;", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedWriteOnly", "params": [{"name": "oldValue", "type": "Boolean"}, {"name": "newValue", "type": "Boolean"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                   {\n    this.context = context;\n    this.oldValue = Optional.ofNullable(oldValue).orElse(false);\n    this.newValue = Optional.ofNullable(newValue).orElse(false);\n    //        this.required = required;\n  }", "signature": "public ChangedWriteOnly(Boolean oldValue, Boolean newValue, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest()) {\n      return DiffResult.COMPATIBLE;\n    }\n    if (context.isResponse()) {\n      if (Boolean.TRUE.equals(newValue)) {\n        if (RESPONSE_WRITEONLY_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      } else if (context.isRequired()) {\n        if (RESPONSE_WRITEONLY_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.UNKNOWN;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isChanged", "params": [], "body": "                                {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest()) {\n      return DiffResult.COMPATIBLE;\n    }\n    if (context.isResponse()) {\n      if (Boolean.TRUE.equals(newValue)) {\n        if (RESPONSE_WRITEONLY_INCREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      } else if (context.isRequired()) {\n        if (RESPONSE_WRITEONLY_REQUIRED_DECREASED.enabled(context)) {\n          return DiffResult.INCOMPATIBLE;\n        }\n      }\n      return DiffResult.COMPATIBLE;\n    }\n    return DiffResult.UNKNOWN;\n  }", "signature": "@Override\n  public DiffResult isChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/schema/ChangedNumericRange.java", "original_string": "package org.openapitools.openapidiff.core.model.schema;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_NUMERIC_RANGE_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_NUMERIC_RANGE_INCREASED;\n\nimport java.math.BigDecimal;\nimport java.util.Objects;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.DiffResult;\n\npublic final class ChangedNumericRange implements Changed {\n  private final BigDecimal oldMinimumValue;\n  private final BigDecimal newMinimumValue;\n  private final BigDecimal oldMaximumValue;\n  private final BigDecimal newMaximumValue;\n  private final Boolean oldMinimumExclusiveValue;\n  private final Boolean newMinimumExclusiveValue;\n  private final Boolean oldMaximumExclusiveValue;\n  private final Boolean newMaximumExclusiveValue;\n  private final DiffContext context;\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldMinimumValue, newMinimumValue)\n        && Objects.equals(oldMaximumValue, newMaximumValue)\n        && Objects.equals(oldMinimumExclusiveValue, newMinimumExclusiveValue)\n        && Objects.equals(oldMaximumExclusiveValue, newMaximumExclusiveValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    if ((context.isRequest() && !REQUEST_NUMERIC_RANGE_DECREASED.enabled(context))\n        || (context.isResponse() && !RESPONSE_NUMERIC_RANGE_INCREASED.enabled(context))) {\n      return DiffResult.COMPATIBLE;\n    }\n\n    boolean exclusiveMaxOld = oldMaximumExclusiveValue != null && oldMaximumExclusiveValue;\n    boolean exclusiveMinOld = oldMinimumExclusiveValue != null && oldMinimumExclusiveValue;\n    boolean exclusiveMaxNew = newMaximumExclusiveValue != null && newMaximumExclusiveValue;\n    boolean exclusiveMinNew = newMinimumExclusiveValue != null && newMinimumExclusiveValue;\n    int diffMax = compare(oldMaximumValue, newMaximumValue, false);\n    int diffMin = compare(oldMinimumValue, newMinimumValue, true);\n\n    if (context.isRequest()) {\n      if (diffMax > 0 || (diffMax == 0 && !exclusiveMaxOld && exclusiveMaxNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (diffMin < 0 || (diffMin == 0 && !exclusiveMinOld && exclusiveMinNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    } else if (context.isResponse()) {\n      if (diffMax < 0 || (diffMax == 0 && exclusiveMaxOld && !exclusiveMaxNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (diffMin > 0 || (diffMin == 0 && exclusiveMinOld && !exclusiveMinNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  private int compare(BigDecimal left, BigDecimal right, boolean nullMeansLessThan) {\n    if (left == null && right == null) {\n      return 0;\n    }\n    if (left == null) {\n      return nullMeansLessThan ? -1 : 1;\n    }\n    if (right == null) {\n      return nullMeansLessThan ? 1 : -1;\n    }\n    return left.unscaledValue().compareTo(right.unscaledValue());\n  }\n\n  public ChangedNumericRange(\n      final BigDecimal oldMinimumValue,\n      final BigDecimal newMinimumValue,\n      final BigDecimal oldMaximumValue,\n      final BigDecimal newMaximumValue,\n      final Boolean oldMinimumExclusiveValue,\n      final Boolean newMinimumExclusiveValue,\n      final Boolean oldMaximumExclusiveValue,\n      final Boolean newMaximumExclusiveValue,\n      final DiffContext context) {\n    this.oldMinimumValue = oldMinimumValue;\n    this.newMinimumValue = newMinimumValue;\n    this.oldMaximumValue = oldMaximumValue;\n    this.newMaximumValue = newMaximumValue;\n    this.oldMinimumExclusiveValue = oldMinimumExclusiveValue;\n    this.newMinimumExclusiveValue = newMinimumExclusiveValue;\n    this.oldMaximumExclusiveValue = oldMaximumExclusiveValue;\n    this.newMaximumExclusiveValue = newMaximumExclusiveValue;\n    this.context = context;\n  }\n\n  public BigDecimal getOldMinimumValue() {\n    return oldMinimumValue;\n  }\n\n  public BigDecimal getNewMinimumValue() {\n    return newMinimumValue;\n  }\n\n  public BigDecimal getOldMaximumValue() {\n    return oldMaximumValue;\n  }\n\n  public BigDecimal getNewMaximumValue() {\n    return newMaximumValue;\n  }\n\n  public Boolean getOldMinimumExclusiveValue() {\n    return oldMinimumExclusiveValue;\n  }\n\n  public Boolean getNewMinimumExclusiveValue() {\n    return newMinimumExclusiveValue;\n  }\n\n  public Boolean getOldMaximumExclusiveValue() {\n    return oldMaximumExclusiveValue;\n  }\n\n  public Boolean getNewMaximumExclusiveValue() {\n    return newMaximumExclusiveValue;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedNumericRange that = (ChangedNumericRange) o;\n    return Objects.equals(oldMinimumValue, newMinimumValue)\n        && Objects.equals(oldMaximumValue, newMaximumValue)\n        && Objects.equals(oldMinimumExclusiveValue, newMinimumExclusiveValue)\n        && Objects.equals(oldMaximumExclusiveValue, newMaximumExclusiveValue)\n        && Objects.equals(context, that.context);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldMinimumValue,\n        newMinimumValue,\n        oldMaximumValue,\n        newMaximumValue,\n        oldMinimumExclusiveValue,\n        newMinimumExclusiveValue,\n        oldMaximumExclusiveValue,\n        newMaximumExclusiveValue,\n        context);\n  }\n\n  @Override\n  public String toString() {\n    return \"ChangedNumericRange(\"\n        + \"oldMinimumValue=\"\n        + oldMinimumValue\n        + \", newMinimumValue=\"\n        + newMinimumValue\n        + \", oldMaximumValue=\"\n        + oldMaximumValue\n        + \", newMaximumValue=\"\n        + newMaximumValue\n        + \", oldMinimumExclusiveValue=\"\n        + oldMinimumExclusiveValue\n        + \", newMinimumExclusiveValue=\"\n        + newMinimumExclusiveValue\n        + \", oldMaximumExclusiveValue=\"\n        + oldMaximumExclusiveValue\n        + \", newMaximumExclusiveValue=\"\n        + newMaximumExclusiveValue\n        + \", context=\"\n        + context\n        + ')';\n  }\n}\n", "file_hash": "c3c3899018f01966fb4142eb141a61876baf369f04027b0403281184ceb69a18", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.schema;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_NUMERIC_RANGE_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_NUMERIC_RANGE_INCREASED;", "import java.math.BigDecimal;", "import java.util.Objects;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.DiffResult;"], "methods": [], "classes": [{"original_string": "public final class ChangedNumericRange implements Changed {\n  private final BigDecimal oldMinimumValue;\n  private final BigDecimal newMinimumValue;\n  private final BigDecimal oldMaximumValue;\n  private final BigDecimal newMaximumValue;\n  private final Boolean oldMinimumExclusiveValue;\n  private final Boolean newMinimumExclusiveValue;\n  private final Boolean oldMaximumExclusiveValue;\n  private final Boolean newMaximumExclusiveValue;\n  private final DiffContext context;\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldMinimumValue, newMinimumValue)\n        && Objects.equals(oldMaximumValue, newMaximumValue)\n        && Objects.equals(oldMinimumExclusiveValue, newMinimumExclusiveValue)\n        && Objects.equals(oldMaximumExclusiveValue, newMaximumExclusiveValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    if ((context.isRequest() && !REQUEST_NUMERIC_RANGE_DECREASED.enabled(context))\n        || (context.isResponse() && !RESPONSE_NUMERIC_RANGE_INCREASED.enabled(context))) {\n      return DiffResult.COMPATIBLE;\n    }\n\n    boolean exclusiveMaxOld = oldMaximumExclusiveValue != null && oldMaximumExclusiveValue;\n    boolean exclusiveMinOld = oldMinimumExclusiveValue != null && oldMinimumExclusiveValue;\n    boolean exclusiveMaxNew = newMaximumExclusiveValue != null && newMaximumExclusiveValue;\n    boolean exclusiveMinNew = newMinimumExclusiveValue != null && newMinimumExclusiveValue;\n    int diffMax = compare(oldMaximumValue, newMaximumValue, false);\n    int diffMin = compare(oldMinimumValue, newMinimumValue, true);\n\n    if (context.isRequest()) {\n      if (diffMax > 0 || (diffMax == 0 && !exclusiveMaxOld && exclusiveMaxNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (diffMin < 0 || (diffMin == 0 && !exclusiveMinOld && exclusiveMinNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    } else if (context.isResponse()) {\n      if (diffMax < 0 || (diffMax == 0 && exclusiveMaxOld && !exclusiveMaxNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (diffMin > 0 || (diffMin == 0 && exclusiveMinOld && !exclusiveMinNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  private int compare(BigDecimal left, BigDecimal right, boolean nullMeansLessThan) {\n    if (left == null && right == null) {\n      return 0;\n    }\n    if (left == null) {\n      return nullMeansLessThan ? -1 : 1;\n    }\n    if (right == null) {\n      return nullMeansLessThan ? 1 : -1;\n    }\n    return left.unscaledValue().compareTo(right.unscaledValue());\n  }\n\n  public ChangedNumericRange(\n      final BigDecimal oldMinimumValue,\n      final BigDecimal newMinimumValue,\n      final BigDecimal oldMaximumValue,\n      final BigDecimal newMaximumValue,\n      final Boolean oldMinimumExclusiveValue,\n      final Boolean newMinimumExclusiveValue,\n      final Boolean oldMaximumExclusiveValue,\n      final Boolean newMaximumExclusiveValue,\n      final DiffContext context) {\n    this.oldMinimumValue = oldMinimumValue;\n    this.newMinimumValue = newMinimumValue;\n    this.oldMaximumValue = oldMaximumValue;\n    this.newMaximumValue = newMaximumValue;\n    this.oldMinimumExclusiveValue = oldMinimumExclusiveValue;\n    this.newMinimumExclusiveValue = newMinimumExclusiveValue;\n    this.oldMaximumExclusiveValue = oldMaximumExclusiveValue;\n    this.newMaximumExclusiveValue = newMaximumExclusiveValue;\n    this.context = context;\n  }\n\n  public BigDecimal getOldMinimumValue() {\n    return oldMinimumValue;\n  }\n\n  public BigDecimal getNewMinimumValue() {\n    return newMinimumValue;\n  }\n\n  public BigDecimal getOldMaximumValue() {\n    return oldMaximumValue;\n  }\n\n  public BigDecimal getNewMaximumValue() {\n    return newMaximumValue;\n  }\n\n  public Boolean getOldMinimumExclusiveValue() {\n    return oldMinimumExclusiveValue;\n  }\n\n  public Boolean getNewMinimumExclusiveValue() {\n    return newMinimumExclusiveValue;\n  }\n\n  public Boolean getOldMaximumExclusiveValue() {\n    return oldMaximumExclusiveValue;\n  }\n\n  public Boolean getNewMaximumExclusiveValue() {\n    return newMaximumExclusiveValue;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedNumericRange that = (ChangedNumericRange) o;\n    return Objects.equals(oldMinimumValue, newMinimumValue)\n        && Objects.equals(oldMaximumValue, newMaximumValue)\n        && Objects.equals(oldMinimumExclusiveValue, newMinimumExclusiveValue)\n        && Objects.equals(oldMaximumExclusiveValue, newMaximumExclusiveValue)\n        && Objects.equals(context, that.context);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldMinimumValue,\n        newMinimumValue,\n        oldMaximumValue,\n        newMaximumValue,\n        oldMinimumExclusiveValue,\n        newMinimumExclusiveValue,\n        oldMaximumExclusiveValue,\n        newMaximumExclusiveValue,\n        context);\n  }\n\n  @Override\n  public String toString() {\n    return \"ChangedNumericRange(\"\n        + \"oldMinimumValue=\"\n        + oldMinimumValue\n        + \", newMinimumValue=\"\n        + newMinimumValue\n        + \", oldMaximumValue=\"\n        + oldMaximumValue\n        + \", newMaximumValue=\"\n        + newMaximumValue\n        + \", oldMinimumExclusiveValue=\"\n        + oldMinimumExclusiveValue\n        + \", newMinimumExclusiveValue=\"\n        + newMinimumExclusiveValue\n        + \", oldMaximumExclusiveValue=\"\n        + oldMaximumExclusiveValue\n        + \", newMaximumExclusiveValue=\"\n        + newMaximumExclusiveValue\n        + \", context=\"\n        + context\n        + ')';\n  }\n}", "definition": "public final class ChangedNumericRange implements Changed", "class_docstring": "", "name": "ChangedNumericRange", "super_interfaces": ["Changed"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final BigDecimal oldMinimumValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BigDecimal", "name": "oldMinimumValue", "syntax_pass": true}, {"attribute_expression": "private final BigDecimal newMinimumValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BigDecimal", "name": "newMinimumValue", "syntax_pass": true}, {"attribute_expression": "private final BigDecimal oldMaximumValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BigDecimal", "name": "oldMaximumValue", "syntax_pass": true}, {"attribute_expression": "private final BigDecimal newMaximumValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BigDecimal", "name": "newMaximumValue", "syntax_pass": true}, {"attribute_expression": "private final Boolean oldMinimumExclusiveValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Boolean", "name": "oldMinimumExclusiveValue", "syntax_pass": true}, {"attribute_expression": "private final Boolean newMinimumExclusiveValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Boolean", "name": "newMinimumExclusiveValue", "syntax_pass": true}, {"attribute_expression": "private final Boolean oldMaximumExclusiveValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Boolean", "name": "oldMaximumExclusiveValue", "syntax_pass": true}, {"attribute_expression": "private final Boolean newMaximumExclusiveValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Boolean", "name": "newMaximumExclusiveValue", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldMinimumValue, newMinimumValue)\n        && Objects.equals(oldMaximumValue, newMaximumValue)\n        && Objects.equals(oldMinimumExclusiveValue, newMinimumExclusiveValue)\n        && Objects.equals(oldMaximumExclusiveValue, newMaximumExclusiveValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    if ((context.isRequest() && !REQUEST_NUMERIC_RANGE_DECREASED.enabled(context))\n        || (context.isResponse() && !RESPONSE_NUMERIC_RANGE_INCREASED.enabled(context))) {\n      return DiffResult.COMPATIBLE;\n    }\n\n    boolean exclusiveMaxOld = oldMaximumExclusiveValue != null && oldMaximumExclusiveValue;\n    boolean exclusiveMinOld = oldMinimumExclusiveValue != null && oldMinimumExclusiveValue;\n    boolean exclusiveMaxNew = newMaximumExclusiveValue != null && newMaximumExclusiveValue;\n    boolean exclusiveMinNew = newMinimumExclusiveValue != null && newMinimumExclusiveValue;\n    int diffMax = compare(oldMaximumValue, newMaximumValue, false);\n    int diffMin = compare(oldMinimumValue, newMinimumValue, true);\n\n    if (context.isRequest()) {\n      if (diffMax > 0 || (diffMax == 0 && !exclusiveMaxOld && exclusiveMaxNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (diffMin < 0 || (diffMin == 0 && !exclusiveMinOld && exclusiveMinNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    } else if (context.isResponse()) {\n      if (diffMax < 0 || (diffMax == 0 && exclusiveMaxOld && !exclusiveMaxNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (diffMin > 0 || (diffMin == 0 && exclusiveMinOld && !exclusiveMinNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isChanged", "params": [], "body": "                                {\n    if (Objects.equals(oldMinimumValue, newMinimumValue)\n        && Objects.equals(oldMaximumValue, newMaximumValue)\n        && Objects.equals(oldMinimumExclusiveValue, newMinimumExclusiveValue)\n        && Objects.equals(oldMaximumExclusiveValue, newMaximumExclusiveValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n\n    if ((context.isRequest() && !REQUEST_NUMERIC_RANGE_DECREASED.enabled(context))\n        || (context.isResponse() && !RESPONSE_NUMERIC_RANGE_INCREASED.enabled(context))) {\n      return DiffResult.COMPATIBLE;\n    }\n\n    boolean exclusiveMaxOld = oldMaximumExclusiveValue != null && oldMaximumExclusiveValue;\n    boolean exclusiveMinOld = oldMinimumExclusiveValue != null && oldMinimumExclusiveValue;\n    boolean exclusiveMaxNew = newMaximumExclusiveValue != null && newMaximumExclusiveValue;\n    boolean exclusiveMinNew = newMinimumExclusiveValue != null && newMinimumExclusiveValue;\n    int diffMax = compare(oldMaximumValue, newMaximumValue, false);\n    int diffMin = compare(oldMinimumValue, newMinimumValue, true);\n\n    if (context.isRequest()) {\n      if (diffMax > 0 || (diffMax == 0 && !exclusiveMaxOld && exclusiveMaxNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (diffMin < 0 || (diffMin == 0 && !exclusiveMinOld && exclusiveMinNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    } else if (context.isResponse()) {\n      if (diffMax < 0 || (diffMax == 0 && exclusiveMaxOld && !exclusiveMaxNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n      if (diffMin > 0 || (diffMin == 0 && exclusiveMinOld && !exclusiveMinNew)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isChanged()"}, {"syntax_pass": true, "original_string": "  private int compare(BigDecimal left, BigDecimal right, boolean nullMeansLessThan) {\n    if (left == null && right == null) {\n      return 0;\n    }\n    if (left == null) {\n      return nullMeansLessThan ? -1 : 1;\n    }\n    if (right == null) {\n      return nullMeansLessThan ? 1 : -1;\n    }\n    return left.unscaledValue().compareTo(right.unscaledValue());\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "left", "type": "BigDecimal"}, {"name": "right", "type": "BigDecimal"}, {"name": "nullMeansLessThan", "type": "boolean"}], "body": "                                                                                    {\n    if (left == null && right == null) {\n      return 0;\n    }\n    if (left == null) {\n      return nullMeansLessThan ? -1 : 1;\n    }\n    if (right == null) {\n      return nullMeansLessThan ? 1 : -1;\n    }\n    return left.unscaledValue().compareTo(right.unscaledValue());\n  }", "signature": "private int compare(BigDecimal left, BigDecimal right, boolean nullMeansLessThan)"}, {"syntax_pass": true, "original_string": "  public ChangedNumericRange(\n      final BigDecimal oldMinimumValue,\n      final BigDecimal newMinimumValue,\n      final BigDecimal oldMaximumValue,\n      final BigDecimal newMaximumValue,\n      final Boolean oldMinimumExclusiveValue,\n      final Boolean newMinimumExclusiveValue,\n      final Boolean oldMaximumExclusiveValue,\n      final Boolean newMaximumExclusiveValue,\n      final DiffContext context) {\n    this.oldMinimumValue = oldMinimumValue;\n    this.newMinimumValue = newMinimumValue;\n    this.oldMaximumValue = oldMaximumValue;\n    this.newMaximumValue = newMaximumValue;\n    this.oldMinimumExclusiveValue = oldMinimumExclusiveValue;\n    this.newMinimumExclusiveValue = newMinimumExclusiveValue;\n    this.oldMaximumExclusiveValue = oldMaximumExclusiveValue;\n    this.newMaximumExclusiveValue = newMaximumExclusiveValue;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedNumericRange", "params": [{"name": "oldMinimumValue", "type": "BigDecimal"}, {"name": "newMinimumValue", "type": "BigDecimal"}, {"name": "oldMaximumValue", "type": "BigDecimal"}, {"name": "newMaximumValue", "type": "BigDecimal"}, {"name": "oldMinimumExclusiveValue", "type": "Boolean"}, {"name": "newMinimumExclusiveValue", "type": "Boolean"}, {"name": "oldMaximumExclusiveValue", "type": "Boolean"}, {"name": "newMaximumExclusiveValue", "type": "Boolean"}, {"name": "context", "type": "DiffContext"}], "body": "                                 {\n    this.oldMinimumValue = oldMinimumValue;\n    this.newMinimumValue = newMinimumValue;\n    this.oldMaximumValue = oldMaximumValue;\n    this.newMaximumValue = newMaximumValue;\n    this.oldMinimumExclusiveValue = oldMinimumExclusiveValue;\n    this.newMinimumExclusiveValue = newMinimumExclusiveValue;\n    this.oldMaximumExclusiveValue = oldMaximumExclusiveValue;\n    this.newMaximumExclusiveValue = newMaximumExclusiveValue;\n    this.context = context;\n  }", "signature": "public ChangedNumericRange(\n      final BigDecimal oldMinimumValue,\n      final BigDecimal newMinimumValue,\n      final BigDecimal oldMaximumValue,\n      final BigDecimal newMaximumValue,\n      final Boolean oldMinimumExclusiveValue,\n      final Boolean newMinimumExclusiveValue,\n      final Boolean oldMaximumExclusiveValue,\n      final Boolean newMaximumExclusiveValue,\n      final DiffContext context)"}, {"syntax_pass": true, "original_string": "  public BigDecimal getOldMinimumValue() {\n    return oldMinimumValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "getOldMinimumValue", "params": [], "body": "                                         {\n    return oldMinimumValue;\n  }", "signature": "public BigDecimal getOldMinimumValue()"}, {"syntax_pass": true, "original_string": "  public BigDecimal getNewMinimumValue() {\n    return newMinimumValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "getNewMinimumValue", "params": [], "body": "                                         {\n    return newMinimumValue;\n  }", "signature": "public BigDecimal getNewMinimumValue()"}, {"syntax_pass": true, "original_string": "  public BigDecimal getOldMaximumValue() {\n    return oldMaximumValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "getOldMaximumValue", "params": [], "body": "                                         {\n    return oldMaximumValue;\n  }", "signature": "public BigDecimal getOldMaximumValue()"}, {"syntax_pass": true, "original_string": "  public BigDecimal getNewMaximumValue() {\n    return newMaximumValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "getNewMaximumValue", "params": [], "body": "                                         {\n    return newMaximumValue;\n  }", "signature": "public BigDecimal getNewMaximumValue()"}, {"syntax_pass": true, "original_string": "  public Boolean getOldMinimumExclusiveValue() {\n    return oldMinimumExclusiveValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Boolean", "classes": []}, "name": "getOldMinimumExclusiveValue", "params": [], "body": "                                               {\n    return oldMinimumExclusiveValue;\n  }", "signature": "public Boolean getOldMinimumExclusiveValue()"}, {"syntax_pass": true, "original_string": "  public Boolean getNewMinimumExclusiveValue() {\n    return newMinimumExclusiveValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Boolean", "classes": []}, "name": "getNewMinimumExclusiveValue", "params": [], "body": "                                               {\n    return newMinimumExclusiveValue;\n  }", "signature": "public Boolean getNewMinimumExclusiveValue()"}, {"syntax_pass": true, "original_string": "  public Boolean getOldMaximumExclusiveValue() {\n    return oldMaximumExclusiveValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Boolean", "classes": []}, "name": "getOldMaximumExclusiveValue", "params": [], "body": "                                               {\n    return oldMaximumExclusiveValue;\n  }", "signature": "public Boolean getOldMaximumExclusiveValue()"}, {"syntax_pass": true, "original_string": "  public Boolean getNewMaximumExclusiveValue() {\n    return newMaximumExclusiveValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Boolean", "classes": []}, "name": "getNewMaximumExclusiveValue", "params": [], "body": "                                               {\n    return newMaximumExclusiveValue;\n  }", "signature": "public Boolean getNewMaximumExclusiveValue()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedNumericRange that = (ChangedNumericRange) o;\n    return Objects.equals(oldMinimumValue, newMinimumValue)\n        && Objects.equals(oldMaximumValue, newMaximumValue)\n        && Objects.equals(oldMinimumExclusiveValue, newMinimumExclusiveValue)\n        && Objects.equals(oldMaximumExclusiveValue, newMaximumExclusiveValue)\n        && Objects.equals(context, that.context);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedNumericRange that = (ChangedNumericRange) o;\n    return Objects.equals(oldMinimumValue, newMinimumValue)\n        && Objects.equals(oldMaximumValue, newMaximumValue)\n        && Objects.equals(oldMinimumExclusiveValue, newMinimumExclusiveValue)\n        && Objects.equals(oldMaximumExclusiveValue, newMaximumExclusiveValue)\n        && Objects.equals(context, that.context);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(\n        oldMinimumValue,\n        newMinimumValue,\n        oldMaximumValue,\n        newMaximumValue,\n        oldMinimumExclusiveValue,\n        newMinimumExclusiveValue,\n        oldMaximumExclusiveValue,\n        newMaximumExclusiveValue,\n        context);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(\n        oldMinimumValue,\n        newMinimumValue,\n        oldMaximumValue,\n        newMaximumValue,\n        oldMinimumExclusiveValue,\n        newMinimumExclusiveValue,\n        oldMaximumExclusiveValue,\n        newMaximumExclusiveValue,\n        context);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @Override\n  public String toString() {\n    return \"ChangedNumericRange(\"\n        + \"oldMinimumValue=\"\n        + oldMinimumValue\n        + \", newMinimumValue=\"\n        + newMinimumValue\n        + \", oldMaximumValue=\"\n        + oldMaximumValue\n        + \", newMaximumValue=\"\n        + newMaximumValue\n        + \", oldMinimumExclusiveValue=\"\n        + oldMinimumExclusiveValue\n        + \", newMinimumExclusiveValue=\"\n        + newMinimumExclusiveValue\n        + \", oldMaximumExclusiveValue=\"\n        + oldMaximumExclusiveValue\n        + \", newMaximumExclusiveValue=\"\n        + newMaximumExclusiveValue\n        + \", context=\"\n        + context\n        + ')';\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                           {\n    return \"ChangedNumericRange(\"\n        + \"oldMinimumValue=\"\n        + oldMinimumValue\n        + \", newMinimumValue=\"\n        + newMinimumValue\n        + \", oldMaximumValue=\"\n        + oldMaximumValue\n        + \", newMaximumValue=\"\n        + newMaximumValue\n        + \", oldMinimumExclusiveValue=\"\n        + oldMinimumExclusiveValue\n        + \", newMinimumExclusiveValue=\"\n        + newMinimumExclusiveValue\n        + \", oldMaximumExclusiveValue=\"\n        + oldMaximumExclusiveValue\n        + \", newMaximumExclusiveValue=\"\n        + newMaximumExclusiveValue\n        + \", context=\"\n        + context\n        + ')';\n  }", "signature": "@Override\n  public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/schema/ChangedEnum.java", "original_string": "package org.openapitools.openapidiff.core.model.schema;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_ENUM_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_ENUM_INCREASED;\n\nimport java.util.List;\nimport org.openapitools.openapidiff.core.model.ChangedList;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.DiffResult;\n\npublic class ChangedEnum<T> extends ChangedList<T> {\n\n  public ChangedEnum(List<T> oldValue, List<T> newValue, DiffContext context) {\n    super(oldValue, newValue, context);\n  }\n\n  @Override\n  public DiffResult isItemsChanged() {\n    if (context.isRequest() && !getMissing().isEmpty()) {\n      if (REQUEST_ENUM_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !getIncreased().isEmpty()) {\n      if (RESPONSE_ENUM_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n}\n", "file_hash": "23c9441c6612297c369128a0623959faaf057a5dd02d813b49b55dc50f999dae", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.schema;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_ENUM_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_ENUM_INCREASED;", "import java.util.List;", "import org.openapitools.openapidiff.core.model.ChangedList;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.DiffResult;"], "methods": [], "classes": [{"original_string": "public class ChangedEnum<T> extends ChangedList<T> {\n\n  public ChangedEnum(List<T> oldValue, List<T> newValue, DiffContext context) {\n    super(oldValue, newValue, context);\n  }\n\n  @Override\n  public DiffResult isItemsChanged() {\n    if (context.isRequest() && !getMissing().isEmpty()) {\n      if (REQUEST_ENUM_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !getIncreased().isEmpty()) {\n      if (RESPONSE_ENUM_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n}", "definition": "public class ChangedEnum<T> extends ChangedList<T>", "class_docstring": "", "name": "ChangedEnum", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedEnum(List<T> oldValue, List<T> newValue, DiffContext context) {\n    super(oldValue, newValue, context);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedEnum", "params": [{"name": "oldValue", "type": "List<T>"}, {"name": "newValue", "type": "List<T>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                              {\n    super(oldValue, newValue, context);\n  }", "signature": "public ChangedEnum(List<T> oldValue, List<T> newValue, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isItemsChanged() {\n    if (context.isRequest() && !getMissing().isEmpty()) {\n      if (REQUEST_ENUM_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !getIncreased().isEmpty()) {\n      if (RESPONSE_ENUM_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isItemsChanged", "params": [], "body": "                                     {\n    if (context.isRequest() && !getMissing().isEmpty()) {\n      if (REQUEST_ENUM_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !getIncreased().isEmpty()) {\n      if (RESPONSE_ENUM_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isItemsChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/schema/ChangedRequired.java", "original_string": "package org.openapitools.openapidiff.core.model.schema;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_REQUIRED_INCREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_REQUIRED_DECREASED;\n\nimport java.util.List;\nimport org.openapitools.openapidiff.core.model.ChangedList;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.DiffResult;\n\npublic class ChangedRequired extends ChangedList<String> {\n\n  public ChangedRequired(List<String> oldValue, List<String> newValue, DiffContext context) {\n    super(oldValue, newValue, context);\n  }\n\n  @Override\n  public DiffResult isItemsChanged() {\n    if (context.isRequest() && !getIncreased().isEmpty()) {\n      if (REQUEST_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !getMissing().isEmpty()) {\n      if (RESPONSE_REQUIRED_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n}\n", "file_hash": "90947428d25da3bfe766e6b02ecc46a90925887d88a0cbc25e2d9d49fd2de138", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.schema;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_REQUIRED_INCREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_REQUIRED_DECREASED;", "import java.util.List;", "import org.openapitools.openapidiff.core.model.ChangedList;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.DiffResult;"], "methods": [], "classes": [{"original_string": "public class ChangedRequired extends ChangedList<String> {\n\n  public ChangedRequired(List<String> oldValue, List<String> newValue, DiffContext context) {\n    super(oldValue, newValue, context);\n  }\n\n  @Override\n  public DiffResult isItemsChanged() {\n    if (context.isRequest() && !getIncreased().isEmpty()) {\n      if (REQUEST_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !getMissing().isEmpty()) {\n      if (RESPONSE_REQUIRED_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n}", "definition": "public class ChangedRequired extends ChangedList<String>", "class_docstring": "", "name": "ChangedRequired", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ChangedRequired(List<String> oldValue, List<String> newValue, DiffContext context) {\n    super(oldValue, newValue, context);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedRequired", "params": [{"name": "oldValue", "type": "List<String>"}, {"name": "newValue", "type": "List<String>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                            {\n    super(oldValue, newValue, context);\n  }", "signature": "public ChangedRequired(List<String> oldValue, List<String> newValue, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isItemsChanged() {\n    if (context.isRequest() && !getIncreased().isEmpty()) {\n      if (REQUEST_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !getMissing().isEmpty()) {\n      if (RESPONSE_REQUIRED_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isItemsChanged", "params": [], "body": "                                     {\n    if (context.isRequest() && !getIncreased().isEmpty()) {\n      if (REQUEST_REQUIRED_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && !getMissing().isEmpty()) {\n      if (RESPONSE_REQUIRED_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isItemsChanged()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/model/schema/ChangedMaxLength.java", "original_string": "package org.openapitools.openapidiff.core.model.schema;\n\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_MAX_LENGTH_DECREASED;\nimport static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_MAX_LENGTH_INCREASED;\n\nimport java.util.Objects;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.DiffResult;\n\npublic final class ChangedMaxLength implements Changed {\n  private final Integer oldValue;\n  private final Integer newValue;\n  private final DiffContext context;\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest() && (oldValue == null || newValue != null && newValue < oldValue)) {\n      if (REQUEST_MAX_LENGTH_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && (newValue == null || oldValue != null && newValue > oldValue)) {\n      if (RESPONSE_MAX_LENGTH_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public ChangedMaxLength(\n      final Integer oldValue, final Integer newValue, final DiffContext context) {\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.context = context;\n  }\n\n  public Integer getOldValue() {\n    return this.oldValue;\n  }\n\n  public Integer getNewValue() {\n    return this.newValue;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMaxLength that = (ChangedMaxLength) o;\n    return Objects.equals(oldValue, that.oldValue)\n        && Objects.equals(newValue, that.newValue)\n        && Objects.equals(context, that.context);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldValue, newValue, context);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedMaxLength(oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", context=\"\n        + this.getContext()\n        + \")\";\n  }\n}\n", "file_hash": "f514303dedfa255b99e79a6e9f180a88eeb5f0fb7278e4e376688e87151227a1", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.model.schema;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.REQUEST_MAX_LENGTH_DECREASED;", "import static org.openapitools.openapidiff.core.model.BackwardIncompatibleProp.RESPONSE_MAX_LENGTH_INCREASED;", "import java.util.Objects;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.DiffResult;"], "methods": [], "classes": [{"original_string": "public final class ChangedMaxLength implements Changed {\n  private final Integer oldValue;\n  private final Integer newValue;\n  private final DiffContext context;\n\n  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest() && (oldValue == null || newValue != null && newValue < oldValue)) {\n      if (REQUEST_MAX_LENGTH_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && (newValue == null || oldValue != null && newValue > oldValue)) {\n      if (RESPONSE_MAX_LENGTH_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }\n\n  public ChangedMaxLength(\n      final Integer oldValue, final Integer newValue, final DiffContext context) {\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.context = context;\n  }\n\n  public Integer getOldValue() {\n    return this.oldValue;\n  }\n\n  public Integer getNewValue() {\n    return this.newValue;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMaxLength that = (ChangedMaxLength) o;\n    return Objects.equals(oldValue, that.oldValue)\n        && Objects.equals(newValue, that.newValue)\n        && Objects.equals(context, that.context);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(oldValue, newValue, context);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedMaxLength(oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", context=\"\n        + this.getContext()\n        + \")\";\n  }\n}", "definition": "public final class ChangedMaxLength implements Changed", "class_docstring": "", "name": "ChangedMaxLength", "super_interfaces": ["Changed"], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final Integer oldValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "oldValue", "syntax_pass": true}, {"attribute_expression": "private final Integer newValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "newValue", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  @Override\n  public DiffResult isChanged() {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest() && (oldValue == null || newValue != null && newValue < oldValue)) {\n      if (REQUEST_MAX_LENGTH_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && (newValue == null || oldValue != null && newValue > oldValue)) {\n      if (RESPONSE_MAX_LENGTH_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffResult", "classes": []}, "name": "isChanged", "params": [], "body": "                                {\n    if (Objects.equals(oldValue, newValue)) {\n      return DiffResult.NO_CHANGES;\n    }\n    if (context.isRequest() && (oldValue == null || newValue != null && newValue < oldValue)) {\n      if (REQUEST_MAX_LENGTH_DECREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    if (context.isResponse() && (newValue == null || oldValue != null && newValue > oldValue)) {\n      if (RESPONSE_MAX_LENGTH_INCREASED.enabled(context)) {\n        return DiffResult.INCOMPATIBLE;\n      }\n    }\n    return DiffResult.COMPATIBLE;\n  }", "signature": "@Override\n  public DiffResult isChanged()"}, {"syntax_pass": true, "original_string": "  public ChangedMaxLength(\n      final Integer oldValue, final Integer newValue, final DiffContext context) {\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChangedMaxLength", "params": [{"name": "oldValue", "type": "Integer"}, {"name": "newValue", "type": "Integer"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                 {\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.context = context;\n  }", "signature": "public ChangedMaxLength(\n      final Integer oldValue, final Integer newValue, final DiffContext context)"}, {"syntax_pass": true, "original_string": "  public Integer getOldValue() {\n    return this.oldValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getOldValue", "params": [], "body": "                               {\n    return this.oldValue;\n  }", "signature": "public Integer getOldValue()"}, {"syntax_pass": true, "original_string": "  public Integer getNewValue() {\n    return this.newValue;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getNewValue", "params": [], "body": "                               {\n    return this.newValue;\n  }", "signature": "public Integer getNewValue()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMaxLength that = (ChangedMaxLength) o;\n    return Objects.equals(oldValue, that.oldValue)\n        && Objects.equals(newValue, that.newValue)\n        && Objects.equals(context, that.context);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ChangedMaxLength that = (ChangedMaxLength) o;\n    return Objects.equals(oldValue, that.oldValue)\n        && Objects.equals(newValue, that.newValue)\n        && Objects.equals(context, that.context);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(oldValue, newValue, context);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(oldValue, newValue, context);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"ChangedMaxLength(oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", context=\"\n        + this.getContext()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"ChangedMaxLength(oldValue=\"\n        + this.getOldValue()\n        + \", newValue=\"\n        + this.getNewValue()\n        + \", context=\"\n        + this.getContext()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/SecurityDiffInfo.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.security.SecurityRequirement;\nimport io.swagger.v3.oas.models.security.SecurityScheme;\nimport java.util.List;\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.ChangedList;\n\npublic class SecurityDiffInfo {\n  private String ref;\n  private SecurityScheme securityScheme;\n  private List<String> scopes;\n\n  public SecurityDiffInfo(\n      final String ref, final SecurityScheme securityScheme, final List<String> scopes) {\n    this.ref = ref;\n    this.securityScheme = securityScheme;\n    this.scopes = scopes;\n  }\n\n  public static SecurityRequirement getSecurityRequirement(\n      List<SecurityDiffInfo> securityDiffInfoList) {\n    SecurityRequirement securityRequirement = new SecurityRequirement();\n    for (SecurityDiffInfo securityDiffInfo : securityDiffInfoList) {\n      securityRequirement.put(securityDiffInfo.getRef(), securityDiffInfo.getScopes());\n    }\n    return securityRequirement;\n  }\n\n  public static Optional<List<SecurityDiffInfo>> containsList(\n      List<List<SecurityDiffInfo>> securityRequirements, List<SecurityDiffInfo> leftSecurities) {\n    return securityRequirements.stream()\n        .filter(rightSecurities -> sameList(leftSecurities, rightSecurities))\n        .findFirst();\n  }\n\n  public static boolean sameList(\n      List<SecurityDiffInfo> leftSecurities, List<SecurityDiffInfo> rightSecurities) {\n    return ListDiff.diff(new ChangedList.SimpleChangedList<>(leftSecurities, rightSecurities))\n        .isUnchanged();\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    SecurityDiffInfo that = (SecurityDiffInfo) o;\n    if (securityScheme != null\n        ? !securityScheme.equals(that.securityScheme)\n        : that.securityScheme != null) {\n      return false;\n    }\n    return scopes != null ? scopes.equals(that.scopes) : that.scopes == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = securityScheme != null ? securityScheme.hashCode() : 0;\n    result = 31 * result + (scopes != null ? scopes.hashCode() : 0);\n    return result;\n  }\n\n  public String getRef() {\n    return this.ref;\n  }\n\n  public SecurityScheme getSecurityScheme() {\n    return this.securityScheme;\n  }\n\n  public List<String> getScopes() {\n    return this.scopes;\n  }\n\n  public void setRef(final String ref) {\n    this.ref = ref;\n  }\n\n  public void setSecurityScheme(final SecurityScheme securityScheme) {\n    this.securityScheme = securityScheme;\n  }\n\n  public void setScopes(final List<String> scopes) {\n    this.scopes = scopes;\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"SecurityDiffInfo(ref=\"\n        + this.getRef()\n        + \", securityScheme=\"\n        + this.getSecurityScheme()\n        + \", scopes=\"\n        + this.getScopes()\n        + \")\";\n  }\n}\n", "file_hash": "7c3b48de6b549f62022c924700917707790bf0ea21f069ca26100b2ce67e49dc", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.security.SecurityRequirement;", "import io.swagger.v3.oas.models.security.SecurityScheme;", "import java.util.List;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.ChangedList;"], "methods": [], "classes": [{"original_string": "public class SecurityDiffInfo {\n  private String ref;\n  private SecurityScheme securityScheme;\n  private List<String> scopes;\n\n  public SecurityDiffInfo(\n      final String ref, final SecurityScheme securityScheme, final List<String> scopes) {\n    this.ref = ref;\n    this.securityScheme = securityScheme;\n    this.scopes = scopes;\n  }\n\n  public static SecurityRequirement getSecurityRequirement(\n      List<SecurityDiffInfo> securityDiffInfoList) {\n    SecurityRequirement securityRequirement = new SecurityRequirement();\n    for (SecurityDiffInfo securityDiffInfo : securityDiffInfoList) {\n      securityRequirement.put(securityDiffInfo.getRef(), securityDiffInfo.getScopes());\n    }\n    return securityRequirement;\n  }\n\n  public static Optional<List<SecurityDiffInfo>> containsList(\n      List<List<SecurityDiffInfo>> securityRequirements, List<SecurityDiffInfo> leftSecurities) {\n    return securityRequirements.stream()\n        .filter(rightSecurities -> sameList(leftSecurities, rightSecurities))\n        .findFirst();\n  }\n\n  public static boolean sameList(\n      List<SecurityDiffInfo> leftSecurities, List<SecurityDiffInfo> rightSecurities) {\n    return ListDiff.diff(new ChangedList.SimpleChangedList<>(leftSecurities, rightSecurities))\n        .isUnchanged();\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    SecurityDiffInfo that = (SecurityDiffInfo) o;\n    if (securityScheme != null\n        ? !securityScheme.equals(that.securityScheme)\n        : that.securityScheme != null) {\n      return false;\n    }\n    return scopes != null ? scopes.equals(that.scopes) : that.scopes == null;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = securityScheme != null ? securityScheme.hashCode() : 0;\n    result = 31 * result + (scopes != null ? scopes.hashCode() : 0);\n    return result;\n  }\n\n  public String getRef() {\n    return this.ref;\n  }\n\n  public SecurityScheme getSecurityScheme() {\n    return this.securityScheme;\n  }\n\n  public List<String> getScopes() {\n    return this.scopes;\n  }\n\n  public void setRef(final String ref) {\n    this.ref = ref;\n  }\n\n  public void setSecurityScheme(final SecurityScheme securityScheme) {\n    this.securityScheme = securityScheme;\n  }\n\n  public void setScopes(final List<String> scopes) {\n    this.scopes = scopes;\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"SecurityDiffInfo(ref=\"\n        + this.getRef()\n        + \", securityScheme=\"\n        + this.getSecurityScheme()\n        + \", scopes=\"\n        + this.getScopes()\n        + \")\";\n  }\n}", "definition": "public class SecurityDiffInfo", "class_docstring": "", "name": "SecurityDiffInfo", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private String ref;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "ref", "syntax_pass": true}, {"attribute_expression": "private SecurityScheme securityScheme;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecurityScheme", "name": "securityScheme", "syntax_pass": true}, {"attribute_expression": "private List<String> scopes;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "scopes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public SecurityDiffInfo(\n      final String ref, final SecurityScheme securityScheme, final List<String> scopes) {\n    this.ref = ref;\n    this.securityScheme = securityScheme;\n    this.scopes = scopes;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SecurityDiffInfo", "params": [{"name": "ref", "type": "String"}, {"name": "securityScheme", "type": "SecurityScheme"}, {"name": "scopes", "type": "List<String>"}], "body": "                                                                                        {\n    this.ref = ref;\n    this.securityScheme = securityScheme;\n    this.scopes = scopes;\n  }", "signature": "public SecurityDiffInfo(\n      final String ref, final SecurityScheme securityScheme, final List<String> scopes)"}, {"syntax_pass": true, "original_string": "  public static SecurityRequirement getSecurityRequirement(\n      List<SecurityDiffInfo> securityDiffInfoList) {\n    SecurityRequirement securityRequirement = new SecurityRequirement();\n    for (SecurityDiffInfo securityDiffInfo : securityDiffInfoList) {\n      securityRequirement.put(securityDiffInfo.getRef(), securityDiffInfo.getScopes());\n    }\n    return securityRequirement;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SecurityRequirement", "classes": []}, "name": "getSecurityRequirement", "params": [{"name": "securityDiffInfoList", "type": "List<SecurityDiffInfo>"}], "body": "                                                   {\n    SecurityRequirement securityRequirement = new SecurityRequirement();\n    for (SecurityDiffInfo securityDiffInfo : securityDiffInfoList) {\n      securityRequirement.put(securityDiffInfo.getRef(), securityDiffInfo.getScopes());\n    }\n    return securityRequirement;\n  }", "signature": "public static SecurityRequirement getSecurityRequirement(\n      List<SecurityDiffInfo> securityDiffInfoList)"}, {"syntax_pass": true, "original_string": "  public static Optional<List<SecurityDiffInfo>> containsList(\n      List<List<SecurityDiffInfo>> securityRequirements, List<SecurityDiffInfo> leftSecurities) {\n    return securityRequirements.stream()\n        .filter(rightSecurities -> sameList(leftSecurities, rightSecurities))\n        .findFirst();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Optional<List<SecurityDiffInfo>>", "classes": []}, "name": "containsList", "params": [{"name": "securityRequirements", "type": "List<List<SecurityDiffInfo>>"}, {"name": "leftSecurities", "type": "List<SecurityDiffInfo>"}], "body": "                                                                                                {\n    return securityRequirements.stream()\n        .filter(rightSecurities -> sameList(leftSecurities, rightSecurities))\n        .findFirst();\n  }", "signature": "public static Optional<List<SecurityDiffInfo>> containsList(\n      List<List<SecurityDiffInfo>> securityRequirements, List<SecurityDiffInfo> leftSecurities)"}, {"syntax_pass": true, "original_string": "  public static boolean sameList(\n      List<SecurityDiffInfo> leftSecurities, List<SecurityDiffInfo> rightSecurities) {\n    return ListDiff.diff(new ChangedList.SimpleChangedList<>(leftSecurities, rightSecurities))\n        .isUnchanged();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "sameList", "params": [{"name": "leftSecurities", "type": "List<SecurityDiffInfo>"}, {"name": "rightSecurities", "type": "List<SecurityDiffInfo>"}], "body": "                                                                                     {\n    return ListDiff.diff(new ChangedList.SimpleChangedList<>(leftSecurities, rightSecurities))\n        .isUnchanged();\n  }", "signature": "public static boolean sameList(\n      List<SecurityDiffInfo> leftSecurities, List<SecurityDiffInfo> rightSecurities)"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    SecurityDiffInfo that = (SecurityDiffInfo) o;\n    if (securityScheme != null\n        ? !securityScheme.equals(that.securityScheme)\n        : that.securityScheme != null) {\n      return false;\n    }\n    return scopes != null ? scopes.equals(that.scopes) : that.scopes == null;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    SecurityDiffInfo that = (SecurityDiffInfo) o;\n    if (securityScheme != null\n        ? !securityScheme.equals(that.securityScheme)\n        : that.securityScheme != null) {\n      return false;\n    }\n    return scopes != null ? scopes.equals(that.scopes) : that.scopes == null;\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    int result = securityScheme != null ? securityScheme.hashCode() : 0;\n    result = 31 * result + (scopes != null ? scopes.hashCode() : 0);\n    return result;\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    int result = securityScheme != null ? securityScheme.hashCode() : 0;\n    result = 31 * result + (scopes != null ? scopes.hashCode() : 0);\n    return result;\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  public String getRef() {\n    return this.ref;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getRef", "params": [], "body": "                         {\n    return this.ref;\n  }", "signature": "public String getRef()"}, {"syntax_pass": true, "original_string": "  public SecurityScheme getSecurityScheme() {\n    return this.securityScheme;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecurityScheme", "classes": []}, "name": "getSecurityScheme", "params": [], "body": "                                            {\n    return this.securityScheme;\n  }", "signature": "public SecurityScheme getSecurityScheme()"}, {"syntax_pass": true, "original_string": "  public List<String> getScopes() {\n    return this.scopes;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getScopes", "params": [], "body": "                                  {\n    return this.scopes;\n  }", "signature": "public List<String> getScopes()"}, {"syntax_pass": true, "original_string": "  public void setRef(final String ref) {\n    this.ref = ref;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setRef", "params": [{"name": "ref", "type": "String"}], "body": "                                       {\n    this.ref = ref;\n  }", "signature": "public void setRef(final String ref)"}, {"syntax_pass": true, "original_string": "  public void setSecurityScheme(final SecurityScheme securityScheme) {\n    this.securityScheme = securityScheme;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setSecurityScheme", "params": [{"name": "securityScheme", "type": "SecurityScheme"}], "body": "                                                                     {\n    this.securityScheme = securityScheme;\n  }", "signature": "public void setSecurityScheme(final SecurityScheme securityScheme)"}, {"syntax_pass": true, "original_string": "  public void setScopes(final List<String> scopes) {\n    this.scopes = scopes;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setScopes", "params": [{"name": "scopes", "type": "List<String>"}], "body": "                                                   {\n    this.scopes = scopes;\n  }", "signature": "public void setScopes(final List<String> scopes)"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"SecurityDiffInfo(ref=\"\n        + this.getRef()\n        + \", securityScheme=\"\n        + this.getSecurityScheme()\n        + \", scopes=\"\n        + this.getScopes()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"SecurityDiffInfo(ref=\"\n        + this.getRef()\n        + \", securityScheme=\"\n        + this.getSecurityScheme()\n        + \", scopes=\"\n        + this.getScopes()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/OAuthFlowsDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static java.util.Optional.ofNullable;\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\n\nimport io.swagger.v3.oas.models.security.OAuthFlows;\nimport java.util.Map;\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.ChangedOAuthFlows;\nimport org.openapitools.openapidiff.core.model.DiffContext;\n\npublic class OAuthFlowsDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public OAuthFlowsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  private static Map<String, Object> getExtensions(OAuthFlows oAuthFlow) {\n    return ofNullable(oAuthFlow).map(OAuthFlows::getExtensions).orElse(null);\n  }\n\n  public Optional<ChangedOAuthFlows> diff(OAuthFlows left, OAuthFlows right, DiffContext context) {\n    ChangedOAuthFlows changedOAuthFlows = new ChangedOAuthFlows(left, right);\n    if (left != null && right != null) {\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getImplicit(), right.getImplicit(), context)\n          .ifPresent(changedOAuthFlows::setImplicitOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getPassword(), right.getPassword(), context)\n          .ifPresent(changedOAuthFlows::setPasswordOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getClientCredentials(), right.getClientCredentials(), context)\n          .ifPresent(changedOAuthFlows::setClientCredentialOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getAuthorizationCode(), right.getAuthorizationCode(), context)\n          .ifPresent(changedOAuthFlows::setAuthorizationCodeOAuthFlow);\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(getExtensions(left), getExtensions(right))\n        .ifPresent(changedOAuthFlows::setExtensions);\n    return isChanged(changedOAuthFlows);\n  }\n}\n", "file_hash": "c34469db497371a5a47d0aa47277aafbedb128dea76ad64d5ec3f423bf35293f", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static java.util.Optional.ofNullable;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import io.swagger.v3.oas.models.security.OAuthFlows;", "import java.util.Map;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.ChangedOAuthFlows;", "import org.openapitools.openapidiff.core.model.DiffContext;"], "methods": [], "classes": [{"original_string": "public class OAuthFlowsDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public OAuthFlowsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  private static Map<String, Object> getExtensions(OAuthFlows oAuthFlow) {\n    return ofNullable(oAuthFlow).map(OAuthFlows::getExtensions).orElse(null);\n  }\n\n  public Optional<ChangedOAuthFlows> diff(OAuthFlows left, OAuthFlows right, DiffContext context) {\n    ChangedOAuthFlows changedOAuthFlows = new ChangedOAuthFlows(left, right);\n    if (left != null && right != null) {\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getImplicit(), right.getImplicit(), context)\n          .ifPresent(changedOAuthFlows::setImplicitOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getPassword(), right.getPassword(), context)\n          .ifPresent(changedOAuthFlows::setPasswordOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getClientCredentials(), right.getClientCredentials(), context)\n          .ifPresent(changedOAuthFlows::setClientCredentialOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getAuthorizationCode(), right.getAuthorizationCode(), context)\n          .ifPresent(changedOAuthFlows::setAuthorizationCodeOAuthFlow);\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(getExtensions(left), getExtensions(right))\n        .ifPresent(changedOAuthFlows::setExtensions);\n    return isChanged(changedOAuthFlows);\n  }\n}", "definition": "public class OAuthFlowsDiff", "class_docstring": "", "name": "OAuthFlowsDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public OAuthFlowsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "OAuthFlowsDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                 {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public OAuthFlowsDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  private static Map<String, Object> getExtensions(OAuthFlows oAuthFlow) {\n    return ofNullable(oAuthFlow).map(OAuthFlows::getExtensions).orElse(null);\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "getExtensions", "params": [{"name": "oAuthFlow", "type": "OAuthFlows"}], "body": "                                                                         {\n    return ofNullable(oAuthFlow).map(OAuthFlows::getExtensions).orElse(null);\n  }", "signature": "private static Map<String, Object> getExtensions(OAuthFlows oAuthFlow)"}, {"syntax_pass": true, "original_string": "  public Optional<ChangedOAuthFlows> diff(OAuthFlows left, OAuthFlows right, DiffContext context) {\n    ChangedOAuthFlows changedOAuthFlows = new ChangedOAuthFlows(left, right);\n    if (left != null && right != null) {\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getImplicit(), right.getImplicit(), context)\n          .ifPresent(changedOAuthFlows::setImplicitOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getPassword(), right.getPassword(), context)\n          .ifPresent(changedOAuthFlows::setPasswordOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getClientCredentials(), right.getClientCredentials(), context)\n          .ifPresent(changedOAuthFlows::setClientCredentialOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getAuthorizationCode(), right.getAuthorizationCode(), context)\n          .ifPresent(changedOAuthFlows::setAuthorizationCodeOAuthFlow);\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(getExtensions(left), getExtensions(right))\n        .ifPresent(changedOAuthFlows::setExtensions);\n    return isChanged(changedOAuthFlows);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<ChangedOAuthFlows>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "OAuthFlows"}, {"name": "right", "type": "OAuthFlows"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                                  {\n    ChangedOAuthFlows changedOAuthFlows = new ChangedOAuthFlows(left, right);\n    if (left != null && right != null) {\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getImplicit(), right.getImplicit(), context)\n          .ifPresent(changedOAuthFlows::setImplicitOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getPassword(), right.getPassword(), context)\n          .ifPresent(changedOAuthFlows::setPasswordOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getClientCredentials(), right.getClientCredentials(), context)\n          .ifPresent(changedOAuthFlows::setClientCredentialOAuthFlow);\n      openApiDiff\n          .getOAuthFlowDiff()\n          .diff(left.getAuthorizationCode(), right.getAuthorizationCode(), context)\n          .ifPresent(changedOAuthFlows::setAuthorizationCodeOAuthFlow);\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(getExtensions(left), getExtensions(right))\n        .ifPresent(changedOAuthFlows::setExtensions);\n    return isChanged(changedOAuthFlows);\n  }", "signature": "public Optional<ChangedOAuthFlows> diff(OAuthFlows left, OAuthFlows right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/MapKeyDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\n/** compare two Maps by key */\npublic class MapKeyDiff<K, V> {\n\n  private Map<K, V> increased;\n  private Map<K, V> missing;\n  private final List<K> sharedKey;\n\n  private MapKeyDiff() {\n    this.sharedKey = new ArrayList<>();\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n  }\n\n  public static <K, V> MapKeyDiff<K, V> diff(Map<K, V> mapLeft, Map<K, V> mapRight) {\n    MapKeyDiff<K, V> instance = new MapKeyDiff<>();\n    if (null == mapLeft && null == mapRight) return instance;\n    if (null == mapLeft) {\n      instance.increased = mapRight;\n      return instance;\n    }\n    if (null == mapRight) {\n      instance.missing = mapLeft;\n      return instance;\n    }\n    instance.increased = new LinkedHashMap<>(mapRight);\n    instance.missing = new LinkedHashMap<>();\n    for (Entry<K, V> entry : mapLeft.entrySet()) {\n      K leftKey = entry.getKey();\n      V leftValue = entry.getValue();\n      if (mapRight.containsKey(leftKey)) {\n        instance.increased.remove(leftKey);\n        instance.sharedKey.add(leftKey);\n\n      } else {\n        instance.missing.put(leftKey, leftValue);\n      }\n    }\n    return instance;\n  }\n\n  public Map<K, V> getIncreased() {\n    return increased;\n  }\n\n  public Map<K, V> getMissing() {\n    return missing;\n  }\n\n  public List<K> getSharedKey() {\n    return sharedKey;\n  }\n}\n", "file_hash": "4c3172f09b7a1beedd63e15ff333fb60bcdf862984878bdc2237340a3c9af53e", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import java.util.ArrayList;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Map.Entry;"], "methods": [], "classes": [{"original_string": "public class MapKeyDiff<K, V> {\n\n  private Map<K, V> increased;\n  private Map<K, V> missing;\n  private final List<K> sharedKey;\n\n  private MapKeyDiff() {\n    this.sharedKey = new ArrayList<>();\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n  }\n\n  public static <K, V> MapKeyDiff<K, V> diff(Map<K, V> mapLeft, Map<K, V> mapRight) {\n    MapKeyDiff<K, V> instance = new MapKeyDiff<>();\n    if (null == mapLeft && null == mapRight) return instance;\n    if (null == mapLeft) {\n      instance.increased = mapRight;\n      return instance;\n    }\n    if (null == mapRight) {\n      instance.missing = mapLeft;\n      return instance;\n    }\n    instance.increased = new LinkedHashMap<>(mapRight);\n    instance.missing = new LinkedHashMap<>();\n    for (Entry<K, V> entry : mapLeft.entrySet()) {\n      K leftKey = entry.getKey();\n      V leftValue = entry.getValue();\n      if (mapRight.containsKey(leftKey)) {\n        instance.increased.remove(leftKey);\n        instance.sharedKey.add(leftKey);\n\n      } else {\n        instance.missing.put(leftKey, leftValue);\n      }\n    }\n    return instance;\n  }\n\n  public Map<K, V> getIncreased() {\n    return increased;\n  }\n\n  public Map<K, V> getMissing() {\n    return missing;\n  }\n\n  public List<K> getSharedKey() {\n    return sharedKey;\n  }\n}", "definition": "public class MapKeyDiff<K, V>", "class_docstring": " compare two Maps by key", "name": "MapKeyDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Map<K, V> increased;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<K, V>", "name": "increased", "syntax_pass": true}, {"attribute_expression": "private Map<K, V> missing;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<K, V>", "name": "missing", "syntax_pass": true}, {"attribute_expression": "private final List<K> sharedKey;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<K>", "name": "sharedKey", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private MapKeyDiff() {\n    this.sharedKey = new ArrayList<>();\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "MapKeyDiff", "params": [], "body": "                       {\n    this.sharedKey = new ArrayList<>();\n    this.increased = new LinkedHashMap<>();\n    this.missing = new LinkedHashMap<>();\n  }", "signature": "private MapKeyDiff()"}, {"syntax_pass": true, "original_string": "  public static <K, V> MapKeyDiff<K, V> diff(Map<K, V> mapLeft, Map<K, V> mapRight) {\n    MapKeyDiff<K, V> instance = new MapKeyDiff<>();\n    if (null == mapLeft && null == mapRight) return instance;\n    if (null == mapLeft) {\n      instance.increased = mapRight;\n      return instance;\n    }\n    if (null == mapRight) {\n      instance.missing = mapLeft;\n      return instance;\n    }\n    instance.increased = new LinkedHashMap<>(mapRight);\n    instance.missing = new LinkedHashMap<>();\n    for (Entry<K, V> entry : mapLeft.entrySet()) {\n      K leftKey = entry.getKey();\n      V leftValue = entry.getValue();\n      if (mapRight.containsKey(leftKey)) {\n        instance.increased.remove(leftKey);\n        instance.sharedKey.add(leftKey);\n\n      } else {\n        instance.missing.put(leftKey, leftValue);\n      }\n    }\n    return instance;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "MapKeyDiff<K, V>", "classes": []}, "name": "diff", "params": [{"name": "mapLeft", "type": "Map<K, V>"}, {"name": "mapRight", "type": "Map<K, V>"}], "body": "                                                                                    {\n    MapKeyDiff<K, V> instance = new MapKeyDiff<>();\n    if (null == mapLeft && null == mapRight) return instance;\n    if (null == mapLeft) {\n      instance.increased = mapRight;\n      return instance;\n    }\n    if (null == mapRight) {\n      instance.missing = mapLeft;\n      return instance;\n    }\n    instance.increased = new LinkedHashMap<>(mapRight);\n    instance.missing = new LinkedHashMap<>();\n    for (Entry<K, V> entry : mapLeft.entrySet()) {\n      K leftKey = entry.getKey();\n      V leftValue = entry.getValue();\n      if (mapRight.containsKey(leftKey)) {\n        instance.increased.remove(leftKey);\n        instance.sharedKey.add(leftKey);\n\n      } else {\n        instance.missing.put(leftKey, leftValue);\n      }\n    }\n    return instance;\n  }", "signature": "public static <K, V> MapKeyDiff<K, V> diff(Map<K, V> mapLeft, Map<K, V> mapRight)"}, {"syntax_pass": true, "original_string": "  public Map<K, V> getIncreased() {\n    return increased;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "getIncreased", "params": [], "body": "                                  {\n    return increased;\n  }", "signature": "public Map<K, V> getIncreased()"}, {"syntax_pass": true, "original_string": "  public Map<K, V> getMissing() {\n    return missing;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "getMissing", "params": [], "body": "                                {\n    return missing;\n  }", "signature": "public Map<K, V> getMissing()"}, {"syntax_pass": true, "original_string": "  public List<K> getSharedKey() {\n    return sharedKey;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<K>", "classes": []}, "name": "getSharedKey", "params": [], "body": "                                {\n    return sharedKey;\n  }", "signature": "public List<K> getSharedKey()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/SchemaDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static java.util.Optional.ofNullable;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.ExternalDocumentation;\nimport io.swagger.v3.oas.models.media.ArraySchema;\nimport io.swagger.v3.oas.models.media.ComposedSchema;\nimport io.swagger.v3.oas.models.media.Discriminator;\nimport io.swagger.v3.oas.models.media.Schema;\nimport io.swagger.v3.oas.models.media.XML;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport org.openapitools.openapidiff.core.compare.schemadiffresult.ArraySchemaDiffResult;\nimport org.openapitools.openapidiff.core.compare.schemadiffresult.ComposedSchemaDiffResult;\nimport org.openapitools.openapidiff.core.compare.schemadiffresult.SchemaDiffResult;\nimport org.openapitools.openapidiff.core.model.ChangedSchema;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.model.deferred.RealizedChanged;\nimport org.openapitools.openapidiff.core.model.deferred.RecursiveSchemaSet;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\npublic class SchemaDiff {\n\n  private static final RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  private static final Map<Class<? extends Schema>, Class<? extends SchemaDiffResult>>\n      schemaDiffResultClassMap = new LinkedHashMap<>();\n\n  static {\n    schemaDiffResultClassMap.put(Schema.class, SchemaDiffResult.class);\n    schemaDiffResultClassMap.put(ArraySchema.class, ArraySchemaDiffResult.class);\n    schemaDiffResultClassMap.put(ComposedSchema.class, ComposedSchemaDiffResult.class);\n  }\n\n  private final Components leftComponents;\n  private final Components rightComponents;\n  private final OpenApiDiff openApiDiff;\n\n  public SchemaDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public static SchemaDiffResult getSchemaDiffResult(OpenApiDiff openApiDiff) {\n    return getSchemaDiffResult(null, openApiDiff);\n  }\n\n  public static SchemaDiffResult getSchemaDiffResult(\n      Class<? extends Schema> classType, OpenApiDiff openApiDiff) {\n    if (classType == null) {\n      classType = Schema.class;\n    }\n\n    Class<? extends SchemaDiffResult> aClass = schemaDiffResultClassMap.get(classType);\n    try {\n      if (aClass == null) {\n        aClass = schemaDiffResultClassMap.get(Schema.class);\n      }\n      if (aClass != null) {\n        return aClass.getConstructor(OpenApiDiff.class).newInstance(openApiDiff);\n      } else {\n        throw new IllegalArgumentException(\"invalid classType\");\n      }\n    } catch (Exception e) {\n      throw new IllegalArgumentException(\"type \" + classType + \" is illegal\");\n    }\n  }\n\n  protected static Schema<?> resolveComposedSchema(\n      Components components, Schema<?> schema, Set<String> visitedRefs) {\n    if (schema instanceof ComposedSchema) {\n      ComposedSchema composedSchema = (ComposedSchema) schema;\n      List<Schema> composedSchemas = new ArrayList<>();\n      Optional.ofNullable(composedSchema.getAllOf()).ifPresent(composedSchemas::addAll);\n      Optional.ofNullable(composedSchema.getAnyOf()).ifPresent(composedSchemas::addAll);\n\n      if (!composedSchemas.isEmpty()) {\n        for (Schema<?> composed : composedSchemas) {\n          if (composed.get$ref() == null || !visitedRefs.contains(composed.get$ref())) {\n            Set<String> updatedVisitedRefs = new HashSet<>(visitedRefs);\n            updatedVisitedRefs.add(composed.get$ref());\n            composed = refPointer.resolveRef(components, composed, composed.get$ref());\n            composed = resolveComposedSchema(components, composed, updatedVisitedRefs);\n            schema = addSchema(schema, composed);\n          }\n        }\n        composedSchema.setAllOf(null);\n        composedSchema.setAnyOf(null);\n      }\n    }\n    return schema;\n  }\n\n  protected static Schema<?> addSchema(Schema<?> schema, Schema<?> fromSchema) {\n    if (fromSchema.getProperties() != null) {\n      if (schema.getProperties() == null) {\n        schema.setProperties(new LinkedHashMap<>());\n      }\n      schema.getProperties().putAll(fromSchema.getProperties());\n    }\n\n    if (fromSchema.getRequired() != null) {\n      if (schema.getRequired() == null) {\n        schema.setRequired(fromSchema.getRequired());\n      } else {\n        schema.getRequired().addAll(fromSchema.getRequired());\n      }\n    }\n\n    if (fromSchema.getReadOnly() != null) {\n      schema.setReadOnly(fromSchema.getReadOnly());\n    }\n    if (fromSchema.getWriteOnly() != null) {\n      schema.setWriteOnly(fromSchema.getWriteOnly());\n    }\n    if (fromSchema.getDeprecated() != null) {\n      schema.setDeprecated(fromSchema.getDeprecated());\n    }\n    if (fromSchema.getExclusiveMaximum() != null) {\n      schema.setExclusiveMaximum(fromSchema.getExclusiveMaximum());\n    }\n    if (fromSchema.getExclusiveMinimum() != null) {\n      schema.setExclusiveMinimum(fromSchema.getExclusiveMinimum());\n    }\n    if (fromSchema.getNullable() != null) {\n      schema.setNullable(fromSchema.getNullable());\n    }\n    if (fromSchema.getUniqueItems() != null) {\n      schema.setUniqueItems(fromSchema.getUniqueItems());\n    }\n    if (fromSchema.getDescription() != null) {\n      schema.setDescription(fromSchema.getDescription());\n    }\n    if (fromSchema.getFormat() != null) {\n      schema.setFormat(fromSchema.getFormat());\n    }\n    if (fromSchema.getType() != null) {\n      schema.setType(fromSchema.getType());\n    }\n    if (fromSchema.getEnum() != null) {\n      if (schema.getEnum() == null) {\n        schema.setEnum(new ArrayList<>());\n      }\n      //noinspection unchecked\n      schema.getEnum().addAll((List) fromSchema.getEnum());\n    }\n    if (fromSchema.getExtensions() != null) {\n      if (schema.getExtensions() == null) {\n        schema.setExtensions(new LinkedHashMap<>());\n      }\n      schema.getExtensions().putAll(fromSchema.getExtensions());\n    }\n    if (fromSchema instanceof ComposedSchema && schema instanceof ComposedSchema) {\n      ComposedSchema composedFromSchema = (ComposedSchema) fromSchema;\n      ComposedSchema composedSchema = (ComposedSchema) schema;\n      if (composedFromSchema.getOneOf() != null) {\n        if (composedSchema.getOneOf() == null) {\n          composedSchema.setOneOf(new ArrayList<>());\n        }\n        composedSchema.getOneOf().addAll(composedFromSchema.getOneOf());\n      }\n    }\n    if (fromSchema.getDiscriminator() != null) {\n      if (schema.getDiscriminator() == null) {\n        schema.setDiscriminator(new Discriminator());\n      }\n      final Discriminator discriminator = schema.getDiscriminator();\n      final Discriminator fromDiscriminator = fromSchema.getDiscriminator();\n      if (fromDiscriminator.getPropertyName() != null) {\n        discriminator.setPropertyName(fromDiscriminator.getPropertyName());\n      }\n      if (fromDiscriminator.getMapping() != null) {\n        if (discriminator.getMapping() == null) {\n          discriminator.setMapping(new LinkedHashMap<>());\n        }\n        discriminator.getMapping().putAll(fromDiscriminator.getMapping());\n      }\n    }\n    if (fromSchema.getTitle() != null) {\n      schema.setTitle(fromSchema.getTitle());\n    }\n    if (fromSchema.getName() != null) {\n      schema.setName(fromSchema.getName());\n    }\n    if (fromSchema.getAdditionalProperties() != null) {\n      schema.setAdditionalProperties(fromSchema.getAdditionalProperties());\n    }\n    if (fromSchema.getDefault() != null) {\n      schema.setDefault(fromSchema.getDefault());\n    }\n    if (fromSchema.getExample() != null) {\n      schema.setExample(fromSchema.getExample());\n    }\n    if (fromSchema.getExternalDocs() != null) {\n      if (schema.getExternalDocs() == null) {\n        schema.setExternalDocs(new ExternalDocumentation());\n      }\n      final ExternalDocumentation externalDocs = schema.getExternalDocs();\n      final ExternalDocumentation fromExternalDocs = fromSchema.getExternalDocs();\n      if (fromExternalDocs.getDescription() != null) {\n        externalDocs.setDescription(fromExternalDocs.getDescription());\n      }\n      if (fromExternalDocs.getExtensions() != null) {\n        if (externalDocs.getExtensions() == null) {\n          externalDocs.setExtensions(new LinkedHashMap<>());\n        }\n        externalDocs.getExtensions().putAll(fromExternalDocs.getExtensions());\n      }\n      if (fromExternalDocs.getUrl() != null) {\n        externalDocs.setUrl(fromExternalDocs.getUrl());\n      }\n    }\n    if (fromSchema.getMaximum() != null) {\n      schema.setMaximum(fromSchema.getMaximum());\n    }\n    if (fromSchema.getMinimum() != null) {\n      schema.setMinimum(fromSchema.getMinimum());\n    }\n    if (fromSchema.getMaxItems() != null) {\n      schema.setMaxItems(fromSchema.getMaxItems());\n    }\n    if (fromSchema.getMinItems() != null) {\n      schema.setMinItems(fromSchema.getMinItems());\n    }\n    if (fromSchema.getMaxProperties() != null) {\n      schema.setMaxProperties(fromSchema.getMaxProperties());\n    }\n    if (fromSchema.getMinProperties() != null) {\n      schema.setMinProperties(fromSchema.getMinProperties());\n    }\n    if (fromSchema.getMaxLength() != null) {\n      schema.setMaxLength(fromSchema.getMaxLength());\n    }\n    if (fromSchema.getMinLength() != null) {\n      schema.setMinLength(fromSchema.getMinLength());\n    }\n    if (fromSchema.getMultipleOf() != null) {\n      schema.setMultipleOf(fromSchema.getMultipleOf());\n    }\n    if (fromSchema.getNot() != null) {\n      if (schema.getNot() == null) {\n        schema.setNot(addSchema(new Schema<>(), fromSchema.getNot()));\n      } else {\n        addSchema(schema.getNot(), fromSchema.getNot());\n      }\n    }\n    if (fromSchema.getPattern() != null) {\n      schema.setPattern(fromSchema.getPattern());\n    }\n    if (fromSchema.getXml() != null) {\n      if (schema.getXml() == null) {\n        schema.setXml(new XML());\n      }\n      final XML xml = schema.getXml();\n      final XML fromXml = fromSchema.getXml();\n      if (fromXml.getAttribute() != null) {\n        xml.setAttribute(fromXml.getAttribute());\n      }\n      if (fromXml.getName() != null) {\n        xml.setName(fromXml.getName());\n      }\n      if (fromXml.getNamespace() != null) {\n        xml.setNamespace(fromXml.getNamespace());\n      }\n      if (fromXml.getExtensions() != null) {\n        if (xml.getExtensions() == null) {\n          xml.setExtensions(new LinkedHashMap<>());\n        }\n        xml.getExtensions().putAll(fromXml.getExtensions());\n      }\n      if (fromXml.getPrefix() != null) {\n        xml.setPrefix(fromXml.getPrefix());\n      }\n      if (fromXml.getWrapped() != null) {\n        xml.setWrapped(fromXml.getWrapped());\n      }\n    }\n    return schema;\n  }\n\n  private static String getSchemaRef(Schema<?> schema) {\n    return ofNullable(schema).map(Schema::get$ref).orElse(null);\n  }\n\n  public DeferredChanged<ChangedSchema> diff(Schema left, Schema right, DiffContext context) {\n    return this.diff(new RecursiveSchemaSet(), left, right, context);\n  }\n\n  public DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet, Schema left, Schema right, DiffContext context) {\n    if (left == null && right == null) {\n      return new RealizedChanged<>(Optional.empty());\n    }\n    return computeDeferredDiff(refSet, left, right, context);\n  }\n\n  public DeferredChanged<ChangedSchema> getTypeChangedSchema(\n      Schema left, Schema right, DiffContext context) {\n    return new RealizedChanged(\n        SchemaDiff.getSchemaDiffResult(openApiDiff)\n            .getChangedSchema()\n            .setOldSchema(left)\n            .setNewSchema(right)\n            .setChangedType(true)\n            .setContext(context));\n  }\n\n  protected DeferredChanged<ChangedSchema> computeDeferredDiff(\n      RecursiveSchemaSet refSet, Schema<?> left, Schema<?> right, DiffContext context) {\n\n    CacheKey key = new CacheKey(getSchemaRef(left), getSchemaRef(right), context);\n    if (key.getLeft() != null && key.getRight() != null) {\n      return openApiDiff.getDeferredSchemaCache().getOrAddSchema(refSet, key, left, right);\n    } else {\n      return computeDiffForReal(refSet, left, right, context);\n    }\n  }\n\n  public DeferredChanged<ChangedSchema> computeDiffForReal(\n      RecursiveSchemaSet refSet, Schema left, Schema right, DiffContext context) {\n\n    left = refPointer.resolveRef(this.leftComponents, left, getSchemaRef(left));\n    right = refPointer.resolveRef(this.rightComponents, right, getSchemaRef(right));\n\n    left = resolveComposedSchema(leftComponents, left, new HashSet<>());\n    right = resolveComposedSchema(rightComponents, right, new HashSet<>());\n\n    // If type of schemas are different, just set old & new schema, set changedType to true in\n    // SchemaDiffResult and\n    // return the object\n    if ((left == null || right == null)\n        || !Objects.equals(left.getType(), right.getType())\n        || !Objects.equals(left.getFormat(), right.getFormat())) {\n      return getTypeChangedSchema(left, right, context);\n    }\n\n    // If schema type is same then get specific SchemaDiffResult and compare the properties\n    SchemaDiffResult result = SchemaDiff.getSchemaDiffResult(right.getClass(), openApiDiff);\n    return result.diff(refSet, leftComponents, rightComponents, left, right, context);\n  }\n}\n", "file_hash": "5b4f85293c2a5f1c412af673a313792b9c5dd74cd2c8eadf42982c483de94aa4", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static java.util.Optional.ofNullable;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.ExternalDocumentation;", "import io.swagger.v3.oas.models.media.ArraySchema;", "import io.swagger.v3.oas.models.media.ComposedSchema;", "import io.swagger.v3.oas.models.media.Discriminator;", "import io.swagger.v3.oas.models.media.Schema;", "import io.swagger.v3.oas.models.media.XML;", "import java.util.ArrayList;", "import java.util.HashSet;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Objects;", "import java.util.Optional;", "import java.util.Set;", "import org.openapitools.openapidiff.core.compare.schemadiffresult.ArraySchemaDiffResult;", "import org.openapitools.openapidiff.core.compare.schemadiffresult.ComposedSchemaDiffResult;", "import org.openapitools.openapidiff.core.compare.schemadiffresult.SchemaDiffResult;", "import org.openapitools.openapidiff.core.model.ChangedSchema;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.model.deferred.RealizedChanged;", "import org.openapitools.openapidiff.core.model.deferred.RecursiveSchemaSet;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "public class SchemaDiff {\n\n  private static final RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n  private static final Map<Class<? extends Schema>, Class<? extends SchemaDiffResult>>\n      schemaDiffResultClassMap = new LinkedHashMap<>();\n\n  static {\n    schemaDiffResultClassMap.put(Schema.class, SchemaDiffResult.class);\n    schemaDiffResultClassMap.put(ArraySchema.class, ArraySchemaDiffResult.class);\n    schemaDiffResultClassMap.put(ComposedSchema.class, ComposedSchemaDiffResult.class);\n  }\n\n  private final Components leftComponents;\n  private final Components rightComponents;\n  private final OpenApiDiff openApiDiff;\n\n  public SchemaDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public static SchemaDiffResult getSchemaDiffResult(OpenApiDiff openApiDiff) {\n    return getSchemaDiffResult(null, openApiDiff);\n  }\n\n  public static SchemaDiffResult getSchemaDiffResult(\n      Class<? extends Schema> classType, OpenApiDiff openApiDiff) {\n    if (classType == null) {\n      classType = Schema.class;\n    }\n\n    Class<? extends SchemaDiffResult> aClass = schemaDiffResultClassMap.get(classType);\n    try {\n      if (aClass == null) {\n        aClass = schemaDiffResultClassMap.get(Schema.class);\n      }\n      if (aClass != null) {\n        return aClass.getConstructor(OpenApiDiff.class).newInstance(openApiDiff);\n      } else {\n        throw new IllegalArgumentException(\"invalid classType\");\n      }\n    } catch (Exception e) {\n      throw new IllegalArgumentException(\"type \" + classType + \" is illegal\");\n    }\n  }\n\n  protected static Schema<?> resolveComposedSchema(\n      Components components, Schema<?> schema, Set<String> visitedRefs) {\n    if (schema instanceof ComposedSchema) {\n      ComposedSchema composedSchema = (ComposedSchema) schema;\n      List<Schema> composedSchemas = new ArrayList<>();\n      Optional.ofNullable(composedSchema.getAllOf()).ifPresent(composedSchemas::addAll);\n      Optional.ofNullable(composedSchema.getAnyOf()).ifPresent(composedSchemas::addAll);\n\n      if (!composedSchemas.isEmpty()) {\n        for (Schema<?> composed : composedSchemas) {\n          if (composed.get$ref() == null || !visitedRefs.contains(composed.get$ref())) {\n            Set<String> updatedVisitedRefs = new HashSet<>(visitedRefs);\n            updatedVisitedRefs.add(composed.get$ref());\n            composed = refPointer.resolveRef(components, composed, composed.get$ref());\n            composed = resolveComposedSchema(components, composed, updatedVisitedRefs);\n            schema = addSchema(schema, composed);\n          }\n        }\n        composedSchema.setAllOf(null);\n        composedSchema.setAnyOf(null);\n      }\n    }\n    return schema;\n  }\n\n  protected static Schema<?> addSchema(Schema<?> schema, Schema<?> fromSchema) {\n    if (fromSchema.getProperties() != null) {\n      if (schema.getProperties() == null) {\n        schema.setProperties(new LinkedHashMap<>());\n      }\n      schema.getProperties().putAll(fromSchema.getProperties());\n    }\n\n    if (fromSchema.getRequired() != null) {\n      if (schema.getRequired() == null) {\n        schema.setRequired(fromSchema.getRequired());\n      } else {\n        schema.getRequired().addAll(fromSchema.getRequired());\n      }\n    }\n\n    if (fromSchema.getReadOnly() != null) {\n      schema.setReadOnly(fromSchema.getReadOnly());\n    }\n    if (fromSchema.getWriteOnly() != null) {\n      schema.setWriteOnly(fromSchema.getWriteOnly());\n    }\n    if (fromSchema.getDeprecated() != null) {\n      schema.setDeprecated(fromSchema.getDeprecated());\n    }\n    if (fromSchema.getExclusiveMaximum() != null) {\n      schema.setExclusiveMaximum(fromSchema.getExclusiveMaximum());\n    }\n    if (fromSchema.getExclusiveMinimum() != null) {\n      schema.setExclusiveMinimum(fromSchema.getExclusiveMinimum());\n    }\n    if (fromSchema.getNullable() != null) {\n      schema.setNullable(fromSchema.getNullable());\n    }\n    if (fromSchema.getUniqueItems() != null) {\n      schema.setUniqueItems(fromSchema.getUniqueItems());\n    }\n    if (fromSchema.getDescription() != null) {\n      schema.setDescription(fromSchema.getDescription());\n    }\n    if (fromSchema.getFormat() != null) {\n      schema.setFormat(fromSchema.getFormat());\n    }\n    if (fromSchema.getType() != null) {\n      schema.setType(fromSchema.getType());\n    }\n    if (fromSchema.getEnum() != null) {\n      if (schema.getEnum() == null) {\n        schema.setEnum(new ArrayList<>());\n      }\n      //noinspection unchecked\n      schema.getEnum().addAll((List) fromSchema.getEnum());\n    }\n    if (fromSchema.getExtensions() != null) {\n      if (schema.getExtensions() == null) {\n        schema.setExtensions(new LinkedHashMap<>());\n      }\n      schema.getExtensions().putAll(fromSchema.getExtensions());\n    }\n    if (fromSchema instanceof ComposedSchema && schema instanceof ComposedSchema) {\n      ComposedSchema composedFromSchema = (ComposedSchema) fromSchema;\n      ComposedSchema composedSchema = (ComposedSchema) schema;\n      if (composedFromSchema.getOneOf() != null) {\n        if (composedSchema.getOneOf() == null) {\n          composedSchema.setOneOf(new ArrayList<>());\n        }\n        composedSchema.getOneOf().addAll(composedFromSchema.getOneOf());\n      }\n    }\n    if (fromSchema.getDiscriminator() != null) {\n      if (schema.getDiscriminator() == null) {\n        schema.setDiscriminator(new Discriminator());\n      }\n      final Discriminator discriminator = schema.getDiscriminator();\n      final Discriminator fromDiscriminator = fromSchema.getDiscriminator();\n      if (fromDiscriminator.getPropertyName() != null) {\n        discriminator.setPropertyName(fromDiscriminator.getPropertyName());\n      }\n      if (fromDiscriminator.getMapping() != null) {\n        if (discriminator.getMapping() == null) {\n          discriminator.setMapping(new LinkedHashMap<>());\n        }\n        discriminator.getMapping().putAll(fromDiscriminator.getMapping());\n      }\n    }\n    if (fromSchema.getTitle() != null) {\n      schema.setTitle(fromSchema.getTitle());\n    }\n    if (fromSchema.getName() != null) {\n      schema.setName(fromSchema.getName());\n    }\n    if (fromSchema.getAdditionalProperties() != null) {\n      schema.setAdditionalProperties(fromSchema.getAdditionalProperties());\n    }\n    if (fromSchema.getDefault() != null) {\n      schema.setDefault(fromSchema.getDefault());\n    }\n    if (fromSchema.getExample() != null) {\n      schema.setExample(fromSchema.getExample());\n    }\n    if (fromSchema.getExternalDocs() != null) {\n      if (schema.getExternalDocs() == null) {\n        schema.setExternalDocs(new ExternalDocumentation());\n      }\n      final ExternalDocumentation externalDocs = schema.getExternalDocs();\n      final ExternalDocumentation fromExternalDocs = fromSchema.getExternalDocs();\n      if (fromExternalDocs.getDescription() != null) {\n        externalDocs.setDescription(fromExternalDocs.getDescription());\n      }\n      if (fromExternalDocs.getExtensions() != null) {\n        if (externalDocs.getExtensions() == null) {\n          externalDocs.setExtensions(new LinkedHashMap<>());\n        }\n        externalDocs.getExtensions().putAll(fromExternalDocs.getExtensions());\n      }\n      if (fromExternalDocs.getUrl() != null) {\n        externalDocs.setUrl(fromExternalDocs.getUrl());\n      }\n    }\n    if (fromSchema.getMaximum() != null) {\n      schema.setMaximum(fromSchema.getMaximum());\n    }\n    if (fromSchema.getMinimum() != null) {\n      schema.setMinimum(fromSchema.getMinimum());\n    }\n    if (fromSchema.getMaxItems() != null) {\n      schema.setMaxItems(fromSchema.getMaxItems());\n    }\n    if (fromSchema.getMinItems() != null) {\n      schema.setMinItems(fromSchema.getMinItems());\n    }\n    if (fromSchema.getMaxProperties() != null) {\n      schema.setMaxProperties(fromSchema.getMaxProperties());\n    }\n    if (fromSchema.getMinProperties() != null) {\n      schema.setMinProperties(fromSchema.getMinProperties());\n    }\n    if (fromSchema.getMaxLength() != null) {\n      schema.setMaxLength(fromSchema.getMaxLength());\n    }\n    if (fromSchema.getMinLength() != null) {\n      schema.setMinLength(fromSchema.getMinLength());\n    }\n    if (fromSchema.getMultipleOf() != null) {\n      schema.setMultipleOf(fromSchema.getMultipleOf());\n    }\n    if (fromSchema.getNot() != null) {\n      if (schema.getNot() == null) {\n        schema.setNot(addSchema(new Schema<>(), fromSchema.getNot()));\n      } else {\n        addSchema(schema.getNot(), fromSchema.getNot());\n      }\n    }\n    if (fromSchema.getPattern() != null) {\n      schema.setPattern(fromSchema.getPattern());\n    }\n    if (fromSchema.getXml() != null) {\n      if (schema.getXml() == null) {\n        schema.setXml(new XML());\n      }\n      final XML xml = schema.getXml();\n      final XML fromXml = fromSchema.getXml();\n      if (fromXml.getAttribute() != null) {\n        xml.setAttribute(fromXml.getAttribute());\n      }\n      if (fromXml.getName() != null) {\n        xml.setName(fromXml.getName());\n      }\n      if (fromXml.getNamespace() != null) {\n        xml.setNamespace(fromXml.getNamespace());\n      }\n      if (fromXml.getExtensions() != null) {\n        if (xml.getExtensions() == null) {\n          xml.setExtensions(new LinkedHashMap<>());\n        }\n        xml.getExtensions().putAll(fromXml.getExtensions());\n      }\n      if (fromXml.getPrefix() != null) {\n        xml.setPrefix(fromXml.getPrefix());\n      }\n      if (fromXml.getWrapped() != null) {\n        xml.setWrapped(fromXml.getWrapped());\n      }\n    }\n    return schema;\n  }\n\n  private static String getSchemaRef(Schema<?> schema) {\n    return ofNullable(schema).map(Schema::get$ref).orElse(null);\n  }\n\n  public DeferredChanged<ChangedSchema> diff(Schema left, Schema right, DiffContext context) {\n    return this.diff(new RecursiveSchemaSet(), left, right, context);\n  }\n\n  public DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet, Schema left, Schema right, DiffContext context) {\n    if (left == null && right == null) {\n      return new RealizedChanged<>(Optional.empty());\n    }\n    return computeDeferredDiff(refSet, left, right, context);\n  }\n\n  public DeferredChanged<ChangedSchema> getTypeChangedSchema(\n      Schema left, Schema right, DiffContext context) {\n    return new RealizedChanged(\n        SchemaDiff.getSchemaDiffResult(openApiDiff)\n            .getChangedSchema()\n            .setOldSchema(left)\n            .setNewSchema(right)\n            .setChangedType(true)\n            .setContext(context));\n  }\n\n  protected DeferredChanged<ChangedSchema> computeDeferredDiff(\n      RecursiveSchemaSet refSet, Schema<?> left, Schema<?> right, DiffContext context) {\n\n    CacheKey key = new CacheKey(getSchemaRef(left), getSchemaRef(right), context);\n    if (key.getLeft() != null && key.getRight() != null) {\n      return openApiDiff.getDeferredSchemaCache().getOrAddSchema(refSet, key, left, right);\n    } else {\n      return computeDiffForReal(refSet, left, right, context);\n    }\n  }\n\n  public DeferredChanged<ChangedSchema> computeDiffForReal(\n      RecursiveSchemaSet refSet, Schema left, Schema right, DiffContext context) {\n\n    left = refPointer.resolveRef(this.leftComponents, left, getSchemaRef(left));\n    right = refPointer.resolveRef(this.rightComponents, right, getSchemaRef(right));\n\n    left = resolveComposedSchema(leftComponents, left, new HashSet<>());\n    right = resolveComposedSchema(rightComponents, right, new HashSet<>());\n\n    // If type of schemas are different, just set old & new schema, set changedType to true in\n    // SchemaDiffResult and\n    // return the object\n    if ((left == null || right == null)\n        || !Objects.equals(left.getType(), right.getType())\n        || !Objects.equals(left.getFormat(), right.getFormat())) {\n      return getTypeChangedSchema(left, right, context);\n    }\n\n    // If schema type is same then get specific SchemaDiffResult and compare the properties\n    SchemaDiffResult result = SchemaDiff.getSchemaDiffResult(right.getClass(), openApiDiff);\n    return result.diff(refSet, leftComponents, rightComponents, left, right, context);\n  }\n}", "definition": "public class SchemaDiff", "class_docstring": "", "name": "SchemaDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RefPointer<Schema<?>>", "name": "refPointer = new RefPointer<>(RefType.SCHEMAS)", "syntax_pass": true}, {"attribute_expression": "private static final Map<Class<? extends Schema>, Class<? extends SchemaDiffResult>>\n      schemaDiffResultClassMap = new LinkedHashMap<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<Class<? extends Schema>, Class<? extends SchemaDiffResult>>", "name": "schemaDiffResultClassMap = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Components leftComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "leftComponents", "syntax_pass": true}, {"attribute_expression": "private final Components rightComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "rightComponents", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public SchemaDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SchemaDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                             {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "signature": "public SchemaDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public static SchemaDiffResult getSchemaDiffResult(OpenApiDiff openApiDiff) {\n    return getSchemaDiffResult(null, openApiDiff);\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SchemaDiffResult", "classes": []}, "name": "getSchemaDiffResult", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                                              {\n    return getSchemaDiffResult(null, openApiDiff);\n  }", "signature": "public static SchemaDiffResult getSchemaDiffResult(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public static SchemaDiffResult getSchemaDiffResult(\n      Class<? extends Schema> classType, OpenApiDiff openApiDiff) {\n    if (classType == null) {\n      classType = Schema.class;\n    }\n\n    Class<? extends SchemaDiffResult> aClass = schemaDiffResultClassMap.get(classType);\n    try {\n      if (aClass == null) {\n        aClass = schemaDiffResultClassMap.get(Schema.class);\n      }\n      if (aClass != null) {\n        return aClass.getConstructor(OpenApiDiff.class).newInstance(openApiDiff);\n      } else {\n        throw new IllegalArgumentException(\"invalid classType\");\n      }\n    } catch (Exception e) {\n      throw new IllegalArgumentException(\"type \" + classType + \" is illegal\");\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SchemaDiffResult", "classes": []}, "name": "getSchemaDiffResult", "params": [{"name": "classType", "type": "Class<? extends Schema>"}, {"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                                  {\n    if (classType == null) {\n      classType = Schema.class;\n    }\n\n    Class<? extends SchemaDiffResult> aClass = schemaDiffResultClassMap.get(classType);\n    try {\n      if (aClass == null) {\n        aClass = schemaDiffResultClassMap.get(Schema.class);\n      }\n      if (aClass != null) {\n        return aClass.getConstructor(OpenApiDiff.class).newInstance(openApiDiff);\n      } else {\n        throw new IllegalArgumentException(\"invalid classType\");\n      }\n    } catch (Exception e) {\n      throw new IllegalArgumentException(\"type \" + classType + \" is illegal\");\n    }\n  }", "signature": "public static SchemaDiffResult getSchemaDiffResult(\n      Class<? extends Schema> classType, OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  protected static Schema<?> resolveComposedSchema(\n      Components components, Schema<?> schema, Set<String> visitedRefs) {\n    if (schema instanceof ComposedSchema) {\n      ComposedSchema composedSchema = (ComposedSchema) schema;\n      List<Schema> composedSchemas = new ArrayList<>();\n      Optional.ofNullable(composedSchema.getAllOf()).ifPresent(composedSchemas::addAll);\n      Optional.ofNullable(composedSchema.getAnyOf()).ifPresent(composedSchemas::addAll);\n\n      if (!composedSchemas.isEmpty()) {\n        for (Schema<?> composed : composedSchemas) {\n          if (composed.get$ref() == null || !visitedRefs.contains(composed.get$ref())) {\n            Set<String> updatedVisitedRefs = new HashSet<>(visitedRefs);\n            updatedVisitedRefs.add(composed.get$ref());\n            composed = refPointer.resolveRef(components, composed, composed.get$ref());\n            composed = resolveComposedSchema(components, composed, updatedVisitedRefs);\n            schema = addSchema(schema, composed);\n          }\n        }\n        composedSchema.setAllOf(null);\n        composedSchema.setAnyOf(null);\n      }\n    }\n    return schema;\n  }", "docstring": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "return_type": "Schema<?>", "classes": []}, "name": "resolveComposedSchema", "params": [{"name": "components", "type": "Components"}, {"name": "schema", "type": "Schema<?>"}, {"name": "visitedRefs", "type": "Set<String>"}], "body": "                                                                        {\n    if (schema instanceof ComposedSchema) {\n      ComposedSchema composedSchema = (ComposedSchema) schema;\n      List<Schema> composedSchemas = new ArrayList<>();\n      Optional.ofNullable(composedSchema.getAllOf()).ifPresent(composedSchemas::addAll);\n      Optional.ofNullable(composedSchema.getAnyOf()).ifPresent(composedSchemas::addAll);\n\n      if (!composedSchemas.isEmpty()) {\n        for (Schema<?> composed : composedSchemas) {\n          if (composed.get$ref() == null || !visitedRefs.contains(composed.get$ref())) {\n            Set<String> updatedVisitedRefs = new HashSet<>(visitedRefs);\n            updatedVisitedRefs.add(composed.get$ref());\n            composed = refPointer.resolveRef(components, composed, composed.get$ref());\n            composed = resolveComposedSchema(components, composed, updatedVisitedRefs);\n            schema = addSchema(schema, composed);\n          }\n        }\n        composedSchema.setAllOf(null);\n        composedSchema.setAnyOf(null);\n      }\n    }\n    return schema;\n  }", "signature": "protected static Schema<?> resolveComposedSchema(\n      Components components, Schema<?> schema, Set<String> visitedRefs)"}, {"syntax_pass": true, "original_string": "  protected static Schema<?> addSchema(Schema<?> schema, Schema<?> fromSchema) {\n    if (fromSchema.getProperties() != null) {\n      if (schema.getProperties() == null) {\n        schema.setProperties(new LinkedHashMap<>());\n      }\n      schema.getProperties().putAll(fromSchema.getProperties());\n    }\n\n    if (fromSchema.getRequired() != null) {\n      if (schema.getRequired() == null) {\n        schema.setRequired(fromSchema.getRequired());\n      } else {\n        schema.getRequired().addAll(fromSchema.getRequired());\n      }\n    }\n\n    if (fromSchema.getReadOnly() != null) {\n      schema.setReadOnly(fromSchema.getReadOnly());\n    }\n    if (fromSchema.getWriteOnly() != null) {\n      schema.setWriteOnly(fromSchema.getWriteOnly());\n    }\n    if (fromSchema.getDeprecated() != null) {\n      schema.setDeprecated(fromSchema.getDeprecated());\n    }\n    if (fromSchema.getExclusiveMaximum() != null) {\n      schema.setExclusiveMaximum(fromSchema.getExclusiveMaximum());\n    }\n    if (fromSchema.getExclusiveMinimum() != null) {\n      schema.setExclusiveMinimum(fromSchema.getExclusiveMinimum());\n    }\n    if (fromSchema.getNullable() != null) {\n      schema.setNullable(fromSchema.getNullable());\n    }\n    if (fromSchema.getUniqueItems() != null) {\n      schema.setUniqueItems(fromSchema.getUniqueItems());\n    }\n    if (fromSchema.getDescription() != null) {\n      schema.setDescription(fromSchema.getDescription());\n    }\n    if (fromSchema.getFormat() != null) {\n      schema.setFormat(fromSchema.getFormat());\n    }\n    if (fromSchema.getType() != null) {\n      schema.setType(fromSchema.getType());\n    }\n    if (fromSchema.getEnum() != null) {\n      if (schema.getEnum() == null) {\n        schema.setEnum(new ArrayList<>());\n      }\n      //noinspection unchecked\n      schema.getEnum().addAll((List) fromSchema.getEnum());\n    }\n    if (fromSchema.getExtensions() != null) {\n      if (schema.getExtensions() == null) {\n        schema.setExtensions(new LinkedHashMap<>());\n      }\n      schema.getExtensions().putAll(fromSchema.getExtensions());\n    }\n    if (fromSchema instanceof ComposedSchema && schema instanceof ComposedSchema) {\n      ComposedSchema composedFromSchema = (ComposedSchema) fromSchema;\n      ComposedSchema composedSchema = (ComposedSchema) schema;\n      if (composedFromSchema.getOneOf() != null) {\n        if (composedSchema.getOneOf() == null) {\n          composedSchema.setOneOf(new ArrayList<>());\n        }\n        composedSchema.getOneOf().addAll(composedFromSchema.getOneOf());\n      }\n    }\n    if (fromSchema.getDiscriminator() != null) {\n      if (schema.getDiscriminator() == null) {\n        schema.setDiscriminator(new Discriminator());\n      }\n      final Discriminator discriminator = schema.getDiscriminator();\n      final Discriminator fromDiscriminator = fromSchema.getDiscriminator();\n      if (fromDiscriminator.getPropertyName() != null) {\n        discriminator.setPropertyName(fromDiscriminator.getPropertyName());\n      }\n      if (fromDiscriminator.getMapping() != null) {\n        if (discriminator.getMapping() == null) {\n          discriminator.setMapping(new LinkedHashMap<>());\n        }\n        discriminator.getMapping().putAll(fromDiscriminator.getMapping());\n      }\n    }\n    if (fromSchema.getTitle() != null) {\n      schema.setTitle(fromSchema.getTitle());\n    }\n    if (fromSchema.getName() != null) {\n      schema.setName(fromSchema.getName());\n    }\n    if (fromSchema.getAdditionalProperties() != null) {\n      schema.setAdditionalProperties(fromSchema.getAdditionalProperties());\n    }\n    if (fromSchema.getDefault() != null) {\n      schema.setDefault(fromSchema.getDefault());\n    }\n    if (fromSchema.getExample() != null) {\n      schema.setExample(fromSchema.getExample());\n    }\n    if (fromSchema.getExternalDocs() != null) {\n      if (schema.getExternalDocs() == null) {\n        schema.setExternalDocs(new ExternalDocumentation());\n      }\n      final ExternalDocumentation externalDocs = schema.getExternalDocs();\n      final ExternalDocumentation fromExternalDocs = fromSchema.getExternalDocs();\n      if (fromExternalDocs.getDescription() != null) {\n        externalDocs.setDescription(fromExternalDocs.getDescription());\n      }\n      if (fromExternalDocs.getExtensions() != null) {\n        if (externalDocs.getExtensions() == null) {\n          externalDocs.setExtensions(new LinkedHashMap<>());\n        }\n        externalDocs.getExtensions().putAll(fromExternalDocs.getExtensions());\n      }\n      if (fromExternalDocs.getUrl() != null) {\n        externalDocs.setUrl(fromExternalDocs.getUrl());\n      }\n    }\n    if (fromSchema.getMaximum() != null) {\n      schema.setMaximum(fromSchema.getMaximum());\n    }\n    if (fromSchema.getMinimum() != null) {\n      schema.setMinimum(fromSchema.getMinimum());\n    }\n    if (fromSchema.getMaxItems() != null) {\n      schema.setMaxItems(fromSchema.getMaxItems());\n    }\n    if (fromSchema.getMinItems() != null) {\n      schema.setMinItems(fromSchema.getMinItems());\n    }\n    if (fromSchema.getMaxProperties() != null) {\n      schema.setMaxProperties(fromSchema.getMaxProperties());\n    }\n    if (fromSchema.getMinProperties() != null) {\n      schema.setMinProperties(fromSchema.getMinProperties());\n    }\n    if (fromSchema.getMaxLength() != null) {\n      schema.setMaxLength(fromSchema.getMaxLength());\n    }\n    if (fromSchema.getMinLength() != null) {\n      schema.setMinLength(fromSchema.getMinLength());\n    }\n    if (fromSchema.getMultipleOf() != null) {\n      schema.setMultipleOf(fromSchema.getMultipleOf());\n    }\n    if (fromSchema.getNot() != null) {\n      if (schema.getNot() == null) {\n        schema.setNot(addSchema(new Schema<>(), fromSchema.getNot()));\n      } else {\n        addSchema(schema.getNot(), fromSchema.getNot());\n      }\n    }\n    if (fromSchema.getPattern() != null) {\n      schema.setPattern(fromSchema.getPattern());\n    }\n    if (fromSchema.getXml() != null) {\n      if (schema.getXml() == null) {\n        schema.setXml(new XML());\n      }\n      final XML xml = schema.getXml();\n      final XML fromXml = fromSchema.getXml();\n      if (fromXml.getAttribute() != null) {\n        xml.setAttribute(fromXml.getAttribute());\n      }\n      if (fromXml.getName() != null) {\n        xml.setName(fromXml.getName());\n      }\n      if (fromXml.getNamespace() != null) {\n        xml.setNamespace(fromXml.getNamespace());\n      }\n      if (fromXml.getExtensions() != null) {\n        if (xml.getExtensions() == null) {\n          xml.setExtensions(new LinkedHashMap<>());\n        }\n        xml.getExtensions().putAll(fromXml.getExtensions());\n      }\n      if (fromXml.getPrefix() != null) {\n        xml.setPrefix(fromXml.getPrefix());\n      }\n      if (fromXml.getWrapped() != null) {\n        xml.setWrapped(fromXml.getWrapped());\n      }\n    }\n    return schema;\n  }", "docstring": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "return_type": "Schema<?>", "classes": []}, "name": "addSchema", "params": [{"name": "schema", "type": "Schema<?>"}, {"name": "fromSchema", "type": "Schema<?>"}], "body": "                                                                               {\n    if (fromSchema.getProperties() != null) {\n      if (schema.getProperties() == null) {\n        schema.setProperties(new LinkedHashMap<>());\n      }\n      schema.getProperties().putAll(fromSchema.getProperties());\n    }\n\n    if (fromSchema.getRequired() != null) {\n      if (schema.getRequired() == null) {\n        schema.setRequired(fromSchema.getRequired());\n      } else {\n        schema.getRequired().addAll(fromSchema.getRequired());\n      }\n    }\n\n    if (fromSchema.getReadOnly() != null) {\n      schema.setReadOnly(fromSchema.getReadOnly());\n    }\n    if (fromSchema.getWriteOnly() != null) {\n      schema.setWriteOnly(fromSchema.getWriteOnly());\n    }\n    if (fromSchema.getDeprecated() != null) {\n      schema.setDeprecated(fromSchema.getDeprecated());\n    }\n    if (fromSchema.getExclusiveMaximum() != null) {\n      schema.setExclusiveMaximum(fromSchema.getExclusiveMaximum());\n    }\n    if (fromSchema.getExclusiveMinimum() != null) {\n      schema.setExclusiveMinimum(fromSchema.getExclusiveMinimum());\n    }\n    if (fromSchema.getNullable() != null) {\n      schema.setNullable(fromSchema.getNullable());\n    }\n    if (fromSchema.getUniqueItems() != null) {\n      schema.setUniqueItems(fromSchema.getUniqueItems());\n    }\n    if (fromSchema.getDescription() != null) {\n      schema.setDescription(fromSchema.getDescription());\n    }\n    if (fromSchema.getFormat() != null) {\n      schema.setFormat(fromSchema.getFormat());\n    }\n    if (fromSchema.getType() != null) {\n      schema.setType(fromSchema.getType());\n    }\n    if (fromSchema.getEnum() != null) {\n      if (schema.getEnum() == null) {\n        schema.setEnum(new ArrayList<>());\n      }\n      //noinspection unchecked\n      schema.getEnum().addAll((List) fromSchema.getEnum());\n    }\n    if (fromSchema.getExtensions() != null) {\n      if (schema.getExtensions() == null) {\n        schema.setExtensions(new LinkedHashMap<>());\n      }\n      schema.getExtensions().putAll(fromSchema.getExtensions());\n    }\n    if (fromSchema instanceof ComposedSchema && schema instanceof ComposedSchema) {\n      ComposedSchema composedFromSchema = (ComposedSchema) fromSchema;\n      ComposedSchema composedSchema = (ComposedSchema) schema;\n      if (composedFromSchema.getOneOf() != null) {\n        if (composedSchema.getOneOf() == null) {\n          composedSchema.setOneOf(new ArrayList<>());\n        }\n        composedSchema.getOneOf().addAll(composedFromSchema.getOneOf());\n      }\n    }\n    if (fromSchema.getDiscriminator() != null) {\n      if (schema.getDiscriminator() == null) {\n        schema.setDiscriminator(new Discriminator());\n      }\n      final Discriminator discriminator = schema.getDiscriminator();\n      final Discriminator fromDiscriminator = fromSchema.getDiscriminator();\n      if (fromDiscriminator.getPropertyName() != null) {\n        discriminator.setPropertyName(fromDiscriminator.getPropertyName());\n      }\n      if (fromDiscriminator.getMapping() != null) {\n        if (discriminator.getMapping() == null) {\n          discriminator.setMapping(new LinkedHashMap<>());\n        }\n        discriminator.getMapping().putAll(fromDiscriminator.getMapping());\n      }\n    }\n    if (fromSchema.getTitle() != null) {\n      schema.setTitle(fromSchema.getTitle());\n    }\n    if (fromSchema.getName() != null) {\n      schema.setName(fromSchema.getName());\n    }\n    if (fromSchema.getAdditionalProperties() != null) {\n      schema.setAdditionalProperties(fromSchema.getAdditionalProperties());\n    }\n    if (fromSchema.getDefault() != null) {\n      schema.setDefault(fromSchema.getDefault());\n    }\n    if (fromSchema.getExample() != null) {\n      schema.setExample(fromSchema.getExample());\n    }\n    if (fromSchema.getExternalDocs() != null) {\n      if (schema.getExternalDocs() == null) {\n        schema.setExternalDocs(new ExternalDocumentation());\n      }\n      final ExternalDocumentation externalDocs = schema.getExternalDocs();\n      final ExternalDocumentation fromExternalDocs = fromSchema.getExternalDocs();\n      if (fromExternalDocs.getDescription() != null) {\n        externalDocs.setDescription(fromExternalDocs.getDescription());\n      }\n      if (fromExternalDocs.getExtensions() != null) {\n        if (externalDocs.getExtensions() == null) {\n          externalDocs.setExtensions(new LinkedHashMap<>());\n        }\n        externalDocs.getExtensions().putAll(fromExternalDocs.getExtensions());\n      }\n      if (fromExternalDocs.getUrl() != null) {\n        externalDocs.setUrl(fromExternalDocs.getUrl());\n      }\n    }\n    if (fromSchema.getMaximum() != null) {\n      schema.setMaximum(fromSchema.getMaximum());\n    }\n    if (fromSchema.getMinimum() != null) {\n      schema.setMinimum(fromSchema.getMinimum());\n    }\n    if (fromSchema.getMaxItems() != null) {\n      schema.setMaxItems(fromSchema.getMaxItems());\n    }\n    if (fromSchema.getMinItems() != null) {\n      schema.setMinItems(fromSchema.getMinItems());\n    }\n    if (fromSchema.getMaxProperties() != null) {\n      schema.setMaxProperties(fromSchema.getMaxProperties());\n    }\n    if (fromSchema.getMinProperties() != null) {\n      schema.setMinProperties(fromSchema.getMinProperties());\n    }\n    if (fromSchema.getMaxLength() != null) {\n      schema.setMaxLength(fromSchema.getMaxLength());\n    }\n    if (fromSchema.getMinLength() != null) {\n      schema.setMinLength(fromSchema.getMinLength());\n    }\n    if (fromSchema.getMultipleOf() != null) {\n      schema.setMultipleOf(fromSchema.getMultipleOf());\n    }\n    if (fromSchema.getNot() != null) {\n      if (schema.getNot() == null) {\n        schema.setNot(addSchema(new Schema<>(), fromSchema.getNot()));\n      } else {\n        addSchema(schema.getNot(), fromSchema.getNot());\n      }\n    }\n    if (fromSchema.getPattern() != null) {\n      schema.setPattern(fromSchema.getPattern());\n    }\n    if (fromSchema.getXml() != null) {\n      if (schema.getXml() == null) {\n        schema.setXml(new XML());\n      }\n      final XML xml = schema.getXml();\n      final XML fromXml = fromSchema.getXml();\n      if (fromXml.getAttribute() != null) {\n        xml.setAttribute(fromXml.getAttribute());\n      }\n      if (fromXml.getName() != null) {\n        xml.setName(fromXml.getName());\n      }\n      if (fromXml.getNamespace() != null) {\n        xml.setNamespace(fromXml.getNamespace());\n      }\n      if (fromXml.getExtensions() != null) {\n        if (xml.getExtensions() == null) {\n          xml.setExtensions(new LinkedHashMap<>());\n        }\n        xml.getExtensions().putAll(fromXml.getExtensions());\n      }\n      if (fromXml.getPrefix() != null) {\n        xml.setPrefix(fromXml.getPrefix());\n      }\n      if (fromXml.getWrapped() != null) {\n        xml.setWrapped(fromXml.getWrapped());\n      }\n    }\n    return schema;\n  }", "signature": "protected static Schema<?> addSchema(Schema<?> schema, Schema<?> fromSchema)"}, {"syntax_pass": true, "original_string": "  private static String getSchemaRef(Schema<?> schema) {\n    return ofNullable(schema).map(Schema::get$ref).orElse(null);\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "getSchemaRef", "params": [{"name": "schema", "type": "Schema<?>"}], "body": "                                                       {\n    return ofNullable(schema).map(Schema::get$ref).orElse(null);\n  }", "signature": "private static String getSchemaRef(Schema<?> schema)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedSchema> diff(Schema left, Schema right, DiffContext context) {\n    return this.diff(new RecursiveSchemaSet(), left, right, context);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSchema>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "Schema"}, {"name": "right", "type": "Schema"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                             {\n    return this.diff(new RecursiveSchemaSet(), left, right, context);\n  }", "signature": "public DeferredChanged<ChangedSchema> diff(Schema left, Schema right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet, Schema left, Schema right, DiffContext context) {\n    if (left == null && right == null) {\n      return new RealizedChanged<>(Optional.empty());\n    }\n    return computeDeferredDiff(refSet, left, right, context);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSchema>", "classes": []}, "name": "diff", "params": [{"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "left", "type": "Schema"}, {"name": "right", "type": "Schema"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                 {\n    if (left == null && right == null) {\n      return new RealizedChanged<>(Optional.empty());\n    }\n    return computeDeferredDiff(refSet, left, right, context);\n  }", "signature": "public DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet, Schema left, Schema right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedSchema> getTypeChangedSchema(\n      Schema left, Schema right, DiffContext context) {\n    return new RealizedChanged(\n        SchemaDiff.getSchemaDiffResult(openApiDiff)\n            .getChangedSchema()\n            .setOldSchema(left)\n            .setNewSchema(right)\n            .setChangedType(true)\n            .setContext(context));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSchema>", "classes": []}, "name": "getTypeChangedSchema", "params": [{"name": "left", "type": "Schema"}, {"name": "right", "type": "Schema"}, {"name": "context", "type": "DiffContext"}], "body": "                                                      {\n    return new RealizedChanged(\n        SchemaDiff.getSchemaDiffResult(openApiDiff)\n            .getChangedSchema()\n            .setOldSchema(left)\n            .setNewSchema(right)\n            .setChangedType(true)\n            .setContext(context));\n  }", "signature": "public DeferredChanged<ChangedSchema> getTypeChangedSchema(\n      Schema left, Schema right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  protected DeferredChanged<ChangedSchema> computeDeferredDiff(\n      RecursiveSchemaSet refSet, Schema<?> left, Schema<?> right, DiffContext context) {\n\n    CacheKey key = new CacheKey(getSchemaRef(left), getSchemaRef(right), context);\n    if (key.getLeft() != null && key.getRight() != null) {\n      return openApiDiff.getDeferredSchemaCache().getOrAddSchema(refSet, key, left, right);\n    } else {\n      return computeDiffForReal(refSet, left, right, context);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "DeferredChanged<ChangedSchema>", "classes": []}, "name": "computeDeferredDiff", "params": [{"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "left", "type": "Schema<?>"}, {"name": "right", "type": "Schema<?>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                       {\n\n    CacheKey key = new CacheKey(getSchemaRef(left), getSchemaRef(right), context);\n    if (key.getLeft() != null && key.getRight() != null) {\n      return openApiDiff.getDeferredSchemaCache().getOrAddSchema(refSet, key, left, right);\n    } else {\n      return computeDiffForReal(refSet, left, right, context);\n    }\n  }", "signature": "protected DeferredChanged<ChangedSchema> computeDeferredDiff(\n      RecursiveSchemaSet refSet, Schema<?> left, Schema<?> right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedSchema> computeDiffForReal(\n      RecursiveSchemaSet refSet, Schema left, Schema right, DiffContext context) {\n\n    left = refPointer.resolveRef(this.leftComponents, left, getSchemaRef(left));\n    right = refPointer.resolveRef(this.rightComponents, right, getSchemaRef(right));\n\n    left = resolveComposedSchema(leftComponents, left, new HashSet<>());\n    right = resolveComposedSchema(rightComponents, right, new HashSet<>());\n\n    // If type of schemas are different, just set old & new schema, set changedType to true in\n    // SchemaDiffResult and\n    // return the object\n    if ((left == null || right == null)\n        || !Objects.equals(left.getType(), right.getType())\n        || !Objects.equals(left.getFormat(), right.getFormat())) {\n      return getTypeChangedSchema(left, right, context);\n    }\n\n    // If schema type is same then get specific SchemaDiffResult and compare the properties\n    SchemaDiffResult result = SchemaDiff.getSchemaDiffResult(right.getClass(), openApiDiff);\n    return result.diff(refSet, leftComponents, rightComponents, left, right, context);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSchema>", "classes": []}, "name": "computeDiffForReal", "params": [{"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "left", "type": "Schema"}, {"name": "right", "type": "Schema"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                 {\n\n    left = refPointer.resolveRef(this.leftComponents, left, getSchemaRef(left));\n    right = refPointer.resolveRef(this.rightComponents, right, getSchemaRef(right));\n\n    left = resolveComposedSchema(leftComponents, left, new HashSet<>());\n    right = resolveComposedSchema(rightComponents, right, new HashSet<>());\n\n    // If type of schemas are different, just set old & new schema, set changedType to true in\n    // SchemaDiffResult and\n    // return the object\n    if ((left == null || right == null)\n        || !Objects.equals(left.getType(), right.getType())\n        || !Objects.equals(left.getFormat(), right.getFormat())) {\n      return getTypeChangedSchema(left, right, context);\n    }\n\n    // If schema type is same then get specific SchemaDiffResult and compare the properties\n    SchemaDiffResult result = SchemaDiff.getSchemaDiffResult(right.getClass(), openApiDiff);\n    return result.diff(refSet, leftComponents, rightComponents, left, right, context);\n  }", "signature": "public DeferredChanged<ChangedSchema> computeDiffForReal(\n      RecursiveSchemaSet refSet, Schema left, Schema right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/ListDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport org.openapitools.openapidiff.core.model.ChangedList;\n\npublic class ListDiff {\n\n  private ListDiff() {}\n\n  public static <K extends ChangedList<X>, X> K diff(K instance) {\n    if (instance.getOldValue() == null && instance.getNewValue() == null) {\n      return instance;\n    }\n    if (instance.getOldValue() == null) {\n      instance.setIncreased(instance.getNewValue());\n      return instance;\n    }\n    if (instance.getNewValue() == null) {\n      instance.setMissing(instance.getOldValue());\n      return instance;\n    }\n    instance.getIncreased().addAll(instance.getNewValue());\n    for (X leftItem : instance.getOldValue()) {\n      if (instance.getNewValue().contains(leftItem)) {\n        instance.getIncreased().remove(leftItem);\n        instance.getShared().add(leftItem);\n      } else {\n        instance.getMissing().add(leftItem);\n      }\n    }\n    return instance;\n  }\n}\n", "file_hash": "89177c0897df9397f30dc4efa92869ada73ae2a5b3046024b122de76decdec32", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import org.openapitools.openapidiff.core.model.ChangedList;"], "methods": [], "classes": [{"original_string": "public class ListDiff {\n\n  private ListDiff() {}\n\n  public static <K extends ChangedList<X>, X> K diff(K instance) {\n    if (instance.getOldValue() == null && instance.getNewValue() == null) {\n      return instance;\n    }\n    if (instance.getOldValue() == null) {\n      instance.setIncreased(instance.getNewValue());\n      return instance;\n    }\n    if (instance.getNewValue() == null) {\n      instance.setMissing(instance.getOldValue());\n      return instance;\n    }\n    instance.getIncreased().addAll(instance.getNewValue());\n    for (X leftItem : instance.getOldValue()) {\n      if (instance.getNewValue().contains(leftItem)) {\n        instance.getIncreased().remove(leftItem);\n        instance.getShared().add(leftItem);\n      } else {\n        instance.getMissing().add(leftItem);\n      }\n    }\n    return instance;\n  }\n}", "definition": "public class ListDiff", "class_docstring": "", "name": "ListDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private ListDiff() {}", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ListDiff", "params": [], "body": "                     {}", "signature": "private ListDiff()"}, {"syntax_pass": true, "original_string": "  public static <K extends ChangedList<X>, X> K diff(K instance) {\n    if (instance.getOldValue() == null && instance.getNewValue() == null) {\n      return instance;\n    }\n    if (instance.getOldValue() == null) {\n      instance.setIncreased(instance.getNewValue());\n      return instance;\n    }\n    if (instance.getNewValue() == null) {\n      instance.setMissing(instance.getOldValue());\n      return instance;\n    }\n    instance.getIncreased().addAll(instance.getNewValue());\n    for (X leftItem : instance.getOldValue()) {\n      if (instance.getNewValue().contains(leftItem)) {\n        instance.getIncreased().remove(leftItem);\n        instance.getShared().add(leftItem);\n      } else {\n        instance.getMissing().add(leftItem);\n      }\n    }\n    return instance;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "K", "classes": []}, "name": "diff", "params": [{"name": "instance", "type": "K"}], "body": "                                                                 {\n    if (instance.getOldValue() == null && instance.getNewValue() == null) {\n      return instance;\n    }\n    if (instance.getOldValue() == null) {\n      instance.setIncreased(instance.getNewValue());\n      return instance;\n    }\n    if (instance.getNewValue() == null) {\n      instance.setMissing(instance.getOldValue());\n      return instance;\n    }\n    instance.getIncreased().addAll(instance.getNewValue());\n    for (X leftItem : instance.getOldValue()) {\n      if (instance.getNewValue().contains(leftItem)) {\n        instance.getIncreased().remove(leftItem);\n        instance.getShared().add(leftItem);\n      } else {\n        instance.getMissing().add(leftItem);\n      }\n    }\n    return instance;\n  }", "signature": "public static <K extends ChangedList<X>, X> K diff(K instance)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/HeadersDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\n\nimport io.swagger.v3.oas.models.headers.Header;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.openapitools.openapidiff.core.model.ChangedHeader;\nimport org.openapitools.openapidiff.core.model.ChangedHeaders;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\n\npublic class HeadersDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public HeadersDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedHeaders> diff(\n      Map<String, Header> left, Map<String, Header> right, DiffContext context) {\n    MapKeyDiff<String, Header> headerMapDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedHeaderKeys = headerMapDiff.getSharedKey();\n\n    Map<String, ChangedHeader> changed = new LinkedHashMap<>();\n    DeferredBuilder<ChangedHeader> builder = new DeferredBuilder<>();\n    for (String headerKey : sharedHeaderKeys) {\n      Header oldHeader = left.get(headerKey);\n      Header newHeader = right.get(headerKey);\n      builder\n          .with(openApiDiff.getHeaderDiff().diff(oldHeader, newHeader, context))\n          .ifPresent(changedHeader -> changed.put(headerKey, changedHeader));\n    }\n    return builder\n        .build()\n        .mapOptional(\n            value ->\n                isChanged(\n                    new ChangedHeaders(left, right, context)\n                        .setIncreased(headerMapDiff.getIncreased())\n                        .setMissing(headerMapDiff.getMissing())\n                        .setChanged(changed)));\n  }\n}\n", "file_hash": "2bb3622110ff3b89e3092c61bbbed044c9b4259875cadab1a3cc3a62172b9d56", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import io.swagger.v3.oas.models.headers.Header;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Map;", "import org.openapitools.openapidiff.core.model.ChangedHeader;", "import org.openapitools.openapidiff.core.model.ChangedHeaders;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;"], "methods": [], "classes": [{"original_string": "public class HeadersDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public HeadersDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedHeaders> diff(\n      Map<String, Header> left, Map<String, Header> right, DiffContext context) {\n    MapKeyDiff<String, Header> headerMapDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedHeaderKeys = headerMapDiff.getSharedKey();\n\n    Map<String, ChangedHeader> changed = new LinkedHashMap<>();\n    DeferredBuilder<ChangedHeader> builder = new DeferredBuilder<>();\n    for (String headerKey : sharedHeaderKeys) {\n      Header oldHeader = left.get(headerKey);\n      Header newHeader = right.get(headerKey);\n      builder\n          .with(openApiDiff.getHeaderDiff().diff(oldHeader, newHeader, context))\n          .ifPresent(changedHeader -> changed.put(headerKey, changedHeader));\n    }\n    return builder\n        .build()\n        .mapOptional(\n            value ->\n                isChanged(\n                    new ChangedHeaders(left, right, context)\n                        .setIncreased(headerMapDiff.getIncreased())\n                        .setMissing(headerMapDiff.getMissing())\n                        .setChanged(changed)));\n  }\n}", "definition": "public class HeadersDiff", "class_docstring": "", "name": "HeadersDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public HeadersDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "HeadersDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                              {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public HeadersDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedHeaders> diff(\n      Map<String, Header> left, Map<String, Header> right, DiffContext context) {\n    MapKeyDiff<String, Header> headerMapDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedHeaderKeys = headerMapDiff.getSharedKey();\n\n    Map<String, ChangedHeader> changed = new LinkedHashMap<>();\n    DeferredBuilder<ChangedHeader> builder = new DeferredBuilder<>();\n    for (String headerKey : sharedHeaderKeys) {\n      Header oldHeader = left.get(headerKey);\n      Header newHeader = right.get(headerKey);\n      builder\n          .with(openApiDiff.getHeaderDiff().diff(oldHeader, newHeader, context))\n          .ifPresent(changedHeader -> changed.put(headerKey, changedHeader));\n    }\n    return builder\n        .build()\n        .mapOptional(\n            value ->\n                isChanged(\n                    new ChangedHeaders(left, right, context)\n                        .setIncreased(headerMapDiff.getIncreased())\n                        .setMissing(headerMapDiff.getMissing())\n                        .setChanged(changed)));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedHeaders>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "Map<String, Header>"}, {"name": "right", "type": "Map<String, Header>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                {\n    MapKeyDiff<String, Header> headerMapDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedHeaderKeys = headerMapDiff.getSharedKey();\n\n    Map<String, ChangedHeader> changed = new LinkedHashMap<>();\n    DeferredBuilder<ChangedHeader> builder = new DeferredBuilder<>();\n    for (String headerKey : sharedHeaderKeys) {\n      Header oldHeader = left.get(headerKey);\n      Header newHeader = right.get(headerKey);\n      builder\n          .with(openApiDiff.getHeaderDiff().diff(oldHeader, newHeader, context))\n          .ifPresent(changedHeader -> changed.put(headerKey, changedHeader));\n    }\n    return builder\n        .build()\n        .mapOptional(\n            value ->\n                isChanged(\n                    new ChangedHeaders(left, right, context)\n                        .setIncreased(headerMapDiff.getIncreased())\n                        .setMissing(headerMapDiff.getMissing())\n                        .setChanged(changed)));\n  }", "signature": "public DeferredChanged<ChangedHeaders> diff(\n      Map<String, Header> left, Map<String, Header> right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/OperationDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\n\nimport io.swagger.v3.oas.models.Operation;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedOperation;\nimport org.openapitools.openapidiff.core.model.ChangedParameters;\nimport org.openapitools.openapidiff.core.model.ComposedChanged;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class OperationDiff {\n  private static final Logger log = LoggerFactory.getLogger(OperationDiff.class);\n\n  private final OpenApiDiff openApiDiff;\n\n  public OperationDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedOperation> diff(\n      Operation oldOperation, Operation newOperation, DiffContext context) {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedOperation changedOperation =\n        new ChangedOperation(context.getUrl(), context.getMethod(), oldOperation, newOperation);\n\n    log.debug(\n        \"Diff operation {} {}\", changedOperation.getPathUrl(), changedOperation.getHttpMethod());\n\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getSummary(), newOperation.getSummary(), context))\n        .ifPresent(changedOperation::setSummary);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getDescription(), newOperation.getDescription(), context))\n        .ifPresent(changedOperation::setDescription);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getOperationId(), newOperation.getOperationId(), context))\n        .ifPresent(changedOperation::setOperationId);\n    changedOperation.setDeprecated(\n        !Boolean.TRUE.equals(oldOperation.getDeprecated())\n            && Boolean.TRUE.equals(newOperation.getDeprecated()));\n\n    if (oldOperation.getRequestBody() != null || newOperation.getRequestBody() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getRequestBodyDiff()\n                  .diff(\n                      oldOperation.getRequestBody(),\n                      newOperation.getRequestBody(),\n                      context.copyAsRequest()))\n          .ifPresent(changedOperation::setRequestBody);\n    }\n\n    ParametersDiffResult parametersDiffResult =\n        openApiDiff\n            .getParametersDiff()\n            .diff(oldOperation.getParameters(), newOperation.getParameters(), context);\n    builder\n        .with(parametersDiffResult.deferredChanged)\n        .ifPresent(\n            params -> {\n              if (!parametersDiffResult.sameOperationsDiffSchema) {\n                removePathParameters(context.getParameters(), params);\n              }\n              changedOperation.setParameters(params);\n            });\n\n    if (oldOperation.getResponses() != null || newOperation.getResponses() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getApiResponseDiff()\n                  .diff(\n                      oldOperation.getResponses(),\n                      newOperation.getResponses(),\n                      context.copyAsResponse()))\n          .ifPresent(\n              responses -> {\n                log.debug(\n                    \"operation \"\n                        + changedOperation.getPathUrl()\n                        + \" \"\n                        + changedOperation.getHttpMethod()\n                        + \" setting api responses \"\n                        + responses.getChangedElements().stream()\n                            .filter(Objects::nonNull)\n                            .map(Changed::isChanged)\n                            .filter(Objects::nonNull)\n                            .map(Enum::toString)\n                            .collect(Collectors.joining(\",\")));\n                changedOperation.setApiResponses(responses);\n              });\n    }\n\n    if (oldOperation.getSecurity() != null || newOperation.getSecurity() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getSecurityRequirementsDiff()\n                  .diff(oldOperation.getSecurity(), newOperation.getSecurity(), context))\n          .ifPresent(changedOperation::setSecurityRequirements);\n    }\n\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(oldOperation.getExtensions(), newOperation.getExtensions(), context))\n        .ifPresent(changedOperation::setExtensions);\n\n    return builder\n        .build()\n        .mapOptional(\n            value -> {\n              Optional<ChangedOperation> changed = isChanged(changedOperation);\n              log.debug(\n                  \"Is changed operation \"\n                      + changedOperation.getPathUrl()\n                      + \" \"\n                      + changedOperation.getHttpMethod()\n                      + \" changed: \"\n                      + changed.map(ComposedChanged::isChanged).orElse(null));\n              return changed;\n            });\n  }\n\n  public void removePathParameters(Map<String, String> pathParameters, ChangedParameters params) {\n    pathParameters.forEach(\n        (oldParam, newParam) -> {\n          removePathParameter(oldParam, params.getMissing());\n          removePathParameter(newParam, params.getIncreased());\n        });\n  }\n\n  public void removePathParameter(String name, List<Parameter> parameters) {\n    parameters.stream()\n        .filter(p -> \"path\".equals(p.getIn()) && name.equals(p.getName()))\n        .findFirst()\n        .ifPresent(parameters::remove);\n  }\n}\n", "file_hash": "5ff893873b55f098afcb802922b8e056d15bc4769a94222fbcbfea5adbac62db", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import io.swagger.v3.oas.models.Operation;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import java.util.List;", "import java.util.Map;", "import java.util.Objects;", "import java.util.Optional;", "import java.util.stream.Collectors;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedOperation;", "import org.openapitools.openapidiff.core.model.ChangedParameters;", "import org.openapitools.openapidiff.core.model.ComposedChanged;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.slf4j.Logger;", "import org.slf4j.LoggerFactory;"], "methods": [], "classes": [{"original_string": "public class OperationDiff {\n  private static final Logger log = LoggerFactory.getLogger(OperationDiff.class);\n\n  private final OpenApiDiff openApiDiff;\n\n  public OperationDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedOperation> diff(\n      Operation oldOperation, Operation newOperation, DiffContext context) {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedOperation changedOperation =\n        new ChangedOperation(context.getUrl(), context.getMethod(), oldOperation, newOperation);\n\n    log.debug(\n        \"Diff operation {} {}\", changedOperation.getPathUrl(), changedOperation.getHttpMethod());\n\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getSummary(), newOperation.getSummary(), context))\n        .ifPresent(changedOperation::setSummary);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getDescription(), newOperation.getDescription(), context))\n        .ifPresent(changedOperation::setDescription);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getOperationId(), newOperation.getOperationId(), context))\n        .ifPresent(changedOperation::setOperationId);\n    changedOperation.setDeprecated(\n        !Boolean.TRUE.equals(oldOperation.getDeprecated())\n            && Boolean.TRUE.equals(newOperation.getDeprecated()));\n\n    if (oldOperation.getRequestBody() != null || newOperation.getRequestBody() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getRequestBodyDiff()\n                  .diff(\n                      oldOperation.getRequestBody(),\n                      newOperation.getRequestBody(),\n                      context.copyAsRequest()))\n          .ifPresent(changedOperation::setRequestBody);\n    }\n\n    ParametersDiffResult parametersDiffResult =\n        openApiDiff\n            .getParametersDiff()\n            .diff(oldOperation.getParameters(), newOperation.getParameters(), context);\n    builder\n        .with(parametersDiffResult.deferredChanged)\n        .ifPresent(\n            params -> {\n              if (!parametersDiffResult.sameOperationsDiffSchema) {\n                removePathParameters(context.getParameters(), params);\n              }\n              changedOperation.setParameters(params);\n            });\n\n    if (oldOperation.getResponses() != null || newOperation.getResponses() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getApiResponseDiff()\n                  .diff(\n                      oldOperation.getResponses(),\n                      newOperation.getResponses(),\n                      context.copyAsResponse()))\n          .ifPresent(\n              responses -> {\n                log.debug(\n                    \"operation \"\n                        + changedOperation.getPathUrl()\n                        + \" \"\n                        + changedOperation.getHttpMethod()\n                        + \" setting api responses \"\n                        + responses.getChangedElements().stream()\n                            .filter(Objects::nonNull)\n                            .map(Changed::isChanged)\n                            .filter(Objects::nonNull)\n                            .map(Enum::toString)\n                            .collect(Collectors.joining(\",\")));\n                changedOperation.setApiResponses(responses);\n              });\n    }\n\n    if (oldOperation.getSecurity() != null || newOperation.getSecurity() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getSecurityRequirementsDiff()\n                  .diff(oldOperation.getSecurity(), newOperation.getSecurity(), context))\n          .ifPresent(changedOperation::setSecurityRequirements);\n    }\n\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(oldOperation.getExtensions(), newOperation.getExtensions(), context))\n        .ifPresent(changedOperation::setExtensions);\n\n    return builder\n        .build()\n        .mapOptional(\n            value -> {\n              Optional<ChangedOperation> changed = isChanged(changedOperation);\n              log.debug(\n                  \"Is changed operation \"\n                      + changedOperation.getPathUrl()\n                      + \" \"\n                      + changedOperation.getHttpMethod()\n                      + \" changed: \"\n                      + changed.map(ComposedChanged::isChanged).orElse(null));\n              return changed;\n            });\n  }\n\n  public void removePathParameters(Map<String, String> pathParameters, ChangedParameters params) {\n    pathParameters.forEach(\n        (oldParam, newParam) -> {\n          removePathParameter(oldParam, params.getMissing());\n          removePathParameter(newParam, params.getIncreased());\n        });\n  }\n\n  public void removePathParameter(String name, List<Parameter> parameters) {\n    parameters.stream()\n        .filter(p -> \"path\".equals(p.getIn()) && name.equals(p.getName()))\n        .findFirst()\n        .ifPresent(parameters::remove);\n  }\n}", "definition": "public class OperationDiff", "class_docstring": "", "name": "OperationDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Logger log = LoggerFactory.getLogger(OperationDiff.class);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "log = LoggerFactory.getLogger(OperationDiff.class)", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public OperationDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "OperationDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public OperationDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedOperation> diff(\n      Operation oldOperation, Operation newOperation, DiffContext context) {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedOperation changedOperation =\n        new ChangedOperation(context.getUrl(), context.getMethod(), oldOperation, newOperation);\n\n    log.debug(\n        \"Diff operation {} {}\", changedOperation.getPathUrl(), changedOperation.getHttpMethod());\n\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getSummary(), newOperation.getSummary(), context))\n        .ifPresent(changedOperation::setSummary);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getDescription(), newOperation.getDescription(), context))\n        .ifPresent(changedOperation::setDescription);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getOperationId(), newOperation.getOperationId(), context))\n        .ifPresent(changedOperation::setOperationId);\n    changedOperation.setDeprecated(\n        !Boolean.TRUE.equals(oldOperation.getDeprecated())\n            && Boolean.TRUE.equals(newOperation.getDeprecated()));\n\n    if (oldOperation.getRequestBody() != null || newOperation.getRequestBody() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getRequestBodyDiff()\n                  .diff(\n                      oldOperation.getRequestBody(),\n                      newOperation.getRequestBody(),\n                      context.copyAsRequest()))\n          .ifPresent(changedOperation::setRequestBody);\n    }\n\n    ParametersDiffResult parametersDiffResult =\n        openApiDiff\n            .getParametersDiff()\n            .diff(oldOperation.getParameters(), newOperation.getParameters(), context);\n    builder\n        .with(parametersDiffResult.deferredChanged)\n        .ifPresent(\n            params -> {\n              if (!parametersDiffResult.sameOperationsDiffSchema) {\n                removePathParameters(context.getParameters(), params);\n              }\n              changedOperation.setParameters(params);\n            });\n\n    if (oldOperation.getResponses() != null || newOperation.getResponses() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getApiResponseDiff()\n                  .diff(\n                      oldOperation.getResponses(),\n                      newOperation.getResponses(),\n                      context.copyAsResponse()))\n          .ifPresent(\n              responses -> {\n                log.debug(\n                    \"operation \"\n                        + changedOperation.getPathUrl()\n                        + \" \"\n                        + changedOperation.getHttpMethod()\n                        + \" setting api responses \"\n                        + responses.getChangedElements().stream()\n                            .filter(Objects::nonNull)\n                            .map(Changed::isChanged)\n                            .filter(Objects::nonNull)\n                            .map(Enum::toString)\n                            .collect(Collectors.joining(\",\")));\n                changedOperation.setApiResponses(responses);\n              });\n    }\n\n    if (oldOperation.getSecurity() != null || newOperation.getSecurity() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getSecurityRequirementsDiff()\n                  .diff(oldOperation.getSecurity(), newOperation.getSecurity(), context))\n          .ifPresent(changedOperation::setSecurityRequirements);\n    }\n\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(oldOperation.getExtensions(), newOperation.getExtensions(), context))\n        .ifPresent(changedOperation::setExtensions);\n\n    return builder\n        .build()\n        .mapOptional(\n            value -> {\n              Optional<ChangedOperation> changed = isChanged(changedOperation);\n              log.debug(\n                  \"Is changed operation \"\n                      + changedOperation.getPathUrl()\n                      + \" \"\n                      + changedOperation.getHttpMethod()\n                      + \" changed: \"\n                      + changed.map(ComposedChanged::isChanged).orElse(null));\n              return changed;\n            });\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedOperation>", "classes": []}, "name": "diff", "params": [{"name": "oldOperation", "type": "Operation"}, {"name": "newOperation", "type": "Operation"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                           {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedOperation changedOperation =\n        new ChangedOperation(context.getUrl(), context.getMethod(), oldOperation, newOperation);\n\n    log.debug(\n        \"Diff operation {} {}\", changedOperation.getPathUrl(), changedOperation.getHttpMethod());\n\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getSummary(), newOperation.getSummary(), context))\n        .ifPresent(changedOperation::setSummary);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getDescription(), newOperation.getDescription(), context))\n        .ifPresent(changedOperation::setDescription);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(oldOperation.getOperationId(), newOperation.getOperationId(), context))\n        .ifPresent(changedOperation::setOperationId);\n    changedOperation.setDeprecated(\n        !Boolean.TRUE.equals(oldOperation.getDeprecated())\n            && Boolean.TRUE.equals(newOperation.getDeprecated()));\n\n    if (oldOperation.getRequestBody() != null || newOperation.getRequestBody() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getRequestBodyDiff()\n                  .diff(\n                      oldOperation.getRequestBody(),\n                      newOperation.getRequestBody(),\n                      context.copyAsRequest()))\n          .ifPresent(changedOperation::setRequestBody);\n    }\n\n    ParametersDiffResult parametersDiffResult =\n        openApiDiff\n            .getParametersDiff()\n            .diff(oldOperation.getParameters(), newOperation.getParameters(), context);\n    builder\n        .with(parametersDiffResult.deferredChanged)\n        .ifPresent(\n            params -> {\n              if (!parametersDiffResult.sameOperationsDiffSchema) {\n                removePathParameters(context.getParameters(), params);\n              }\n              changedOperation.setParameters(params);\n            });\n\n    if (oldOperation.getResponses() != null || newOperation.getResponses() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getApiResponseDiff()\n                  .diff(\n                      oldOperation.getResponses(),\n                      newOperation.getResponses(),\n                      context.copyAsResponse()))\n          .ifPresent(\n              responses -> {\n                log.debug(\n                    \"operation \"\n                        + changedOperation.getPathUrl()\n                        + \" \"\n                        + changedOperation.getHttpMethod()\n                        + \" setting api responses \"\n                        + responses.getChangedElements().stream()\n                            .filter(Objects::nonNull)\n                            .map(Changed::isChanged)\n                            .filter(Objects::nonNull)\n                            .map(Enum::toString)\n                            .collect(Collectors.joining(\",\")));\n                changedOperation.setApiResponses(responses);\n              });\n    }\n\n    if (oldOperation.getSecurity() != null || newOperation.getSecurity() != null) {\n      builder\n          .with(\n              openApiDiff\n                  .getSecurityRequirementsDiff()\n                  .diff(oldOperation.getSecurity(), newOperation.getSecurity(), context))\n          .ifPresent(changedOperation::setSecurityRequirements);\n    }\n\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(oldOperation.getExtensions(), newOperation.getExtensions(), context))\n        .ifPresent(changedOperation::setExtensions);\n\n    return builder\n        .build()\n        .mapOptional(\n            value -> {\n              Optional<ChangedOperation> changed = isChanged(changedOperation);\n              log.debug(\n                  \"Is changed operation \"\n                      + changedOperation.getPathUrl()\n                      + \" \"\n                      + changedOperation.getHttpMethod()\n                      + \" changed: \"\n                      + changed.map(ComposedChanged::isChanged).orElse(null));\n              return changed;\n            });\n  }", "signature": "public DeferredChanged<ChangedOperation> diff(\n      Operation oldOperation, Operation newOperation, DiffContext context)"}, {"syntax_pass": true, "original_string": "  public void removePathParameters(Map<String, String> pathParameters, ChangedParameters params) {\n    pathParameters.forEach(\n        (oldParam, newParam) -> {\n          removePathParameter(oldParam, params.getMissing());\n          removePathParameter(newParam, params.getIncreased());\n        });\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "removePathParameters", "params": [{"name": "pathParameters", "type": "Map<String, String>"}, {"name": "params", "type": "ChangedParameters"}], "body": "                                                                                                 {\n    pathParameters.forEach(\n        (oldParam, newParam) -> {\n          removePathParameter(oldParam, params.getMissing());\n          removePathParameter(newParam, params.getIncreased());\n        });\n  }", "signature": "public void removePathParameters(Map<String, String> pathParameters, ChangedParameters params)"}, {"syntax_pass": true, "original_string": "  public void removePathParameter(String name, List<Parameter> parameters) {\n    parameters.stream()\n        .filter(p -> \"path\".equals(p.getIn()) && name.equals(p.getName()))\n        .findFirst()\n        .ifPresent(parameters::remove);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "removePathParameter", "params": [{"name": "name", "type": "String"}, {"name": "parameters", "type": "List<Parameter>"}], "body": "                                                                           {\n    parameters.stream()\n        .filter(p -> \"path\".equals(p.getIn()) && name.equals(p.getName()))\n        .findFirst()\n        .ifPresent(parameters::remove);\n  }", "signature": "public void removePathParameter(String name, List<Parameter> parameters)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/RequestBodyDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static java.util.Optional.ofNullable;\n\nimport io.swagger.v3.oas.models.media.Content;\nimport io.swagger.v3.oas.models.parameters.RequestBody;\nimport java.util.HashSet;\nimport java.util.Map;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedRequestBody;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\npublic class RequestBodyDiff extends ReferenceDiffCache<RequestBody, ChangedRequestBody> {\n  private static final RefPointer<RequestBody> refPointer =\n      new RefPointer<>(RefType.REQUEST_BODIES);\n  private final OpenApiDiff openApiDiff;\n\n  public RequestBodyDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  private static Map<String, Object> getExtensions(RequestBody body) {\n    return ofNullable(body).map(RequestBody::getExtensions).orElse(null);\n  }\n\n  public DeferredChanged<ChangedRequestBody> diff(\n      RequestBody left, RequestBody right, DiffContext context) {\n    String leftRef = left != null ? left.get$ref() : null;\n    String rightRef = right != null ? right.get$ref() : null;\n    return cachedDiff(new HashSet<>(), left, right, leftRef, rightRef, context);\n  }\n\n  @Override\n  protected DeferredChanged<ChangedRequestBody> computeDiff(\n      HashSet<String> refSet, RequestBody left, RequestBody right, DiffContext context) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    Content oldRequestContent = new Content();\n    Content newRequestContent = new Content();\n    RequestBody oldRequestBody = null;\n    RequestBody newRequestBody = null;\n    if (left != null) {\n      oldRequestBody =\n          refPointer.resolveRef(\n              openApiDiff.getOldSpecOpenApi().getComponents(), left, left.get$ref());\n      if (oldRequestBody.getContent() != null) {\n        oldRequestContent = oldRequestBody.getContent();\n      }\n    }\n    if (right != null) {\n      newRequestBody =\n          refPointer.resolveRef(\n              openApiDiff.getNewSpecOpenApi().getComponents(), right, right.get$ref());\n      if (newRequestBody.getContent() != null) {\n        newRequestContent = newRequestBody.getContent();\n      }\n    }\n    boolean leftRequired =\n        oldRequestBody != null && Boolean.TRUE.equals(oldRequestBody.getRequired());\n    boolean rightRequired =\n        newRequestBody != null && Boolean.TRUE.equals(newRequestBody.getRequired());\n\n    ChangedRequestBody changedRequestBody =\n        new ChangedRequestBody(oldRequestBody, newRequestBody, context)\n            .setChangeRequired(leftRequired != rightRequired);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(\n                    oldRequestBody != null ? oldRequestBody.getDescription() : null,\n                    newRequestBody != null ? newRequestBody.getDescription() : null,\n                    context))\n        .ifPresent(changedRequestBody::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(oldRequestContent, newRequestContent, context))\n        .ifPresent(changedRequestBody::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(getExtensions(left), getExtensions(right), context))\n        .ifPresent(changedRequestBody::setExtensions);\n\n    return builder.buildIsChanged(changedRequestBody);\n  }\n}\n", "file_hash": "f0a21c98c83723bac41d937d576e6f17a02bab9e45a2ff18722cc92919c6aa59", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static java.util.Optional.ofNullable;", "import io.swagger.v3.oas.models.media.Content;", "import io.swagger.v3.oas.models.parameters.RequestBody;", "import java.util.HashSet;", "import java.util.Map;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedRequestBody;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "public class RequestBodyDiff extends ReferenceDiffCache<RequestBody, ChangedRequestBody> {\n  private static final RefPointer<RequestBody> refPointer =\n      new RefPointer<>(RefType.REQUEST_BODIES);\n  private final OpenApiDiff openApiDiff;\n\n  public RequestBodyDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  private static Map<String, Object> getExtensions(RequestBody body) {\n    return ofNullable(body).map(RequestBody::getExtensions).orElse(null);\n  }\n\n  public DeferredChanged<ChangedRequestBody> diff(\n      RequestBody left, RequestBody right, DiffContext context) {\n    String leftRef = left != null ? left.get$ref() : null;\n    String rightRef = right != null ? right.get$ref() : null;\n    return cachedDiff(new HashSet<>(), left, right, leftRef, rightRef, context);\n  }\n\n  @Override\n  protected DeferredChanged<ChangedRequestBody> computeDiff(\n      HashSet<String> refSet, RequestBody left, RequestBody right, DiffContext context) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    Content oldRequestContent = new Content();\n    Content newRequestContent = new Content();\n    RequestBody oldRequestBody = null;\n    RequestBody newRequestBody = null;\n    if (left != null) {\n      oldRequestBody =\n          refPointer.resolveRef(\n              openApiDiff.getOldSpecOpenApi().getComponents(), left, left.get$ref());\n      if (oldRequestBody.getContent() != null) {\n        oldRequestContent = oldRequestBody.getContent();\n      }\n    }\n    if (right != null) {\n      newRequestBody =\n          refPointer.resolveRef(\n              openApiDiff.getNewSpecOpenApi().getComponents(), right, right.get$ref());\n      if (newRequestBody.getContent() != null) {\n        newRequestContent = newRequestBody.getContent();\n      }\n    }\n    boolean leftRequired =\n        oldRequestBody != null && Boolean.TRUE.equals(oldRequestBody.getRequired());\n    boolean rightRequired =\n        newRequestBody != null && Boolean.TRUE.equals(newRequestBody.getRequired());\n\n    ChangedRequestBody changedRequestBody =\n        new ChangedRequestBody(oldRequestBody, newRequestBody, context)\n            .setChangeRequired(leftRequired != rightRequired);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(\n                    oldRequestBody != null ? oldRequestBody.getDescription() : null,\n                    newRequestBody != null ? newRequestBody.getDescription() : null,\n                    context))\n        .ifPresent(changedRequestBody::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(oldRequestContent, newRequestContent, context))\n        .ifPresent(changedRequestBody::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(getExtensions(left), getExtensions(right), context))\n        .ifPresent(changedRequestBody::setExtensions);\n\n    return builder.buildIsChanged(changedRequestBody);\n  }\n}", "definition": "public class RequestBodyDiff extends ReferenceDiffCache<RequestBody, ChangedRequestBody>", "class_docstring": "", "name": "RequestBodyDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final RefPointer<RequestBody> refPointer =\n      new RefPointer<>(RefType.REQUEST_BODIES);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RefPointer<RequestBody>", "name": "refPointer =\n      new RefPointer<>(RefType.REQUEST_BODIES)", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public RequestBodyDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "RequestBodyDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                  {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public RequestBodyDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  private static Map<String, Object> getExtensions(RequestBody body) {\n    return ofNullable(body).map(RequestBody::getExtensions).orElse(null);\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "getExtensions", "params": [{"name": "body", "type": "RequestBody"}], "body": "                                                                     {\n    return ofNullable(body).map(RequestBody::getExtensions).orElse(null);\n  }", "signature": "private static Map<String, Object> getExtensions(RequestBody body)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedRequestBody> diff(\n      RequestBody left, RequestBody right, DiffContext context) {\n    String leftRef = left != null ? left.get$ref() : null;\n    String rightRef = right != null ? right.get$ref() : null;\n    return cachedDiff(new HashSet<>(), left, right, leftRef, rightRef, context);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedRequestBody>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "RequestBody"}, {"name": "right", "type": "RequestBody"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                {\n    String leftRef = left != null ? left.get$ref() : null;\n    String rightRef = right != null ? right.get$ref() : null;\n    return cachedDiff(new HashSet<>(), left, right, leftRef, rightRef, context);\n  }", "signature": "public DeferredChanged<ChangedRequestBody> diff(\n      RequestBody left, RequestBody right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  protected DeferredChanged<ChangedRequestBody> computeDiff(\n      HashSet<String> refSet, RequestBody left, RequestBody right, DiffContext context) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    Content oldRequestContent = new Content();\n    Content newRequestContent = new Content();\n    RequestBody oldRequestBody = null;\n    RequestBody newRequestBody = null;\n    if (left != null) {\n      oldRequestBody =\n          refPointer.resolveRef(\n              openApiDiff.getOldSpecOpenApi().getComponents(), left, left.get$ref());\n      if (oldRequestBody.getContent() != null) {\n        oldRequestContent = oldRequestBody.getContent();\n      }\n    }\n    if (right != null) {\n      newRequestBody =\n          refPointer.resolveRef(\n              openApiDiff.getNewSpecOpenApi().getComponents(), right, right.get$ref());\n      if (newRequestBody.getContent() != null) {\n        newRequestContent = newRequestBody.getContent();\n      }\n    }\n    boolean leftRequired =\n        oldRequestBody != null && Boolean.TRUE.equals(oldRequestBody.getRequired());\n    boolean rightRequired =\n        newRequestBody != null && Boolean.TRUE.equals(newRequestBody.getRequired());\n\n    ChangedRequestBody changedRequestBody =\n        new ChangedRequestBody(oldRequestBody, newRequestBody, context)\n            .setChangeRequired(leftRequired != rightRequired);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(\n                    oldRequestBody != null ? oldRequestBody.getDescription() : null,\n                    newRequestBody != null ? newRequestBody.getDescription() : null,\n                    context))\n        .ifPresent(changedRequestBody::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(oldRequestContent, newRequestContent, context))\n        .ifPresent(changedRequestBody::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(getExtensions(left), getExtensions(right), context))\n        .ifPresent(changedRequestBody::setExtensions);\n\n    return builder.buildIsChanged(changedRequestBody);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "DeferredChanged<ChangedRequestBody>", "classes": []}, "name": "computeDiff", "params": [{"name": "refSet", "type": "HashSet<String>"}, {"name": "left", "type": "RequestBody"}, {"name": "right", "type": "RequestBody"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                        {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    Content oldRequestContent = new Content();\n    Content newRequestContent = new Content();\n    RequestBody oldRequestBody = null;\n    RequestBody newRequestBody = null;\n    if (left != null) {\n      oldRequestBody =\n          refPointer.resolveRef(\n              openApiDiff.getOldSpecOpenApi().getComponents(), left, left.get$ref());\n      if (oldRequestBody.getContent() != null) {\n        oldRequestContent = oldRequestBody.getContent();\n      }\n    }\n    if (right != null) {\n      newRequestBody =\n          refPointer.resolveRef(\n              openApiDiff.getNewSpecOpenApi().getComponents(), right, right.get$ref());\n      if (newRequestBody.getContent() != null) {\n        newRequestContent = newRequestBody.getContent();\n      }\n    }\n    boolean leftRequired =\n        oldRequestBody != null && Boolean.TRUE.equals(oldRequestBody.getRequired());\n    boolean rightRequired =\n        newRequestBody != null && Boolean.TRUE.equals(newRequestBody.getRequired());\n\n    ChangedRequestBody changedRequestBody =\n        new ChangedRequestBody(oldRequestBody, newRequestBody, context)\n            .setChangeRequired(leftRequired != rightRequired);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(\n                    oldRequestBody != null ? oldRequestBody.getDescription() : null,\n                    newRequestBody != null ? newRequestBody.getDescription() : null,\n                    context))\n        .ifPresent(changedRequestBody::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(oldRequestContent, newRequestContent, context))\n        .ifPresent(changedRequestBody::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(getExtensions(left), getExtensions(right), context))\n        .ifPresent(changedRequestBody::setExtensions);\n\n    return builder.buildIsChanged(changedRequestBody);\n  }", "signature": "@Override\n  protected DeferredChanged<ChangedRequestBody> computeDiff(\n      HashSet<String> refSet, RequestBody left, RequestBody right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/SecurityRequirementsDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.security.SecurityRequirement;\nimport io.swagger.v3.oas.models.security.SecurityScheme;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.apache.commons.lang3.tuple.ImmutablePair;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedSecurityRequirements;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\n\npublic class SecurityRequirementsDiff {\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public SecurityRequirementsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public Optional<SecurityRequirement> contains(\n      List<SecurityRequirement> securityRequirements, SecurityRequirement left) {\n    return securityRequirements.stream()\n        .filter(rightSecurities -> same(left, rightSecurities))\n        .findFirst();\n  }\n\n  public boolean same(SecurityRequirement left, SecurityRequirement right) {\n    List<Pair<SecurityScheme.Type, SecurityScheme.In>> leftTypes =\n        getListOfSecuritySchemes(leftComponents, left);\n    List<Pair<SecurityScheme.Type, SecurityScheme.In>> rightTypes =\n        getListOfSecuritySchemes(rightComponents, right);\n\n    return CollectionUtils.isEqualCollection(leftTypes, rightTypes);\n  }\n\n  private List<Pair<SecurityScheme.Type, SecurityScheme.In>> getListOfSecuritySchemes(\n      Components components, SecurityRequirement securityRequirement) {\n    return securityRequirement.keySet().stream()\n        .map(\n            x -> {\n              if (components == null) {\n                throw new IllegalArgumentException(\"Missing securitySchemes component definition.\");\n              }\n              Map<String, SecurityScheme> securitySchemes = components.getSecuritySchemes();\n              if (securitySchemes == null) {\n                throw new IllegalArgumentException(\"Missing securitySchemes component definition.\");\n              }\n\n              SecurityScheme result = securitySchemes.get(x);\n              if (result == null) {\n                throw new IllegalArgumentException(\"Impossible to find security scheme: \" + x);\n              }\n\n              return result;\n            })\n        .map(this::getPair)\n        .distinct()\n        .collect(Collectors.toList());\n  }\n\n  private Pair<SecurityScheme.Type, SecurityScheme.In> getPair(SecurityScheme securityScheme) {\n    return new ImmutablePair<>(securityScheme.getType(), securityScheme.getIn());\n  }\n\n  protected DeferredChanged<ChangedSecurityRequirements> diff(\n      List<SecurityRequirement> left, List<SecurityRequirement> right, DiffContext context) {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    left = left == null ? new ArrayList<>() : left;\n    right = right == null ? new ArrayList<>() : getCopy(right);\n\n    ChangedSecurityRequirements changedSecurityRequirements =\n        new ChangedSecurityRequirements(left, right, context);\n\n    for (SecurityRequirement leftSecurity : left) {\n      Optional<SecurityRequirement> rightSecOpt = contains(right, leftSecurity);\n      if (!rightSecOpt.isPresent()) {\n        changedSecurityRequirements.addMissing(leftSecurity);\n      } else {\n        SecurityRequirement rightSec = rightSecOpt.get();\n        right.remove(rightSec);\n        builder\n            .with(openApiDiff.getSecurityRequirementDiff().diff(leftSecurity, rightSec, context))\n            .ifPresent(changedSecurityRequirements::addChanged);\n      }\n    }\n    right.forEach(changedSecurityRequirements::addIncreased);\n\n    return builder.buildIsChanged(changedSecurityRequirements);\n  }\n\n  private List<SecurityRequirement> getCopy(List<SecurityRequirement> right) {\n    return right.stream().map(SecurityRequirementDiff::getCopy).collect(Collectors.toList());\n  }\n}\n", "file_hash": "6f26b6e7fbaeeae1521b9bc969c0b261252199c0271beb6fb8b794211316cd1e", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.security.SecurityRequirement;", "import io.swagger.v3.oas.models.security.SecurityScheme;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Map;", "import java.util.Optional;", "import java.util.stream.Collectors;", "import org.apache.commons.collections4.CollectionUtils;", "import org.apache.commons.lang3.tuple.ImmutablePair;", "import org.apache.commons.lang3.tuple.Pair;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedSecurityRequirements;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;"], "methods": [], "classes": [{"original_string": "public class SecurityRequirementsDiff {\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public SecurityRequirementsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public Optional<SecurityRequirement> contains(\n      List<SecurityRequirement> securityRequirements, SecurityRequirement left) {\n    return securityRequirements.stream()\n        .filter(rightSecurities -> same(left, rightSecurities))\n        .findFirst();\n  }\n\n  public boolean same(SecurityRequirement left, SecurityRequirement right) {\n    List<Pair<SecurityScheme.Type, SecurityScheme.In>> leftTypes =\n        getListOfSecuritySchemes(leftComponents, left);\n    List<Pair<SecurityScheme.Type, SecurityScheme.In>> rightTypes =\n        getListOfSecuritySchemes(rightComponents, right);\n\n    return CollectionUtils.isEqualCollection(leftTypes, rightTypes);\n  }\n\n  private List<Pair<SecurityScheme.Type, SecurityScheme.In>> getListOfSecuritySchemes(\n      Components components, SecurityRequirement securityRequirement) {\n    return securityRequirement.keySet().stream()\n        .map(\n            x -> {\n              if (components == null) {\n                throw new IllegalArgumentException(\"Missing securitySchemes component definition.\");\n              }\n              Map<String, SecurityScheme> securitySchemes = components.getSecuritySchemes();\n              if (securitySchemes == null) {\n                throw new IllegalArgumentException(\"Missing securitySchemes component definition.\");\n              }\n\n              SecurityScheme result = securitySchemes.get(x);\n              if (result == null) {\n                throw new IllegalArgumentException(\"Impossible to find security scheme: \" + x);\n              }\n\n              return result;\n            })\n        .map(this::getPair)\n        .distinct()\n        .collect(Collectors.toList());\n  }\n\n  private Pair<SecurityScheme.Type, SecurityScheme.In> getPair(SecurityScheme securityScheme) {\n    return new ImmutablePair<>(securityScheme.getType(), securityScheme.getIn());\n  }\n\n  protected DeferredChanged<ChangedSecurityRequirements> diff(\n      List<SecurityRequirement> left, List<SecurityRequirement> right, DiffContext context) {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    left = left == null ? new ArrayList<>() : left;\n    right = right == null ? new ArrayList<>() : getCopy(right);\n\n    ChangedSecurityRequirements changedSecurityRequirements =\n        new ChangedSecurityRequirements(left, right, context);\n\n    for (SecurityRequirement leftSecurity : left) {\n      Optional<SecurityRequirement> rightSecOpt = contains(right, leftSecurity);\n      if (!rightSecOpt.isPresent()) {\n        changedSecurityRequirements.addMissing(leftSecurity);\n      } else {\n        SecurityRequirement rightSec = rightSecOpt.get();\n        right.remove(rightSec);\n        builder\n            .with(openApiDiff.getSecurityRequirementDiff().diff(leftSecurity, rightSec, context))\n            .ifPresent(changedSecurityRequirements::addChanged);\n      }\n    }\n    right.forEach(changedSecurityRequirements::addIncreased);\n\n    return builder.buildIsChanged(changedSecurityRequirements);\n  }\n\n  private List<SecurityRequirement> getCopy(List<SecurityRequirement> right) {\n    return right.stream().map(SecurityRequirementDiff::getCopy).collect(Collectors.toList());\n  }\n}", "definition": "public class SecurityRequirementsDiff", "class_docstring": "", "name": "SecurityRequirementsDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}, {"attribute_expression": "private final Components leftComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "leftComponents", "syntax_pass": true}, {"attribute_expression": "private final Components rightComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "rightComponents", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public SecurityRequirementsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SecurityRequirementsDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                           {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "signature": "public SecurityRequirementsDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public Optional<SecurityRequirement> contains(\n      List<SecurityRequirement> securityRequirements, SecurityRequirement left) {\n    return securityRequirements.stream()\n        .filter(rightSecurities -> same(left, rightSecurities))\n        .findFirst();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<SecurityRequirement>", "classes": []}, "name": "contains", "params": [{"name": "securityRequirements", "type": "List<SecurityRequirement>"}, {"name": "left", "type": "SecurityRequirement"}], "body": "                                                                                {\n    return securityRequirements.stream()\n        .filter(rightSecurities -> same(left, rightSecurities))\n        .findFirst();\n  }", "signature": "public Optional<SecurityRequirement> contains(\n      List<SecurityRequirement> securityRequirements, SecurityRequirement left)"}, {"syntax_pass": true, "original_string": "  public boolean same(SecurityRequirement left, SecurityRequirement right) {\n    List<Pair<SecurityScheme.Type, SecurityScheme.In>> leftTypes =\n        getListOfSecuritySchemes(leftComponents, left);\n    List<Pair<SecurityScheme.Type, SecurityScheme.In>> rightTypes =\n        getListOfSecuritySchemes(rightComponents, right);\n\n    return CollectionUtils.isEqualCollection(leftTypes, rightTypes);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "same", "params": [{"name": "left", "type": "SecurityRequirement"}, {"name": "right", "type": "SecurityRequirement"}], "body": "                                                                           {\n    List<Pair<SecurityScheme.Type, SecurityScheme.In>> leftTypes =\n        getListOfSecuritySchemes(leftComponents, left);\n    List<Pair<SecurityScheme.Type, SecurityScheme.In>> rightTypes =\n        getListOfSecuritySchemes(rightComponents, right);\n\n    return CollectionUtils.isEqualCollection(leftTypes, rightTypes);\n  }", "signature": "public boolean same(SecurityRequirement left, SecurityRequirement right)"}, {"syntax_pass": true, "original_string": "  private List<Pair<SecurityScheme.Type, SecurityScheme.In>> getListOfSecuritySchemes(\n      Components components, SecurityRequirement securityRequirement) {\n    return securityRequirement.keySet().stream()\n        .map(\n            x -> {\n              if (components == null) {\n                throw new IllegalArgumentException(\"Missing securitySchemes component definition.\");\n              }\n              Map<String, SecurityScheme> securitySchemes = components.getSecuritySchemes();\n              if (securitySchemes == null) {\n                throw new IllegalArgumentException(\"Missing securitySchemes component definition.\");\n              }\n\n              SecurityScheme result = securitySchemes.get(x);\n              if (result == null) {\n                throw new IllegalArgumentException(\"Impossible to find security scheme: \" + x);\n              }\n\n              return result;\n            })\n        .map(this::getPair)\n        .distinct()\n        .collect(Collectors.toList());\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<Pair<SecurityScheme.Type, SecurityScheme.In>>", "classes": []}, "name": "getListOfSecuritySchemes", "params": [{"name": "components", "type": "Components"}, {"name": "securityRequirement", "type": "SecurityRequirement"}], "body": "                                                                      {\n    return securityRequirement.keySet().stream()\n        .map(\n            x -> {\n              if (components == null) {\n                throw new IllegalArgumentException(\"Missing securitySchemes component definition.\");\n              }\n              Map<String, SecurityScheme> securitySchemes = components.getSecuritySchemes();\n              if (securitySchemes == null) {\n                throw new IllegalArgumentException(\"Missing securitySchemes component definition.\");\n              }\n\n              SecurityScheme result = securitySchemes.get(x);\n              if (result == null) {\n                throw new IllegalArgumentException(\"Impossible to find security scheme: \" + x);\n              }\n\n              return result;\n            })\n        .map(this::getPair)\n        .distinct()\n        .collect(Collectors.toList());\n  }", "signature": "private List<Pair<SecurityScheme.Type, SecurityScheme.In>> getListOfSecuritySchemes(\n      Components components, SecurityRequirement securityRequirement)"}, {"syntax_pass": true, "original_string": "  private Pair<SecurityScheme.Type, SecurityScheme.In> getPair(SecurityScheme securityScheme) {\n    return new ImmutablePair<>(securityScheme.getType(), securityScheme.getIn());\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Pair<SecurityScheme.Type, SecurityScheme.In>", "classes": []}, "name": "getPair", "params": [{"name": "securityScheme", "type": "SecurityScheme"}], "body": "                                                                                              {\n    return new ImmutablePair<>(securityScheme.getType(), securityScheme.getIn());\n  }", "signature": "private Pair<SecurityScheme.Type, SecurityScheme.In> getPair(SecurityScheme securityScheme)"}, {"syntax_pass": true, "original_string": "  protected DeferredChanged<ChangedSecurityRequirements> diff(\n      List<SecurityRequirement> left, List<SecurityRequirement> right, DiffContext context) {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    left = left == null ? new ArrayList<>() : left;\n    right = right == null ? new ArrayList<>() : getCopy(right);\n\n    ChangedSecurityRequirements changedSecurityRequirements =\n        new ChangedSecurityRequirements(left, right, context);\n\n    for (SecurityRequirement leftSecurity : left) {\n      Optional<SecurityRequirement> rightSecOpt = contains(right, leftSecurity);\n      if (!rightSecOpt.isPresent()) {\n        changedSecurityRequirements.addMissing(leftSecurity);\n      } else {\n        SecurityRequirement rightSec = rightSecOpt.get();\n        right.remove(rightSec);\n        builder\n            .with(openApiDiff.getSecurityRequirementDiff().diff(leftSecurity, rightSec, context))\n            .ifPresent(changedSecurityRequirements::addChanged);\n      }\n    }\n    right.forEach(changedSecurityRequirements::addIncreased);\n\n    return builder.buildIsChanged(changedSecurityRequirements);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "DeferredChanged<ChangedSecurityRequirements>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "List<SecurityRequirement>"}, {"name": "right", "type": "List<SecurityRequirement>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                            {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    left = left == null ? new ArrayList<>() : left;\n    right = right == null ? new ArrayList<>() : getCopy(right);\n\n    ChangedSecurityRequirements changedSecurityRequirements =\n        new ChangedSecurityRequirements(left, right, context);\n\n    for (SecurityRequirement leftSecurity : left) {\n      Optional<SecurityRequirement> rightSecOpt = contains(right, leftSecurity);\n      if (!rightSecOpt.isPresent()) {\n        changedSecurityRequirements.addMissing(leftSecurity);\n      } else {\n        SecurityRequirement rightSec = rightSecOpt.get();\n        right.remove(rightSec);\n        builder\n            .with(openApiDiff.getSecurityRequirementDiff().diff(leftSecurity, rightSec, context))\n            .ifPresent(changedSecurityRequirements::addChanged);\n      }\n    }\n    right.forEach(changedSecurityRequirements::addIncreased);\n\n    return builder.buildIsChanged(changedSecurityRequirements);\n  }", "signature": "protected DeferredChanged<ChangedSecurityRequirements> diff(\n      List<SecurityRequirement> left, List<SecurityRequirement> right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  private List<SecurityRequirement> getCopy(List<SecurityRequirement> right) {\n    return right.stream().map(SecurityRequirementDiff::getCopy).collect(Collectors.toList());\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<SecurityRequirement>", "classes": []}, "name": "getCopy", "params": [{"name": "right", "type": "List<SecurityRequirement>"}], "body": "                                                                             {\n    return right.stream().map(SecurityRequirementDiff::getCopy).collect(Collectors.toList());\n  }", "signature": "private List<SecurityRequirement> getCopy(List<SecurityRequirement> right)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/ApiResponseDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport io.swagger.v3.oas.models.responses.ApiResponses;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport javax.annotation.Nullable;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedApiResponse;\nimport org.openapitools.openapidiff.core.model.ChangedResponse;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\n\npublic class ApiResponseDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public ApiResponseDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedApiResponse> diff(\n      @Nullable ApiResponses left, @Nullable ApiResponses right, DiffContext context) {\n    MapKeyDiff<String, ApiResponse> responseMapKeyDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedResponseCodes = responseMapKeyDiff.getSharedKey();\n    Map<String, ChangedResponse> resps = new LinkedHashMap<>();\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    for (String responseCode : sharedResponseCodes) {\n      builder\n          .with(\n              openApiDiff\n                  .getResponseDiff()\n                  .diff(\n                      left != null ? left.get(responseCode) : null,\n                      right != null ? right.get(responseCode) : null,\n                      context))\n          .ifPresent(changedResponse -> resps.put(responseCode, changedResponse));\n    }\n    ChangedApiResponse changedApiResponse =\n        new ChangedApiResponse(left, right, context)\n            .setIncreased(responseMapKeyDiff.getIncreased())\n            .setMissing(responseMapKeyDiff.getMissing())\n            .setChanged(resps);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(\n                    left != null ? left.getExtensions() : null,\n                    right != null ? right.getExtensions() : null,\n                    context))\n        .ifPresent(changedApiResponse::setExtensions);\n    return builder.buildIsChanged(changedApiResponse);\n  }\n}\n", "file_hash": "f51d0147888c1f495c85a53f1c41d1ab1b5f3bb4459d90c0a0719f00f9408453", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import io.swagger.v3.oas.models.responses.ApiResponses;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Map;", "import javax.annotation.Nullable;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedApiResponse;", "import org.openapitools.openapidiff.core.model.ChangedResponse;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;"], "methods": [], "classes": [{"original_string": "public class ApiResponseDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public ApiResponseDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedApiResponse> diff(\n      @Nullable ApiResponses left, @Nullable ApiResponses right, DiffContext context) {\n    MapKeyDiff<String, ApiResponse> responseMapKeyDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedResponseCodes = responseMapKeyDiff.getSharedKey();\n    Map<String, ChangedResponse> resps = new LinkedHashMap<>();\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    for (String responseCode : sharedResponseCodes) {\n      builder\n          .with(\n              openApiDiff\n                  .getResponseDiff()\n                  .diff(\n                      left != null ? left.get(responseCode) : null,\n                      right != null ? right.get(responseCode) : null,\n                      context))\n          .ifPresent(changedResponse -> resps.put(responseCode, changedResponse));\n    }\n    ChangedApiResponse changedApiResponse =\n        new ChangedApiResponse(left, right, context)\n            .setIncreased(responseMapKeyDiff.getIncreased())\n            .setMissing(responseMapKeyDiff.getMissing())\n            .setChanged(resps);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(\n                    left != null ? left.getExtensions() : null,\n                    right != null ? right.getExtensions() : null,\n                    context))\n        .ifPresent(changedApiResponse::setExtensions);\n    return builder.buildIsChanged(changedApiResponse);\n  }\n}", "definition": "public class ApiResponseDiff", "class_docstring": "", "name": "ApiResponseDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ApiResponseDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ApiResponseDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                  {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public ApiResponseDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedApiResponse> diff(\n      @Nullable ApiResponses left, @Nullable ApiResponses right, DiffContext context) {\n    MapKeyDiff<String, ApiResponse> responseMapKeyDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedResponseCodes = responseMapKeyDiff.getSharedKey();\n    Map<String, ChangedResponse> resps = new LinkedHashMap<>();\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    for (String responseCode : sharedResponseCodes) {\n      builder\n          .with(\n              openApiDiff\n                  .getResponseDiff()\n                  .diff(\n                      left != null ? left.get(responseCode) : null,\n                      right != null ? right.get(responseCode) : null,\n                      context))\n          .ifPresent(changedResponse -> resps.put(responseCode, changedResponse));\n    }\n    ChangedApiResponse changedApiResponse =\n        new ChangedApiResponse(left, right, context)\n            .setIncreased(responseMapKeyDiff.getIncreased())\n            .setMissing(responseMapKeyDiff.getMissing())\n            .setChanged(resps);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(\n                    left != null ? left.getExtensions() : null,\n                    right != null ? right.getExtensions() : null,\n                    context))\n        .ifPresent(changedApiResponse::setExtensions);\n    return builder.buildIsChanged(changedApiResponse);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedApiResponse>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "ApiResponses"}, {"name": "right", "type": "ApiResponses"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                      {\n    MapKeyDiff<String, ApiResponse> responseMapKeyDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedResponseCodes = responseMapKeyDiff.getSharedKey();\n    Map<String, ChangedResponse> resps = new LinkedHashMap<>();\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    for (String responseCode : sharedResponseCodes) {\n      builder\n          .with(\n              openApiDiff\n                  .getResponseDiff()\n                  .diff(\n                      left != null ? left.get(responseCode) : null,\n                      right != null ? right.get(responseCode) : null,\n                      context))\n          .ifPresent(changedResponse -> resps.put(responseCode, changedResponse));\n    }\n    ChangedApiResponse changedApiResponse =\n        new ChangedApiResponse(left, right, context)\n            .setIncreased(responseMapKeyDiff.getIncreased())\n            .setMissing(responseMapKeyDiff.getMissing())\n            .setChanged(resps);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(\n                    left != null ? left.getExtensions() : null,\n                    right != null ? right.getExtensions() : null,\n                    context))\n        .ifPresent(changedApiResponse::setExtensions);\n    return builder.buildIsChanged(changedApiResponse);\n  }", "signature": "public DeferredChanged<ChangedApiResponse> diff(\n      @Nullable ApiResponses left, @Nullable ApiResponses right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/ParametersDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang3.StringUtils;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedParameters;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\nclass ParametersDiffResult {\n  protected DeferredChanged<ChangedParameters> deferredChanged;\n  protected boolean sameOperationsDiffSchema;\n\n  public ParametersDiffResult(\n      DeferredChanged<ChangedParameters> deferredChanged, boolean sameOperationsDiffSchema) {\n    this.deferredChanged = deferredChanged;\n    this.sameOperationsDiffSchema = sameOperationsDiffSchema;\n  }\n}\n/** compare two parameter */\npublic class ParametersDiff {\n\n  private static final RefPointer<Parameter> refPointer = new RefPointer<>(RefType.PARAMETERS);\n\n  private final Components leftComponents;\n  private final Components rightComponents;\n  private final OpenApiDiff openApiDiff;\n\n  public ParametersDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public static Optional<Parameter> contains(\n      Components components, List<Parameter> parameters, Parameter parameter) {\n    return parameters.stream()\n        .filter(param -> same(refPointer.resolveRef(components, param, param.get$ref()), parameter))\n        .findFirst();\n  }\n\n  public static boolean same(Parameter left, Parameter right) {\n    return Objects.equals(left.getName(), right.getName())\n        && Objects.equals(left.getIn(), right.getIn());\n  }\n\n  public ParametersDiffResult diff(\n      final List<Parameter> left, final List<Parameter> right, final DiffContext context) {\n    final DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    final List<Parameter> wLeft = Optional.ofNullable(left).orElseGet(Collections::emptyList);\n    final List<Parameter> wRight =\n        Optional.ofNullable(right).map(ArrayList::new).orElseGet(ArrayList::new);\n\n    final ChangedParameters changedParameters = new ChangedParameters(wLeft, wRight, context);\n\n    for (Parameter leftParam : wLeft) {\n      leftParam = refPointer.resolveRef(leftComponents, leftParam, leftParam.get$ref());\n      Optional<Parameter> rightParamOpt = contains(rightComponents, wRight, leftParam);\n      if (!rightParamOpt.isPresent()) {\n        changedParameters.getMissing().add(leftParam);\n      } else {\n        Parameter rightParam = rightParamOpt.get();\n        wRight.remove(rightParam);\n        builder\n            .with(openApiDiff.getParameterDiff().diff(leftParam, rightParam, context))\n            .ifPresent(changedParameters.getChanged()::add);\n      }\n    }\n    changedParameters.getIncreased().addAll(wRight);\n    return new ParametersDiffResult(\n        builder.buildIsChanged(changedParameters),\n        pathUnchangedParametersChanged(changedParameters, context));\n  }\n\n  public boolean pathUnchangedParametersChanged(\n      ChangedParameters changedParameters, DiffContext context) {\n    if (!pathUnchanged(changedParameters, context)) return false;\n    // If missing and increased parameter count is different, it's a new endpoint\n    if (changedParameters.getMissing().size() != changedParameters.getIncreased().size())\n      return false;\n    // Go through each missing Parameter and compare it to newly added Parameters\n    for (Parameter parameter : changedParameters.getMissing()) {\n      // Speedy Check. Use the map already created in changedParameters to check if missing param is\n      // linked to newParam\n      String newParameterName = context.getParameters().get(parameter.getName());\n      if (StringUtils.isBlank(newParameterName)) return false;\n\n      Optional<Parameter> newParameter =\n          changedParameters.getIncreased().stream()\n              .filter(p -> p.getName().equals(newParameterName))\n              .findFirst();\n      if (!newParameter.isPresent()) return false;\n\n      // Check if  the old and new Parameters match . IF so, return TRUE\n      Parameter newParameterRealized = newParameter.get();\n      newParameterRealized.setName(parameter.getName()); // Make names similar\n      boolean samePathDifferentParameter = !newParameterRealized.equals(parameter);\n      newParameterRealized.setName(\n          newParameterName); // Important:: MUST Reset the name as this is not a copy\n      return samePathDifferentParameter;\n    }\n    return false;\n  }\n\n  public boolean pathUnchanged(ChangedParameters changedParameters, DiffContext context) {\n    final String REGEX_PATH = \"\\\\{([^/]+)}\";\n    String oldUrl = context.getLeftUrl();\n    String newUrl = context.getRightUrl();\n    ArrayList<String> oldUrlPathParams = matchedItems(oldUrl, REGEX_PATH);\n    ArrayList<String> newUrlPathParams = matchedItems(newUrl, REGEX_PATH);\n    // Path Param count doesn't match or param-less path doesn't match or param is changed --> It's\n    // a new endpoint\n    return oldUrlPathParams.size() == newUrlPathParams.size()\n        && changedParameters.getChanged().isEmpty()\n        && oldUrl.replaceAll(REGEX_PATH, \"\").equals(newUrl.replaceAll(REGEX_PATH, \"\"));\n  }\n\n  public ArrayList<String> matchedItems(String string, String regex) {\n    Matcher matcher = Pattern.compile(regex).matcher(string);\n    ArrayList<String> matchedItems = new ArrayList<>();\n    while (matcher.find()) {\n      String item = matcher.group();\n      matchedItems.add(item.substring(0, matcher.group().length() - 1).replaceFirst(\"\\\\{\", \"\"));\n    }\n    return matchedItems;\n  }\n}\n", "file_hash": "cdbf973f6841ae9d88febfa199a967e4cab333e4a7fa4eab72eddb6f7db1a9d4", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import java.util.ArrayList;", "import java.util.Collections;", "import java.util.List;", "import java.util.Objects;", "import java.util.Optional;", "import java.util.regex.Matcher;", "import java.util.regex.Pattern;", "import org.apache.commons.lang3.StringUtils;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedParameters;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "class ParametersDiffResult {\n  protected DeferredChanged<ChangedParameters> deferredChanged;\n  protected boolean sameOperationsDiffSchema;\n\n  public ParametersDiffResult(\n      DeferredChanged<ChangedParameters> deferredChanged, boolean sameOperationsDiffSchema) {\n    this.deferredChanged = deferredChanged;\n    this.sameOperationsDiffSchema = sameOperationsDiffSchema;\n  }\n}", "definition": "class ParametersDiffResult", "class_docstring": "", "name": "ParametersDiffResult", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "protected DeferredChanged<ChangedParameters> deferredChanged;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "DeferredChanged<ChangedParameters>", "name": "deferredChanged", "syntax_pass": true}, {"attribute_expression": "protected boolean sameOperationsDiffSchema;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "sameOperationsDiffSchema", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ParametersDiffResult(\n      DeferredChanged<ChangedParameters> deferredChanged, boolean sameOperationsDiffSchema) {\n    this.deferredChanged = deferredChanged;\n    this.sameOperationsDiffSchema = sameOperationsDiffSchema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParametersDiffResult", "params": [{"name": "deferredChanged", "type": "DeferredChanged<ChangedParameters>"}, {"name": "sameOperationsDiffSchema", "type": "boolean"}], "body": "                                                                                            {\n    this.deferredChanged = deferredChanged;\n    this.sameOperationsDiffSchema = sameOperationsDiffSchema;\n  }", "signature": "public ParametersDiffResult(\n      DeferredChanged<ChangedParameters> deferredChanged, boolean sameOperationsDiffSchema)"}]}, {"original_string": "public class ParametersDiff {\n\n  private static final RefPointer<Parameter> refPointer = new RefPointer<>(RefType.PARAMETERS);\n\n  private final Components leftComponents;\n  private final Components rightComponents;\n  private final OpenApiDiff openApiDiff;\n\n  public ParametersDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public static Optional<Parameter> contains(\n      Components components, List<Parameter> parameters, Parameter parameter) {\n    return parameters.stream()\n        .filter(param -> same(refPointer.resolveRef(components, param, param.get$ref()), parameter))\n        .findFirst();\n  }\n\n  public static boolean same(Parameter left, Parameter right) {\n    return Objects.equals(left.getName(), right.getName())\n        && Objects.equals(left.getIn(), right.getIn());\n  }\n\n  public ParametersDiffResult diff(\n      final List<Parameter> left, final List<Parameter> right, final DiffContext context) {\n    final DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    final List<Parameter> wLeft = Optional.ofNullable(left).orElseGet(Collections::emptyList);\n    final List<Parameter> wRight =\n        Optional.ofNullable(right).map(ArrayList::new).orElseGet(ArrayList::new);\n\n    final ChangedParameters changedParameters = new ChangedParameters(wLeft, wRight, context);\n\n    for (Parameter leftParam : wLeft) {\n      leftParam = refPointer.resolveRef(leftComponents, leftParam, leftParam.get$ref());\n      Optional<Parameter> rightParamOpt = contains(rightComponents, wRight, leftParam);\n      if (!rightParamOpt.isPresent()) {\n        changedParameters.getMissing().add(leftParam);\n      } else {\n        Parameter rightParam = rightParamOpt.get();\n        wRight.remove(rightParam);\n        builder\n            .with(openApiDiff.getParameterDiff().diff(leftParam, rightParam, context))\n            .ifPresent(changedParameters.getChanged()::add);\n      }\n    }\n    changedParameters.getIncreased().addAll(wRight);\n    return new ParametersDiffResult(\n        builder.buildIsChanged(changedParameters),\n        pathUnchangedParametersChanged(changedParameters, context));\n  }\n\n  public boolean pathUnchangedParametersChanged(\n      ChangedParameters changedParameters, DiffContext context) {\n    if (!pathUnchanged(changedParameters, context)) return false;\n    // If missing and increased parameter count is different, it's a new endpoint\n    if (changedParameters.getMissing().size() != changedParameters.getIncreased().size())\n      return false;\n    // Go through each missing Parameter and compare it to newly added Parameters\n    for (Parameter parameter : changedParameters.getMissing()) {\n      // Speedy Check. Use the map already created in changedParameters to check if missing param is\n      // linked to newParam\n      String newParameterName = context.getParameters().get(parameter.getName());\n      if (StringUtils.isBlank(newParameterName)) return false;\n\n      Optional<Parameter> newParameter =\n          changedParameters.getIncreased().stream()\n              .filter(p -> p.getName().equals(newParameterName))\n              .findFirst();\n      if (!newParameter.isPresent()) return false;\n\n      // Check if  the old and new Parameters match . IF so, return TRUE\n      Parameter newParameterRealized = newParameter.get();\n      newParameterRealized.setName(parameter.getName()); // Make names similar\n      boolean samePathDifferentParameter = !newParameterRealized.equals(parameter);\n      newParameterRealized.setName(\n          newParameterName); // Important:: MUST Reset the name as this is not a copy\n      return samePathDifferentParameter;\n    }\n    return false;\n  }\n\n  public boolean pathUnchanged(ChangedParameters changedParameters, DiffContext context) {\n    final String REGEX_PATH = \"\\\\{([^/]+)}\";\n    String oldUrl = context.getLeftUrl();\n    String newUrl = context.getRightUrl();\n    ArrayList<String> oldUrlPathParams = matchedItems(oldUrl, REGEX_PATH);\n    ArrayList<String> newUrlPathParams = matchedItems(newUrl, REGEX_PATH);\n    // Path Param count doesn't match or param-less path doesn't match or param is changed --> It's\n    // a new endpoint\n    return oldUrlPathParams.size() == newUrlPathParams.size()\n        && changedParameters.getChanged().isEmpty()\n        && oldUrl.replaceAll(REGEX_PATH, \"\").equals(newUrl.replaceAll(REGEX_PATH, \"\"));\n  }\n\n  public ArrayList<String> matchedItems(String string, String regex) {\n    Matcher matcher = Pattern.compile(regex).matcher(string);\n    ArrayList<String> matchedItems = new ArrayList<>();\n    while (matcher.find()) {\n      String item = matcher.group();\n      matchedItems.add(item.substring(0, matcher.group().length() - 1).replaceFirst(\"\\\\{\", \"\"));\n    }\n    return matchedItems;\n  }\n}", "definition": "public class ParametersDiff", "class_docstring": " compare two parameter", "name": "ParametersDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final RefPointer<Parameter> refPointer = new RefPointer<>(RefType.PARAMETERS);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RefPointer<Parameter>", "name": "refPointer = new RefPointer<>(RefType.PARAMETERS)", "syntax_pass": true}, {"attribute_expression": "private final Components leftComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "leftComponents", "syntax_pass": true}, {"attribute_expression": "private final Components rightComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "rightComponents", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ParametersDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParametersDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                 {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "signature": "public ParametersDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public static Optional<Parameter> contains(\n      Components components, List<Parameter> parameters, Parameter parameter) {\n    return parameters.stream()\n        .filter(param -> same(refPointer.resolveRef(components, param, param.get$ref()), parameter))\n        .findFirst();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Optional<Parameter>", "classes": []}, "name": "contains", "params": [{"name": "components", "type": "Components"}, {"name": "parameters", "type": "List<Parameter>"}, {"name": "parameter", "type": "Parameter"}], "body": "                                                                              {\n    return parameters.stream()\n        .filter(param -> same(refPointer.resolveRef(components, param, param.get$ref()), parameter))\n        .findFirst();\n  }", "signature": "public static Optional<Parameter> contains(\n      Components components, List<Parameter> parameters, Parameter parameter)"}, {"syntax_pass": true, "original_string": "  public static boolean same(Parameter left, Parameter right) {\n    return Objects.equals(left.getName(), right.getName())\n        && Objects.equals(left.getIn(), right.getIn());\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "same", "params": [{"name": "left", "type": "Parameter"}, {"name": "right", "type": "Parameter"}], "body": "                                                              {\n    return Objects.equals(left.getName(), right.getName())\n        && Objects.equals(left.getIn(), right.getIn());\n  }", "signature": "public static boolean same(Parameter left, Parameter right)"}, {"syntax_pass": true, "original_string": "  public ParametersDiffResult diff(\n      final List<Parameter> left, final List<Parameter> right, final DiffContext context) {\n    final DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    final List<Parameter> wLeft = Optional.ofNullable(left).orElseGet(Collections::emptyList);\n    final List<Parameter> wRight =\n        Optional.ofNullable(right).map(ArrayList::new).orElseGet(ArrayList::new);\n\n    final ChangedParameters changedParameters = new ChangedParameters(wLeft, wRight, context);\n\n    for (Parameter leftParam : wLeft) {\n      leftParam = refPointer.resolveRef(leftComponents, leftParam, leftParam.get$ref());\n      Optional<Parameter> rightParamOpt = contains(rightComponents, wRight, leftParam);\n      if (!rightParamOpt.isPresent()) {\n        changedParameters.getMissing().add(leftParam);\n      } else {\n        Parameter rightParam = rightParamOpt.get();\n        wRight.remove(rightParam);\n        builder\n            .with(openApiDiff.getParameterDiff().diff(leftParam, rightParam, context))\n            .ifPresent(changedParameters.getChanged()::add);\n      }\n    }\n    changedParameters.getIncreased().addAll(wRight);\n    return new ParametersDiffResult(\n        builder.buildIsChanged(changedParameters),\n        pathUnchangedParametersChanged(changedParameters, context));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ParametersDiffResult", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "List<Parameter>"}, {"name": "right", "type": "List<Parameter>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                          {\n    final DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    final List<Parameter> wLeft = Optional.ofNullable(left).orElseGet(Collections::emptyList);\n    final List<Parameter> wRight =\n        Optional.ofNullable(right).map(ArrayList::new).orElseGet(ArrayList::new);\n\n    final ChangedParameters changedParameters = new ChangedParameters(wLeft, wRight, context);\n\n    for (Parameter leftParam : wLeft) {\n      leftParam = refPointer.resolveRef(leftComponents, leftParam, leftParam.get$ref());\n      Optional<Parameter> rightParamOpt = contains(rightComponents, wRight, leftParam);\n      if (!rightParamOpt.isPresent()) {\n        changedParameters.getMissing().add(leftParam);\n      } else {\n        Parameter rightParam = rightParamOpt.get();\n        wRight.remove(rightParam);\n        builder\n            .with(openApiDiff.getParameterDiff().diff(leftParam, rightParam, context))\n            .ifPresent(changedParameters.getChanged()::add);\n      }\n    }\n    changedParameters.getIncreased().addAll(wRight);\n    return new ParametersDiffResult(\n        builder.buildIsChanged(changedParameters),\n        pathUnchangedParametersChanged(changedParameters, context));\n  }", "signature": "public ParametersDiffResult diff(\n      final List<Parameter> left, final List<Parameter> right, final DiffContext context)"}, {"syntax_pass": true, "original_string": "  public boolean pathUnchangedParametersChanged(\n      ChangedParameters changedParameters, DiffContext context) {\n    if (!pathUnchanged(changedParameters, context)) return false;\n    // If missing and increased parameter count is different, it's a new endpoint\n    if (changedParameters.getMissing().size() != changedParameters.getIncreased().size())\n      return false;\n    // Go through each missing Parameter and compare it to newly added Parameters\n    for (Parameter parameter : changedParameters.getMissing()) {\n      // Speedy Check. Use the map already created in changedParameters to check if missing param is\n      // linked to newParam\n      String newParameterName = context.getParameters().get(parameter.getName());\n      if (StringUtils.isBlank(newParameterName)) return false;\n\n      Optional<Parameter> newParameter =\n          changedParameters.getIncreased().stream()\n              .filter(p -> p.getName().equals(newParameterName))\n              .findFirst();\n      if (!newParameter.isPresent()) return false;\n\n      // Check if  the old and new Parameters match . IF so, return TRUE\n      Parameter newParameterRealized = newParameter.get();\n      newParameterRealized.setName(parameter.getName()); // Make names similar\n      boolean samePathDifferentParameter = !newParameterRealized.equals(parameter);\n      newParameterRealized.setName(\n          newParameterName); // Important:: MUST Reset the name as this is not a copy\n      return samePathDifferentParameter;\n    }\n    return false;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "pathUnchangedParametersChanged", "params": [{"name": "changedParameters", "type": "ChangedParameters"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                {\n    if (!pathUnchanged(changedParameters, context)) return false;\n    // If missing and increased parameter count is different, it's a new endpoint\n    if (changedParameters.getMissing().size() != changedParameters.getIncreased().size())\n      return false;\n    // Go through each missing Parameter and compare it to newly added Parameters\n    for (Parameter parameter : changedParameters.getMissing()) {\n      // Speedy Check. Use the map already created in changedParameters to check if missing param is\n      // linked to newParam\n      String newParameterName = context.getParameters().get(parameter.getName());\n      if (StringUtils.isBlank(newParameterName)) return false;\n\n      Optional<Parameter> newParameter =\n          changedParameters.getIncreased().stream()\n              .filter(p -> p.getName().equals(newParameterName))\n              .findFirst();\n      if (!newParameter.isPresent()) return false;\n\n      // Check if  the old and new Parameters match . IF so, return TRUE\n      Parameter newParameterRealized = newParameter.get();\n      newParameterRealized.setName(parameter.getName()); // Make names similar\n      boolean samePathDifferentParameter = !newParameterRealized.equals(parameter);\n      newParameterRealized.setName(\n          newParameterName); // Important:: MUST Reset the name as this is not a copy\n      return samePathDifferentParameter;\n    }\n    return false;\n  }", "signature": "public boolean pathUnchangedParametersChanged(\n      ChangedParameters changedParameters, DiffContext context)"}, {"syntax_pass": true, "original_string": "  public boolean pathUnchanged(ChangedParameters changedParameters, DiffContext context) {\n    final String REGEX_PATH = \"\\\\{([^/]+)}\";\n    String oldUrl = context.getLeftUrl();\n    String newUrl = context.getRightUrl();\n    ArrayList<String> oldUrlPathParams = matchedItems(oldUrl, REGEX_PATH);\n    ArrayList<String> newUrlPathParams = matchedItems(newUrl, REGEX_PATH);\n    // Path Param count doesn't match or param-less path doesn't match or param is changed --> It's\n    // a new endpoint\n    return oldUrlPathParams.size() == newUrlPathParams.size()\n        && changedParameters.getChanged().isEmpty()\n        && oldUrl.replaceAll(REGEX_PATH, \"\").equals(newUrl.replaceAll(REGEX_PATH, \"\"));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "pathUnchanged", "params": [{"name": "changedParameters", "type": "ChangedParameters"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                         {\n    final String REGEX_PATH = \"\\\\{([^/]+)}\";\n    String oldUrl = context.getLeftUrl();\n    String newUrl = context.getRightUrl();\n    ArrayList<String> oldUrlPathParams = matchedItems(oldUrl, REGEX_PATH);\n    ArrayList<String> newUrlPathParams = matchedItems(newUrl, REGEX_PATH);\n    // Path Param count doesn't match or param-less path doesn't match or param is changed --> It's\n    // a new endpoint\n    return oldUrlPathParams.size() == newUrlPathParams.size()\n        && changedParameters.getChanged().isEmpty()\n        && oldUrl.replaceAll(REGEX_PATH, \"\").equals(newUrl.replaceAll(REGEX_PATH, \"\"));\n  }", "signature": "public boolean pathUnchanged(ChangedParameters changedParameters, DiffContext context)"}, {"syntax_pass": true, "original_string": "  public ArrayList<String> matchedItems(String string, String regex) {\n    Matcher matcher = Pattern.compile(regex).matcher(string);\n    ArrayList<String> matchedItems = new ArrayList<>();\n    while (matcher.find()) {\n      String item = matcher.group();\n      matchedItems.add(item.substring(0, matcher.group().length() - 1).replaceFirst(\"\\\\{\", \"\"));\n    }\n    return matchedItems;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ArrayList<String>", "classes": []}, "name": "matchedItems", "params": [{"name": "string", "type": "String"}, {"name": "regex", "type": "String"}], "body": "                                                                     {\n    Matcher matcher = Pattern.compile(regex).matcher(string);\n    ArrayList<String> matchedItems = new ArrayList<>();\n    while (matcher.find()) {\n      String item = matcher.group();\n      matchedItems.add(item.substring(0, matcher.group().length() - 1).replaceFirst(\"\\\\{\", \"\"));\n    }\n    return matchedItems;\n  }", "signature": "public ArrayList<String> matchedItems(String string, String regex)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/PathsDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.Operation;\nimport io.swagger.v3.oas.models.PathItem;\nimport io.swagger.v3.oas.models.Paths;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.IntStream;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedPaths;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\n\npublic class PathsDiff {\n  private static final String REGEX_PATH = \"\\\\{([^/{}]+)}\";\n  private final OpenApiDiff openApiDiff;\n\n  public PathsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  private static String normalizePath(String path) {\n    return path.replaceAll(REGEX_PATH, \"{}\");\n  }\n\n  private static List<String> extractParameters(String path) {\n    ArrayList<String> params = new ArrayList<>();\n    Pattern pattern = Pattern.compile(REGEX_PATH);\n    Matcher matcher = pattern.matcher(path);\n    while (matcher.find()) {\n      params.add(matcher.group(1));\n    }\n    return params;\n  }\n\n  public DeferredChanged<ChangedPaths> diff(\n      final Map<String, PathItem> left, final Map<String, PathItem> right) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedPaths changedPaths = new ChangedPaths(left, right, openApiDiff.getOptions());\n    changedPaths.getIncreased().putAll(right);\n\n    left.keySet()\n        .forEach(\n            (String url) -> {\n              PathItem leftPath = left.get(url);\n              String template = normalizePath(url);\n              Optional<Map.Entry<String, PathItem>> result =\n                  changedPaths.getIncreased().entrySet().stream()\n                      .filter(item -> normalizePath(item.getKey()).equals(template))\n                      .min(\n                          (a, b) -> {\n                            if (methodsAndParametersIntersect(a.getValue(), b.getValue())) {\n                              throw new IllegalArgumentException(\n                                  \"Two path items have the same signature: \" + template);\n                            }\n                            if (a.getKey().equals(url)) {\n                              return -1;\n                            } else if (b.getKey().equals((url))) {\n                              return 1;\n                            } else {\n                              HashSet<PathItem.HttpMethod> methodsA =\n                                  new HashSet<>(a.getValue().readOperationsMap().keySet());\n                              methodsA.retainAll(leftPath.readOperationsMap().keySet());\n                              HashSet<PathItem.HttpMethod> methodsB =\n                                  new HashSet<>(b.getValue().readOperationsMap().keySet());\n                              methodsB.retainAll(leftPath.readOperationsMap().keySet());\n                              return Integer.compare(methodsB.size(), methodsA.size());\n                            }\n                          });\n              if (result.isPresent()) {\n                String rightUrl = result.get().getKey();\n                PathItem rightPath = changedPaths.getIncreased().remove(rightUrl);\n                Map<String, String> params = new LinkedHashMap<>();\n                if (!url.equals(rightUrl)) {\n                  List<String> oldParams = extractParameters(url);\n                  List<String> newParams = extractParameters(rightUrl);\n                  for (int i = 0; i < oldParams.size(); i++) {\n                    params.put(oldParams.get(i), newParams.get(i));\n                  }\n                }\n                DiffContext context = new DiffContext(openApiDiff.getOptions());\n                context.setUrl(url);\n                context.setParameters(params);\n                context.setLeftAndRightUrls(url, rightUrl);\n                builder\n                    .with(openApiDiff.getPathDiff().diff(leftPath, rightPath, context))\n                    .ifPresent(path -> changedPaths.getChanged().put(rightUrl, path));\n              } else {\n                changedPaths.getMissing().put(url, leftPath);\n              }\n            });\n    return builder.buildIsChanged(changedPaths);\n  }\n\n  public static Paths valOrEmpty(Paths path) {\n    if (path == null) {\n      path = new Paths();\n    }\n    return path;\n  }\n\n  /**\n   * @param a a path form the open api spec\n   * @param b another path from the same open api spec\n   * @return <code>true</code> in case both paths are of the same method AND their templated\n   *     parameters are of the same type; <code>false</code> otherwise\n   */\n  private static boolean methodsAndParametersIntersect(PathItem a, PathItem b) {\n    Set<PathItem.HttpMethod> methodsA = a.readOperationsMap().keySet();\n    for (PathItem.HttpMethod method : b.readOperationsMap().keySet()) {\n      if (methodsA.contains(method)) {\n        Operation left = a.readOperationsMap().get(method);\n        Operation right = b.readOperationsMap().get(method);\n        if (left.getParameters().size() == right.getParameters().size()) {\n          return parametersIntersect(left.getParameters(), right.getParameters());\n        }\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param left parameters from the first compared method\n   * @param right parameters from the second compared method\n   * @return <code>true</code> in case each parameter pair is of the same type; <code>false</code>\n   *     otherwise\n   */\n  private static boolean parametersIntersect(List<Parameter> left, List<Parameter> right) {\n    int parametersSize = left.size();\n    long intersectedParameters =\n        IntStream.range(0, left.size())\n            .filter(\n                i -> left.get(i).getSchema().getType().equals(right.get(i).getSchema().getType()))\n            .count();\n    return parametersSize == intersectedParameters;\n  }\n}\n", "file_hash": "6c4c1e156cc6bf06bc37e6d64aa6eb5242277d7c757773826a9de282009cb1b8", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.Operation;", "import io.swagger.v3.oas.models.PathItem;", "import io.swagger.v3.oas.models.Paths;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import java.util.*;", "import java.util.regex.Matcher;", "import java.util.regex.Pattern;", "import java.util.stream.IntStream;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedPaths;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;"], "methods": [], "classes": [{"original_string": "public class PathsDiff {\n  private static final String REGEX_PATH = \"\\\\{([^/{}]+)}\";\n  private final OpenApiDiff openApiDiff;\n\n  public PathsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  private static String normalizePath(String path) {\n    return path.replaceAll(REGEX_PATH, \"{}\");\n  }\n\n  private static List<String> extractParameters(String path) {\n    ArrayList<String> params = new ArrayList<>();\n    Pattern pattern = Pattern.compile(REGEX_PATH);\n    Matcher matcher = pattern.matcher(path);\n    while (matcher.find()) {\n      params.add(matcher.group(1));\n    }\n    return params;\n  }\n\n  public DeferredChanged<ChangedPaths> diff(\n      final Map<String, PathItem> left, final Map<String, PathItem> right) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedPaths changedPaths = new ChangedPaths(left, right, openApiDiff.getOptions());\n    changedPaths.getIncreased().putAll(right);\n\n    left.keySet()\n        .forEach(\n            (String url) -> {\n              PathItem leftPath = left.get(url);\n              String template = normalizePath(url);\n              Optional<Map.Entry<String, PathItem>> result =\n                  changedPaths.getIncreased().entrySet().stream()\n                      .filter(item -> normalizePath(item.getKey()).equals(template))\n                      .min(\n                          (a, b) -> {\n                            if (methodsAndParametersIntersect(a.getValue(), b.getValue())) {\n                              throw new IllegalArgumentException(\n                                  \"Two path items have the same signature: \" + template);\n                            }\n                            if (a.getKey().equals(url)) {\n                              return -1;\n                            } else if (b.getKey().equals((url))) {\n                              return 1;\n                            } else {\n                              HashSet<PathItem.HttpMethod> methodsA =\n                                  new HashSet<>(a.getValue().readOperationsMap().keySet());\n                              methodsA.retainAll(leftPath.readOperationsMap().keySet());\n                              HashSet<PathItem.HttpMethod> methodsB =\n                                  new HashSet<>(b.getValue().readOperationsMap().keySet());\n                              methodsB.retainAll(leftPath.readOperationsMap().keySet());\n                              return Integer.compare(methodsB.size(), methodsA.size());\n                            }\n                          });\n              if (result.isPresent()) {\n                String rightUrl = result.get().getKey();\n                PathItem rightPath = changedPaths.getIncreased().remove(rightUrl);\n                Map<String, String> params = new LinkedHashMap<>();\n                if (!url.equals(rightUrl)) {\n                  List<String> oldParams = extractParameters(url);\n                  List<String> newParams = extractParameters(rightUrl);\n                  for (int i = 0; i < oldParams.size(); i++) {\n                    params.put(oldParams.get(i), newParams.get(i));\n                  }\n                }\n                DiffContext context = new DiffContext(openApiDiff.getOptions());\n                context.setUrl(url);\n                context.setParameters(params);\n                context.setLeftAndRightUrls(url, rightUrl);\n                builder\n                    .with(openApiDiff.getPathDiff().diff(leftPath, rightPath, context))\n                    .ifPresent(path -> changedPaths.getChanged().put(rightUrl, path));\n              } else {\n                changedPaths.getMissing().put(url, leftPath);\n              }\n            });\n    return builder.buildIsChanged(changedPaths);\n  }\n\n  public static Paths valOrEmpty(Paths path) {\n    if (path == null) {\n      path = new Paths();\n    }\n    return path;\n  }\n\n  /**\n   * @param a a path form the open api spec\n   * @param b another path from the same open api spec\n   * @return <code>true</code> in case both paths are of the same method AND their templated\n   *     parameters are of the same type; <code>false</code> otherwise\n   */\n  private static boolean methodsAndParametersIntersect(PathItem a, PathItem b) {\n    Set<PathItem.HttpMethod> methodsA = a.readOperationsMap().keySet();\n    for (PathItem.HttpMethod method : b.readOperationsMap().keySet()) {\n      if (methodsA.contains(method)) {\n        Operation left = a.readOperationsMap().get(method);\n        Operation right = b.readOperationsMap().get(method);\n        if (left.getParameters().size() == right.getParameters().size()) {\n          return parametersIntersect(left.getParameters(), right.getParameters());\n        }\n        return false;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param left parameters from the first compared method\n   * @param right parameters from the second compared method\n   * @return <code>true</code> in case each parameter pair is of the same type; <code>false</code>\n   *     otherwise\n   */\n  private static boolean parametersIntersect(List<Parameter> left, List<Parameter> right) {\n    int parametersSize = left.size();\n    long intersectedParameters =\n        IntStream.range(0, left.size())\n            .filter(\n                i -> left.get(i).getSchema().getType().equals(right.get(i).getSchema().getType()))\n            .count();\n    return parametersSize == intersectedParameters;\n  }\n}", "definition": "public class PathsDiff", "class_docstring": "", "name": "PathsDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String REGEX_PATH = \"\\\\{([^/{}]+)}\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "REGEX_PATH = \"\\\\{([^/{}]+)}\"", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public PathsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "PathsDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                            {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public PathsDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  private static String normalizePath(String path) {\n    return path.replaceAll(REGEX_PATH, \"{}\");\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "name": "normalizePath", "params": [{"name": "path", "type": "String"}], "body": "                                                   {\n    return path.replaceAll(REGEX_PATH, \"{}\");\n  }", "signature": "private static String normalizePath(String path)"}, {"syntax_pass": true, "original_string": "  private static List<String> extractParameters(String path) {\n    ArrayList<String> params = new ArrayList<>();\n    Pattern pattern = Pattern.compile(REGEX_PATH);\n    Matcher matcher = pattern.matcher(path);\n    while (matcher.find()) {\n      params.add(matcher.group(1));\n    }\n    return params;\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "extractParameters", "params": [{"name": "path", "type": "String"}], "body": "                                                             {\n    ArrayList<String> params = new ArrayList<>();\n    Pattern pattern = Pattern.compile(REGEX_PATH);\n    Matcher matcher = pattern.matcher(path);\n    while (matcher.find()) {\n      params.add(matcher.group(1));\n    }\n    return params;\n  }", "signature": "private static List<String> extractParameters(String path)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedPaths> diff(\n      final Map<String, PathItem> left, final Map<String, PathItem> right) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedPaths changedPaths = new ChangedPaths(left, right, openApiDiff.getOptions());\n    changedPaths.getIncreased().putAll(right);\n\n    left.keySet()\n        .forEach(\n            (String url) -> {\n              PathItem leftPath = left.get(url);\n              String template = normalizePath(url);\n              Optional<Map.Entry<String, PathItem>> result =\n                  changedPaths.getIncreased().entrySet().stream()\n                      .filter(item -> normalizePath(item.getKey()).equals(template))\n                      .min(\n                          (a, b) -> {\n                            if (methodsAndParametersIntersect(a.getValue(), b.getValue())) {\n                              throw new IllegalArgumentException(\n                                  \"Two path items have the same signature: \" + template);\n                            }\n                            if (a.getKey().equals(url)) {\n                              return -1;\n                            } else if (b.getKey().equals((url))) {\n                              return 1;\n                            } else {\n                              HashSet<PathItem.HttpMethod> methodsA =\n                                  new HashSet<>(a.getValue().readOperationsMap().keySet());\n                              methodsA.retainAll(leftPath.readOperationsMap().keySet());\n                              HashSet<PathItem.HttpMethod> methodsB =\n                                  new HashSet<>(b.getValue().readOperationsMap().keySet());\n                              methodsB.retainAll(leftPath.readOperationsMap().keySet());\n                              return Integer.compare(methodsB.size(), methodsA.size());\n                            }\n                          });\n              if (result.isPresent()) {\n                String rightUrl = result.get().getKey();\n                PathItem rightPath = changedPaths.getIncreased().remove(rightUrl);\n                Map<String, String> params = new LinkedHashMap<>();\n                if (!url.equals(rightUrl)) {\n                  List<String> oldParams = extractParameters(url);\n                  List<String> newParams = extractParameters(rightUrl);\n                  for (int i = 0; i < oldParams.size(); i++) {\n                    params.put(oldParams.get(i), newParams.get(i));\n                  }\n                }\n                DiffContext context = new DiffContext(openApiDiff.getOptions());\n                context.setUrl(url);\n                context.setParameters(params);\n                context.setLeftAndRightUrls(url, rightUrl);\n                builder\n                    .with(openApiDiff.getPathDiff().diff(leftPath, rightPath, context))\n                    .ifPresent(path -> changedPaths.getChanged().put(rightUrl, path));\n              } else {\n                changedPaths.getMissing().put(url, leftPath);\n              }\n            });\n    return builder.buildIsChanged(changedPaths);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedPaths>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "Map<String, PathItem>"}, {"name": "right", "type": "Map<String, PathItem>"}], "body": "                                                                           {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedPaths changedPaths = new ChangedPaths(left, right, openApiDiff.getOptions());\n    changedPaths.getIncreased().putAll(right);\n\n    left.keySet()\n        .forEach(\n            (String url) -> {\n              PathItem leftPath = left.get(url);\n              String template = normalizePath(url);\n              Optional<Map.Entry<String, PathItem>> result =\n                  changedPaths.getIncreased().entrySet().stream()\n                      .filter(item -> normalizePath(item.getKey()).equals(template))\n                      .min(\n                          (a, b) -> {\n                            if (methodsAndParametersIntersect(a.getValue(), b.getValue())) {\n                              throw new IllegalArgumentException(\n                                  \"Two path items have the same signature: \" + template);\n                            }\n                            if (a.getKey().equals(url)) {\n                              return -1;\n                            } else if (b.getKey().equals((url))) {\n                              return 1;\n                            } else {\n                              HashSet<PathItem.HttpMethod> methodsA =\n                                  new HashSet<>(a.getValue().readOperationsMap().keySet());\n                              methodsA.retainAll(leftPath.readOperationsMap().keySet());\n                              HashSet<PathItem.HttpMethod> methodsB =\n                                  new HashSet<>(b.getValue().readOperationsMap().keySet());\n                              methodsB.retainAll(leftPath.readOperationsMap().keySet());\n                              return Integer.compare(methodsB.size(), methodsA.size());\n                            }\n                          });\n              if (result.isPresent()) {\n                String rightUrl = result.get().getKey();\n                PathItem rightPath = changedPaths.getIncreased().remove(rightUrl);\n                Map<String, String> params = new LinkedHashMap<>();\n                if (!url.equals(rightUrl)) {\n                  List<String> oldParams = extractParameters(url);\n                  List<String> newParams = extractParameters(rightUrl);\n                  for (int i = 0; i < oldParams.size(); i++) {\n                    params.put(oldParams.get(i), newParams.get(i));\n                  }\n                }\n                DiffContext context = new DiffContext(openApiDiff.getOptions());\n                context.setUrl(url);\n                context.setParameters(params);\n                context.setLeftAndRightUrls(url, rightUrl);\n                builder\n                    .with(openApiDiff.getPathDiff().diff(leftPath, rightPath, context))\n                    .ifPresent(path -> changedPaths.getChanged().put(rightUrl, path));\n              } else {\n                changedPaths.getMissing().put(url, leftPath);\n              }\n            });\n    return builder.buildIsChanged(changedPaths);\n  }", "signature": "public DeferredChanged<ChangedPaths> diff(\n      final Map<String, PathItem> left, final Map<String, PathItem> right)"}, {"syntax_pass": true, "original_string": "  public static Paths valOrEmpty(Paths path) {\n    if (path == null) {\n      path = new Paths();\n    }\n    return path;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Paths", "classes": []}, "name": "valOrEmpty", "params": [{"name": "path", "type": "Paths"}], "body": "                                             {\n    if (path == null) {\n      path = new Paths();\n    }\n    return path;\n  }", "signature": "public static Paths valOrEmpty(Paths path)"}, {"syntax_pass": true, "original_string": "  private static boolean methodsAndParametersIntersect(PathItem a, PathItem b) {\n    Set<PathItem.HttpMethod> methodsA = a.readOperationsMap().keySet();\n    for (PathItem.HttpMethod method : b.readOperationsMap().keySet()) {\n      if (methodsA.contains(method)) {\n        Operation left = a.readOperationsMap().get(method);\n        Operation right = b.readOperationsMap().get(method);\n        if (left.getParameters().size() == right.getParameters().size()) {\n          return parametersIntersect(left.getParameters(), right.getParameters());\n        }\n        return false;\n      }\n    }\n    return false;\n  }", "docstring": "\n@param a a path form the open api spec\n@param b another path from the same open api spec\n@return <code>true</code> in case both paths are of the same method AND their templated\n    parameters are of the same type; <code>false</code> otherwise\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "methodsAndParametersIntersect", "params": [{"name": "a", "type": "PathItem"}, {"name": "b", "type": "PathItem"}], "body": "                                                                               {\n    Set<PathItem.HttpMethod> methodsA = a.readOperationsMap().keySet();\n    for (PathItem.HttpMethod method : b.readOperationsMap().keySet()) {\n      if (methodsA.contains(method)) {\n        Operation left = a.readOperationsMap().get(method);\n        Operation right = b.readOperationsMap().get(method);\n        if (left.getParameters().size() == right.getParameters().size()) {\n          return parametersIntersect(left.getParameters(), right.getParameters());\n        }\n        return false;\n      }\n    }\n    return false;\n  }", "signature": "private static boolean methodsAndParametersIntersect(PathItem a, PathItem b)"}, {"syntax_pass": true, "original_string": "  private static boolean parametersIntersect(List<Parameter> left, List<Parameter> right) {\n    int parametersSize = left.size();\n    long intersectedParameters =\n        IntStream.range(0, left.size())\n            .filter(\n                i -> left.get(i).getSchema().getType().equals(right.get(i).getSchema().getType()))\n            .count();\n    return parametersSize == intersectedParameters;\n  }", "docstring": "\n@param left parameters from the first compared method\n@param right parameters from the second compared method\n@return <code>true</code> in case each parameter pair is of the same type; <code>false</code>\n    otherwise\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "parametersIntersect", "params": [{"name": "left", "type": "List<Parameter>"}, {"name": "right", "type": "List<Parameter>"}], "body": "                                                                                          {\n    int parametersSize = left.size();\n    long intersectedParameters =\n        IntStream.range(0, left.size())\n            .filter(\n                i -> left.get(i).getSchema().getType().equals(right.get(i).getSchema().getType()))\n            .count();\n    return parametersSize == intersectedParameters;\n  }", "signature": "private static boolean parametersIntersect(List<Parameter> left, List<Parameter> right)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/ResponseDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.responses.ApiResponse;\nimport java.util.HashSet;\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedResponse;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.model.deferred.RealizedChanged;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\npublic class ResponseDiff extends ReferenceDiffCache<ApiResponse, ChangedResponse> {\n  private static final RefPointer<ApiResponse> refPointer = new RefPointer<>(RefType.RESPONSES);\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public ResponseDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public DeferredChanged<ChangedResponse> diff(\n      ApiResponse left, ApiResponse right, DiffContext context) {\n    if (left == null && right == null) {\n      return new RealizedChanged<>(Optional.empty());\n    }\n    if ((left == null && right != null) || (left != null && right == null)) {\n      return new RealizedChanged<>(Optional.of(new ChangedResponse(left, right, context)));\n    }\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }\n\n  @Override\n  protected DeferredChanged<ChangedResponse> computeDiff(\n      HashSet<String> refSet, ApiResponse left, ApiResponse right, DiffContext context) {\n    left = refPointer.resolveRef(leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedResponse changedResponse = new ChangedResponse(left, right, context);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedResponse::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedResponse::setContent);\n    builder\n        .with(openApiDiff.getHeadersDiff().diff(left.getHeaders(), right.getHeaders(), context))\n        .ifPresent(changedResponse::setHeaders);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedResponse::setExtensions);\n\n    return builder.buildIsChanged(changedResponse);\n  }\n}\n", "file_hash": "c47c3322a0ad6cb0ca6d2564cd1fe86736fac8c36325e3e335b25614dfd8947d", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.responses.ApiResponse;", "import java.util.HashSet;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedResponse;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.model.deferred.RealizedChanged;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "public class ResponseDiff extends ReferenceDiffCache<ApiResponse, ChangedResponse> {\n  private static final RefPointer<ApiResponse> refPointer = new RefPointer<>(RefType.RESPONSES);\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public ResponseDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public DeferredChanged<ChangedResponse> diff(\n      ApiResponse left, ApiResponse right, DiffContext context) {\n    if (left == null && right == null) {\n      return new RealizedChanged<>(Optional.empty());\n    }\n    if ((left == null && right != null) || (left != null && right == null)) {\n      return new RealizedChanged<>(Optional.of(new ChangedResponse(left, right, context)));\n    }\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }\n\n  @Override\n  protected DeferredChanged<ChangedResponse> computeDiff(\n      HashSet<String> refSet, ApiResponse left, ApiResponse right, DiffContext context) {\n    left = refPointer.resolveRef(leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedResponse changedResponse = new ChangedResponse(left, right, context);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedResponse::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedResponse::setContent);\n    builder\n        .with(openApiDiff.getHeadersDiff().diff(left.getHeaders(), right.getHeaders(), context))\n        .ifPresent(changedResponse::setHeaders);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedResponse::setExtensions);\n\n    return builder.buildIsChanged(changedResponse);\n  }\n}", "definition": "public class ResponseDiff extends ReferenceDiffCache<ApiResponse, ChangedResponse>", "class_docstring": "", "name": "ResponseDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final RefPointer<ApiResponse> refPointer = new RefPointer<>(RefType.RESPONSES);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RefPointer<ApiResponse>", "name": "refPointer = new RefPointer<>(RefType.RESPONSES)", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}, {"attribute_expression": "private final Components leftComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "leftComponents", "syntax_pass": true}, {"attribute_expression": "private final Components rightComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "rightComponents", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ResponseDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ResponseDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                               {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "signature": "public ResponseDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedResponse> diff(\n      ApiResponse left, ApiResponse right, DiffContext context) {\n    if (left == null && right == null) {\n      return new RealizedChanged<>(Optional.empty());\n    }\n    if ((left == null && right != null) || (left != null && right == null)) {\n      return new RealizedChanged<>(Optional.of(new ChangedResponse(left, right, context)));\n    }\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedResponse>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "ApiResponse"}, {"name": "right", "type": "ApiResponse"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                {\n    if (left == null && right == null) {\n      return new RealizedChanged<>(Optional.empty());\n    }\n    if ((left == null && right != null) || (left != null && right == null)) {\n      return new RealizedChanged<>(Optional.of(new ChangedResponse(left, right, context)));\n    }\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }", "signature": "public DeferredChanged<ChangedResponse> diff(\n      ApiResponse left, ApiResponse right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  protected DeferredChanged<ChangedResponse> computeDiff(\n      HashSet<String> refSet, ApiResponse left, ApiResponse right, DiffContext context) {\n    left = refPointer.resolveRef(leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedResponse changedResponse = new ChangedResponse(left, right, context);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedResponse::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedResponse::setContent);\n    builder\n        .with(openApiDiff.getHeadersDiff().diff(left.getHeaders(), right.getHeaders(), context))\n        .ifPresent(changedResponse::setHeaders);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedResponse::setExtensions);\n\n    return builder.buildIsChanged(changedResponse);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "DeferredChanged<ChangedResponse>", "classes": []}, "name": "computeDiff", "params": [{"name": "refSet", "type": "HashSet<String>"}, {"name": "left", "type": "ApiResponse"}, {"name": "right", "type": "ApiResponse"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                        {\n    left = refPointer.resolveRef(leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedResponse changedResponse = new ChangedResponse(left, right, context);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedResponse::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedResponse::setContent);\n    builder\n        .with(openApiDiff.getHeadersDiff().diff(left.getHeaders(), right.getHeaders(), context))\n        .ifPresent(changedResponse::setHeaders);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedResponse::setExtensions);\n\n    return builder.buildIsChanged(changedResponse);\n  }", "signature": "@Override\n  protected DeferredChanged<ChangedResponse> computeDiff(\n      HashSet<String> refSet, ApiResponse left, ApiResponse right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/HeaderDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.headers.Header;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedHeader;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\npublic class HeaderDiff extends ReferenceDiffCache<Header, ChangedHeader> {\n  private static final RefPointer<Header> refPointer = new RefPointer<>(RefType.HEADERS);\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public HeaderDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public DeferredChanged<ChangedHeader> diff(Header left, Header right, DiffContext context) {\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }\n\n  @Override\n  protected DeferredChanged<ChangedHeader> computeDiff(\n      HashSet<String> refSet, Header left, Header right, DiffContext context) {\n    left = refPointer.resolveRef(leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedHeader changedHeader =\n        new ChangedHeader(left, right, context)\n            .setRequired(getBooleanDiff(left.getRequired(), right.getRequired()))\n            .setDeprecated(\n                !Boolean.TRUE.equals(left.getDeprecated())\n                    && Boolean.TRUE.equals(right.getDeprecated()))\n            .setStyle(!Objects.equals(left.getStyle(), right.getStyle()))\n            .setExplode(getBooleanDiff(left.getExplode(), right.getExplode()));\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedHeader::setDescription);\n    builder\n        .with(\n            openApiDiff\n                .getSchemaDiff()\n                .diff(left.getSchema(), right.getSchema(), context.copyWithRequired(true)))\n        .ifPresent(changedHeader::setSchema);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedHeader::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedHeader::setExtensions);\n    return builder.buildIsChanged(changedHeader);\n  }\n\n  private boolean getBooleanDiff(Boolean left, Boolean right) {\n    boolean leftRequired = Optional.ofNullable(left).orElse(Boolean.FALSE);\n    boolean rightRequired = Optional.ofNullable(right).orElse(Boolean.FALSE);\n    return leftRequired != rightRequired;\n  }\n}\n", "file_hash": "962dc327c5f24bd88e40a236fa9ea9107c5395d1e37fbec3257d972ab66ba0aa", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.headers.Header;", "import java.util.HashSet;", "import java.util.Objects;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedHeader;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "public class HeaderDiff extends ReferenceDiffCache<Header, ChangedHeader> {\n  private static final RefPointer<Header> refPointer = new RefPointer<>(RefType.HEADERS);\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public HeaderDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public DeferredChanged<ChangedHeader> diff(Header left, Header right, DiffContext context) {\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }\n\n  @Override\n  protected DeferredChanged<ChangedHeader> computeDiff(\n      HashSet<String> refSet, Header left, Header right, DiffContext context) {\n    left = refPointer.resolveRef(leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedHeader changedHeader =\n        new ChangedHeader(left, right, context)\n            .setRequired(getBooleanDiff(left.getRequired(), right.getRequired()))\n            .setDeprecated(\n                !Boolean.TRUE.equals(left.getDeprecated())\n                    && Boolean.TRUE.equals(right.getDeprecated()))\n            .setStyle(!Objects.equals(left.getStyle(), right.getStyle()))\n            .setExplode(getBooleanDiff(left.getExplode(), right.getExplode()));\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedHeader::setDescription);\n    builder\n        .with(\n            openApiDiff\n                .getSchemaDiff()\n                .diff(left.getSchema(), right.getSchema(), context.copyWithRequired(true)))\n        .ifPresent(changedHeader::setSchema);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedHeader::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedHeader::setExtensions);\n    return builder.buildIsChanged(changedHeader);\n  }\n\n  private boolean getBooleanDiff(Boolean left, Boolean right) {\n    boolean leftRequired = Optional.ofNullable(left).orElse(Boolean.FALSE);\n    boolean rightRequired = Optional.ofNullable(right).orElse(Boolean.FALSE);\n    return leftRequired != rightRequired;\n  }\n}", "definition": "public class HeaderDiff extends ReferenceDiffCache<Header, ChangedHeader>", "class_docstring": "", "name": "HeaderDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final RefPointer<Header> refPointer = new RefPointer<>(RefType.HEADERS);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RefPointer<Header>", "name": "refPointer = new RefPointer<>(RefType.HEADERS)", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}, {"attribute_expression": "private final Components leftComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "leftComponents", "syntax_pass": true}, {"attribute_expression": "private final Components rightComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "rightComponents", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public HeaderDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "HeaderDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                             {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "signature": "public HeaderDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedHeader> diff(Header left, Header right, DiffContext context) {\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedHeader>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "Header"}, {"name": "right", "type": "Header"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                             {\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }", "signature": "public DeferredChanged<ChangedHeader> diff(Header left, Header right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  protected DeferredChanged<ChangedHeader> computeDiff(\n      HashSet<String> refSet, Header left, Header right, DiffContext context) {\n    left = refPointer.resolveRef(leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedHeader changedHeader =\n        new ChangedHeader(left, right, context)\n            .setRequired(getBooleanDiff(left.getRequired(), right.getRequired()))\n            .setDeprecated(\n                !Boolean.TRUE.equals(left.getDeprecated())\n                    && Boolean.TRUE.equals(right.getDeprecated()))\n            .setStyle(!Objects.equals(left.getStyle(), right.getStyle()))\n            .setExplode(getBooleanDiff(left.getExplode(), right.getExplode()));\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedHeader::setDescription);\n    builder\n        .with(\n            openApiDiff\n                .getSchemaDiff()\n                .diff(left.getSchema(), right.getSchema(), context.copyWithRequired(true)))\n        .ifPresent(changedHeader::setSchema);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedHeader::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedHeader::setExtensions);\n    return builder.buildIsChanged(changedHeader);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "DeferredChanged<ChangedHeader>", "classes": []}, "name": "computeDiff", "params": [{"name": "refSet", "type": "HashSet<String>"}, {"name": "left", "type": "Header"}, {"name": "right", "type": "Header"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                              {\n    left = refPointer.resolveRef(leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n    ChangedHeader changedHeader =\n        new ChangedHeader(left, right, context)\n            .setRequired(getBooleanDiff(left.getRequired(), right.getRequired()))\n            .setDeprecated(\n                !Boolean.TRUE.equals(left.getDeprecated())\n                    && Boolean.TRUE.equals(right.getDeprecated()))\n            .setStyle(!Objects.equals(left.getStyle(), right.getStyle()))\n            .setExplode(getBooleanDiff(left.getExplode(), right.getExplode()));\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedHeader::setDescription);\n    builder\n        .with(\n            openApiDiff\n                .getSchemaDiff()\n                .diff(left.getSchema(), right.getSchema(), context.copyWithRequired(true)))\n        .ifPresent(changedHeader::setSchema);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedHeader::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedHeader::setExtensions);\n    return builder.buildIsChanged(changedHeader);\n  }", "signature": "@Override\n  protected DeferredChanged<ChangedHeader> computeDiff(\n      HashSet<String> refSet, Header left, Header right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  private boolean getBooleanDiff(Boolean left, Boolean right) {\n    boolean leftRequired = Optional.ofNullable(left).orElse(Boolean.FALSE);\n    boolean rightRequired = Optional.ofNullable(right).orElse(Boolean.FALSE);\n    return leftRequired != rightRequired;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "getBooleanDiff", "params": [{"name": "left", "type": "Boolean"}, {"name": "right", "type": "Boolean"}], "body": "                                                              {\n    boolean leftRequired = Optional.ofNullable(left).orElse(Boolean.FALSE);\n    boolean rightRequired = Optional.ofNullable(right).orElse(Boolean.FALSE);\n    return leftRequired != rightRequired;\n  }", "signature": "private boolean getBooleanDiff(Boolean left, Boolean right)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/ContentDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isUnchanged;\n\nimport io.swagger.v3.oas.models.media.Content;\nimport io.swagger.v3.oas.models.media.MediaType;\nimport java.util.*;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedContent;\nimport org.openapitools.openapidiff.core.model.ChangedMediaType;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\n\npublic class ContentDiff {\n\n  private final OpenApiDiff openApiDiff;\n\n  public ContentDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedContent> diff(Content left, Content right, DiffContext context) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    MapKeyDiff<String, MediaType> mediaTypeDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedMediaTypes = mediaTypeDiff.getSharedKey();\n    Map<String, ChangedMediaType> changedMediaTypes = new LinkedHashMap<>();\n\n    sharedMediaTypes.stream()\n        .forEach(\n            mediaTypeKey -> {\n              MediaType oldMediaType = left.get(mediaTypeKey);\n              MediaType newMediaType = right.get(mediaTypeKey);\n\n              ChangedMediaType changedMediaType =\n                  new ChangedMediaType(oldMediaType.getSchema(), newMediaType.getSchema(), context);\n\n              builder\n                  .with(\n                      openApiDiff\n                          .getSchemaDiff()\n                          .diff(\n                              oldMediaType.getSchema(),\n                              newMediaType.getSchema(),\n                              context.copyWithRequired(true)))\n                  .ifPresent(\n                      value -> {\n                        changedMediaType.setSchema(value);\n                        if (!isUnchanged(changedMediaType)) {\n                          changedMediaTypes.put(mediaTypeKey, changedMediaType);\n                        }\n                      });\n            });\n\n    return builder\n        .build()\n        .mapOptional(\n            value ->\n                isChanged(\n                    new ChangedContent(left, right, context)\n                        .setIncreased(mediaTypeDiff.getIncreased())\n                        .setMissing(mediaTypeDiff.getMissing())\n                        .setChanged(changedMediaTypes)));\n  }\n}\n", "file_hash": "74765589d8feffa2bb7a923d24e1c5c8fa459af321f07a0f76351167e27e302d", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isUnchanged;", "import io.swagger.v3.oas.models.media.Content;", "import io.swagger.v3.oas.models.media.MediaType;", "import java.util.*;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedContent;", "import org.openapitools.openapidiff.core.model.ChangedMediaType;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;"], "methods": [], "classes": [{"original_string": "public class ContentDiff {\n\n  private final OpenApiDiff openApiDiff;\n\n  public ContentDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedContent> diff(Content left, Content right, DiffContext context) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    MapKeyDiff<String, MediaType> mediaTypeDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedMediaTypes = mediaTypeDiff.getSharedKey();\n    Map<String, ChangedMediaType> changedMediaTypes = new LinkedHashMap<>();\n\n    sharedMediaTypes.stream()\n        .forEach(\n            mediaTypeKey -> {\n              MediaType oldMediaType = left.get(mediaTypeKey);\n              MediaType newMediaType = right.get(mediaTypeKey);\n\n              ChangedMediaType changedMediaType =\n                  new ChangedMediaType(oldMediaType.getSchema(), newMediaType.getSchema(), context);\n\n              builder\n                  .with(\n                      openApiDiff\n                          .getSchemaDiff()\n                          .diff(\n                              oldMediaType.getSchema(),\n                              newMediaType.getSchema(),\n                              context.copyWithRequired(true)))\n                  .ifPresent(\n                      value -> {\n                        changedMediaType.setSchema(value);\n                        if (!isUnchanged(changedMediaType)) {\n                          changedMediaTypes.put(mediaTypeKey, changedMediaType);\n                        }\n                      });\n            });\n\n    return builder\n        .build()\n        .mapOptional(\n            value ->\n                isChanged(\n                    new ChangedContent(left, right, context)\n                        .setIncreased(mediaTypeDiff.getIncreased())\n                        .setMissing(mediaTypeDiff.getMissing())\n                        .setChanged(changedMediaTypes)));\n  }\n}", "definition": "public class ContentDiff", "class_docstring": "", "name": "ContentDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ContentDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ContentDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                              {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public ContentDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedContent> diff(Content left, Content right, DiffContext context) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    MapKeyDiff<String, MediaType> mediaTypeDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedMediaTypes = mediaTypeDiff.getSharedKey();\n    Map<String, ChangedMediaType> changedMediaTypes = new LinkedHashMap<>();\n\n    sharedMediaTypes.stream()\n        .forEach(\n            mediaTypeKey -> {\n              MediaType oldMediaType = left.get(mediaTypeKey);\n              MediaType newMediaType = right.get(mediaTypeKey);\n\n              ChangedMediaType changedMediaType =\n                  new ChangedMediaType(oldMediaType.getSchema(), newMediaType.getSchema(), context);\n\n              builder\n                  .with(\n                      openApiDiff\n                          .getSchemaDiff()\n                          .diff(\n                              oldMediaType.getSchema(),\n                              newMediaType.getSchema(),\n                              context.copyWithRequired(true)))\n                  .ifPresent(\n                      value -> {\n                        changedMediaType.setSchema(value);\n                        if (!isUnchanged(changedMediaType)) {\n                          changedMediaTypes.put(mediaTypeKey, changedMediaType);\n                        }\n                      });\n            });\n\n    return builder\n        .build()\n        .mapOptional(\n            value ->\n                isChanged(\n                    new ChangedContent(left, right, context)\n                        .setIncreased(mediaTypeDiff.getIncreased())\n                        .setMissing(mediaTypeDiff.getMissing())\n                        .setChanged(changedMediaTypes)));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedContent>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "Content"}, {"name": "right", "type": "Content"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                                {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    MapKeyDiff<String, MediaType> mediaTypeDiff = MapKeyDiff.diff(left, right);\n    List<String> sharedMediaTypes = mediaTypeDiff.getSharedKey();\n    Map<String, ChangedMediaType> changedMediaTypes = new LinkedHashMap<>();\n\n    sharedMediaTypes.stream()\n        .forEach(\n            mediaTypeKey -> {\n              MediaType oldMediaType = left.get(mediaTypeKey);\n              MediaType newMediaType = right.get(mediaTypeKey);\n\n              ChangedMediaType changedMediaType =\n                  new ChangedMediaType(oldMediaType.getSchema(), newMediaType.getSchema(), context);\n\n              builder\n                  .with(\n                      openApiDiff\n                          .getSchemaDiff()\n                          .diff(\n                              oldMediaType.getSchema(),\n                              newMediaType.getSchema(),\n                              context.copyWithRequired(true)))\n                  .ifPresent(\n                      value -> {\n                        changedMediaType.setSchema(value);\n                        if (!isUnchanged(changedMediaType)) {\n                          changedMediaTypes.put(mediaTypeKey, changedMediaType);\n                        }\n                      });\n            });\n\n    return builder\n        .build()\n        .mapOptional(\n            value ->\n                isChanged(\n                    new ChangedContent(left, right, context)\n                        .setIncreased(mediaTypeDiff.getIncreased())\n                        .setMissing(mediaTypeDiff.getMissing())\n                        .setChanged(changedMediaTypes)));\n  }", "signature": "public DeferredChanged<ChangedContent> diff(Content left, Content right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/ParameterDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.parameters.Parameter;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedParameter;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\npublic class ParameterDiff extends ReferenceDiffCache<Parameter, ChangedParameter> {\n\n  private static final RefPointer<Parameter> refPointer = new RefPointer<>(RefType.PARAMETERS);\n  private final Components leftComponents;\n  private final Components rightComponents;\n  private final OpenApiDiff openApiDiff;\n\n  public ParameterDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public DeferredChanged<ChangedParameter> diff(\n      Parameter left, Parameter right, DiffContext context) {\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }\n\n  @Override\n  protected DeferredChanged<ChangedParameter> computeDiff(\n      HashSet<String> refSet, Parameter left, Parameter right, DiffContext context) {\n    left = refPointer.resolveRef(this.leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(this.rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedParameter changedParameter =\n        new ChangedParameter(right.getName(), right.getIn(), context)\n            .setOldParameter(left)\n            .setNewParameter(right)\n            .setChangeRequired(getBooleanDiff(left.getRequired(), right.getRequired()))\n            .setDeprecated(\n                !Boolean.TRUE.equals(left.getDeprecated())\n                    && Boolean.TRUE.equals(right.getDeprecated()))\n            .setChangeAllowEmptyValue(\n                getBooleanDiff(left.getAllowEmptyValue(), right.getAllowEmptyValue()))\n            .setChangeStyle(!Objects.equals(left.getStyle(), right.getStyle()))\n            .setChangeExplode(getBooleanDiff(left.getExplode(), right.getExplode()));\n    builder\n        .with(\n            openApiDiff\n                .getSchemaDiff()\n                .diff(left.getSchema(), right.getSchema(), context.copyWithRequired(true)))\n        .ifPresent(changedParameter::setSchema);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedParameter::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedParameter::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedParameter::setExtensions);\n    return builder.buildIsChanged(changedParameter);\n  }\n\n  private boolean getBooleanDiff(Boolean left, Boolean right) {\n    boolean leftRequired = Optional.ofNullable(left).orElse(Boolean.FALSE);\n    boolean rightRequired = Optional.ofNullable(right).orElse(Boolean.FALSE);\n    return leftRequired != rightRequired;\n  }\n}\n", "file_hash": "4709239183be0fc31fe19a5902602c8cdd914e86c8841ff27c0ac721ca95136d", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.parameters.Parameter;", "import java.util.HashSet;", "import java.util.Objects;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedParameter;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "public class ParameterDiff extends ReferenceDiffCache<Parameter, ChangedParameter> {\n\n  private static final RefPointer<Parameter> refPointer = new RefPointer<>(RefType.PARAMETERS);\n  private final Components leftComponents;\n  private final Components rightComponents;\n  private final OpenApiDiff openApiDiff;\n\n  public ParameterDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public DeferredChanged<ChangedParameter> diff(\n      Parameter left, Parameter right, DiffContext context) {\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }\n\n  @Override\n  protected DeferredChanged<ChangedParameter> computeDiff(\n      HashSet<String> refSet, Parameter left, Parameter right, DiffContext context) {\n    left = refPointer.resolveRef(this.leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(this.rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedParameter changedParameter =\n        new ChangedParameter(right.getName(), right.getIn(), context)\n            .setOldParameter(left)\n            .setNewParameter(right)\n            .setChangeRequired(getBooleanDiff(left.getRequired(), right.getRequired()))\n            .setDeprecated(\n                !Boolean.TRUE.equals(left.getDeprecated())\n                    && Boolean.TRUE.equals(right.getDeprecated()))\n            .setChangeAllowEmptyValue(\n                getBooleanDiff(left.getAllowEmptyValue(), right.getAllowEmptyValue()))\n            .setChangeStyle(!Objects.equals(left.getStyle(), right.getStyle()))\n            .setChangeExplode(getBooleanDiff(left.getExplode(), right.getExplode()));\n    builder\n        .with(\n            openApiDiff\n                .getSchemaDiff()\n                .diff(left.getSchema(), right.getSchema(), context.copyWithRequired(true)))\n        .ifPresent(changedParameter::setSchema);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedParameter::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedParameter::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedParameter::setExtensions);\n    return builder.buildIsChanged(changedParameter);\n  }\n\n  private boolean getBooleanDiff(Boolean left, Boolean right) {\n    boolean leftRequired = Optional.ofNullable(left).orElse(Boolean.FALSE);\n    boolean rightRequired = Optional.ofNullable(right).orElse(Boolean.FALSE);\n    return leftRequired != rightRequired;\n  }\n}", "definition": "public class ParameterDiff extends ReferenceDiffCache<Parameter, ChangedParameter>", "class_docstring": "", "name": "ParameterDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final RefPointer<Parameter> refPointer = new RefPointer<>(RefType.PARAMETERS);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RefPointer<Parameter>", "name": "refPointer = new RefPointer<>(RefType.PARAMETERS)", "syntax_pass": true}, {"attribute_expression": "private final Components leftComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "leftComponents", "syntax_pass": true}, {"attribute_expression": "private final Components rightComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "rightComponents", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ParameterDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ParameterDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "signature": "public ParameterDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedParameter> diff(\n      Parameter left, Parameter right, DiffContext context) {\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedParameter>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "Parameter"}, {"name": "right", "type": "Parameter"}, {"name": "context", "type": "DiffContext"}], "body": "                                                            {\n    return cachedDiff(new HashSet<>(), left, right, left.get$ref(), right.get$ref(), context);\n  }", "signature": "public DeferredChanged<ChangedParameter> diff(\n      Parameter left, Parameter right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  protected DeferredChanged<ChangedParameter> computeDiff(\n      HashSet<String> refSet, Parameter left, Parameter right, DiffContext context) {\n    left = refPointer.resolveRef(this.leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(this.rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedParameter changedParameter =\n        new ChangedParameter(right.getName(), right.getIn(), context)\n            .setOldParameter(left)\n            .setNewParameter(right)\n            .setChangeRequired(getBooleanDiff(left.getRequired(), right.getRequired()))\n            .setDeprecated(\n                !Boolean.TRUE.equals(left.getDeprecated())\n                    && Boolean.TRUE.equals(right.getDeprecated()))\n            .setChangeAllowEmptyValue(\n                getBooleanDiff(left.getAllowEmptyValue(), right.getAllowEmptyValue()))\n            .setChangeStyle(!Objects.equals(left.getStyle(), right.getStyle()))\n            .setChangeExplode(getBooleanDiff(left.getExplode(), right.getExplode()));\n    builder\n        .with(\n            openApiDiff\n                .getSchemaDiff()\n                .diff(left.getSchema(), right.getSchema(), context.copyWithRequired(true)))\n        .ifPresent(changedParameter::setSchema);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedParameter::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedParameter::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedParameter::setExtensions);\n    return builder.buildIsChanged(changedParameter);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "DeferredChanged<ChangedParameter>", "classes": []}, "name": "computeDiff", "params": [{"name": "refSet", "type": "HashSet<String>"}, {"name": "left", "type": "Parameter"}, {"name": "right", "type": "Parameter"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                    {\n    left = refPointer.resolveRef(this.leftComponents, left, left.get$ref());\n    right = refPointer.resolveRef(this.rightComponents, right, right.get$ref());\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedParameter changedParameter =\n        new ChangedParameter(right.getName(), right.getIn(), context)\n            .setOldParameter(left)\n            .setNewParameter(right)\n            .setChangeRequired(getBooleanDiff(left.getRequired(), right.getRequired()))\n            .setDeprecated(\n                !Boolean.TRUE.equals(left.getDeprecated())\n                    && Boolean.TRUE.equals(right.getDeprecated()))\n            .setChangeAllowEmptyValue(\n                getBooleanDiff(left.getAllowEmptyValue(), right.getAllowEmptyValue()))\n            .setChangeStyle(!Objects.equals(left.getStyle(), right.getStyle()))\n            .setChangeExplode(getBooleanDiff(left.getExplode(), right.getExplode()));\n    builder\n        .with(\n            openApiDiff\n                .getSchemaDiff()\n                .diff(left.getSchema(), right.getSchema(), context.copyWithRequired(true)))\n        .ifPresent(changedParameter::setSchema);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedParameter::setDescription);\n    builder\n        .with(openApiDiff.getContentDiff().diff(left.getContent(), right.getContent(), context))\n        .ifPresent(changedParameter::setContent);\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedParameter::setExtensions);\n    return builder.buildIsChanged(changedParameter);\n  }", "signature": "@Override\n  protected DeferredChanged<ChangedParameter> computeDiff(\n      HashSet<String> refSet, Parameter left, Parameter right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  private boolean getBooleanDiff(Boolean left, Boolean right) {\n    boolean leftRequired = Optional.ofNullable(left).orElse(Boolean.FALSE);\n    boolean rightRequired = Optional.ofNullable(right).orElse(Boolean.FALSE);\n    return leftRequired != rightRequired;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "getBooleanDiff", "params": [{"name": "left", "type": "Boolean"}, {"name": "right", "type": "Boolean"}], "body": "                                                              {\n    boolean leftRequired = Optional.ofNullable(left).orElse(Boolean.FALSE);\n    boolean rightRequired = Optional.ofNullable(right).orElse(Boolean.FALSE);\n    return leftRequired != rightRequired;\n  }", "signature": "private boolean getBooleanDiff(Boolean left, Boolean right)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/ReferenceDiffCache.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.model.deferred.RealizedChanged;\n\npublic abstract class ReferenceDiffCache<C, D extends Changed> {\n  private final Map<CacheKey, DeferredChanged<D>> refDiffMap;\n\n  public ReferenceDiffCache() {\n    this.refDiffMap = new HashMap<>();\n  }\n\n  private DeferredChanged<D> getFromCache(CacheKey cacheKey) {\n    return refDiffMap.get(cacheKey);\n  }\n\n  private void addToCache(CacheKey cacheKey, DeferredChanged<D> changed) {\n    refDiffMap.put(cacheKey, changed);\n  }\n\n  public DeferredChanged<D> cachedDiff(\n      HashSet<String> refSet,\n      C left,\n      C right,\n      String leftRef,\n      String rightRef,\n      DiffContext context) {\n    boolean areBothRefParameters = leftRef != null && rightRef != null;\n    if (areBothRefParameters) {\n      CacheKey key = new CacheKey(leftRef, rightRef, context);\n      DeferredChanged<D> changedFromRef = getFromCache(key);\n      if (changedFromRef != null) {\n        return changedFromRef;\n      } else {\n        String refKey = getRefKey(leftRef, rightRef);\n        if (refSet.contains(refKey)) {\n          return RealizedChanged.empty();\n        } else {\n          refSet.add(refKey);\n          DeferredChanged<D> changed = computeDiff(refSet, left, right, context);\n          addToCache(key, changed);\n          refSet.remove(refKey);\n          return changed;\n        }\n      }\n    } else {\n      return computeDiff(refSet, left, right, context);\n    }\n  }\n\n  protected String getRefKey(String leftRef, String rightRef) {\n    return leftRef + \":\" + rightRef;\n  }\n\n  protected abstract DeferredChanged<D> computeDiff(\n      HashSet<String> refSet, C left, C right, DiffContext context);\n}\n", "file_hash": "e2e7f98882a660376f564bc1680fa8d929e7f93efa1ccca0a5b7508c9756020a", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import java.util.HashMap;", "import java.util.HashSet;", "import java.util.Map;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.model.deferred.RealizedChanged;"], "methods": [], "classes": [{"original_string": "public abstract class ReferenceDiffCache<C, D extends Changed> {\n  private final Map<CacheKey, DeferredChanged<D>> refDiffMap;\n\n  public ReferenceDiffCache() {\n    this.refDiffMap = new HashMap<>();\n  }\n\n  private DeferredChanged<D> getFromCache(CacheKey cacheKey) {\n    return refDiffMap.get(cacheKey);\n  }\n\n  private void addToCache(CacheKey cacheKey, DeferredChanged<D> changed) {\n    refDiffMap.put(cacheKey, changed);\n  }\n\n  public DeferredChanged<D> cachedDiff(\n      HashSet<String> refSet,\n      C left,\n      C right,\n      String leftRef,\n      String rightRef,\n      DiffContext context) {\n    boolean areBothRefParameters = leftRef != null && rightRef != null;\n    if (areBothRefParameters) {\n      CacheKey key = new CacheKey(leftRef, rightRef, context);\n      DeferredChanged<D> changedFromRef = getFromCache(key);\n      if (changedFromRef != null) {\n        return changedFromRef;\n      } else {\n        String refKey = getRefKey(leftRef, rightRef);\n        if (refSet.contains(refKey)) {\n          return RealizedChanged.empty();\n        } else {\n          refSet.add(refKey);\n          DeferredChanged<D> changed = computeDiff(refSet, left, right, context);\n          addToCache(key, changed);\n          refSet.remove(refKey);\n          return changed;\n        }\n      }\n    } else {\n      return computeDiff(refSet, left, right, context);\n    }\n  }\n\n  protected String getRefKey(String leftRef, String rightRef) {\n    return leftRef + \":\" + rightRef;\n  }\n\n  protected abstract DeferredChanged<D> computeDiff(\n      HashSet<String> refSet, C left, C right, DiffContext context);\n}", "definition": "public abstract class ReferenceDiffCache<C, D extends Changed>", "class_docstring": "", "name": "ReferenceDiffCache", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [{"attribute_expression": "private final Map<CacheKey, DeferredChanged<D>> refDiffMap;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<CacheKey, DeferredChanged<D>>", "name": "refDiffMap", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ReferenceDiffCache() {\n    this.refDiffMap = new HashMap<>();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceDiffCache", "params": [], "body": "                              {\n    this.refDiffMap = new HashMap<>();\n  }", "signature": "public ReferenceDiffCache()"}, {"syntax_pass": true, "original_string": "  private DeferredChanged<D> getFromCache(CacheKey cacheKey) {\n    return refDiffMap.get(cacheKey);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DeferredChanged<D>", "classes": []}, "name": "getFromCache", "params": [{"name": "cacheKey", "type": "CacheKey"}], "body": "                                                             {\n    return refDiffMap.get(cacheKey);\n  }", "signature": "private DeferredChanged<D> getFromCache(CacheKey cacheKey)"}, {"syntax_pass": true, "original_string": "  private void addToCache(CacheKey cacheKey, DeferredChanged<D> changed) {\n    refDiffMap.put(cacheKey, changed);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "addToCache", "params": [{"name": "cacheKey", "type": "CacheKey"}, {"name": "changed", "type": "DeferredChanged<D>"}], "body": "                                                                         {\n    refDiffMap.put(cacheKey, changed);\n  }", "signature": "private void addToCache(CacheKey cacheKey, DeferredChanged<D> changed)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<D> cachedDiff(\n      HashSet<String> refSet,\n      C left,\n      C right,\n      String leftRef,\n      String rightRef,\n      DiffContext context) {\n    boolean areBothRefParameters = leftRef != null && rightRef != null;\n    if (areBothRefParameters) {\n      CacheKey key = new CacheKey(leftRef, rightRef, context);\n      DeferredChanged<D> changedFromRef = getFromCache(key);\n      if (changedFromRef != null) {\n        return changedFromRef;\n      } else {\n        String refKey = getRefKey(leftRef, rightRef);\n        if (refSet.contains(refKey)) {\n          return RealizedChanged.empty();\n        } else {\n          refSet.add(refKey);\n          DeferredChanged<D> changed = computeDiff(refSet, left, right, context);\n          addToCache(key, changed);\n          refSet.remove(refKey);\n          return changed;\n        }\n      }\n    } else {\n      return computeDiff(refSet, left, right, context);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<D>", "classes": []}, "name": "cachedDiff", "params": [{"name": "refSet", "type": "HashSet<String>"}, {"name": "left", "type": "C"}, {"name": "right", "type": "C"}, {"name": "leftRef", "type": "String"}, {"name": "rightRef", "type": "String"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n    boolean areBothRefParameters = leftRef != null && rightRef != null;\n    if (areBothRefParameters) {\n      CacheKey key = new CacheKey(leftRef, rightRef, context);\n      DeferredChanged<D> changedFromRef = getFromCache(key);\n      if (changedFromRef != null) {\n        return changedFromRef;\n      } else {\n        String refKey = getRefKey(leftRef, rightRef);\n        if (refSet.contains(refKey)) {\n          return RealizedChanged.empty();\n        } else {\n          refSet.add(refKey);\n          DeferredChanged<D> changed = computeDiff(refSet, left, right, context);\n          addToCache(key, changed);\n          refSet.remove(refKey);\n          return changed;\n        }\n      }\n    } else {\n      return computeDiff(refSet, left, right, context);\n    }\n  }", "signature": "public DeferredChanged<D> cachedDiff(\n      HashSet<String> refSet,\n      C left,\n      C right,\n      String leftRef,\n      String rightRef,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  protected String getRefKey(String leftRef, String rightRef) {\n    return leftRef + \":\" + rightRef;\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "getRefKey", "params": [{"name": "leftRef", "type": "String"}, {"name": "rightRef", "type": "String"}], "body": "                                                              {\n    return leftRef + \":\" + rightRef;\n  }", "signature": "protected String getRefKey(String leftRef, String rightRef)"}, {"syntax_pass": true, "original_string": "  protected abstract DeferredChanged<D> computeDiff(\n      HashSet<String> refSet, C left, C right, DiffContext context);", "docstring": "", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "DeferredChanged<D>", "classes": []}, "name": "computeDiff", "params": [{"name": "refSet", "type": "HashSet<String>"}, {"name": "left", "type": "C"}, {"name": "right", "type": "C"}, {"name": "context", "type": "DiffContext"}], "body": "", "signature": "protected abstract DeferredChanged<D> computeDiff(\n      HashSet<String> refSet, C left, C right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/OAuthFlowDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static java.util.Optional.ofNullable;\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\n\nimport io.swagger.v3.oas.models.security.OAuthFlow;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.ChangedOAuthFlow;\nimport org.openapitools.openapidiff.core.model.DiffContext;\n\npublic class OAuthFlowDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public OAuthFlowDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  private static Map<String, Object> getExtensions(OAuthFlow oAuthFlow) {\n    return ofNullable(oAuthFlow).map(OAuthFlow::getExtensions).orElse(null);\n  }\n\n  public Optional<ChangedOAuthFlow> diff(OAuthFlow left, OAuthFlow right, DiffContext context) {\n    ChangedOAuthFlow changedOAuthFlow = new ChangedOAuthFlow(left, right, context);\n    if (left != null && right != null) {\n      changedOAuthFlow\n          .setAuthorizationUrl(\n              !Objects.equals(left.getAuthorizationUrl(), right.getAuthorizationUrl()))\n          .setTokenUrl(!Objects.equals(left.getTokenUrl(), right.getTokenUrl()))\n          .setRefreshUrl(!Objects.equals(left.getRefreshUrl(), right.getRefreshUrl()));\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(getExtensions(left), getExtensions(right))\n        .ifPresent(changedOAuthFlow::setExtensions);\n    return isChanged(changedOAuthFlow);\n  }\n}\n", "file_hash": "888aa4043bbad655c48bec85fd8b55062cb4765703137cbabf2ebdaceaa9d1e8", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static java.util.Optional.ofNullable;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import io.swagger.v3.oas.models.security.OAuthFlow;", "import java.util.Map;", "import java.util.Objects;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.ChangedOAuthFlow;", "import org.openapitools.openapidiff.core.model.DiffContext;"], "methods": [], "classes": [{"original_string": "public class OAuthFlowDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public OAuthFlowDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  private static Map<String, Object> getExtensions(OAuthFlow oAuthFlow) {\n    return ofNullable(oAuthFlow).map(OAuthFlow::getExtensions).orElse(null);\n  }\n\n  public Optional<ChangedOAuthFlow> diff(OAuthFlow left, OAuthFlow right, DiffContext context) {\n    ChangedOAuthFlow changedOAuthFlow = new ChangedOAuthFlow(left, right, context);\n    if (left != null && right != null) {\n      changedOAuthFlow\n          .setAuthorizationUrl(\n              !Objects.equals(left.getAuthorizationUrl(), right.getAuthorizationUrl()))\n          .setTokenUrl(!Objects.equals(left.getTokenUrl(), right.getTokenUrl()))\n          .setRefreshUrl(!Objects.equals(left.getRefreshUrl(), right.getRefreshUrl()));\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(getExtensions(left), getExtensions(right))\n        .ifPresent(changedOAuthFlow::setExtensions);\n    return isChanged(changedOAuthFlow);\n  }\n}", "definition": "public class OAuthFlowDiff", "class_docstring": "", "name": "OAuthFlowDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public OAuthFlowDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "OAuthFlowDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public OAuthFlowDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  private static Map<String, Object> getExtensions(OAuthFlow oAuthFlow) {\n    return ofNullable(oAuthFlow).map(OAuthFlow::getExtensions).orElse(null);\n  }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "getExtensions", "params": [{"name": "oAuthFlow", "type": "OAuthFlow"}], "body": "                                                                        {\n    return ofNullable(oAuthFlow).map(OAuthFlow::getExtensions).orElse(null);\n  }", "signature": "private static Map<String, Object> getExtensions(OAuthFlow oAuthFlow)"}, {"syntax_pass": true, "original_string": "  public Optional<ChangedOAuthFlow> diff(OAuthFlow left, OAuthFlow right, DiffContext context) {\n    ChangedOAuthFlow changedOAuthFlow = new ChangedOAuthFlow(left, right, context);\n    if (left != null && right != null) {\n      changedOAuthFlow\n          .setAuthorizationUrl(\n              !Objects.equals(left.getAuthorizationUrl(), right.getAuthorizationUrl()))\n          .setTokenUrl(!Objects.equals(left.getTokenUrl(), right.getTokenUrl()))\n          .setRefreshUrl(!Objects.equals(left.getRefreshUrl(), right.getRefreshUrl()));\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(getExtensions(left), getExtensions(right))\n        .ifPresent(changedOAuthFlow::setExtensions);\n    return isChanged(changedOAuthFlow);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<ChangedOAuthFlow>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "OAuthFlow"}, {"name": "right", "type": "OAuthFlow"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                               {\n    ChangedOAuthFlow changedOAuthFlow = new ChangedOAuthFlow(left, right, context);\n    if (left != null && right != null) {\n      changedOAuthFlow\n          .setAuthorizationUrl(\n              !Objects.equals(left.getAuthorizationUrl(), right.getAuthorizationUrl()))\n          .setTokenUrl(!Objects.equals(left.getTokenUrl(), right.getTokenUrl()))\n          .setRefreshUrl(!Objects.equals(left.getRefreshUrl(), right.getRefreshUrl()));\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(getExtensions(left), getExtensions(right))\n        .ifPresent(changedOAuthFlow::setExtensions);\n    return isChanged(changedOAuthFlow);\n  }", "signature": "public Optional<ChangedOAuthFlow> diff(OAuthFlow left, OAuthFlow right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/MetadataDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\n\nimport java.util.Optional;\nimport org.openapitools.openapidiff.core.model.ChangedMetadata;\nimport org.openapitools.openapidiff.core.model.DiffContext;\n\npublic class MetadataDiff {\n  public MetadataDiff(OpenApiDiff openApiDiff) {}\n\n  public Optional<ChangedMetadata> diff(String left, String right, DiffContext context) {\n    return isChanged(new ChangedMetadata().setLeft(left).setRight(right));\n  }\n}\n", "file_hash": "f09cb96b0ed8752a69e39883a93046a8a3d235d3560e1bf5bab049d0171a2dbe", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import java.util.Optional;", "import org.openapitools.openapidiff.core.model.ChangedMetadata;", "import org.openapitools.openapidiff.core.model.DiffContext;"], "methods": [], "classes": [{"original_string": "public class MetadataDiff {\n  public MetadataDiff(OpenApiDiff openApiDiff) {}\n\n  public Optional<ChangedMetadata> diff(String left, String right, DiffContext context) {\n    return isChanged(new ChangedMetadata().setLeft(left).setRight(right));\n  }\n}", "definition": "public class MetadataDiff", "class_docstring": "", "name": "MetadataDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public MetadataDiff(OpenApiDiff openApiDiff) {}", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MetadataDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                               {}", "signature": "public MetadataDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public Optional<ChangedMetadata> diff(String left, String right, DiffContext context) {\n    return isChanged(new ChangedMetadata().setLeft(left).setRight(right));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<ChangedMetadata>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "String"}, {"name": "right", "type": "String"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                        {\n    return isChanged(new ChangedMetadata().setLeft(left).setRight(right));\n  }", "signature": "public Optional<ChangedMetadata> diff(String left, String right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/SecurityRequirementDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.security.SecurityRequirement;\nimport io.swagger.v3.oas.models.security.SecurityScheme;\nimport java.util.*;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedSecurityRequirement;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\n\npublic class SecurityRequirementDiff {\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public SecurityRequirementDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public static SecurityRequirement getCopy(LinkedHashMap<String, List<String>> right) {\n    SecurityRequirement newSecurityRequirement = new SecurityRequirement();\n    right.forEach((key, value) -> newSecurityRequirement.put(key, new ArrayList<>(value)));\n    return newSecurityRequirement;\n  }\n\n  private LinkedHashMap<String, List<String>> contains(\n      SecurityRequirement right, String schemeRef) {\n    SecurityScheme leftSecurityScheme = leftComponents.getSecuritySchemes().get(schemeRef);\n    LinkedHashMap<String, List<String>> found = new LinkedHashMap<>();\n\n    for (Map.Entry<String, List<String>> entry : right.entrySet()) {\n      SecurityScheme rightSecurityScheme = rightComponents.getSecuritySchemes().get(entry.getKey());\n      if (leftSecurityScheme.getType() == rightSecurityScheme.getType()) {\n        switch (leftSecurityScheme.getType()) {\n          case APIKEY:\n            if (leftSecurityScheme.getName().equals(rightSecurityScheme.getName())) {\n              found.put(entry.getKey(), entry.getValue());\n              return found;\n            }\n            break;\n\n          case OAUTH2:\n          case HTTP:\n          case OPENIDCONNECT:\n            found.put(entry.getKey(), entry.getValue());\n            return found;\n        }\n      }\n    }\n\n    return found;\n  }\n\n  public DeferredChanged<ChangedSecurityRequirement> diff(\n      SecurityRequirement left, SecurityRequirement right, DiffContext context) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedSecurityRequirement changedSecurityRequirement =\n        new ChangedSecurityRequirement(left, right != null ? getCopy(right) : null, context);\n\n    SecurityRequirement leftRequirement = left == null ? new SecurityRequirement() : left;\n    SecurityRequirement rightRequirement = right == null ? new SecurityRequirement() : right;\n\n    for (Map.Entry<String, List<String>> leftEntry : leftRequirement.entrySet()) {\n      LinkedHashMap<String, List<String>> rightSec = contains(rightRequirement, leftEntry.getKey());\n      if (rightSec.isEmpty()) {\n        changedSecurityRequirement.addMissing(leftEntry.getKey(), leftEntry.getValue());\n      } else {\n        Optional<String> rightSchemeRef = rightSec.keySet().stream().findFirst();\n        rightSchemeRef.ifPresent(rightRequirement::remove);\n        rightSchemeRef.ifPresent(\n            rightScheme ->\n                builder\n                    .with(\n                        openApiDiff\n                            .getSecuritySchemeDiff()\n                            .diff(\n                                leftEntry.getKey(),\n                                leftEntry.getValue(),\n                                rightScheme,\n                                rightSec.get(rightScheme),\n                                context))\n                    .ifPresent(changedSecurityRequirement::addChanged));\n      }\n    }\n    rightRequirement.forEach(changedSecurityRequirement::addIncreased);\n\n    return builder.buildIsChanged(changedSecurityRequirement);\n  }\n}\n", "file_hash": "223ca9a2c344673e25cd82d7c2c44337bb5ebaa8051f93fcc7a22c4b1540b6a8", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.security.SecurityRequirement;", "import io.swagger.v3.oas.models.security.SecurityScheme;", "import java.util.*;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedSecurityRequirement;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;"], "methods": [], "classes": [{"original_string": "public class SecurityRequirementDiff {\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public SecurityRequirementDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public static SecurityRequirement getCopy(LinkedHashMap<String, List<String>> right) {\n    SecurityRequirement newSecurityRequirement = new SecurityRequirement();\n    right.forEach((key, value) -> newSecurityRequirement.put(key, new ArrayList<>(value)));\n    return newSecurityRequirement;\n  }\n\n  private LinkedHashMap<String, List<String>> contains(\n      SecurityRequirement right, String schemeRef) {\n    SecurityScheme leftSecurityScheme = leftComponents.getSecuritySchemes().get(schemeRef);\n    LinkedHashMap<String, List<String>> found = new LinkedHashMap<>();\n\n    for (Map.Entry<String, List<String>> entry : right.entrySet()) {\n      SecurityScheme rightSecurityScheme = rightComponents.getSecuritySchemes().get(entry.getKey());\n      if (leftSecurityScheme.getType() == rightSecurityScheme.getType()) {\n        switch (leftSecurityScheme.getType()) {\n          case APIKEY:\n            if (leftSecurityScheme.getName().equals(rightSecurityScheme.getName())) {\n              found.put(entry.getKey(), entry.getValue());\n              return found;\n            }\n            break;\n\n          case OAUTH2:\n          case HTTP:\n          case OPENIDCONNECT:\n            found.put(entry.getKey(), entry.getValue());\n            return found;\n        }\n      }\n    }\n\n    return found;\n  }\n\n  public DeferredChanged<ChangedSecurityRequirement> diff(\n      SecurityRequirement left, SecurityRequirement right, DiffContext context) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedSecurityRequirement changedSecurityRequirement =\n        new ChangedSecurityRequirement(left, right != null ? getCopy(right) : null, context);\n\n    SecurityRequirement leftRequirement = left == null ? new SecurityRequirement() : left;\n    SecurityRequirement rightRequirement = right == null ? new SecurityRequirement() : right;\n\n    for (Map.Entry<String, List<String>> leftEntry : leftRequirement.entrySet()) {\n      LinkedHashMap<String, List<String>> rightSec = contains(rightRequirement, leftEntry.getKey());\n      if (rightSec.isEmpty()) {\n        changedSecurityRequirement.addMissing(leftEntry.getKey(), leftEntry.getValue());\n      } else {\n        Optional<String> rightSchemeRef = rightSec.keySet().stream().findFirst();\n        rightSchemeRef.ifPresent(rightRequirement::remove);\n        rightSchemeRef.ifPresent(\n            rightScheme ->\n                builder\n                    .with(\n                        openApiDiff\n                            .getSecuritySchemeDiff()\n                            .diff(\n                                leftEntry.getKey(),\n                                leftEntry.getValue(),\n                                rightScheme,\n                                rightSec.get(rightScheme),\n                                context))\n                    .ifPresent(changedSecurityRequirement::addChanged));\n      }\n    }\n    rightRequirement.forEach(changedSecurityRequirement::addIncreased);\n\n    return builder.buildIsChanged(changedSecurityRequirement);\n  }\n}", "definition": "public class SecurityRequirementDiff", "class_docstring": "", "name": "SecurityRequirementDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}, {"attribute_expression": "private final Components leftComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "leftComponents", "syntax_pass": true}, {"attribute_expression": "private final Components rightComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "rightComponents", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public SecurityRequirementDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SecurityRequirementDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                          {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "signature": "public SecurityRequirementDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public static SecurityRequirement getCopy(LinkedHashMap<String, List<String>> right) {\n    SecurityRequirement newSecurityRequirement = new SecurityRequirement();\n    right.forEach((key, value) -> newSecurityRequirement.put(key, new ArrayList<>(value)));\n    return newSecurityRequirement;\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SecurityRequirement", "classes": []}, "name": "getCopy", "params": [{"name": "right", "type": "LinkedHashMap<String, List<String>>"}], "body": "                                                                                       {\n    SecurityRequirement newSecurityRequirement = new SecurityRequirement();\n    right.forEach((key, value) -> newSecurityRequirement.put(key, new ArrayList<>(value)));\n    return newSecurityRequirement;\n  }", "signature": "public static SecurityRequirement getCopy(LinkedHashMap<String, List<String>> right)"}, {"syntax_pass": true, "original_string": "  private LinkedHashMap<String, List<String>> contains(\n      SecurityRequirement right, String schemeRef) {\n    SecurityScheme leftSecurityScheme = leftComponents.getSecuritySchemes().get(schemeRef);\n    LinkedHashMap<String, List<String>> found = new LinkedHashMap<>();\n\n    for (Map.Entry<String, List<String>> entry : right.entrySet()) {\n      SecurityScheme rightSecurityScheme = rightComponents.getSecuritySchemes().get(entry.getKey());\n      if (leftSecurityScheme.getType() == rightSecurityScheme.getType()) {\n        switch (leftSecurityScheme.getType()) {\n          case APIKEY:\n            if (leftSecurityScheme.getName().equals(rightSecurityScheme.getName())) {\n              found.put(entry.getKey(), entry.getValue());\n              return found;\n            }\n            break;\n\n          case OAUTH2:\n          case HTTP:\n          case OPENIDCONNECT:\n            found.put(entry.getKey(), entry.getValue());\n            return found;\n        }\n      }\n    }\n\n    return found;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LinkedHashMap<String, List<String>>", "classes": []}, "name": "contains", "params": [{"name": "right", "type": "SecurityRequirement"}, {"name": "schemeRef", "type": "String"}], "body": "                                                   {\n    SecurityScheme leftSecurityScheme = leftComponents.getSecuritySchemes().get(schemeRef);\n    LinkedHashMap<String, List<String>> found = new LinkedHashMap<>();\n\n    for (Map.Entry<String, List<String>> entry : right.entrySet()) {\n      SecurityScheme rightSecurityScheme = rightComponents.getSecuritySchemes().get(entry.getKey());\n      if (leftSecurityScheme.getType() == rightSecurityScheme.getType()) {\n        switch (leftSecurityScheme.getType()) {\n          case APIKEY:\n            if (leftSecurityScheme.getName().equals(rightSecurityScheme.getName())) {\n              found.put(entry.getKey(), entry.getValue());\n              return found;\n            }\n            break;\n\n          case OAUTH2:\n          case HTTP:\n          case OPENIDCONNECT:\n            found.put(entry.getKey(), entry.getValue());\n            return found;\n        }\n      }\n    }\n\n    return found;\n  }", "signature": "private LinkedHashMap<String, List<String>> contains(\n      SecurityRequirement right, String schemeRef)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedSecurityRequirement> diff(\n      SecurityRequirement left, SecurityRequirement right, DiffContext context) {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedSecurityRequirement changedSecurityRequirement =\n        new ChangedSecurityRequirement(left, right != null ? getCopy(right) : null, context);\n\n    SecurityRequirement leftRequirement = left == null ? new SecurityRequirement() : left;\n    SecurityRequirement rightRequirement = right == null ? new SecurityRequirement() : right;\n\n    for (Map.Entry<String, List<String>> leftEntry : leftRequirement.entrySet()) {\n      LinkedHashMap<String, List<String>> rightSec = contains(rightRequirement, leftEntry.getKey());\n      if (rightSec.isEmpty()) {\n        changedSecurityRequirement.addMissing(leftEntry.getKey(), leftEntry.getValue());\n      } else {\n        Optional<String> rightSchemeRef = rightSec.keySet().stream().findFirst();\n        rightSchemeRef.ifPresent(rightRequirement::remove);\n        rightSchemeRef.ifPresent(\n            rightScheme ->\n                builder\n                    .with(\n                        openApiDiff\n                            .getSecuritySchemeDiff()\n                            .diff(\n                                leftEntry.getKey(),\n                                leftEntry.getValue(),\n                                rightScheme,\n                                rightSec.get(rightScheme),\n                                context))\n                    .ifPresent(changedSecurityRequirement::addChanged));\n      }\n    }\n    rightRequirement.forEach(changedSecurityRequirement::addIncreased);\n\n    return builder.buildIsChanged(changedSecurityRequirement);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSecurityRequirement>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "SecurityRequirement"}, {"name": "right", "type": "SecurityRequirement"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                {\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedSecurityRequirement changedSecurityRequirement =\n        new ChangedSecurityRequirement(left, right != null ? getCopy(right) : null, context);\n\n    SecurityRequirement leftRequirement = left == null ? new SecurityRequirement() : left;\n    SecurityRequirement rightRequirement = right == null ? new SecurityRequirement() : right;\n\n    for (Map.Entry<String, List<String>> leftEntry : leftRequirement.entrySet()) {\n      LinkedHashMap<String, List<String>> rightSec = contains(rightRequirement, leftEntry.getKey());\n      if (rightSec.isEmpty()) {\n        changedSecurityRequirement.addMissing(leftEntry.getKey(), leftEntry.getValue());\n      } else {\n        Optional<String> rightSchemeRef = rightSec.keySet().stream().findFirst();\n        rightSchemeRef.ifPresent(rightRequirement::remove);\n        rightSchemeRef.ifPresent(\n            rightScheme ->\n                builder\n                    .with(\n                        openApiDiff\n                            .getSecuritySchemeDiff()\n                            .diff(\n                                leftEntry.getKey(),\n                                leftEntry.getValue(),\n                                rightScheme,\n                                rightSec.get(rightScheme),\n                                context))\n                    .ifPresent(changedSecurityRequirement::addChanged));\n      }\n    }\n    rightRequirement.forEach(changedSecurityRequirement::addIncreased);\n\n    return builder.buildIsChanged(changedSecurityRequirement);\n  }", "signature": "public DeferredChanged<ChangedSecurityRequirement> diff(\n      SecurityRequirement left, SecurityRequirement right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/PathDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport io.swagger.v3.oas.models.Operation;\nimport io.swagger.v3.oas.models.PathItem;\nimport java.util.List;\nimport java.util.Map;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedPath;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\n\npublic class PathDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public PathDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedPath> diff(PathItem left, PathItem right, DiffContext context) {\n    Map<PathItem.HttpMethod, Operation> oldOperationMap = left.readOperationsMap();\n    Map<PathItem.HttpMethod, Operation> newOperationMap = right.readOperationsMap();\n    MapKeyDiff<PathItem.HttpMethod, Operation> operationsDiff =\n        MapKeyDiff.diff(oldOperationMap, newOperationMap);\n    List<PathItem.HttpMethod> sharedMethods = operationsDiff.getSharedKey();\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedPath changedPath =\n        new ChangedPath(context.getUrl(), left, right, context)\n            .setIncreased(operationsDiff.getIncreased())\n            .setMissing(operationsDiff.getMissing());\n    for (PathItem.HttpMethod method : sharedMethods) {\n      Operation oldOperation = oldOperationMap.get(method);\n      Operation newOperation = newOperationMap.get(method);\n      builder\n          .with(\n              openApiDiff\n                  .getOperationDiff()\n                  .diff(\n                      oldOperation,\n                      newOperation,\n                      context\n                          .copyWithMethod(method)\n                          .copyWithLeftRightUrls(context.getLeftUrl(), context.getRightUrl())))\n          .ifPresent(changedPath.getChanged()::add);\n    }\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedPath::setExtensions);\n\n    return builder.buildIsChanged(changedPath);\n  }\n}\n", "file_hash": "9f466f45e1dca53d86f1f60390a6c5fd90081e4c7c9a986f069ff4c34600205e", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import io.swagger.v3.oas.models.Operation;", "import io.swagger.v3.oas.models.PathItem;", "import java.util.List;", "import java.util.Map;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedPath;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;"], "methods": [], "classes": [{"original_string": "public class PathDiff {\n  private final OpenApiDiff openApiDiff;\n\n  public PathDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }\n\n  public DeferredChanged<ChangedPath> diff(PathItem left, PathItem right, DiffContext context) {\n    Map<PathItem.HttpMethod, Operation> oldOperationMap = left.readOperationsMap();\n    Map<PathItem.HttpMethod, Operation> newOperationMap = right.readOperationsMap();\n    MapKeyDiff<PathItem.HttpMethod, Operation> operationsDiff =\n        MapKeyDiff.diff(oldOperationMap, newOperationMap);\n    List<PathItem.HttpMethod> sharedMethods = operationsDiff.getSharedKey();\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedPath changedPath =\n        new ChangedPath(context.getUrl(), left, right, context)\n            .setIncreased(operationsDiff.getIncreased())\n            .setMissing(operationsDiff.getMissing());\n    for (PathItem.HttpMethod method : sharedMethods) {\n      Operation oldOperation = oldOperationMap.get(method);\n      Operation newOperation = newOperationMap.get(method);\n      builder\n          .with(\n              openApiDiff\n                  .getOperationDiff()\n                  .diff(\n                      oldOperation,\n                      newOperation,\n                      context\n                          .copyWithMethod(method)\n                          .copyWithLeftRightUrls(context.getLeftUrl(), context.getRightUrl())))\n          .ifPresent(changedPath.getChanged()::add);\n    }\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedPath::setExtensions);\n\n    return builder.buildIsChanged(changedPath);\n  }\n}", "definition": "public class PathDiff", "class_docstring": "", "name": "PathDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public PathDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "PathDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                           {\n    this.openApiDiff = openApiDiff;\n  }", "signature": "public PathDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedPath> diff(PathItem left, PathItem right, DiffContext context) {\n    Map<PathItem.HttpMethod, Operation> oldOperationMap = left.readOperationsMap();\n    Map<PathItem.HttpMethod, Operation> newOperationMap = right.readOperationsMap();\n    MapKeyDiff<PathItem.HttpMethod, Operation> operationsDiff =\n        MapKeyDiff.diff(oldOperationMap, newOperationMap);\n    List<PathItem.HttpMethod> sharedMethods = operationsDiff.getSharedKey();\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedPath changedPath =\n        new ChangedPath(context.getUrl(), left, right, context)\n            .setIncreased(operationsDiff.getIncreased())\n            .setMissing(operationsDiff.getMissing());\n    for (PathItem.HttpMethod method : sharedMethods) {\n      Operation oldOperation = oldOperationMap.get(method);\n      Operation newOperation = newOperationMap.get(method);\n      builder\n          .with(\n              openApiDiff\n                  .getOperationDiff()\n                  .diff(\n                      oldOperation,\n                      newOperation,\n                      context\n                          .copyWithMethod(method)\n                          .copyWithLeftRightUrls(context.getLeftUrl(), context.getRightUrl())))\n          .ifPresent(changedPath.getChanged()::add);\n    }\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedPath::setExtensions);\n\n    return builder.buildIsChanged(changedPath);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedPath>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "PathItem"}, {"name": "right", "type": "PathItem"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                               {\n    Map<PathItem.HttpMethod, Operation> oldOperationMap = left.readOperationsMap();\n    Map<PathItem.HttpMethod, Operation> newOperationMap = right.readOperationsMap();\n    MapKeyDiff<PathItem.HttpMethod, Operation> operationsDiff =\n        MapKeyDiff.diff(oldOperationMap, newOperationMap);\n    List<PathItem.HttpMethod> sharedMethods = operationsDiff.getSharedKey();\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedPath changedPath =\n        new ChangedPath(context.getUrl(), left, right, context)\n            .setIncreased(operationsDiff.getIncreased())\n            .setMissing(operationsDiff.getMissing());\n    for (PathItem.HttpMethod method : sharedMethods) {\n      Operation oldOperation = oldOperationMap.get(method);\n      Operation newOperation = newOperationMap.get(method);\n      builder\n          .with(\n              openApiDiff\n                  .getOperationDiff()\n                  .diff(\n                      oldOperation,\n                      newOperation,\n                      context\n                          .copyWithMethod(method)\n                          .copyWithLeftRightUrls(context.getLeftUrl(), context.getRightUrl())))\n          .ifPresent(changedPath.getChanged()::add);\n    }\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedPath::setExtensions);\n\n    return builder.buildIsChanged(changedPath);\n  }", "signature": "public DeferredChanged<ChangedPath> diff(PathItem left, PathItem right, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/SecuritySchemeDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.security.SecurityScheme;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport org.openapitools.openapidiff.core.model.ChangedSecurityScheme;\nimport org.openapitools.openapidiff.core.model.ChangedSecuritySchemeScopes;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.model.deferred.RealizedChanged;\n\npublic class SecuritySchemeDiff extends ReferenceDiffCache<SecurityScheme, ChangedSecurityScheme> {\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public SecuritySchemeDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public DeferredChanged<ChangedSecurityScheme> diff(\n      String leftSchemeRef,\n      List<String> leftScopes,\n      String rightSchemeRef,\n      List<String> rightScopes,\n      DiffContext context) {\n    SecurityScheme leftSecurityScheme = leftComponents.getSecuritySchemes().get(leftSchemeRef);\n    SecurityScheme rightSecurityScheme = rightComponents.getSecuritySchemes().get(rightSchemeRef);\n    DeferredChanged<ChangedSecurityScheme> changedSecuritySchemeOpt =\n        cachedDiff(\n            new HashSet<>(),\n            leftSecurityScheme,\n            rightSecurityScheme,\n            leftSchemeRef,\n            rightSchemeRef,\n            context);\n\n    return changedSecuritySchemeOpt.map(\n        changedSecuritySchemeOptional -> {\n          ChangedSecurityScheme changedSecurityScheme =\n              changedSecuritySchemeOptional.orElse(\n                  new ChangedSecurityScheme(leftSecurityScheme, rightSecurityScheme, context));\n          changedSecurityScheme = getCopyWithoutScopes(changedSecurityScheme, context);\n\n          if (changedSecurityScheme != null\n              && leftSecurityScheme.getType() == SecurityScheme.Type.OAUTH2) {\n            isChanged(ListDiff.diff(new ChangedSecuritySchemeScopes(leftScopes, rightScopes)))\n                .ifPresent(changedSecurityScheme::setChangedScopes);\n          }\n\n          return changedSecurityScheme;\n        });\n  }\n\n  @Override\n  protected DeferredChanged<ChangedSecurityScheme> computeDiff(\n      HashSet<String> refSet,\n      SecurityScheme leftSecurityScheme,\n      SecurityScheme rightSecurityScheme,\n      DiffContext context) {\n    ChangedSecurityScheme changedSecurityScheme =\n        new ChangedSecurityScheme(leftSecurityScheme, rightSecurityScheme, context);\n\n    openApiDiff\n        .getMetadataDiff()\n        .diff(leftSecurityScheme.getDescription(), rightSecurityScheme.getDescription(), context)\n        .ifPresent(changedSecurityScheme::setDescription);\n\n    switch (leftSecurityScheme.getType()) {\n      case APIKEY:\n        changedSecurityScheme.setChangedIn(\n            !Objects.equals(leftSecurityScheme.getIn(), rightSecurityScheme.getIn()));\n        break;\n\n      case OAUTH2:\n        openApiDiff\n            .getOAuthFlowsDiff()\n            .diff(leftSecurityScheme.getFlows(), rightSecurityScheme.getFlows(), context)\n            .ifPresent(changedSecurityScheme::setOAuthFlows);\n        break;\n\n      case HTTP:\n        changedSecurityScheme.setChangedScheme(\n            !Objects.equals(leftSecurityScheme.getScheme(), rightSecurityScheme.getScheme()));\n        changedSecurityScheme.setChangedBearerFormat(\n            !Objects.equals(\n                leftSecurityScheme.getBearerFormat(), rightSecurityScheme.getBearerFormat()));\n        break;\n\n      case OPENIDCONNECT:\n        changedSecurityScheme.setChangedOpenIdConnectUrl(\n            !Objects.equals(\n                leftSecurityScheme.getOpenIdConnectUrl(),\n                rightSecurityScheme.getOpenIdConnectUrl()));\n        break;\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(leftSecurityScheme.getExtensions(), rightSecurityScheme.getExtensions(), context)\n        .ifPresent(changedSecurityScheme::setExtensions);\n\n    return new RealizedChanged<>(changedSecurityScheme);\n  }\n\n  private ChangedSecurityScheme getCopyWithoutScopes(\n      ChangedSecurityScheme original, DiffContext context) {\n    return new ChangedSecurityScheme(\n            original.getOldSecurityScheme(), original.getNewSecurityScheme(), context)\n        .setChangedType(original.isChangedType())\n        .setChangedIn(original.isChangedIn())\n        .setChangedScheme(original.isChangedScheme())\n        .setChangedBearerFormat(original.isChangedBearerFormat())\n        .setDescription(original.getDescription())\n        .setOAuthFlows(original.getOAuthFlows())\n        .setChangedOpenIdConnectUrl(original.isChangedOpenIdConnectUrl());\n  }\n}\n", "file_hash": "1ff33cee5b8ae7c687289dd43120491dfd38112696fe708f93a1a6a854286e72", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.security.SecurityScheme;", "import java.util.HashSet;", "import java.util.List;", "import java.util.Objects;", "import org.openapitools.openapidiff.core.model.ChangedSecurityScheme;", "import org.openapitools.openapidiff.core.model.ChangedSecuritySchemeScopes;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.model.deferred.RealizedChanged;"], "methods": [], "classes": [{"original_string": "public class SecuritySchemeDiff extends ReferenceDiffCache<SecurityScheme, ChangedSecurityScheme> {\n  private final OpenApiDiff openApiDiff;\n  private final Components leftComponents;\n  private final Components rightComponents;\n\n  public SecuritySchemeDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }\n\n  public DeferredChanged<ChangedSecurityScheme> diff(\n      String leftSchemeRef,\n      List<String> leftScopes,\n      String rightSchemeRef,\n      List<String> rightScopes,\n      DiffContext context) {\n    SecurityScheme leftSecurityScheme = leftComponents.getSecuritySchemes().get(leftSchemeRef);\n    SecurityScheme rightSecurityScheme = rightComponents.getSecuritySchemes().get(rightSchemeRef);\n    DeferredChanged<ChangedSecurityScheme> changedSecuritySchemeOpt =\n        cachedDiff(\n            new HashSet<>(),\n            leftSecurityScheme,\n            rightSecurityScheme,\n            leftSchemeRef,\n            rightSchemeRef,\n            context);\n\n    return changedSecuritySchemeOpt.map(\n        changedSecuritySchemeOptional -> {\n          ChangedSecurityScheme changedSecurityScheme =\n              changedSecuritySchemeOptional.orElse(\n                  new ChangedSecurityScheme(leftSecurityScheme, rightSecurityScheme, context));\n          changedSecurityScheme = getCopyWithoutScopes(changedSecurityScheme, context);\n\n          if (changedSecurityScheme != null\n              && leftSecurityScheme.getType() == SecurityScheme.Type.OAUTH2) {\n            isChanged(ListDiff.diff(new ChangedSecuritySchemeScopes(leftScopes, rightScopes)))\n                .ifPresent(changedSecurityScheme::setChangedScopes);\n          }\n\n          return changedSecurityScheme;\n        });\n  }\n\n  @Override\n  protected DeferredChanged<ChangedSecurityScheme> computeDiff(\n      HashSet<String> refSet,\n      SecurityScheme leftSecurityScheme,\n      SecurityScheme rightSecurityScheme,\n      DiffContext context) {\n    ChangedSecurityScheme changedSecurityScheme =\n        new ChangedSecurityScheme(leftSecurityScheme, rightSecurityScheme, context);\n\n    openApiDiff\n        .getMetadataDiff()\n        .diff(leftSecurityScheme.getDescription(), rightSecurityScheme.getDescription(), context)\n        .ifPresent(changedSecurityScheme::setDescription);\n\n    switch (leftSecurityScheme.getType()) {\n      case APIKEY:\n        changedSecurityScheme.setChangedIn(\n            !Objects.equals(leftSecurityScheme.getIn(), rightSecurityScheme.getIn()));\n        break;\n\n      case OAUTH2:\n        openApiDiff\n            .getOAuthFlowsDiff()\n            .diff(leftSecurityScheme.getFlows(), rightSecurityScheme.getFlows(), context)\n            .ifPresent(changedSecurityScheme::setOAuthFlows);\n        break;\n\n      case HTTP:\n        changedSecurityScheme.setChangedScheme(\n            !Objects.equals(leftSecurityScheme.getScheme(), rightSecurityScheme.getScheme()));\n        changedSecurityScheme.setChangedBearerFormat(\n            !Objects.equals(\n                leftSecurityScheme.getBearerFormat(), rightSecurityScheme.getBearerFormat()));\n        break;\n\n      case OPENIDCONNECT:\n        changedSecurityScheme.setChangedOpenIdConnectUrl(\n            !Objects.equals(\n                leftSecurityScheme.getOpenIdConnectUrl(),\n                rightSecurityScheme.getOpenIdConnectUrl()));\n        break;\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(leftSecurityScheme.getExtensions(), rightSecurityScheme.getExtensions(), context)\n        .ifPresent(changedSecurityScheme::setExtensions);\n\n    return new RealizedChanged<>(changedSecurityScheme);\n  }\n\n  private ChangedSecurityScheme getCopyWithoutScopes(\n      ChangedSecurityScheme original, DiffContext context) {\n    return new ChangedSecurityScheme(\n            original.getOldSecurityScheme(), original.getNewSecurityScheme(), context)\n        .setChangedType(original.isChangedType())\n        .setChangedIn(original.isChangedIn())\n        .setChangedScheme(original.isChangedScheme())\n        .setChangedBearerFormat(original.isChangedBearerFormat())\n        .setDescription(original.getDescription())\n        .setOAuthFlows(original.getOAuthFlows())\n        .setChangedOpenIdConnectUrl(original.isChangedOpenIdConnectUrl());\n  }\n}", "definition": "public class SecuritySchemeDiff extends ReferenceDiffCache<SecurityScheme, ChangedSecurityScheme>", "class_docstring": "", "name": "SecuritySchemeDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}, {"attribute_expression": "private final Components leftComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "leftComponents", "syntax_pass": true}, {"attribute_expression": "private final Components rightComponents;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Components", "name": "rightComponents", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public SecuritySchemeDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SecuritySchemeDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                     {\n    this.openApiDiff = openApiDiff;\n    this.leftComponents =\n        openApiDiff.getOldSpecOpenApi() != null\n            ? openApiDiff.getOldSpecOpenApi().getComponents()\n            : null;\n    this.rightComponents =\n        openApiDiff.getNewSpecOpenApi() != null\n            ? openApiDiff.getNewSpecOpenApi().getComponents()\n            : null;\n  }", "signature": "public SecuritySchemeDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public DeferredChanged<ChangedSecurityScheme> diff(\n      String leftSchemeRef,\n      List<String> leftScopes,\n      String rightSchemeRef,\n      List<String> rightScopes,\n      DiffContext context) {\n    SecurityScheme leftSecurityScheme = leftComponents.getSecuritySchemes().get(leftSchemeRef);\n    SecurityScheme rightSecurityScheme = rightComponents.getSecuritySchemes().get(rightSchemeRef);\n    DeferredChanged<ChangedSecurityScheme> changedSecuritySchemeOpt =\n        cachedDiff(\n            new HashSet<>(),\n            leftSecurityScheme,\n            rightSecurityScheme,\n            leftSchemeRef,\n            rightSchemeRef,\n            context);\n\n    return changedSecuritySchemeOpt.map(\n        changedSecuritySchemeOptional -> {\n          ChangedSecurityScheme changedSecurityScheme =\n              changedSecuritySchemeOptional.orElse(\n                  new ChangedSecurityScheme(leftSecurityScheme, rightSecurityScheme, context));\n          changedSecurityScheme = getCopyWithoutScopes(changedSecurityScheme, context);\n\n          if (changedSecurityScheme != null\n              && leftSecurityScheme.getType() == SecurityScheme.Type.OAUTH2) {\n            isChanged(ListDiff.diff(new ChangedSecuritySchemeScopes(leftScopes, rightScopes)))\n                .ifPresent(changedSecurityScheme::setChangedScopes);\n          }\n\n          return changedSecurityScheme;\n        });\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSecurityScheme>", "classes": []}, "name": "diff", "params": [{"name": "leftSchemeRef", "type": "String"}, {"name": "leftScopes", "type": "List<String>"}, {"name": "rightSchemeRef", "type": "String"}, {"name": "rightScopes", "type": "List<String>"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n    SecurityScheme leftSecurityScheme = leftComponents.getSecuritySchemes().get(leftSchemeRef);\n    SecurityScheme rightSecurityScheme = rightComponents.getSecuritySchemes().get(rightSchemeRef);\n    DeferredChanged<ChangedSecurityScheme> changedSecuritySchemeOpt =\n        cachedDiff(\n            new HashSet<>(),\n            leftSecurityScheme,\n            rightSecurityScheme,\n            leftSchemeRef,\n            rightSchemeRef,\n            context);\n\n    return changedSecuritySchemeOpt.map(\n        changedSecuritySchemeOptional -> {\n          ChangedSecurityScheme changedSecurityScheme =\n              changedSecuritySchemeOptional.orElse(\n                  new ChangedSecurityScheme(leftSecurityScheme, rightSecurityScheme, context));\n          changedSecurityScheme = getCopyWithoutScopes(changedSecurityScheme, context);\n\n          if (changedSecurityScheme != null\n              && leftSecurityScheme.getType() == SecurityScheme.Type.OAUTH2) {\n            isChanged(ListDiff.diff(new ChangedSecuritySchemeScopes(leftScopes, rightScopes)))\n                .ifPresent(changedSecurityScheme::setChangedScopes);\n          }\n\n          return changedSecurityScheme;\n        });\n  }", "signature": "public DeferredChanged<ChangedSecurityScheme> diff(\n      String leftSchemeRef,\n      List<String> leftScopes,\n      String rightSchemeRef,\n      List<String> rightScopes,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  @Override\n  protected DeferredChanged<ChangedSecurityScheme> computeDiff(\n      HashSet<String> refSet,\n      SecurityScheme leftSecurityScheme,\n      SecurityScheme rightSecurityScheme,\n      DiffContext context) {\n    ChangedSecurityScheme changedSecurityScheme =\n        new ChangedSecurityScheme(leftSecurityScheme, rightSecurityScheme, context);\n\n    openApiDiff\n        .getMetadataDiff()\n        .diff(leftSecurityScheme.getDescription(), rightSecurityScheme.getDescription(), context)\n        .ifPresent(changedSecurityScheme::setDescription);\n\n    switch (leftSecurityScheme.getType()) {\n      case APIKEY:\n        changedSecurityScheme.setChangedIn(\n            !Objects.equals(leftSecurityScheme.getIn(), rightSecurityScheme.getIn()));\n        break;\n\n      case OAUTH2:\n        openApiDiff\n            .getOAuthFlowsDiff()\n            .diff(leftSecurityScheme.getFlows(), rightSecurityScheme.getFlows(), context)\n            .ifPresent(changedSecurityScheme::setOAuthFlows);\n        break;\n\n      case HTTP:\n        changedSecurityScheme.setChangedScheme(\n            !Objects.equals(leftSecurityScheme.getScheme(), rightSecurityScheme.getScheme()));\n        changedSecurityScheme.setChangedBearerFormat(\n            !Objects.equals(\n                leftSecurityScheme.getBearerFormat(), rightSecurityScheme.getBearerFormat()));\n        break;\n\n      case OPENIDCONNECT:\n        changedSecurityScheme.setChangedOpenIdConnectUrl(\n            !Objects.equals(\n                leftSecurityScheme.getOpenIdConnectUrl(),\n                rightSecurityScheme.getOpenIdConnectUrl()));\n        break;\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(leftSecurityScheme.getExtensions(), rightSecurityScheme.getExtensions(), context)\n        .ifPresent(changedSecurityScheme::setExtensions);\n\n    return new RealizedChanged<>(changedSecurityScheme);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "DeferredChanged<ChangedSecurityScheme>", "classes": []}, "name": "computeDiff", "params": [{"name": "refSet", "type": "HashSet<String>"}, {"name": "leftSecurityScheme", "type": "SecurityScheme"}, {"name": "rightSecurityScheme", "type": "SecurityScheme"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n    ChangedSecurityScheme changedSecurityScheme =\n        new ChangedSecurityScheme(leftSecurityScheme, rightSecurityScheme, context);\n\n    openApiDiff\n        .getMetadataDiff()\n        .diff(leftSecurityScheme.getDescription(), rightSecurityScheme.getDescription(), context)\n        .ifPresent(changedSecurityScheme::setDescription);\n\n    switch (leftSecurityScheme.getType()) {\n      case APIKEY:\n        changedSecurityScheme.setChangedIn(\n            !Objects.equals(leftSecurityScheme.getIn(), rightSecurityScheme.getIn()));\n        break;\n\n      case OAUTH2:\n        openApiDiff\n            .getOAuthFlowsDiff()\n            .diff(leftSecurityScheme.getFlows(), rightSecurityScheme.getFlows(), context)\n            .ifPresent(changedSecurityScheme::setOAuthFlows);\n        break;\n\n      case HTTP:\n        changedSecurityScheme.setChangedScheme(\n            !Objects.equals(leftSecurityScheme.getScheme(), rightSecurityScheme.getScheme()));\n        changedSecurityScheme.setChangedBearerFormat(\n            !Objects.equals(\n                leftSecurityScheme.getBearerFormat(), rightSecurityScheme.getBearerFormat()));\n        break;\n\n      case OPENIDCONNECT:\n        changedSecurityScheme.setChangedOpenIdConnectUrl(\n            !Objects.equals(\n                leftSecurityScheme.getOpenIdConnectUrl(),\n                rightSecurityScheme.getOpenIdConnectUrl()));\n        break;\n    }\n    openApiDiff\n        .getExtensionsDiff()\n        .diff(leftSecurityScheme.getExtensions(), rightSecurityScheme.getExtensions(), context)\n        .ifPresent(changedSecurityScheme::setExtensions);\n\n    return new RealizedChanged<>(changedSecurityScheme);\n  }", "signature": "@Override\n  protected DeferredChanged<ChangedSecurityScheme> computeDiff(\n      HashSet<String> refSet,\n      SecurityScheme leftSecurityScheme,\n      SecurityScheme rightSecurityScheme,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  private ChangedSecurityScheme getCopyWithoutScopes(\n      ChangedSecurityScheme original, DiffContext context) {\n    return new ChangedSecurityScheme(\n            original.getOldSecurityScheme(), original.getNewSecurityScheme(), context)\n        .setChangedType(original.isChangedType())\n        .setChangedIn(original.isChangedIn())\n        .setChangedScheme(original.isChangedScheme())\n        .setChangedBearerFormat(original.isChangedBearerFormat())\n        .setDescription(original.getDescription())\n        .setOAuthFlows(original.getOAuthFlows())\n        .setChangedOpenIdConnectUrl(original.isChangedOpenIdConnectUrl());\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ChangedSecurityScheme", "classes": []}, "name": "getCopyWithoutScopes", "params": [{"name": "original", "type": "ChangedSecurityScheme"}, {"name": "context", "type": "DiffContext"}], "body": "                                                           {\n    return new ChangedSecurityScheme(\n            original.getOldSecurityScheme(), original.getNewSecurityScheme(), context)\n        .setChangedType(original.isChangedType())\n        .setChangedIn(original.isChangedIn())\n        .setChangedScheme(original.isChangedScheme())\n        .setChangedBearerFormat(original.isChangedBearerFormat())\n        .setDescription(original.getDescription())\n        .setOAuthFlows(original.getOAuthFlows())\n        .setChangedOpenIdConnectUrl(original.isChangedOpenIdConnectUrl());\n  }", "signature": "private ChangedSecurityScheme getCopyWithoutScopes(\n      ChangedSecurityScheme original, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/OpenApiDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static org.openapitools.openapidiff.core.compare.PathsDiff.valOrEmpty;\n\nimport io.swagger.v3.oas.models.OpenAPI;\nimport io.swagger.v3.oas.models.PathItem;\nimport io.swagger.v3.oas.models.security.SecurityRequirement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport org.openapitools.openapidiff.core.model.ChangedExtensions;\nimport org.openapitools.openapidiff.core.model.ChangedOpenApi;\nimport org.openapitools.openapidiff.core.model.ChangedOperation;\nimport org.openapitools.openapidiff.core.model.ChangedPath;\nimport org.openapitools.openapidiff.core.model.ChangedPaths;\nimport org.openapitools.openapidiff.core.model.Endpoint;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredSchemaCache;\nimport org.openapitools.openapidiff.core.utils.EndpointUtils;\n\npublic class OpenApiDiff {\n  private PathsDiff pathsDiff;\n  private PathDiff pathDiff;\n  private SchemaDiff schemaDiff;\n  private ContentDiff contentDiff;\n  private ParametersDiff parametersDiff;\n  private ParameterDiff parameterDiff;\n  private RequestBodyDiff requestBodyDiff;\n  private ResponseDiff responseDiff;\n  private HeadersDiff headersDiff;\n  private HeaderDiff headerDiff;\n  private ApiResponseDiff apiResponseDiff;\n  private OperationDiff operationDiff;\n  private SecurityRequirementsDiff securityRequirementsDiff;\n  private SecurityRequirementDiff securityRequirementDiff;\n  private SecuritySchemeDiff securitySchemeDiff;\n  private OAuthFlowsDiff oAuthFlowsDiff;\n  private OAuthFlowDiff oAuthFlowDiff;\n  private ExtensionsDiff extensionsDiff;\n  private MetadataDiff metadataDiff;\n  private final OpenAPI oldSpecOpenApi;\n  private final OpenAPI newSpecOpenApi;\n  private final OpenApiDiffOptions options;\n  private List<Endpoint> newEndpoints;\n  private List<Endpoint> missingEndpoints;\n  private List<ChangedOperation> changedOperations;\n  private ChangedExtensions changedExtensions;\n  private DeferredSchemaCache deferredSchemaCache;\n\n  /*\n   * @param oldSpecOpenApi\n   * @param newSpecOpenApi\n   * @param diffOptions\n   */\n  private OpenApiDiff(OpenAPI oldSpecOpenApi, OpenAPI newSpecOpenApi, OpenApiDiffOptions options) {\n    this.oldSpecOpenApi = oldSpecOpenApi;\n    this.newSpecOpenApi = newSpecOpenApi;\n    this.options = options;\n    if (null == oldSpecOpenApi || null == newSpecOpenApi) {\n      throw new RuntimeException(\"one of the old or new object is null\");\n    }\n    if (null == options) {\n      throw new IllegalArgumentException(\"options parameter is null but is required\");\n    }\n    initializeFields();\n  }\n\n  public static ChangedOpenApi compare(\n      OpenAPI oldSpec, OpenAPI newSpec, OpenApiDiffOptions diffOptions) {\n    return new OpenApiDiff(oldSpec, newSpec, diffOptions).compare();\n  }\n\n  private void initializeFields() {\n    this.pathsDiff = new PathsDiff(this);\n    this.pathDiff = new PathDiff(this);\n    this.schemaDiff = new SchemaDiff(this);\n    this.contentDiff = new ContentDiff(this);\n    this.parametersDiff = new ParametersDiff(this);\n    this.parameterDiff = new ParameterDiff(this);\n    this.requestBodyDiff = new RequestBodyDiff(this);\n    this.responseDiff = new ResponseDiff(this);\n    this.headersDiff = new HeadersDiff(this);\n    this.headerDiff = new HeaderDiff(this);\n    this.apiResponseDiff = new ApiResponseDiff(this);\n    this.operationDiff = new OperationDiff(this);\n    this.securityRequirementsDiff = new SecurityRequirementsDiff(this);\n    this.securityRequirementDiff = new SecurityRequirementDiff(this);\n    this.securitySchemeDiff = new SecuritySchemeDiff(this);\n    this.oAuthFlowsDiff = new OAuthFlowsDiff(this);\n    this.oAuthFlowDiff = new OAuthFlowDiff(this);\n    this.extensionsDiff = new ExtensionsDiff(this);\n    this.metadataDiff = new MetadataDiff(this);\n    this.deferredSchemaCache = new DeferredSchemaCache(this);\n  }\n\n  public OpenApiDiffOptions getOptions() {\n    return options;\n  }\n\n  private ChangedOpenApi compare() {\n    preProcess(oldSpecOpenApi);\n    preProcess(newSpecOpenApi);\n\n    // 1st pass scans paths to collect all schemas\n    DeferredChanged<ChangedPaths> paths =\n        this.pathsDiff.diff(\n            valOrEmpty(oldSpecOpenApi.getPaths()), valOrEmpty(newSpecOpenApi.getPaths()));\n\n    // 2nd pass processes deferred schemas\n    deferredSchemaCache.process();\n\n    this.newEndpoints = new ArrayList<>();\n    this.missingEndpoints = new ArrayList<>();\n    this.changedOperations = new ArrayList<>();\n\n    paths.ifPresent(\n        changedPaths -> {\n          this.newEndpoints = EndpointUtils.convert2EndpointList(changedPaths.getIncreased());\n          this.missingEndpoints = EndpointUtils.convert2EndpointList(changedPaths.getMissing());\n          changedPaths\n              .getChanged()\n              .keySet()\n              .forEach(\n                  path -> {\n                    ChangedPath changedPath = changedPaths.getChanged().get(path);\n                    this.newEndpoints.addAll(\n                        EndpointUtils.convert2Endpoints(path, changedPath.getIncreased()));\n                    this.missingEndpoints.addAll(\n                        EndpointUtils.convert2Endpoints(path, changedPath.getMissing()));\n                    changedOperations.addAll(changedPath.getChanged());\n                  });\n        });\n    getExtensionsDiff()\n        .diff(oldSpecOpenApi.getExtensions(), newSpecOpenApi.getExtensions())\n        .ifPresent(this::setChangedExtension);\n\n    return getChangedOpenApi();\n  }\n\n  private void setChangedExtension(ChangedExtensions changedExtension) {\n    this.changedExtensions = changedExtension;\n  }\n\n  private void preProcess(OpenAPI openApi) {\n    List<SecurityRequirement> securityRequirements = openApi.getSecurity();\n    if (securityRequirements != null) {\n      List<SecurityRequirement> distinctSecurityRequirements =\n          securityRequirements.stream().distinct().collect(Collectors.toList());\n      Map<String, PathItem> paths = openApi.getPaths();\n      if (paths != null) {\n        paths\n            .values()\n            .forEach(\n                pathItem ->\n                    pathItem.readOperationsMap().values().stream()\n                        .filter(operation -> operation.getSecurity() != null)\n                        .forEach(\n                            operation ->\n                                operation.setSecurity(\n                                    operation.getSecurity().stream()\n                                        .distinct()\n                                        .collect(Collectors.toList()))));\n        paths\n            .values()\n            .forEach(\n                pathItem ->\n                    pathItem.readOperationsMap().values().stream()\n                        .filter(operation -> operation.getSecurity() == null)\n                        .forEach(operation -> operation.setSecurity(distinctSecurityRequirements)));\n      }\n      openApi.setSecurity(null);\n    }\n  }\n\n  private ChangedOpenApi getChangedOpenApi() {\n    return new ChangedOpenApi(options)\n        .setMissingEndpoints(missingEndpoints)\n        .setNewEndpoints(newEndpoints)\n        .setNewSpecOpenApi(newSpecOpenApi)\n        .setOldSpecOpenApi(oldSpecOpenApi)\n        .setChangedOperations(changedOperations)\n        .setChangedExtensions(changedExtensions)\n        .setChangedSchemas(deferredSchemaCache.getChangedSchemas());\n  }\n\n  public DeferredSchemaCache getDeferredSchemaCache() {\n    return deferredSchemaCache;\n  }\n\n  public PathsDiff getPathsDiff() {\n    return this.pathsDiff;\n  }\n\n  public PathDiff getPathDiff() {\n    return this.pathDiff;\n  }\n\n  public SchemaDiff getSchemaDiff() {\n    return this.schemaDiff;\n  }\n\n  public ContentDiff getContentDiff() {\n    return this.contentDiff;\n  }\n\n  public ParametersDiff getParametersDiff() {\n    return this.parametersDiff;\n  }\n\n  public ParameterDiff getParameterDiff() {\n    return this.parameterDiff;\n  }\n\n  public RequestBodyDiff getRequestBodyDiff() {\n    return this.requestBodyDiff;\n  }\n\n  public ResponseDiff getResponseDiff() {\n    return this.responseDiff;\n  }\n\n  public HeadersDiff getHeadersDiff() {\n    return this.headersDiff;\n  }\n\n  public HeaderDiff getHeaderDiff() {\n    return this.headerDiff;\n  }\n\n  public ApiResponseDiff getApiResponseDiff() {\n    return this.apiResponseDiff;\n  }\n\n  public OperationDiff getOperationDiff() {\n    return this.operationDiff;\n  }\n\n  public SecurityRequirementsDiff getSecurityRequirementsDiff() {\n    return this.securityRequirementsDiff;\n  }\n\n  public SecurityRequirementDiff getSecurityRequirementDiff() {\n    return this.securityRequirementDiff;\n  }\n\n  public SecuritySchemeDiff getSecuritySchemeDiff() {\n    return this.securitySchemeDiff;\n  }\n\n  public OAuthFlowsDiff getOAuthFlowsDiff() {\n    return this.oAuthFlowsDiff;\n  }\n\n  public OAuthFlowDiff getOAuthFlowDiff() {\n    return this.oAuthFlowDiff;\n  }\n\n  public ExtensionsDiff getExtensionsDiff() {\n    return this.extensionsDiff;\n  }\n\n  public MetadataDiff getMetadataDiff() {\n    return this.metadataDiff;\n  }\n\n  public OpenAPI getOldSpecOpenApi() {\n    return this.oldSpecOpenApi;\n  }\n\n  public OpenAPI getNewSpecOpenApi() {\n    return this.newSpecOpenApi;\n  }\n\n  public List<Endpoint> getNewEndpoints() {\n    return this.newEndpoints;\n  }\n\n  public List<Endpoint> getMissingEndpoints() {\n    return this.missingEndpoints;\n  }\n\n  public List<ChangedOperation> getChangedOperations() {\n    return this.changedOperations;\n  }\n\n  public ChangedExtensions getChangedExtensions() {\n    return this.changedExtensions;\n  }\n}\n", "file_hash": "86ae7c999a07c4e95acfaa70d4d6917e393dbae04f6ed74e8503a5870f4abf15", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static org.openapitools.openapidiff.core.compare.PathsDiff.valOrEmpty;", "import io.swagger.v3.oas.models.OpenAPI;", "import io.swagger.v3.oas.models.PathItem;", "import io.swagger.v3.oas.models.security.SecurityRequirement;", "import java.util.ArrayList;", "import java.util.List;", "import java.util.Map;", "import java.util.stream.Collectors;", "import org.openapitools.openapidiff.core.model.ChangedExtensions;", "import org.openapitools.openapidiff.core.model.ChangedOpenApi;", "import org.openapitools.openapidiff.core.model.ChangedOperation;", "import org.openapitools.openapidiff.core.model.ChangedPath;", "import org.openapitools.openapidiff.core.model.ChangedPaths;", "import org.openapitools.openapidiff.core.model.Endpoint;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.model.deferred.DeferredSchemaCache;", "import org.openapitools.openapidiff.core.utils.EndpointUtils;"], "methods": [], "classes": [{"original_string": "public class OpenApiDiff {\n  private PathsDiff pathsDiff;\n  private PathDiff pathDiff;\n  private SchemaDiff schemaDiff;\n  private ContentDiff contentDiff;\n  private ParametersDiff parametersDiff;\n  private ParameterDiff parameterDiff;\n  private RequestBodyDiff requestBodyDiff;\n  private ResponseDiff responseDiff;\n  private HeadersDiff headersDiff;\n  private HeaderDiff headerDiff;\n  private ApiResponseDiff apiResponseDiff;\n  private OperationDiff operationDiff;\n  private SecurityRequirementsDiff securityRequirementsDiff;\n  private SecurityRequirementDiff securityRequirementDiff;\n  private SecuritySchemeDiff securitySchemeDiff;\n  private OAuthFlowsDiff oAuthFlowsDiff;\n  private OAuthFlowDiff oAuthFlowDiff;\n  private ExtensionsDiff extensionsDiff;\n  private MetadataDiff metadataDiff;\n  private final OpenAPI oldSpecOpenApi;\n  private final OpenAPI newSpecOpenApi;\n  private final OpenApiDiffOptions options;\n  private List<Endpoint> newEndpoints;\n  private List<Endpoint> missingEndpoints;\n  private List<ChangedOperation> changedOperations;\n  private ChangedExtensions changedExtensions;\n  private DeferredSchemaCache deferredSchemaCache;\n\n  /*\n   * @param oldSpecOpenApi\n   * @param newSpecOpenApi\n   * @param diffOptions\n   */\n  private OpenApiDiff(OpenAPI oldSpecOpenApi, OpenAPI newSpecOpenApi, OpenApiDiffOptions options) {\n    this.oldSpecOpenApi = oldSpecOpenApi;\n    this.newSpecOpenApi = newSpecOpenApi;\n    this.options = options;\n    if (null == oldSpecOpenApi || null == newSpecOpenApi) {\n      throw new RuntimeException(\"one of the old or new object is null\");\n    }\n    if (null == options) {\n      throw new IllegalArgumentException(\"options parameter is null but is required\");\n    }\n    initializeFields();\n  }\n\n  public static ChangedOpenApi compare(\n      OpenAPI oldSpec, OpenAPI newSpec, OpenApiDiffOptions diffOptions) {\n    return new OpenApiDiff(oldSpec, newSpec, diffOptions).compare();\n  }\n\n  private void initializeFields() {\n    this.pathsDiff = new PathsDiff(this);\n    this.pathDiff = new PathDiff(this);\n    this.schemaDiff = new SchemaDiff(this);\n    this.contentDiff = new ContentDiff(this);\n    this.parametersDiff = new ParametersDiff(this);\n    this.parameterDiff = new ParameterDiff(this);\n    this.requestBodyDiff = new RequestBodyDiff(this);\n    this.responseDiff = new ResponseDiff(this);\n    this.headersDiff = new HeadersDiff(this);\n    this.headerDiff = new HeaderDiff(this);\n    this.apiResponseDiff = new ApiResponseDiff(this);\n    this.operationDiff = new OperationDiff(this);\n    this.securityRequirementsDiff = new SecurityRequirementsDiff(this);\n    this.securityRequirementDiff = new SecurityRequirementDiff(this);\n    this.securitySchemeDiff = new SecuritySchemeDiff(this);\n    this.oAuthFlowsDiff = new OAuthFlowsDiff(this);\n    this.oAuthFlowDiff = new OAuthFlowDiff(this);\n    this.extensionsDiff = new ExtensionsDiff(this);\n    this.metadataDiff = new MetadataDiff(this);\n    this.deferredSchemaCache = new DeferredSchemaCache(this);\n  }\n\n  public OpenApiDiffOptions getOptions() {\n    return options;\n  }\n\n  private ChangedOpenApi compare() {\n    preProcess(oldSpecOpenApi);\n    preProcess(newSpecOpenApi);\n\n    // 1st pass scans paths to collect all schemas\n    DeferredChanged<ChangedPaths> paths =\n        this.pathsDiff.diff(\n            valOrEmpty(oldSpecOpenApi.getPaths()), valOrEmpty(newSpecOpenApi.getPaths()));\n\n    // 2nd pass processes deferred schemas\n    deferredSchemaCache.process();\n\n    this.newEndpoints = new ArrayList<>();\n    this.missingEndpoints = new ArrayList<>();\n    this.changedOperations = new ArrayList<>();\n\n    paths.ifPresent(\n        changedPaths -> {\n          this.newEndpoints = EndpointUtils.convert2EndpointList(changedPaths.getIncreased());\n          this.missingEndpoints = EndpointUtils.convert2EndpointList(changedPaths.getMissing());\n          changedPaths\n              .getChanged()\n              .keySet()\n              .forEach(\n                  path -> {\n                    ChangedPath changedPath = changedPaths.getChanged().get(path);\n                    this.newEndpoints.addAll(\n                        EndpointUtils.convert2Endpoints(path, changedPath.getIncreased()));\n                    this.missingEndpoints.addAll(\n                        EndpointUtils.convert2Endpoints(path, changedPath.getMissing()));\n                    changedOperations.addAll(changedPath.getChanged());\n                  });\n        });\n    getExtensionsDiff()\n        .diff(oldSpecOpenApi.getExtensions(), newSpecOpenApi.getExtensions())\n        .ifPresent(this::setChangedExtension);\n\n    return getChangedOpenApi();\n  }\n\n  private void setChangedExtension(ChangedExtensions changedExtension) {\n    this.changedExtensions = changedExtension;\n  }\n\n  private void preProcess(OpenAPI openApi) {\n    List<SecurityRequirement> securityRequirements = openApi.getSecurity();\n    if (securityRequirements != null) {\n      List<SecurityRequirement> distinctSecurityRequirements =\n          securityRequirements.stream().distinct().collect(Collectors.toList());\n      Map<String, PathItem> paths = openApi.getPaths();\n      if (paths != null) {\n        paths\n            .values()\n            .forEach(\n                pathItem ->\n                    pathItem.readOperationsMap().values().stream()\n                        .filter(operation -> operation.getSecurity() != null)\n                        .forEach(\n                            operation ->\n                                operation.setSecurity(\n                                    operation.getSecurity().stream()\n                                        .distinct()\n                                        .collect(Collectors.toList()))));\n        paths\n            .values()\n            .forEach(\n                pathItem ->\n                    pathItem.readOperationsMap().values().stream()\n                        .filter(operation -> operation.getSecurity() == null)\n                        .forEach(operation -> operation.setSecurity(distinctSecurityRequirements)));\n      }\n      openApi.setSecurity(null);\n    }\n  }\n\n  private ChangedOpenApi getChangedOpenApi() {\n    return new ChangedOpenApi(options)\n        .setMissingEndpoints(missingEndpoints)\n        .setNewEndpoints(newEndpoints)\n        .setNewSpecOpenApi(newSpecOpenApi)\n        .setOldSpecOpenApi(oldSpecOpenApi)\n        .setChangedOperations(changedOperations)\n        .setChangedExtensions(changedExtensions)\n        .setChangedSchemas(deferredSchemaCache.getChangedSchemas());\n  }\n\n  public DeferredSchemaCache getDeferredSchemaCache() {\n    return deferredSchemaCache;\n  }\n\n  public PathsDiff getPathsDiff() {\n    return this.pathsDiff;\n  }\n\n  public PathDiff getPathDiff() {\n    return this.pathDiff;\n  }\n\n  public SchemaDiff getSchemaDiff() {\n    return this.schemaDiff;\n  }\n\n  public ContentDiff getContentDiff() {\n    return this.contentDiff;\n  }\n\n  public ParametersDiff getParametersDiff() {\n    return this.parametersDiff;\n  }\n\n  public ParameterDiff getParameterDiff() {\n    return this.parameterDiff;\n  }\n\n  public RequestBodyDiff getRequestBodyDiff() {\n    return this.requestBodyDiff;\n  }\n\n  public ResponseDiff getResponseDiff() {\n    return this.responseDiff;\n  }\n\n  public HeadersDiff getHeadersDiff() {\n    return this.headersDiff;\n  }\n\n  public HeaderDiff getHeaderDiff() {\n    return this.headerDiff;\n  }\n\n  public ApiResponseDiff getApiResponseDiff() {\n    return this.apiResponseDiff;\n  }\n\n  public OperationDiff getOperationDiff() {\n    return this.operationDiff;\n  }\n\n  public SecurityRequirementsDiff getSecurityRequirementsDiff() {\n    return this.securityRequirementsDiff;\n  }\n\n  public SecurityRequirementDiff getSecurityRequirementDiff() {\n    return this.securityRequirementDiff;\n  }\n\n  public SecuritySchemeDiff getSecuritySchemeDiff() {\n    return this.securitySchemeDiff;\n  }\n\n  public OAuthFlowsDiff getOAuthFlowsDiff() {\n    return this.oAuthFlowsDiff;\n  }\n\n  public OAuthFlowDiff getOAuthFlowDiff() {\n    return this.oAuthFlowDiff;\n  }\n\n  public ExtensionsDiff getExtensionsDiff() {\n    return this.extensionsDiff;\n  }\n\n  public MetadataDiff getMetadataDiff() {\n    return this.metadataDiff;\n  }\n\n  public OpenAPI getOldSpecOpenApi() {\n    return this.oldSpecOpenApi;\n  }\n\n  public OpenAPI getNewSpecOpenApi() {\n    return this.newSpecOpenApi;\n  }\n\n  public List<Endpoint> getNewEndpoints() {\n    return this.newEndpoints;\n  }\n\n  public List<Endpoint> getMissingEndpoints() {\n    return this.missingEndpoints;\n  }\n\n  public List<ChangedOperation> getChangedOperations() {\n    return this.changedOperations;\n  }\n\n  public ChangedExtensions getChangedExtensions() {\n    return this.changedExtensions;\n  }\n}", "definition": "public class OpenApiDiff", "class_docstring": "", "name": "OpenApiDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private PathsDiff pathsDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PathsDiff", "name": "pathsDiff", "syntax_pass": true}, {"attribute_expression": "private PathDiff pathDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PathDiff", "name": "pathDiff", "syntax_pass": true}, {"attribute_expression": "private SchemaDiff schemaDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SchemaDiff", "name": "schemaDiff", "syntax_pass": true}, {"attribute_expression": "private ContentDiff contentDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ContentDiff", "name": "contentDiff", "syntax_pass": true}, {"attribute_expression": "private ParametersDiff parametersDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParametersDiff", "name": "parametersDiff", "syntax_pass": true}, {"attribute_expression": "private ParameterDiff parameterDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterDiff", "name": "parameterDiff", "syntax_pass": true}, {"attribute_expression": "private RequestBodyDiff requestBodyDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RequestBodyDiff", "name": "requestBodyDiff", "syntax_pass": true}, {"attribute_expression": "private ResponseDiff responseDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResponseDiff", "name": "responseDiff", "syntax_pass": true}, {"attribute_expression": "private HeadersDiff headersDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HeadersDiff", "name": "headersDiff", "syntax_pass": true}, {"attribute_expression": "private HeaderDiff headerDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HeaderDiff", "name": "headerDiff", "syntax_pass": true}, {"attribute_expression": "private ApiResponseDiff apiResponseDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ApiResponseDiff", "name": "apiResponseDiff", "syntax_pass": true}, {"attribute_expression": "private OperationDiff operationDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OperationDiff", "name": "operationDiff", "syntax_pass": true}, {"attribute_expression": "private SecurityRequirementsDiff securityRequirementsDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecurityRequirementsDiff", "name": "securityRequirementsDiff", "syntax_pass": true}, {"attribute_expression": "private SecurityRequirementDiff securityRequirementDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecurityRequirementDiff", "name": "securityRequirementDiff", "syntax_pass": true}, {"attribute_expression": "private SecuritySchemeDiff securitySchemeDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SecuritySchemeDiff", "name": "securitySchemeDiff", "syntax_pass": true}, {"attribute_expression": "private OAuthFlowsDiff oAuthFlowsDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OAuthFlowsDiff", "name": "oAuthFlowsDiff", "syntax_pass": true}, {"attribute_expression": "private OAuthFlowDiff oAuthFlowDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OAuthFlowDiff", "name": "oAuthFlowDiff", "syntax_pass": true}, {"attribute_expression": "private ExtensionsDiff extensionsDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ExtensionsDiff", "name": "extensionsDiff", "syntax_pass": true}, {"attribute_expression": "private MetadataDiff metadataDiff;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MetadataDiff", "name": "metadataDiff", "syntax_pass": true}, {"attribute_expression": "private final OpenAPI oldSpecOpenApi;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenAPI", "name": "oldSpecOpenApi", "syntax_pass": true}, {"attribute_expression": "private final OpenAPI newSpecOpenApi;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenAPI", "name": "newSpecOpenApi", "syntax_pass": true}, {"attribute_expression": "private final OpenApiDiffOptions options;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiffOptions", "name": "options", "syntax_pass": true}, {"attribute_expression": "private List<Endpoint> newEndpoints;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Endpoint>", "name": "newEndpoints", "syntax_pass": true}, {"attribute_expression": "private List<Endpoint> missingEndpoints;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Endpoint>", "name": "missingEndpoints", "syntax_pass": true}, {"attribute_expression": "private List<ChangedOperation> changedOperations;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<ChangedOperation>", "name": "changedOperations", "syntax_pass": true}, {"attribute_expression": "private ChangedExtensions changedExtensions;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedExtensions", "name": "changedExtensions", "syntax_pass": true}, {"attribute_expression": "private DeferredSchemaCache deferredSchemaCache;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DeferredSchemaCache", "name": "deferredSchemaCache", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private OpenApiDiff(OpenAPI oldSpecOpenApi, OpenAPI newSpecOpenApi, OpenApiDiffOptions options) {\n    this.oldSpecOpenApi = oldSpecOpenApi;\n    this.newSpecOpenApi = newSpecOpenApi;\n    this.options = options;\n    if (null == oldSpecOpenApi || null == newSpecOpenApi) {\n      throw new RuntimeException(\"one of the old or new object is null\");\n    }\n    if (null == options) {\n      throw new IllegalArgumentException(\"options parameter is null but is required\");\n    }\n    initializeFields();\n  }", "docstring": "\n@param oldSpecOpenApi\n@param newSpecOpenApi\n@param diffOptions\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "OpenApiDiff", "params": [{"name": "oldSpecOpenApi", "type": "OpenAPI"}, {"name": "newSpecOpenApi", "type": "OpenAPI"}, {"name": "options", "type": "OpenApiDiffOptions"}], "body": "                                                                                                  {\n    this.oldSpecOpenApi = oldSpecOpenApi;\n    this.newSpecOpenApi = newSpecOpenApi;\n    this.options = options;\n    if (null == oldSpecOpenApi || null == newSpecOpenApi) {\n      throw new RuntimeException(\"one of the old or new object is null\");\n    }\n    if (null == options) {\n      throw new IllegalArgumentException(\"options parameter is null but is required\");\n    }\n    initializeFields();\n  }", "signature": "private OpenApiDiff(OpenAPI oldSpecOpenApi, OpenAPI newSpecOpenApi, OpenApiDiffOptions options)"}, {"syntax_pass": true, "original_string": "  public static ChangedOpenApi compare(\n      OpenAPI oldSpec, OpenAPI newSpec, OpenApiDiffOptions diffOptions) {\n    return new OpenApiDiff(oldSpec, newSpec, diffOptions).compare();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "compare", "params": [{"name": "oldSpec", "type": "OpenAPI"}, {"name": "newSpec", "type": "OpenAPI"}, {"name": "diffOptions", "type": "OpenApiDiffOptions"}], "body": "                                                                        {\n    return new OpenApiDiff(oldSpec, newSpec, diffOptions).compare();\n  }", "signature": "public static ChangedOpenApi compare(\n      OpenAPI oldSpec, OpenAPI newSpec, OpenApiDiffOptions diffOptions)"}, {"syntax_pass": true, "original_string": "  private void initializeFields() {\n    this.pathsDiff = new PathsDiff(this);\n    this.pathDiff = new PathDiff(this);\n    this.schemaDiff = new SchemaDiff(this);\n    this.contentDiff = new ContentDiff(this);\n    this.parametersDiff = new ParametersDiff(this);\n    this.parameterDiff = new ParameterDiff(this);\n    this.requestBodyDiff = new RequestBodyDiff(this);\n    this.responseDiff = new ResponseDiff(this);\n    this.headersDiff = new HeadersDiff(this);\n    this.headerDiff = new HeaderDiff(this);\n    this.apiResponseDiff = new ApiResponseDiff(this);\n    this.operationDiff = new OperationDiff(this);\n    this.securityRequirementsDiff = new SecurityRequirementsDiff(this);\n    this.securityRequirementDiff = new SecurityRequirementDiff(this);\n    this.securitySchemeDiff = new SecuritySchemeDiff(this);\n    this.oAuthFlowsDiff = new OAuthFlowsDiff(this);\n    this.oAuthFlowDiff = new OAuthFlowDiff(this);\n    this.extensionsDiff = new ExtensionsDiff(this);\n    this.metadataDiff = new MetadataDiff(this);\n    this.deferredSchemaCache = new DeferredSchemaCache(this);\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "initializeFields", "params": [], "body": "                                  {\n    this.pathsDiff = new PathsDiff(this);\n    this.pathDiff = new PathDiff(this);\n    this.schemaDiff = new SchemaDiff(this);\n    this.contentDiff = new ContentDiff(this);\n    this.parametersDiff = new ParametersDiff(this);\n    this.parameterDiff = new ParameterDiff(this);\n    this.requestBodyDiff = new RequestBodyDiff(this);\n    this.responseDiff = new ResponseDiff(this);\n    this.headersDiff = new HeadersDiff(this);\n    this.headerDiff = new HeaderDiff(this);\n    this.apiResponseDiff = new ApiResponseDiff(this);\n    this.operationDiff = new OperationDiff(this);\n    this.securityRequirementsDiff = new SecurityRequirementsDiff(this);\n    this.securityRequirementDiff = new SecurityRequirementDiff(this);\n    this.securitySchemeDiff = new SecuritySchemeDiff(this);\n    this.oAuthFlowsDiff = new OAuthFlowsDiff(this);\n    this.oAuthFlowDiff = new OAuthFlowDiff(this);\n    this.extensionsDiff = new ExtensionsDiff(this);\n    this.metadataDiff = new MetadataDiff(this);\n    this.deferredSchemaCache = new DeferredSchemaCache(this);\n  }", "signature": "private void initializeFields()"}, {"syntax_pass": true, "original_string": "  public OpenApiDiffOptions getOptions() {\n    return options;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OpenApiDiffOptions", "classes": []}, "name": "getOptions", "params": [], "body": "                                         {\n    return options;\n  }", "signature": "public OpenApiDiffOptions getOptions()"}, {"syntax_pass": true, "original_string": "  private ChangedOpenApi compare() {\n    preProcess(oldSpecOpenApi);\n    preProcess(newSpecOpenApi);\n\n    // 1st pass scans paths to collect all schemas\n    DeferredChanged<ChangedPaths> paths =\n        this.pathsDiff.diff(\n            valOrEmpty(oldSpecOpenApi.getPaths()), valOrEmpty(newSpecOpenApi.getPaths()));\n\n    // 2nd pass processes deferred schemas\n    deferredSchemaCache.process();\n\n    this.newEndpoints = new ArrayList<>();\n    this.missingEndpoints = new ArrayList<>();\n    this.changedOperations = new ArrayList<>();\n\n    paths.ifPresent(\n        changedPaths -> {\n          this.newEndpoints = EndpointUtils.convert2EndpointList(changedPaths.getIncreased());\n          this.missingEndpoints = EndpointUtils.convert2EndpointList(changedPaths.getMissing());\n          changedPaths\n              .getChanged()\n              .keySet()\n              .forEach(\n                  path -> {\n                    ChangedPath changedPath = changedPaths.getChanged().get(path);\n                    this.newEndpoints.addAll(\n                        EndpointUtils.convert2Endpoints(path, changedPath.getIncreased()));\n                    this.missingEndpoints.addAll(\n                        EndpointUtils.convert2Endpoints(path, changedPath.getMissing()));\n                    changedOperations.addAll(changedPath.getChanged());\n                  });\n        });\n    getExtensionsDiff()\n        .diff(oldSpecOpenApi.getExtensions(), newSpecOpenApi.getExtensions())\n        .ifPresent(this::setChangedExtension);\n\n    return getChangedOpenApi();\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "compare", "params": [], "body": "                                   {\n    preProcess(oldSpecOpenApi);\n    preProcess(newSpecOpenApi);\n\n    // 1st pass scans paths to collect all schemas\n    DeferredChanged<ChangedPaths> paths =\n        this.pathsDiff.diff(\n            valOrEmpty(oldSpecOpenApi.getPaths()), valOrEmpty(newSpecOpenApi.getPaths()));\n\n    // 2nd pass processes deferred schemas\n    deferredSchemaCache.process();\n\n    this.newEndpoints = new ArrayList<>();\n    this.missingEndpoints = new ArrayList<>();\n    this.changedOperations = new ArrayList<>();\n\n    paths.ifPresent(\n        changedPaths -> {\n          this.newEndpoints = EndpointUtils.convert2EndpointList(changedPaths.getIncreased());\n          this.missingEndpoints = EndpointUtils.convert2EndpointList(changedPaths.getMissing());\n          changedPaths\n              .getChanged()\n              .keySet()\n              .forEach(\n                  path -> {\n                    ChangedPath changedPath = changedPaths.getChanged().get(path);\n                    this.newEndpoints.addAll(\n                        EndpointUtils.convert2Endpoints(path, changedPath.getIncreased()));\n                    this.missingEndpoints.addAll(\n                        EndpointUtils.convert2Endpoints(path, changedPath.getMissing()));\n                    changedOperations.addAll(changedPath.getChanged());\n                  });\n        });\n    getExtensionsDiff()\n        .diff(oldSpecOpenApi.getExtensions(), newSpecOpenApi.getExtensions())\n        .ifPresent(this::setChangedExtension);\n\n    return getChangedOpenApi();\n  }", "signature": "private ChangedOpenApi compare()"}, {"syntax_pass": true, "original_string": "  private void setChangedExtension(ChangedExtensions changedExtension) {\n    this.changedExtensions = changedExtension;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setChangedExtension", "params": [{"name": "changedExtension", "type": "ChangedExtensions"}], "body": "                                                                       {\n    this.changedExtensions = changedExtension;\n  }", "signature": "private void setChangedExtension(ChangedExtensions changedExtension)"}, {"syntax_pass": true, "original_string": "  private void preProcess(OpenAPI openApi) {\n    List<SecurityRequirement> securityRequirements = openApi.getSecurity();\n    if (securityRequirements != null) {\n      List<SecurityRequirement> distinctSecurityRequirements =\n          securityRequirements.stream().distinct().collect(Collectors.toList());\n      Map<String, PathItem> paths = openApi.getPaths();\n      if (paths != null) {\n        paths\n            .values()\n            .forEach(\n                pathItem ->\n                    pathItem.readOperationsMap().values().stream()\n                        .filter(operation -> operation.getSecurity() != null)\n                        .forEach(\n                            operation ->\n                                operation.setSecurity(\n                                    operation.getSecurity().stream()\n                                        .distinct()\n                                        .collect(Collectors.toList()))));\n        paths\n            .values()\n            .forEach(\n                pathItem ->\n                    pathItem.readOperationsMap().values().stream()\n                        .filter(operation -> operation.getSecurity() == null)\n                        .forEach(operation -> operation.setSecurity(distinctSecurityRequirements)));\n      }\n      openApi.setSecurity(null);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "preProcess", "params": [{"name": "openApi", "type": "OpenAPI"}], "body": "                                           {\n    List<SecurityRequirement> securityRequirements = openApi.getSecurity();\n    if (securityRequirements != null) {\n      List<SecurityRequirement> distinctSecurityRequirements =\n          securityRequirements.stream().distinct().collect(Collectors.toList());\n      Map<String, PathItem> paths = openApi.getPaths();\n      if (paths != null) {\n        paths\n            .values()\n            .forEach(\n                pathItem ->\n                    pathItem.readOperationsMap().values().stream()\n                        .filter(operation -> operation.getSecurity() != null)\n                        .forEach(\n                            operation ->\n                                operation.setSecurity(\n                                    operation.getSecurity().stream()\n                                        .distinct()\n                                        .collect(Collectors.toList()))));\n        paths\n            .values()\n            .forEach(\n                pathItem ->\n                    pathItem.readOperationsMap().values().stream()\n                        .filter(operation -> operation.getSecurity() == null)\n                        .forEach(operation -> operation.setSecurity(distinctSecurityRequirements)));\n      }\n      openApi.setSecurity(null);\n    }\n  }", "signature": "private void preProcess(OpenAPI openApi)"}, {"syntax_pass": true, "original_string": "  private ChangedOpenApi getChangedOpenApi() {\n    return new ChangedOpenApi(options)\n        .setMissingEndpoints(missingEndpoints)\n        .setNewEndpoints(newEndpoints)\n        .setNewSpecOpenApi(newSpecOpenApi)\n        .setOldSpecOpenApi(oldSpecOpenApi)\n        .setChangedOperations(changedOperations)\n        .setChangedExtensions(changedExtensions)\n        .setChangedSchemas(deferredSchemaCache.getChangedSchemas());\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ChangedOpenApi", "classes": []}, "name": "getChangedOpenApi", "params": [], "body": "                                             {\n    return new ChangedOpenApi(options)\n        .setMissingEndpoints(missingEndpoints)\n        .setNewEndpoints(newEndpoints)\n        .setNewSpecOpenApi(newSpecOpenApi)\n        .setOldSpecOpenApi(oldSpecOpenApi)\n        .setChangedOperations(changedOperations)\n        .setChangedExtensions(changedExtensions)\n        .setChangedSchemas(deferredSchemaCache.getChangedSchemas());\n  }", "signature": "private ChangedOpenApi getChangedOpenApi()"}, {"syntax_pass": true, "original_string": "  public DeferredSchemaCache getDeferredSchemaCache() {\n    return deferredSchemaCache;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredSchemaCache", "classes": []}, "name": "getDeferredSchemaCache", "params": [], "body": "                                                      {\n    return deferredSchemaCache;\n  }", "signature": "public DeferredSchemaCache getDeferredSchemaCache()"}, {"syntax_pass": true, "original_string": "  public PathsDiff getPathsDiff() {\n    return this.pathsDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PathsDiff", "classes": []}, "name": "getPathsDiff", "params": [], "body": "                                  {\n    return this.pathsDiff;\n  }", "signature": "public PathsDiff getPathsDiff()"}, {"syntax_pass": true, "original_string": "  public PathDiff getPathDiff() {\n    return this.pathDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PathDiff", "classes": []}, "name": "getPathDiff", "params": [], "body": "                                {\n    return this.pathDiff;\n  }", "signature": "public PathDiff getPathDiff()"}, {"syntax_pass": true, "original_string": "  public SchemaDiff getSchemaDiff() {\n    return this.schemaDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SchemaDiff", "classes": []}, "name": "getSchemaDiff", "params": [], "body": "                                    {\n    return this.schemaDiff;\n  }", "signature": "public SchemaDiff getSchemaDiff()"}, {"syntax_pass": true, "original_string": "  public ContentDiff getContentDiff() {\n    return this.contentDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ContentDiff", "classes": []}, "name": "getContentDiff", "params": [], "body": "                                      {\n    return this.contentDiff;\n  }", "signature": "public ContentDiff getContentDiff()"}, {"syntax_pass": true, "original_string": "  public ParametersDiff getParametersDiff() {\n    return this.parametersDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ParametersDiff", "classes": []}, "name": "getParametersDiff", "params": [], "body": "                                            {\n    return this.parametersDiff;\n  }", "signature": "public ParametersDiff getParametersDiff()"}, {"syntax_pass": true, "original_string": "  public ParameterDiff getParameterDiff() {\n    return this.parameterDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ParameterDiff", "classes": []}, "name": "getParameterDiff", "params": [], "body": "                                          {\n    return this.parameterDiff;\n  }", "signature": "public ParameterDiff getParameterDiff()"}, {"syntax_pass": true, "original_string": "  public RequestBodyDiff getRequestBodyDiff() {\n    return this.requestBodyDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RequestBodyDiff", "classes": []}, "name": "getRequestBodyDiff", "params": [], "body": "                                              {\n    return this.requestBodyDiff;\n  }", "signature": "public RequestBodyDiff getRequestBodyDiff()"}, {"syntax_pass": true, "original_string": "  public ResponseDiff getResponseDiff() {\n    return this.responseDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ResponseDiff", "classes": []}, "name": "getResponseDiff", "params": [], "body": "                                        {\n    return this.responseDiff;\n  }", "signature": "public ResponseDiff getResponseDiff()"}, {"syntax_pass": true, "original_string": "  public HeadersDiff getHeadersDiff() {\n    return this.headersDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "HeadersDiff", "classes": []}, "name": "getHeadersDiff", "params": [], "body": "                                      {\n    return this.headersDiff;\n  }", "signature": "public HeadersDiff getHeadersDiff()"}, {"syntax_pass": true, "original_string": "  public HeaderDiff getHeaderDiff() {\n    return this.headerDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "HeaderDiff", "classes": []}, "name": "getHeaderDiff", "params": [], "body": "                                    {\n    return this.headerDiff;\n  }", "signature": "public HeaderDiff getHeaderDiff()"}, {"syntax_pass": true, "original_string": "  public ApiResponseDiff getApiResponseDiff() {\n    return this.apiResponseDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ApiResponseDiff", "classes": []}, "name": "getApiResponseDiff", "params": [], "body": "                                              {\n    return this.apiResponseDiff;\n  }", "signature": "public ApiResponseDiff getApiResponseDiff()"}, {"syntax_pass": true, "original_string": "  public OperationDiff getOperationDiff() {\n    return this.operationDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OperationDiff", "classes": []}, "name": "getOperationDiff", "params": [], "body": "                                          {\n    return this.operationDiff;\n  }", "signature": "public OperationDiff getOperationDiff()"}, {"syntax_pass": true, "original_string": "  public SecurityRequirementsDiff getSecurityRequirementsDiff() {\n    return this.securityRequirementsDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecurityRequirementsDiff", "classes": []}, "name": "getSecurityRequirementsDiff", "params": [], "body": "                                                                {\n    return this.securityRequirementsDiff;\n  }", "signature": "public SecurityRequirementsDiff getSecurityRequirementsDiff()"}, {"syntax_pass": true, "original_string": "  public SecurityRequirementDiff getSecurityRequirementDiff() {\n    return this.securityRequirementDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecurityRequirementDiff", "classes": []}, "name": "getSecurityRequirementDiff", "params": [], "body": "                                                              {\n    return this.securityRequirementDiff;\n  }", "signature": "public SecurityRequirementDiff getSecurityRequirementDiff()"}, {"syntax_pass": true, "original_string": "  public SecuritySchemeDiff getSecuritySchemeDiff() {\n    return this.securitySchemeDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SecuritySchemeDiff", "classes": []}, "name": "getSecuritySchemeDiff", "params": [], "body": "                                                    {\n    return this.securitySchemeDiff;\n  }", "signature": "public SecuritySchemeDiff getSecuritySchemeDiff()"}, {"syntax_pass": true, "original_string": "  public OAuthFlowsDiff getOAuthFlowsDiff() {\n    return this.oAuthFlowsDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OAuthFlowsDiff", "classes": []}, "name": "getOAuthFlowsDiff", "params": [], "body": "                                            {\n    return this.oAuthFlowsDiff;\n  }", "signature": "public OAuthFlowsDiff getOAuthFlowsDiff()"}, {"syntax_pass": true, "original_string": "  public OAuthFlowDiff getOAuthFlowDiff() {\n    return this.oAuthFlowDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OAuthFlowDiff", "classes": []}, "name": "getOAuthFlowDiff", "params": [], "body": "                                          {\n    return this.oAuthFlowDiff;\n  }", "signature": "public OAuthFlowDiff getOAuthFlowDiff()"}, {"syntax_pass": true, "original_string": "  public ExtensionsDiff getExtensionsDiff() {\n    return this.extensionsDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ExtensionsDiff", "classes": []}, "name": "getExtensionsDiff", "params": [], "body": "                                            {\n    return this.extensionsDiff;\n  }", "signature": "public ExtensionsDiff getExtensionsDiff()"}, {"syntax_pass": true, "original_string": "  public MetadataDiff getMetadataDiff() {\n    return this.metadataDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "MetadataDiff", "classes": []}, "name": "getMetadataDiff", "params": [], "body": "                                        {\n    return this.metadataDiff;\n  }", "signature": "public MetadataDiff getMetadataDiff()"}, {"syntax_pass": true, "original_string": "  public OpenAPI getOldSpecOpenApi() {\n    return this.oldSpecOpenApi;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OpenAPI", "classes": []}, "name": "getOldSpecOpenApi", "params": [], "body": "                                     {\n    return this.oldSpecOpenApi;\n  }", "signature": "public OpenAPI getOldSpecOpenApi()"}, {"syntax_pass": true, "original_string": "  public OpenAPI getNewSpecOpenApi() {\n    return this.newSpecOpenApi;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OpenAPI", "classes": []}, "name": "getNewSpecOpenApi", "params": [], "body": "                                     {\n    return this.newSpecOpenApi;\n  }", "signature": "public OpenAPI getNewSpecOpenApi()"}, {"syntax_pass": true, "original_string": "  public List<Endpoint> getNewEndpoints() {\n    return this.newEndpoints;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Endpoint>", "classes": []}, "name": "getNewEndpoints", "params": [], "body": "                                          {\n    return this.newEndpoints;\n  }", "signature": "public List<Endpoint> getNewEndpoints()"}, {"syntax_pass": true, "original_string": "  public List<Endpoint> getMissingEndpoints() {\n    return this.missingEndpoints;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Endpoint>", "classes": []}, "name": "getMissingEndpoints", "params": [], "body": "                                              {\n    return this.missingEndpoints;\n  }", "signature": "public List<Endpoint> getMissingEndpoints()"}, {"syntax_pass": true, "original_string": "  public List<ChangedOperation> getChangedOperations() {\n    return this.changedOperations;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<ChangedOperation>", "classes": []}, "name": "getChangedOperations", "params": [], "body": "                                                       {\n    return this.changedOperations;\n  }", "signature": "public List<ChangedOperation> getChangedOperations()"}, {"syntax_pass": true, "original_string": "  public ChangedExtensions getChangedExtensions() {\n    return this.changedExtensions;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedExtensions", "classes": []}, "name": "getChangedExtensions", "params": [], "body": "                                                  {\n    return this.changedExtensions;\n  }", "signature": "public ChangedExtensions getChangedExtensions()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/OpenApiDiffOptions.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport org.apache.commons.configuration2.CompositeConfiguration;\nimport org.apache.commons.configuration2.YAMLConfiguration;\nimport org.apache.commons.configuration2.ex.ConfigurationException;\n\npublic class OpenApiDiffOptions {\n  private final CompositeConfiguration config;\n\n  private OpenApiDiffOptions(CompositeConfiguration config) {\n    this.config = config;\n  }\n\n  public CompositeConfiguration getConfig() {\n    return config;\n  }\n\n  public static Builder builder() {\n    return new Builder();\n  }\n\n  public static class Builder {\n    private OpenApiDiffOptions built = new OpenApiDiffOptions(new CompositeConfiguration());\n\n    public Builder configYaml(File file) {\n      YAMLConfiguration yamlConfig = new YAMLConfiguration();\n      try {\n        yamlConfig.read(new FileReader(file));\n      } catch (ConfigurationException | FileNotFoundException e) {\n        throw new IllegalArgumentException(\"Problem loading config. file=\" + file, e);\n      }\n      // Ideally immutable, but since it isn't, we just modify the config directly\n      built.getConfig().addConfigurationFirst(yamlConfig);\n      return this;\n    }\n\n    public Builder configProperty(String propKey, String propVal) {\n      built.getConfig().setProperty(propKey, propVal);\n      return this;\n    }\n\n    public OpenApiDiffOptions build() {\n      return built;\n    }\n  }\n}\n", "file_hash": "6c81773d2cadbbdf4cab6a7fe0988bec9acf52ddac292d7c4c9a9fa12821a61f", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import java.io.File;", "import java.io.FileNotFoundException;", "import java.io.FileReader;", "import org.apache.commons.configuration2.CompositeConfiguration;", "import org.apache.commons.configuration2.YAMLConfiguration;", "import org.apache.commons.configuration2.ex.ConfigurationException;"], "methods": [], "classes": [{"original_string": "public class OpenApiDiffOptions {\n  private final CompositeConfiguration config;\n\n  private OpenApiDiffOptions(CompositeConfiguration config) {\n    this.config = config;\n  }\n\n  public CompositeConfiguration getConfig() {\n    return config;\n  }\n\n  public static Builder builder() {\n    return new Builder();\n  }\n\n  public static class Builder {\n    private OpenApiDiffOptions built = new OpenApiDiffOptions(new CompositeConfiguration());\n\n    public Builder configYaml(File file) {\n      YAMLConfiguration yamlConfig = new YAMLConfiguration();\n      try {\n        yamlConfig.read(new FileReader(file));\n      } catch (ConfigurationException | FileNotFoundException e) {\n        throw new IllegalArgumentException(\"Problem loading config. file=\" + file, e);\n      }\n      // Ideally immutable, but since it isn't, we just modify the config directly\n      built.getConfig().addConfigurationFirst(yamlConfig);\n      return this;\n    }\n\n    public Builder configProperty(String propKey, String propVal) {\n      built.getConfig().setProperty(propKey, propVal);\n      return this;\n    }\n\n    public OpenApiDiffOptions build() {\n      return built;\n    }\n  }\n}", "definition": "public class OpenApiDiffOptions", "class_docstring": "", "name": "OpenApiDiffOptions", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final CompositeConfiguration config;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CompositeConfiguration", "name": "config", "syntax_pass": true}], "classes": [{"original_string": "  public static class Builder {\n    private OpenApiDiffOptions built = new OpenApiDiffOptions(new CompositeConfiguration());\n\n    public Builder configYaml(File file) {\n      YAMLConfiguration yamlConfig = new YAMLConfiguration();\n      try {\n        yamlConfig.read(new FileReader(file));\n      } catch (ConfigurationException | FileNotFoundException e) {\n        throw new IllegalArgumentException(\"Problem loading config. file=\" + file, e);\n      }\n      // Ideally immutable, but since it isn't, we just modify the config directly\n      built.getConfig().addConfigurationFirst(yamlConfig);\n      return this;\n    }\n\n    public Builder configProperty(String propKey, String propVal) {\n      built.getConfig().setProperty(propKey, propVal);\n      return this;\n    }\n\n    public OpenApiDiffOptions build() {\n      return built;\n    }\n  }", "definition": "  public static class Builder", "class_docstring": "", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private OpenApiDiffOptions built = new OpenApiDiffOptions(new CompositeConfiguration());", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OpenApiDiffOptions", "name": "built = new OpenApiDiffOptions(new CompositeConfiguration())", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public Builder configYaml(File file) {\n      YAMLConfiguration yamlConfig = new YAMLConfiguration();\n      try {\n        yamlConfig.read(new FileReader(file));\n      } catch (ConfigurationException | FileNotFoundException e) {\n        throw new IllegalArgumentException(\"Problem loading config. file=\" + file, e);\n      }\n      // Ideally immutable, but since it isn't, we just modify the config directly\n      built.getConfig().addConfigurationFirst(yamlConfig);\n      return this;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "configYaml", "params": [{"name": "file", "type": "File"}], "body": "                                         {\n      YAMLConfiguration yamlConfig = new YAMLConfiguration();\n      try {\n        yamlConfig.read(new FileReader(file));\n      } catch (ConfigurationException | FileNotFoundException e) {\n        throw new IllegalArgumentException(\"Problem loading config. file=\" + file, e);\n      }\n      // Ideally immutable, but since it isn't, we just modify the config directly\n      built.getConfig().addConfigurationFirst(yamlConfig);\n      return this;\n    }", "signature": "public Builder configYaml(File file)"}, {"syntax_pass": true, "original_string": "    public Builder configProperty(String propKey, String propVal) {\n      built.getConfig().setProperty(propKey, propVal);\n      return this;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "configProperty", "params": [{"name": "propKey", "type": "String"}, {"name": "propVal", "type": "String"}], "body": "                                                                  {\n      built.getConfig().setProperty(propKey, propVal);\n      return this;\n    }", "signature": "public Builder configProperty(String propKey, String propVal)"}, {"syntax_pass": true, "original_string": "    public OpenApiDiffOptions build() {\n      return built;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OpenApiDiffOptions", "classes": []}, "name": "build", "params": [], "body": "                                      {\n      return built;\n    }", "signature": "public OpenApiDiffOptions build()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  private OpenApiDiffOptions(CompositeConfiguration config) {\n    this.config = config;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "OpenApiDiffOptions", "params": [{"name": "config", "type": "CompositeConfiguration"}], "body": "                                                            {\n    this.config = config;\n  }", "signature": "private OpenApiDiffOptions(CompositeConfiguration config)"}, {"syntax_pass": true, "original_string": "  public CompositeConfiguration getConfig() {\n    return config;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CompositeConfiguration", "classes": []}, "name": "getConfig", "params": [], "body": "                                            {\n    return config;\n  }", "signature": "public CompositeConfiguration getConfig()"}, {"syntax_pass": true, "original_string": "  public static Builder builder() {\n    return new Builder();\n  }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Builder", "classes": []}, "name": "builder", "params": [], "body": "                                  {\n    return new Builder();\n  }", "signature": "public static Builder builder()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/CacheKey.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport java.util.Objects;\nimport org.openapitools.openapidiff.core.model.DiffContext;\n\npublic final class CacheKey {\n  private final String left;\n  private final String right;\n  private final DiffContext context;\n\n  public CacheKey(final String left, final String right, final DiffContext context) {\n    this.left = left;\n    this.right = right;\n    this.context = context;\n  }\n\n  public String getLeft() {\n    return this.left;\n  }\n\n  public String getRight() {\n    return this.right;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    CacheKey cacheKey = (CacheKey) o;\n    return Objects.equals(left, cacheKey.left)\n        && Objects.equals(right, cacheKey.right)\n        && Objects.equals(context, cacheKey.context);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(left, right, context);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"CacheKey(left=\"\n        + this.getLeft()\n        + \", right=\"\n        + this.getRight()\n        + \", context=\"\n        + this.getContext()\n        + \")\";\n  }\n}\n", "file_hash": "a4adbaec43821105570d62fd1ac892fd17391145839e1e99245bd22dd2a556f4", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import java.util.Objects;", "import org.openapitools.openapidiff.core.model.DiffContext;"], "methods": [], "classes": [{"original_string": "public final class CacheKey {\n  private final String left;\n  private final String right;\n  private final DiffContext context;\n\n  public CacheKey(final String left, final String right, final DiffContext context) {\n    this.left = left;\n    this.right = right;\n    this.context = context;\n  }\n\n  public String getLeft() {\n    return this.left;\n  }\n\n  public String getRight() {\n    return this.right;\n  }\n\n  public DiffContext getContext() {\n    return this.context;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    CacheKey cacheKey = (CacheKey) o;\n    return Objects.equals(left, cacheKey.left)\n        && Objects.equals(right, cacheKey.right)\n        && Objects.equals(context, cacheKey.context);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(left, right, context);\n  }\n\n  @java.lang.Override\n  public java.lang.String toString() {\n    return \"CacheKey(left=\"\n        + this.getLeft()\n        + \", right=\"\n        + this.getRight()\n        + \", context=\"\n        + this.getContext()\n        + \")\";\n  }\n}", "definition": "public final class CacheKey", "class_docstring": "", "name": "CacheKey", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [{"attribute_expression": "private final String left;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "left", "syntax_pass": true}, {"attribute_expression": "private final String right;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "right", "syntax_pass": true}, {"attribute_expression": "private final DiffContext context;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DiffContext", "name": "context", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public CacheKey(final String left, final String right, final DiffContext context) {\n    this.left = left;\n    this.right = right;\n    this.context = context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "CacheKey", "params": [{"name": "left", "type": "String"}, {"name": "right", "type": "String"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                    {\n    this.left = left;\n    this.right = right;\n    this.context = context;\n  }", "signature": "public CacheKey(final String left, final String right, final DiffContext context)"}, {"syntax_pass": true, "original_string": "  public String getLeft() {\n    return this.left;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getLeft", "params": [], "body": "                          {\n    return this.left;\n  }", "signature": "public String getLeft()"}, {"syntax_pass": true, "original_string": "  public String getRight() {\n    return this.right;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getRight", "params": [], "body": "                           {\n    return this.right;\n  }", "signature": "public String getRight()"}, {"syntax_pass": true, "original_string": "  public DiffContext getContext() {\n    return this.context;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "getContext", "params": [], "body": "                                  {\n    return this.context;\n  }", "signature": "public DiffContext getContext()"}, {"syntax_pass": true, "original_string": "  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    CacheKey cacheKey = (CacheKey) o;\n    return Objects.equals(left, cacheKey.left)\n        && Objects.equals(right, cacheKey.right)\n        && Objects.equals(context, cacheKey.context);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                  {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    CacheKey cacheKey = (CacheKey) o;\n    return Objects.equals(left, cacheKey.left)\n        && Objects.equals(right, cacheKey.right)\n        && Objects.equals(context, cacheKey.context);\n  }", "signature": "@Override\n  public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "  @Override\n  public int hashCode() {\n    return Objects.hash(left, right, context);\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                        {\n    return Objects.hash(left, right, context);\n  }", "signature": "@Override\n  public int hashCode()"}, {"syntax_pass": true, "original_string": "  @java.lang.Override\n  public java.lang.String toString() {\n    return \"CacheKey(left=\"\n        + this.getLeft()\n        + \", right=\"\n        + this.getRight()\n        + \", context=\"\n        + this.getContext()\n        + \")\";\n  }", "docstring": "", "attributes": {"modifiers": "@java.lang.Override\n  public", "marker_annotations": ["@java.lang.Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "java.lang.String", "classes": []}, "name": "toString", "params": [], "body": "                                     {\n    return \"CacheKey(left=\"\n        + this.getLeft()\n        + \", right=\"\n        + this.getRight()\n        + \", context=\"\n        + this.getContext()\n        + \")\";\n  }", "signature": "@java.lang.Override\n  public java.lang.String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/ExtensionDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport org.openapitools.openapidiff.core.model.Change;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.DiffContext;\n\npublic interface ExtensionDiff {\n\n  ExtensionDiff setOpenApiDiff(OpenApiDiff openApiDiff);\n\n  String getName();\n\n  Changed diff(Change<?> extension, DiffContext context);\n\n  default boolean isParentApplicable(\n      Change.Type type, Object object, Object extension, DiffContext context) {\n    return true;\n  }\n}\n", "file_hash": "e6f099fe99ac567d20693219fbb335900d1b44e2d5e615d82e552cb0d78812f9", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import org.openapitools.openapidiff.core.model.Change;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.DiffContext;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface ExtensionDiff {\n\n  ExtensionDiff setOpenApiDiff(OpenApiDiff openApiDiff);\n\n  String getName();\n\n  Changed diff(Change<?> extension, DiffContext context);\n\n  default boolean isParentApplicable(\n      Change.Type type, Object object, Object extension, DiffContext context) {\n    return true;\n  }\n}", "definition": "public interface ExtensionDiff", "interface_docstring": "", "name": "ExtensionDiff", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  ExtensionDiff setOpenApiDiff(OpenApiDiff openApiDiff);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ExtensionDiff", "classes": []}, "name": "setOpenApiDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "", "signature": "ExtensionDiff setOpenApiDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  String getName();", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "getName", "params": [], "body": "", "signature": "String getName()"}, {"syntax_pass": true, "original_string": "  Changed diff(Change<?> extension, DiffContext context);", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Changed", "classes": []}, "name": "diff", "params": [{"name": "extension", "type": "Change<?>"}, {"name": "context", "type": "DiffContext"}], "body": "", "signature": "Changed diff(Change<?> extension, DiffContext context)"}, {"syntax_pass": true, "original_string": "  default boolean isParentApplicable(\n      Change.Type type, Object object, Object extension, DiffContext context) {\n    return true;\n  }", "docstring": "", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isParentApplicable", "params": [{"name": "type", "type": "Change.Type"}, {"name": "object", "type": "Object"}, {"name": "extension", "type": "Object"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                              {\n    return true;\n  }", "signature": "default boolean isParentApplicable(\n      Change.Type type, Object object, Object extension, DiffContext context)"}]}], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/ExtensionsDiff.java", "original_string": "package org.openapitools.openapidiff.core.compare;\n\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\nimport static org.openapitools.openapidiff.core.utils.Copy.copyMap;\n\nimport java.util.*;\nimport java.util.function.Function;\nimport org.openapitools.openapidiff.core.model.Change;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedExtensions;\nimport org.openapitools.openapidiff.core.model.DiffContext;\n\npublic class ExtensionsDiff {\n  private final OpenApiDiff openApiDiff;\n\n  private final List<ExtensionDiff> extensionDiffs = new ArrayList<>();\n\n  public ExtensionsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    ServiceLoader<ExtensionDiff> extensionsLoader = ServiceLoader.load(ExtensionDiff.class);\n    extensionsLoader.reload();\n    for (ExtensionDiff anExtensionsLoader : extensionsLoader) {\n      extensionDiffs.add(anExtensionsLoader);\n    }\n  }\n\n  public boolean isParentApplicable(\n      Change.Type type, Object parent, Map<String, Object> extensions, DiffContext context) {\n    if (extensions.isEmpty()) {\n      return true;\n    }\n    return extensions.entrySet().stream()\n        .map(\n            entry ->\n                executeExtension(\n                    entry.getKey(),\n                    extensionDiff ->\n                        extensionDiff.isParentApplicable(type, parent, entry.getValue(), context)))\n        .allMatch(aBoolean -> aBoolean.orElse(true));\n  }\n\n  public Optional<ExtensionDiff> getExtensionDiff(String name) {\n    return extensionDiffs.stream().filter(diff -> (\"x-\" + diff.getName()).equals(name)).findFirst();\n  }\n\n  public <T> Optional<T> executeExtension(String name, Function<ExtensionDiff, T> predicate) {\n    return getExtensionDiff(name)\n        .map(extensionDiff -> extensionDiff.setOpenApiDiff(openApiDiff))\n        .map(predicate);\n  }\n\n  public Optional<ChangedExtensions> diff(Map<String, Object> left, Map<String, Object> right) {\n    return this.diff(left, right, null);\n  }\n\n  public Optional<ChangedExtensions> diff(\n      Map<String, Object> left, Map<String, Object> right, DiffContext context) {\n    left = copyMap(left);\n    right = copyMap(right);\n    ChangedExtensions changedExtensions = new ChangedExtensions(left, copyMap(right), context);\n    for (Map.Entry<String, Object> entry : left.entrySet()) {\n      if (right.containsKey(entry.getKey())) {\n        Object rightValue = right.remove(entry.getKey());\n        executeExtensionDiff(entry.getKey(), Change.changed(entry.getValue(), rightValue), context)\n            .filter(Changed::isDifferent)\n            .ifPresent(changed -> changedExtensions.getChanged().put(entry.getKey(), changed));\n      } else {\n        executeExtensionDiff(entry.getKey(), Change.removed(entry.getValue()), context)\n            .filter(Changed::isDifferent)\n            .ifPresent(changed -> changedExtensions.getMissing().put(entry.getKey(), changed));\n      }\n    }\n    right.forEach(\n        (key, value) ->\n            executeExtensionDiff(key, Change.added(value), context)\n                .filter(Changed::isDifferent)\n                .ifPresent(changed -> changedExtensions.getIncreased().put(key, changed)));\n    return isChanged(changedExtensions);\n  }\n\n  private Optional<Changed> executeExtensionDiff(\n      String name, Change<?> change, DiffContext context) {\n    return executeExtension(name, diff -> diff.setOpenApiDiff(openApiDiff).diff(change, context));\n  }\n}\n", "file_hash": "7fb01c9933cd5e80846b6962386f7182b939a1e156907d080861b3caa7110cb8", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import static org.openapitools.openapidiff.core.utils.Copy.copyMap;", "import java.util.*;", "import java.util.function.Function;", "import org.openapitools.openapidiff.core.model.Change;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedExtensions;", "import org.openapitools.openapidiff.core.model.DiffContext;"], "methods": [], "classes": [{"original_string": "public class ExtensionsDiff {\n  private final OpenApiDiff openApiDiff;\n\n  private final List<ExtensionDiff> extensionDiffs = new ArrayList<>();\n\n  public ExtensionsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    ServiceLoader<ExtensionDiff> extensionsLoader = ServiceLoader.load(ExtensionDiff.class);\n    extensionsLoader.reload();\n    for (ExtensionDiff anExtensionsLoader : extensionsLoader) {\n      extensionDiffs.add(anExtensionsLoader);\n    }\n  }\n\n  public boolean isParentApplicable(\n      Change.Type type, Object parent, Map<String, Object> extensions, DiffContext context) {\n    if (extensions.isEmpty()) {\n      return true;\n    }\n    return extensions.entrySet().stream()\n        .map(\n            entry ->\n                executeExtension(\n                    entry.getKey(),\n                    extensionDiff ->\n                        extensionDiff.isParentApplicable(type, parent, entry.getValue(), context)))\n        .allMatch(aBoolean -> aBoolean.orElse(true));\n  }\n\n  public Optional<ExtensionDiff> getExtensionDiff(String name) {\n    return extensionDiffs.stream().filter(diff -> (\"x-\" + diff.getName()).equals(name)).findFirst();\n  }\n\n  public <T> Optional<T> executeExtension(String name, Function<ExtensionDiff, T> predicate) {\n    return getExtensionDiff(name)\n        .map(extensionDiff -> extensionDiff.setOpenApiDiff(openApiDiff))\n        .map(predicate);\n  }\n\n  public Optional<ChangedExtensions> diff(Map<String, Object> left, Map<String, Object> right) {\n    return this.diff(left, right, null);\n  }\n\n  public Optional<ChangedExtensions> diff(\n      Map<String, Object> left, Map<String, Object> right, DiffContext context) {\n    left = copyMap(left);\n    right = copyMap(right);\n    ChangedExtensions changedExtensions = new ChangedExtensions(left, copyMap(right), context);\n    for (Map.Entry<String, Object> entry : left.entrySet()) {\n      if (right.containsKey(entry.getKey())) {\n        Object rightValue = right.remove(entry.getKey());\n        executeExtensionDiff(entry.getKey(), Change.changed(entry.getValue(), rightValue), context)\n            .filter(Changed::isDifferent)\n            .ifPresent(changed -> changedExtensions.getChanged().put(entry.getKey(), changed));\n      } else {\n        executeExtensionDiff(entry.getKey(), Change.removed(entry.getValue()), context)\n            .filter(Changed::isDifferent)\n            .ifPresent(changed -> changedExtensions.getMissing().put(entry.getKey(), changed));\n      }\n    }\n    right.forEach(\n        (key, value) ->\n            executeExtensionDiff(key, Change.added(value), context)\n                .filter(Changed::isDifferent)\n                .ifPresent(changed -> changedExtensions.getIncreased().put(key, changed)));\n    return isChanged(changedExtensions);\n  }\n\n  private Optional<Changed> executeExtensionDiff(\n      String name, Change<?> change, DiffContext context) {\n    return executeExtension(name, diff -> diff.setOpenApiDiff(openApiDiff).diff(change, context));\n  }\n}", "definition": "public class ExtensionsDiff", "class_docstring": "", "name": "ExtensionsDiff", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}, {"attribute_expression": "private final List<ExtensionDiff> extensionDiffs = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<ExtensionDiff>", "name": "extensionDiffs = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ExtensionsDiff(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    ServiceLoader<ExtensionDiff> extensionsLoader = ServiceLoader.load(ExtensionDiff.class);\n    extensionsLoader.reload();\n    for (ExtensionDiff anExtensionsLoader : extensionsLoader) {\n      extensionDiffs.add(anExtensionsLoader);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ExtensionsDiff", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                 {\n    this.openApiDiff = openApiDiff;\n    ServiceLoader<ExtensionDiff> extensionsLoader = ServiceLoader.load(ExtensionDiff.class);\n    extensionsLoader.reload();\n    for (ExtensionDiff anExtensionsLoader : extensionsLoader) {\n      extensionDiffs.add(anExtensionsLoader);\n    }\n  }", "signature": "public ExtensionsDiff(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public boolean isParentApplicable(\n      Change.Type type, Object parent, Map<String, Object> extensions, DiffContext context) {\n    if (extensions.isEmpty()) {\n      return true;\n    }\n    return extensions.entrySet().stream()\n        .map(\n            entry ->\n                executeExtension(\n                    entry.getKey(),\n                    extensionDiff ->\n                        extensionDiff.isParentApplicable(type, parent, entry.getValue(), context)))\n        .allMatch(aBoolean -> aBoolean.orElse(true));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isParentApplicable", "params": [{"name": "type", "type": "Change.Type"}, {"name": "parent", "type": "Object"}, {"name": "extensions", "type": "Map<String, Object>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                            {\n    if (extensions.isEmpty()) {\n      return true;\n    }\n    return extensions.entrySet().stream()\n        .map(\n            entry ->\n                executeExtension(\n                    entry.getKey(),\n                    extensionDiff ->\n                        extensionDiff.isParentApplicable(type, parent, entry.getValue(), context)))\n        .allMatch(aBoolean -> aBoolean.orElse(true));\n  }", "signature": "public boolean isParentApplicable(\n      Change.Type type, Object parent, Map<String, Object> extensions, DiffContext context)"}, {"syntax_pass": true, "original_string": "  public Optional<ExtensionDiff> getExtensionDiff(String name) {\n    return extensionDiffs.stream().filter(diff -> (\"x-\" + diff.getName()).equals(name)).findFirst();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<ExtensionDiff>", "classes": []}, "name": "getExtensionDiff", "params": [{"name": "name", "type": "String"}], "body": "                                                               {\n    return extensionDiffs.stream().filter(diff -> (\"x-\" + diff.getName()).equals(name)).findFirst();\n  }", "signature": "public Optional<ExtensionDiff> getExtensionDiff(String name)"}, {"syntax_pass": true, "original_string": "  public <T> Optional<T> executeExtension(String name, Function<ExtensionDiff, T> predicate) {\n    return getExtensionDiff(name)\n        .map(extensionDiff -> extensionDiff.setOpenApiDiff(openApiDiff))\n        .map(predicate);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<T>", "classes": []}, "name": "executeExtension", "params": [{"name": "name", "type": "String"}, {"name": "predicate", "type": "Function<ExtensionDiff, T>"}], "body": "                                                                                             {\n    return getExtensionDiff(name)\n        .map(extensionDiff -> extensionDiff.setOpenApiDiff(openApiDiff))\n        .map(predicate);\n  }", "signature": "public <T> Optional<T> executeExtension(String name, Function<ExtensionDiff, T> predicate)"}, {"syntax_pass": true, "original_string": "  public Optional<ChangedExtensions> diff(Map<String, Object> left, Map<String, Object> right) {\n    return this.diff(left, right, null);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<ChangedExtensions>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "Map<String, Object>"}, {"name": "right", "type": "Map<String, Object>"}], "body": "                                                                                               {\n    return this.diff(left, right, null);\n  }", "signature": "public Optional<ChangedExtensions> diff(Map<String, Object> left, Map<String, Object> right)"}, {"syntax_pass": true, "original_string": "  public Optional<ChangedExtensions> diff(\n      Map<String, Object> left, Map<String, Object> right, DiffContext context) {\n    left = copyMap(left);\n    right = copyMap(right);\n    ChangedExtensions changedExtensions = new ChangedExtensions(left, copyMap(right), context);\n    for (Map.Entry<String, Object> entry : left.entrySet()) {\n      if (right.containsKey(entry.getKey())) {\n        Object rightValue = right.remove(entry.getKey());\n        executeExtensionDiff(entry.getKey(), Change.changed(entry.getValue(), rightValue), context)\n            .filter(Changed::isDifferent)\n            .ifPresent(changed -> changedExtensions.getChanged().put(entry.getKey(), changed));\n      } else {\n        executeExtensionDiff(entry.getKey(), Change.removed(entry.getValue()), context)\n            .filter(Changed::isDifferent)\n            .ifPresent(changed -> changedExtensions.getMissing().put(entry.getKey(), changed));\n      }\n    }\n    right.forEach(\n        (key, value) ->\n            executeExtensionDiff(key, Change.added(value), context)\n                .filter(Changed::isDifferent)\n                .ifPresent(changed -> changedExtensions.getIncreased().put(key, changed)));\n    return isChanged(changedExtensions);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Optional<ChangedExtensions>", "classes": []}, "name": "diff", "params": [{"name": "left", "type": "Map<String, Object>"}, {"name": "right", "type": "Map<String, Object>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                                {\n    left = copyMap(left);\n    right = copyMap(right);\n    ChangedExtensions changedExtensions = new ChangedExtensions(left, copyMap(right), context);\n    for (Map.Entry<String, Object> entry : left.entrySet()) {\n      if (right.containsKey(entry.getKey())) {\n        Object rightValue = right.remove(entry.getKey());\n        executeExtensionDiff(entry.getKey(), Change.changed(entry.getValue(), rightValue), context)\n            .filter(Changed::isDifferent)\n            .ifPresent(changed -> changedExtensions.getChanged().put(entry.getKey(), changed));\n      } else {\n        executeExtensionDiff(entry.getKey(), Change.removed(entry.getValue()), context)\n            .filter(Changed::isDifferent)\n            .ifPresent(changed -> changedExtensions.getMissing().put(entry.getKey(), changed));\n      }\n    }\n    right.forEach(\n        (key, value) ->\n            executeExtensionDiff(key, Change.added(value), context)\n                .filter(Changed::isDifferent)\n                .ifPresent(changed -> changedExtensions.getIncreased().put(key, changed)));\n    return isChanged(changedExtensions);\n  }", "signature": "public Optional<ChangedExtensions> diff(\n      Map<String, Object> left, Map<String, Object> right, DiffContext context)"}, {"syntax_pass": true, "original_string": "  private Optional<Changed> executeExtensionDiff(\n      String name, Change<?> change, DiffContext context) {\n    return executeExtension(name, diff -> diff.setOpenApiDiff(openApiDiff).diff(change, context));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Optional<Changed>", "classes": []}, "name": "executeExtensionDiff", "params": [{"name": "name", "type": "String"}, {"name": "change", "type": "Change<?>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                          {\n    return executeExtension(name, diff -> diff.setOpenApiDiff(openApiDiff).diff(change, context));\n  }", "signature": "private Optional<Changed> executeExtensionDiff(\n      String name, Change<?> change, DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/schemadiffresult/ArraySchemaDiffResult.java", "original_string": "package org.openapitools.openapidiff.core.compare.schemadiffresult;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.media.ArraySchema;\nimport io.swagger.v3.oas.models.media.Schema;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiff;\nimport org.openapitools.openapidiff.core.model.ChangedSchema;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.model.deferred.RecursiveSchemaSet;\n\npublic class ArraySchemaDiffResult extends SchemaDiffResult {\n  public ArraySchemaDiffResult(OpenApiDiff openApiDiff) {\n    super(\"array\", openApiDiff);\n  }\n\n  @Override\n  public <T extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      T left,\n      T right,\n      DiffContext context) {\n    ArraySchema leftArraySchema = (ArraySchema) left;\n    ArraySchema rightArraySchema = (ArraySchema) right;\n\n    DeferredChanged<ChangedSchema> superSchemaDiff =\n        super.diff(refSet, leftComponents, rightComponents, left, right, context)\n            .flatMap(\n                changeSchemaOptional -> {\n                  DeferredChanged<ChangedSchema> itemsDiff =\n                      openApiDiff\n                          .getSchemaDiff()\n                          .diff(\n                              refSet,\n                              leftArraySchema.getItems(),\n                              rightArraySchema.getItems(),\n                              context.copyWithRequired(true));\n                  itemsDiff.ifPresent(changedSchema::setItems);\n                  return itemsDiff;\n                });\n\n    return superSchemaDiff.mapOptional(schemaOptional -> isApplicable(context));\n  }\n}\n", "file_hash": "fc7fe567d1ddb12584ed9c783574fe98455e31b50af417bacf0dc5875319a1b7", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare.schemadiffresult;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.media.ArraySchema;", "import io.swagger.v3.oas.models.media.Schema;", "import org.openapitools.openapidiff.core.compare.OpenApiDiff;", "import org.openapitools.openapidiff.core.model.ChangedSchema;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.model.deferred.RecursiveSchemaSet;"], "methods": [], "classes": [{"original_string": "public class ArraySchemaDiffResult extends SchemaDiffResult {\n  public ArraySchemaDiffResult(OpenApiDiff openApiDiff) {\n    super(\"array\", openApiDiff);\n  }\n\n  @Override\n  public <T extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      T left,\n      T right,\n      DiffContext context) {\n    ArraySchema leftArraySchema = (ArraySchema) left;\n    ArraySchema rightArraySchema = (ArraySchema) right;\n\n    DeferredChanged<ChangedSchema> superSchemaDiff =\n        super.diff(refSet, leftComponents, rightComponents, left, right, context)\n            .flatMap(\n                changeSchemaOptional -> {\n                  DeferredChanged<ChangedSchema> itemsDiff =\n                      openApiDiff\n                          .getSchemaDiff()\n                          .diff(\n                              refSet,\n                              leftArraySchema.getItems(),\n                              rightArraySchema.getItems(),\n                              context.copyWithRequired(true));\n                  itemsDiff.ifPresent(changedSchema::setItems);\n                  return itemsDiff;\n                });\n\n    return superSchemaDiff.mapOptional(schemaOptional -> isApplicable(context));\n  }\n}", "definition": "public class ArraySchemaDiffResult extends SchemaDiffResult", "class_docstring": "", "name": "ArraySchemaDiffResult", "super_interfaces": [], "superclasses": "SchemaDiffResult", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ArraySchemaDiffResult(OpenApiDiff openApiDiff) {\n    super(\"array\", openApiDiff);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ArraySchemaDiffResult", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                        {\n    super(\"array\", openApiDiff);\n  }", "signature": "public ArraySchemaDiffResult(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  @Override\n  public <T extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      T left,\n      T right,\n      DiffContext context) {\n    ArraySchema leftArraySchema = (ArraySchema) left;\n    ArraySchema rightArraySchema = (ArraySchema) right;\n\n    DeferredChanged<ChangedSchema> superSchemaDiff =\n        super.diff(refSet, leftComponents, rightComponents, left, right, context)\n            .flatMap(\n                changeSchemaOptional -> {\n                  DeferredChanged<ChangedSchema> itemsDiff =\n                      openApiDiff\n                          .getSchemaDiff()\n                          .diff(\n                              refSet,\n                              leftArraySchema.getItems(),\n                              rightArraySchema.getItems(),\n                              context.copyWithRequired(true));\n                  itemsDiff.ifPresent(changedSchema::setItems);\n                  return itemsDiff;\n                });\n\n    return superSchemaDiff.mapOptional(schemaOptional -> isApplicable(context));\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSchema>", "classes": []}, "name": "diff", "params": [{"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "leftComponents", "type": "Components"}, {"name": "rightComponents", "type": "Components"}, {"name": "left", "type": "T"}, {"name": "right", "type": "T"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n    ArraySchema leftArraySchema = (ArraySchema) left;\n    ArraySchema rightArraySchema = (ArraySchema) right;\n\n    DeferredChanged<ChangedSchema> superSchemaDiff =\n        super.diff(refSet, leftComponents, rightComponents, left, right, context)\n            .flatMap(\n                changeSchemaOptional -> {\n                  DeferredChanged<ChangedSchema> itemsDiff =\n                      openApiDiff\n                          .getSchemaDiff()\n                          .diff(\n                              refSet,\n                              leftArraySchema.getItems(),\n                              rightArraySchema.getItems(),\n                              context.copyWithRequired(true));\n                  itemsDiff.ifPresent(changedSchema::setItems);\n                  return itemsDiff;\n                });\n\n    return superSchemaDiff.mapOptional(schemaOptional -> isApplicable(context));\n  }", "signature": "@Override\n  public <T extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      T left,\n      T right,\n      DiffContext context)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/schemadiffresult/ComposedSchemaDiffResult.java", "original_string": "package org.openapitools.openapidiff.core.compare.schemadiffresult;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.media.ComposedSchema;\nimport io.swagger.v3.oas.models.media.Discriminator;\nimport io.swagger.v3.oas.models.media.Schema;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\nimport org.apache.commons.collections4.CollectionUtils;\nimport org.openapitools.openapidiff.core.compare.MapKeyDiff;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiff;\nimport org.openapitools.openapidiff.core.model.ChangedOneOfSchema;\nimport org.openapitools.openapidiff.core.model.ChangedSchema;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.model.deferred.RealizedChanged;\nimport org.openapitools.openapidiff.core.model.deferred.RecursiveSchemaSet;\nimport org.openapitools.openapidiff.core.utils.RefPointer;\nimport org.openapitools.openapidiff.core.utils.RefType;\n\npublic class ComposedSchemaDiffResult extends SchemaDiffResult {\n  private static final RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n\n  public ComposedSchemaDiffResult(OpenApiDiff openApiDiff) {\n    super(openApiDiff);\n  }\n\n  @Override\n  public <T extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      T left,\n      T right,\n      DiffContext context) {\n\n    if (left instanceof ComposedSchema) {\n      ComposedSchema leftComposedSchema = (ComposedSchema) left;\n      ComposedSchema rightComposedSchema = (ComposedSchema) right;\n      DeferredBuilder<ChangedSchema> discriminatorChangedBuilder = new DeferredBuilder<>();\n\n      if (CollectionUtils.isNotEmpty(leftComposedSchema.getOneOf())\n          || CollectionUtils.isNotEmpty(rightComposedSchema.getOneOf())) {\n\n        Discriminator leftDis = leftComposedSchema.getDiscriminator();\n        Discriminator rightDis = rightComposedSchema.getDiscriminator();\n        if ((leftDis == null && rightDis != null)\n            || (leftDis != null && rightDis == null)\n            || (leftDis != null\n                && rightDis != null\n                && ((leftDis.getPropertyName() == null && rightDis.getPropertyName() != null)\n                    || (leftDis.getPropertyName() != null && rightDis.getPropertyName() == null)\n                    || (leftDis.getPropertyName() != null\n                        && rightDis.getPropertyName() != null\n                        && !leftDis.getPropertyName().equals(rightDis.getPropertyName()))))) {\n          changedSchema.setOldSchema(left);\n          changedSchema.setNewSchema(right);\n          changedSchema.setDiscriminatorPropertyChanged(true);\n          changedSchema.setContext(context);\n          return new RealizedChanged<>(Optional.of(changedSchema));\n        }\n\n        Map<String, String> leftMapping = getMapping(leftComposedSchema);\n        Map<String, String> rightMapping = getMapping(rightComposedSchema);\n\n        MapKeyDiff<String, Schema> mappingDiff =\n            MapKeyDiff.diff(\n                getSchema(leftComponents, leftMapping, leftComposedSchema),\n                getSchema(rightComponents, rightMapping, rightComposedSchema));\n        Map<String, ChangedSchema> changedMapping = new LinkedHashMap<>();\n        for (String key : mappingDiff.getSharedKey()) {\n          Schema<?> leftSchema = new Schema<>();\n          leftSchema.set$ref(leftMapping.get(key));\n          Schema<?> rightSchema = new Schema<>();\n          rightSchema.set$ref(rightMapping.get(key));\n          discriminatorChangedBuilder\n              .with(\n                  openApiDiff\n                      .getSchemaDiff()\n                      .diff(refSet, leftSchema, rightSchema, context.copyWithRequired(true)))\n              .ifPresent(schema -> changedMapping.put(key, schema));\n        }\n\n        discriminatorChangedBuilder.whenSet(\n            composedSchemas ->\n                changedSchema.setOneOfSchema(\n                    new ChangedOneOfSchema(leftMapping, rightMapping, context)\n                        .setIncreased(mappingDiff.getIncreased())\n                        .setMissing(mappingDiff.getMissing())\n                        .setChanged(changedMapping)));\n      }\n\n      return discriminatorChangedBuilder\n          .build()\n          .flatMap(\n              values -> super.diff(refSet, leftComponents, rightComponents, left, right, context));\n    } else {\n      return openApiDiff.getSchemaDiff().getTypeChangedSchema(left, right, context);\n    }\n  }\n\n  private Map<String, Schema> getSchema(\n      Components components, Map<String, String> mapping, ComposedSchema composedSchema) {\n    Map<String, Schema> result = new LinkedHashMap<>();\n    mapping.forEach(\n        (key, value) -> result.put(key, refPointer.resolveRef(components, new Schema<>(), value)));\n\n    result.putAll(getUnnamedSchemas(composedSchema.getAllOf(), \"all-of\"));\n    result.putAll(getUnnamedSchemas(composedSchema.getOneOf(), \"one-of\"));\n    result.putAll(getUnnamedSchemas(composedSchema.getAnyOf(), \"any-of\"));\n    return result;\n  }\n\n  private Map<String, String> getMapping(ComposedSchema composedSchema) {\n    Map<String, String> reverseMapping = new LinkedHashMap<>();\n    for (Schema<?> schema : composedSchema.getOneOf()) {\n      String ref = schema.get$ref();\n      if (ref == null) {\n        continue;\n      }\n      String schemaName = refPointer.getRefName(ref);\n      if (schemaName == null) {\n        throw new IllegalArgumentException(\"invalid schema: \" + ref);\n      }\n      reverseMapping.put(ref, schemaName);\n    }\n\n    if (composedSchema.getDiscriminator() != null\n        && composedSchema.getDiscriminator().getMapping() != null) {\n      for (String ref : composedSchema.getDiscriminator().getMapping().keySet()) {\n        reverseMapping.put(composedSchema.getDiscriminator().getMapping().get(ref), ref);\n      }\n    }\n\n    return reverseMapping.entrySet().stream()\n        .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\n  }\n\n  private Map<String, Schema> getUnnamedSchemas(List<Schema> schemas, String name) {\n    Map<String, Schema> result = new LinkedHashMap<>();\n\n    if (schemas == null) {\n      return result;\n    }\n\n    for (int i = 0; i < schemas.size(); i++) {\n      Schema<?> schema = schemas.get(i);\n\n      // If the ref is named, then we ignore it since getMapping will handle it.\n      if (schema.get$ref() != null) {\n        continue;\n      }\n\n      result.put(String.format(\"%s-%s\", name, i), schema);\n    }\n\n    return result;\n  }\n}\n", "file_hash": "9bc5ba02463872bae2ebbb4e1d9227998c95dce7b2f83a91b9f498c92ad4632e", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare.schemadiffresult;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.media.ComposedSchema;", "import io.swagger.v3.oas.models.media.Discriminator;", "import io.swagger.v3.oas.models.media.Schema;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Optional;", "import java.util.stream.Collectors;", "import org.apache.commons.collections4.CollectionUtils;", "import org.openapitools.openapidiff.core.compare.MapKeyDiff;", "import org.openapitools.openapidiff.core.compare.OpenApiDiff;", "import org.openapitools.openapidiff.core.model.ChangedOneOfSchema;", "import org.openapitools.openapidiff.core.model.ChangedSchema;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.model.deferred.RealizedChanged;", "import org.openapitools.openapidiff.core.model.deferred.RecursiveSchemaSet;", "import org.openapitools.openapidiff.core.utils.RefPointer;", "import org.openapitools.openapidiff.core.utils.RefType;"], "methods": [], "classes": [{"original_string": "public class ComposedSchemaDiffResult extends SchemaDiffResult {\n  private static final RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);\n\n  public ComposedSchemaDiffResult(OpenApiDiff openApiDiff) {\n    super(openApiDiff);\n  }\n\n  @Override\n  public <T extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      T left,\n      T right,\n      DiffContext context) {\n\n    if (left instanceof ComposedSchema) {\n      ComposedSchema leftComposedSchema = (ComposedSchema) left;\n      ComposedSchema rightComposedSchema = (ComposedSchema) right;\n      DeferredBuilder<ChangedSchema> discriminatorChangedBuilder = new DeferredBuilder<>();\n\n      if (CollectionUtils.isNotEmpty(leftComposedSchema.getOneOf())\n          || CollectionUtils.isNotEmpty(rightComposedSchema.getOneOf())) {\n\n        Discriminator leftDis = leftComposedSchema.getDiscriminator();\n        Discriminator rightDis = rightComposedSchema.getDiscriminator();\n        if ((leftDis == null && rightDis != null)\n            || (leftDis != null && rightDis == null)\n            || (leftDis != null\n                && rightDis != null\n                && ((leftDis.getPropertyName() == null && rightDis.getPropertyName() != null)\n                    || (leftDis.getPropertyName() != null && rightDis.getPropertyName() == null)\n                    || (leftDis.getPropertyName() != null\n                        && rightDis.getPropertyName() != null\n                        && !leftDis.getPropertyName().equals(rightDis.getPropertyName()))))) {\n          changedSchema.setOldSchema(left);\n          changedSchema.setNewSchema(right);\n          changedSchema.setDiscriminatorPropertyChanged(true);\n          changedSchema.setContext(context);\n          return new RealizedChanged<>(Optional.of(changedSchema));\n        }\n\n        Map<String, String> leftMapping = getMapping(leftComposedSchema);\n        Map<String, String> rightMapping = getMapping(rightComposedSchema);\n\n        MapKeyDiff<String, Schema> mappingDiff =\n            MapKeyDiff.diff(\n                getSchema(leftComponents, leftMapping, leftComposedSchema),\n                getSchema(rightComponents, rightMapping, rightComposedSchema));\n        Map<String, ChangedSchema> changedMapping = new LinkedHashMap<>();\n        for (String key : mappingDiff.getSharedKey()) {\n          Schema<?> leftSchema = new Schema<>();\n          leftSchema.set$ref(leftMapping.get(key));\n          Schema<?> rightSchema = new Schema<>();\n          rightSchema.set$ref(rightMapping.get(key));\n          discriminatorChangedBuilder\n              .with(\n                  openApiDiff\n                      .getSchemaDiff()\n                      .diff(refSet, leftSchema, rightSchema, context.copyWithRequired(true)))\n              .ifPresent(schema -> changedMapping.put(key, schema));\n        }\n\n        discriminatorChangedBuilder.whenSet(\n            composedSchemas ->\n                changedSchema.setOneOfSchema(\n                    new ChangedOneOfSchema(leftMapping, rightMapping, context)\n                        .setIncreased(mappingDiff.getIncreased())\n                        .setMissing(mappingDiff.getMissing())\n                        .setChanged(changedMapping)));\n      }\n\n      return discriminatorChangedBuilder\n          .build()\n          .flatMap(\n              values -> super.diff(refSet, leftComponents, rightComponents, left, right, context));\n    } else {\n      return openApiDiff.getSchemaDiff().getTypeChangedSchema(left, right, context);\n    }\n  }\n\n  private Map<String, Schema> getSchema(\n      Components components, Map<String, String> mapping, ComposedSchema composedSchema) {\n    Map<String, Schema> result = new LinkedHashMap<>();\n    mapping.forEach(\n        (key, value) -> result.put(key, refPointer.resolveRef(components, new Schema<>(), value)));\n\n    result.putAll(getUnnamedSchemas(composedSchema.getAllOf(), \"all-of\"));\n    result.putAll(getUnnamedSchemas(composedSchema.getOneOf(), \"one-of\"));\n    result.putAll(getUnnamedSchemas(composedSchema.getAnyOf(), \"any-of\"));\n    return result;\n  }\n\n  private Map<String, String> getMapping(ComposedSchema composedSchema) {\n    Map<String, String> reverseMapping = new LinkedHashMap<>();\n    for (Schema<?> schema : composedSchema.getOneOf()) {\n      String ref = schema.get$ref();\n      if (ref == null) {\n        continue;\n      }\n      String schemaName = refPointer.getRefName(ref);\n      if (schemaName == null) {\n        throw new IllegalArgumentException(\"invalid schema: \" + ref);\n      }\n      reverseMapping.put(ref, schemaName);\n    }\n\n    if (composedSchema.getDiscriminator() != null\n        && composedSchema.getDiscriminator().getMapping() != null) {\n      for (String ref : composedSchema.getDiscriminator().getMapping().keySet()) {\n        reverseMapping.put(composedSchema.getDiscriminator().getMapping().get(ref), ref);\n      }\n    }\n\n    return reverseMapping.entrySet().stream()\n        .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\n  }\n\n  private Map<String, Schema> getUnnamedSchemas(List<Schema> schemas, String name) {\n    Map<String, Schema> result = new LinkedHashMap<>();\n\n    if (schemas == null) {\n      return result;\n    }\n\n    for (int i = 0; i < schemas.size(); i++) {\n      Schema<?> schema = schemas.get(i);\n\n      // If the ref is named, then we ignore it since getMapping will handle it.\n      if (schema.get$ref() != null) {\n        continue;\n      }\n\n      result.put(String.format(\"%s-%s\", name, i), schema);\n    }\n\n    return result;\n  }\n}", "definition": "public class ComposedSchemaDiffResult extends SchemaDiffResult", "class_docstring": "", "name": "ComposedSchemaDiffResult", "super_interfaces": [], "superclasses": "SchemaDiffResult", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final RefPointer<Schema<?>> refPointer = new RefPointer<>(RefType.SCHEMAS);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RefPointer<Schema<?>>", "name": "refPointer = new RefPointer<>(RefType.SCHEMAS)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public ComposedSchemaDiffResult(OpenApiDiff openApiDiff) {\n    super(openApiDiff);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ComposedSchemaDiffResult", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                           {\n    super(openApiDiff);\n  }", "signature": "public ComposedSchemaDiffResult(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  @Override\n  public <T extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      T left,\n      T right,\n      DiffContext context) {\n\n    if (left instanceof ComposedSchema) {\n      ComposedSchema leftComposedSchema = (ComposedSchema) left;\n      ComposedSchema rightComposedSchema = (ComposedSchema) right;\n      DeferredBuilder<ChangedSchema> discriminatorChangedBuilder = new DeferredBuilder<>();\n\n      if (CollectionUtils.isNotEmpty(leftComposedSchema.getOneOf())\n          || CollectionUtils.isNotEmpty(rightComposedSchema.getOneOf())) {\n\n        Discriminator leftDis = leftComposedSchema.getDiscriminator();\n        Discriminator rightDis = rightComposedSchema.getDiscriminator();\n        if ((leftDis == null && rightDis != null)\n            || (leftDis != null && rightDis == null)\n            || (leftDis != null\n                && rightDis != null\n                && ((leftDis.getPropertyName() == null && rightDis.getPropertyName() != null)\n                    || (leftDis.getPropertyName() != null && rightDis.getPropertyName() == null)\n                    || (leftDis.getPropertyName() != null\n                        && rightDis.getPropertyName() != null\n                        && !leftDis.getPropertyName().equals(rightDis.getPropertyName()))))) {\n          changedSchema.setOldSchema(left);\n          changedSchema.setNewSchema(right);\n          changedSchema.setDiscriminatorPropertyChanged(true);\n          changedSchema.setContext(context);\n          return new RealizedChanged<>(Optional.of(changedSchema));\n        }\n\n        Map<String, String> leftMapping = getMapping(leftComposedSchema);\n        Map<String, String> rightMapping = getMapping(rightComposedSchema);\n\n        MapKeyDiff<String, Schema> mappingDiff =\n            MapKeyDiff.diff(\n                getSchema(leftComponents, leftMapping, leftComposedSchema),\n                getSchema(rightComponents, rightMapping, rightComposedSchema));\n        Map<String, ChangedSchema> changedMapping = new LinkedHashMap<>();\n        for (String key : mappingDiff.getSharedKey()) {\n          Schema<?> leftSchema = new Schema<>();\n          leftSchema.set$ref(leftMapping.get(key));\n          Schema<?> rightSchema = new Schema<>();\n          rightSchema.set$ref(rightMapping.get(key));\n          discriminatorChangedBuilder\n              .with(\n                  openApiDiff\n                      .getSchemaDiff()\n                      .diff(refSet, leftSchema, rightSchema, context.copyWithRequired(true)))\n              .ifPresent(schema -> changedMapping.put(key, schema));\n        }\n\n        discriminatorChangedBuilder.whenSet(\n            composedSchemas ->\n                changedSchema.setOneOfSchema(\n                    new ChangedOneOfSchema(leftMapping, rightMapping, context)\n                        .setIncreased(mappingDiff.getIncreased())\n                        .setMissing(mappingDiff.getMissing())\n                        .setChanged(changedMapping)));\n      }\n\n      return discriminatorChangedBuilder\n          .build()\n          .flatMap(\n              values -> super.diff(refSet, leftComponents, rightComponents, left, right, context));\n    } else {\n      return openApiDiff.getSchemaDiff().getTypeChangedSchema(left, right, context);\n    }\n  }", "docstring": "", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSchema>", "classes": []}, "name": "diff", "params": [{"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "leftComponents", "type": "Components"}, {"name": "rightComponents", "type": "Components"}, {"name": "left", "type": "T"}, {"name": "right", "type": "T"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n\n    if (left instanceof ComposedSchema) {\n      ComposedSchema leftComposedSchema = (ComposedSchema) left;\n      ComposedSchema rightComposedSchema = (ComposedSchema) right;\n      DeferredBuilder<ChangedSchema> discriminatorChangedBuilder = new DeferredBuilder<>();\n\n      if (CollectionUtils.isNotEmpty(leftComposedSchema.getOneOf())\n          || CollectionUtils.isNotEmpty(rightComposedSchema.getOneOf())) {\n\n        Discriminator leftDis = leftComposedSchema.getDiscriminator();\n        Discriminator rightDis = rightComposedSchema.getDiscriminator();\n        if ((leftDis == null && rightDis != null)\n            || (leftDis != null && rightDis == null)\n            || (leftDis != null\n                && rightDis != null\n                && ((leftDis.getPropertyName() == null && rightDis.getPropertyName() != null)\n                    || (leftDis.getPropertyName() != null && rightDis.getPropertyName() == null)\n                    || (leftDis.getPropertyName() != null\n                        && rightDis.getPropertyName() != null\n                        && !leftDis.getPropertyName().equals(rightDis.getPropertyName()))))) {\n          changedSchema.setOldSchema(left);\n          changedSchema.setNewSchema(right);\n          changedSchema.setDiscriminatorPropertyChanged(true);\n          changedSchema.setContext(context);\n          return new RealizedChanged<>(Optional.of(changedSchema));\n        }\n\n        Map<String, String> leftMapping = getMapping(leftComposedSchema);\n        Map<String, String> rightMapping = getMapping(rightComposedSchema);\n\n        MapKeyDiff<String, Schema> mappingDiff =\n            MapKeyDiff.diff(\n                getSchema(leftComponents, leftMapping, leftComposedSchema),\n                getSchema(rightComponents, rightMapping, rightComposedSchema));\n        Map<String, ChangedSchema> changedMapping = new LinkedHashMap<>();\n        for (String key : mappingDiff.getSharedKey()) {\n          Schema<?> leftSchema = new Schema<>();\n          leftSchema.set$ref(leftMapping.get(key));\n          Schema<?> rightSchema = new Schema<>();\n          rightSchema.set$ref(rightMapping.get(key));\n          discriminatorChangedBuilder\n              .with(\n                  openApiDiff\n                      .getSchemaDiff()\n                      .diff(refSet, leftSchema, rightSchema, context.copyWithRequired(true)))\n              .ifPresent(schema -> changedMapping.put(key, schema));\n        }\n\n        discriminatorChangedBuilder.whenSet(\n            composedSchemas ->\n                changedSchema.setOneOfSchema(\n                    new ChangedOneOfSchema(leftMapping, rightMapping, context)\n                        .setIncreased(mappingDiff.getIncreased())\n                        .setMissing(mappingDiff.getMissing())\n                        .setChanged(changedMapping)));\n      }\n\n      return discriminatorChangedBuilder\n          .build()\n          .flatMap(\n              values -> super.diff(refSet, leftComponents, rightComponents, left, right, context));\n    } else {\n      return openApiDiff.getSchemaDiff().getTypeChangedSchema(left, right, context);\n    }\n  }", "signature": "@Override\n  public <T extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      T left,\n      T right,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  private Map<String, Schema> getSchema(\n      Components components, Map<String, String> mapping, ComposedSchema composedSchema) {\n    Map<String, Schema> result = new LinkedHashMap<>();\n    mapping.forEach(\n        (key, value) -> result.put(key, refPointer.resolveRef(components, new Schema<>(), value)));\n\n    result.putAll(getUnnamedSchemas(composedSchema.getAllOf(), \"all-of\"));\n    result.putAll(getUnnamedSchemas(composedSchema.getOneOf(), \"one-of\"));\n    result.putAll(getUnnamedSchemas(composedSchema.getAnyOf(), \"any-of\"));\n    return result;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Map<String, Schema>", "classes": []}, "name": "getSchema", "params": [{"name": "components", "type": "Components"}, {"name": "mapping", "type": "Map<String, String>"}, {"name": "composedSchema", "type": "ComposedSchema"}], "body": "                                                                                         {\n    Map<String, Schema> result = new LinkedHashMap<>();\n    mapping.forEach(\n        (key, value) -> result.put(key, refPointer.resolveRef(components, new Schema<>(), value)));\n\n    result.putAll(getUnnamedSchemas(composedSchema.getAllOf(), \"all-of\"));\n    result.putAll(getUnnamedSchemas(composedSchema.getOneOf(), \"one-of\"));\n    result.putAll(getUnnamedSchemas(composedSchema.getAnyOf(), \"any-of\"));\n    return result;\n  }", "signature": "private Map<String, Schema> getSchema(\n      Components components, Map<String, String> mapping, ComposedSchema composedSchema)"}, {"syntax_pass": true, "original_string": "  private Map<String, String> getMapping(ComposedSchema composedSchema) {\n    Map<String, String> reverseMapping = new LinkedHashMap<>();\n    for (Schema<?> schema : composedSchema.getOneOf()) {\n      String ref = schema.get$ref();\n      if (ref == null) {\n        continue;\n      }\n      String schemaName = refPointer.getRefName(ref);\n      if (schemaName == null) {\n        throw new IllegalArgumentException(\"invalid schema: \" + ref);\n      }\n      reverseMapping.put(ref, schemaName);\n    }\n\n    if (composedSchema.getDiscriminator() != null\n        && composedSchema.getDiscriminator().getMapping() != null) {\n      for (String ref : composedSchema.getDiscriminator().getMapping().keySet()) {\n        reverseMapping.put(composedSchema.getDiscriminator().getMapping().get(ref), ref);\n      }\n    }\n\n    return reverseMapping.entrySet().stream()\n        .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Map<String, String>", "classes": []}, "name": "getMapping", "params": [{"name": "composedSchema", "type": "ComposedSchema"}], "body": "                                                                        {\n    Map<String, String> reverseMapping = new LinkedHashMap<>();\n    for (Schema<?> schema : composedSchema.getOneOf()) {\n      String ref = schema.get$ref();\n      if (ref == null) {\n        continue;\n      }\n      String schemaName = refPointer.getRefName(ref);\n      if (schemaName == null) {\n        throw new IllegalArgumentException(\"invalid schema: \" + ref);\n      }\n      reverseMapping.put(ref, schemaName);\n    }\n\n    if (composedSchema.getDiscriminator() != null\n        && composedSchema.getDiscriminator().getMapping() != null) {\n      for (String ref : composedSchema.getDiscriminator().getMapping().keySet()) {\n        reverseMapping.put(composedSchema.getDiscriminator().getMapping().get(ref), ref);\n      }\n    }\n\n    return reverseMapping.entrySet().stream()\n        .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\n  }", "signature": "private Map<String, String> getMapping(ComposedSchema composedSchema)"}, {"syntax_pass": true, "original_string": "  private Map<String, Schema> getUnnamedSchemas(List<Schema> schemas, String name) {\n    Map<String, Schema> result = new LinkedHashMap<>();\n\n    if (schemas == null) {\n      return result;\n    }\n\n    for (int i = 0; i < schemas.size(); i++) {\n      Schema<?> schema = schemas.get(i);\n\n      // If the ref is named, then we ignore it since getMapping will handle it.\n      if (schema.get$ref() != null) {\n        continue;\n      }\n\n      result.put(String.format(\"%s-%s\", name, i), schema);\n    }\n\n    return result;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Map<String, Schema>", "classes": []}, "name": "getUnnamedSchemas", "params": [{"name": "schemas", "type": "List<Schema>"}, {"name": "name", "type": "String"}], "body": "                                                                                   {\n    Map<String, Schema> result = new LinkedHashMap<>();\n\n    if (schemas == null) {\n      return result;\n    }\n\n    for (int i = 0; i < schemas.size(); i++) {\n      Schema<?> schema = schemas.get(i);\n\n      // If the ref is named, then we ignore it since getMapping will handle it.\n      if (schema.get$ref() != null) {\n        continue;\n      }\n\n      result.put(String.format(\"%s-%s\", name, i), schema);\n    }\n\n    return result;\n  }", "signature": "private Map<String, Schema> getUnnamedSchemas(List<Schema> schemas, String name)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/compare/schemadiffresult/SchemaDiffResult.java", "original_string": "package org.openapitools.openapidiff.core.compare.schemadiffresult;\n\nimport static java.util.Optional.ofNullable;\nimport static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;\n\nimport io.swagger.v3.oas.models.Components;\nimport io.swagger.v3.oas.models.media.Schema;\nimport java.util.*;\nimport org.openapitools.openapidiff.core.compare.ListDiff;\nimport org.openapitools.openapidiff.core.compare.MapKeyDiff;\nimport org.openapitools.openapidiff.core.compare.OpenApiDiff;\nimport org.openapitools.openapidiff.core.model.Change;\nimport org.openapitools.openapidiff.core.model.Changed;\nimport org.openapitools.openapidiff.core.model.ChangedSchema;\nimport org.openapitools.openapidiff.core.model.DiffContext;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;\nimport org.openapitools.openapidiff.core.model.deferred.DeferredChanged;\nimport org.openapitools.openapidiff.core.model.deferred.RecursiveSchemaSet;\nimport org.openapitools.openapidiff.core.model.schema.*;\n\npublic class SchemaDiffResult {\n  protected ChangedSchema changedSchema;\n  protected OpenApiDiff openApiDiff;\n\n  public SchemaDiffResult(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.changedSchema = new ChangedSchema();\n  }\n\n  public SchemaDiffResult(String type, OpenApiDiff openApiDiff) {\n    this(openApiDiff);\n    this.changedSchema.setType(type);\n  }\n\n  public <V extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      V left,\n      V right,\n      DiffContext context) {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedEnum<X> changedEnum =\n        ListDiff.diff(new ChangedEnum<>(left.getEnum(), right.getEnum(), context));\n    changedSchema\n        .setContext(context)\n        .setOldSchema(left)\n        .setNewSchema(right)\n        .setChangeDeprecated(\n            !Boolean.TRUE.equals(left.getDeprecated())\n                && Boolean.TRUE.equals(right.getDeprecated()))\n        .setChangeTitle(!Objects.equals(left.getTitle(), right.getTitle()))\n        .setRequired(\n            ListDiff.diff(new ChangedRequired(left.getRequired(), right.getRequired(), context)))\n        .setChangeDefault(!Objects.equals(left.getDefault(), right.getDefault()))\n        .setEnumeration(changedEnum)\n        .setChangeFormat(!Objects.equals(left.getFormat(), right.getFormat()))\n        .setReadOnly(new ChangedReadOnly(left.getReadOnly(), right.getReadOnly(), context))\n        .setWriteOnly(new ChangedWriteOnly(left.getWriteOnly(), right.getWriteOnly(), context))\n        .setMaxLength(new ChangedMaxLength(left.getMaxLength(), right.getMaxLength(), context))\n        .setNumericRange(\n            new ChangedNumericRange(\n                left.getMinimum(),\n                right.getMinimum(),\n                left.getMaximum(),\n                right.getMaximum(),\n                left.getExclusiveMinimum(),\n                right.getExclusiveMinimum(),\n                left.getExclusiveMaximum(),\n                right.getExclusiveMaximum(),\n                context));\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedSchema::setExtensions);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedSchema::setDescription);\n    Map<String, Schema> leftProperties = left.getProperties();\n    Map<String, Schema> rightProperties = right.getProperties();\n    MapKeyDiff<String, Schema> propertyDiff = MapKeyDiff.diff(leftProperties, rightProperties);\n    for (String key : propertyDiff.getSharedKey()) {\n      builder\n          .with(\n              openApiDiff\n                  .getSchemaDiff()\n                  .diff(\n                      refSet,\n                      leftProperties.get(key),\n                      rightProperties.get(key),\n                      required(context, key, right.getRequired())))\n          .ifPresent(\n              changedSchema1 -> changedSchema.getChangedProperties().put(key, changedSchema1));\n    }\n    compareAdditionalProperties(refSet, left, right, context, builder);\n    changedSchema\n        .getIncreasedProperties()\n        .putAll(filterProperties(Change.Type.ADDED, propertyDiff.getIncreased(), context));\n    changedSchema\n        .getMissingProperties()\n        .putAll(filterProperties(Change.Type.REMOVED, propertyDiff.getMissing(), context));\n    return builder.build().mapOptional(values -> isApplicable(context));\n  }\n\n  protected Optional<ChangedSchema> isApplicable(DiffContext context) {\n    if (changedSchema.getReadOnly().isUnchanged()\n        && changedSchema.getWriteOnly().isUnchanged()\n        && !isPropertyApplicable(changedSchema.getNewSchema(), context)) {\n      return Optional.empty();\n    }\n    return isChanged(changedSchema);\n  }\n\n  private Map<String, Schema<?>> filterProperties(\n      Change.Type type, Map<String, Schema> properties, DiffContext context) {\n    Map<String, Schema<?>> result = new LinkedHashMap<>();\n    for (Map.Entry<String, Schema> entry : properties.entrySet()) {\n      if (isPropertyApplicable(entry.getValue(), context)\n          && openApiDiff\n              .getExtensionsDiff()\n              .isParentApplicable(\n                  type,\n                  entry.getValue(),\n                  ofNullable(entry.getValue().getExtensions()).orElse(new LinkedHashMap<>()),\n                  context)) {\n        result.put(entry.getKey(), entry.getValue());\n      } else {\n        // Child property is not applicable, so required cannot be applied\n        changedSchema.getRequired().getIncreased().remove(entry.getKey());\n      }\n    }\n    return result;\n  }\n\n  private boolean isPropertyApplicable(Schema<?> schema, DiffContext context) {\n    return !(context.isResponse() && Boolean.TRUE.equals(schema.getWriteOnly()))\n        && !(context.isRequest() && Boolean.TRUE.equals(schema.getReadOnly()));\n  }\n\n  private DiffContext required(DiffContext context, String key, List<String> required) {\n    return context.copyWithRequired(required != null && required.contains(key));\n  }\n\n  private void compareAdditionalProperties(\n      RecursiveSchemaSet refSet,\n      Schema<?> leftSchema,\n      Schema<?> rightSchema,\n      DiffContext context,\n      DeferredBuilder<Changed> builder) {\n    Object left = leftSchema.getAdditionalProperties();\n    Object right = rightSchema.getAdditionalProperties();\n    if (left instanceof Schema || right instanceof Schema) {\n      Schema<?> leftAdditionalSchema = left instanceof Schema ? (Schema<?>) left : null;\n      Schema<?> rightAdditionalSchema = right instanceof Schema ? (Schema<?>) right : null;\n      ChangedSchema apChangedSchema =\n          new ChangedSchema()\n              .setContext(context)\n              .setOldSchema(leftAdditionalSchema)\n              .setNewSchema(rightAdditionalSchema);\n      if (left != null && right != null) {\n        DeferredChanged<ChangedSchema> addPropChangedSchemaOP =\n            openApiDiff\n                .getSchemaDiff()\n                .diff(\n                    refSet,\n                    leftAdditionalSchema,\n                    rightAdditionalSchema,\n                    context.copyWithRequired(false));\n        builder\n            .with(addPropChangedSchemaOP)\n            .whenSet(\n                optional -> {\n                  ChangedSchema apc = optional.orElse(apChangedSchema);\n                  isChanged(apc).ifPresent(changedSchema::setAddProp);\n                });\n      } else {\n        isChanged(apChangedSchema).ifPresent(changedSchema::setAddProp);\n      }\n    }\n  }\n\n  public ChangedSchema getChangedSchema() {\n    return this.changedSchema;\n  }\n\n  public OpenApiDiff getOpenApiDiff() {\n    return this.openApiDiff;\n  }\n}\n", "file_hash": "1832802ebbb51bb6f4aa67731045b40f17519d297398adbd126a915d1eda2efb", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.compare.schemadiffresult;", "import static java.util.Optional.ofNullable;", "import static org.openapitools.openapidiff.core.utils.ChangedUtils.isChanged;", "import io.swagger.v3.oas.models.Components;", "import io.swagger.v3.oas.models.media.Schema;", "import java.util.*;", "import org.openapitools.openapidiff.core.compare.ListDiff;", "import org.openapitools.openapidiff.core.compare.MapKeyDiff;", "import org.openapitools.openapidiff.core.compare.OpenApiDiff;", "import org.openapitools.openapidiff.core.model.Change;", "import org.openapitools.openapidiff.core.model.Changed;", "import org.openapitools.openapidiff.core.model.ChangedSchema;", "import org.openapitools.openapidiff.core.model.DiffContext;", "import org.openapitools.openapidiff.core.model.deferred.DeferredBuilder;", "import org.openapitools.openapidiff.core.model.deferred.DeferredChanged;", "import org.openapitools.openapidiff.core.model.deferred.RecursiveSchemaSet;", "import org.openapitools.openapidiff.core.model.schema.*;"], "methods": [], "classes": [{"original_string": "public class SchemaDiffResult {\n  protected ChangedSchema changedSchema;\n  protected OpenApiDiff openApiDiff;\n\n  public SchemaDiffResult(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.changedSchema = new ChangedSchema();\n  }\n\n  public SchemaDiffResult(String type, OpenApiDiff openApiDiff) {\n    this(openApiDiff);\n    this.changedSchema.setType(type);\n  }\n\n  public <V extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      V left,\n      V right,\n      DiffContext context) {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedEnum<X> changedEnum =\n        ListDiff.diff(new ChangedEnum<>(left.getEnum(), right.getEnum(), context));\n    changedSchema\n        .setContext(context)\n        .setOldSchema(left)\n        .setNewSchema(right)\n        .setChangeDeprecated(\n            !Boolean.TRUE.equals(left.getDeprecated())\n                && Boolean.TRUE.equals(right.getDeprecated()))\n        .setChangeTitle(!Objects.equals(left.getTitle(), right.getTitle()))\n        .setRequired(\n            ListDiff.diff(new ChangedRequired(left.getRequired(), right.getRequired(), context)))\n        .setChangeDefault(!Objects.equals(left.getDefault(), right.getDefault()))\n        .setEnumeration(changedEnum)\n        .setChangeFormat(!Objects.equals(left.getFormat(), right.getFormat()))\n        .setReadOnly(new ChangedReadOnly(left.getReadOnly(), right.getReadOnly(), context))\n        .setWriteOnly(new ChangedWriteOnly(left.getWriteOnly(), right.getWriteOnly(), context))\n        .setMaxLength(new ChangedMaxLength(left.getMaxLength(), right.getMaxLength(), context))\n        .setNumericRange(\n            new ChangedNumericRange(\n                left.getMinimum(),\n                right.getMinimum(),\n                left.getMaximum(),\n                right.getMaximum(),\n                left.getExclusiveMinimum(),\n                right.getExclusiveMinimum(),\n                left.getExclusiveMaximum(),\n                right.getExclusiveMaximum(),\n                context));\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedSchema::setExtensions);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedSchema::setDescription);\n    Map<String, Schema> leftProperties = left.getProperties();\n    Map<String, Schema> rightProperties = right.getProperties();\n    MapKeyDiff<String, Schema> propertyDiff = MapKeyDiff.diff(leftProperties, rightProperties);\n    for (String key : propertyDiff.getSharedKey()) {\n      builder\n          .with(\n              openApiDiff\n                  .getSchemaDiff()\n                  .diff(\n                      refSet,\n                      leftProperties.get(key),\n                      rightProperties.get(key),\n                      required(context, key, right.getRequired())))\n          .ifPresent(\n              changedSchema1 -> changedSchema.getChangedProperties().put(key, changedSchema1));\n    }\n    compareAdditionalProperties(refSet, left, right, context, builder);\n    changedSchema\n        .getIncreasedProperties()\n        .putAll(filterProperties(Change.Type.ADDED, propertyDiff.getIncreased(), context));\n    changedSchema\n        .getMissingProperties()\n        .putAll(filterProperties(Change.Type.REMOVED, propertyDiff.getMissing(), context));\n    return builder.build().mapOptional(values -> isApplicable(context));\n  }\n\n  protected Optional<ChangedSchema> isApplicable(DiffContext context) {\n    if (changedSchema.getReadOnly().isUnchanged()\n        && changedSchema.getWriteOnly().isUnchanged()\n        && !isPropertyApplicable(changedSchema.getNewSchema(), context)) {\n      return Optional.empty();\n    }\n    return isChanged(changedSchema);\n  }\n\n  private Map<String, Schema<?>> filterProperties(\n      Change.Type type, Map<String, Schema> properties, DiffContext context) {\n    Map<String, Schema<?>> result = new LinkedHashMap<>();\n    for (Map.Entry<String, Schema> entry : properties.entrySet()) {\n      if (isPropertyApplicable(entry.getValue(), context)\n          && openApiDiff\n              .getExtensionsDiff()\n              .isParentApplicable(\n                  type,\n                  entry.getValue(),\n                  ofNullable(entry.getValue().getExtensions()).orElse(new LinkedHashMap<>()),\n                  context)) {\n        result.put(entry.getKey(), entry.getValue());\n      } else {\n        // Child property is not applicable, so required cannot be applied\n        changedSchema.getRequired().getIncreased().remove(entry.getKey());\n      }\n    }\n    return result;\n  }\n\n  private boolean isPropertyApplicable(Schema<?> schema, DiffContext context) {\n    return !(context.isResponse() && Boolean.TRUE.equals(schema.getWriteOnly()))\n        && !(context.isRequest() && Boolean.TRUE.equals(schema.getReadOnly()));\n  }\n\n  private DiffContext required(DiffContext context, String key, List<String> required) {\n    return context.copyWithRequired(required != null && required.contains(key));\n  }\n\n  private void compareAdditionalProperties(\n      RecursiveSchemaSet refSet,\n      Schema<?> leftSchema,\n      Schema<?> rightSchema,\n      DiffContext context,\n      DeferredBuilder<Changed> builder) {\n    Object left = leftSchema.getAdditionalProperties();\n    Object right = rightSchema.getAdditionalProperties();\n    if (left instanceof Schema || right instanceof Schema) {\n      Schema<?> leftAdditionalSchema = left instanceof Schema ? (Schema<?>) left : null;\n      Schema<?> rightAdditionalSchema = right instanceof Schema ? (Schema<?>) right : null;\n      ChangedSchema apChangedSchema =\n          new ChangedSchema()\n              .setContext(context)\n              .setOldSchema(leftAdditionalSchema)\n              .setNewSchema(rightAdditionalSchema);\n      if (left != null && right != null) {\n        DeferredChanged<ChangedSchema> addPropChangedSchemaOP =\n            openApiDiff\n                .getSchemaDiff()\n                .diff(\n                    refSet,\n                    leftAdditionalSchema,\n                    rightAdditionalSchema,\n                    context.copyWithRequired(false));\n        builder\n            .with(addPropChangedSchemaOP)\n            .whenSet(\n                optional -> {\n                  ChangedSchema apc = optional.orElse(apChangedSchema);\n                  isChanged(apc).ifPresent(changedSchema::setAddProp);\n                });\n      } else {\n        isChanged(apChangedSchema).ifPresent(changedSchema::setAddProp);\n      }\n    }\n  }\n\n  public ChangedSchema getChangedSchema() {\n    return this.changedSchema;\n  }\n\n  public OpenApiDiff getOpenApiDiff() {\n    return this.openApiDiff;\n  }\n}", "definition": "public class SchemaDiffResult", "class_docstring": "", "name": "SchemaDiffResult", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "protected ChangedSchema changedSchema;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ChangedSchema", "name": "changedSchema", "syntax_pass": true}, {"attribute_expression": "protected OpenApiDiff openApiDiff;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "OpenApiDiff", "name": "openApiDiff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public SchemaDiffResult(OpenApiDiff openApiDiff) {\n    this.openApiDiff = openApiDiff;\n    this.changedSchema = new ChangedSchema();\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SchemaDiffResult", "params": [{"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                   {\n    this.openApiDiff = openApiDiff;\n    this.changedSchema = new ChangedSchema();\n  }", "signature": "public SchemaDiffResult(OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public SchemaDiffResult(String type, OpenApiDiff openApiDiff) {\n    this(openApiDiff);\n    this.changedSchema.setType(type);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SchemaDiffResult", "params": [{"name": "type", "type": "String"}, {"name": "openApiDiff", "type": "OpenApiDiff"}], "body": "                                                                {\n    this(openApiDiff);\n    this.changedSchema.setType(type);\n  }", "signature": "public SchemaDiffResult(String type, OpenApiDiff openApiDiff)"}, {"syntax_pass": true, "original_string": "  public <V extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      V left,\n      V right,\n      DiffContext context) {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedEnum<X> changedEnum =\n        ListDiff.diff(new ChangedEnum<>(left.getEnum(), right.getEnum(), context));\n    changedSchema\n        .setContext(context)\n        .setOldSchema(left)\n        .setNewSchema(right)\n        .setChangeDeprecated(\n            !Boolean.TRUE.equals(left.getDeprecated())\n                && Boolean.TRUE.equals(right.getDeprecated()))\n        .setChangeTitle(!Objects.equals(left.getTitle(), right.getTitle()))\n        .setRequired(\n            ListDiff.diff(new ChangedRequired(left.getRequired(), right.getRequired(), context)))\n        .setChangeDefault(!Objects.equals(left.getDefault(), right.getDefault()))\n        .setEnumeration(changedEnum)\n        .setChangeFormat(!Objects.equals(left.getFormat(), right.getFormat()))\n        .setReadOnly(new ChangedReadOnly(left.getReadOnly(), right.getReadOnly(), context))\n        .setWriteOnly(new ChangedWriteOnly(left.getWriteOnly(), right.getWriteOnly(), context))\n        .setMaxLength(new ChangedMaxLength(left.getMaxLength(), right.getMaxLength(), context))\n        .setNumericRange(\n            new ChangedNumericRange(\n                left.getMinimum(),\n                right.getMinimum(),\n                left.getMaximum(),\n                right.getMaximum(),\n                left.getExclusiveMinimum(),\n                right.getExclusiveMinimum(),\n                left.getExclusiveMaximum(),\n                right.getExclusiveMaximum(),\n                context));\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedSchema::setExtensions);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedSchema::setDescription);\n    Map<String, Schema> leftProperties = left.getProperties();\n    Map<String, Schema> rightProperties = right.getProperties();\n    MapKeyDiff<String, Schema> propertyDiff = MapKeyDiff.diff(leftProperties, rightProperties);\n    for (String key : propertyDiff.getSharedKey()) {\n      builder\n          .with(\n              openApiDiff\n                  .getSchemaDiff()\n                  .diff(\n                      refSet,\n                      leftProperties.get(key),\n                      rightProperties.get(key),\n                      required(context, key, right.getRequired())))\n          .ifPresent(\n              changedSchema1 -> changedSchema.getChangedProperties().put(key, changedSchema1));\n    }\n    compareAdditionalProperties(refSet, left, right, context, builder);\n    changedSchema\n        .getIncreasedProperties()\n        .putAll(filterProperties(Change.Type.ADDED, propertyDiff.getIncreased(), context));\n    changedSchema\n        .getMissingProperties()\n        .putAll(filterProperties(Change.Type.REMOVED, propertyDiff.getMissing(), context));\n    return builder.build().mapOptional(values -> isApplicable(context));\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeferredChanged<ChangedSchema>", "classes": []}, "name": "diff", "params": [{"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "leftComponents", "type": "Components"}, {"name": "rightComponents", "type": "Components"}, {"name": "left", "type": "V"}, {"name": "right", "type": "V"}, {"name": "context", "type": "DiffContext"}], "body": "                           {\n\n    DeferredBuilder<Changed> builder = new DeferredBuilder<>();\n\n    ChangedEnum<X> changedEnum =\n        ListDiff.diff(new ChangedEnum<>(left.getEnum(), right.getEnum(), context));\n    changedSchema\n        .setContext(context)\n        .setOldSchema(left)\n        .setNewSchema(right)\n        .setChangeDeprecated(\n            !Boolean.TRUE.equals(left.getDeprecated())\n                && Boolean.TRUE.equals(right.getDeprecated()))\n        .setChangeTitle(!Objects.equals(left.getTitle(), right.getTitle()))\n        .setRequired(\n            ListDiff.diff(new ChangedRequired(left.getRequired(), right.getRequired(), context)))\n        .setChangeDefault(!Objects.equals(left.getDefault(), right.getDefault()))\n        .setEnumeration(changedEnum)\n        .setChangeFormat(!Objects.equals(left.getFormat(), right.getFormat()))\n        .setReadOnly(new ChangedReadOnly(left.getReadOnly(), right.getReadOnly(), context))\n        .setWriteOnly(new ChangedWriteOnly(left.getWriteOnly(), right.getWriteOnly(), context))\n        .setMaxLength(new ChangedMaxLength(left.getMaxLength(), right.getMaxLength(), context))\n        .setNumericRange(\n            new ChangedNumericRange(\n                left.getMinimum(),\n                right.getMinimum(),\n                left.getMaximum(),\n                right.getMaximum(),\n                left.getExclusiveMinimum(),\n                right.getExclusiveMinimum(),\n                left.getExclusiveMaximum(),\n                right.getExclusiveMaximum(),\n                context));\n    builder\n        .with(\n            openApiDiff\n                .getExtensionsDiff()\n                .diff(left.getExtensions(), right.getExtensions(), context))\n        .ifPresent(changedSchema::setExtensions);\n    builder\n        .with(\n            openApiDiff\n                .getMetadataDiff()\n                .diff(left.getDescription(), right.getDescription(), context))\n        .ifPresent(changedSchema::setDescription);\n    Map<String, Schema> leftProperties = left.getProperties();\n    Map<String, Schema> rightProperties = right.getProperties();\n    MapKeyDiff<String, Schema> propertyDiff = MapKeyDiff.diff(leftProperties, rightProperties);\n    for (String key : propertyDiff.getSharedKey()) {\n      builder\n          .with(\n              openApiDiff\n                  .getSchemaDiff()\n                  .diff(\n                      refSet,\n                      leftProperties.get(key),\n                      rightProperties.get(key),\n                      required(context, key, right.getRequired())))\n          .ifPresent(\n              changedSchema1 -> changedSchema.getChangedProperties().put(key, changedSchema1));\n    }\n    compareAdditionalProperties(refSet, left, right, context, builder);\n    changedSchema\n        .getIncreasedProperties()\n        .putAll(filterProperties(Change.Type.ADDED, propertyDiff.getIncreased(), context));\n    changedSchema\n        .getMissingProperties()\n        .putAll(filterProperties(Change.Type.REMOVED, propertyDiff.getMissing(), context));\n    return builder.build().mapOptional(values -> isApplicable(context));\n  }", "signature": "public <V extends Schema<X>, X> DeferredChanged<ChangedSchema> diff(\n      RecursiveSchemaSet refSet,\n      Components leftComponents,\n      Components rightComponents,\n      V left,\n      V right,\n      DiffContext context)"}, {"syntax_pass": true, "original_string": "  protected Optional<ChangedSchema> isApplicable(DiffContext context) {\n    if (changedSchema.getReadOnly().isUnchanged()\n        && changedSchema.getWriteOnly().isUnchanged()\n        && !isPropertyApplicable(changedSchema.getNewSchema(), context)) {\n      return Optional.empty();\n    }\n    return isChanged(changedSchema);\n  }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Optional<ChangedSchema>", "classes": []}, "name": "isApplicable", "params": [{"name": "context", "type": "DiffContext"}], "body": "                                                                      {\n    if (changedSchema.getReadOnly().isUnchanged()\n        && changedSchema.getWriteOnly().isUnchanged()\n        && !isPropertyApplicable(changedSchema.getNewSchema(), context)) {\n      return Optional.empty();\n    }\n    return isChanged(changedSchema);\n  }", "signature": "protected Optional<ChangedSchema> isApplicable(DiffContext context)"}, {"syntax_pass": true, "original_string": "  private Map<String, Schema<?>> filterProperties(\n      Change.Type type, Map<String, Schema> properties, DiffContext context) {\n    Map<String, Schema<?>> result = new LinkedHashMap<>();\n    for (Map.Entry<String, Schema> entry : properties.entrySet()) {\n      if (isPropertyApplicable(entry.getValue(), context)\n          && openApiDiff\n              .getExtensionsDiff()\n              .isParentApplicable(\n                  type,\n                  entry.getValue(),\n                  ofNullable(entry.getValue().getExtensions()).orElse(new LinkedHashMap<>()),\n                  context)) {\n        result.put(entry.getKey(), entry.getValue());\n      } else {\n        // Child property is not applicable, so required cannot be applied\n        changedSchema.getRequired().getIncreased().remove(entry.getKey());\n      }\n    }\n    return result;\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Map<String, Schema<?>>", "classes": []}, "name": "filterProperties", "params": [{"name": "type", "type": "Change.Type"}, {"name": "properties", "type": "Map<String, Schema>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                             {\n    Map<String, Schema<?>> result = new LinkedHashMap<>();\n    for (Map.Entry<String, Schema> entry : properties.entrySet()) {\n      if (isPropertyApplicable(entry.getValue(), context)\n          && openApiDiff\n              .getExtensionsDiff()\n              .isParentApplicable(\n                  type,\n                  entry.getValue(),\n                  ofNullable(entry.getValue().getExtensions()).orElse(new LinkedHashMap<>()),\n                  context)) {\n        result.put(entry.getKey(), entry.getValue());\n      } else {\n        // Child property is not applicable, so required cannot be applied\n        changedSchema.getRequired().getIncreased().remove(entry.getKey());\n      }\n    }\n    return result;\n  }", "signature": "private Map<String, Schema<?>> filterProperties(\n      Change.Type type, Map<String, Schema> properties, DiffContext context)"}, {"syntax_pass": true, "original_string": "  private boolean isPropertyApplicable(Schema<?> schema, DiffContext context) {\n    return !(context.isResponse() && Boolean.TRUE.equals(schema.getWriteOnly()))\n        && !(context.isRequest() && Boolean.TRUE.equals(schema.getReadOnly()));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPropertyApplicable", "params": [{"name": "schema", "type": "Schema<?>"}, {"name": "context", "type": "DiffContext"}], "body": "                                                                              {\n    return !(context.isResponse() && Boolean.TRUE.equals(schema.getWriteOnly()))\n        && !(context.isRequest() && Boolean.TRUE.equals(schema.getReadOnly()));\n  }", "signature": "private boolean isPropertyApplicable(Schema<?> schema, DiffContext context)"}, {"syntax_pass": true, "original_string": "  private DiffContext required(DiffContext context, String key, List<String> required) {\n    return context.copyWithRequired(required != null && required.contains(key));\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DiffContext", "classes": []}, "name": "required", "params": [{"name": "context", "type": "DiffContext"}, {"name": "key", "type": "String"}, {"name": "required", "type": "List<String>"}], "body": "                                                                                       {\n    return context.copyWithRequired(required != null && required.contains(key));\n  }", "signature": "private DiffContext required(DiffContext context, String key, List<String> required)"}, {"syntax_pass": true, "original_string": "  private void compareAdditionalProperties(\n      RecursiveSchemaSet refSet,\n      Schema<?> leftSchema,\n      Schema<?> rightSchema,\n      DiffContext context,\n      DeferredBuilder<Changed> builder) {\n    Object left = leftSchema.getAdditionalProperties();\n    Object right = rightSchema.getAdditionalProperties();\n    if (left instanceof Schema || right instanceof Schema) {\n      Schema<?> leftAdditionalSchema = left instanceof Schema ? (Schema<?>) left : null;\n      Schema<?> rightAdditionalSchema = right instanceof Schema ? (Schema<?>) right : null;\n      ChangedSchema apChangedSchema =\n          new ChangedSchema()\n              .setContext(context)\n              .setOldSchema(leftAdditionalSchema)\n              .setNewSchema(rightAdditionalSchema);\n      if (left != null && right != null) {\n        DeferredChanged<ChangedSchema> addPropChangedSchemaOP =\n            openApiDiff\n                .getSchemaDiff()\n                .diff(\n                    refSet,\n                    leftAdditionalSchema,\n                    rightAdditionalSchema,\n                    context.copyWithRequired(false));\n        builder\n            .with(addPropChangedSchemaOP)\n            .whenSet(\n                optional -> {\n                  ChangedSchema apc = optional.orElse(apChangedSchema);\n                  isChanged(apc).ifPresent(changedSchema::setAddProp);\n                });\n      } else {\n        isChanged(apChangedSchema).ifPresent(changedSchema::setAddProp);\n      }\n    }\n  }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "compareAdditionalProperties", "params": [{"name": "refSet", "type": "RecursiveSchemaSet"}, {"name": "leftSchema", "type": "Schema<?>"}, {"name": "rightSchema", "type": "Schema<?>"}, {"name": "context", "type": "DiffContext"}, {"name": "builder", "type": "DeferredBuilder<Changed>"}], "body": "                                        {\n    Object left = leftSchema.getAdditionalProperties();\n    Object right = rightSchema.getAdditionalProperties();\n    if (left instanceof Schema || right instanceof Schema) {\n      Schema<?> leftAdditionalSchema = left instanceof Schema ? (Schema<?>) left : null;\n      Schema<?> rightAdditionalSchema = right instanceof Schema ? (Schema<?>) right : null;\n      ChangedSchema apChangedSchema =\n          new ChangedSchema()\n              .setContext(context)\n              .setOldSchema(leftAdditionalSchema)\n              .setNewSchema(rightAdditionalSchema);\n      if (left != null && right != null) {\n        DeferredChanged<ChangedSchema> addPropChangedSchemaOP =\n            openApiDiff\n                .getSchemaDiff()\n                .diff(\n                    refSet,\n                    leftAdditionalSchema,\n                    rightAdditionalSchema,\n                    context.copyWithRequired(false));\n        builder\n            .with(addPropChangedSchemaOP)\n            .whenSet(\n                optional -> {\n                  ChangedSchema apc = optional.orElse(apChangedSchema);\n                  isChanged(apc).ifPresent(changedSchema::setAddProp);\n                });\n      } else {\n        isChanged(apChangedSchema).ifPresent(changedSchema::setAddProp);\n      }\n    }\n  }", "signature": "private void compareAdditionalProperties(\n      RecursiveSchemaSet refSet,\n      Schema<?> leftSchema,\n      Schema<?> rightSchema,\n      DiffContext context,\n      DeferredBuilder<Changed> builder)"}, {"syntax_pass": true, "original_string": "  public ChangedSchema getChangedSchema() {\n    return this.changedSchema;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChangedSchema", "classes": []}, "name": "getChangedSchema", "params": [], "body": "                                          {\n    return this.changedSchema;\n  }", "signature": "public ChangedSchema getChangedSchema()"}, {"syntax_pass": true, "original_string": "  public OpenApiDiff getOpenApiDiff() {\n    return this.openApiDiff;\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OpenApiDiff", "classes": []}, "name": "getOpenApiDiff", "params": [], "body": "                                      {\n    return this.openApiDiff;\n  }", "signature": "public OpenApiDiff getOpenApiDiff()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/openapitools/openapidiff/core/exception/RendererException.java", "original_string": "package org.openapitools.openapidiff.core.exception;\n\npublic class RendererException extends RuntimeException {\n\n  public RendererException(Throwable cause) {\n    super(cause);\n  }\n\n  public RendererException(String message, Throwable cause) {\n    super(message, cause);\n  }\n}\n", "file_hash": "6c19e888535b44a2ee2e7c06a14cab7be5924d4f9e75c94cb77ead53558085e7", "file_docstring": "", "contexts": ["package org.openapitools.openapidiff.core.exception;"], "methods": [], "classes": [{"original_string": "public class RendererException extends RuntimeException {\n\n  public RendererException(Throwable cause) {\n    super(cause);\n  }\n\n  public RendererException(String message, Throwable cause) {\n    super(message, cause);\n  }\n}", "definition": "public class RendererException extends RuntimeException", "class_docstring": "", "name": "RendererException", "super_interfaces": [], "superclasses": "RuntimeException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "  public RendererException(Throwable cause) {\n    super(cause);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "RendererException", "params": [{"name": "cause", "type": "Throwable"}], "body": "                                            {\n    super(cause);\n  }", "signature": "public RendererException(Throwable cause)"}, {"syntax_pass": true, "original_string": "  public RendererException(String message, Throwable cause) {\n    super(message, cause);\n  }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "RendererException", "params": [{"name": "message", "type": "String"}, {"name": "cause", "type": "Throwable"}], "body": "                                                            {\n    super(message, cause);\n  }", "signature": "public RendererException(String message, Throwable cause)"}]}], "interfaces": [], "records": []}]