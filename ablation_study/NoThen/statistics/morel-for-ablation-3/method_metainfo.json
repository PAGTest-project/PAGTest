[{"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[Fixture]fixture()", "name": "fixture", "arg_nums": 0, "params": [], "return_type": "Fixture", "signature": "static Fixture fixture()", "original_string": "  static Fixture fixture() {\n    return new FixtureImpl(Fixture.DEFAULT_ARG_LIST, \"?\", false, new File(\"\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Fixture", "classes": []}, "docstring": " Creates a Fixture."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]pauseForTenMilliseconds()", "name": "pauseForTenMilliseconds", "arg_nums": 0, "params": [], "return_type": "void", "signature": "static void pauseForTenMilliseconds()", "original_string": "  static void pauseForTenMilliseconds() {\n    try {\n      Thread.sleep(10);\n    } catch (InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]assumeNotInCi()", "name": "assumeNotInCi", "arg_nums": 0, "params": [], "return_type": "void", "signature": "static void assumeNotInCi()", "original_string": "  static void assumeNotInCi() {\n    final String ci = System.getProperty(\"morel.ci\");\n    assumeTrue(ci == null\n            || ci.equalsIgnoreCase(\"false\")\n            || ci.equals(\"0\"),\n        \"test skipped during CI (morel.ci is \" + ci + \")\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Throws \"assumption failed\" if the environment variable 'morel.ci'\nis set and is not 0 or false. Allows us to skip tests that are\nnon-deterministic when run in GitHub actions or Travis CI."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[File]getUseDirectory()", "name": "getUseDirectory", "arg_nums": 0, "params": [], "return_type": "File", "signature": "static File getUseDirectory()", "original_string": "  static File getUseDirectory() {\n    final File rootDirectory = findDirectory();\n    return new File(rootDirectory, \"use\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "File", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[Matcher<String>]is2(String)", "name": "is2", "arg_nums": 1, "params": [{"name": "expected", "type": "String"}], "return_type": "Matcher<String>", "signature": "private Matcher<String> is2(String expected)", "original_string": "  private Matcher<String> is2(String expected) {\n    return anyOf(is(expected),\n        is(expected.replace(\"\\u001B[?2004l\", \"\")));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Matcher<String>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[]Matchers()", "name": "Matchers", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Matchers()", "original_string": "  private Matchers() {}", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Ast.Literal>]isLiteral(Comparable,String)", "name": "isLiteral", "arg_nums": 2, "params": [{"name": "comparable", "type": "Comparable"}, {"name": "ml", "type": "String"}], "return_type": "Matcher<Ast.Literal>", "signature": "@SuppressWarnings(\"rawtypes\")\n  static Matcher<Ast.Literal> isLiteral(Comparable comparable, String ml)", "original_string": "  @SuppressWarnings(\"rawtypes\")\n  static Matcher<Ast.Literal> isLiteral(Comparable comparable, String ml) {\n    return new TypeSafeMatcher<Ast.Literal>() {\n      protected boolean matchesSafely(Ast.Literal literal) {\n        final String actualMl = literal.toString();\n        return literal.value.equals(comparable)\n            && actualMl.equals(ml);\n      }\n\n      public void describeTo(Description description) {\n        description.appendText(\"literal with value \" + comparable\n            + \" and ML \" + ml);\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "@SuppressWarnings(\"rawtypes\")\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "static"], "comments": [], "return_type": "Matcher<Ast.Literal>", "classes": []}, "docstring": " Matches a literal by value."}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<AstNode>]isAst(boolean,String)", "name": "isAst", "arg_nums": 2, "params": [{"name": "parenthesize", "type": "boolean"}, {"name": "expected", "type": "String"}], "return_type": "Matcher<AstNode>", "signature": "static Matcher<AstNode> isAst(boolean parenthesize, String expected)", "original_string": "  static Matcher<AstNode> isAst(boolean parenthesize, String expected) {\n    return isAst(AstNode.class, parenthesize, expected);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<AstNode>", "classes": []}, "docstring": " Matches an AST node by its string representation."}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<T>]isAst(Class<? extends T>,boolean,String)", "name": "isAst", "arg_nums": 3, "params": [{"name": "clazz", "type": "Class<? extends T>"}, {"name": "parenthesize", "type": "boolean"}, {"name": "expected", "type": "String"}], "return_type": "Matcher<T>", "signature": "static <T extends AstNode> Matcher<T> isAst(Class<? extends T> clazz,\n      boolean parenthesize, String expected)", "original_string": "  static <T extends AstNode> Matcher<T> isAst(Class<? extends T> clazz,\n      boolean parenthesize, String expected) {\n    return new CustomTypeSafeMatcher<T>(\"ast with value [\" + expected + \"]\") {\n      protected boolean matchesSafely(T t) {\n        assertThat(clazz.isInstance(t), is(true));\n        final String s =\n            stringValue(t);\n        return s.equals(expected);\n      }\n\n      private String stringValue(T t) {\n        return t.unparse(new AstWriter().withParenthesize(parenthesize));\n      }\n\n      @Override protected void describeMismatchSafely(T item,\n          Description description) {\n        description.appendText(\"was \").appendValue(stringValue(item));\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<T>", "classes": []}, "docstring": " Matches an AST node by its string representation."}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Code>]isCode(String)", "name": "isCode", "arg_nums": 1, "params": [{"name": "expected", "type": "String"}], "return_type": "Matcher<Code>", "signature": "static Matcher<Code> isCode(String expected)", "original_string": "  static Matcher<Code> isCode(String expected) {\n    return new CustomTypeSafeMatcher<Code>(\"code \" + expected) {\n      @Override protected boolean matchesSafely(Code code) {\n        final String plan = Codes.describe(code);\n        return plan.equals(expected);\n      }\n\n      @Override protected void describeMismatchSafely(Code code,\n          Description description) {\n        final String plan = Codes.describe(code);\n        description.appendText(\"was \").appendValue(plan);\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Code>", "classes": []}, "docstring": " Matches a Code node by its string representation."}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Code>]isCode2(String)", "name": "isCode2", "arg_nums": 1, "params": [{"name": "expected", "type": "String"}], "return_type": "Matcher<Code>", "signature": "static Matcher<Code> isCode2(String expected)", "original_string": "  static Matcher<Code> isCode2(String expected) {\n    final String expected0 = PATTERN0.matcher(expected).replaceAll(\"(\");\n    final String expected1 = PATTERN1.matcher(expected0).replaceAll(\" \");\n    return isCode(expected1);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Code>", "classes": []}, "docstring": " Matches a Code node by its string representation,\nremoving spaces that occur after newlines."}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Code>]isFullyCalcite()", "name": "isFullyCalcite", "arg_nums": 0, "params": [], "return_type": "Matcher<Code>", "signature": "static Matcher<Code> isFullyCalcite()", "original_string": "  static Matcher<Code> isFullyCalcite() {\n    return new CustomTypeSafeMatcher<Code>(\"code is all Calcite\") {\n      protected boolean matchesSafely(Code code) {\n        final String plan = Codes.describe(code);\n        return plan.startsWith(\"calcite(\") // instanceof CalciteCode\n            && !plan.contains(\"morelScalar\")\n            && !plan.contains(\"morelTable\");\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Code>", "classes": []}, "docstring": " Matches a Code if it is wholly within Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[List<Object>]list()", "name": "list", "arg_nums": 0, "params": [], "return_type": "List<Object>", "signature": "static List<Object> list(Object... values)", "original_string": "  static List<Object> list(Object... values) {\n    return Arrays.asList(values);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "List<Object>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Map<Object, Object>]map()", "name": "map", "arg_nums": 0, "params": [], "return_type": "Map<Object, Object>", "signature": "static Map<Object, Object> map(Object... keyValues)", "original_string": "  static Map<Object, Object> map(Object... keyValues) {\n    final LinkedHashMap<Object, Object> map = new LinkedHashMap<>();\n    for (int i = 0; i < keyValues.length / 2; i++) {\n      map.put(keyValues[i * 2], keyValues[i * 2 + 1]);\n    }\n    return map;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Map<Object, Object>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Iterable<E>>]equalsUnordered()", "name": "equalsUnordered", "arg_nums": 0, "params": [], "return_type": "Matcher<Iterable<E>>", "signature": "@SafeVarargs\n  static <E> Matcher<Iterable<E>> equalsUnordered(E... elements)", "original_string": "  @SafeVarargs\n  static <E> Matcher<Iterable<E>> equalsUnordered(E... elements) {\n    final Set<E> expectedSet = Sets.newHashSet(elements);\n    return new TypeSafeMatcher<Iterable<E>>() {\n      protected boolean matchesSafely(Iterable<E> item) {\n        //noinspection rawtypes\n        return Sets.newHashSet((Iterable) item).equals(expectedSet);\n      }\n\n      public void describeTo(Description description) {\n        description.appendText(\"equalsUnordered\").appendValue(expectedSet);\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "@SafeVarargs\n  static", "marker_annotations": ["@SafeVarargs"], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Iterable<E>>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Iterable<E>>]equalsOrdered()", "name": "equalsOrdered", "arg_nums": 0, "params": [], "return_type": "Matcher<Iterable<E>>", "signature": "@SafeVarargs\n  static <E> Matcher<Iterable<E>> equalsOrdered(E... elements)", "original_string": "  @SafeVarargs\n  static <E> Matcher<Iterable<E>> equalsOrdered(E... elements) {\n    final List<E> expectedList = Arrays.asList(elements);\n    return new TypeSafeMatcher<Iterable<E>>() {\n      protected boolean matchesSafely(Iterable<E> item) {\n        return Lists.newArrayList(item).equals(expectedList);\n      }\n\n      public void describeTo(Description description) {\n        description.appendText(\"equalsOrdered\").appendValue(expectedList);\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "@SafeVarargs\n  static", "marker_annotations": ["@SafeVarargs"], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Iterable<E>>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<E>]isUnordered(E)", "name": "isUnordered", "arg_nums": 1, "params": [{"name": "expected", "type": "E"}], "return_type": "Matcher<E>", "signature": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  static <E> Matcher<E> isUnordered(E expected)", "original_string": "  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  static <E> Matcher<E> isUnordered(E expected) {\n    final E expectedMultiset = expected instanceof Iterable\n        ? (E) ImmutableMultiset.copyOf((Iterable) expected)\n        : expected;\n    return new TypeSafeMatcher<E>() {\n      @Override public void describeTo(Description description) {\n        description.appendText(\"equalsOrdered\").appendValue(expectedMultiset);\n      }\n\n      @Override protected boolean matchesSafely(E actual) {\n        final E actualMultiset = expectedMultiset instanceof Multiset\n            && actual instanceof Iterable\n            && !(actual instanceof Multiset)\n            ? (E) ImmutableMultiset.copyOf((Iterable) actual)\n            : actual;\n        return expectedMultiset.equals(actualMultiset);\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings({\"unchecked\", \"rawtypes\"})", "static"], "comments": [], "return_type": "Matcher<E>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Throwable>]throwsA(String)", "name": "throwsA", "arg_nums": 1, "params": [{"name": "message", "type": "String"}], "return_type": "Matcher<Throwable>", "signature": "static Matcher<Throwable> throwsA(String message)", "original_string": "  static Matcher<Throwable> throwsA(String message) {\n    return new CustomTypeSafeMatcher<Throwable>(\"throwable: \" + message) {\n      @Override protected boolean matchesSafely(Throwable item) {\n        return item.toString().contains(message);\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Throwable>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Throwable>]throwsA(String,Pos)", "name": "throwsA", "arg_nums": 2, "params": [{"name": "message", "type": "String"}, {"name": "position", "type": "Pos"}], "return_type": "Matcher<Throwable>", "signature": "static Matcher<Throwable> throwsA(String message, Pos position)", "original_string": "  static Matcher<Throwable> throwsA(String message, Pos position) {\n    return throwsA(Throwable.class, message, position);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Throwable>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<T>]throwsA(Class<T>,String,Pos)", "name": "throwsA", "arg_nums": 3, "params": [{"name": "clazz", "type": "Class<T>"}, {"name": "message", "type": "String"}, {"name": "position", "type": "Pos"}], "return_type": "Matcher<T>", "signature": "static <T extends Throwable> Matcher<T> throwsA(Class<T> clazz,\n      String message, Pos position)", "original_string": "  static <T extends Throwable> Matcher<T> throwsA(Class<T> clazz,\n      String message, Pos position) {\n    requireNonNull(clazz, \"clazz\");\n    requireNonNull(message, \"message\");\n    requireNonNull(position, \"position\");\n    return new TypeSafeMatcher<T>(clazz) {\n      @Override public void describeTo(Description description) {\n        description.appendText(\"throwable [\" + message\n            + \"] at position [\" + position + \"]\");\n      }\n\n      @Override protected boolean matchesSafely(Throwable item) {\n        return item.toString().contains(message)\n            && Objects.equals(positionString(item), position.toString());\n      }\n\n      @Nullable String positionString(Throwable e) {\n        if (e instanceof MorelException) {\n          return ((MorelException) e).pos()\n              .describeTo(new StringBuilder()).toString();\n        }\n        return null;\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<T>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<T>]throwsA(Class<T>,String)", "name": "throwsA", "arg_nums": 2, "params": [{"name": "clazz", "type": "Class<T>"}, {"name": "message", "type": "String"}], "return_type": "Matcher<T>", "signature": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  static <T extends Throwable> Matcher<T> throwsA(Class<T> clazz,\n      String message)", "original_string": "  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  static <T extends Throwable> Matcher<T> throwsA(Class<T> clazz,\n      String message) {\n    return (Matcher) throwsA(clazz, is(message));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings({\"unchecked\", \"rawtypes\"})", "static"], "comments": [], "return_type": "Matcher<T>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Throwable>]throwsA(Class<T>,Matcher<?>)", "name": "throwsA", "arg_nums": 2, "params": [{"name": "clazz", "type": "Class<T>"}, {"name": "messageMatcher", "type": "Matcher<?>"}], "return_type": "Matcher<Throwable>", "signature": "static <T extends Throwable> Matcher<Throwable> throwsA(Class<T> clazz,\n      Matcher<?> messageMatcher)", "original_string": "  static <T extends Throwable> Matcher<Throwable> throwsA(Class<T> clazz,\n      Matcher<?> messageMatcher) {\n    return new TypeSafeMatcher<Throwable>(clazz) {\n      @Override public void describeTo(Description description) {\n        description.appendText(clazz + \" with message \")\n            .appendDescriptionOf(messageMatcher);\n      }\n\n      @Override protected boolean matchesSafely(Throwable item) {\n        return clazz.isInstance(item)\n            && messageMatcher.matches(item.getMessage());\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Throwable>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[LearningMatcher<T>]learning(Class<T>)", "name": "learning", "arg_nums": 1, "params": [{"name": "type", "type": "Class<T>"}], "return_type": "LearningMatcher<T>", "signature": "public static <T> LearningMatcher<T> learning(Class<T> type)", "original_string": "  public static <T> LearningMatcher<T> learning(Class<T> type) {\n    return new LearningMatcherImpl<>(Is.isA(type));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "LearningMatcher<T>", "classes": []}, "docstring": " Creates a Matcher that behaves the same as a given delegate Matcher,\nbut remembers the value that was compared.\n\n@param <T> Type of expected item"}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Object>]whenAppliedTo(Object,Matcher<Object>)", "name": "whenAppliedTo", "arg_nums": 2, "params": [{"name": "arg", "type": "Object"}, {"name": "resultMatcher", "type": "Matcher<Object>"}], "return_type": "Matcher<Object>", "signature": "static Matcher<Object> whenAppliedTo(Object arg,\n      Matcher<Object> resultMatcher)", "original_string": "  static Matcher<Object> whenAppliedTo(Object arg,\n      Matcher<Object> resultMatcher) {\n    return new CallingMatcher(arg, resultMatcher);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Object>", "classes": []}, "docstring": " Creates a Matcher that matches an Applicable, calls it with the given\nargument, and checks the result."}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<Type>]hasMoniker(String)", "name": "hasMoniker", "arg_nums": 1, "params": [{"name": "expectedMoniker", "type": "String"}], "return_type": "Matcher<Type>", "signature": "static Matcher<Type> hasMoniker(String expectedMoniker)", "original_string": "  static Matcher<Type> hasMoniker(String expectedMoniker) {\n    return new CustomTypeSafeMatcher<Type>(\"type with moniker [\"\n        + expectedMoniker + \"]\") {\n      @Override protected boolean matchesSafely(Type type) {\n        return type.moniker().equals(expectedMoniker);\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<Type>", "classes": []}, "docstring": " Creates a Matcher that matches a Type based on {@link Type#moniker()}."}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<DataType>]hasTypeConstructors(String)", "name": "hasTypeConstructors", "arg_nums": 1, "params": [{"name": "expected", "type": "String"}], "return_type": "Matcher<DataType>", "signature": "static Matcher<DataType> hasTypeConstructors(String expected)", "original_string": "  static Matcher<DataType> hasTypeConstructors(String expected) {\n    return new CustomTypeSafeMatcher<DataType>(\"datatype with constructors \"\n        + expected) {\n      @Override protected boolean matchesSafely(DataType type) {\n        return type.typeConstructors.toString().equals(expected);\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<DataType>", "classes": []}, "docstring": " Creates a Matcher that matches a {@link DataType} with given type\nconstructors."}, {"uris": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers.[Matcher<T>]instanceOfAnd(Class<T2>,Matcher<T2>)", "name": "instanceOfAnd", "arg_nums": 2, "params": [{"name": "expectedClass", "type": "Class<T2>"}, {"name": "matcher", "type": "Matcher<T2>"}], "return_type": "Matcher<T>", "signature": "static <T, T2 extends T> Matcher<T> instanceOfAnd(Class<T2> expectedClass,\n      Matcher<T2> matcher)", "original_string": "  static <T, T2 extends T> Matcher<T> instanceOfAnd(Class<T2> expectedClass,\n      Matcher<T2> matcher) {\n    return new TypeSafeDiagnosingMatcher<T>() {\n      @Override protected boolean matchesSafely(T item,\n          Description mismatchDescription) {\n        if (!expectedClass.isInstance(item)) {\n          mismatchDescription.appendText(\"expected instance of \" + expectedClass\n              + \" but was \" + item + \" (a \" + item.getClass() + \")\");\n          return false;\n        }\n        if (!matcher.matches(item)) {\n          matcher.describeMismatch(item, mismatchDescription);\n          return false;\n        }\n        return true;\n      }\n\n      @Override public void describeTo(Description description) {\n        description.appendText(\"instance of \" + expectedClass + \" and \");\n        matcher.describeTo(description);\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Matchers.java", "class_name": "Matchers", "class_uri": "src/test/java/net/hydromatic/morel/Matchers.java.Matchers", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Matcher<T>", "classes": []}, "docstring": " Creates a Matcher that tests for a sub-class and then makes another\ntest.\n\n@param <T> Value type\n@param <T2> Required subtype"}, {"uris": "src/test/java/net/hydromatic/morel/LintTest.java.LintTest.[Puffin.Program<GlobalState>]makeProgram()", "name": "makeProgram", "arg_nums": 0, "params": [], "return_type": "Puffin.Program<GlobalState>", "signature": "@SuppressWarnings(\"Convert2MethodRef\") // JDK 8 requires lambdas\n  private Puffin.Program<GlobalState> makeProgram()", "original_string": "  @SuppressWarnings(\"Convert2MethodRef\") // JDK 8 requires lambdas\n  private Puffin.Program<GlobalState> makeProgram() {\n    return Puffin.builder(GlobalState::new, global -> new FileState(global))\n        .add(line -> line.isLast(),\n            line -> {\n              String f = line.filename();\n              final int slash = f.lastIndexOf('/');\n              final String endMarker =\n                  \"// End \" + (slash < 0 ? f : f.substring(slash + 1));\n              if (!line.line().equals(endMarker)\n                  && line.filename().endsWith(\".java\")) {\n                line.state().message(\"File must end with '\" + endMarker + \"'\",\n                    line);\n              }\n            })\n        .add(line -> line.fnr() == 1,\n            line -> line.globalState().fileCount++)\n\n        // Trailing space\n        .add(line -> line.endsWith(\" \"),\n            line -> line.state().message(\"Trailing space\", line))\n\n        // Tab\n        .add(line -> line.contains(\"\\t\"),\n            line -> line.state().message(\"Tab\", line))\n\n        // Nullable\n        .add(line -> line.startsWith(\"import javax.annotation.Nullable;\"),\n            line -> line.state().message(\n                \"use org.checkerframework.checker.nullness.qual.Nullable\",\n                line))\n\n        // Nonnull\n        .add(line -> line.startsWith(\"import javax.annotation.Nonnull;\"),\n            line -> line.state().message(\n                \"use org.checkerframework.checker.nullness.qual.NonNull\",\n                line))\n\n        // Use of 'Static.' other than in an import.\n        .add(line -> (line.contains(\"Assertions.\")\n                || line.contains(\"CoreMatchers.\")\n                || line.contains(\"MatcherAssert.assertThat\")\n                || line.contains(\"Objects.requireNonNull\")\n                || line.contains(\"Ord.forEachIndexed\")\n                || line.contains(\"Pair.forEach\")\n                || line.contains(\"Preconditions.\")\n                || line.contains(\"Static.\"))\n                && line.filename().endsWith(\".java\")\n                && !line.startsWith(\"import static\")\n                && !line.matches(\"^ *// .*$\")\n                && !line.endsWith(\"// lint:skip\")\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"LintTest.java\")).isPresent()\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"UtilTest.java\")).isPresent(),\n            line -> line.state().message(\"should be static import\", line))\n\n        // In a test,\n        //   assertThat(x.toString(), is(y));\n        // should be\n        //   assertThat(x, hasToString(y)));\n        .add(line -> line.contains(\".toString(), is(\")\n                && line.filename().endsWith(\".java\")\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"LintTest.java\")).isPresent(),\n            line -> line.state().message(\"use 'Matchers.hasToString'\", line))\n\n        // Comment without space\n        .add(line -> line.matches(\".* //[^ ].*\")\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"LintTest.java\")).isPresent()\n                && !line.contains(\"//--\")\n                && !line.contains(\"//~\")\n                && !line.contains(\"//noinspection\")\n                && !line.contains(\"//CHECKSTYLE\"),\n            line -> line.state().message(\"'//' must be followed by ' '\", line))\n\n        // Javadoc does not require '</p>', so we do not allow '</p>'\n        .add(line -> line.state().inJavadoc()\n                && line.contains(\"</p>\"),\n            line -> line.state().message(\"no '</p>'\", line))\n\n        // No \"**/\"\n        .add(line -> line.contains(\" **/\")\n                && line.state().inJavadoc(),\n            line ->\n                line.state().message(\"no '**/'; use '*/'\",\n                    line))\n\n        // A Javadoc paragraph '<p>' must not be on its own line.\n        .add(line -> line.matches(\"^ *\\\\* <p>\"),\n            line ->\n                line.state().message(\"<p> must not be on its own line\",\n                    line))\n\n        // A Javadoc paragraph '<p>' must be preceded by a blank Javadoc\n        // line.\n        .add(line -> line.matches(\"^ *\\\\*\"),\n            line -> {\n              final FileState f = line.state();\n              if (f.starLine == line.fnr() - 1) {\n                f.message(\"duplicate empty line in javadoc\", line);\n              }\n              f.starLine = line.fnr();\n            })\n        .add(line -> line.matches(\"^ *\\\\* <p>.*\")\n                && line.fnr() - 1 != line.state().starLine,\n            line ->\n                line.state().message(\"<p> must be preceded by blank line\",\n                    line))\n\n        // A non-blank line following a blank line must have a '<p>'\n        .add(line -> line.state().inJavadoc()\n                && line.state().ulCount == 0\n                && line.state().blockquoteCount == 0\n                && line.contains(\"* \")\n                && line.fnr() - 1 == line.state().starLine\n                && line.matches(\"^ *\\\\* [^<@].*\"),\n            line -> line.state().message(\"missing '<p>'\", line))\n\n        // The first \"@param\" of a javadoc block must be preceded by a blank\n        // line.\n        .add(line -> line.matches(\"^ */\\\\*\\\\*.*\"),\n            line -> {\n              final FileState f = line.state();\n              f.javadocStartLine = line.fnr();\n              f.blockquoteCount = 0;\n              f.ulCount = 0;\n            })\n        .add(line -> line.matches(\".*\\\\*/\"),\n            line -> line.state().javadocEndLine = line.fnr())\n        .add(line -> line.matches(\"^ *\\\\* @.*\"),\n            line -> {\n              if (line.state().inJavadoc()\n                  && line.state().atLine < line.state().javadocStartLine\n                  && line.fnr() - 1 != line.state().starLine) {\n                line.state().message(\n                    \"First @tag must be preceded by blank line\",\n                    line);\n              }\n              line.state().atLine = line.fnr();\n            })\n        .add(line -> line.contains(\"<blockquote>\"),\n            line -> line.state().blockquoteCount++)\n        .add(line -> line.contains(\"</blockquote>\"),\n            line -> line.state().blockquoteCount--)\n        .add(line -> line.contains(\"<ul>\"),\n            line -> line.state().ulCount++)\n        .add(line -> line.contains(\"</ul>\"),\n            line -> line.state().ulCount--)\n        .build();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/LintTest.java", "class_name": "LintTest", "class_uri": "src/test/java/net/hydromatic/morel/LintTest.java.LintTest", "attributes": {"modifiers": "@SuppressWarnings(\"Convert2MethodRef\") // JDK 8 requires lambdas\n  private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"Convert2MethodRef\")", "private"], "comments": ["// JDK 8 requires lambdas"], "return_type": "Puffin.Program<GlobalState>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]checkShorterThan(Iterable<E>,int)", "name": "checkShorterThan", "arg_nums": 2, "params": [{"name": "iterable", "type": "Iterable<E>"}, {"name": "size", "type": "int"}], "return_type": "void", "signature": "private <E> void checkShorterThan(Iterable<E> iterable, int size)", "original_string": "  private <E> void checkShorterThan(Iterable<E> iterable, int size) {\n    assertThat(Static.shorterThan(iterable, -1), is(size < -1));\n    assertThat(Static.shorterThan(iterable, 0), is(size < 0));\n    assertThat(Static.shorterThan(iterable, 1), is(size < 1));\n    assertThat(Static.shorterThan(iterable, 2), is(size < 2));\n    assertThat(Static.shorterThan(iterable, 3), is(size < 3));\n    assertThat(Static.shorterThan(iterable, 4), is(size < 4));\n    assertThat(Static.shorterThan(iterable, 1_000_000), is(size < 1_000_000));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier]createUnifier()", "name": "createUnifier", "arg_nums": 0, "params": [], "return_type": "Unifier", "signature": "protected abstract Unifier createUnifier()", "original_string": "  protected abstract Unifier createUnifier();", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "Unifier", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]arrow(Unifier.Term,Unifier.Term)", "name": "arrow", "arg_nums": 2, "params": [{"name": "t0", "type": "Unifier.Term"}, {"name": "t1", "type": "Unifier.Term"}], "return_type": "Unifier.Sequence", "signature": "Unifier.Sequence arrow(Unifier.Term t0, Unifier.Term t1)", "original_string": "  Unifier.Sequence arrow(Unifier.Term t0, Unifier.Term t1) {\n    return unifier.apply(\"->\", t0, t1);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]a()", "name": "a", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "Unifier.Sequence a(Unifier.Term... terms)", "original_string": "  Unifier.Sequence a(Unifier.Term... terms) {\n    return unifier.apply(\"a\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]b()", "name": "b", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "Unifier.Sequence b(Unifier.Term... terms)", "original_string": "  Unifier.Sequence b(Unifier.Term... terms) {\n    return unifier.apply(\"b\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]c()", "name": "c", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence c(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence c(Unifier.Term... terms) {\n    return unifier.apply(\"c\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]d()", "name": "d", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence d(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence d(Unifier.Term... terms) {\n    return unifier.apply(\"d\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]f()", "name": "f", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence f(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence f(Unifier.Term... terms) {\n    return unifier.apply(\"f\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]g()", "name": "g", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence g(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence g(Unifier.Term... terms) {\n    return unifier.apply(\"g\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]h()", "name": "h", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence h(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence h(Unifier.Term... terms) {\n    return unifier.apply(\"h\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]p()", "name": "p", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence p(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence p(Unifier.Term... terms) {\n    return unifier.apply(\"p\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]bill()", "name": "bill", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence bill(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence bill(Unifier.Term... terms) {\n    return unifier.apply(\"bill\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]bob()", "name": "bob", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence bob(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence bob(Unifier.Term... terms) {\n    return unifier.apply(\"bob\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]john()", "name": "john", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence john(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence john(Unifier.Term... terms) {\n    return unifier.apply(\"john\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]tom()", "name": "tom", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence tom(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence tom(Unifier.Term... terms) {\n    return unifier.apply(\"tom\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]father()", "name": "father", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence father(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence father(Unifier.Term... terms) {\n    return unifier.apply(\"father\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]mother()", "name": "mother", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence mother(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence mother(Unifier.Term... terms) {\n    return unifier.apply(\"mother\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]parents()", "name": "parents", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence parents(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence parents(Unifier.Term... terms) {\n    return unifier.apply(\"parents\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]parent()", "name": "parent", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence parent(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence parent(Unifier.Term... terms) {\n    return unifier.apply(\"parent\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]grandParent()", "name": "grandParent", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence grandParent(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence grandParent(Unifier.Term... terms) {\n    return unifier.apply(\"grandParent\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]connected()", "name": "connected", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence connected(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence connected(Unifier.Term... terms) {\n    return unifier.apply(\"connected\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[Unifier.Sequence]part()", "name": "part", "arg_nums": 0, "params": [], "return_type": "Unifier.Sequence", "signature": "private Unifier.Sequence part(Unifier.Term... terms)", "original_string": "  private Unifier.Sequence part(Unifier.Term... terms) {\n    return unifier.apply(\"part\", terms);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Sequence", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]assertThatUnify(Unifier.Term,Unifier.Term,Matcher<String>)", "name": "assertThatUnify", "arg_nums": 3, "params": [{"name": "e1", "type": "Unifier.Term"}, {"name": "e2", "type": "Unifier.Term"}, {"name": "matcher", "type": "Matcher<String>"}], "return_type": "void", "signature": "void assertThatUnify(Unifier.Term e1, Unifier.Term e2,\n      Matcher<String> matcher)", "original_string": "  void assertThatUnify(Unifier.Term e1, Unifier.Term e2,\n      Matcher<String> matcher) {\n    assertThatUnify(termPairs(e1, e2), matcher);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]assertThatUnify(List<Unifier.TermTerm>,Matcher<String>)", "name": "assertThatUnify", "arg_nums": 2, "params": [{"name": "termPairs", "type": "List<Unifier.TermTerm>"}, {"name": "matcher", "type": "Matcher<String>"}], "return_type": "void", "signature": "void assertThatUnify(List<Unifier.TermTerm> termPairs,\n      Matcher<String> matcher)", "original_string": "  void assertThatUnify(List<Unifier.TermTerm> termPairs,\n      Matcher<String> matcher) {\n    final Unifier.Result result =\n        unifier.unify(termPairs, ImmutableMap.of(), Tracers.nullTracer());\n    assertThat(result, notNullValue());\n    assertThat(result instanceof Unifier.Substitution, is(true));\n    assertThat(((Unifier.Substitution) result).resolve().toString(), matcher);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]assertThatCannotUnify(Unifier.Term,Unifier.Term)", "name": "assertThatCannotUnify", "arg_nums": 2, "params": [{"name": "e1", "type": "Unifier.Term"}, {"name": "e2", "type": "Unifier.Term"}], "return_type": "void", "signature": "void assertThatCannotUnify(Unifier.Term e1, Unifier.Term e2)", "original_string": "  void assertThatCannotUnify(Unifier.Term e1, Unifier.Term e2) {\n    assertThatCannotUnify(termPairs(e1, e2));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[List<Unifier.TermTerm>]termPairs()", "name": "termPairs", "arg_nums": 0, "params": [], "return_type": "List<Unifier.TermTerm>", "signature": "List<Unifier.TermTerm> termPairs(Unifier.Term... terms)", "original_string": "  List<Unifier.TermTerm> termPairs(Unifier.Term... terms) {\n    assert terms.length % 2 == 0;\n    final ImmutableList.Builder<Unifier.TermTerm> pairs =\n        ImmutableList.builder();\n    for (int i = 0; i < terms.length; i += 2) {\n      pairs.add(new Unifier.TermTerm(terms[i], terms[i + 1]));\n    }\n    return pairs.build();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Unifier.TermTerm>", "classes": []}, "docstring": " Given [a, b, c, d], returns [(a, b), (c, d)]."}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]assertThatCannotUnify(List<Unifier.TermTerm>)", "name": "assertThatCannotUnify", "arg_nums": 1, "params": [{"name": "pairList", "type": "List<Unifier.TermTerm>"}], "return_type": "void", "signature": "void assertThatCannotUnify(List<Unifier.TermTerm> pairList)", "original_string": "  void assertThatCannotUnify(List<Unifier.TermTerm> pairList) {\n    final Unifier.Result result =\n        unifier.unify(pairList, ImmutableMap.of(), Tracers.nullTracer());\n    assertThat(result, not(instanceOf(Unifier.Substitution.class)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[]ScriptTest()", "name": "ScriptTest", "arg_nums": 0, "params": [], "return_type": "", "signature": "public ScriptTest()", "original_string": "  public ScriptTest() {\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ScriptTest.java", "class_name": "ScriptTest", "class_uri": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "  public static void main(String[] args) throws Exception {\n    for (String arg : args) {\n      new ScriptTest().test(arg);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ScriptTest.java", "class_name": "ScriptTest", "class_uri": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Runs a test from the command line.\n\n<p>For example:\n\n<blockquote>\n  <code>java ScriptTest script/table.sml</code>\n</blockquote>"}, {"uris": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[Stream<Arguments>]data()", "name": "data", "arg_nums": 0, "params": [], "return_type": "Stream<Arguments>", "signature": "@SuppressWarnings(\"unused\")\n  static Stream<Arguments> data()", "original_string": "  @SuppressWarnings(\"unused\")\n  static Stream<Arguments> data() {\n    // Start with a test file we know exists, then find the directory and list\n    // its files.\n    final String first = \"script/simple.smli\";\n    return data_(first);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ScriptTest.java", "class_name": "ScriptTest", "class_uri": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "docstring": " For {@link ParameterizedTest} runner."}, {"uris": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[Method]findMethod(String)", "name": "findMethod", "arg_nums": 1, "params": [{"name": "path", "type": "String"}], "return_type": "Method", "signature": "private Method findMethod(String path)", "original_string": "  private Method findMethod(String path) {\n    // E.g. path \"script/simple.sml\" gives method \"testScriptSimple\"\n    String methodName = toCamelCase(\"test_\"\n        + path.replace(File.separatorChar, '_').replaceAll(\"\\\\.sml$\", \"\"));\n    Method m;\n    try {\n      m = getClass().getMethod(methodName);\n    } catch (NoSuchMethodException e) {\n      m = null;\n    }\n    return m;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ScriptTest.java", "class_name": "ScriptTest", "class_uri": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Method", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[void]checkRun(String)", "name": "checkRun", "arg_nums": 1, "params": [{"name": "path", "type": "String"}], "return_type": "void", "signature": "protected void checkRun(String path)", "original_string": "  protected void checkRun(String path) throws Exception {\n    final File inFile;\n    final File outFile;\n    final File f = new File(path);\n    final boolean idempotent = path.endsWith(\".smli\");\n    if (f.isAbsolute()) {\n      // e.g. path = \"/tmp/foo.sml\"\n      inFile = f;\n      outFile = new File(path + \".out\");\n    } else {\n      // e.g. path = \"sql/outer.sml\"\n      // inUrl = \"file:/home/fred/morel/target/test-classes/script/outer.sml\"\n      final URL inUrl = MainTest.class.getResource(\"/\" + n2u(path));\n      assertThat(inUrl, notNullValue());\n      inFile = urlToFile(inUrl);\n      assertThat(inFile, notNullValue());\n      String outPath = idempotent ? path : path + \".out\";\n      outFile =\n          new File(inFile.getAbsoluteFile().getParent(),\n              u2n(\"surefire/\") + outPath);\n    }\n    TestUtils.discard(outFile.getParentFile().mkdirs());\n    final List<String> argList = ImmutableList.of(\"--echo\");\n    final File scriptDirectory = inFile.getParentFile();\n    final boolean loadDictionary =\n        inFile.getPath()\n            .matches(\".*/(blog|dummy|foreign|hybrid|suchThat)\\\\.(sml|smli)\");\n    final Map<String, ForeignValue> dictionary =\n        loadDictionary\n            ? Calcite.withDataSets(BuiltInDataSet.DICTIONARY).foreignValues()\n            : ImmutableMap.of();\n\n    final Map<Prop, Object> propMap = new LinkedHashMap<>();\n    File directory = scriptDirectory;\n    for (File d = scriptDirectory; d != null; d = d.getParentFile()) {\n      if (d.getName().equals(\"script\")) {\n        directory = d.getParentFile();\n        break;\n      }\n    }\n    // For the \"file.smli\" test, move to a subdirectory; it's more predictable\n    if (inFile.getPath().matches(\".*/(file)\\\\.(sml|smli)\")) {\n      directory = new File(directory, \"data\");\n    }\n    Prop.DIRECTORY.set(propMap, directory);\n    Prop.SCRIPT_DIRECTORY.set(propMap, scriptDirectory);\n\n    try (Reader reader = TestUtils.reader(inFile);\n         Writer writer = TestUtils.printWriter(outFile)) {\n      Main main =\n          new Main(argList, reader, writer, dictionary, propMap, idempotent);\n      main.run();\n    }\n    final String inName =\n        idempotent ? inFile.getName() : inFile.getName() + \".out\";\n    final File refFile = new File(inFile.getParentFile(), inName);\n    if (!refFile.exists()) {\n      System.out.println(\"Reference file not found: \" + refFile);\n    }\n    final String diff = TestUtils.diff(refFile, outFile);\n    if (!diff.isEmpty()) {\n      fail(\"Files differ: \" + refFile + \" \" + outFile + \"\\n\"\n          + diff);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ScriptTest.java", "class_name": "ScriptTest", "class_uri": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[Stream<Arguments>]data_(String)", "name": "data_", "arg_nums": 1, "params": [{"name": "first", "type": "String"}], "return_type": "Stream<Arguments>", "signature": "@SuppressWarnings(\"SameParameterValue\")\n  protected static Stream<Arguments> data_(String first)", "original_string": "  @SuppressWarnings(\"SameParameterValue\")\n  protected static Stream<Arguments> data_(String first) {\n    // inUrl = \"file:/home/fred/morel/target/test-classes/script/agg.sml\"\n    final URL inUrl = MainTest.class.getResource(\"/\" + n2u(first));\n    assertThat(inUrl, notNullValue());\n    final File firstFile = urlToFile(inUrl);\n    assertThat(firstFile, notNullValue());\n    final int commonPrefixLength =\n        firstFile.getAbsolutePath().length() - first.length();\n    final File dir = firstFile.getParentFile();\n    @SuppressWarnings(\"UnstableApiUsage\") final FilenameFilter filter =\n        new PatternFilenameFilter(\".*\\\\.(sml|smli)$\");\n    File[] files = dir.listFiles(filter);\n    return Stream.of(first(files, new File[0]))\n        .map(f ->\n            Arguments.of(f.getAbsolutePath().substring(commonPrefixLength)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ScriptTest.java", "class_name": "ScriptTest", "class_uri": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest", "attributes": {"modifiers": "@SuppressWarnings(\"SameParameterValue\")\n  protected static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"SameParameterValue\")", "protected", "static"], "comments": [], "return_type": "Stream<Arguments>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MorelTests.java.MorelTests.[]MorelTests()", "name": "MorelTests", "arg_nums": 0, "params": [], "return_type": "", "signature": "private MorelTests()", "original_string": "  private MorelTests() {}", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MorelTests.java", "class_name": "MorelTests", "class_uri": "src/test/java/net/hydromatic/morel/MorelTests.java.MorelTests", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MorelTests.java.MorelTests.[void]abandon(String)", "name": "abandon", "arg_nums": 1, "params": [{"name": "message", "type": "String"}], "return_type": "void", "signature": "@SuppressWarnings(\"ConstantConditions\")\n  public static void abandon(String message)", "original_string": "  @SuppressWarnings(\"ConstantConditions\")\n  public static void abandon(String message) {\n    assumeTrue(false, message);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MorelTests.java", "class_name": "MorelTests", "class_uri": "src/test/java/net/hydromatic/morel/MorelTests.java.MorelTests", "attributes": {"modifiers": "@SuppressWarnings(\"ConstantConditions\")\n  public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"ConstantConditions\")", "public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Aborts the test with a given message.\nUse this method if you want to abandon a test case half way through.\nThe test will \"succeed\", because this is an {@link Assumptions} failure.\n\n@param message Message\n"}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]checkFullCalcite(String)", "name": "checkFullCalcite", "arg_nums": 1, "params": [{"name": "ml", "type": "String"}], "return_type": "void", "signature": "private void checkFullCalcite(String ml)", "original_string": "  private void checkFullCalcite(String ml) {\n    String plan = \"calcite(plan \"\n        + \"LogicalProject(d5=[+($1, 5)], deptno=[$1], empno=[$2])\\n\"\n        + \"  LogicalFilter(condition=[<($2, 7500)])\\n\"\n        + \"    LogicalProject(comm=[$6], deptno=[$7], empno=[$0], ename=[$1], \"\n        + \"hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"{d5:int, deptno:int, empno:int} list\")\n        .assertEvalIter(equalsOrdered(list(25, 20, 7369), list(35, 30, 7499)))\n        .assertPlan(isCode(plan));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]checkCalciteWithVariable(int,String)", "name": "checkCalciteWithVariable", "arg_nums": 2, "params": [{"name": "inlinePassCount", "type": "int"}, {"name": "plan", "type": "String"}], "return_type": "void", "signature": "private void checkCalciteWithVariable(int inlinePassCount, String plan)", "original_string": "  private void checkCalciteWithVariable(int inlinePassCount, String plan) {\n    final String ml = \"let\\n\"\n        + \"  val five = 2 + 3\\n\"\n        + \"  val ten = five + five\\n\"\n        + \"in\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.empno < 7500 + ten\\n\"\n        + \"  yield {e.empno, e.deptno, d5 = e.deptno + five}\\n\"\n        + \"end\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .with(Prop.INLINE_PASS_COUNT, inlinePassCount)\n        .assertType(\"{d5:int, deptno:int, empno:int} list\")\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(list(25, 20, 7369), list(35, 30, 7499)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[List<Object>]leaf(Object)", "name": "leaf", "arg_nums": 1, "params": [{"name": "arg", "type": "Object"}], "return_type": "List<Object>", "signature": "private static List<Object> leaf(Object arg)", "original_string": "  private static List<Object> leaf(Object arg) {\n    return list(\"LEAF\", arg);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Object>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[List<Object>]node()", "name": "node", "arg_nums": 0, "params": [], "return_type": "List<Object>", "signature": "private static List<Object> node(Object... args)", "original_string": "  private static List<Object> node(Object... args) {\n    return list(\"NODE\", list(args));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Object>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]checkInlineChained(int)", "name": "checkInlineChained", "arg_nums": 1, "params": [{"name": "n", "type": "int"}], "return_type": "void", "signature": "private void checkInlineChained(int n)", "original_string": "  private void checkInlineChained(int n) {\n    final String ml = \"fun f x0 =\\n\"\n        + gen(1, n);\n    final int expected = n * (n + 1) / 2;\n    ml(ml).assertEval(Matchers.whenAppliedTo(0, is(expected)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Checks that a nested expression of depth {@code n} gives the right\nanswer and completes in a reasonable time."}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[String]gen(int,int)", "name": "gen", "arg_nums": 2, "params": [{"name": "i", "type": "int"}, {"name": "n", "type": "int"}], "return_type": "String", "signature": "private String gen(int i, int n)", "original_string": "  private String gen(int i, int n) {\n    if (i == n) {\n      return v(i - 1) + \" + \" + i;\n    } else {\n      return \" let val \" + v(i) + \" = \" + v(i - 1) + \" + \" + i + \" in\\n\"\n          + gen(i + 1, n) + \"\\n\"\n          + \"end\\n\";\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Generates a deeply nested expression,\nsuch as\n\n<pre>{@code\nfun f x0 =\n  let val x1 = x0 + 1 in\n     let val x2 = x1 + 2 in\n       ...\n          xN + (N + 1)\n       ...\n     end\n   end\n}</pre>\n\n<p>Such an expression is a challenge for the inliner, because x0 is\ninlined into x1, x1 is inlined into x2, and so forth. If done wrong, the\nalgorithm is exponential.\n"}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[String]v(int)", "name": "v", "arg_nums": 1, "params": [{"name": "i", "type": "int"}], "return_type": "String", "signature": "private String v(int i)", "original_string": "  private String v(int i) {\n    return \"x\" + i;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Returns a variable name such as \"x1\"."}, {"uris": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[int]runAppProcess(List<String>,File,Logger,Reader,Writer)", "name": "runAppProcess", "arg_nums": 5, "params": [{"name": "argumentList", "type": "List<String>"}, {"name": "directory", "type": "File"}, {"name": "logger", "type": "Logger"}, {"name": "appInput", "type": "Reader"}, {"name": "appOutput", "type": "Writer"}], "return_type": "int", "signature": "public static int runAppProcess(List<String> argumentList, File directory,\n      @Nullable Logger logger, @Nullable Reader appInput,\n      @Nullable Writer appOutput)", "original_string": "  public static int runAppProcess(List<String> argumentList, File directory,\n      @Nullable Logger logger, @Nullable Reader appInput,\n      @Nullable Writer appOutput) throws IOException, InterruptedException {\n\n    // WARNING: ProcessBuilder is security-sensitive. Its use is currently\n    // safe because this code is under \"core/test\". Developers must not move\n    // this code into \"core/main\".\n    final ProcessBuilder pb = new ProcessBuilder(argumentList);\n    pb.directory(directory);\n    pb.redirectErrorStream(true);\n    if (logger != null) {\n      logger.info(\"start process: \" + pb.command());\n    }\n    Process p = pb.start();\n\n    // Setup the input/output streams to the subprocess.\n    // The buffering here is arbitrary. Javadocs strongly encourage\n    // buffering, but the size needed is very dependent on the\n    // specific application being run, the size of the input\n    // provided by the caller, and the amount of output expected.\n    // Since this method is currently used only by unit tests,\n    // large-ish fixed buffer sizes have been chosen. If this\n    // method becomes used for something in production, it might\n    // be better to have the caller provide them as arguments.\n    if (appInput != null) {\n      OutputStream out =\n          new BufferedOutputStream(\n              p.getOutputStream(),\n              100 * 1024);\n      int c;\n      while ((c = appInput.read()) != -1) {\n        out.write(c);\n      }\n      out.flush();\n    }\n    if (appOutput != null) {\n      InputStream in =\n          new BufferedInputStream(\n              p.getInputStream(),\n              100 * 1024);\n      int c;\n      while ((c = in.read()) != -1) {\n        appOutput.write(c);\n      }\n      appOutput.flush();\n      in.close();\n    }\n    p.waitFor();\n\n    int status = p.exitValue();\n    if (logger != null) {\n      logger.info(\"exit status=\" + status + \" from \" + pb.command());\n    }\n    return status;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUnsafe.java", "class_name": "TestUnsafe", "class_uri": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nRuns an external application process.\n\n@param argumentList  command name and its arguments\n@param directory  working directory\n@param logger    if not null, command and exit status will be logged here\n@param appInput  if not null, data will be copied to application's stdin\n@param appOutput if not null, data will be captured from application's\n                 stdout and stderr\n@return application process exit value\n"}, {"uris": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[boolean]haveGit()", "name": "haveGit", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public static boolean haveGit()", "original_string": "  public static boolean haveGit() {\n    // Is there a '.git' directory? If not, we may be in a source tree\n    // unzipped from a tarball.\n    final File base = TestUtil.getBaseDir(TestUnsafe.class);\n    final File gitDir = new File(base, \".git\");\n    if (!gitDir.exists()\n        || !gitDir.isDirectory()\n        || !gitDir.canRead()) {\n      return false;\n    }\n\n    // Execute a simple git command. If it fails, we're probably not in a\n    // valid git environment.\n    final List<String> argumentList =\n        ImmutableList.of(\"git\", \"--version\");\n    try {\n      final StringWriter sw = new StringWriter();\n      int status =\n          runAppProcess(argumentList, base, null, null, sw);\n      final String s = sw.toString();\n      if (status != 0) {\n        return false;\n      }\n    } catch (Exception e) {\n      return false;\n    }\n    return true;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUnsafe.java", "class_name": "TestUnsafe", "class_uri": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether we seem are in a valid environment."}, {"uris": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[List<File>]getJavaFiles()", "name": "getJavaFiles", "arg_nums": 0, "params": [], "return_type": "List<File>", "signature": "public static List<File> getJavaFiles()", "original_string": "  public static List<File> getJavaFiles() {\n    return getGitFiles(\"*.java\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUnsafe.java", "class_name": "TestUnsafe", "class_uri": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<File>", "classes": []}, "docstring": " Returns a list of Java files in git."}, {"uris": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[List<File>]getTextFiles()", "name": "getTextFiles", "arg_nums": 0, "params": [], "return_type": "List<File>", "signature": "public static List<File> getTextFiles()", "original_string": "  public static List<File> getTextFiles() {\n    return getGitFiles(\"*.java\", \"*.jj\", \"*.md\", \"*.properties\",\n        \"*.sh\", \"*.sml\", \"*.smli\", \"*.txt\", \"*.xml\", \"*.yml\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUnsafe.java", "class_name": "TestUnsafe", "class_uri": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<File>", "classes": []}, "docstring": " Returns a list of text files in git."}, {"uris": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[List<File>]getGitFiles()", "name": "getGitFiles", "arg_nums": 0, "params": [], "return_type": "List<File>", "signature": "public static List<File> getGitFiles(String... patterns)", "original_string": "  public static List<File> getGitFiles(String... patterns) {\n    String s;\n    try {\n      final List<String> argumentList =\n          ImmutableList.<String>builder().add(\"git\").add(\"ls-files\")\n              .add(patterns).build();\n      final File base = TestUtil.getBaseDir(TestUnsafe.class);\n      try {\n        final StringWriter sw = new StringWriter();\n        int status =\n            runAppProcess(argumentList, base, null, null, sw);\n        if (status != 0) {\n          throw new RuntimeException(\"command \" + argumentList\n              + \": exited with status \" + status);\n        }\n        s = sw.toString();\n      } catch (Exception e) {\n        throw new RuntimeException(\"command \" + argumentList\n            + \": failed with exception\", e);\n      }\n\n      final ImmutableList.Builder<File> files = ImmutableList.builder();\n      try (StringReader r = new StringReader(s);\n           BufferedReader br = new BufferedReader(r)) {\n        for (;;) {\n          String line = br.readLine();\n          if (line == null) {\n            break;\n          }\n          files.add(new File(base, line));\n        }\n      }\n      return files.build();\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUnsafe.java", "class_name": "TestUnsafe", "class_uri": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<File>", "classes": []}, "docstring": " Returns a list of files in git matching a given pattern or patterns.\n\n<p>Assumes running Linux or macOS, and that git is available."}, {"uris": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe.[void]getCommitMessages(int,BiConsumer<String, String>)", "name": "getCommitMessages", "arg_nums": 2, "params": [{"name": "n", "type": "int"}, {"name": "consumer", "type": "BiConsumer<String, String>"}], "return_type": "void", "signature": "public static void getCommitMessages(int n,\n      BiConsumer<String, String> consumer)", "original_string": "  public static void getCommitMessages(int n,\n      BiConsumer<String, String> consumer) {\n    // Generate log like this:\n    //\n    //   ===\n    //   subject\n    //\n    //   body\n    //   ===\n    //   subject 2\n    //\n    //   body2\n    //\n    // then split on \"===\\n\"\n    final File base = TestUtil.getBaseDir(TestUnsafe.class);\n    final List<String> argumentList =\n        ImmutableList.of(\"git\", \"log\", \"-n\" + n, \"--pretty=format:===%n%B\");\n    try {\n      final StringWriter sw = new StringWriter();\n      int status =\n          runAppProcess(argumentList, base, null, null, sw);\n      String s = sw.toString();\n      if (status != 0) {\n        throw new RuntimeException(\"command \" + argumentList\n            + \": exited with status \" + status\n            + (s.isEmpty() ? \"\" : \"; output [\" + s + \"]\"));\n      }\n      Stream.of(s.split(\"===\\n\")).forEach(s2 -> {\n        if (s2.isEmpty()) {\n          return; // ignore empty subject & body\n        }\n        int i = s2.indexOf(\"\\n\");\n        if (i < 0) {\n          i = s2.length(); // no linefeed; treat entire chunk as subject\n        }\n        String subject = s2.substring(0, i);\n        while (i < s2.length() && s2.charAt(i) == '\\n') {\n          ++i; // skip multiple linefeeds between subject and body\n        }\n        String body = s2.substring(i);\n        consumer.accept(subject, body);\n      });\n    } catch (Exception e) {\n      throw new RuntimeException(\"command \" + argumentList\n          + \": failed with exception\", e);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUnsafe.java", "class_name": "TestUnsafe", "class_uri": "src/test/java/net/hydromatic/morel/TestUnsafe.java.TestUnsafe", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Returns the subject / body pairs of the {@code n} most recent commits."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtil.java.TestUtil.[File]getBaseDir(Class<?>)", "name": "getBaseDir", "arg_nums": 1, "params": [{"name": "klass", "type": "Class<?>"}], "return_type": "File", "signature": "public static File getBaseDir(Class<?> klass)", "original_string": "  public static File getBaseDir(Class<?> klass) {\n    // Algorithm:\n    // 1) Find location of TestUtil.class\n    // 2) Climb via getParentFile() until we detect pom.xml\n    // 3) It means we've got BASE/testkit/pom.xml, and we need to get BASE\n    final URL resource = klass.getResource(klass.getSimpleName() + \".class\");\n    final File classFile =\n        Sources.of(requireNonNull(resource, \"resource\")).file();\n\n    File file = classFile.getAbsoluteFile();\n    for (int i = 0; i < 42; i++) {\n      if (isProjectDir(file)) {\n        // Ok, file == BASE/testkit/\n        break;\n      }\n      file = file.getParentFile();\n    }\n    if (!isProjectDir(file)) {\n      fail(\"Could not find pom.xml, build.gradle.kts or gradle.properties. \"\n          + \"Started with \" + classFile.getAbsolutePath()\n          + \", the current path is \" + file.getAbsolutePath());\n    }\n    return file;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtil.java", "class_name": "TestUtil", "class_uri": "src/test/java/net/hydromatic/morel/TestUtil.java.TestUtil", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "File", "classes": []}, "docstring": " Returns the root directory of the source tree."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtil.java.TestUtil.[boolean]isProjectDir(File)", "name": "isProjectDir", "arg_nums": 1, "params": [{"name": "dir", "type": "File"}], "return_type": "boolean", "signature": "private static boolean isProjectDir(File dir)", "original_string": "  private static boolean isProjectDir(File dir) {\n    return new File(dir, \"pom.xml\").isFile()\n        || new File(dir, \"build.gradle.kts\").isFile()\n        || new File(dir, \"gradle.properties\").isFile();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtil.java", "class_name": "TestUtil", "class_uri": "src/test/java/net/hydromatic/morel/TestUtil.java.TestUtil", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[]Ml(String,Pos,Map<String, DataSet>,Map<Prop, Object>,Tracer)", "name": "Ml", "arg_nums": 5, "params": [{"name": "ml", "type": "String"}, {"name": "pos", "type": "Pos"}, {"name": "dataSetMap", "type": "Map<String, DataSet>"}, {"name": "propMap", "type": "Map<Prop, Object>"}, {"name": "tracer", "type": "Tracer"}], "return_type": "", "signature": "Ml(String ml, @Nullable Pos pos, Map<String, DataSet> dataSetMap,\n      Map<Prop, Object> propMap, Tracer tracer)", "original_string": "  Ml(String ml, @Nullable Pos pos, Map<String, DataSet> dataSetMap,\n      Map<Prop, Object> propMap, Tracer tracer) {\n    this.ml = ml;\n    this.pos = pos;\n    this.dataSetMap = ImmutableMap.copyOf(dataSetMap);\n    this.propMap = ImmutableMap.copyOf(propMap);\n    this.tracer = tracer;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]ml(String)", "name": "ml", "arg_nums": 1, "params": [{"name": "ml", "type": "String"}], "return_type": "Ml", "signature": "static Ml ml(String ml)", "original_string": "  static Ml ml(String ml) {\n    return new Ml(ml, null, ImmutableMap.of(), ImmutableMap.of(),\n        Tracers.empty());\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Ml", "classes": []}, "docstring": " Creates an {@code Ml}."}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]ml(String,char)", "name": "ml", "arg_nums": 2, "params": [{"name": "ml", "type": "String"}, {"name": "delimiter", "type": "char"}], "return_type": "Ml", "signature": "static Ml ml(String ml, char delimiter)", "original_string": "  static Ml ml(String ml, char delimiter) {\n    Pair<String, Pos> pair = Pos.split(ml, delimiter, \"stdIn\");\n    return new Ml(pair.left, pair.right, ImmutableMap.of(), ImmutableMap.of(),\n        Tracers.empty());\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Ml", "classes": []}, "docstring": " Creates an {@code Ml} with an error position in it."}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[void]assertError(Runnable,Matcher<Throwable>)", "name": "assertError", "arg_nums": 2, "params": [{"name": "runnable", "type": "Runnable"}, {"name": "matcher", "type": "Matcher<Throwable>"}], "return_type": "void", "signature": "static void assertError(Runnable runnable,\n      Matcher<Throwable> matcher)", "original_string": "  static void assertError(Runnable runnable,\n      Matcher<Throwable> matcher) {\n    try {\n      runnable.run();\n      fail(\"expected error\");\n    } catch (Throwable e) {\n      assertThat(e, matcher);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Runs a task and checks that it throws an exception.\n\n@param runnable Task to run\n@param matcher Checks whether exception is as expected\n"}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withParser(Consumer<MorelParserImpl>)", "name": "withParser", "arg_nums": 1, "params": [{"name": "action", "type": "Consumer<MorelParserImpl>"}], "return_type": "Ml", "signature": "Ml withParser(Consumer<MorelParserImpl> action)", "original_string": "  Ml withParser(Consumer<MorelParserImpl> action) {\n    final MorelParserImpl parser = new MorelParserImpl(new StringReader(ml));\n    action.accept(parser);\n    return this;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseLiteral(Matcher<Ast.Literal>)", "name": "assertParseLiteral", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<Ast.Literal>"}], "return_type": "Ml", "signature": "Ml assertParseLiteral(Matcher<Ast.Literal> matcher)", "original_string": "  Ml assertParseLiteral(Matcher<Ast.Literal> matcher) {\n    return withParser(parser -> {\n      try {\n        final Ast.Literal literal = parser.literalEof();\n        assertThat(literal, matcher);\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n    });\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseDecl(Matcher<Ast.Decl>)", "name": "assertParseDecl", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<Ast.Decl>"}], "return_type": "Ml", "signature": "Ml assertParseDecl(Matcher<Ast.Decl> matcher)", "original_string": "  Ml assertParseDecl(Matcher<Ast.Decl> matcher) {\n    return withParser(parser -> {\n      try {\n        final Ast.Decl decl = parser.declEof();\n        assertThat(decl, matcher);\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n    });\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseDecl(Class<? extends Ast.Decl>,String)", "name": "assertParseDecl", "arg_nums": 2, "params": [{"name": "clazz", "type": "Class<? extends Ast.Decl>"}, {"name": "expected", "type": "String"}], "return_type": "Ml", "signature": "Ml assertParseDecl(Class<? extends Ast.Decl> clazz,\n      String expected)", "original_string": "  Ml assertParseDecl(Class<? extends Ast.Decl> clazz,\n      String expected) {\n    return assertParseDecl(isAst(clazz, false, expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseStmt(Matcher<AstNode>)", "name": "assertParseStmt", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<AstNode>"}], "return_type": "Ml", "signature": "Ml assertParseStmt(Matcher<AstNode> matcher)", "original_string": "  Ml assertParseStmt(Matcher<AstNode> matcher) {\n    return withParser(parser -> {\n      try {\n        final AstNode statement = parser.statementEof();\n        assertThat(statement, matcher);\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n    });\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseStmt(Class<? extends AstNode>,String)", "name": "assertParseStmt", "arg_nums": 2, "params": [{"name": "clazz", "type": "Class<? extends AstNode>"}, {"name": "expected", "type": "String"}], "return_type": "Ml", "signature": "Ml assertParseStmt(Class<? extends AstNode> clazz,\n      String expected)", "original_string": "  Ml assertParseStmt(Class<? extends AstNode> clazz,\n      String expected) {\n    return assertParseStmt(isAst(clazz, false, expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParse(String)", "name": "assertParse", "arg_nums": 1, "params": [{"name": "expected", "type": "String"}], "return_type": "Ml", "signature": "Ml assertParse(String expected)", "original_string": "  Ml assertParse(String expected) {\n    return assertParse(false, expected);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": " Checks that an expression can be parsed and returns the given string\nwhen unparsed."}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParse(boolean,String)", "name": "assertParse", "arg_nums": 2, "params": [{"name": "parenthesized", "type": "boolean"}, {"name": "expected", "type": "String"}], "return_type": "Ml", "signature": "Ml assertParse(boolean parenthesized, String expected)", "original_string": "  Ml assertParse(boolean parenthesized, String expected) {\n    return assertParseStmt(isAst(AstNode.class, parenthesized, expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": " Checks that an expression can be parsed and returns the given string\nwhen unparsed, optionally with full parentheses."}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseSame()", "name": "assertParseSame", "arg_nums": 0, "params": [], "return_type": "Ml", "signature": "Ml assertParseSame()", "original_string": "  Ml assertParseSame() {\n    return assertParse(ml.replaceAll(\"[\\n ]+\", \" \"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": " Checks that an expression can be parsed and returns the identical\nexpression when unparsed."}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseThrowsParseException(Matcher<String>)", "name": "assertParseThrowsParseException", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<String>"}], "return_type": "Ml", "signature": "Ml assertParseThrowsParseException(Matcher<String> matcher)", "original_string": "  Ml assertParseThrowsParseException(Matcher<String> matcher) {\n    return assertParseThrows(throwsA(ParseException.class, matcher));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseThrowsIllegalArgumentException(Matcher<String>)", "name": "assertParseThrowsIllegalArgumentException", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<String>"}], "return_type": "Ml", "signature": "Ml assertParseThrowsIllegalArgumentException(Matcher<String> matcher)", "original_string": "  Ml assertParseThrowsIllegalArgumentException(Matcher<String> matcher) {\n    return assertParseThrows(throwsA(IllegalArgumentException.class, matcher));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertParseThrows(Matcher<Throwable>)", "name": "assertParseThrows", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<Throwable>"}], "return_type": "Ml", "signature": "Ml assertParseThrows(Matcher<Throwable> matcher)", "original_string": "  Ml assertParseThrows(Matcher<Throwable> matcher) {\n    try {\n      final MorelParserImpl parser = new MorelParserImpl(new StringReader(ml));\n      final AstNode statement = parser.statementEof();\n      fail(\"expected error, got \" + statement);\n    } catch (Throwable e) {\n      assertThat(e, matcher);\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withValidate(BiConsumer<TypeResolver.Resolved, Calcite>)", "name": "withValidate", "arg_nums": 1, "params": [{"name": "action", "type": "BiConsumer<TypeResolver.Resolved, Calcite>"}], "return_type": "Ml", "signature": "private Ml withValidate(BiConsumer<TypeResolver.Resolved, Calcite> action)", "original_string": "  private Ml withValidate(BiConsumer<TypeResolver.Resolved, Calcite> action) {\n    return withParser(parser -> {\n      final AstNode statement;\n      try {\n        parser.zero(\"stdIn\");\n        statement = parser.statementEof();\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n      final Calcite calcite = Calcite.withDataSets(dataSetMap);\n      try {\n        final TypeResolver.Resolved resolved =\n            Compiles.validateExpression(statement, propMap,\n                calcite.foreignValues());\n        tracer.handleCompileException(null);\n        action.accept(resolved, calcite);\n      } catch (TypeResolver.TypeException e) {\n        if (!tracer.onTypeException(e)) {\n          throw e;\n        }\n      } catch (CompileException e) {\n        if (!tracer.handleCompileException(e)) {\n          throw e;\n        }\n      }\n    });\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertType(Matcher<Type>)", "name": "assertType", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<Type>"}], "return_type": "Ml", "signature": "Ml assertType(Matcher<Type> matcher)", "original_string": "  Ml assertType(Matcher<Type> matcher) {\n    return withValidate((resolved, calcite) ->\n        assertThat(resolved.typeMap.getType(resolved.exp()), matcher));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertType(String)", "name": "assertType", "arg_nums": 1, "params": [{"name": "expected", "type": "String"}], "return_type": "Ml", "signature": "Ml assertType(String expected)", "original_string": "  Ml assertType(String expected) {\n    return assertType(hasMoniker(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertTypeThrows(Function<Pos, Matcher<Throwable>>)", "name": "assertTypeThrows", "arg_nums": 1, "params": [{"name": "matcherSupplier", "type": "Function<Pos, Matcher<Throwable>>"}], "return_type": "Ml", "signature": "Ml assertTypeThrows(Function<Pos, Matcher<Throwable>> matcherSupplier)", "original_string": "  Ml assertTypeThrows(Function<Pos, Matcher<Throwable>> matcherSupplier) {\n    return assertTypeThrows(matcherSupplier.apply(pos));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertTypeThrows(Matcher<Throwable>)", "name": "assertTypeThrows", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<Throwable>"}], "return_type": "Ml", "signature": "Ml assertTypeThrows(Matcher<Throwable> matcher)", "original_string": "  Ml assertTypeThrows(Matcher<Throwable> matcher) {\n    assertError(() ->\n            withValidate((resolved, calcite) ->\n                fail(\"expected error\")),\n        matcher);\n    return this;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertTypeException(String)", "name": "assertTypeException", "arg_nums": 1, "params": [{"name": "message", "type": "String"}], "return_type": "Ml", "signature": "Ml assertTypeException(String message)", "original_string": "  Ml assertTypeException(String message) {\n    return withTypeException(message)\n        .assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withPrepare(Consumer<CompiledStatement>)", "name": "withPrepare", "arg_nums": 1, "params": [{"name": "action", "type": "Consumer<CompiledStatement>"}], "return_type": "Ml", "signature": "Ml withPrepare(Consumer<CompiledStatement> action)", "original_string": "  Ml withPrepare(Consumer<CompiledStatement> action) {\n    return withParser(parser -> {\n      try {\n        final TypeSystem typeSystem = new TypeSystem();\n        final AstNode statement = parser.statementEof();\n        final Environment env = Environments.empty();\n        final Session session = new Session(propMap);\n        final List<CompileException> warningList = new ArrayList<>();\n        final CompiledStatement compiled =\n            Compiles.prepareStatement(typeSystem, session, env, statement,\n                null, warningList::add, tracer);\n        action.accept(compiled);\n      } catch (ParseException e) {\n        throw new RuntimeException(e);\n      }\n    });\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertCalcite(Matcher<String>)", "name": "assertCalcite", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<String>"}], "return_type": "Ml", "signature": "Ml assertCalcite(Matcher<String> matcher)", "original_string": "  Ml assertCalcite(Matcher<String> matcher) {\n    try {\n      final MorelParserImpl parser = new MorelParserImpl(new StringReader(ml));\n      final AstNode statement = parser.statementEof();\n      final TypeSystem typeSystem = new TypeSystem();\n\n      final Calcite calcite = Calcite.withDataSets(dataSetMap);\n      final TypeResolver.Resolved resolved =\n          Compiles.validateExpression(statement, propMap,\n              calcite.foreignValues());\n      final Environment env = resolved.env;\n      final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n      final Session session = null;\n      final Resolver resolver = Resolver.of(resolved.typeMap, env, session);\n      final Core.ValDecl valDecl3 = resolver.toCore(valDecl2);\n      assertThat(valDecl3, instanceOf(Core.NonRecValDecl.class));\n      final RelNode rel =\n          new CalciteCompiler(typeSystem, calcite)\n              .toRel(env, Compiles.toExp((Core.NonRecValDecl) valDecl3));\n      requireNonNull(rel);\n      final String relString = RelOptUtil.toString(rel);\n      assertThat(relString, matcher);\n      return this;\n    } catch (ParseException e) {\n      throw new RuntimeException(e);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertCore(int,Matcher<Core.Decl>)", "name": "assertCore", "arg_nums": 2, "params": [{"name": "pass", "type": "int"}, {"name": "expected", "type": "Matcher<Core.Decl>"}], "return_type": "Ml", "signature": "Ml assertCore(int pass, Matcher<Core.Decl> expected)", "original_string": "  Ml assertCore(int pass, Matcher<Core.Decl> expected) {\n    final AtomicInteger callCount = new AtomicInteger(0);\n    final Consumer<Core.Decl> consumer = e -> {\n      callCount.incrementAndGet();\n      assertThat(e, expected);\n    };\n    final Tracer tracer = Tracers.withOnCore(this.tracer, pass, consumer);\n\n    final Consumer<Object> consumer2 = o ->\n        assertThat(\"core(\" + pass + \") was never called\",\n            callCount.get(), greaterThan(0));\n    final Tracer tracer2 = Tracers.withOnResult(tracer, consumer2);\n\n    return withTracer(tracer2).assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": " Asserts that the Core string converts to the expected value.\n\n<p>For pass = 2, the Core string is generated after parsing the current\nexpression and converting it to Core. Which is usually the original\nstring."}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertCoreString(Matcher<Core.Decl>,Matcher<Core.Decl>,Matcher<Core.Decl>)", "name": "assertCoreString", "arg_nums": 3, "params": [{"name": "beforeMatcher", "type": "Matcher<Core.Decl>"}, {"name": "matcher", "type": "Matcher<Core.Decl>"}, {"name": "inlinedMatcher", "type": "Matcher<Core.Decl>"}], "return_type": "Ml", "signature": "public Ml assertCoreString(@Nullable Matcher<Core.Decl> beforeMatcher,\n      Matcher<Core.Decl> matcher,\n      @Nullable Matcher<Core.Decl> inlinedMatcher)", "original_string": "  public Ml assertCoreString(@Nullable Matcher<Core.Decl> beforeMatcher,\n      Matcher<Core.Decl> matcher,\n      @Nullable Matcher<Core.Decl> inlinedMatcher) {\n    return with(Prop.INLINE_PASS_COUNT, 10)\n        .with(Prop.RELATIONALIZE, true)\n        .assertCore(0, beforeMatcher)\n        .assertCore(2, matcher)\n        .assertCore(-1, inlinedMatcher);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Ml", "classes": []}, "docstring": " As {@link #assertCore(int, Matcher)} but also checks how the Core\nstring has changed after inlining."}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertAnalyze(Matcher<Map<Core.NamedPat, Analyzer.Use>>)", "name": "assertAnalyze", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<Map<Core.NamedPat, Analyzer.Use>>"}], "return_type": "Ml", "signature": "Ml assertAnalyze(Matcher<Map<Core.NamedPat, Analyzer.Use>> matcher)", "original_string": "  Ml assertAnalyze(Matcher<Map<Core.NamedPat, Analyzer.Use>> matcher) {\n    final AstNode statement;\n    try {\n      final MorelParserImpl parser = new MorelParserImpl(new StringReader(ml));\n      statement = parser.statementEof();\n    } catch (ParseException parseException) {\n      throw new RuntimeException(parseException);\n    }\n    final TypeSystem typeSystem = new TypeSystem();\n\n    final Session session = null;\n    final Environment env =\n        Environments.env(typeSystem, session, ImmutableMap.of());\n    final Ast.ValDecl valDecl = Compiles.toValDecl(statement);\n    final TypeResolver.Resolved resolved =\n        TypeResolver.deduceType(env, valDecl, typeSystem);\n    final Ast.ValDecl valDecl2 = (Ast.ValDecl) resolved.node;\n    final Resolver resolver = Resolver.of(resolved.typeMap, env, null);\n    final Core.ValDecl valDecl3 = resolver.toCore(valDecl2);\n    final Analyzer.Analysis analysis =\n        Analyzer.analyze(typeSystem, env, valDecl3);\n    assertThat(ImmutableSortedMap.copyOf(analysis.map), matcher);\n    return this;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertMatchCoverage(MatchCoverage)", "name": "assertMatchCoverage", "arg_nums": 1, "params": [{"name": "expectedCoverage", "type": "MatchCoverage"}], "return_type": "Ml", "signature": "Ml assertMatchCoverage(MatchCoverage expectedCoverage)", "original_string": "  Ml assertMatchCoverage(MatchCoverage expectedCoverage) {\n    final Function<Pos, Matcher<Throwable>> exceptionMatcherFactory;\n    final Matcher<List<Throwable>> warningsMatcher;\n    switch (expectedCoverage) {\n    case OK:\n      // Expect no errors or warnings\n      exceptionMatcherFactory = null;\n      warningsMatcher = isEmptyList();\n      break;\n    case REDUNDANT:\n      exceptionMatcherFactory = pos -> throwsA(\"match redundant\", pos);\n      warningsMatcher = isEmptyList();\n      break;\n    case NON_EXHAUSTIVE_AND_REDUNDANT:\n      exceptionMatcherFactory = pos ->\n          throwsA(\"match nonexhaustive and redundant\", pos);\n      warningsMatcher = isEmptyList();\n      break;\n    case NON_EXHAUSTIVE:\n      exceptionMatcherFactory = null;\n      warningsMatcher =\n          new CustomTypeSafeMatcher<List<Throwable>>(\"non-empty list\") {\n            @Override protected boolean matchesSafely(List<Throwable> list) {\n              return list.stream()\n                  .anyMatch(e ->\n                      e instanceof CompileException\n                          && e.getMessage().equals(\"match nonexhaustive\"));\n            }\n          };\n      break;\n    default:\n      // Java doesn't know the switch is exhaustive; how ironic\n      throw new AssertionError(expectedCoverage);\n    }\n    return withResultMatcher(notNullValue())\n        .withWarningsMatcher(warningsMatcher)\n        .withExceptionMatcher(exceptionMatcherFactory)\n        .assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Matcher<List<E>>]isEmptyList()", "name": "isEmptyList", "arg_nums": 0, "params": [], "return_type": "Matcher<List<E>>", "signature": "private static <E> Matcher<List<E>> isEmptyList()", "original_string": "  private static <E> Matcher<List<E>> isEmptyList() {\n    return new CustomTypeSafeMatcher<List<E>>(\"empty list\") {\n      @Override protected boolean matchesSafely(List<E> list) {\n        return list.isEmpty();\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Matcher<List<E>>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertPlan(Matcher<Code>)", "name": "assertPlan", "arg_nums": 1, "params": [{"name": "planMatcher", "type": "Matcher<Code>"}], "return_type": "Ml", "signature": "Ml assertPlan(Matcher<Code> planMatcher)", "original_string": "  Ml assertPlan(Matcher<Code> planMatcher) {\n    final Consumer<Code> consumer = code ->\n        assertThat(code, planMatcher);\n    final Tracer tracer = Tracers.withOnPlan(this.tracer, consumer);\n    return withTracer(tracer).assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalIter(Matcher<Iterable<E>>)", "name": "assertEvalIter", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<Iterable<E>>"}], "return_type": "Ml", "signature": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  <E> Ml assertEvalIter(Matcher<Iterable<E>> matcher)", "original_string": "  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  <E> Ml assertEvalIter(Matcher<Iterable<E>> matcher) {\n    return assertEval((Matcher) matcher);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "@SuppressWarnings({\"unchecked\", \"rawtypes\"})", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings({\"unchecked\", \"rawtypes\"})"], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEval(Matcher<Object>)", "name": "assertEval", "arg_nums": 1, "params": [{"name": "resultMatcher", "type": "Matcher<Object>"}], "return_type": "Ml", "signature": "Ml assertEval(Matcher<Object> resultMatcher)", "original_string": "  Ml assertEval(Matcher<Object> resultMatcher) {\n    return withResultMatcher(resultMatcher).assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEval()", "name": "assertEval", "arg_nums": 0, "params": [], "return_type": "Ml", "signature": "Ml assertEval()", "original_string": "  Ml assertEval() {\n    return withValidate((resolved, calcite) -> {\n      final Session session = new Session(propMap);\n      eval(session, resolved.env, resolved.typeMap.typeSystem, resolved.node,\n          calcite);\n    });\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalThrows(Function<Pos, Matcher<Throwable>>)", "name": "assertEvalThrows", "arg_nums": 1, "params": [{"name": "exceptionMatcherFactory", "type": "Function<Pos, Matcher<Throwable>>"}], "return_type": "Ml", "signature": "Ml assertEvalThrows(\n      Function<Pos, Matcher<Throwable>> exceptionMatcherFactory)", "original_string": "  Ml assertEvalThrows(\n      Function<Pos, Matcher<Throwable>> exceptionMatcherFactory) {\n    return withExceptionMatcher(exceptionMatcherFactory).assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Object]eval(Session,Environment,TypeSystem,AstNode,Calcite)", "name": "eval", "arg_nums": 5, "params": [{"name": "session", "type": "Session"}, {"name": "env", "type": "Environment"}, {"name": "typeSystem", "type": "TypeSystem"}, {"name": "statement", "type": "AstNode"}, {"name": "calcite", "type": "Calcite"}], "return_type": "Object", "signature": "@CanIgnoreReturnValue\n  private <E extends Throwable> Object eval(Session session, Environment env,\n      TypeSystem typeSystem, AstNode statement, Calcite calcite)", "original_string": "  @CanIgnoreReturnValue\n  private <E extends Throwable> Object eval(Session session, Environment env,\n      TypeSystem typeSystem, AstNode statement, Calcite calcite) {\n    final List<Binding> bindings = new ArrayList<>();\n    final List<Throwable> warningList = new ArrayList<>();\n    try {\n      CompiledStatement compiledStatement =\n          Compiles.prepareStatement(typeSystem, session, env, statement,\n              calcite, warningList::add, tracer);\n      session.withoutHandlingExceptions(session1 ->\n          compiledStatement.eval(session1, env, line -> {}, bindings::add));\n      tracer.onException(null);\n    } catch (RuntimeException e) {\n      if (!tracer.onException(e)) {\n        throw e;\n      }\n    }\n    tracer.onWarnings(warningList);\n    final Object result;\n    if (statement instanceof Ast.Exp) {\n      result = bindingValue(bindings, \"it\");\n    } else if (bindings.size() == 1) {\n      result = bindings.get(0).value;\n    } else {\n      Map<String, Object> map = new LinkedHashMap<>();\n      bindings.forEach(b -> {\n        if (!b.id.name.equals(\"it\")) {\n          map.put(b.id.name, b.value);\n        }\n      });\n      result = map;\n    }\n    tracer.onResult(result);\n    tracer.onPlan(session.code);\n    return result;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "@CanIgnoreReturnValue\n  private", "marker_annotations": ["@CanIgnoreReturnValue"], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Object]bindingValue(List<Binding>,String)", "name": "bindingValue", "arg_nums": 2, "params": [{"name": "bindings", "type": "List<Binding>"}, {"name": "name", "type": "String"}], "return_type": "Object", "signature": "private Object bindingValue(List<Binding> bindings, String name)", "original_string": "  private Object bindingValue(List<Binding> bindings, String name) {\n    for (Binding binding : bindings) {\n      if (binding.id.name.equals(name)) {\n        return binding.value;\n      }\n    }\n    return null;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertCompileException(Function<Pos, Matcher<CompileException>>)", "name": "assertCompileException", "arg_nums": 1, "params": [{"name": "matcherSupplier", "type": "Function<Pos, Matcher<CompileException>>"}], "return_type": "Ml", "signature": "Ml assertCompileException(\n      Function<Pos, Matcher<CompileException>> matcherSupplier)", "original_string": "  Ml assertCompileException(\n      Function<Pos, Matcher<CompileException>> matcherSupplier) {\n    assertThat(pos, notNullValue());\n    return withResultMatcher(notNullValue())\n        .withCompileExceptionMatcher(matcherSupplier)\n        .assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalError(Function<Pos, Matcher<Throwable>>)", "name": "assertEvalError", "arg_nums": 1, "params": [{"name": "matcherSupplier", "type": "Function<Pos, Matcher<Throwable>>"}], "return_type": "Ml", "signature": "Ml assertEvalError(Function<Pos, Matcher<Throwable>> matcherSupplier)", "original_string": "  Ml assertEvalError(Function<Pos, Matcher<Throwable>> matcherSupplier) {\n    assertThat(pos, notNullValue());\n    return withResultMatcher(notNullValue())\n        .withExceptionMatcher(matcherSupplier)\n        .assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalWarnings(Matcher<List<Throwable>>)", "name": "assertEvalWarnings", "arg_nums": 1, "params": [{"name": "warningsMatcher", "type": "Matcher<List<Throwable>>"}], "return_type": "Ml", "signature": "Ml assertEvalWarnings(Matcher<List<Throwable>> warningsMatcher)", "original_string": "  Ml assertEvalWarnings(Matcher<List<Throwable>> warningsMatcher) {\n    return withResultMatcher(notNullValue())\n        .withWarningsMatcher(warningsMatcher)\n        .assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertEvalSame()", "name": "assertEvalSame", "arg_nums": 0, "params": [], "return_type": "Ml", "signature": "Ml assertEvalSame()", "original_string": "  Ml assertEvalSame() {\n    final Matchers.LearningMatcher<Object> resultMatcher =\n        Matchers.learning(Object.class);\n    return with(Prop.HYBRID, false)\n        .assertEval(resultMatcher)\n        .with(Prop.HYBRID, true)\n        .assertEval(Matchers.isUnordered(resultMatcher.get()));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertError(Matcher<String>)", "name": "assertError", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<String>"}], "return_type": "Ml", "signature": "Ml assertError(Matcher<String> matcher)", "original_string": "  Ml assertError(Matcher<String> matcher) {\n    // TODO: execute code, and check error occurs\n    return this;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]assertError(String)", "name": "assertError", "arg_nums": 1, "params": [{"name": "expected", "type": "String"}], "return_type": "Ml", "signature": "Ml assertError(String expected)", "original_string": "  Ml assertError(String expected) {\n    return assertError(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withBinding(String,DataSet)", "name": "withBinding", "arg_nums": 2, "params": [{"name": "name", "type": "String"}, {"name": "dataSet", "type": "DataSet"}], "return_type": "Ml", "signature": "Ml withBinding(String name, DataSet dataSet)", "original_string": "  Ml withBinding(String name, DataSet dataSet) {\n    return new Ml(ml, pos, plus(dataSetMap, name, dataSet), propMap, tracer);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]with(Prop,Object)", "name": "with", "arg_nums": 2, "params": [{"name": "prop", "type": "Prop"}, {"name": "value", "type": "Object"}], "return_type": "Ml", "signature": "Ml with(Prop prop, Object value)", "original_string": "  Ml with(Prop prop, Object value) {\n    return new Ml(ml, pos, dataSetMap, plus(propMap, prop, value), tracer);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withTracer(Tracer)", "name": "withTracer", "arg_nums": 1, "params": [{"name": "tracer", "type": "Tracer"}], "return_type": "Ml", "signature": "Ml withTracer(Tracer tracer)", "original_string": "  Ml withTracer(Tracer tracer) {\n    return new Ml(ml, pos, dataSetMap, propMap, tracer);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withTypeExceptionMatcher(Matcher<Throwable>)", "name": "withTypeExceptionMatcher", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<Throwable>"}], "return_type": "Ml", "signature": "Ml withTypeExceptionMatcher(Matcher<Throwable> matcher)", "original_string": "  Ml withTypeExceptionMatcher(Matcher<Throwable> matcher) {\n    final Consumer<TypeResolver.TypeException> consumer =\n        o -> assertThat(o, matcher);\n    return withTracer(Tracers.withOnTypeException(tracer, consumer));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withResultMatcher(Matcher<Object>)", "name": "withResultMatcher", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<Object>"}], "return_type": "Ml", "signature": "Ml withResultMatcher(Matcher<Object> matcher)", "original_string": "  Ml withResultMatcher(Matcher<Object> matcher) {\n    final Consumer<Object> consumer = o -> assertThat(o, matcher);\n    return withTracer(Tracers.withOnResult(this.tracer, consumer));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withWarningsMatcher(Matcher<List<Throwable>>)", "name": "withWarningsMatcher", "arg_nums": 1, "params": [{"name": "matcher", "type": "Matcher<List<Throwable>>"}], "return_type": "Ml", "signature": "Ml withWarningsMatcher(Matcher<List<Throwable>> matcher)", "original_string": "  Ml withWarningsMatcher(Matcher<List<Throwable>> matcher) {\n    final Consumer<List<Throwable>> consumer = warningList ->\n        assertThat(warningList, matcher);\n    return withTracer(Tracers.withOnWarnings(this.tracer, consumer));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withExceptionMatcher(Function<Pos, Matcher<Throwable>>)", "name": "withExceptionMatcher", "arg_nums": 1, "params": [{"name": "matcherFactory", "type": "Function<Pos, Matcher<Throwable>>"}], "return_type": "Ml", "signature": "Ml withExceptionMatcher(\n      @Nullable Function<Pos, Matcher<Throwable>> matcherFactory)", "original_string": "  Ml withExceptionMatcher(\n      @Nullable Function<Pos, Matcher<Throwable>> matcherFactory) {\n    return withTracer(\n        Tracers.withOnException(this.tracer,\n            exceptionConsumer(matcherFactory)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withCompileExceptionMatcher(Function<Pos, Matcher<CompileException>>)", "name": "withCompileExceptionMatcher", "arg_nums": 1, "params": [{"name": "matcherFactory", "type": "Function<Pos, Matcher<CompileException>>"}], "return_type": "Ml", "signature": "Ml withCompileExceptionMatcher(\n      @Nullable Function<Pos, Matcher<CompileException>> matcherFactory)", "original_string": "  Ml withCompileExceptionMatcher(\n      @Nullable Function<Pos, Matcher<CompileException>> matcherFactory) {\n    return withTracer(\n        Tracers.withOnCompileException(this.tracer,\n            exceptionConsumer(matcherFactory)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Ml]withTypeException(String)", "name": "withTypeException", "arg_nums": 1, "params": [{"name": "message", "type": "String"}], "return_type": "Ml", "signature": "Ml withTypeException(String message)", "original_string": "  Ml withTypeException(String message) {\n    return withTypeExceptionMatcher(throwsA(message));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Ml", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Consumer<T>]exceptionConsumer(Function<Pos, Matcher<T>>)", "name": "exceptionConsumer", "arg_nums": 1, "params": [{"name": "exceptionMatcherFactory", "type": "Function<Pos, Matcher<T>>"}], "return_type": "Consumer<T>", "signature": "private <T extends Throwable> Consumer<T> exceptionConsumer(\n      Function<Pos, Matcher<T>> exceptionMatcherFactory)", "original_string": "  private <T extends Throwable> Consumer<T> exceptionConsumer(\n      Function<Pos, Matcher<T>> exceptionMatcherFactory) {\n    @Nullable Matcher<T> matcher =\n        exceptionMatcherFactory == null\n            ? null\n            : exceptionMatcherFactory.apply(pos);\n    return e -> {\n      if (e != null) {\n        if (matcher != null) {\n          assertThat(e, matcher);\n        } else {\n          if (e instanceof RuntimeException) {\n            throw (RuntimeException) e;\n          }\n          if (e instanceof Error) {\n            throw (Error) e;\n          }\n          throw new RuntimeException(e);\n        }\n      } else {\n        if (matcher != null) {\n          fail(\"expected exception, but none was thrown\");\n        }\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Consumer<T>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/Ml.java.Ml.[Map<K, V>]plus(Map<K, V>,K,V)", "name": "plus", "arg_nums": 3, "params": [{"name": "map", "type": "Map<K, V>"}, {"name": "k", "type": "K"}, {"name": "v", "type": "V"}], "return_type": "Map<K, V>", "signature": "private static <K, V> Map<K, V> plus(Map<K, V> map, K k, V v)", "original_string": "  private static <K, V> Map<K, V> plus(Map<K, V> map, K k, V v) {\n    final ImmutableMap.Builder<K, V> builder = ImmutableMap.builder();\n    if (map.containsKey(k)) {\n      map.forEach((k2, v2) -> {\n        if (!k2.equals(k)) {\n          builder.put(k, v);\n        }\n      });\n    } else {\n      builder.putAll(map);\n    }\n    builder.put(k, v);\n    return builder.build();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/Ml.java", "class_name": "Ml", "class_uri": "src/test/java/net/hydromatic/morel/Ml.java.Ml", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "docstring": " Returns a map plus (adding or overwriting) one (key, value) entry."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[]TestUtils()", "name": "TestUtils", "arg_nums": 0, "params": [], "return_type": "", "signature": "private TestUtils()", "original_string": "  private TestUtils() {}", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]u2n(String)", "name": "u2n", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "String", "signature": "public static String u2n(String s)", "original_string": "  public static String u2n(String s) {\n    return File.separatorChar == '\\\\'\n        ? s.replace('/', '\\\\')\n        : s;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Converts a path from Unix to native.\n\n<p>On Windows, converts forward-slashes to back-slashes;\non Linux, does nothing."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]n2u(String)", "name": "n2u", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "String", "signature": "public static String n2u(String s)", "original_string": "  public static String n2u(String s) {\n    return File.separatorChar == '\\\\' ? s.replace('\\\\', '/') : s;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Converts a path from native to Unix."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[E]first(E,E)", "name": "first", "arg_nums": 2, "params": [{"name": "e0", "type": "E"}, {"name": "e1", "type": "E"}], "return_type": "E", "signature": "public static <E> E first(E e0, E e1)", "original_string": "  public static <E> E first(E e0, E e1) {\n    return e0 != null ? e0 : e1;\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]toCamelCase(String)", "name": "toCamelCase", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "String", "signature": "public static String toCamelCase(String name)", "original_string": "  public static String toCamelCase(String name) {\n    StringBuilder buf = new StringBuilder();\n    int nextUpper = -1;\n\n    for (int i = 0; i < name.length(); ++i) {\n      char c = name.charAt(i);\n      if (c == '_') {\n        nextUpper = i + 1;\n      } else {\n        if (nextUpper == i) {\n          c = Character.toUpperCase(c);\n        } else {\n          c = Character.toLowerCase(c);\n        }\n\n        buf.append(c);\n      }\n    }\n\n    return buf.toString();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[File]urlToFile(URL)", "name": "urlToFile", "arg_nums": 1, "params": [{"name": "url", "type": "URL"}], "return_type": "File", "signature": "public static File urlToFile(URL url)", "original_string": "  public static File urlToFile(URL url) {\n    if (!\"file\".equals(url.getProtocol())) {\n      return null;\n    }\n    URI uri;\n    try {\n      uri = url.toURI();\n    } catch (URISyntaxException e) {\n      throw new IllegalArgumentException(\"Unable to convert URL \" + url\n          + \" to URI\", e);\n    }\n    if (uri.isOpaque()) {\n      // It is like file:test%20file.c++\n      // getSchemeSpecificPart would return \"test file.c++\"\n      return new File(uri.getSchemeSpecificPart());\n    }\n    // See https://stackoverflow.com/a/17870390/1261287\n    return Paths.get(uri).toFile();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "File", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[File]findDirectory()", "name": "findDirectory", "arg_nums": 0, "params": [], "return_type": "File", "signature": "static File findDirectory()", "original_string": "  static File findDirectory() {\n    final URL inUrl = MainTest.class.getResource(\"/\");\n    assertThat(inUrl, notNullValue());\n    return urlToFile(inUrl);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "File", "classes": []}, "docstring": " Returns the root directory of test resources."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[void]discard(boolean)", "name": "discard", "arg_nums": 1, "params": [{"name": "value", "type": "boolean"}], "return_type": "void", "signature": "@SuppressWarnings(\"unused\")\n  public static void discard(boolean value)", "original_string": "  @SuppressWarnings(\"unused\")\n  public static void discard(boolean value) {\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\n  public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[PrintWriter]printWriter(OutputStream)", "name": "printWriter", "arg_nums": 1, "params": [{"name": "out", "type": "OutputStream"}], "return_type": "PrintWriter", "signature": "public static PrintWriter printWriter(OutputStream out)", "original_string": "  public static PrintWriter printWriter(OutputStream out) {\n    return new PrintWriter(\n        new BufferedWriter(\n            new OutputStreamWriter(out, StandardCharsets.UTF_8)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "PrintWriter", "classes": []}, "docstring": " Creates a {@link PrintWriter} to a given output stream using UTF-8\ncharacter set.\n\n<p>Does not use the default character set."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[PrintWriter]printWriter(File)", "name": "printWriter", "arg_nums": 1, "params": [{"name": "file", "type": "File"}], "return_type": "PrintWriter", "signature": "public static PrintWriter printWriter(File file)", "original_string": "  public static PrintWriter printWriter(File file)\n      throws FileNotFoundException {\n    return printWriter(new FileOutputStream(file));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "PrintWriter", "classes": []}, "docstring": " Creates a {@link PrintWriter} to a given file using UTF-8\ncharacter set.\n\n<p>Does not use the default character set."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[BufferedReader]reader(InputStream)", "name": "reader", "arg_nums": 1, "params": [{"name": "in", "type": "InputStream"}], "return_type": "BufferedReader", "signature": "public static BufferedReader reader(InputStream in)", "original_string": "  public static BufferedReader reader(InputStream in) {\n    return new BufferedReader(\n        new InputStreamReader(in, StandardCharsets.UTF_8));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "BufferedReader", "classes": []}, "docstring": " Creates a {@link BufferedReader} to a given input stream using UTF-8\ncharacter set.\n\n<p>Does not use the default character set."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[BufferedReader]reader(File)", "name": "reader", "arg_nums": 1, "params": [{"name": "file", "type": "File"}], "return_type": "BufferedReader", "signature": "public static BufferedReader reader(File file)", "original_string": "  public static BufferedReader reader(File file)\n      throws FileNotFoundException {\n    return reader(new FileInputStream(file));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "BufferedReader", "classes": []}, "docstring": " Creates a {@link BufferedReader} to read a given file using UTF-8\ncharacter set.\n\n<p>Does not use the default character set."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]diff(File,File)", "name": "diff", "arg_nums": 2, "params": [{"name": "file1", "type": "File"}, {"name": "file2", "type": "File"}], "return_type": "String", "signature": "public static String diff(File file1, File file2)", "original_string": "  public static String diff(File file1, File file2) {\n    List<String> lines1 = fileLines(file1);\n    List<String> lines2 = fileLines(file2);\n    return diffLines(lines1, lines2);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Returns a string containing the difference between the contents of two\nfiles. The string has a similar format to the UNIX 'diff' utility."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[String]diffLines(List<String>,List<String>)", "name": "diffLines", "arg_nums": 2, "params": [{"name": "lines1", "type": "List<String>"}, {"name": "lines2", "type": "List<String>"}], "return_type": "String", "signature": "public static String diffLines(List<String> lines1, List<String> lines2)", "original_string": "  public static String diffLines(List<String> lines1, List<String> lines2) {\n    final Diff<String> diff = new Diff<>(lines1, lines2);\n    final List<Difference> differences = diff.execute();\n    StringWriter sw = new StringWriter();\n    int offset = 0;\n    for (Difference d : differences) {\n      final int as = d.getAddedStart() + 1;\n      final int ae = d.getAddedEnd() + 1;\n      final int ds = d.getDeletedStart() + 1;\n      final int de = d.getDeletedEnd() + 1;\n      if (ae == 0) {\n        if (de == 0) {\n          // no change\n        } else {\n          // a deletion: \"<ds>,<de>d<as>\"\n          sw.append(String.valueOf(ds));\n          if (de > ds) {\n            sw.append(\",\").append(String.valueOf(de));\n          }\n          sw.append(\"d\").append(String.valueOf(as - 1)).append('\\n');\n          for (int i = ds - 1; i < de; ++i) {\n            sw.append(\"< \").append(lines1.get(i)).append('\\n');\n          }\n        }\n      } else {\n        if (de == 0) {\n          // an addition: \"<ds>a<as,ae>\"\n          sw.append(String.valueOf(ds - 1)).append(\"a\").append(\n              String.valueOf(as));\n          if (ae > as) {\n            sw.append(\",\").append(String.valueOf(ae));\n          }\n          sw.append('\\n');\n          for (int i = as - 1; i < ae; ++i) {\n            sw.append(\"> \").append(lines2.get(i)).append('\\n');\n          }\n        } else {\n          // a change: \"<ds>,<de>c<as>,<ae>\n          sw.append(String.valueOf(ds));\n          if (de > ds) {\n            sw.append(\",\").append(String.valueOf(de));\n          }\n          sw.append(\"c\").append(String.valueOf(as));\n          if (ae > as) {\n            sw.append(\",\").append(String.valueOf(ae));\n          }\n          sw.append('\\n');\n          for (int i = ds - 1; i < de; ++i) {\n            sw.append(\"< \").append(lines1.get(i)).append('\\n');\n          }\n          sw.append(\"---\\n\");\n          for (int i = as - 1; i < ae; ++i) {\n            sw.append(\"> \").append(lines2.get(i)).append('\\n');\n          }\n          offset = offset + (ae - as) - (de - ds);\n        }\n      }\n    }\n    return sw.toString();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Returns a string containing the difference between the two sets of\nlines."}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[List<String>]fileLines(File)", "name": "fileLines", "arg_nums": 1, "params": [{"name": "file", "type": "File"}], "return_type": "List<String>", "signature": "private static List<String> fileLines(File file)", "original_string": "  private static List<String> fileLines(File file) {\n    List<String> lines = new ArrayList<>();\n    if (!file.exists()) {\n      return lines;\n    }\n    try (LineNumberReader r = new LineNumberReader(reader(file))) {\n      String line;\n      while ((line = r.readLine()) != null) {\n        lines.add(line);\n      }\n      return lines;\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<String>", "classes": []}, "docstring": " Returns a list of the lines in a given file, or an empty list if the file\ndoes not exist.\n\n@param file File\n@return List of lines\n"}, {"uris": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils.[ImmutableList<E>]plus(List<E>,E)", "name": "plus", "arg_nums": 2, "params": [{"name": "elements", "type": "List<E>"}, {"name": "element", "type": "E"}], "return_type": "ImmutableList<E>", "signature": "public static <E> ImmutableList<E> plus(List<E> elements, E element)", "original_string": "  public static <E> ImmutableList<E> plus(List<E> elements, E element) {\n    return ImmutableList.<E>builder()\n        .addAll(elements)\n        .add(element)\n        .build();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/TestUtils.java", "class_name": "TestUtils", "class_uri": "src/test/java/net/hydromatic/morel/TestUtils.java.TestUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ImmutableList<E>", "classes": []}, "docstring": " Returns a list plus one element."}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[List<T>]left(List<? extends Map.Entry<? extends T, ? extends U>>)", "name": "left", "arg_nums": 1, "params": [{"name": "pairs", "type": "List<? extends Map.Entry<? extends T, ? extends U>>"}], "return_type": "List<T>", "signature": "private static <T, U> List<T> left(\n      final List<? extends Map.Entry<? extends T, ? extends U>> pairs)", "original_string": "  private static <T, U> List<T> left(\n      final List<? extends Map.Entry<? extends T, ? extends U>> pairs) {\n    return new AbstractList<T>() {\n      @Override public T get(int index) {\n        return pairs.get(index).getKey();\n      }\n\n      @Override public int size() {\n        return pairs.size();\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<T>", "classes": []}, "docstring": " Equivalent to {@link Pair#left} but without calling\n{@link PairList#leftList()}."}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[List<U>]right(List<? extends Map.Entry<? extends T, ? extends U>>)", "name": "right", "arg_nums": 1, "params": [{"name": "pairs", "type": "List<? extends Map.Entry<? extends T, ? extends U>>"}], "return_type": "List<U>", "signature": "private static <T, U> List<U> right(\n      final List<? extends Map.Entry<? extends T, ? extends U>> pairs)", "original_string": "  private static <T, U> List<U> right(\n      final List<? extends Map.Entry<? extends T, ? extends U>> pairs) {\n    return new AbstractList<U>() {\n      @Override public U get(int index) {\n        return pairs.get(index).getValue();\n      }\n\n      @Override public int size() {\n        return pairs.size();\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<U>", "classes": []}, "docstring": " Equivalent to {@link Pair#right} but without calling\n{@link PairList#rightList()}."}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[void]validate(PairList<T, U>,List<? extends Map.Entry<T, U>>)", "name": "validate", "arg_nums": 2, "params": [{"name": "pairList", "type": "PairList<T, U>"}, {"name": "list", "type": "List<? extends Map.Entry<T, U>>"}], "return_type": "void", "signature": "private <T, U> void validate(PairList<T, U> pairList,\n      List<? extends Map.Entry<T, U>> list)", "original_string": "  private <T, U> void validate(PairList<T, U> pairList,\n      List<? extends Map.Entry<T, U>> list) {\n    assertThat(pairList.isEmpty(), is(list.isEmpty()));\n    assertThat(pairList, hasSize(list.size()));\n    assertThat(pairList.leftList(), hasSize(list.size()));\n    assertThat(pairList.rightList(), hasSize(list.size()));\n    assertThat(pairList.leftList(), is(left(list)));\n    assertThat(pairList.leftList(), instanceOf(RandomAccess.class));\n    assertThat(pairList.rightList(), is(right(list)));\n    assertThat(pairList.rightList(), instanceOf(RandomAccess.class));\n\n    // Check PairList.left(int) and PairList.right(int)\n    for (int i = 0; i < list.size(); i++) {\n      Map.Entry<T, U> entry = list.get(i);\n      assertThat(pairList.left(i), is(entry.getKey()));\n      assertThat(pairList.right(i), is(entry.getValue()));\n    }\n\n    final List<Map.Entry<T, U>> list2 = new ArrayList<>(pairList);\n    assertThat(list2, is(list));\n\n    // Check PairList.forEach(Consumer)\n    list2.clear();\n    //noinspection UseBulkOperation\n    pairList.forEach(p -> list2.add(p));\n    assertThat(list2, is(list));\n\n    // Check PairList.forEach(BiConsumer)\n    list2.clear();\n    pairList.forEach((t, u) -> list2.add(Pair.of(t, u)));\n    assertThat(list2, is(list));\n\n    // Check PairList.forEachIndexed\n    list2.clear();\n    pairList.forEachIndexed((i, t, u) -> {\n      assertThat(i, is(list2.size()));\n      list2.add(Pair.of(t, u));\n    });\n    assertThat(list2, is(list));\n\n    // Check PairList.immutable()\n    // Skip if there are no null keys or values\n    if (list.stream().anyMatch(e -> e.getKey() == null)) {\n      // PairList.immutable should throw if there are null keys\n      try {\n        Object o = pairList.immutable();\n        fail(\"expected error, got \" + o);\n      } catch (NullPointerException e) {\n        assertThat(e.getMessage(), startsWith(\"key at index\"));\n      }\n    } else if (list.stream().anyMatch(e -> e.getValue() == null)) {\n      // PairList.immutable should throw if there are null values\n      try {\n        Object o = pairList.immutable();\n        fail(\"expected error, got \" + o);\n      } catch (NullPointerException e) {\n        assertThat(e.getMessage(), startsWith(\"value at index\"));\n      }\n    } else {\n      final PairList<T, U> immutablePairList = pairList.immutable();\n      assertThat(immutablePairList, hasSize(list.size()));\n      assertThat(immutablePairList, is(list));\n\n      list2.clear();\n      immutablePairList.forEach((k, v) -> list2.add(Pair.of(k, v)));\n      assertThat(list2, is(list));\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Compares a {@link PairList} with a {@link List} that should have\nequivalent contents."}, {"uris": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java.EnvironmentTest.[void]checkOptimizeSubEnvironment(Environment)", "name": "checkOptimizeSubEnvironment", "arg_nums": 1, "params": [{"name": "e0", "type": "Environment"}], "return_type": "void", "signature": "private void checkOptimizeSubEnvironment(Environment e0)", "original_string": "  private void checkOptimizeSubEnvironment(Environment e0) {\n    final Set<String> nameSet = ImmutableSet.of(\"false\", \"true\", \"a\", \"b\", \"c\");\n    final Set<String> namePlusFooSet =\n        ImmutableSet.<String>builder().addAll(nameSet).add(\"foo\").build();\n\n    assertThat(e0.getValueMap().keySet(), is(nameSet));\n    assertThat(e0, hasEnvLength(5));\n\n    // Overwrite \"true\"; there are still 5 values, but 6 bindings.\n    final Environment e1 =\n        e0.bind(core.idPat(PrimitiveType.STRING, \"true\", 0), \"yes\");\n    assertThat(e1.getValueMap().keySet(), is(nameSet));\n    assertThat(e1, hasEnvLength(6));\n\n    // Overwrite \"true\" again; still 5 values, and still 6 bindings.\n    final Environment e2 =\n        e1.bind(core.idPat(PrimitiveType.STRING, \"true\", 0), \"no\");\n    assertThat(e2.getValueMap().keySet(), is(nameSet));\n    assertThat(e2, hasEnvLength(6));\n\n    // Add \"foo\". Value count and binding count increase.\n    final Environment e3 =\n        e2.bind(core.idPat(PrimitiveType.STRING, \"foo\", 0), \"baz\");\n    assertThat(e3.getValueMap().keySet(), is(namePlusFooSet));\n    assertThat(e3, hasEnvLength(7));\n\n    // Add \"true\". Value count stays at 7, binding count increases.\n    // (We do not look beyond the \"foo\" for the \"true\"; such optimization would\n    // be nice, but is expensive, so we do not do it.)\n    final Environment e4 =\n        e3.bind(core.idPat(PrimitiveType.STRING, \"true\", 0), \"yes\");\n    assertThat(e4.getValueMap().keySet(), is(namePlusFooSet));\n    assertThat(e4, hasEnvLength(8));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java", "class_name": "EnvironmentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java.EnvironmentTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java.EnvironmentTest.[Matcher<Environment>]hasEnvLength(int)", "name": "hasEnvLength", "arg_nums": 1, "params": [{"name": "i", "type": "int"}], "return_type": "Matcher<Environment>", "signature": "private Matcher<Environment> hasEnvLength(int i)", "original_string": "  private Matcher<Environment> hasEnvLength(int i) {\n    return new CustomTypeSafeMatcher<Environment>(\"environment depth \" + i) {\n      @Override protected boolean matchesSafely(Environment env) {\n        return depth(env) == i;\n      }\n\n      private int depth(Environment env) {\n        final AtomicInteger c = new AtomicInteger();\n        env.visit(b -> c.incrementAndGet());\n        return c.get();\n      }\n    };\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java", "class_name": "EnvironmentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java.EnvironmentTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Matcher<Environment>", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        backingList = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\", \"d\"));\n        tailList = new TailList<>(backingList, 2);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java", "class_name": "TailList_clearTest", "class_uri": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        sat = new Sat();\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java", "class_name": "Sat_variableTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "  public static void main(String[] args) {\n    final List<String> argList = ImmutableList.copyOf(args);\n    final Map<String, ForeignValue> valueMap = ImmutableMap.of();\n    final Map<Prop, Object> propMap = new LinkedHashMap<>();\n    Prop.DIRECTORY.set(propMap, new File(System.getProperty(\"user.dir\")));\n    final Main main =\n        new Main(argList, System.in, System.out, valueMap, propMap, false);\n    try {\n      main.run();\n    } catch (Throwable e) {\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Main.java", "class_name": "Main", "class_uri": "src/main/java/net/hydromatic/morel/Main.java.Main", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Command-line entry point.\n\n@param args Command-line arguments"}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main.[]Main(List<String>,InputStream,PrintStream,Map<String, ForeignValue>,Map<Prop, Object>,boolean)", "name": "Main", "arg_nums": 6, "params": [{"name": "args", "type": "List<String>"}, {"name": "in", "type": "InputStream"}, {"name": "out", "type": "PrintStream"}, {"name": "valueMap", "type": "Map<String, ForeignValue>"}, {"name": "propMap", "type": "Map<Prop, Object>"}, {"name": "idempotent", "type": "boolean"}], "return_type": "", "signature": "public Main(List<String> args, InputStream in, PrintStream out,\n      Map<String, ForeignValue> valueMap, Map<Prop, Object> propMap,\n      boolean idempotent)", "original_string": "  public Main(List<String> args, InputStream in, PrintStream out,\n      Map<String, ForeignValue> valueMap, Map<Prop, Object> propMap,\n      boolean idempotent) {\n    this(args, new InputStreamReader(in), new OutputStreamWriter(out),\n        valueMap, propMap, idempotent);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Main.java", "class_name": "Main", "class_uri": "src/main/java/net/hydromatic/morel/Main.java.Main", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a Main."}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main.[]Main(List<String>,Reader,Writer,Map<String, ForeignValue>,Map<Prop, Object>,boolean)", "name": "Main", "arg_nums": 6, "params": [{"name": "argList", "type": "List<String>"}, {"name": "in", "type": "Reader"}, {"name": "out", "type": "Writer"}, {"name": "valueMap", "type": "Map<String, ForeignValue>"}, {"name": "propMap", "type": "Map<Prop, Object>"}, {"name": "idempotent", "type": "boolean"}], "return_type": "", "signature": "public Main(List<String> argList, Reader in, Writer out,\n      Map<String, ForeignValue> valueMap, Map<Prop, Object> propMap,\n      boolean idempotent)", "original_string": "  public Main(List<String> argList, Reader in, Writer out,\n      Map<String, ForeignValue> valueMap, Map<Prop, Object> propMap,\n      boolean idempotent) {\n    this.in = buffer(idempotent ? stripOutLines(in) : in);\n    this.out = buffer(out);\n    this.echo = argList.contains(\"--echo\");\n    this.valueMap = ImmutableMap.copyOf(valueMap);\n    this.session = new Session(propMap);\n    this.idempotent = idempotent;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Main.java", "class_name": "Main", "class_uri": "src/main/java/net/hydromatic/morel/Main.java.Main", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a Main."}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main.[void]readerToString(Reader,StringBuilder)", "name": "readerToString", "arg_nums": 2, "params": [{"name": "r", "type": "Reader"}, {"name": "b", "type": "StringBuilder"}], "return_type": "void", "signature": "private static void readerToString(Reader r, StringBuilder b)", "original_string": "  private static void readerToString(Reader r, StringBuilder b) {\n    final char[] chars = new char[1024];\n    try {\n      for (;;) {\n        final int read = r.read(chars);\n        if (read < 0) {\n          return;\n        }\n        b.append(chars, 0, read);\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Main.java", "class_name": "Main", "class_uri": "src/main/java/net/hydromatic/morel/Main.java.Main", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main.[Reader]stripOutLines(Reader)", "name": "stripOutLines", "arg_nums": 1, "params": [{"name": "in", "type": "Reader"}], "return_type": "Reader", "signature": "private static Reader stripOutLines(Reader in)", "original_string": "  private static Reader stripOutLines(Reader in) {\n    final StringBuilder b = new StringBuilder();\n    readerToString(in, b);\n    final String s = str(b);\n    for (int i = 0, n = s.length();;) {\n      int j0 = i == 0 && s.startsWith(\"> \") ? 0 : -1;\n      int j1 = s.indexOf(\"\\n> \", i);\n      int j2 = s.indexOf(\"(*)\", i);\n      int j3 = s.indexOf(\"(*\", i);\n      int j = min(j0, j1, j2, j3);\n      if (j < 0) {\n        b.append(s, i, n);\n        break;\n      }\n      if (j == j0 || j == j1) {\n        // Skip line beginning \"> \"\n        b.append(s, i, j);\n        int k = s.indexOf(\"\\n\", j + 2);\n        if (k < 0) {\n          k = n;\n        }\n        i = k;\n      } else if (j == j2) {\n        // If a line contains \"(*)\", next search begins at the start of the\n        // next line.\n        int k = s.indexOf(\"\\n\", j + \"(*)\".length());\n        if (k < 0) {\n          k = n;\n        }\n        b.append(s, i, k);\n        i = k;\n      } else if (j == j3) {\n        // If a line contains \"(*\", next search begins at the next \"*)\".\n        int k = s.indexOf(\"*)\", j + \"(*\".length());\n        if (k < 0) {\n          k = n;\n        }\n        b.append(s, i, k);\n        i = k;\n      }\n    }\n    return new StringReader(b.toString());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Main.java", "class_name": "Main", "class_uri": "src/main/java/net/hydromatic/morel/Main.java.Main", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Reader", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main.[int]min()", "name": "min", "arg_nums": 0, "params": [], "return_type": "int", "signature": "private static int min(int... ints)", "original_string": "  private static int min(int... ints) {\n    int count = 0;\n    int min = Integer.MAX_VALUE;\n    for (int i : ints) {\n      if (i >= 0) {\n        ++count;\n        if (i < min) {\n          min = i;\n        }\n      }\n    }\n    return count == 0 ? -1 : min;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Main.java", "class_name": "Main", "class_uri": "src/main/java/net/hydromatic/morel/Main.java.Main", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Returns the minimum non-negative value of the list, or -1 if all are\nnegative."}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main.[PrintWriter]buffer(Writer)", "name": "buffer", "arg_nums": 1, "params": [{"name": "out", "type": "Writer"}], "return_type": "PrintWriter", "signature": "private static PrintWriter buffer(Writer out)", "original_string": "  private static PrintWriter buffer(Writer out) {\n    if (out instanceof PrintWriter) {\n      return (PrintWriter) out;\n    } else {\n      if (!(out instanceof BufferedWriter)) {\n        out = new BufferedWriter(out);\n      }\n      return new PrintWriter(out);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Main.java", "class_name": "Main", "class_uri": "src/main/java/net/hydromatic/morel/Main.java.Main", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "PrintWriter", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main.[BufferedReader]buffer(Reader)", "name": "buffer", "arg_nums": 1, "params": [{"name": "in", "type": "Reader"}], "return_type": "BufferedReader", "signature": "private static BufferedReader buffer(Reader in)", "original_string": "  private static BufferedReader buffer(Reader in) {\n    if (in instanceof BufferedReader) {\n      return (BufferedReader) in;\n    } else {\n      return new BufferedReader(in);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Main.java", "class_name": "Main", "class_uri": "src/main/java/net/hydromatic/morel/Main.java.Main", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "BufferedReader", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/Main.java.Main.[void]run()", "name": "run", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void run()", "original_string": "  public void run() {\n    Environment env = Environments.env(typeSystem, session, valueMap);\n    final Consumer<String> echoLines = out::println;\n    final Consumer<String> outLines =\n        idempotent\n            ? x -> out.println(\"> \" + x.replace(\"\\n\", \"\\n> \"))\n            : echoLines;\n    final Map<String, Binding> outBindings = new LinkedHashMap<>();\n    final Shell shell = new Shell(this, env, echoLines, outLines, outBindings);\n    session.withShell(shell, outLines, session1 ->\n        shell.run(session1, new BufferingReader(in), echoLines, outLines));\n    out.flush();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Main.java", "class_name": "Main", "class_uri": "src/main/java/net/hydromatic/morel/Main.java.Main", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "  public static void main(String[] args) {\n    try {\n      final Config config =\n          parse(ConfigImpl.DEFAULT\n              .withDirectory(new File(System.getProperty(\"user.dir\"))),\n              ImmutableList.copyOf(args));\n      final Shell main = create(config, System.in, System.out);\n      main.run();\n    } catch (Throwable e) {\n      e.printStackTrace();\n      System.exit(1);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Command-line entry point.\n\n@param args Command-line arguments"}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[Shell]create(List<String>,InputStream,OutputStream)", "name": "create", "arg_nums": 3, "params": [{"name": "args", "type": "List<String>"}, {"name": "in", "type": "InputStream"}, {"name": "out", "type": "OutputStream"}], "return_type": "Shell", "signature": "public static Shell create(List<String> args, InputStream in,\n      OutputStream out)", "original_string": "  public static Shell create(List<String> args, InputStream in,\n      OutputStream out) throws IOException {\n    final Config config = parse(ConfigImpl.DEFAULT, args);\n    return create(config, in, out);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Shell", "classes": []}, "docstring": " Creates a Shell."}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[Shell]create(Config,InputStream,OutputStream)", "name": "create", "arg_nums": 3, "params": [{"name": "config", "type": "Config"}, {"name": "in", "type": "InputStream"}, {"name": "out", "type": "OutputStream"}], "return_type": "Shell", "signature": "public static Shell create(Config config, InputStream in,\n      OutputStream out)", "original_string": "  public static Shell create(Config config, InputStream in,\n      OutputStream out) throws IOException {\n    final TerminalBuilder builder = TerminalBuilder.builder();\n    builder.streams(in, out);\n    final ConfigImpl configImpl = (ConfigImpl) config;\n    builder.system(configImpl.system);\n    builder.dumb(configImpl.dumb);\n    if (configImpl.dumb) {\n      builder.type(\"dumb\");\n    }\n    final Terminal terminal = builder.build();\n    return new Shell(config, terminal);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Shell", "classes": []}, "docstring": " Creates a Shell."}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[]Shell(Config,Terminal)", "name": "Shell", "arg_nums": 2, "params": [{"name": "config", "type": "Config"}, {"name": "terminal", "type": "Terminal"}], "return_type": "", "signature": "public Shell(Config config, Terminal terminal)", "original_string": "  public Shell(Config config, Terminal terminal) {\n    this.config = (ConfigImpl) config;\n    this.terminal = terminal;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a Shell."}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[Config]parse(Config,List<String>)", "name": "parse", "arg_nums": 2, "params": [{"name": "config", "type": "Config"}, {"name": "argList", "type": "List<String>"}], "return_type": "Config", "signature": "public static Config parse(Config config, List<String> argList)", "original_string": "  public static Config parse(Config config, List<String> argList) {\n    ConfigImpl c = (ConfigImpl) config;\n    final ImmutableMap.Builder<String, ForeignValue> valueMapBuilder =\n        ImmutableMap.builder();\n    for (String arg : argList) {\n      if (arg.equals(\"--banner=false\")) {\n        c = c.withBanner(false);\n      }\n      if (arg.equals(\"--terminal=dumb\")) {\n        c = c.withDumb(true);\n      }\n      if (arg.equals(\"--echo\")) {\n        c = c.withEcho(true);\n      }\n      if (arg.equals(\"--help\")) {\n        c = c.withHelp(true);\n      }\n      if (arg.equals(\"--system=false\")) {\n        c = c.withSystem(false);\n      }\n      if (arg.startsWith(\"--foreign=\")) {\n        final String className = arg.substring(\"--foreign=\".length());\n        @SuppressWarnings(\"unchecked\") final Map<String, DataSet> map =\n            instantiate(className, Map.class);\n        valueMapBuilder.putAll(Calcite.withDataSets(map).foreignValues());\n      }\n      if (arg.startsWith(\"--directory=\")) {\n        final String directoryPath = arg.substring(\"--directory=\".length());\n        c = c.withDirectory(new File(directoryPath));\n      }\n      if (arg.startsWith(\"--maxUseDepth=\")) {\n        int maxUseDepth =\n            Integer.parseInt(arg.substring(\"--maxUseDepth=\".length()));\n        c = c.withMaxUseDepth(maxUseDepth);\n      }\n    }\n\n    return c.withValueMap(valueMapBuilder.build());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Config", "classes": []}, "docstring": " Parses an argument list to an equivalent Config."}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]usage(Consumer<String>)", "name": "usage", "arg_nums": 1, "params": [{"name": "outLines", "type": "Consumer<String>"}], "return_type": "void", "signature": "static void usage(Consumer<String> outLines)", "original_string": "  static void usage(Consumer<String> outLines) {\n    String[] usageLines = {\n        \"Usage: java \" + Shell.class.getName(),\n    };\n    Arrays.asList(usageLines).forEach(outLines);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]help(Consumer<String>)", "name": "help", "arg_nums": 1, "params": [{"name": "outLines", "type": "Consumer<String>"}], "return_type": "void", "signature": "static void help(Consumer<String> outLines)", "original_string": "  static void help(Consumer<String> outLines) {\n    String[] helpLines = {\n        \"List of available commands:\",\n        \"    help   Print this help\",\n        \"    quit   Quit shell\",\n    };\n    Arrays.asList(helpLines).forEach(outLines);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]pause()", "name": "pause", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected final void pause()", "original_string": "  protected final void pause() {\n    config.pauseFn.run();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Pauses after creating the terminal.\n\n<p>Calls the value set by {@link Config#withPauseFn(Runnable)} which,\nfor the default config, does nothing;\nthe instance used in testing pauses for a few milliseconds,\nwhich gives classes time to load and makes test deterministic."}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[boolean]canIgnoreLine(StringBuilder,String)", "name": "canIgnoreLine", "arg_nums": 2, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "line", "type": "String"}], "return_type": "boolean", "signature": "private static boolean canIgnoreLine(StringBuilder buf, String line)", "original_string": "  private static boolean canIgnoreLine(StringBuilder buf, String line) {\n    final String trimmedLine = line\n        .replaceAll(\"\\\\(\\\\*.*\\\\*\\\\)\", \"\")\n        .replaceAll(\"\\\\(\\\\*\\\\) .*$\", \"\")\n        .trim();\n    return buf.length() == 0\n        && (trimmedLine.isEmpty() || trimmedLine.equals(\";\"));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether we can ignore a line. We can ignore a line if it consists\nonly of comments, spaces, and optionally semicolon, and if we are not on a\ncontinuation line."}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[String]banner()", "name": "banner", "arg_nums": 0, "params": [], "return_type": "String", "signature": "private String banner()", "original_string": "  private String banner() {\n    return \"morel version 0.4.0\"\n        + \" (java version \\\"\" + System.getProperty(\"java.version\")\n        + \"\\\", JRE \" + System.getProperty(\"java.vendor.version\")\n        + \" (build \" + System.getProperty(\"java.vm.version\")\n        + \"), \" + terminal.getName()\n        + \", \" + terminal.getType() + \")\";\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Generates a banner to be shown on startup."}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[void]run()", "name": "run", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void run()", "original_string": "  public void run() {\n    if (config.help) {\n      usage(terminal.writer()::println);\n      return;\n    }\n\n    final Parser parser = new DefaultParser() {\n      {\n        setEofOnUnclosedQuote(true);\n        setEofOnUnclosedBracket(DefaultParser.Bracket.CURLY,\n            DefaultParser.Bracket.ROUND, DefaultParser.Bracket.SQUARE);\n      }\n\n      @Override public ParsedLine parse(String line, int cursor,\n          ParseContext context) {\n        // Remove from \"(*)\" to end of line, if present\n        if (line.matches(\".*\\\\(\\\\*\\\\).*\")) {\n          line = line.replaceAll(\"\\\\(\\\\*\\\\).*$\", \"\");\n        }\n        return super.parse(line, cursor, context);\n      }\n    };\n\n    final String equalsPrompt = new AttributedStringBuilder()\n        .style(AttributedStyle.DEFAULT.bold()).append(\"=\")\n        .style(AttributedStyle.DEFAULT).append(\" \")\n        .toAnsi(terminal);\n    final String minusPrompt = new AttributedStringBuilder()\n        .style(AttributedStyle.DEFAULT.bold()).append(\"-\")\n        .style(AttributedStyle.DEFAULT).append(\" \")\n        .toAnsi(terminal);\n\n    if (config.banner) {\n      terminal.writer().println(banner());\n    }\n    LineReader lineReader = LineReaderBuilder.builder()\n        .appName(\"morel\")\n        .terminal(terminal)\n        .parser(parser)\n        .variable(LineReader.SECONDARY_PROMPT_PATTERN, equalsPrompt)\n        .build();\n\n    pause();\n    final TypeSystem typeSystem = new TypeSystem();\n    final Map<Prop, Object> map = new LinkedHashMap<>();\n    Prop.DIRECTORY.set(map, config.directory);\n    Prop.SCRIPT_DIRECTORY.set(map, config.directory);\n    final Session session = new Session(map);\n    Environment env = Environments.env(typeSystem, session, config.valueMap);\n    final LineFn lineFn =\n        new TerminalLineFn(minusPrompt, equalsPrompt, lineReader);\n    final SubShell subShell =\n        new SubShell(1, config.maxUseDepth, lineFn, config.echo, typeSystem,\n            env, terminal.writer()::println, session, config.directory);\n    final Map<String, Binding> bindings = new LinkedHashMap<>();\n    subShell.extracted(bindings);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/Shell.java.Shell.[T]instantiate(String,Class<T>)", "name": "instantiate", "arg_nums": 2, "params": [{"name": "className", "type": "String"}, {"name": "clazz", "type": "Class<T>"}], "return_type": "T", "signature": "@NonNull private static <T> T instantiate(String className,\n      @SuppressWarnings(\"SameParameterValue\") Class<T> clazz)", "original_string": "  @NonNull private static <T> T instantiate(String className,\n      @SuppressWarnings(\"SameParameterValue\") Class<T> clazz) {\n    try {\n      final Class<?> aClass = Class.forName(className);\n      return clazz.cast(aClass.getConstructor().newInstance());\n    } catch (ClassNotFoundException | NoSuchMethodException\n        | InstantiationException | InvocationTargetException\n        | IllegalAccessException e) {\n      throw new RuntimeException(\"Cannot load class: \" + className, e);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/Shell.java", "class_name": "Shell", "class_uri": "src/main/java/net/hydromatic/morel/Shell.java.Shell", "attributes": {"modifiers": "@NonNull private static", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "T", "classes": []}, "docstring": " Instantiates a class.\n\n<p>Assumes that the class has a public no-arguments constructor."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[]AstWriter(StringBuilder,boolean)", "name": "AstWriter", "arg_nums": 2, "params": [{"name": "b", "type": "StringBuilder"}, {"name": "parenthesize", "type": "boolean"}], "return_type": "", "signature": "private AstWriter(StringBuilder b, boolean parenthesize)", "original_string": "  private AstWriter(StringBuilder b, boolean parenthesize) {\n    this.b = new StringBuilder();\n    this.parenthesize = parenthesize;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[]AstWriter()", "name": "AstWriter", "arg_nums": 0, "params": [], "return_type": "", "signature": "public AstWriter()", "original_string": "  public AstWriter() {\n    this(new StringBuilder(), false);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return b.toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": " {@inheritDoc}\n\n<p>Returns the ML source code generated by this writer."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]withParenthesize(boolean)", "name": "withParenthesize", "arg_nums": 1, "params": [{"name": "parenthesize", "type": "boolean"}], "return_type": "AstWriter", "signature": "public AstWriter withParenthesize(boolean parenthesize)", "original_string": "  public AstWriter withParenthesize(boolean parenthesize) {\n    return parenthesize == this.parenthesize ? this\n        : new AstWriter(this.b, parenthesize);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Returns a writer that wraps everything in parentheses."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]append(String)", "name": "append", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "AstWriter", "signature": "public AstWriter append(String s)", "original_string": "  public AstWriter append(String s) {\n    b.append(s);\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a string to the output."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]id(String)", "name": "id", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "AstWriter", "signature": "public AstWriter id(String s)", "original_string": "  public AstWriter id(String s) {\n    b.append(s);\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends an identifier to the output."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]id(String,int)", "name": "id", "arg_nums": 2, "params": [{"name": "s", "type": "String"}, {"name": "i", "type": "int"}], "return_type": "AstWriter", "signature": "public AstWriter id(String s, int i)", "original_string": "  public AstWriter id(String s, int i) {\n    b.append(s);\n    if (i > 0) {\n      b.append('_').append(i);\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a ordinal-qualified-identifier to the output.\n\n<p>Prints \"v\" for {@code id(\"v\", 0)}, \"v#1\" for {@code id(\"v\", 1)},\nand so forth."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]infix(int,AstNode,Op,AstNode,int)", "name": "infix", "arg_nums": 5, "params": [{"name": "left", "type": "int"}, {"name": "a0", "type": "AstNode"}, {"name": "op", "type": "Op"}, {"name": "a1", "type": "AstNode"}, {"name": "right", "type": "int"}], "return_type": "AstWriter", "signature": "public AstWriter infix(int left, AstNode a0, Op op, AstNode a1, int right)", "original_string": "  public AstWriter infix(int left, AstNode a0, Op op, AstNode a1, int right) {\n    if (op == Op.APPLY && a0.op == Op.ID) {\n      if (a0 instanceof Ast.Id) {\n        final Op op2 = Op.BY_OP_NAME.get(((Ast.Id) a0).name);\n        if (op2 != null && op2.left > 0) {\n          final List<Ast.Exp> args = ((Ast.Tuple) a1).args;\n          final Ast.InfixCall call =\n              new Ast.InfixCall(Pos.ZERO, op2, args.get(0), args.get(1));\n          return call.unparse(this, left, right);\n        }\n      }\n      if (a0 instanceof Core.Id) {\n        // TODO: obsolete Core.Id for these purposes. The operator should\n        // be a function literal, and we would use a reverse mapping to\n        // figure out which built-in operator it implements, and whether it\n        // is infix (e.g. \"+\") or in a namespace (e.g. \"#translate String\")\n        final Op op2 = Op.BY_OP_NAME.get(((Core.Id) a0).idPat.name);\n        if (op2 != null && op2.left > 0) {\n          final List<Core.Exp> args = ((Core.Tuple) a1).args;\n          return infix(left, args.get(0), op2, args.get(1), right);\n        }\n      }\n    }\n    final boolean p = parenthesize || left > op.left || op.right < right;\n    if (p) {\n      b.append('(');\n      left = right = 0;\n    }\n    append(a0, left, op.left);\n    append(op.padded);\n    append(a1, op.right, right);\n    if (p) {\n      b.append(')');\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a call to an infix operator."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]prefix(int,Op,AstNode,int)", "name": "prefix", "arg_nums": 4, "params": [{"name": "left", "type": "int"}, {"name": "op", "type": "Op"}, {"name": "a", "type": "AstNode"}, {"name": "right", "type": "int"}], "return_type": "AstWriter", "signature": "public AstWriter prefix(int left, Op op, AstNode a, int right)", "original_string": "  public AstWriter prefix(int left, Op op, AstNode a, int right) {\n    final boolean p = parenthesize || left > op.left || op.right < right;\n    if (p) {\n      b.append('(');\n      right = 0;\n    }\n    append(op.padded);\n    a.unparse(this, op.right, right);\n    if (p) {\n      b.append(')');\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a call to an prefix operator."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]binary(String,AstNode,String,AstNode,int)", "name": "binary", "arg_nums": 5, "params": [{"name": "left", "type": "String"}, {"name": "a0", "type": "AstNode"}, {"name": "mid", "type": "String"}, {"name": "a1", "type": "AstNode"}, {"name": "right", "type": "int"}], "return_type": "AstWriter", "signature": "public AstWriter binary(String left, AstNode a0, String mid, AstNode a1,\n      int right)", "original_string": "  public AstWriter binary(String left, AstNode a0, String mid, AstNode a1,\n      int right) {\n    append(left);\n    a0.unparse(this, 0, 0);\n    append(mid);\n    a1.unparse(this, 0, right);\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a call to a binary operator (e.g. \"val ... = ...\")."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]binary(String,AstNode,String,AstNode,String)", "name": "binary", "arg_nums": 5, "params": [{"name": "left", "type": "String"}, {"name": "a0", "type": "AstNode"}, {"name": "mid", "type": "String"}, {"name": "a1", "type": "AstNode"}, {"name": "right", "type": "String"}], "return_type": "AstWriter", "signature": "public AstWriter binary(String left, AstNode a0, String mid, AstNode a1,\n      String right)", "original_string": "  public AstWriter binary(String left, AstNode a0, String mid, AstNode a1,\n      String right) {\n    append(left);\n    a0.unparse(this, 0, 0);\n    append(mid);\n    a1.unparse(this, 0, 0);\n    append(right);\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a call to a binary operator (e.g. \"let ... in ... end\")."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]append(AstNode,int,int)", "name": "append", "arg_nums": 3, "params": [{"name": "node", "type": "AstNode"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "return_type": "AstWriter", "signature": "public AstWriter append(AstNode node, int left, int right)", "original_string": "  public AstWriter append(AstNode node, int left, int right) {\n    final boolean p =\n        parenthesize || left > node.op.left || node.op.right < right;\n    if (p) {\n      b.append('(');\n      left = right = 0;\n    }\n    node.unparse(this, left, right);\n    if (p) {\n      b.append(')');\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a parse tree node."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendAll(Iterable<? extends AstNode>,int,Op,int)", "name": "appendAll", "arg_nums": 4, "params": [{"name": "nodes", "type": "Iterable<? extends AstNode>"}, {"name": "left", "type": "int"}, {"name": "op", "type": "Op"}, {"name": "right", "type": "int"}], "return_type": "AstWriter", "signature": "public AstWriter appendAll(Iterable<? extends AstNode> nodes, int left, Op op,\n      int right)", "original_string": "  public AstWriter appendAll(Iterable<? extends AstNode> nodes, int left, Op op,\n      int right) {\n    @SuppressWarnings(\"unchecked\")\n    final List<AstNode> nodeList = nodes instanceof List\n        ? (List) nodes : Lists.newArrayList(nodes);\n    for (int i = 0; i < nodeList.size(); i++) {\n      final AstNode node = nodeList.get(i);\n      final int thisLeft = i == 0 ? left : op.left;\n      final int thisRight = i == nodeList.size() - 1 ? right : op.right;\n      if (i > 0) {\n        append(op.padded);\n      }\n      append(node, thisLeft, thisRight);\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a list of parse tree nodes."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendAll(Iterable<? extends AstNode>,String)", "name": "appendAll", "arg_nums": 2, "params": [{"name": "list", "type": "Iterable<? extends AstNode>"}, {"name": "sep", "type": "String"}], "return_type": "AstWriter", "signature": "public AstWriter appendAll(Iterable<? extends AstNode> list, String sep)", "original_string": "  public AstWriter appendAll(Iterable<? extends AstNode> list, String sep) {\n    return appendAll(list, \"\", sep, \"\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a list of parse tree nodes separated by {@code sep}."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendAll(Iterable<? extends AstNode>,String,String,String)", "name": "appendAll", "arg_nums": 4, "params": [{"name": "list", "type": "Iterable<? extends AstNode>"}, {"name": "start", "type": "String"}, {"name": "sep", "type": "String"}, {"name": "end", "type": "String"}], "return_type": "AstWriter", "signature": "public AstWriter appendAll(Iterable<? extends AstNode> list, String start,\n      String sep, String end)", "original_string": "  public AstWriter appendAll(Iterable<? extends AstNode> list, String start,\n      String sep, String end) {\n    return appendAll(list, start, sep, end, \"\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a list of parse tree nodes separated by {@code sep}, and also with\nprefix and suffix: {@code start node0 sep node1 ... sep nodeN end}."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendAll(Iterable<? extends AstNode>,String,String,String,String)", "name": "appendAll", "arg_nums": 5, "params": [{"name": "list", "type": "Iterable<? extends AstNode>"}, {"name": "start", "type": "String"}, {"name": "sep", "type": "String"}, {"name": "end", "type": "String"}, {"name": "empty", "type": "String"}], "return_type": "AstWriter", "signature": "public AstWriter appendAll(Iterable<? extends AstNode> list, String start,\n      String sep, String end, String empty)", "original_string": "  public AstWriter appendAll(Iterable<? extends AstNode> list, String start,\n      String sep, String end, String empty) {\n    String s = start;\n    int i = 0;\n    for (AstNode node : list) {\n      ++i;\n      append(s);\n      s = sep;\n      append(node, 0, 0);\n    }\n    if (i == 0 && empty != null) {\n      append(empty);\n    } else {\n      append(end);\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": " Appends a list of parse tree nodes separated by {@code sep}, and also with\nprefix and suffix: {@code start node0 sep node1 ... sep nodeN end}."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter.[AstWriter]appendLiteral(Comparable)", "name": "appendLiteral", "arg_nums": 1, "params": [{"name": "value", "type": "Comparable"}], "return_type": "AstWriter", "signature": "public AstWriter appendLiteral(Comparable value)", "original_string": "  public AstWriter appendLiteral(Comparable value) {\n    if (value instanceof String) {\n      append(\"\\\"\")\n          .append(((String) value)\n              .replace(\"\\\\\", \"\\\\\\\\\")\n              .replace(\"\\\"\", \"\\\\\\\"\"))\n          .append(\"\\\"\");\n    } else if (value instanceof Character) {\n      final Character c = (Character) value;\n      append(\"#\\\"\")\n          .append(c == '\"' ? \"\\\\\\\"\"\n              : c == '\\\\' ? \"\\\\\\\\\"\n                  : c.toString())\n          .append(\"\\\"\");\n    } else if (value instanceof BigDecimal) {\n      BigDecimal c = (BigDecimal) value;\n      if (c.compareTo(BigDecimal.ZERO) < 0) {\n        append(\"~\");\n        c = c.negate();\n      }\n      append(c.toString());\n    } else if (value instanceof BuiltIn) {\n      final BuiltIn builtIn = (BuiltIn) value;\n      if (builtIn.structure != null && !builtIn.structure.equals(\"$\")) {\n        // E.g. \"#find List\" for the List.find function\n        append(\"#\").append(builtIn.mlName)\n            .append(\" \").append(builtIn.structure);\n      } else {\n        append(builtIn.mlName);\n      }\n    } else {\n      append(value.toString());\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstWriter.java", "class_name": "AstWriter", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstWriter.java.AstWriter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[]Pos(String,int,int,int,int)", "name": "Pos", "arg_nums": 5, "params": [{"name": "file", "type": "String"}, {"name": "startLine", "type": "int"}, {"name": "startColumn", "type": "int"}, {"name": "endLine", "type": "int"}, {"name": "endColumn", "type": "int"}], "return_type": "", "signature": "public Pos(String file, int startLine, int startColumn,\n      int endLine, int endColumn)", "original_string": "  public Pos(String file, int startLine, int startColumn,\n      int endLine, int endColumn) {\n    this.file = file;\n    this.startLine = startLine;\n    this.startColumn = startColumn;\n    this.endLine = endLine;\n    this.endColumn = endColumn;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a Pos."}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]of(String,String,int,int)", "name": "of", "arg_nums": 4, "params": [{"name": "ml", "type": "String"}, {"name": "file", "type": "String"}, {"name": "startOffset", "type": "int"}, {"name": "endOffset", "type": "int"}], "return_type": "Pos", "signature": "public static Pos of(String ml, String file, int startOffset, int endOffset)", "original_string": "  public static Pos of(String ml, String file, int startOffset, int endOffset) {\n    IntPair start = lineCol(ml, startOffset);\n    IntPair end = lineCol(ml, endOffset);\n    return new Pos(file, start.source, start.target, end.source, end.target);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": " Creates a Pos from two offsets."}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pair<@NonNull String, @NonNull Pos>]split(String,char,String)", "name": "split", "arg_nums": 3, "params": [{"name": "s", "type": "String"}, {"name": "delimiter", "type": "char"}, {"name": "file", "type": "String"}], "return_type": "Pair<@NonNull String, @NonNull Pos>", "signature": "public static Pair<@NonNull String, @NonNull Pos> split(String s,\n      char delimiter, String file)", "original_string": "  public static Pair<@NonNull String, @NonNull Pos> split(String s,\n      char delimiter, String file) {\n    final int i = s.indexOf(delimiter);\n    final int j = s.indexOf(delimiter, i + 1);\n    final int k = s.indexOf(delimiter, j + 1);\n    if (i < 0 || j <= i || k >= 0) {\n      throw new IllegalArgumentException(\"expected exactly two occurrences \"\n          + \"of delimiter, '\" + delimiter + \"'\");\n    }\n    final String s2 = s.substring(0, i)\n        + s.substring(i + 1, j)\n        + s.substring(j + 1);\n    final Pos pos = of(s2, file, i, j - 1);\n    return Pair.of(s2, pos);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Pair<@NonNull String, @NonNull Pos>", "classes": []}, "docstring": " Creates a Pos from a filename and a string with a delimiter character.\nThe delimiter must occur exactly twice in the string."}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override public int hashCode()", "original_string": "  @Override public int hashCode() {\n    return Objects.hash(startLine, startColumn, endLine, endColumn);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "boolean", "signature": "@Override public boolean equals(Object o)", "original_string": "  @Override public boolean equals(Object o) {\n    return o == this\n        || o instanceof Pos\n        && this.startLine == ((Pos) o).startLine\n        && this.startColumn == ((Pos) o).startColumn\n        && this.endLine == ((Pos) o).endLine\n        && this.endColumn == ((Pos) o).endColumn;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return describeTo(new StringBuilder()).toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[StringBuilder]describeTo(StringBuilder)", "name": "describeTo", "arg_nums": 1, "params": [{"name": "buf", "type": "StringBuilder"}], "return_type": "StringBuilder", "signature": "public StringBuilder describeTo(StringBuilder buf)", "original_string": "  public StringBuilder describeTo(StringBuilder buf) {\n    buf.append(file)\n        .append(file.isEmpty() ? \"\" : \":\")\n        .append(startLine)\n        .append('.')\n        .append(startColumn);\n    if (endColumn != startColumn + 1 || endLine != startLine) {\n      buf.append('-')\n          .append(endLine)\n          .append('.')\n          .append(endColumn);\n    }\n    return buf;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum(Iterable<Pos>)", "name": "sum", "arg_nums": 1, "params": [{"name": "poses", "type": "Iterable<Pos>"}], "return_type": "Pos", "signature": "public static Pos sum(Iterable<Pos> poses)", "original_string": "  public static Pos sum(Iterable<Pos> poses) {\n    final List<Pos> list =\n        poses instanceof List\n            ? (List<Pos>) poses\n            : Lists.newArrayList(poses);\n    return sum_(list);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": "\nCombines an iterable of parser positions to create a position which spans\nfrom the beginning of the first to the end of the last.\n"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum(Iterable<E>,Function<E, Pos>)", "name": "sum", "arg_nums": 2, "params": [{"name": "elements", "type": "Iterable<E>"}, {"name": "fn", "type": "Function<E, Pos>"}], "return_type": "Pos", "signature": "public static <E> Pos sum(Iterable<E> elements, Function<E, Pos> fn)", "original_string": "  public static <E> Pos sum(Iterable<E> elements, Function<E, Pos> fn) {\n    //noinspection StaticPseudoFunctionalStyleMethod\n    return sum(Iterables.transform(elements, fn::apply));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum(List<? extends AstNode>)", "name": "sum", "arg_nums": 1, "params": [{"name": "nodes", "type": "List<? extends AstNode>"}], "return_type": "Pos", "signature": "public static Pos sum(List<? extends AstNode> nodes)", "original_string": "  public static Pos sum(List<? extends AstNode> nodes) {\n    return sum(nodes, node -> node.pos);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum_(List<Pos>)", "name": "sum_", "arg_nums": 1, "params": [{"name": "positions", "type": "List<Pos>"}], "return_type": "Pos", "signature": "private static Pos sum_(final List<Pos> positions)", "original_string": "  private static Pos sum_(final List<Pos> positions) {\n    switch (positions.size()) {\n    case 0:\n      throw new AssertionError();\n    case 1:\n      return positions.get(0);\n    default:\n      final List<Pos> poses = new AbstractList<Pos>() {\n        public Pos get(int index) {\n          return positions.get(index + 1);\n        }\n        public int size() {\n          return positions.size() - 1;\n        }\n      };\n      final Pos p = positions.get(0);\n      return sum(poses, p.startLine, p.startColumn, p.endLine, p.endColumn);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": "\nCombines a list of parser positions to create a position which spans\nfrom the beginning of the first to the end of the last.\n"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]sum(Iterable<Pos>,int,int,int,int)", "name": "sum", "arg_nums": 5, "params": [{"name": "poses", "type": "Iterable<Pos>"}, {"name": "line", "type": "int"}, {"name": "column", "type": "int"}, {"name": "endLine", "type": "int"}, {"name": "endColumn", "type": "int"}], "return_type": "Pos", "signature": "private static Pos sum(\n      Iterable<Pos> poses,\n      int line,\n      int column,\n      int endLine,\n      int endColumn)", "original_string": "  private static Pos sum(\n      Iterable<Pos> poses,\n      int line,\n      int column,\n      int endLine,\n      int endColumn) {\n    int testLine;\n    int testColumn;\n    String file = Pos.ZERO.file;\n    for (Pos pos : poses) {\n      if (pos == null || pos.equals(Pos.ZERO)) {\n        continue;\n      }\n      file = pos.file;\n      testLine = pos.startLine;\n      testColumn = pos.startColumn;\n      if (testLine < line || testLine == line && testColumn < column) {\n        line = testLine;\n        column = testColumn;\n      }\n\n      testLine = pos.endLine;\n      testColumn = pos.endColumn;\n      if (testLine > endLine || testLine == endLine && testColumn > endColumn) {\n        endLine = testLine;\n        endColumn = testColumn;\n      }\n    }\n    return new Pos(file, line, column, endLine, endColumn);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": "\nComputes the parser position which is the sum of an array of parser\npositions and of a parser position represented by (line, column, endLine,\nendColumn).\n\n@param poses     Array of parser positions\n@param line      Start line\n@param column    Start column\n@param endLine   End line\n@param endColumn End column\n@return Sum of parser positions\n"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]plus(Pos)", "name": "plus", "arg_nums": 1, "params": [{"name": "pos", "type": "Pos"}], "return_type": "Pos", "signature": "public Pos plus(Pos pos)", "original_string": "  public Pos plus(Pos pos) {\n    int startLine = this.startLine;\n    int startColumn = this.startColumn;\n    if (pos.startLine < startLine\n        || pos.startLine == startLine\n        && pos.startColumn < startColumn) {\n      startLine = pos.startLine;\n      startColumn = pos.startColumn;\n    }\n    int endLine = pos.endLine;\n    int endColumn = pos.endColumn;\n    if (this.endLine > endLine\n        || this.endLine == endLine\n        && this.endColumn > endColumn) {\n      endLine = this.endLine;\n      endColumn = this.endColumn;\n    }\n    return new Pos(file, startLine, startColumn, endLine, endColumn);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]plusAll(Iterable<Pos>)", "name": "plusAll", "arg_nums": 1, "params": [{"name": "poses", "type": "Iterable<Pos>"}], "return_type": "Pos", "signature": "public Pos plusAll(Iterable<Pos> poses)", "original_string": "  public Pos plusAll(Iterable<Pos> poses) {\n    return sum(poses, startLine, startColumn, endLine, endColumn);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[Pos]plusAll(List<? extends AstNode>)", "name": "plusAll", "arg_nums": 1, "params": [{"name": "nodes", "type": "List<? extends AstNode>"}], "return_type": "Pos", "signature": "public Pos plusAll(@NonNull List<? extends AstNode> nodes)", "original_string": "  public Pos plusAll(@NonNull List<? extends AstNode> nodes) {\n    //noinspection StaticPseudoFunctionalStyleMethod,ConstantConditions\n    return plusAll(Lists.transform(nodes, (AstNode node) -> node.pos));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos.[IntPair]lineCol(String,int)", "name": "lineCol", "arg_nums": 2, "params": [{"name": "s", "type": "String"}, {"name": "offset", "type": "int"}], "return_type": "IntPair", "signature": "private static IntPair lineCol(String s, int offset)", "original_string": "  private static IntPair lineCol(String s, int offset) {\n    int line = 1;\n    int lineStart = 0;\n    int i;\n    final int n = Math.min(s.length(), offset);\n    for (i = 0; i < n; i++) {\n      if (s.charAt(i) == '\\n') {\n        ++line;\n        lineStart = i + 1;\n      }\n    }\n    if (i == offset) {\n      return IntPair.of(line, offset - lineStart + 1);\n    } else {\n      throw new IllegalArgumentException(\"not found\");\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Pos.java", "class_name": "Pos", "class_uri": "src/main/java/net/hydromatic/morel/ast/Pos.java.Pos", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "IntPair", "classes": []}, "docstring": " Returns the 1-based line."}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[]FromBuilder(TypeSystem,Environment)", "name": "FromBuilder", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}], "return_type": "", "signature": "FromBuilder(TypeSystem typeSystem, @Nullable Environment env)", "original_string": "  FromBuilder(TypeSystem typeSystem, @Nullable Environment env) {\n    this.typeSystem = typeSystem;\n    this.env = env;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": " Use {@link net.hydromatic.morel.ast.CoreBuilder#fromBuilder}."}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[void]clear()", "name": "clear", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void clear()", "original_string": "  public void clear() {\n    steps.clear();\n    bindings.clear();\n    removeIfNotLastIndex = Integer.MIN_VALUE;\n    removeIfLastIndex = Integer.MIN_VALUE;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Resets state as if this {@code FromBuilder} had just been created."}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return steps.toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[List<Binding>]bindings()", "name": "bindings", "arg_nums": 0, "params": [], "return_type": "List<Binding>", "signature": "public List<Binding> bindings()", "original_string": "  public List<Binding> bindings() {\n    return ImmutableList.copyOf(bindings);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Binding>", "classes": []}, "docstring": " Returns the bindings available after the most recent step."}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]addStep(Core.FromStep)", "name": "addStep", "arg_nums": 1, "params": [{"name": "step", "type": "Core.FromStep"}], "return_type": "FromBuilder", "signature": "private FromBuilder addStep(Core.FromStep step)", "original_string": "  private FromBuilder addStep(Core.FromStep step) {\n    if (env != null) {\n      // Validate the step. (Not necessary, but helps find bugs.)\n      RefChecker.of(typeSystem, env.bindAll(bindings))\n          .visitStep(step, bindings);\n    }\n    if (removeIfNotLastIndex == steps.size() - 1) {\n      // A trivial record yield with a single yield, e.g. 'yield {i = i}', has\n      // a purpose only if it is the last step. (It forces the return to be a\n      // record, e.g. '{i: int}' rather than a scalar 'int'.)\n      // We've just about to add a new step, so this is no longer necessary.\n      removeIfNotLastIndex = Integer.MIN_VALUE;\n      removeIfLastIndex = Integer.MIN_VALUE;\n      final Core.FromStep lastStep = getLast(steps);\n      if (lastStep.op == Op.YIELD) {\n        final Core.Yield yield = (Core.Yield) lastStep;\n        if (yield.exp.op == Op.TUPLE) {\n          final Core.Tuple tuple = (Core.Tuple) yield.exp;\n          final Core.FromStep previousStep = steps.get(steps.size() - 2);\n          final List<Binding> previousBindings = previousStep.bindings;\n          if (tuple.args.size() == 1\n              && isTrivial(tuple, previousBindings, yield.bindings)) {\n            steps.remove(steps.size() - 1);\n          }\n        }\n      }\n    }\n    steps.add(step);\n    if (!bindings.equals(step.bindings)) {\n      bindings.clear();\n      bindings.addAll(step.bindings);\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]scan(Core.Pat)", "name": "scan", "arg_nums": 1, "params": [{"name": "pat", "type": "Core.Pat"}], "return_type": "FromBuilder", "signature": "public FromBuilder scan(Core.Pat pat)", "original_string": "  public FromBuilder scan(Core.Pat pat) {\n    final Core.Exp extent =\n        core.extent(typeSystem, pat.type, ImmutableRangeSet.of(Range.all()));\n    return scan(pat, extent, core.boolLiteral(true));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": " Creates an unbounded scan, \"from pat\"."}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]scan(Core.Pat,Core.Exp)", "name": "scan", "arg_nums": 2, "params": [{"name": "pat", "type": "Core.Pat"}, {"name": "exp", "type": "Core.Exp"}], "return_type": "FromBuilder", "signature": "public FromBuilder scan(Core.Pat pat, Core.Exp exp)", "original_string": "  public FromBuilder scan(Core.Pat pat, Core.Exp exp) {\n    return scan(pat, exp, core.boolLiteral(true));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": " Creates a bounded scan, \"from pat in exp\"."}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]scan(Core.Pat,Core.Exp,Core.Exp)", "name": "scan", "arg_nums": 3, "params": [{"name": "pat", "type": "Core.Pat"}, {"name": "exp", "type": "Core.Exp"}, {"name": "condition", "type": "Core.Exp"}], "return_type": "FromBuilder", "signature": "public FromBuilder scan(Core.Pat pat, Core.Exp exp, Core.Exp condition)", "original_string": "  public FromBuilder scan(Core.Pat pat, Core.Exp exp, Core.Exp condition) {\n    if (exp.op == Op.FROM\n        && core.boolLiteral(true).equals(condition)\n        && (pat instanceof Core.IdPat\n            && !((Core.From) exp).steps.isEmpty()\n            && getLast(((Core.From) exp).steps).bindings.size() == 1\n            || pat instanceof Core.RecordPat\n                && ((Core.RecordPat) pat).args.stream()\n                    .allMatch(a -> a instanceof Core.IdPat)\n            || pat instanceof Core.TuplePat\n                && ((Core.TuplePat) pat).args.stream()\n                    .allMatch(a -> a instanceof Core.IdPat))) {\n      final Core.From from = (Core.From) exp;\n      final Core.FromStep lastStep = getLast(from.steps);\n      final List<Core.FromStep> steps =\n          lastStep.op == Op.YIELD ? Util.skipLast(from.steps) : from.steps;\n\n      final PairList<String, Core.Exp> nameExps = PairList.of();\n      boolean uselessIfLast = this.bindings.isEmpty();\n      final List<Binding> bindings;\n      if (pat instanceof Core.RecordPat) {\n        final Core.RecordPat recordPat = (Core.RecordPat) pat;\n        this.bindings.forEach(b -> nameExps.add(b.id.name, core.id(b.id)));\n        forEach(recordPat.type().argNameTypes.keySet(), recordPat.args,\n            (name, arg) -> nameExps.add(name, core.id((Core.IdPat) arg)));\n        bindings = null;\n      } else if (pat instanceof Core.TuplePat) {\n        final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n        forEach(tuplePat.args, lastStep.bindings,\n            (arg, binding) ->\n                nameExps.add(((Core.IdPat) arg).name, core.id(binding.id)));\n        bindings = null;\n      } else if (!this.bindings.isEmpty()) {\n        // With at least one binding, and one new variable, the output will be\n        // a record type.\n        final Core.IdPat idPat = (Core.IdPat) pat;\n        this.bindings.forEach(b -> nameExps.add(b.id.name, core.id(b.id)));\n        lastStep.bindings.forEach(b -> nameExps.add(idPat.name, core.id(b.id)));\n        bindings = null;\n      } else {\n        final Core.IdPat idPat = (Core.IdPat) pat;\n        if (lastStep instanceof Core.Yield\n            && ((Core.Yield) lastStep).exp.op != Op.RECORD) {\n          // The last step is a yield scalar, say 'yield x + 1'.\n          // Translate it to a yield singleton record, say 'yield {y = x + 1}'\n          addAll(steps);\n          if (((Core.Yield) lastStep).exp.op == Op.ID\n              && this.bindings.size() == 1) {\n            // The last step is 'yield e'. Skip it.\n            return this;\n          }\n          nameExps.add(idPat.name, ((Core.Yield) lastStep).exp);\n          bindings = ImmutableList.of(Binding.of(idPat));\n          return yield_(false, bindings, core.record(typeSystem, nameExps));\n        }\n        final Binding binding = Iterables.getOnlyElement(lastStep.bindings);\n        nameExps.add(idPat.name, core.id(binding.id));\n        bindings = append(this.bindings, Binding.of(idPat));\n      }\n      addAll(steps);\n      return yield_(uselessIfLast, bindings, core.record(typeSystem, nameExps));\n    }\n    Compiles.acceptBinding(typeSystem, pat, bindings);\n    return addStep(core.scan(bindings, pat, exp, condition));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]addAll(Iterable<? extends Core.FromStep>)", "name": "addAll", "arg_nums": 1, "params": [{"name": "steps", "type": "Iterable<? extends Core.FromStep>"}], "return_type": "FromBuilder", "signature": "public FromBuilder addAll(Iterable<? extends Core.FromStep> steps)", "original_string": "  public FromBuilder addAll(Iterable<? extends Core.FromStep> steps) {\n    final StepHandler stepHandler = new StepHandler();\n    steps.forEach(stepHandler::accept);\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]where(Core.Exp)", "name": "where", "arg_nums": 1, "params": [{"name": "condition", "type": "Core.Exp"}], "return_type": "FromBuilder", "signature": "public FromBuilder where(Core.Exp condition)", "original_string": "  public FromBuilder where(Core.Exp condition) {\n    if (condition.op == Op.BOOL_LITERAL\n        && ((Core.Literal) condition).unwrap(Boolean.class)) {\n      // skip \"where true\"\n      return this;\n    }\n    return addStep(core.where(bindings, condition));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]skip(Core.Exp)", "name": "skip", "arg_nums": 1, "params": [{"name": "count", "type": "Core.Exp"}], "return_type": "FromBuilder", "signature": "public FromBuilder skip(Core.Exp count)", "original_string": "  public FromBuilder skip(Core.Exp count) {\n    if (count.op == Op.INT_LITERAL\n        && ((Core.Literal) count).value.equals(BigDecimal.ZERO)) {\n      // skip \"skip 0\"\n      return this;\n    }\n    return addStep(core.skip(bindings, count));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]take(Core.Exp)", "name": "take", "arg_nums": 1, "params": [{"name": "count", "type": "Core.Exp"}], "return_type": "FromBuilder", "signature": "public FromBuilder take(Core.Exp count)", "original_string": "  public FromBuilder take(Core.Exp count) {\n    return addStep(core.take(bindings, count));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]group(SortedMap<Core.IdPat, Core.Exp>,SortedMap<Core.IdPat, Core.Aggregate>)", "name": "group", "arg_nums": 2, "params": [{"name": "groupExps", "type": "SortedMap<Core.IdPat, Core.Exp>"}, {"name": "aggregates", "type": "SortedMap<Core.IdPat, Core.Aggregate>"}], "return_type": "FromBuilder", "signature": "public FromBuilder group(SortedMap<Core.IdPat, Core.Exp> groupExps,\n      SortedMap<Core.IdPat, Core.Aggregate> aggregates)", "original_string": "  public FromBuilder group(SortedMap<Core.IdPat, Core.Exp> groupExps,\n      SortedMap<Core.IdPat, Core.Aggregate> aggregates) {\n    return addStep(core.group(groupExps, aggregates));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]order(Iterable<Core.OrderItem>)", "name": "order", "arg_nums": 1, "params": [{"name": "orderItems", "type": "Iterable<Core.OrderItem>"}], "return_type": "FromBuilder", "signature": "public FromBuilder order(Iterable<Core.OrderItem> orderItems)", "original_string": "  public FromBuilder order(Iterable<Core.OrderItem> orderItems) {\n    final List<Core.OrderItem> orderItemList = ImmutableList.copyOf(orderItems);\n    if (orderItemList.isEmpty()) {\n      // skip empty \"order\"\n      return this;\n    }\n    return addStep(core.order(bindings, orderItems));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]yield_(Core.Exp)", "name": "yield_", "arg_nums": 1, "params": [{"name": "exp", "type": "Core.Exp"}], "return_type": "FromBuilder", "signature": "public FromBuilder yield_(Core.Exp exp)", "original_string": "  public FromBuilder yield_(Core.Exp exp) {\n    return yield_(false, exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]yield_(boolean,Core.Exp)", "name": "yield_", "arg_nums": 2, "params": [{"name": "uselessIfLast", "type": "boolean"}, {"name": "exp", "type": "Core.Exp"}], "return_type": "FromBuilder", "signature": "public FromBuilder yield_(boolean uselessIfLast, Core.Exp exp)", "original_string": "  public FromBuilder yield_(boolean uselessIfLast, Core.Exp exp) {\n    return yield_(uselessIfLast, null, exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[FromBuilder]yield_(boolean,List<Binding>,Core.Exp)", "name": "yield_", "arg_nums": 3, "params": [{"name": "uselessIfLast", "type": "boolean"}, {"name": "bindings2", "type": "List<Binding>"}, {"name": "exp", "type": "Core.Exp"}], "return_type": "FromBuilder", "signature": "public FromBuilder yield_(boolean uselessIfLast,\n      @Nullable List<Binding> bindings2, Core.Exp exp)", "original_string": "  public FromBuilder yield_(boolean uselessIfLast,\n      @Nullable List<Binding> bindings2, Core.Exp exp) {\n    boolean uselessIfNotLast = false;\n    switch (exp.op) {\n    case TUPLE:\n      final TupleType tupleType =\n          tupleType((Core.Tuple) exp, bindings, bindings2);\n      switch (tupleType) {\n      case IDENTITY:\n        // A trivial record does not rename, so its only purpose is to change\n        // from a scalar to a record, and even then only when a singleton.\n        if (bindings.size() == 1) {\n          // Singleton record that does not rename, e.g. 'yield {x=x}'\n          // It only has meaning as the last step.\n          if (bindings2 == null) {\n            bindings2 = ImmutableList.copyOf(bindings);\n          }\n          uselessIfNotLast = true;\n          break;\n        } else {\n          // Non-singleton record that does not rename, e.g. 'yield {x=x,y=y}'\n          // It is useless.\n          return this;\n        }\n      case RENAME:\n        if (bindings.size() == 1) {\n          // Singleton record that renames, e.g. 'yield {y=x}'.\n          // It is always useful.\n          break;\n        } else {\n          // Non-singleton record that renames, e.g. 'yield {y=x,z=y}'\n          // It is always useful.\n          break;\n        }\n      }\n      break;\n\n    case ID:\n      if (bindings.size() == 1\n          && ((Core.Id) exp).idPat.equals(bindings.get(0).id)) {\n        return this;\n      }\n    }\n    addStep(bindings2 != null\n        ? core.yield_(bindings2, exp)\n        : core.yield_(typeSystem, exp));\n    removeIfNotLastIndex = uselessIfNotLast ? steps.size() - 1 : Integer.MIN_VALUE;\n    removeIfLastIndex = uselessIfLast ? steps.size() - 1 : Integer.MIN_VALUE;\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FromBuilder", "classes": []}, "docstring": " Creates a \"yield\" step.\n\n<p>When copying, the {@code bindings2} parameter is the\n{@link net.hydromatic.morel.ast.Core.Yield#bindings} value of the current\nYield, so that we don't generate new variables (with different ordinals).\nLater steps are relying on the variables remaining the same. For example,\nin\n\n<blockquote>{@code\nfrom ... yield {a = b} where a > 5\n}</blockquote>\n\n<p>the {@code a} in {@code a > 5} references {@code IdPat('a', 0)} and we\ndon't want yield to generate an {@code IdPat('a', 1)}.\n\n@param uselessIfLast Whether this Yield will be useless if it is the last\n                     step. The expression {@code {x = y} } is an example of\n                     this\n@param bindings2     Desired bindings, or null\n@param exp           Expression to yield\n\n@return This FromBuilder, with a Yield added to the list of steps\n"}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[boolean]isTrivial(Core.Tuple,List<Binding>,List<Binding>)", "name": "isTrivial", "arg_nums": 3, "params": [{"name": "tuple", "type": "Core.Tuple"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "bindings2", "type": "List<Binding>"}], "return_type": "boolean", "signature": "private static boolean isTrivial(Core.Tuple tuple, List<Binding> bindings,\n      @Nullable List<Binding> bindings2)", "original_string": "  private static boolean isTrivial(Core.Tuple tuple, List<Binding> bindings,\n      @Nullable List<Binding> bindings2) {\n    return tupleType(tuple, bindings, bindings2) == TupleType.IDENTITY;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether tuple is something like \"{i = i, j = j}\"."}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[TupleType]tupleType(Core.Tuple,List<Binding>,List<Binding>)", "name": "tupleType", "arg_nums": 3, "params": [{"name": "tuple", "type": "Core.Tuple"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "bindings2", "type": "List<Binding>"}], "return_type": "TupleType", "signature": "private static TupleType tupleType(Core.Tuple tuple, List<Binding> bindings,\n      @Nullable List<Binding> bindings2)", "original_string": "  private static TupleType tupleType(Core.Tuple tuple, List<Binding> bindings,\n      @Nullable List<Binding> bindings2) {\n    if (tuple.args.size() != bindings.size()) {\n      return TupleType.OTHER;\n    }\n    final ImmutableList<String> argNames =\n        ImmutableList.copyOf(tuple.type().argNameTypes().keySet());\n    boolean identity = bindings2 == null || bindings.equals(bindings2);\n    for (int i = 0; i < tuple.args.size(); i++) {\n      Core.Exp exp = tuple.args.get(i);\n      if (exp.op != Op.ID) {\n        return TupleType.OTHER;\n      }\n      if (!((Core.Id) exp).idPat.name.equals(argNames.get(i))) {\n        identity = false;\n      }\n    }\n    return identity ? TupleType.IDENTITY : TupleType.RENAME;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "TupleType", "classes": []}, "docstring": " Returns whether tuple is something like \"{i = i, j = j}\"."}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[Core.Exp]build(boolean)", "name": "build", "arg_nums": 1, "params": [{"name": "simplify", "type": "boolean"}], "return_type": "Core.Exp", "signature": "private Core.Exp build(boolean simplify)", "original_string": "  private Core.Exp build(boolean simplify) {\n    if (removeIfLastIndex == steps.size() - 1) {\n      removeIfLastIndex = Integer.MIN_VALUE;\n      final Core.Yield yield = (Core.Yield) getLast(steps);\n      if (yield.exp.op != Op.TUPLE\n          || ((Core.Tuple) yield.exp).args.size() != 1) {\n        throw new AssertionError(yield.exp);\n      }\n      steps.remove(steps.size() - 1);\n    }\n    if (simplify\n        && steps.size() == 1\n        && steps.get(0).op == Op.SCAN) {\n      final Core.Scan scan = (Core.Scan) steps.get(0);\n      if (scan.pat.op == Op.ID_PAT) {\n        return scan.exp;\n      }\n    }\n    return core.from(typeSystem, steps);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[Core.From]build()", "name": "build", "arg_nums": 0, "params": [], "return_type": "Core.From", "signature": "public Core.From build()", "original_string": "  public Core.From build() {\n    return (Core.From) build(false);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Core.From", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder.[Core.Exp]buildSimplify()", "name": "buildSimplify", "arg_nums": 0, "params": [], "return_type": "Core.Exp", "signature": "public Core.Exp buildSimplify()", "original_string": "  public Core.Exp buildSimplify() {\n    return build(true);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java", "class_name": "FromBuilder", "class_uri": "src/main/java/net/hydromatic/morel/ast/FromBuilder.java.FromBuilder", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": " As {@link #build}, but also simplifies \"from x in list\" to \"list\"."}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[]Shuttle(TypeSystem)", "name": "Shuttle", "arg_nums": 1, "params": [{"name": "typeSystem", "type": "TypeSystem"}], "return_type": "", "signature": "public Shuttle(TypeSystem typeSystem)", "original_string": "  public Shuttle(TypeSystem typeSystem) {\n    this.typeSystem = typeSystem;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a Shuttle."}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[List<E>]visitList(List<E>)", "name": "visitList", "arg_nums": 1, "params": [{"name": "nodes", "type": "List<E>"}], "return_type": "List<E>", "signature": "protected <E extends AstNode> List<E> visitList(List<E> nodes)", "original_string": "  protected <E extends AstNode> List<E> visitList(List<E> nodes) {\n    final List<E> list = new ArrayList<>();\n    for (E node : nodes) {\n      //noinspection unchecked\n      list.add((E) node.accept(this));\n    }\n    return list;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Map<K, E>]visitMap(Map<K, E>)", "name": "visitMap", "arg_nums": 1, "params": [{"name": "nodes", "type": "Map<K, E>"}], "return_type": "Map<K, E>", "signature": "protected <K, E extends AstNode> Map<K, E> visitMap(Map<K, E> nodes)", "original_string": "  protected <K, E extends AstNode> Map<K, E> visitMap(Map<K, E> nodes) {\n    final Map<K, E> map = new LinkedHashMap<>();\n    //noinspection unchecked\n    nodes.forEach((k, v) -> map.put(k, (E) v.accept(this)));\n    return map;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Map<K, E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[SortedMap<K, E>]visitSortedMap(SortedMap<K, E>)", "name": "visitSortedMap", "arg_nums": 1, "params": [{"name": "nodes", "type": "SortedMap<K, E>"}], "return_type": "SortedMap<K, E>", "signature": "protected <K, E extends AstNode> SortedMap<K, E> visitSortedMap(\n      SortedMap<K, E> nodes)", "original_string": "  protected <K, E extends AstNode> SortedMap<K, E> visitSortedMap(\n      SortedMap<K, E> nodes) {\n    final SortedMap<K, E> map = new TreeMap<>(nodes.comparator());\n    //noinspection unchecked\n    nodes.forEach((k, v) -> map.put(k, (E) v.accept(this)));\n    return map;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "SortedMap<K, E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.Literal)", "name": "visit", "arg_nums": 1, "params": [{"name": "literal", "type": "Ast.Literal"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.Literal literal)", "original_string": "  protected Ast.Exp visit(Ast.Literal literal) {\n    return literal; // leaf\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": " expressions"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Id]visit(Ast.Id)", "name": "visit", "arg_nums": 1, "params": [{"name": "id", "type": "Ast.Id"}], "return_type": "Ast.Id", "signature": "protected Ast.Id visit(Ast.Id id)", "original_string": "  protected Ast.Id visit(Ast.Id id) {\n    return id; // leaf\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Id", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.AnnotatedExp)", "name": "visit", "arg_nums": 1, "params": [{"name": "annotatedExp", "type": "Ast.AnnotatedExp"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.AnnotatedExp annotatedExp)", "original_string": "  protected Ast.Exp visit(Ast.AnnotatedExp annotatedExp) {\n    return ast.annotatedExp(annotatedExp.pos, annotatedExp.exp.accept(this),\n        annotatedExp.type.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.If)", "name": "visit", "arg_nums": 1, "params": [{"name": "ifThenElse", "type": "Ast.If"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.If ifThenElse)", "original_string": "  protected Ast.Exp visit(Ast.If ifThenElse) {\n    return ast.ifThenElse(ifThenElse.pos, ifThenElse.condition.accept(this),\n        ifThenElse.ifTrue.accept(this), ifThenElse.ifFalse.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Let]visit(Ast.Let)", "name": "visit", "arg_nums": 1, "params": [{"name": "let", "type": "Ast.Let"}], "return_type": "Ast.Let", "signature": "protected Ast.Let visit(Ast.Let let)", "original_string": "  protected Ast.Let visit(Ast.Let let) {\n    return ast.let(let.pos, visitList(let.decls), let.exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Let", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.Case)", "name": "visit", "arg_nums": 1, "params": [{"name": "caseOf", "type": "Ast.Case"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.Case caseOf)", "original_string": "  protected Ast.Exp visit(Ast.Case caseOf) {\n    return ast.caseOf(caseOf.pos, caseOf.exp.accept(this),\n        visitList(caseOf.matchList));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.InfixCall)", "name": "visit", "arg_nums": 1, "params": [{"name": "infixCall", "type": "Ast.InfixCall"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.InfixCall infixCall)", "original_string": "  protected Ast.Exp visit(Ast.InfixCall infixCall) {\n    return ast.infixCall(infixCall.pos, infixCall.op,\n        infixCall.a0.accept(this), infixCall.a1.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": " calls"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.PrefixCall)", "name": "visit", "arg_nums": 1, "params": [{"name": "prefixCall", "type": "Ast.PrefixCall"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.PrefixCall prefixCall)", "original_string": "  protected Ast.Exp visit(Ast.PrefixCall prefixCall) {\n    return ast.prefixCall(prefixCall.pos, prefixCall.op,\n        prefixCall.a.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.IdPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "idPat", "type": "Ast.IdPat"}], "return_type": "Ast.Pat", "signature": "protected Ast.Pat visit(Ast.IdPat idPat)", "original_string": "  protected Ast.Pat visit(Ast.IdPat idPat) {\n    return idPat; // leaf\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": " patterns"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.LiteralPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "literalPat", "type": "Ast.LiteralPat"}], "return_type": "Ast.Pat", "signature": "protected Ast.Pat visit(Ast.LiteralPat literalPat)", "original_string": "  protected Ast.Pat visit(Ast.LiteralPat literalPat) {\n    return literalPat; // leaf\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.WildcardPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "wildcardPat", "type": "Ast.WildcardPat"}], "return_type": "Ast.Pat", "signature": "protected Ast.Pat visit(Ast.WildcardPat wildcardPat)", "original_string": "  protected Ast.Pat visit(Ast.WildcardPat wildcardPat) {\n    return wildcardPat; // leaf\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.InfixPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "infixPat", "type": "Ast.InfixPat"}], "return_type": "Ast.Pat", "signature": "protected Ast.Pat visit(Ast.InfixPat infixPat)", "original_string": "  protected Ast.Pat visit(Ast.InfixPat infixPat) {\n    return infixPat.copy(infixPat.p0.accept(this), infixPat.p1.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.TuplePat)", "name": "visit", "arg_nums": 1, "params": [{"name": "tuplePat", "type": "Ast.TuplePat"}], "return_type": "Ast.Pat", "signature": "protected Ast.Pat visit(Ast.TuplePat tuplePat)", "original_string": "  protected Ast.Pat visit(Ast.TuplePat tuplePat) {\n    return tuplePat.copy(visitList(tuplePat.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.ListPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "listPat", "type": "Ast.ListPat"}], "return_type": "Ast.Pat", "signature": "protected Ast.Pat visit(Ast.ListPat listPat)", "original_string": "  protected Ast.Pat visit(Ast.ListPat listPat) {\n    return listPat.copy(visitList(listPat.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.RecordPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordPat", "type": "Ast.RecordPat"}], "return_type": "Ast.Pat", "signature": "protected Ast.Pat visit(Ast.RecordPat recordPat)", "original_string": "  protected Ast.Pat visit(Ast.RecordPat recordPat) {\n    return recordPat.copy(recordPat.ellipsis, visitMap(recordPat.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.AnnotatedPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "annotatedPat", "type": "Ast.AnnotatedPat"}], "return_type": "Ast.Pat", "signature": "protected Ast.Pat visit(Ast.AnnotatedPat annotatedPat)", "original_string": "  protected Ast.Pat visit(Ast.AnnotatedPat annotatedPat) {\n    return annotatedPat.copy(annotatedPat.pat.accept(this),\n        annotatedPat.type.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Pat]visit(Ast.AsPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "asPat", "type": "Ast.AsPat"}], "return_type": "Ast.Pat", "signature": "protected Ast.Pat visit(Ast.AsPat asPat)", "original_string": "  protected Ast.Pat visit(Ast.AsPat asPat) {\n    return asPat.copy((Ast.IdPat) asPat.id.accept(this),\n        asPat.pat.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.ConPat]visit(Ast.ConPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "conPat", "type": "Ast.ConPat"}], "return_type": "Ast.ConPat", "signature": "protected Ast.ConPat visit(Ast.ConPat conPat)", "original_string": "  protected Ast.ConPat visit(Ast.ConPat conPat) {\n    return conPat.copy(conPat.tyCon.accept(this), conPat.pat.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.ConPat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Con0Pat]visit(Ast.Con0Pat)", "name": "visit", "arg_nums": 1, "params": [{"name": "con0Pat", "type": "Ast.Con0Pat"}], "return_type": "Ast.Con0Pat", "signature": "protected Ast.Con0Pat visit(Ast.Con0Pat con0Pat)", "original_string": "  protected Ast.Con0Pat visit(Ast.Con0Pat con0Pat) {\n    return con0Pat.copy(con0Pat.tyCon.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Con0Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.Tuple)", "name": "visit", "arg_nums": 1, "params": [{"name": "tuple", "type": "Ast.Tuple"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.Tuple tuple)", "original_string": "  protected Ast.Exp visit(Ast.Tuple tuple) {\n    return ast.tuple(tuple.pos, visitList(tuple.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": " value constructors"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.ListExp]visit(Ast.ListExp)", "name": "visit", "arg_nums": 1, "params": [{"name": "list", "type": "Ast.ListExp"}], "return_type": "Ast.ListExp", "signature": "protected Ast.ListExp visit(Ast.ListExp list)", "original_string": "  protected Ast.ListExp visit(Ast.ListExp list) {\n    return ast.list(list.pos, visitList(list.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.ListExp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.Record)", "name": "visit", "arg_nums": 1, "params": [{"name": "record", "type": "Ast.Record"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.Record record)", "original_string": "  protected Ast.Exp visit(Ast.Record record) {\n    return ast.record(record.pos, visitMap(record.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Fn]visit(Ast.Fn)", "name": "visit", "arg_nums": 1, "params": [{"name": "fn", "type": "Ast.Fn"}], "return_type": "Ast.Fn", "signature": "protected Ast.Fn visit(Ast.Fn fn)", "original_string": "  protected Ast.Fn visit(Ast.Fn fn) {\n    return ast.fn(fn.pos, visitList(fn.matchList));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Fn", "classes": []}, "docstring": " functions and matches"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Apply]visit(Ast.Apply)", "name": "visit", "arg_nums": 1, "params": [{"name": "apply", "type": "Ast.Apply"}], "return_type": "Ast.Apply", "signature": "protected Ast.Apply visit(Ast.Apply apply)", "original_string": "  protected Ast.Apply visit(Ast.Apply apply) {\n    return ast.apply(apply.fn.accept(this), apply.arg.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Apply", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.RecordSelector)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordSelector", "type": "Ast.RecordSelector"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.RecordSelector recordSelector)", "original_string": "  protected Ast.Exp visit(Ast.RecordSelector recordSelector) {\n    return recordSelector; // leaf\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Match]visit(Ast.Match)", "name": "visit", "arg_nums": 1, "params": [{"name": "match", "type": "Ast.Match"}], "return_type": "Ast.Match", "signature": "protected Ast.Match visit(Ast.Match match)", "original_string": "  protected Ast.Match visit(Ast.Match match) {\n    return ast.match(match.pos, match.pat.accept(this), match.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Match", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Type]visit(Ast.NamedType)", "name": "visit", "arg_nums": 1, "params": [{"name": "namedType", "type": "Ast.NamedType"}], "return_type": "Ast.Type", "signature": "protected Ast.Type visit(Ast.NamedType namedType)", "original_string": "  protected Ast.Type visit(Ast.NamedType namedType) {\n    return namedType; // leaf\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Type", "classes": []}, "docstring": " types"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.TyVar]visit(Ast.TyVar)", "name": "visit", "arg_nums": 1, "params": [{"name": "tyVar", "type": "Ast.TyVar"}], "return_type": "Ast.TyVar", "signature": "protected Ast.TyVar visit(Ast.TyVar tyVar)", "original_string": "  protected Ast.TyVar visit(Ast.TyVar tyVar) {\n    return tyVar; // leaf\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.TyVar", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Decl]visit(Ast.FunDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "funDecl", "type": "Ast.FunDecl"}], "return_type": "Ast.Decl", "signature": "protected Ast.Decl visit(Ast.FunDecl funDecl)", "original_string": "  protected Ast.Decl visit(Ast.FunDecl funDecl) {\n    return ast.funDecl(funDecl.pos, visitList(funDecl.funBinds));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Decl", "classes": []}, "docstring": " declarations"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.FunBind]visit(Ast.FunBind)", "name": "visit", "arg_nums": 1, "params": [{"name": "funBind", "type": "Ast.FunBind"}], "return_type": "Ast.FunBind", "signature": "protected Ast.FunBind visit(Ast.FunBind funBind)", "original_string": "  protected Ast.FunBind visit(Ast.FunBind funBind) {\n    return ast.funBind(funBind.pos, visitList(funBind.matchList));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.FunBind", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.FunMatch]visit(Ast.FunMatch)", "name": "visit", "arg_nums": 1, "params": [{"name": "funMatch", "type": "Ast.FunMatch"}], "return_type": "Ast.FunMatch", "signature": "protected Ast.FunMatch visit(Ast.FunMatch funMatch)", "original_string": "  protected Ast.FunMatch visit(Ast.FunMatch funMatch) {\n    return ast.funMatch(funMatch.pos, funMatch.name,\n        visitList(funMatch.patList),\n        funMatch.returnType == null ? null : funMatch.returnType.accept(this),\n        funMatch.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.FunMatch", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.ValDecl]visit(Ast.ValDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "valDecl", "type": "Ast.ValDecl"}], "return_type": "Ast.ValDecl", "signature": "protected Ast.ValDecl visit(Ast.ValDecl valDecl)", "original_string": "  protected Ast.ValDecl visit(Ast.ValDecl valDecl) {\n    return ast.valDecl(valDecl.pos, valDecl.rec, visitList(valDecl.valBinds));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.ValDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.ValBind]visit(Ast.ValBind)", "name": "visit", "arg_nums": 1, "params": [{"name": "valBind", "type": "Ast.ValBind"}], "return_type": "Ast.ValBind", "signature": "protected Ast.ValBind visit(Ast.ValBind valBind)", "original_string": "  protected Ast.ValBind visit(Ast.ValBind valBind) {\n    return ast.valBind(valBind.pos, valBind.pat, valBind.exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.ValBind", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Exp]visit(Ast.From)", "name": "visit", "arg_nums": 1, "params": [{"name": "from", "type": "Ast.From"}], "return_type": "Ast.Exp", "signature": "protected Ast.Exp visit(Ast.From from)", "original_string": "  protected Ast.Exp visit(Ast.From from) {\n    return ast.from(from.pos, from.steps);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Order)", "name": "visit", "arg_nums": 1, "params": [{"name": "order", "type": "Ast.Order"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Order order)", "original_string": "  protected AstNode visit(Ast.Order order) {\n    return ast.order(order.pos, order.orderItems);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.OrderItem)", "name": "visit", "arg_nums": 1, "params": [{"name": "orderItem", "type": "Ast.OrderItem"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.OrderItem orderItem)", "original_string": "  protected AstNode visit(Ast.OrderItem orderItem) {\n    return ast.orderItem(orderItem.pos, orderItem.exp, orderItem.direction);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Scan]visit(Ast.Scan)", "name": "visit", "arg_nums": 1, "params": [{"name": "scan", "type": "Ast.Scan"}], "return_type": "Ast.Scan", "signature": "protected Ast.Scan visit(Ast.Scan scan)", "original_string": "  protected Ast.Scan visit(Ast.Scan scan) {\n    return ast.scan(scan.pos, scan.pat.accept(this),\n        scan.exp.accept(this),\n        scan.condition == null ? null : scan.condition.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Scan", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Where)", "name": "visit", "arg_nums": 1, "params": [{"name": "where", "type": "Ast.Where"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Where where)", "original_string": "  protected AstNode visit(Ast.Where where) {\n    return ast.where(where.pos, where.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Skip)", "name": "visit", "arg_nums": 1, "params": [{"name": "skip", "type": "Ast.Skip"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Skip skip)", "original_string": "  protected AstNode visit(Ast.Skip skip) {\n    return ast.skip(skip.pos, skip.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Take)", "name": "visit", "arg_nums": 1, "params": [{"name": "take", "type": "Ast.Take"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Take take)", "original_string": "  protected AstNode visit(Ast.Take take) {\n    return ast.take(take.pos, take.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Yield)", "name": "visit", "arg_nums": 1, "params": [{"name": "yield", "type": "Ast.Yield"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Yield yield)", "original_string": "  protected AstNode visit(Ast.Yield yield) {\n    return ast.yield(yield.pos, yield.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Into)", "name": "visit", "arg_nums": 1, "params": [{"name": "into", "type": "Ast.Into"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Into into)", "original_string": "  protected AstNode visit(Ast.Into into) {\n    return ast.into(into.pos, into.exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Through)", "name": "visit", "arg_nums": 1, "params": [{"name": "through", "type": "Ast.Through"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Through through)", "original_string": "  protected AstNode visit(Ast.Through through) {\n    return ast.through(through.pos, through.pat, through.exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Compute)", "name": "visit", "arg_nums": 1, "params": [{"name": "compute", "type": "Ast.Compute"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Compute compute)", "original_string": "  protected AstNode visit(Ast.Compute compute) {\n    return ast.compute(compute.pos, compute.aggregates);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Group)", "name": "visit", "arg_nums": 1, "params": [{"name": "group", "type": "Ast.Group"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Group group)", "original_string": "  protected AstNode visit(Ast.Group group) {\n    return ast.group(group.pos, group.groupExps, group.aggregates);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.Aggregate)", "name": "visit", "arg_nums": 1, "params": [{"name": "aggregate", "type": "Ast.Aggregate"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.Aggregate aggregate)", "original_string": "  protected AstNode visit(Ast.Aggregate aggregate) {\n    return ast.aggregate(aggregate.pos, aggregate.aggregate, aggregate.argument,\n        aggregate.id);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.DatatypeDecl]visit(Ast.DatatypeDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "datatypeDecl", "type": "Ast.DatatypeDecl"}], "return_type": "Ast.DatatypeDecl", "signature": "protected Ast.DatatypeDecl visit(Ast.DatatypeDecl datatypeDecl)", "original_string": "  protected Ast.DatatypeDecl visit(Ast.DatatypeDecl datatypeDecl) {\n    return ast.datatypeDecl(datatypeDecl.pos, visitList(datatypeDecl.binds));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.DatatypeDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.DatatypeBind]visit(Ast.DatatypeBind)", "name": "visit", "arg_nums": 1, "params": [{"name": "datatypeBind", "type": "Ast.DatatypeBind"}], "return_type": "Ast.DatatypeBind", "signature": "protected Ast.DatatypeBind visit(Ast.DatatypeBind datatypeBind)", "original_string": "  protected Ast.DatatypeBind visit(Ast.DatatypeBind datatypeBind) {\n    return ast.datatypeBind(datatypeBind.pos, datatypeBind.name.accept(this),\n        visitList(datatypeBind.tyVars), visitList(datatypeBind.tyCons));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.DatatypeBind", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[AstNode]visit(Ast.TyCon)", "name": "visit", "arg_nums": 1, "params": [{"name": "tyCon", "type": "Ast.TyCon"}], "return_type": "AstNode", "signature": "protected AstNode visit(Ast.TyCon tyCon)", "original_string": "  protected AstNode visit(Ast.TyCon tyCon) {\n    return ast.typeConstructor(tyCon.pos, tyCon.id.accept(this),\n        tyCon.type == null ? null : tyCon.type.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.RecordType]visit(Ast.RecordType)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordType", "type": "Ast.RecordType"}], "return_type": "Ast.RecordType", "signature": "protected Ast.RecordType visit(Ast.RecordType recordType)", "original_string": "  protected Ast.RecordType visit(Ast.RecordType recordType) {\n    return ast.recordType(recordType.pos, visitMap(recordType.fieldTypes));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.RecordType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Type]visit(Ast.TupleType)", "name": "visit", "arg_nums": 1, "params": [{"name": "tupleType", "type": "Ast.TupleType"}], "return_type": "Ast.Type", "signature": "protected Ast.Type visit(Ast.TupleType tupleType)", "original_string": "  protected Ast.Type visit(Ast.TupleType tupleType) {\n    return ast.tupleType(tupleType.pos, visitList(tupleType.types));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Type]visit(Ast.FunctionType)", "name": "visit", "arg_nums": 1, "params": [{"name": "functionType", "type": "Ast.FunctionType"}], "return_type": "Ast.Type", "signature": "protected Ast.Type visit(Ast.FunctionType functionType)", "original_string": "  protected Ast.Type visit(Ast.FunctionType functionType) {\n    return ast.functionType(functionType.pos, functionType.paramType,\n        functionType.resultType);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Ast.Type]visit(Ast.CompositeType)", "name": "visit", "arg_nums": 1, "params": [{"name": "compositeType", "type": "Ast.CompositeType"}], "return_type": "Ast.Type", "signature": "protected Ast.Type visit(Ast.CompositeType compositeType)", "original_string": "  protected Ast.Type visit(Ast.CompositeType compositeType) {\n    return ast.compositeType(compositeType.pos,\n        visitList(compositeType.types));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Ast.Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Apply)", "name": "visit", "arg_nums": 1, "params": [{"name": "apply", "type": "Core.Apply"}], "return_type": "Core.Exp", "signature": "protected Core.Exp visit(Core.Apply apply)", "original_string": "  protected Core.Exp visit(Core.Apply apply) {\n    return apply.copy(apply.fn.accept(this), apply.arg.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": " core expressions, patterns"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Id)", "name": "visit", "arg_nums": 1, "params": [{"name": "id", "type": "Core.Id"}], "return_type": "Core.Exp", "signature": "protected Core.Exp visit(Core.Id id)", "original_string": "  protected Core.Exp visit(Core.Id id) {\n    return id;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.RecordSelector]visit(Core.RecordSelector)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordSelector", "type": "Core.RecordSelector"}], "return_type": "Core.RecordSelector", "signature": "protected Core.RecordSelector visit(Core.RecordSelector recordSelector)", "original_string": "  protected Core.RecordSelector visit(Core.RecordSelector recordSelector) {\n    return recordSelector;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.RecordSelector", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Literal)", "name": "visit", "arg_nums": 1, "params": [{"name": "literal", "type": "Core.Literal"}], "return_type": "Core.Exp", "signature": "protected Core.Exp visit(Core.Literal literal)", "original_string": "  protected Core.Exp visit(Core.Literal literal) {\n    return literal;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Tuple)", "name": "visit", "arg_nums": 1, "params": [{"name": "tuple", "type": "Core.Tuple"}], "return_type": "Core.Exp", "signature": "protected Core.Exp visit(Core.Tuple tuple)", "original_string": "  protected Core.Exp visit(Core.Tuple tuple) {\n    return tuple.copy(typeSystem, visitList(tuple.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Let)", "name": "visit", "arg_nums": 1, "params": [{"name": "let", "type": "Core.Let"}], "return_type": "Core.Exp", "signature": "protected Core.Exp visit(Core.Let let)", "original_string": "  protected Core.Exp visit(Core.Let let) {\n    return let.copy(let.decl.accept(this), let.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Local)", "name": "visit", "arg_nums": 1, "params": [{"name": "local", "type": "Core.Local"}], "return_type": "Core.Exp", "signature": "protected Core.Exp visit(Core.Local local)", "original_string": "  protected Core.Exp visit(Core.Local local) {\n    return local.copy(local.dataType, local.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.DatatypeDecl]visit(Core.DatatypeDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "datatypeDecl", "type": "Core.DatatypeDecl"}], "return_type": "Core.DatatypeDecl", "signature": "protected Core.DatatypeDecl visit(Core.DatatypeDecl datatypeDecl)", "original_string": "  protected Core.DatatypeDecl visit(Core.DatatypeDecl datatypeDecl) {\n    return datatypeDecl;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.DatatypeDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.NonRecValDecl]visit(Core.NonRecValDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "valDecl", "type": "Core.NonRecValDecl"}], "return_type": "Core.NonRecValDecl", "signature": "protected Core.NonRecValDecl visit(Core.NonRecValDecl valDecl)", "original_string": "  protected Core.NonRecValDecl visit(Core.NonRecValDecl valDecl) {\n    return valDecl.copy(valDecl.pat.accept(this),\n        valDecl.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.NonRecValDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.RecValDecl]visit(Core.RecValDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "valDecl", "type": "Core.RecValDecl"}], "return_type": "Core.RecValDecl", "signature": "protected Core.RecValDecl visit(Core.RecValDecl valDecl)", "original_string": "  protected Core.RecValDecl visit(Core.RecValDecl valDecl) {\n    return valDecl.copy(visitList(valDecl.list));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.RecValDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.IdPat]visit(Core.IdPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "idPat", "type": "Core.IdPat"}], "return_type": "Core.IdPat", "signature": "protected Core.IdPat visit(Core.IdPat idPat)", "original_string": "  protected Core.IdPat visit(Core.IdPat idPat) {\n    return idPat;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.IdPat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.AsPat]visit(Core.AsPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "asPat", "type": "Core.AsPat"}], "return_type": "Core.AsPat", "signature": "protected Core.AsPat visit(Core.AsPat asPat)", "original_string": "  protected Core.AsPat visit(Core.AsPat asPat) {\n    return asPat.copy(asPat.name, asPat.i, asPat.pat.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.AsPat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.LiteralPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "literalPat", "type": "Core.LiteralPat"}], "return_type": "Core.Pat", "signature": "protected Core.Pat visit(Core.LiteralPat literalPat)", "original_string": "  protected Core.Pat visit(Core.LiteralPat literalPat) {\n    return literalPat;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.WildcardPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "wildcardPat", "type": "Core.WildcardPat"}], "return_type": "Core.Pat", "signature": "protected Core.Pat visit(Core.WildcardPat wildcardPat)", "original_string": "  protected Core.Pat visit(Core.WildcardPat wildcardPat) {\n    return wildcardPat;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.ConPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "conPat", "type": "Core.ConPat"}], "return_type": "Core.Pat", "signature": "protected Core.Pat visit(Core.ConPat conPat)", "original_string": "  protected Core.Pat visit(Core.ConPat conPat) {\n    return conPat.copy(conPat.tyCon, conPat.pat.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.Con0Pat)", "name": "visit", "arg_nums": 1, "params": [{"name": "con0Pat", "type": "Core.Con0Pat"}], "return_type": "Core.Pat", "signature": "protected Core.Pat visit(Core.Con0Pat con0Pat)", "original_string": "  protected Core.Pat visit(Core.Con0Pat con0Pat) {\n    return con0Pat;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.TuplePat)", "name": "visit", "arg_nums": 1, "params": [{"name": "tuplePat", "type": "Core.TuplePat"}], "return_type": "Core.Pat", "signature": "protected Core.Pat visit(Core.TuplePat tuplePat)", "original_string": "  protected Core.Pat visit(Core.TuplePat tuplePat) {\n    return tuplePat.copy(typeSystem, visitList(tuplePat.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.ListPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "listPat", "type": "Core.ListPat"}], "return_type": "Core.Pat", "signature": "protected Core.Pat visit(Core.ListPat listPat)", "original_string": "  protected Core.Pat visit(Core.ListPat listPat) {\n    return listPat.copy(typeSystem, visitList(listPat.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Pat]visit(Core.RecordPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordPat", "type": "Core.RecordPat"}], "return_type": "Core.Pat", "signature": "protected Core.Pat visit(Core.RecordPat recordPat)", "original_string": "  protected Core.Pat visit(Core.RecordPat recordPat) {\n    return recordPat.copy(typeSystem, recordPat.type().argNameTypes.keySet(),\n        visitList(recordPat.args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Fn)", "name": "visit", "arg_nums": 1, "params": [{"name": "fn", "type": "Core.Fn"}], "return_type": "Core.Exp", "signature": "protected Core.Exp visit(Core.Fn fn)", "original_string": "  protected Core.Exp visit(Core.Fn fn) {\n    return fn.copy(fn.idPat.accept(this), fn.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.Case)", "name": "visit", "arg_nums": 1, "params": [{"name": "caseOf", "type": "Core.Case"}], "return_type": "Core.Exp", "signature": "protected Core.Exp visit(Core.Case caseOf)", "original_string": "  protected Core.Exp visit(Core.Case caseOf) {\n    return caseOf.copy(caseOf.exp.accept(this), visitList(caseOf.matchList));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Match]visit(Core.Match)", "name": "visit", "arg_nums": 1, "params": [{"name": "match", "type": "Core.Match"}], "return_type": "Core.Match", "signature": "protected Core.Match visit(Core.Match match)", "original_string": "  protected Core.Match visit(Core.Match match) {\n    return match.copy(match.pat.accept(this), match.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Match", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Exp]visit(Core.From)", "name": "visit", "arg_nums": 1, "params": [{"name": "from", "type": "Core.From"}], "return_type": "Core.Exp", "signature": "protected Core.Exp visit(Core.From from)", "original_string": "  protected Core.Exp visit(Core.From from) {\n    return from.copy(typeSystem, null, visitList(from.steps));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Scan]visit(Core.Scan)", "name": "visit", "arg_nums": 1, "params": [{"name": "scan", "type": "Core.Scan"}], "return_type": "Core.Scan", "signature": "protected Core.Scan visit(Core.Scan scan)", "original_string": "  protected Core.Scan visit(Core.Scan scan) {\n    return scan.copy(scan.bindings, scan.pat.accept(this),\n        scan.exp.accept(this), scan.condition.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Scan", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Where]visit(Core.Where)", "name": "visit", "arg_nums": 1, "params": [{"name": "where", "type": "Core.Where"}], "return_type": "Core.Where", "signature": "protected Core.Where visit(Core.Where where)", "original_string": "  protected Core.Where visit(Core.Where where) {\n    return where.copy(where.exp.accept(this), where.bindings);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Where", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Skip]visit(Core.Skip)", "name": "visit", "arg_nums": 1, "params": [{"name": "skip", "type": "Core.Skip"}], "return_type": "Core.Skip", "signature": "protected Core.Skip visit(Core.Skip skip)", "original_string": "  protected Core.Skip visit(Core.Skip skip) {\n    return skip.copy(skip.exp.accept(this), skip.bindings);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Skip", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Take]visit(Core.Take)", "name": "visit", "arg_nums": 1, "params": [{"name": "take", "type": "Core.Take"}], "return_type": "Core.Take", "signature": "protected Core.Take visit(Core.Take take)", "original_string": "  protected Core.Take visit(Core.Take take) {\n    return take.copy(take.exp.accept(this), take.bindings);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Take", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Group]visit(Core.Group)", "name": "visit", "arg_nums": 1, "params": [{"name": "group", "type": "Core.Group"}], "return_type": "Core.Group", "signature": "protected Core.Group visit(Core.Group group)", "original_string": "  protected Core.Group visit(Core.Group group) {\n    return group.copy(visitSortedMap(group.groupExps),\n        visitSortedMap(group.aggregates));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Group", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Aggregate]visit(Core.Aggregate)", "name": "visit", "arg_nums": 1, "params": [{"name": "aggregate", "type": "Core.Aggregate"}], "return_type": "Core.Aggregate", "signature": "protected Core.Aggregate visit(Core.Aggregate aggregate)", "original_string": "  protected Core.Aggregate visit(Core.Aggregate aggregate) {\n    return aggregate.copy(aggregate.type, aggregate.aggregate.accept(this),\n        aggregate.argument == null ? null : aggregate.argument.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Aggregate", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Order]visit(Core.Order)", "name": "visit", "arg_nums": 1, "params": [{"name": "order", "type": "Core.Order"}], "return_type": "Core.Order", "signature": "protected Core.Order visit(Core.Order order)", "original_string": "  protected Core.Order visit(Core.Order order) {\n    return order.copy(order.bindings, visitList(order.orderItems));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Order", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.OrderItem]visit(Core.OrderItem)", "name": "visit", "arg_nums": 1, "params": [{"name": "orderItem", "type": "Core.OrderItem"}], "return_type": "Core.OrderItem", "signature": "protected Core.OrderItem visit(Core.OrderItem orderItem)", "original_string": "  protected Core.OrderItem visit(Core.OrderItem orderItem) {\n    return orderItem.copy(orderItem.exp.accept(this), orderItem.direction);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.OrderItem", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle.[Core.Yield]visit(Core.Yield)", "name": "visit", "arg_nums": 1, "params": [{"name": "yield", "type": "Core.Yield"}], "return_type": "Core.Yield", "signature": "protected Core.Yield visit(Core.Yield yield)", "original_string": "  protected Core.Yield visit(Core.Yield yield) {\n    return yield.copy(yield.bindings, yield.exp.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Shuttle.java", "class_name": "Shuttle", "class_uri": "src/main/java/net/hydromatic/morel/ast/Shuttle.java.Shuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Yield", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[]AstNode(Pos,Op)", "name": "AstNode", "arg_nums": 2, "params": [{"name": "pos", "type": "Pos"}, {"name": "op", "type": "Op"}], "return_type": "", "signature": "public AstNode(Pos pos, Op op)", "original_string": "  public AstNode(Pos pos, Op op) {\n    this.pos = requireNonNull(pos);\n    this.op = requireNonNull(op);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstNode.java", "class_name": "AstNode", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public final String toString()", "original_string": "  @Override public final String toString() {\n    // Marked final because you should override unparse, not toString\n    return unparse(new AstWriter());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstNode.java", "class_name": "AstNode", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode", "attributes": {"modifiers": "@Override public final", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Converts this node into an ML string.\n\n<p>The purpose of this string is debugging. If you want to generate an\nexpression, use {@link #unparse}, which will insert parentheses as\nnecessary for operator precedence.\n\n<p>Derived classes <em>may</em> override, but they must produce the same\nresult; so the only reason to override is if they can do it more\nefficiently.\n"}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[String]unparse(AstWriter)", "name": "unparse", "arg_nums": 1, "params": [{"name": "w", "type": "AstWriter"}], "return_type": "String", "signature": "public final String unparse(AstWriter w)", "original_string": "  public final String unparse(AstWriter w) {\n    return unparse(w, 0, 0).toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstNode.java", "class_name": "AstNode", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Converts this node into an ML string, with a given writer."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[AstWriter]unparse(AstWriter,int,int)", "name": "unparse", "arg_nums": 3, "params": [{"name": "w", "type": "AstWriter"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "return_type": "AstWriter", "signature": "abstract AstWriter unparse(AstWriter w, int left, int right)", "original_string": "  abstract AstWriter unparse(AstWriter w, int left, int right);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstNode.java", "class_name": "AstNode", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "return_type": "AstWriter", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[AstNode]accept(Shuttle)", "name": "accept", "arg_nums": 1, "params": [{"name": "shuttle", "type": "Shuttle"}], "return_type": "AstNode", "signature": "public abstract AstNode accept(Shuttle shuttle)", "original_string": "  public abstract AstNode accept(Shuttle shuttle);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstNode.java", "class_name": "AstNode", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": " Accepts a shuttle, calling the\n{@link net.hydromatic.morel.ast.Shuttle#visit}\nmethod appropriate to the type of this node, and returning the result."}, {"uris": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode.[void]accept(Visitor)", "name": "accept", "arg_nums": 1, "params": [{"name": "visitor", "type": "Visitor"}], "return_type": "void", "signature": "public abstract void accept(Visitor visitor)", "original_string": "  public abstract void accept(Visitor visitor);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/AstNode.java", "class_name": "AstNode", "class_uri": "src/main/java/net/hydromatic/morel/ast/AstNode.java.AstNode", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Accepts a visitor, calling the\n{@link net.hydromatic.morel.ast.Shuttle#visit}\nmethod appropriate to the type of this node, and returning the result."}, {"uris": "src/main/java/net/hydromatic/morel/ast/Ast.java.Ast.[]Ast()", "name": "Ast", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Ast()", "original_string": "  private Ast() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Ast.java", "class_name": "Ast", "class_uri": "src/main/java/net/hydromatic/morel/ast/Ast.java.Ast", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Core.java.Core.[]Core()", "name": "Core", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Core()", "original_string": "  private Core() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Core.java", "class_name": "Core", "class_uri": "src/main/java/net/hydromatic/morel/ast/Core.java.Core", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]accept(E)", "name": "accept", "arg_nums": 1, "params": [{"name": "e", "type": "E"}], "return_type": "void", "signature": "protected <E extends AstNode> void accept(E e)", "original_string": "  protected <E extends AstNode> void accept(E e) {\n    e.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": " For use as a method reference."}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Literal)", "name": "visit", "arg_nums": 1, "params": [{"name": "literal", "type": "Ast.Literal"}], "return_type": "void", "signature": "protected void visit(Ast.Literal literal)", "original_string": "  protected void visit(Ast.Literal literal) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": " expressions"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Id)", "name": "visit", "arg_nums": 1, "params": [{"name": "id", "type": "Ast.Id"}], "return_type": "void", "signature": "protected void visit(Ast.Id id)", "original_string": "  protected void visit(Ast.Id id) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.AnnotatedExp)", "name": "visit", "arg_nums": 1, "params": [{"name": "annotatedExp", "type": "Ast.AnnotatedExp"}], "return_type": "void", "signature": "protected void visit(Ast.AnnotatedExp annotatedExp)", "original_string": "  protected void visit(Ast.AnnotatedExp annotatedExp) {\n    annotatedExp.exp.accept(this);\n    annotatedExp.type.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.If)", "name": "visit", "arg_nums": 1, "params": [{"name": "anIf", "type": "Ast.If"}], "return_type": "void", "signature": "protected void visit(Ast.If anIf)", "original_string": "  protected void visit(Ast.If anIf) {\n    anIf.condition.accept(this);\n    anIf.ifTrue.accept(this);\n    anIf.ifFalse.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Let)", "name": "visit", "arg_nums": 1, "params": [{"name": "let", "type": "Ast.Let"}], "return_type": "void", "signature": "protected void visit(Ast.Let let)", "original_string": "  protected void visit(Ast.Let let) {\n    let.decls.forEach(this::accept);\n    let.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Case)", "name": "visit", "arg_nums": 1, "params": [{"name": "kase", "type": "Ast.Case"}], "return_type": "void", "signature": "protected void visit(Ast.Case kase)", "original_string": "  protected void visit(Ast.Case kase) {\n    kase.exp.accept(this);\n    kase.matchList.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.InfixCall)", "name": "visit", "arg_nums": 1, "params": [{"name": "infixCall", "type": "Ast.InfixCall"}], "return_type": "void", "signature": "protected void visit(Ast.InfixCall infixCall)", "original_string": "  protected void visit(Ast.InfixCall infixCall) {\n    infixCall.a0.accept(this);\n    infixCall.a1.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": " calls"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.PrefixCall)", "name": "visit", "arg_nums": 1, "params": [{"name": "prefixCall", "type": "Ast.PrefixCall"}], "return_type": "void", "signature": "protected void visit(Ast.PrefixCall prefixCall)", "original_string": "  protected void visit(Ast.PrefixCall prefixCall) {\n    prefixCall.a.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.IdPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "idPat", "type": "Ast.IdPat"}], "return_type": "void", "signature": "protected void visit(Ast.IdPat idPat)", "original_string": "  protected void visit(Ast.IdPat idPat) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": " patterns"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.LiteralPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "literalPat", "type": "Ast.LiteralPat"}], "return_type": "void", "signature": "protected void visit(Ast.LiteralPat literalPat)", "original_string": "  protected void visit(Ast.LiteralPat literalPat) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.WildcardPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "wildcardPat", "type": "Ast.WildcardPat"}], "return_type": "void", "signature": "protected void visit(Ast.WildcardPat wildcardPat)", "original_string": "  protected void visit(Ast.WildcardPat wildcardPat) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.InfixPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "infixPat", "type": "Ast.InfixPat"}], "return_type": "void", "signature": "protected void visit(Ast.InfixPat infixPat)", "original_string": "  protected void visit(Ast.InfixPat infixPat) {\n    infixPat.p0.accept(this);\n    infixPat.p1.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.TuplePat)", "name": "visit", "arg_nums": 1, "params": [{"name": "tuplePat", "type": "Ast.TuplePat"}], "return_type": "void", "signature": "protected void visit(Ast.TuplePat tuplePat)", "original_string": "  protected void visit(Ast.TuplePat tuplePat) {\n    tuplePat.args.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ListPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "listPat", "type": "Ast.ListPat"}], "return_type": "void", "signature": "protected void visit(Ast.ListPat listPat)", "original_string": "  protected void visit(Ast.ListPat listPat) {\n    listPat.args.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.RecordPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordPat", "type": "Ast.RecordPat"}], "return_type": "void", "signature": "protected void visit(Ast.RecordPat recordPat)", "original_string": "  protected void visit(Ast.RecordPat recordPat) {\n    recordPat.args.values().forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.AnnotatedPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "annotatedPat", "type": "Ast.AnnotatedPat"}], "return_type": "void", "signature": "protected void visit(Ast.AnnotatedPat annotatedPat)", "original_string": "  protected void visit(Ast.AnnotatedPat annotatedPat) {\n    annotatedPat.pat.accept(this);\n    annotatedPat.type.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.AsPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "asPat", "type": "Ast.AsPat"}], "return_type": "void", "signature": "protected void visit(Ast.AsPat asPat)", "original_string": "  protected void visit(Ast.AsPat asPat) {\n    asPat.id.accept(this);\n    asPat.pat.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ConPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "conPat", "type": "Ast.ConPat"}], "return_type": "void", "signature": "protected void visit(Ast.ConPat conPat)", "original_string": "  protected void visit(Ast.ConPat conPat) {\n    conPat.tyCon.accept(this);\n    conPat.pat.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Con0Pat)", "name": "visit", "arg_nums": 1, "params": [{"name": "con0Pat", "type": "Ast.Con0Pat"}], "return_type": "void", "signature": "protected void visit(Ast.Con0Pat con0Pat)", "original_string": "  protected void visit(Ast.Con0Pat con0Pat) {\n    con0Pat.tyCon.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Tuple)", "name": "visit", "arg_nums": 1, "params": [{"name": "tuple", "type": "Ast.Tuple"}], "return_type": "void", "signature": "protected void visit(Ast.Tuple tuple)", "original_string": "  protected void visit(Ast.Tuple tuple) {\n    tuple.args.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": " value constructors"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ListExp)", "name": "visit", "arg_nums": 1, "params": [{"name": "list", "type": "Ast.ListExp"}], "return_type": "void", "signature": "protected void visit(Ast.ListExp list)", "original_string": "  protected void visit(Ast.ListExp list) {\n    list.args.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Record)", "name": "visit", "arg_nums": 1, "params": [{"name": "record", "type": "Ast.Record"}], "return_type": "void", "signature": "protected void visit(Ast.Record record)", "original_string": "  protected void visit(Ast.Record record) {\n    record.args.values().forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Fn)", "name": "visit", "arg_nums": 1, "params": [{"name": "fn", "type": "Ast.Fn"}], "return_type": "void", "signature": "protected void visit(Ast.Fn fn)", "original_string": "  protected void visit(Ast.Fn fn) {\n    fn.matchList.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": " functions and matches"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Apply)", "name": "visit", "arg_nums": 1, "params": [{"name": "apply", "type": "Ast.Apply"}], "return_type": "void", "signature": "protected void visit(Ast.Apply apply)", "original_string": "  protected void visit(Ast.Apply apply) {\n    apply.fn.accept(this);\n    apply.arg.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.RecordSelector)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordSelector", "type": "Ast.RecordSelector"}], "return_type": "void", "signature": "protected void visit(Ast.RecordSelector recordSelector)", "original_string": "  protected void visit(Ast.RecordSelector recordSelector) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Match)", "name": "visit", "arg_nums": 1, "params": [{"name": "match", "type": "Ast.Match"}], "return_type": "void", "signature": "protected void visit(Ast.Match match)", "original_string": "  protected void visit(Ast.Match match) {\n    match.pat.accept(this);\n    match.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.NamedType)", "name": "visit", "arg_nums": 1, "params": [{"name": "namedType", "type": "Ast.NamedType"}], "return_type": "void", "signature": "protected void visit(Ast.NamedType namedType)", "original_string": "  protected void visit(Ast.NamedType namedType) {\n    namedType.types.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": " types"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.TyVar)", "name": "visit", "arg_nums": 1, "params": [{"name": "tyVar", "type": "Ast.TyVar"}], "return_type": "void", "signature": "protected void visit(Ast.TyVar tyVar)", "original_string": "  protected void visit(Ast.TyVar tyVar) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.FunDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "funDecl", "type": "Ast.FunDecl"}], "return_type": "void", "signature": "protected void visit(Ast.FunDecl funDecl)", "original_string": "  protected void visit(Ast.FunDecl funDecl) {\n    funDecl.funBinds.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": " declarations"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.FunBind)", "name": "visit", "arg_nums": 1, "params": [{"name": "funBind", "type": "Ast.FunBind"}], "return_type": "void", "signature": "protected void visit(Ast.FunBind funBind)", "original_string": "  protected void visit(Ast.FunBind funBind) {\n    funBind.matchList.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.FunMatch)", "name": "visit", "arg_nums": 1, "params": [{"name": "funMatch", "type": "Ast.FunMatch"}], "return_type": "void", "signature": "protected void visit(Ast.FunMatch funMatch)", "original_string": "  protected void visit(Ast.FunMatch funMatch) {\n    funMatch.patList.forEach(this::accept);\n    funMatch.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ValDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "valDecl", "type": "Ast.ValDecl"}], "return_type": "void", "signature": "protected void visit(Ast.ValDecl valDecl)", "original_string": "  protected void visit(Ast.ValDecl valDecl) {\n    valDecl.valBinds.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.ValBind)", "name": "visit", "arg_nums": 1, "params": [{"name": "valBind", "type": "Ast.ValBind"}], "return_type": "void", "signature": "protected void visit(Ast.ValBind valBind)", "original_string": "  protected void visit(Ast.ValBind valBind) {\n    valBind.pat.accept(this);\n    valBind.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.From)", "name": "visit", "arg_nums": 1, "params": [{"name": "from", "type": "Ast.From"}], "return_type": "void", "signature": "protected void visit(Ast.From from)", "original_string": "  protected void visit(Ast.From from) {\n    from.steps.forEach(this::accept);\n    if (from.implicitYieldExp != null) {\n      from.implicitYieldExp.accept(this);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Scan)", "name": "visit", "arg_nums": 1, "params": [{"name": "scan", "type": "Ast.Scan"}], "return_type": "void", "signature": "protected void visit(Ast.Scan scan)", "original_string": "  protected void visit(Ast.Scan scan) {\n    scan.pat.accept(this);\n    if (scan.exp != null) {\n      scan.exp.accept(this);\n    }\n    if (scan.condition != null) {\n      scan.condition.accept(this);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Order)", "name": "visit", "arg_nums": 1, "params": [{"name": "order", "type": "Ast.Order"}], "return_type": "void", "signature": "protected void visit(Ast.Order order)", "original_string": "  protected void visit(Ast.Order order) {\n    order.orderItems.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.OrderItem)", "name": "visit", "arg_nums": 1, "params": [{"name": "orderItem", "type": "Ast.OrderItem"}], "return_type": "void", "signature": "protected void visit(Ast.OrderItem orderItem)", "original_string": "  protected void visit(Ast.OrderItem orderItem) {\n    orderItem.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Where)", "name": "visit", "arg_nums": 1, "params": [{"name": "where", "type": "Ast.Where"}], "return_type": "void", "signature": "protected void visit(Ast.Where where)", "original_string": "  protected void visit(Ast.Where where) {\n    where.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Skip)", "name": "visit", "arg_nums": 1, "params": [{"name": "skip", "type": "Ast.Skip"}], "return_type": "void", "signature": "protected void visit(Ast.Skip skip)", "original_string": "  protected void visit(Ast.Skip skip) {\n    skip.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Take)", "name": "visit", "arg_nums": 1, "params": [{"name": "take", "type": "Ast.Take"}], "return_type": "void", "signature": "protected void visit(Ast.Take take)", "original_string": "  protected void visit(Ast.Take take) {\n    take.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Yield)", "name": "visit", "arg_nums": 1, "params": [{"name": "yield", "type": "Ast.Yield"}], "return_type": "void", "signature": "protected void visit(Ast.Yield yield)", "original_string": "  protected void visit(Ast.Yield yield) {\n    yield.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Into)", "name": "visit", "arg_nums": 1, "params": [{"name": "into", "type": "Ast.Into"}], "return_type": "void", "signature": "protected void visit(Ast.Into into)", "original_string": "  protected void visit(Ast.Into into) {\n    into.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Through)", "name": "visit", "arg_nums": 1, "params": [{"name": "through", "type": "Ast.Through"}], "return_type": "void", "signature": "protected void visit(Ast.Through through)", "original_string": "  protected void visit(Ast.Through through) {\n    through.pat.accept(this);\n    through.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Compute)", "name": "visit", "arg_nums": 1, "params": [{"name": "compute", "type": "Ast.Compute"}], "return_type": "void", "signature": "protected void visit(Ast.Compute compute)", "original_string": "  protected void visit(Ast.Compute compute) {\n    compute.aggregates.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Group)", "name": "visit", "arg_nums": 1, "params": [{"name": "group", "type": "Ast.Group"}], "return_type": "void", "signature": "protected void visit(Ast.Group group)", "original_string": "  protected void visit(Ast.Group group) {\n    group.groupExps.forEach((id, exp) -> {\n      id.accept(this);\n      exp.accept(this);\n    });\n    group.aggregates.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.Aggregate)", "name": "visit", "arg_nums": 1, "params": [{"name": "aggregate", "type": "Ast.Aggregate"}], "return_type": "void", "signature": "protected void visit(Ast.Aggregate aggregate)", "original_string": "  protected void visit(Ast.Aggregate aggregate) {\n    aggregate.aggregate.accept(this);\n    if (aggregate.argument != null) {\n      aggregate.argument.accept(this);\n    }\n    aggregate.id.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.DatatypeDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "datatypeDecl", "type": "Ast.DatatypeDecl"}], "return_type": "void", "signature": "protected void visit(Ast.DatatypeDecl datatypeDecl)", "original_string": "  protected void visit(Ast.DatatypeDecl datatypeDecl) {\n    datatypeDecl.binds.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.DatatypeBind)", "name": "visit", "arg_nums": 1, "params": [{"name": "datatypeBind", "type": "Ast.DatatypeBind"}], "return_type": "void", "signature": "protected void visit(Ast.DatatypeBind datatypeBind)", "original_string": "  protected void visit(Ast.DatatypeBind datatypeBind) {\n    datatypeBind.tyVars.forEach(this::accept);\n    datatypeBind.tyCons.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.TyCon)", "name": "visit", "arg_nums": 1, "params": [{"name": "tyCon", "type": "Ast.TyCon"}], "return_type": "void", "signature": "protected void visit(Ast.TyCon tyCon)", "original_string": "  protected void visit(Ast.TyCon tyCon) {\n    if (tyCon.type != null) {\n      tyCon.type.accept(this);\n    }\n    tyCon.id.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.RecordType)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordType", "type": "Ast.RecordType"}], "return_type": "void", "signature": "protected void visit(Ast.RecordType recordType)", "original_string": "  protected void visit(Ast.RecordType recordType) {\n    recordType.fieldTypes.values().forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.TupleType)", "name": "visit", "arg_nums": 1, "params": [{"name": "tupleType", "type": "Ast.TupleType"}], "return_type": "void", "signature": "protected void visit(Ast.TupleType tupleType)", "original_string": "  protected void visit(Ast.TupleType tupleType) {\n    tupleType.types.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.FunctionType)", "name": "visit", "arg_nums": 1, "params": [{"name": "functionType", "type": "Ast.FunctionType"}], "return_type": "void", "signature": "protected void visit(Ast.FunctionType functionType)", "original_string": "  protected void visit(Ast.FunctionType functionType) {\n    functionType.paramType.accept(this);\n    functionType.resultType.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Ast.CompositeType)", "name": "visit", "arg_nums": 1, "params": [{"name": "compositeType", "type": "Ast.CompositeType"}], "return_type": "void", "signature": "protected void visit(Ast.CompositeType compositeType)", "original_string": "  protected void visit(Ast.CompositeType compositeType) {\n    compositeType.types.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Literal)", "name": "visit", "arg_nums": 1, "params": [{"name": "literal", "type": "Core.Literal"}], "return_type": "void", "signature": "protected void visit(Core.Literal literal)", "original_string": "  protected void visit(Core.Literal literal) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": " core expressions"}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Id)", "name": "visit", "arg_nums": 1, "params": [{"name": "id", "type": "Core.Id"}], "return_type": "void", "signature": "protected void visit(Core.Id id)", "original_string": "  protected void visit(Core.Id id) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Let)", "name": "visit", "arg_nums": 1, "params": [{"name": "let", "type": "Core.Let"}], "return_type": "void", "signature": "protected void visit(Core.Let let)", "original_string": "  protected void visit(Core.Let let) {\n    let.decl.accept(this);\n    let.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Local)", "name": "visit", "arg_nums": 1, "params": [{"name": "local", "type": "Core.Local"}], "return_type": "void", "signature": "protected void visit(Core.Local local)", "original_string": "  protected void visit(Core.Local local) {\n    local.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Case)", "name": "visit", "arg_nums": 1, "params": [{"name": "kase", "type": "Core.Case"}], "return_type": "void", "signature": "protected void visit(Core.Case kase)", "original_string": "  protected void visit(Core.Case kase) {\n    kase.exp.accept(this);\n    kase.matchList.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Apply)", "name": "visit", "arg_nums": 1, "params": [{"name": "apply", "type": "Core.Apply"}], "return_type": "void", "signature": "protected void visit(Core.Apply apply)", "original_string": "  protected void visit(Core.Apply apply) {\n    apply.fn.accept(this);\n    apply.arg.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.RecordSelector)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordSelector", "type": "Core.RecordSelector"}], "return_type": "void", "signature": "protected void visit(Core.RecordSelector recordSelector)", "original_string": "  protected void visit(Core.RecordSelector recordSelector) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Tuple)", "name": "visit", "arg_nums": 1, "params": [{"name": "tuple", "type": "Core.Tuple"}], "return_type": "void", "signature": "protected void visit(Core.Tuple tuple)", "original_string": "  protected void visit(Core.Tuple tuple) {\n    tuple.args.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.DatatypeDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "datatypeDecl", "type": "Core.DatatypeDecl"}], "return_type": "void", "signature": "protected void visit(Core.DatatypeDecl datatypeDecl)", "original_string": "  protected void visit(Core.DatatypeDecl datatypeDecl) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Fn)", "name": "visit", "arg_nums": 1, "params": [{"name": "fn", "type": "Core.Fn"}], "return_type": "void", "signature": "protected void visit(Core.Fn fn)", "original_string": "  protected void visit(Core.Fn fn) {\n    fn.idPat.accept(this);\n    fn.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Match)", "name": "visit", "arg_nums": 1, "params": [{"name": "match", "type": "Core.Match"}], "return_type": "void", "signature": "protected void visit(Core.Match match)", "original_string": "  protected void visit(Core.Match match) {\n    match.pat.accept(this);\n    match.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.From)", "name": "visit", "arg_nums": 1, "params": [{"name": "from", "type": "Core.From"}], "return_type": "void", "signature": "protected void visit(Core.From from)", "original_string": "  protected void visit(Core.From from) {\n    from.steps.forEach(step -> step.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Scan)", "name": "visit", "arg_nums": 1, "params": [{"name": "scan", "type": "Core.Scan"}], "return_type": "void", "signature": "protected void visit(Core.Scan scan)", "original_string": "  protected void visit(Core.Scan scan) {\n    scan.pat.accept(this);\n    scan.exp.accept(this);\n    if (scan.condition != null) {\n      scan.condition.accept(this);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Where)", "name": "visit", "arg_nums": 1, "params": [{"name": "where", "type": "Core.Where"}], "return_type": "void", "signature": "protected void visit(Core.Where where)", "original_string": "  protected void visit(Core.Where where) {\n    where.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Skip)", "name": "visit", "arg_nums": 1, "params": [{"name": "skip", "type": "Core.Skip"}], "return_type": "void", "signature": "protected void visit(Core.Skip skip)", "original_string": "  protected void visit(Core.Skip skip) {\n    skip.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Take)", "name": "visit", "arg_nums": 1, "params": [{"name": "take", "type": "Core.Take"}], "return_type": "void", "signature": "protected void visit(Core.Take take)", "original_string": "  protected void visit(Core.Take take) {\n    take.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.NonRecValDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "valDecl", "type": "Core.NonRecValDecl"}], "return_type": "void", "signature": "protected void visit(Core.NonRecValDecl valDecl)", "original_string": "  protected void visit(Core.NonRecValDecl valDecl) {\n    valDecl.pat.accept(this);\n    valDecl.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.RecValDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "recValDecl", "type": "Core.RecValDecl"}], "return_type": "void", "signature": "protected void visit(Core.RecValDecl recValDecl)", "original_string": "  protected void visit(Core.RecValDecl recValDecl) {\n    recValDecl.list.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Group)", "name": "visit", "arg_nums": 1, "params": [{"name": "group", "type": "Core.Group"}], "return_type": "void", "signature": "protected void visit(Core.Group group)", "original_string": "  protected void visit(Core.Group group) {\n    group.groupExps.values().forEach(this::accept);\n    group.aggregates.values().forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Aggregate)", "name": "visit", "arg_nums": 1, "params": [{"name": "aggregate", "type": "Core.Aggregate"}], "return_type": "void", "signature": "protected void visit(Core.Aggregate aggregate)", "original_string": "  protected void visit(Core.Aggregate aggregate) {\n    aggregate.aggregate.accept(this);\n    if (aggregate.argument != null) {\n      aggregate.argument.accept(this);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Order)", "name": "visit", "arg_nums": 1, "params": [{"name": "order", "type": "Core.Order"}], "return_type": "void", "signature": "protected void visit(Core.Order order)", "original_string": "  protected void visit(Core.Order order) {\n    order.orderItems.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.OrderItem)", "name": "visit", "arg_nums": 1, "params": [{"name": "orderItem", "type": "Core.OrderItem"}], "return_type": "void", "signature": "protected void visit(Core.OrderItem orderItem)", "original_string": "  protected void visit(Core.OrderItem orderItem) {\n    orderItem.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Yield)", "name": "visit", "arg_nums": 1, "params": [{"name": "yield", "type": "Core.Yield"}], "return_type": "void", "signature": "protected void visit(Core.Yield yield)", "original_string": "  protected void visit(Core.Yield yield) {\n    yield.exp.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.TuplePat)", "name": "visit", "arg_nums": 1, "params": [{"name": "tuplePat", "type": "Core.TuplePat"}], "return_type": "void", "signature": "protected void visit(Core.TuplePat tuplePat)", "original_string": "  protected void visit(Core.TuplePat tuplePat) {\n    tuplePat.args.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.RecordPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordPat", "type": "Core.RecordPat"}], "return_type": "void", "signature": "protected void visit(Core.RecordPat recordPat)", "original_string": "  protected void visit(Core.RecordPat recordPat) {\n    recordPat.args.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.ListPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "listPat", "type": "Core.ListPat"}], "return_type": "void", "signature": "protected void visit(Core.ListPat listPat)", "original_string": "  protected void visit(Core.ListPat listPat) {\n    listPat.args.forEach(this::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.ConPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "conPat", "type": "Core.ConPat"}], "return_type": "void", "signature": "protected void visit(Core.ConPat conPat)", "original_string": "  protected void visit(Core.ConPat conPat) {\n    conPat.pat.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.Con0Pat)", "name": "visit", "arg_nums": 1, "params": [{"name": "con0Pat", "type": "Core.Con0Pat"}], "return_type": "void", "signature": "protected void visit(Core.Con0Pat con0Pat)", "original_string": "  protected void visit(Core.Con0Pat con0Pat) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.IdPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "idPat", "type": "Core.IdPat"}], "return_type": "void", "signature": "protected void visit(Core.IdPat idPat)", "original_string": "  protected void visit(Core.IdPat idPat) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.AsPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "asPat", "type": "Core.AsPat"}], "return_type": "void", "signature": "protected void visit(Core.AsPat asPat)", "original_string": "  protected void visit(Core.AsPat asPat) {\n    asPat.pat.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.LiteralPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "idPat", "type": "Core.LiteralPat"}], "return_type": "void", "signature": "protected void visit(Core.LiteralPat idPat)", "original_string": "  protected void visit(Core.LiteralPat idPat) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor.[void]visit(Core.WildcardPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "wildcardPat", "type": "Core.WildcardPat"}], "return_type": "void", "signature": "protected void visit(Core.WildcardPat wildcardPat)", "original_string": "  protected void visit(Core.WildcardPat wildcardPat) {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/ast/Visitor.java", "class_name": "Visitor", "class_uri": "src/main/java/net/hydromatic/morel/ast/Visitor.java.Visitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[]Closure(EvalEnv,ImmutablePairList<Core.Pat, Code>,Pos)", "name": "Closure", "arg_nums": 3, "params": [{"name": "evalEnv", "type": "EvalEnv"}, {"name": "patCodes", "type": "ImmutablePairList<Core.Pat, Code>"}, {"name": "pos", "type": "Pos"}], "return_type": "", "signature": "public Closure(EvalEnv evalEnv,\n      ImmutablePairList<Core.Pat, Code> patCodes, Pos pos)", "original_string": "  public Closure(EvalEnv evalEnv,\n      ImmutablePairList<Core.Pat, Code> patCodes, Pos pos) {\n    this.evalEnv = requireNonNull(evalEnv).fix();\n    this.patCodes = requireNonNull(patCodes);\n    this.pos = pos;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Closure.java", "class_name": "Closure", "class_uri": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Not a public API."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return \"Closure(evalEnv = \" + evalEnv + \", patCodes = \" + patCodes + \")\";\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Closure.java", "class_name": "Closure", "class_uri": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[int]compareTo(Closure)", "name": "compareTo", "arg_nums": 1, "params": [{"name": "o", "type": "Closure"}], "return_type": "int", "signature": "public int compareTo(Closure o)", "original_string": "  public int compareTo(Closure o) {\n    return 0;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Closure.java", "class_name": "Closure", "class_uri": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[EvalEnv]bind(Object)", "name": "bind", "arg_nums": 1, "params": [{"name": "argValue", "type": "Object"}], "return_type": "EvalEnv", "signature": "EvalEnv bind(Object argValue)", "original_string": "  EvalEnv bind(Object argValue) {\n    final EvalEnvHolder envRef = new EvalEnvHolder(evalEnv);\n    for (Core.Pat pat : patCodes.leftList()) {\n      if (bindRecurse(pat, argValue, envRef)) {\n        return envRef.env;\n      }\n    }\n    throw new AssertionError(\"no match\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Closure.java", "class_name": "Closure", "class_uri": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "EvalEnv", "classes": []}, "docstring": " Binds an argument value to create a new environment for a closure.\n\n<p>When calling a simple function such as {@code (fn x => x + 1) 2},\nthe binder sets just contains one variable, {@code x}, and the\nnew environment contains {@code x = 1}.  If the function's\nparameter is a match, more variables might be bound. For example,\nwhen you invoke {@code (fn (x, y) => x + y) (3, 4)}, the binder\nsets {@code x} to 3 and {@code y} to 4."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[EvalEnv]evalBind(EvalEnv)", "name": "evalBind", "arg_nums": 1, "params": [{"name": "env", "type": "EvalEnv"}], "return_type": "EvalEnv", "signature": "EvalEnv evalBind(EvalEnv env)", "original_string": "  EvalEnv evalBind(EvalEnv env) {\n    final EvalEnvHolder envRef = new EvalEnvHolder(env);\n    for (Map.Entry<Core.Pat, Code> patCode : patCodes) {\n      final Object argValue = patCode.getValue().eval(env);\n      final Core.Pat pat = patCode.getKey();\n      if (bindRecurse(pat, argValue, envRef)) {\n        return envRef.env;\n      }\n    }\n    throw new AssertionError(\"no match\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Closure.java", "class_name": "Closure", "class_uri": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "EvalEnv", "classes": []}, "docstring": " Similar to {@link #bind}, but evaluates an expression first."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[Object]bindEval(Object)", "name": "bindEval", "arg_nums": 1, "params": [{"name": "argValue", "type": "Object"}], "return_type": "Object", "signature": "Object bindEval(Object argValue)", "original_string": "  Object bindEval(Object argValue) {\n    final EvalEnvHolder envRef = new EvalEnvHolder(evalEnv);\n    for (Map.Entry<Core.Pat, Code> patCode : patCodes) {\n      final Core.Pat pat = patCode.getKey();\n      if (bindRecurse(pat, argValue, envRef)) {\n        final Code code = patCode.getValue();\n        return code.eval(envRef.env);\n      }\n    }\n    throw new Codes.MorelRuntimeException(Codes.BuiltInExn.BIND, pos);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Closure.java", "class_name": "Closure", "class_uri": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Object", "classes": []}, "docstring": " Similar to {@link #bind}, but also evaluates."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[Object]apply(EvalEnv,Object)", "name": "apply", "arg_nums": 2, "params": [{"name": "env", "type": "EvalEnv"}, {"name": "argValue", "type": "Object"}], "return_type": "Object", "signature": "@Override public Object apply(EvalEnv env, Object argValue)", "original_string": "  @Override public Object apply(EvalEnv env, Object argValue) {\n    return bindEval(argValue);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Closure.java", "class_name": "Closure", "class_uri": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[Describer]describe(Describer)", "name": "describe", "arg_nums": 1, "params": [{"name": "describer", "type": "Describer"}], "return_type": "Describer", "signature": "@Override public Describer describe(Describer describer)", "original_string": "  @Override public Describer describe(Describer describer) {\n    return describer.start(\"closure\", d -> {});\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Closure.java", "class_name": "Closure", "class_uri": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure.[boolean]bindRecurse(Core.Pat,Object,BiConsumer<Core.NamedPat, Object>)", "name": "bindRecurse", "arg_nums": 3, "params": [{"name": "pat", "type": "Core.Pat"}, {"name": "argValue", "type": "Object"}, {"name": "envRef", "type": "BiConsumer<Core.NamedPat, Object>"}], "return_type": "boolean", "signature": "public static boolean bindRecurse(Core.Pat pat, Object argValue,\n      BiConsumer<Core.NamedPat, Object> envRef)", "original_string": "  public static boolean bindRecurse(Core.Pat pat, Object argValue,\n      BiConsumer<Core.NamedPat, Object> envRef) {\n    final List<Object> listValue;\n    final Core.LiteralPat literalPat;\n    switch (pat.op) {\n    case ID_PAT:\n      final Core.IdPat idPat = (Core.IdPat) pat;\n      envRef.accept(idPat, argValue);\n      return true;\n\n    case WILDCARD_PAT:\n      return true;\n\n    case AS_PAT:\n      final Core.AsPat asPat = (Core.AsPat) pat;\n      envRef.accept(asPat, argValue);\n      return bindRecurse(asPat.pat, argValue, envRef);\n\n    case BOOL_LITERAL_PAT:\n    case CHAR_LITERAL_PAT:\n    case STRING_LITERAL_PAT:\n      literalPat = (Core.LiteralPat) pat;\n      return literalPat.value.equals(argValue);\n\n    case INT_LITERAL_PAT:\n      literalPat = (Core.LiteralPat) pat;\n      return ((BigDecimal) literalPat.value).intValue() == (Integer) argValue;\n\n    case REAL_LITERAL_PAT:\n      literalPat = (Core.LiteralPat) pat;\n      return ((BigDecimal) literalPat.value).doubleValue() == (Double) argValue;\n\n    case TUPLE_PAT:\n      final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n      listValue = (List) argValue;\n      return allMatch(tuplePat.args, listValue,\n          (pat1, value) -> bindRecurse(pat1, value, envRef));\n\n    case RECORD_PAT:\n      final Core.RecordPat recordPat = (Core.RecordPat) pat;\n      listValue = (List) argValue;\n      return allMatch(recordPat.args, listValue,\n          (pat1, value) -> bindRecurse(pat1, value, envRef));\n\n    case LIST_PAT:\n      final Core.ListPat listPat = (Core.ListPat) pat;\n      listValue = (List) argValue;\n      if (listValue.size() != listPat.args.size()) {\n        return false;\n      }\n      return allMatch(listPat.args, listValue,\n          (pat1, value) -> bindRecurse(pat1, value, envRef));\n\n    case CONS_PAT:\n      final Core.ConPat consPat = (Core.ConPat) pat;\n      @SuppressWarnings(\"unchecked\") final List<Object> consValue =\n          (List) argValue;\n      if (consValue.isEmpty()) {\n        return false;\n      }\n      final Object head = consValue.get(0);\n      final List<Object> tail = skip(consValue);\n      List<Core.Pat> patArgs = ((Core.TuplePat) consPat.pat).args;\n      return bindRecurse(patArgs.get(0), head, envRef)\n          && bindRecurse(patArgs.get(1), tail, envRef);\n\n    case CON0_PAT:\n      final Core.Con0Pat con0Pat = (Core.Con0Pat) pat;\n      final List con0Value = (List) argValue;\n      return con0Value.get(0).equals(con0Pat.tyCon);\n\n    case CON_PAT:\n      final Core.ConPat conPat = (Core.ConPat) pat;\n      final List conValue = (List) argValue;\n      return conValue.get(0).equals(conPat.tyCon)\n          && bindRecurse(conPat.pat, conValue.get(1), envRef);\n\n    default:\n      throw new AssertionError(\"cannot compile \" + pat.op + \": \" + pat);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Closure.java", "class_name": "Closure", "class_uri": "src/main/java/net/hydromatic/morel/eval/Closure.java.Closure", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Attempts to bind a value to a pattern. Returns whether it has succeeded in\nmatching the whole pattern.\n\n<p>Each time it matches a name, calls a consumer. It's possible that the\nconsumer is called a few times even if the whole pattern ultimately fails\nto match."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Describer.java.Describer.[Describer]start(String,Consumer<Detail>)", "name": "start", "arg_nums": 2, "params": [{"name": "name", "type": "String"}, {"name": "detail", "type": "Consumer<Detail>"}], "return_type": "Describer", "signature": "Describer start(String name, Consumer<Detail> detail)", "original_string": "  Describer start(String name, Consumer<Detail> detail);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Describer.java", "class_name": "Describer", "class_uri": "src/main/java/net/hydromatic/morel/eval/Describer.java.Describer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Describer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Code.java.Code.[Object]eval(EvalEnv)", "name": "eval", "arg_nums": 1, "params": [{"name": "evalEnv", "type": "EvalEnv"}], "return_type": "Object", "signature": "Object eval(EvalEnv evalEnv)", "original_string": "  Object eval(EvalEnv evalEnv);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Code.java", "class_name": "Code", "class_uri": "src/main/java/net/hydromatic/morel/eval/Code.java.Code", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Code.java.Code.[boolean]isConstant()", "name": "isConstant", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "default boolean isConstant()", "original_string": "  default boolean isConstant() {\n    return false;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Code.java", "class_name": "Code", "class_uri": "src/main/java/net/hydromatic/morel/eval/Code.java.Code", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[]Unit()", "name": "Unit", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Unit()", "original_string": "  private Unit() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Unit.java", "class_name": "Unit", "class_uri": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return \"()\";\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Unit.java", "class_name": "Unit", "class_uri": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[Object]get(int)", "name": "get", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "Object", "signature": "public Object get(int index)", "original_string": "  public Object get(int index) {\n    throw new IndexOutOfBoundsException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Unit.java", "class_name": "Unit", "class_uri": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[int]size()", "name": "size", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int size()", "original_string": "  public int size() {\n    return 0;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Unit.java", "class_name": "Unit", "class_uri": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit.[int]compareTo(Unit)", "name": "compareTo", "arg_nums": 1, "params": [{"name": "o", "type": "Unit"}], "return_type": "int", "signature": "public int compareTo(Unit o)", "original_string": "  public int compareTo(Unit o) {\n    return 0;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Unit.java", "class_name": "Unit", "class_uri": "src/main/java/net/hydromatic/morel/eval/Unit.java.Unit", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable.java.Applicable.[Object]apply(EvalEnv,Object)", "name": "apply", "arg_nums": 2, "params": [{"name": "env", "type": "EvalEnv"}, {"name": "argValue", "type": "Object"}], "return_type": "Object", "signature": "Object apply(EvalEnv env, Object argValue)", "original_string": "  Object apply(EvalEnv env, Object argValue);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable.java", "class_name": "Applicable", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable.java.Applicable", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable.java.Applicable.[Code]asCode()", "name": "asCode", "arg_nums": 0, "params": [], "return_type": "Code", "signature": "default Code asCode()", "original_string": "  default Code asCode() {\n    return new Code() {\n      @Override public Describer describe(Describer describer) {\n        return describer.start(\"code2\", d ->\n            d.arg(\"applicable\", Applicable.this));\n      }\n\n      @Override public Object eval(EvalEnv env) {\n        return Applicable.this;\n      }\n\n      @Override public boolean isConstant() {\n        return true;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable.java", "class_name": "Applicable", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable.java.Applicable", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Converts this Applicable to a Code that has similar effect\n(but is less efficient)."}, {"uris": "src/main/java/net/hydromatic/morel/eval/DescriberImpl.java.DescriberImpl.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return buf.toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/DescriberImpl.java", "class_name": "DescriberImpl", "class_uri": "src/main/java/net/hydromatic/morel/eval/DescriberImpl.java.DescriberImpl", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/DescriberImpl.java.DescriberImpl.[Describer]start(String,Consumer<Detail>)", "name": "start", "arg_nums": 2, "params": [{"name": "name", "type": "String"}, {"name": "consumer", "type": "Consumer<Detail>"}], "return_type": "Describer", "signature": "@Override public Describer start(String name,\n      Consumer<Detail> consumer)", "original_string": "  @Override public Describer start(String name,\n      Consumer<Detail> consumer) {\n    buf.append(name);\n    final DetailImpl detail = new DetailImpl();\n    consumer.accept(detail);\n    detail.end();\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/DescriberImpl.java", "class_name": "DescriberImpl", "class_uri": "src/main/java/net/hydromatic/morel/eval/DescriberImpl.java.DescriberImpl", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/File.java.File.[File]expand()", "name": "expand", "arg_nums": 0, "params": [], "return_type": "File", "signature": "default File expand()", "original_string": "  default File expand() {\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/File.java", "class_name": "File", "class_uri": "src/main/java/net/hydromatic/morel/eval/File.java.File", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "File", "classes": []}, "docstring": " Expands this file to a file with a more precise type.\n\n<p>During expansion, record types may get new fields, never lose them.\n\n<p>This file object may or may not be mutable. If this file is immutable\nand is expanded, returns the new file. If this file is mutable, returns\nthis file regardless of whether expansion occurred; the caller cannot\ndiscern whether expansion occurred."}, {"uris": "src/main/java/net/hydromatic/morel/eval/File.java.File.[File]discoverField(TypeSystem,String)", "name": "discoverField", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "fieldName", "type": "String"}], "return_type": "File", "signature": "default File discoverField(TypeSystem typeSystem,\n      String fieldName)", "original_string": "  default File discoverField(TypeSystem typeSystem,\n      String fieldName) {\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/File.java", "class_name": "File", "class_uri": "src/main/java/net/hydromatic/morel/eval/File.java.File", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "File", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[Object]getOpt(String)", "name": "getOpt", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Object", "signature": "Object getOpt(String name)", "original_string": "  Object getOpt(String name);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java", "class_name": "EvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Object", "classes": []}, "docstring": " Returns the binding of {@code name} if bound, null if not."}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[EvalEnv]bind(String,Object)", "name": "bind", "arg_nums": 2, "params": [{"name": "name", "type": "String"}, {"name": "value", "type": "Object"}], "return_type": "EvalEnv", "signature": "default EvalEnv bind(String name, Object value)", "original_string": "  default EvalEnv bind(String name, Object value) {\n    return new EvalEnvs.SubEvalEnv(this, name, value);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java", "class_name": "EvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "EvalEnv", "classes": []}, "docstring": " Creates an environment that has the same content as this one, plus\nthe binding (name, value)."}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[MutableEvalEnv]bindMutable(String)", "name": "bindMutable", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "MutableEvalEnv", "signature": "default MutableEvalEnv bindMutable(String name)", "original_string": "  default MutableEvalEnv bindMutable(String name) {\n    return new EvalEnvs.MutableSubEvalEnv(this, name);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java", "class_name": "EvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "MutableEvalEnv", "classes": []}, "docstring": " Creates an evaluation environment that has the same content as this one,\nplus a mutable slot."}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[MutableEvalEnv]bindMutablePat(Core.Pat)", "name": "bindMutablePat", "arg_nums": 1, "params": [{"name": "pat", "type": "Core.Pat"}], "return_type": "MutableEvalEnv", "signature": "default MutableEvalEnv bindMutablePat(Core.Pat pat)", "original_string": "  default MutableEvalEnv bindMutablePat(Core.Pat pat) {\n    if (pat instanceof Core.IdPat) {\n      // Pattern is simple; use a simple implementation.\n      return bindMutable(((Core.IdPat) pat).name);\n    }\n    final List<String> names = new ArrayList<>();\n    pat.accept(new Visitor() {\n      @Override protected void visit(Core.IdPat idPat) {\n        names.add(idPat.name);\n      }\n      @Override protected void visit(Core.AsPat asPat) {\n        names.add(asPat.name);\n        super.visit(asPat);\n      }\n    });\n    return new EvalEnvs.MutablePatSubEvalEnv(this, pat, names);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java", "class_name": "EvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "MutableEvalEnv", "classes": []}, "docstring": " Creates an evaluation environment that has the same content as this one,\nplus mutable slots for each name in a pattern."}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[MutableEvalEnv]bindMutableArray(List<String>)", "name": "bindMutableArray", "arg_nums": 1, "params": [{"name": "names", "type": "List<String>"}], "return_type": "MutableEvalEnv", "signature": "default MutableEvalEnv bindMutableArray(List<String> names)", "original_string": "  default MutableEvalEnv bindMutableArray(List<String> names) {\n    if (names.size() == 1) {\n      return bindMutable(names.get(0));\n    }\n    return new EvalEnvs.MutableArraySubEvalEnv(this, names);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java", "class_name": "EvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "MutableEvalEnv", "classes": []}, "docstring": " Creates an evaluation environment that has the same content as this one,\nplus a mutable slot or slots.\n\n<p>If {@code names} has one element, calling\n{@link MutableEvalEnv#set(Object)} will populate the slot will be filled by\nan object; if {@code names} has more than one element, {@code set} will\nexpect to be given an array with the same number of elements."}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[void]visit(BiConsumer<String, Object>)", "name": "visit", "arg_nums": 1, "params": [{"name": "consumer", "type": "BiConsumer<String, Object>"}], "return_type": "void", "signature": "void visit(BiConsumer<String, Object> consumer)", "original_string": "  void visit(BiConsumer<String, Object> consumer);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java", "class_name": "EvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Visits every variable binding in this environment.\n\n<p>Bindings that are obscured by more recent bindings of the same name\nare visited, but after the more obscuring bindings."}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[Map<String, Object>]valueMap()", "name": "valueMap", "arg_nums": 0, "params": [], "return_type": "Map<String, Object>", "signature": "default Map<String, Object> valueMap()", "original_string": "  default Map<String, Object> valueMap() {\n    final Map<String, Object> valueMap = new HashMap<>();\n    visit(valueMap::putIfAbsent);\n    return valueMap;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java", "class_name": "EvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "docstring": " Returns a map of the values and bindings."}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv.[EvalEnv]fix()", "name": "fix", "arg_nums": 0, "params": [], "return_type": "EvalEnv", "signature": "default EvalEnv fix()", "original_string": "  default EvalEnv fix() {\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java", "class_name": "EvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnv.java.EvalEnv", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "EvalEnv", "classes": []}, "docstring": " Converts this environment to a non-mutable environment."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2.[]Applicable2(BuiltIn,Pos)", "name": "Applicable2", "arg_nums": 2, "params": [{"name": "builtIn", "type": "BuiltIn"}, {"name": "pos", "type": "Pos"}], "return_type": "", "signature": "protected Applicable2(BuiltIn builtIn, Pos pos)", "original_string": "  protected Applicable2(BuiltIn builtIn, Pos pos) {\n    super(builtIn, pos);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable2.java", "class_name": "Applicable2", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2.[]Applicable2(BuiltIn)", "name": "Applicable2", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "", "signature": "protected Applicable2(BuiltIn builtIn)", "original_string": "  protected Applicable2(BuiltIn builtIn) {\n    this(builtIn, Pos.ZERO);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable2.java", "class_name": "Applicable2", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2.[Object]apply(EvalEnv,Object)", "name": "apply", "arg_nums": 2, "params": [{"name": "env", "type": "EvalEnv"}, {"name": "argValue", "type": "Object"}], "return_type": "Object", "signature": "@Override public Object apply(EvalEnv env, Object argValue)", "original_string": "  @Override public Object apply(EvalEnv env, Object argValue) {\n    final List list = (List) argValue;\n    return apply((A0) list.get(0), (A1) list.get(1));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable2.java", "class_name": "Applicable2", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2.[R]apply(A0,A1)", "name": "apply", "arg_nums": 2, "params": [{"name": "a0", "type": "A0"}, {"name": "a1", "type": "A1"}], "return_type": "R", "signature": "public abstract R apply(A0 a0, A1 a1)", "original_string": "  public abstract R apply(A0 a0, A1 a1);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable2.java", "class_name": "Applicable2", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable2.java.Applicable2", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Session.java.Session.[]Session(Map<Prop, Object>)", "name": "Session", "arg_nums": 1, "params": [{"name": "map", "type": "Map<Prop, Object>"}], "return_type": "", "signature": "public Session(Map<Prop, Object> map)", "original_string": "  public Session(Map<Prop, Object> map) {\n    this.map = map;\n    this.file =\n        Suppliers.memoize(() ->\n            Files.create(Prop.DIRECTORY.fileValue(this.map)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Session.java", "class_name": "Session", "class_uri": "src/main/java/net/hydromatic/morel/eval/Session.java.Session", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a Session.\n\n<p>The {@code map} parameter, that becomes the property map, is used as is,\nnot copied. It may be immutable if the session is for a narrow, internal\nuse. Otherwise, it should probably be a {@link LinkedHashMap} to provide\ndeterministic iteration order.\n\n@param map Map that contains property values"}, {"uris": "src/main/java/net/hydromatic/morel/eval/Session.java.Session.[void]withShell(Shell,Consumer<String>,Consumer<Session>)", "name": "withShell", "arg_nums": 3, "params": [{"name": "shell", "type": "Shell"}, {"name": "outLines", "type": "Consumer<String>"}, {"name": "consumer", "type": "Consumer<Session>"}], "return_type": "void", "signature": "public void withShell(Shell shell, Consumer<String> outLines,\n      Consumer<Session> consumer)", "original_string": "  public void withShell(Shell shell, Consumer<String> outLines,\n      Consumer<Session> consumer) {\n    final Shell prevShell = this.shell;\n    try {\n      this.shell = requireNonNull(shell, \"shell\");\n      consumer.accept(this);\n    } catch (RuntimeException e) {\n      final StringBuilder buf = new StringBuilder();\n      prevShell.handle(e, buf);\n      outLines.accept(buf.toString());\n    } finally {\n      this.shell = prevShell;\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Session.java", "class_name": "Session", "class_uri": "src/main/java/net/hydromatic/morel/eval/Session.java.Session", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls some code with a new value of {@link Shell}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Session.java.Session.[void]withoutHandlingExceptions(Consumer<Session>)", "name": "withoutHandlingExceptions", "arg_nums": 1, "params": [{"name": "consumer", "type": "Consumer<Session>"}], "return_type": "void", "signature": "public void withoutHandlingExceptions(Consumer<Session> consumer)", "original_string": "  public void withoutHandlingExceptions(Consumer<Session> consumer) {\n    final Shell prevShell = this.shell;\n    try {\n      this.shell = Shells.BARF;\n      consumer.accept(this);\n    } finally {\n      this.shell = prevShell;\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Session.java", "class_name": "Session", "class_uri": "src/main/java/net/hydromatic/morel/eval/Session.java.Session", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls some code with a {@link Shell} that does not handle errors."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Session.java.Session.[void]use(String,boolean,Pos)", "name": "use", "arg_nums": 3, "params": [{"name": "fileName", "type": "String"}, {"name": "silent", "type": "boolean"}, {"name": "pos", "type": "Pos"}], "return_type": "void", "signature": "public void use(String fileName, boolean silent, Pos pos)", "original_string": "  public void use(String fileName, boolean silent, Pos pos) {\n    shell.use(fileName, silent, pos);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Session.java", "class_name": "Session", "class_uri": "src/main/java/net/hydromatic/morel/eval/Session.java.Session", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Session.java.Session.[void]handle(MorelException,StringBuilder)", "name": "handle", "arg_nums": 2, "params": [{"name": "e", "type": "MorelException"}, {"name": "buf", "type": "StringBuilder"}], "return_type": "void", "signature": "public void handle(MorelException e, StringBuilder buf)", "original_string": "  public void handle(MorelException e, StringBuilder buf) {\n    shell.handle((RuntimeException) e, buf);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Session.java", "class_name": "Session", "class_uri": "src/main/java/net/hydromatic/morel/eval/Session.java.Session", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3.[]Applicable3(BuiltIn,Pos)", "name": "Applicable3", "arg_nums": 2, "params": [{"name": "builtIn", "type": "BuiltIn"}, {"name": "pos", "type": "Pos"}], "return_type": "", "signature": "protected Applicable3(BuiltIn builtIn, Pos pos)", "original_string": "  protected Applicable3(BuiltIn builtIn, Pos pos) {\n    super(builtIn, pos);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable3.java", "class_name": "Applicable3", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3.[]Applicable3(BuiltIn)", "name": "Applicable3", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "", "signature": "protected Applicable3(BuiltIn builtIn)", "original_string": "  protected Applicable3(BuiltIn builtIn) {\n    this(builtIn, Pos.ZERO);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable3.java", "class_name": "Applicable3", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3.[Object]apply(EvalEnv,Object)", "name": "apply", "arg_nums": 2, "params": [{"name": "env", "type": "EvalEnv"}, {"name": "argValue", "type": "Object"}], "return_type": "Object", "signature": "@Override public Object apply(EvalEnv env, Object argValue)", "original_string": "  @Override public Object apply(EvalEnv env, Object argValue) {\n    final List list = (List) argValue;\n    return apply((A0) list.get(0), (A1) list.get(1), (A2) list.get(2));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable3.java", "class_name": "Applicable3", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3.[R]apply(A0,A1,A2)", "name": "apply", "arg_nums": 3, "params": [{"name": "a0", "type": "A0"}, {"name": "a1", "type": "A1"}, {"name": "a2", "type": "A2"}], "return_type": "R", "signature": "public abstract R apply(A0 a0, A1 a1, A2 a2)", "original_string": "  public abstract R apply(A0 a0, A1 a1, A2 a2);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Applicable3.java", "class_name": "Applicable3", "class_uri": "src/main/java/net/hydromatic/morel/eval/Applicable3.java.Applicable3", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[]ApplicableImpl(String,Pos)", "name": "ApplicableImpl", "arg_nums": 2, "params": [{"name": "name", "type": "String"}, {"name": "pos", "type": "Pos"}], "return_type": "", "signature": "protected ApplicableImpl(String name, Pos pos)", "original_string": "  protected ApplicableImpl(String name, Pos pos) {\n    this.name = name;\n    this.pos = pos;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java", "class_name": "ApplicableImpl", "class_uri": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[]ApplicableImpl(String)", "name": "ApplicableImpl", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "", "signature": "protected ApplicableImpl(String name)", "original_string": "  protected ApplicableImpl(String name) {\n    this(name, Pos.ZERO);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java", "class_name": "ApplicableImpl", "class_uri": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[]ApplicableImpl(BuiltIn,Pos)", "name": "ApplicableImpl", "arg_nums": 2, "params": [{"name": "builtIn", "type": "BuiltIn"}, {"name": "pos", "type": "Pos"}], "return_type": "", "signature": "protected ApplicableImpl(BuiltIn builtIn, Pos pos)", "original_string": "  protected ApplicableImpl(BuiltIn builtIn, Pos pos) {\n    this(builtIn.mlName.startsWith(\"op \")\n        ? builtIn.mlName.substring(\"op \".length())\n        : builtIn.structure + \".\" + builtIn.mlName,\n        pos);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java", "class_name": "ApplicableImpl", "class_uri": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates an ApplicableImpl that directly implements a BuiltIn.\nThe parameter is currently only for provenance purposes."}, {"uris": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[]ApplicableImpl(BuiltIn)", "name": "ApplicableImpl", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "", "signature": "protected ApplicableImpl(BuiltIn builtIn)", "original_string": "  protected ApplicableImpl(BuiltIn builtIn) {\n    this(builtIn, Pos.ZERO);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java", "class_name": "ApplicableImpl", "class_uri": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates an ApplicableImpl that directly implements a BuiltIn.\nThe parameter is currently only for provenance purposes."}, {"uris": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return name;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java", "class_name": "ApplicableImpl", "class_uri": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl.[Describer]describe(Describer)", "name": "describe", "arg_nums": 1, "params": [{"name": "describer", "type": "Describer"}], "return_type": "Describer", "signature": "@Override public Describer describe(Describer describer)", "original_string": "  @Override public Describer describe(Describer describer) {\n    return describer.start(name, d -> {});\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java", "class_name": "ApplicableImpl", "class_uri": "src/main/java/net/hydromatic/morel/eval/ApplicableImpl.java.ApplicableImpl", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Describer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Describable.java.Describable.[Describer]describe(Describer)", "name": "describe", "arg_nums": 1, "params": [{"name": "describer", "type": "Describer"}], "return_type": "Describer", "signature": "Describer describe(Describer describer)", "original_string": "  Describer describe(Describer describer);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Describable.java", "class_name": "Describable", "class_uri": "src/main/java/net/hydromatic/morel/eval/Describable.java.Describable", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Describer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[]Codes()", "name": "Codes", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Codes()", "original_string": "  private Codes() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[String]describe(Code)", "name": "describe", "arg_nums": 1, "params": [{"name": "code", "type": "Code"}], "return_type": "String", "signature": "public static String describe(Code code)", "original_string": "  public static String describe(Code code) {\n    final Code code2 = Codes.strip(code);\n    return code2.describe(new DescriberImpl()).toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Describes a {@link Code}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]constant(Object)", "name": "constant", "arg_nums": 1, "params": [{"name": "value", "type": "Object"}], "return_type": "Code", "signature": "public static Code constant(Object value)", "original_string": "  public static Code constant(Object value) {\n    return new ConstantCode(value);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Returns a Code that evaluates to the same value in all environments."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]identity(BuiltIn)", "name": "identity", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "ApplicableImpl", "signature": "private static ApplicableImpl identity(BuiltIn builtIn)", "original_string": "  private static ApplicableImpl identity(BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return arg;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ApplicableImpl", "classes": []}, "docstring": " Returns an Applicable that returns its argument."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]andAlso(Code,Code)", "name": "andAlso", "arg_nums": 2, "params": [{"name": "code0", "type": "Code"}, {"name": "code1", "type": "Code"}], "return_type": "Code", "signature": "public static Code andAlso(Code code0, Code code1)", "original_string": "  public static Code andAlso(Code code0, Code code1) {\n    return new AndAlsoCode(code0, code1);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Returns a Code that evaluates \"andalso\"."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]orElse(Code,Code)", "name": "orElse", "arg_nums": 2, "params": [{"name": "code0", "type": "Code"}, {"name": "code1", "type": "Code"}], "return_type": "Code", "signature": "public static Code orElse(Code code0, Code code1)", "original_string": "  public static Code orElse(Code code0, Code code1) {\n    return new OrElseCode(code0, code1);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Returns a Code that evaluates \"orelse\"."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]strip(Code)", "name": "strip", "arg_nums": 1, "params": [{"name": "code", "type": "Code"}], "return_type": "Code", "signature": "public static Code strip(Code code)", "original_string": "  public static Code strip(Code code) {\n    for (;;) {\n      if (code instanceof WrapRelList) {\n        code = ((WrapRelList) code).code;\n      } else {\n        return code;\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Removes wrappers, in particular the one due to\n{@link #wrapRelList(Code)}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]get(String)", "name": "get", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Code", "signature": "public static Code get(String name)", "original_string": "  public static Code get(String name) {\n    return new GetCode(name);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Returns a Code that returns the value of variable \"name\" in the current\nenvironment."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]getTuple(Iterable<String>)", "name": "getTuple", "arg_nums": 1, "params": [{"name": "names", "type": "Iterable<String>"}], "return_type": "Code", "signature": "public static Code getTuple(Iterable<String> names)", "original_string": "  public static Code getTuple(Iterable<String> names) {\n    if (Iterables.isEmpty(names)) {\n      return new ConstantCode(Unit.INSTANCE);\n    }\n    return new GetTupleCode(ImmutableList.copyOf(names));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Returns a Code that returns a tuple consisting of the values of variables\n\"name0\", ... \"nameN\" in the current environment."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]let(List<Code>,Code)", "name": "let", "arg_nums": 2, "params": [{"name": "matchCodes", "type": "List<Code>"}, {"name": "resultCode", "type": "Code"}], "return_type": "Code", "signature": "public static Code let(List<Code> matchCodes, Code resultCode)", "original_string": "  public static Code let(List<Code> matchCodes, Code resultCode) {\n    switch (matchCodes.size()) {\n    case 0:\n      return resultCode;\n\n    case 1:\n      // Use a more efficient runtime path if the list has only one element.\n      // The effect is the same.\n      return new Let1Code(matchCodes.get(0), resultCode);\n\n    default:\n      return new LetCode(ImmutableList.copyOf(matchCodes), resultCode);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]apply(Code,Code)", "name": "apply", "arg_nums": 2, "params": [{"name": "fnCode", "type": "Code"}, {"name": "argCode", "type": "Code"}], "return_type": "Code", "signature": "public static Code apply(Code fnCode, Code argCode)", "original_string": "  public static Code apply(Code fnCode, Code argCode) {\n    assert !fnCode.isConstant(); // if constant, use \"apply(Closure, Code)\"\n    return new ApplyCodeCode(fnCode, argCode);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Generates the code for applying a function (or function value) to an\nargument."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]apply(Applicable,Code)", "name": "apply", "arg_nums": 2, "params": [{"name": "fnValue", "type": "Applicable"}, {"name": "argCode", "type": "Code"}], "return_type": "Code", "signature": "public static Code apply(Applicable fnValue, Code argCode)", "original_string": "  public static Code apply(Applicable fnValue, Code argCode) {\n    return new ApplyCode(fnValue, argCode);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Generates the code for applying a function value to an argument."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]apply2(Applicable2,Code,Code)", "name": "apply2", "arg_nums": 3, "params": [{"name": "fnValue", "type": "Applicable2"}, {"name": "argCode0", "type": "Code"}, {"name": "argCode1", "type": "Code"}], "return_type": "Code", "signature": "public static Code apply2(Applicable2 fnValue, Code argCode0, Code argCode1)", "original_string": "  public static Code apply2(Applicable2 fnValue, Code argCode0, Code argCode1) {\n    return new ApplyCode2(fnValue, argCode0, argCode1);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Generates the code for applying a function value to two arguments."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]apply3(Applicable3,Code,Code,Code)", "name": "apply3", "arg_nums": 4, "params": [{"name": "fnValue", "type": "Applicable3"}, {"name": "argCode0", "type": "Code"}, {"name": "argCode1", "type": "Code"}, {"name": "argCode2", "type": "Code"}], "return_type": "Code", "signature": "public static Code apply3(Applicable3 fnValue, Code argCode0, Code argCode1,\n      Code argCode2)", "original_string": "  public static Code apply3(Applicable3 fnValue, Code argCode0, Code argCode1,\n      Code argCode2) {\n    return new ApplyCode3(fnValue, argCode0, argCode1, argCode2);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Generates the code for applying a function value to three arguments."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]list(Iterable<? extends Code>)", "name": "list", "arg_nums": 1, "params": [{"name": "codes", "type": "Iterable<? extends Code>"}], "return_type": "Code", "signature": "public static Code list(Iterable<? extends Code> codes)", "original_string": "  public static Code list(Iterable<? extends Code> codes) {\n    return tuple(codes);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]tuple(Iterable<? extends Code>)", "name": "tuple", "arg_nums": 1, "params": [{"name": "codes", "type": "Iterable<? extends Code>"}], "return_type": "Code", "signature": "public static Code tuple(Iterable<? extends Code> codes)", "original_string": "  public static Code tuple(Iterable<? extends Code> codes) {\n    return new TupleCode(ImmutableList.copyOf(codes));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]wrapRelList(Code)", "name": "wrapRelList", "arg_nums": 1, "params": [{"name": "code", "type": "Code"}], "return_type": "Code", "signature": "public static Code wrapRelList(Code code)", "original_string": "  public static Code wrapRelList(Code code) {\n    return new WrapRelList(code);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]tyCon(Type,String)", "name": "tyCon", "arg_nums": 2, "params": [{"name": "dataType", "type": "Type"}, {"name": "name", "type": "String"}], "return_type": "Applicable", "signature": "public static Applicable tyCon(Type dataType, String name)", "original_string": "  public static Applicable tyCon(Type dataType, String name) {\n    requireNonNull(dataType);\n    requireNonNull(name);\n    return new ApplicableImpl(\"tyCon\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return ImmutableList.of(name, arg);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Returns an applicable that constructs an instance of a datatype.\nThe instance is a list with two elements [constructorName, value]."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Code]from(Supplier<RowSink>)", "name": "from", "arg_nums": 1, "params": [{"name": "rowSinkFactory", "type": "Supplier<RowSink>"}], "return_type": "Code", "signature": "public static Code from(Supplier<RowSink> rowSinkFactory)", "original_string": "  public static Code from(Supplier<RowSink> rowSinkFactory) {\n    return new Code() {\n      @Override public Describer describe(Describer describer) {\n        return describer.start(\"from\", d ->\n            d.arg(\"sink\", rowSinkFactory.get()));\n      }\n\n      @Override public Object eval(EvalEnv env) {\n        final RowSink rowSink = rowSinkFactory.get();\n        rowSink.start(env);\n        rowSink.accept(env);\n        return rowSink.result(env);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]scanRowSink(Op,Core.Pat,Code,Code,RowSink)", "name": "scanRowSink", "arg_nums": 5, "params": [{"name": "op", "type": "Op"}, {"name": "pat", "type": "Core.Pat"}, {"name": "code", "type": "Code"}, {"name": "conditionCode", "type": "Code"}, {"name": "rowSink", "type": "RowSink"}], "return_type": "RowSink", "signature": "public static RowSink scanRowSink(Op op, Core.Pat pat, Code code,\n      Code conditionCode, RowSink rowSink)", "original_string": "  public static RowSink scanRowSink(Op op, Core.Pat pat, Code code,\n      Code conditionCode, RowSink rowSink) {\n    return new ScanRowSink(op, pat, code, conditionCode, rowSink);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RowSink", "classes": []}, "docstring": " Creates a {@link RowSink} for a {@code join} clause."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]whereRowSink(Code,RowSink)", "name": "whereRowSink", "arg_nums": 2, "params": [{"name": "filterCode", "type": "Code"}, {"name": "rowSink", "type": "RowSink"}], "return_type": "RowSink", "signature": "public static RowSink whereRowSink(Code filterCode, RowSink rowSink)", "original_string": "  public static RowSink whereRowSink(Code filterCode, RowSink rowSink) {\n    return new WhereRowSink(filterCode, rowSink);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RowSink", "classes": []}, "docstring": " Creates a {@link RowSink} for a {@code where} clause."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]skipRowSink(Code,RowSink)", "name": "skipRowSink", "arg_nums": 2, "params": [{"name": "filterCode", "type": "Code"}, {"name": "rowSink", "type": "RowSink"}], "return_type": "RowSink", "signature": "public static RowSink skipRowSink(Code filterCode, RowSink rowSink)", "original_string": "  public static RowSink skipRowSink(Code filterCode, RowSink rowSink) {\n    return new SkipRowSink(filterCode, rowSink);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RowSink", "classes": []}, "docstring": " Creates a {@link RowSink} for a {@code skip} clause."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]takeRowSink(Code,RowSink)", "name": "takeRowSink", "arg_nums": 2, "params": [{"name": "filterCode", "type": "Code"}, {"name": "rowSink", "type": "RowSink"}], "return_type": "RowSink", "signature": "public static RowSink takeRowSink(Code filterCode, RowSink rowSink)", "original_string": "  public static RowSink takeRowSink(Code filterCode, RowSink rowSink) {\n    return new TakeRowSink(filterCode, rowSink);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RowSink", "classes": []}, "docstring": " Creates a {@link RowSink} for a {@code take} clause."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]orderRowSink(Iterable<? extends Map.Entry<Code, Boolean>>,ImmutableList<Binding>,RowSink)", "name": "orderRowSink", "arg_nums": 3, "params": [{"name": "codes", "type": "Iterable<? extends Map.Entry<Code, Boolean>>"}, {"name": "bindings", "type": "ImmutableList<Binding>"}, {"name": "rowSink", "type": "RowSink"}], "return_type": "RowSink", "signature": "public static RowSink orderRowSink(\n      Iterable<? extends Map.Entry<Code, Boolean>> codes,\n      ImmutableList<Binding> bindings, RowSink rowSink)", "original_string": "  public static RowSink orderRowSink(\n      Iterable<? extends Map.Entry<Code, Boolean>> codes,\n      ImmutableList<Binding> bindings, RowSink rowSink) {\n    return new OrderRowSink(ImmutablePairList.copyOf(codes),\n        transformEager(bindings, b -> b.id.name),\n        rowSink);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RowSink", "classes": []}, "docstring": " Creates a {@link RowSink} for a {@code order} clause."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]groupRowSink(Code,ImmutableList<Applicable>,ImmutableList<String>,ImmutableList<String>,ImmutableList<String>,RowSink)", "name": "groupRowSink", "arg_nums": 6, "params": [{"name": "keyCode", "type": "Code"}, {"name": "aggregateCodes", "type": "ImmutableList<Applicable>"}, {"name": "inNames", "type": "ImmutableList<String>"}, {"name": "keyNames", "type": "ImmutableList<String>"}, {"name": "outNames", "type": "ImmutableList<String>"}, {"name": "rowSink", "type": "RowSink"}], "return_type": "RowSink", "signature": "public static RowSink groupRowSink(Code keyCode,\n      ImmutableList<Applicable> aggregateCodes, ImmutableList<String> inNames,\n      ImmutableList<String> keyNames,\n      ImmutableList<String> outNames, RowSink rowSink)", "original_string": "  public static RowSink groupRowSink(Code keyCode,\n      ImmutableList<Applicable> aggregateCodes, ImmutableList<String> inNames,\n      ImmutableList<String> keyNames,\n      ImmutableList<String> outNames, RowSink rowSink) {\n    return new GroupRowSink(keyCode, aggregateCodes, inNames, keyNames,\n        outNames, rowSink);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RowSink", "classes": []}, "docstring": " Creates a {@link RowSink} for a {@code group} clause."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]yieldRowSink(Map<String, Code>,RowSink)", "name": "yieldRowSink", "arg_nums": 2, "params": [{"name": "yieldCodes", "type": "Map<String, Code>"}, {"name": "rowSink", "type": "RowSink"}], "return_type": "RowSink", "signature": "public static RowSink yieldRowSink(Map<String, Code> yieldCodes,\n      RowSink rowSink)", "original_string": "  public static RowSink yieldRowSink(Map<String, Code> yieldCodes,\n      RowSink rowSink) {\n    return new YieldRowSink(ImmutableList.copyOf(yieldCodes.keySet()),\n        ImmutableList.copyOf(yieldCodes.values()), rowSink);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RowSink", "classes": []}, "docstring": " Creates a {@link RowSink} for a non-terminal {@code yield} step."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[RowSink]collectRowSink(Code)", "name": "collectRowSink", "arg_nums": 1, "params": [{"name": "code", "type": "Code"}], "return_type": "RowSink", "signature": "public static RowSink collectRowSink(Code code)", "original_string": "  public static RowSink collectRowSink(Code code) {\n    return new CollectRowSink(code);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RowSink", "classes": []}, "docstring": " Creates a {@link RowSink} to collect the results of a {@code from}\nexpression."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]nth(int)", "name": "nth", "arg_nums": 1, "params": [{"name": "slot", "type": "int"}], "return_type": "Applicable", "signature": "public static Applicable nth(int slot)", "original_string": "  public static Applicable nth(int slot) {\n    assert slot >= 0 : slot;\n    return new ApplicableImpl(\"nth:\" + slot) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return ((List) arg).get(slot);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Returns an applicable that returns the {@code slot}th field of a tuple or\nrecord."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[String]stringConcat(Pos,String,List<String>)", "name": "stringConcat", "arg_nums": 3, "params": [{"name": "pos", "type": "Pos"}, {"name": "separator", "type": "String"}, {"name": "list", "type": "List<String>"}], "return_type": "String", "signature": "private static String stringConcat(Pos pos, String separator,\n      List<String> list)", "original_string": "  private static String stringConcat(Pos pos, String separator,\n      List<String> list) {\n    long n = 0;\n    for (String s : list) {\n      n += s.length();\n      n += separator.length();\n    }\n    if (n > STRING_MAX_SIZE) {\n      throw new MorelRuntimeException(BuiltInExn.SIZE, pos);\n    }\n    return String.join(separator, list);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]stringMap(Applicable)", "name": "stringMap", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable stringMap(Applicable f)", "original_string": "  private static Applicable stringMap(Applicable f) {\n    return new ApplicableImpl(\"String.map$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final String s = (String) arg;\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n          final char c = s.charAt(i);\n          final char c2 = (Character) f.apply(env, c);\n          buf.append(c2);\n        }\n        return buf.toString();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]translate(Applicable)", "name": "translate", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable translate(Applicable f)", "original_string": "  private static Applicable translate(Applicable f) {\n    return new ApplicableImpl(\"String.translate$f\") {\n      @Override public String apply(EvalEnv env, Object arg) {\n        final String s = (String) arg;\n        final StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n          final char c = s.charAt(i);\n          final String c2 = (String) f.apply(env, c);\n          buf.append(c2);\n        }\n        return buf.toString();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]isPrefix(String)", "name": "isPrefix", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "Applicable", "signature": "private static Applicable isPrefix(String s)", "original_string": "  private static Applicable isPrefix(String s) {\n    return new ApplicableImpl(\"String.isPrefix$s\") {\n      @Override public Boolean apply(EvalEnv env, Object arg) {\n        final String s2 = (String) arg;\n        return s2.startsWith(s);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]isSubstring(String)", "name": "isSubstring", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "Applicable", "signature": "private static Applicable isSubstring(String s)", "original_string": "  private static Applicable isSubstring(String s) {\n    return new ApplicableImpl(\"String.isSubstring$s\") {\n      @Override public Boolean apply(EvalEnv env, Object arg) {\n        final String s2 = (String) arg;\n        return s2.contains(s);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]isSuffix(String)", "name": "isSuffix", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "Applicable", "signature": "private static Applicable isSuffix(String s)", "original_string": "  private static Applicable isSuffix(String s) {\n    return new ApplicableImpl(\"String.isSuffix$s\") {\n      @Override public Boolean apply(EvalEnv env, Object arg) {\n        final String s2 = (String) arg;\n        return s2.endsWith(s);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]length(BuiltIn)", "name": "length", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "ApplicableImpl", "signature": "private static ApplicableImpl length(BuiltIn builtIn)", "original_string": "  private static ApplicableImpl length(BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return ((List) arg).size();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ApplicableImpl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]union(BuiltIn)", "name": "union", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "ApplicableImpl", "signature": "private static ApplicableImpl union(final BuiltIn builtIn)", "original_string": "  private static ApplicableImpl union(final BuiltIn builtIn) {\n    return new Applicable2<List, List, List>(builtIn) {\n      @Override public List apply(List list0, List list1) {\n        return ImmutableList.builder().addAll(list0).addAll(list1).build();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ApplicableImpl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listApp(Applicable)", "name": "listApp", "arg_nums": 1, "params": [{"name": "consumer", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable listApp(Applicable consumer)", "original_string": "  private static Applicable listApp(Applicable consumer) {\n    return new ApplicableImpl(\"List.app$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        list.forEach(o -> consumer.apply(env, o));\n        return Unit.INSTANCE;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listMap(Applicable)", "name": "listMap", "arg_nums": 1, "params": [{"name": "fn", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable listMap(Applicable fn)", "original_string": "  private static Applicable listMap(Applicable fn) {\n    return new ApplicableImpl(\"List.map$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n        for (Object o : list) {\n          builder.add(fn.apply(env, o));\n        }\n        return builder.build();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listMapPartial(Applicable)", "name": "listMapPartial", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable listMapPartial(Applicable f)", "original_string": "  private static Applicable listMapPartial(Applicable f) {\n    return new ApplicableImpl(\"List.mapPartial$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        final ImmutableList.Builder<Object> builder = ImmutableList.builder();\n        for (Object o : list) {\n          final List opt = (List) f.apply(env, o);\n          if (opt.size() == 2) {\n            builder.add(opt.get(1));\n          }\n        }\n        return builder.build();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]find(BuiltIn)", "name": "find", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "ApplicableImpl", "signature": "private static ApplicableImpl find(BuiltIn builtIn)", "original_string": "  private static ApplicableImpl find(BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Applicable apply(EvalEnv env, Object arg) {\n        final Applicable fn = (Applicable) arg;\n        return find(fn);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ApplicableImpl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]find(Applicable)", "name": "find", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable find(Applicable f)", "original_string": "  private static Applicable find(Applicable f) {\n    return new ApplicableImpl(\"List.find$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        for (Object o : list) {\n          if ((Boolean) f.apply(env, o)) {\n            return optionSome(o);\n          }\n        }\n        return OPTION_NONE;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listFilter(Applicable)", "name": "listFilter", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable listFilter(Applicable f)", "original_string": "  private static Applicable listFilter(Applicable f) {\n    return new ApplicableImpl(\"List.filter$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        final ImmutableList.Builder builder = ImmutableList.builder();\n        for (Object o : list) {\n          if ((Boolean) f.apply(env, o)) {\n            builder.add(o);\n          }\n        }\n        return builder.build();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listPartition(Applicable)", "name": "listPartition", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable listPartition(Applicable f)", "original_string": "  private static Applicable listPartition(Applicable f) {\n    return new ApplicableImpl(\"List.partition$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        final ImmutableList.Builder trueBuilder = ImmutableList.builder();\n        final ImmutableList.Builder falseBuilder = ImmutableList.builder();\n        for (Object o : list) {\n          ((Boolean) f.apply(env, o) ? trueBuilder : falseBuilder).add(o);\n        }\n        return ImmutableList.of(trueBuilder.build(), falseBuilder.build());\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listFold(boolean,Applicable)", "name": "listFold", "arg_nums": 2, "params": [{"name": "left", "type": "boolean"}, {"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable listFold(boolean left, Applicable f)", "original_string": "  private static Applicable listFold(boolean left, Applicable f) {\n    return new ApplicableImpl(\"List.fold$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return listFold2(left, f, arg);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listFold2(boolean,Applicable,Object)", "name": "listFold2", "arg_nums": 3, "params": [{"name": "left", "type": "boolean"}, {"name": "f", "type": "Applicable"}, {"name": "init", "type": "Object"}], "return_type": "Applicable", "signature": "private static Applicable listFold2(boolean left, Applicable f,\n      Object init)", "original_string": "  private static Applicable listFold2(boolean left, Applicable f,\n      Object init) {\n    return new ApplicableImpl(\"List.fold$f$init\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        Object b = init;\n        for (Object a : left ? list : Lists.reverse(list)) {\n          b = f.apply(env, ImmutableList.of(a, b));\n        }\n        return b;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]exists(BuiltIn)", "name": "exists", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "ApplicableImpl", "signature": "private static ApplicableImpl exists(final BuiltIn builtIn)", "original_string": "  private static ApplicableImpl exists(final BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return listExists((Applicable) arg);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ApplicableImpl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listExists(Applicable)", "name": "listExists", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable listExists(Applicable f)", "original_string": "  private static Applicable listExists(Applicable f) {\n    return new ApplicableImpl(\"List.exists$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        for (Object o : list) {\n          if ((Boolean) f.apply(env, o)) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]all(BuiltIn)", "name": "all", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "ApplicableImpl", "signature": "private static ApplicableImpl all(final BuiltIn builtIn)", "original_string": "  private static ApplicableImpl all(final BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return listAll((Applicable) arg);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ApplicableImpl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]listAll(Applicable)", "name": "listAll", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable listAll(Applicable f)", "original_string": "  private static Applicable listAll(Applicable f) {\n    return new ApplicableImpl(\"List.all$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List list = (List) arg;\n        for (Object o : list) {\n          if (!(Boolean) f.apply(env, o)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]collate(BuiltIn)", "name": "collate", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "ApplicableImpl", "signature": "private static ApplicableImpl collate(final BuiltIn builtIn)", "original_string": "  private static ApplicableImpl collate(final BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return collate((Applicable) arg);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ApplicableImpl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]collate(Applicable)", "name": "collate", "arg_nums": 1, "params": [{"name": "comparator", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable collate(Applicable comparator)", "original_string": "  private static Applicable collate(Applicable comparator) {\n    return new ApplicableImpl(\"List.collate$comparator\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List tuple = (List) arg;\n        final List list0 = (List) tuple.get(0);\n        final List list1 = (List) tuple.get(1);\n        final int n0 = list0.size();\n        final int n1 = list1.size();\n        final int n = Math.min(n0, n1);\n        for (int i = 0; i < n; i++) {\n          final Object element0 = list0.get(i);\n          final Object element1 = list1.get(i);\n          final List compare = (List) comparator.apply(env,\n              ImmutableList.of(element0, element1));\n          if (!compare.get(0).equals(\"EQUAL\")) {\n            return compare;\n          }\n        }\n        return n0 < n1 ? ORDER_LESS : n0 == n1 ? ORDER_EQUAL : ORDER_GREATER;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionApp(Applicable)", "name": "optionApp", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable optionApp(Applicable f)", "original_string": "  private static Applicable optionApp(Applicable f) {\n    return new ApplicableImpl(\"Option.app$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List a = (List) arg;\n        if (a.size() == 2) {\n          f.apply(env, a.get(1));\n        }\n        return Unit.INSTANCE;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #OPTION_APP}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionFilter(Applicable)", "name": "optionFilter", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable optionFilter(Applicable f)", "original_string": "  private static Applicable optionFilter(Applicable f) {\n    return new ApplicableImpl(\"Option.filter$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        if ((Boolean) f.apply(env, arg)) {\n          return optionSome(arg);\n        } else {\n          return OPTION_NONE;\n        }\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implementation of {@link #OPTION_FILTER}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionMap(Applicable)", "name": "optionMap", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable optionMap(Applicable f)", "original_string": "  private static Applicable optionMap(Applicable f) {\n    return new ApplicableImpl(BuiltIn.OPTION_MAP) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List a = (List) arg;\n        if (a.size() == 2) { // SOME v\n          return optionSome(f.apply(env, a.get(1))); // SOME (f v)\n        }\n        return a; // NONE\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #OPTION_MAP}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[List]optionSome(Object)", "name": "optionSome", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "List", "signature": "private static List optionSome(Object o)", "original_string": "  private static List optionSome(Object o) {\n    return ImmutableList.of(\"SOME\", o);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List", "classes": []}, "docstring": " Creates a value of {@code SOME v}.\n\n@see #OPTION_NONE"}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionMapPartial(Applicable)", "name": "optionMapPartial", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable optionMapPartial(Applicable f)", "original_string": "  private static Applicable optionMapPartial(Applicable f) {\n    return new ApplicableImpl(\"Option.mapPartial$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List a = (List) arg;\n        if (a.size() == 2) { // SOME v\n          return f.apply(env, a.get(1)); // f v\n        }\n        return a; // NONE\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #OPTION_MAP_PARTIAL}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionCompose(Applicable,Applicable)", "name": "optionCompose", "arg_nums": 2, "params": [{"name": "f", "type": "Applicable"}, {"name": "g", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable optionCompose(Applicable f, Applicable g)", "original_string": "  private static Applicable optionCompose(Applicable f, Applicable g) {\n    return new ApplicableImpl(\"Option.compose$f$g\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List ga = (List) g.apply(env, arg); // g (a)\n        if (ga.size() == 2) { // SOME v\n          return optionSome(f.apply(env, ga.get(1))); // SOME (f (v))\n        }\n        return ga; // NONE\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #OPTION_COMPOSE}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]optionComposePartial(Applicable,Applicable)", "name": "optionComposePartial", "arg_nums": 2, "params": [{"name": "f", "type": "Applicable"}, {"name": "g", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable optionComposePartial(Applicable f, Applicable g)", "original_string": "  private static Applicable optionComposePartial(Applicable f, Applicable g) {\n    return new ApplicableImpl(\"Option.composePartial$f$g\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        final List ga = (List) g.apply(env, arg); // g (a)\n        if (ga.size() == 2) { // SOME v\n          return f.apply(env, ga.get(1)); // f (v)\n        }\n        return ga; // NONE\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #OPTION_COMPOSE_PARTIAL}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[boolean]isNegative(float)", "name": "isNegative", "arg_nums": 1, "params": [{"name": "f", "type": "float"}], "return_type": "boolean", "signature": "@VisibleForTesting\n  public static boolean isNegative(float f)", "original_string": "  @VisibleForTesting\n  public static boolean isNegative(float f) {\n    final boolean negative =\n        (Float.floatToRawIntBits(f) & 0x8000_0000) == 0x8000_0000;\n    if (Float.isNaN(f)) {\n      // Standard ML/NJ and Mlton treat nan as negative,\n      // and ~nan as positive. Let's do the same.\n      return !negative;\n    }\n    return negative;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "@VisibleForTesting\n  public static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether a {@code float} is negative.\nThis is the same as the specification of {@code Real.signBit}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]isEmpty(BuiltIn)", "name": "isEmpty", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "ApplicableImpl", "signature": "private static ApplicableImpl isEmpty(final BuiltIn builtIn)", "original_string": "  private static ApplicableImpl isEmpty(final BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        return !((List) arg).isEmpty();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ApplicableImpl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[ApplicableImpl]isNotEmpty(BuiltIn)", "name": "isNotEmpty", "arg_nums": 1, "params": [{"name": "builtIn", "type": "BuiltIn"}], "return_type": "ApplicableImpl", "signature": "private static ApplicableImpl isNotEmpty(BuiltIn builtIn)", "original_string": "  private static ApplicableImpl isNotEmpty(BuiltIn builtIn) {\n    return new ApplicableImpl(builtIn) {\n      @Override public Boolean apply(EvalEnv env, Object arg) {\n        return ((List) arg).isEmpty();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ApplicableImpl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Core.Exp]sysEnv(TypeSystem,Environment,Type)", "name": "sysEnv", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "argType", "type": "Type"}], "return_type": "Core.Exp", "signature": "private static Core.Exp sysEnv(TypeSystem typeSystem, Environment env,\n      Type argType)", "original_string": "  private static Core.Exp sysEnv(TypeSystem typeSystem, Environment env,\n      Type argType) {\n    final TupleType stringPairType =\n        typeSystem.tupleType(PrimitiveType.STRING, PrimitiveType.STRING);\n    final List<Core.Tuple> args =\n        env.getValueMap()\n            .entrySet()\n            .stream()\n            .sorted(Map.Entry.comparingByKey())\n            .map(entry ->\n                core.tuple(stringPairType,\n                    core.stringLiteral(entry.getKey()),\n                    core.stringLiteral(entry.getValue().id.type.moniker())))\n            .collect(Collectors.toList());\n    return core.apply(Pos.ZERO, typeSystem.listType(argType),\n        core.functionLiteral(typeSystem, BuiltIn.Z_LIST),\n        core.tuple(typeSystem, null, args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": " @see BuiltIn#SYS_ENV"}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorAppi(Applicable)", "name": "vectorAppi", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable vectorAppi(Applicable f)", "original_string": "  private static Applicable vectorAppi(Applicable f) {\n    return new ApplicableImpl(\"Vector.appi$f\") {\n      @Override public Unit apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        forEachIndexed(vec, (e, i) -> f.apply(env, FlatLists.of(i, e)));\n        return Unit.INSTANCE;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #VECTOR_APPI}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorApp(Applicable)", "name": "vectorApp", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable vectorApp(Applicable f)", "original_string": "  private static Applicable vectorApp(Applicable f) {\n    return new ApplicableImpl(\"Vector.app$f\") {\n      @Override public Unit apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        vec.forEach(e -> f.apply(env, e));\n        return Unit.INSTANCE;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #VECTOR_APP}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorMapi(Applicable)", "name": "vectorMapi", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable vectorMapi(Applicable f)", "original_string": "  private static Applicable vectorMapi(Applicable f) {\n    return new ApplicableImpl(\"Vector.map$f\") {\n      @Override public List apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        ImmutableList.Builder<Object> b = ImmutableList.builder();\n        forEachIndexed(vec, (e, i) -> b.add(f.apply(env, FlatLists.of(i, e))));\n        return b.build();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #VECTOR_MAPI}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorMap(Applicable)", "name": "vectorMap", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable vectorMap(Applicable f)", "original_string": "  private static Applicable vectorMap(Applicable f) {\n    return new ApplicableImpl(\"Vector.map$f\") {\n      @Override public List apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        ImmutableList.Builder<Object> b = ImmutableList.builder();\n        vec.forEach(e -> b.add(f.apply(env, e)));\n        return b.build();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #VECTOR_MAP}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]vectorFindi(Applicable)", "name": "vectorFindi", "arg_nums": 1, "params": [{"name": "f", "type": "Applicable"}], "return_type": "Applicable", "signature": "private static Applicable vectorFindi(Applicable f)", "original_string": "  private static Applicable vectorFindi(Applicable f) {\n    return new ApplicableImpl(\"Vector.findi$f\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> vec =\n            (List<Object>) arg;\n        for (int i = 0, n = vec.size(); i < n; i++) {\n          final List<Object> tuple = FlatLists.of(i, vec.get(i));\n          if ((Boolean) f.apply(env, tuple)) {\n            return optionSome(tuple);\n          }\n        }\n        return OPTION_NONE;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Implements {@link #VECTOR_FINDI}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[void]populateBuiltIns(Map<String, Object>)", "name": "populateBuiltIns", "arg_nums": 1, "params": [{"name": "valueMap", "type": "Map<String, Object>"}], "return_type": "void", "signature": "private static void populateBuiltIns(Map<String, Object> valueMap)", "original_string": "  private static void populateBuiltIns(Map<String, Object> valueMap) {\n    if (SKIP) {\n      return;\n    }\n    // Dummy type system, thrown away after this method\n    final TypeSystem typeSystem = new TypeSystem();\n    BuiltIn.dataTypes(typeSystem, new ArrayList<>());\n    BuiltIn.forEach(typeSystem, (key, type) -> {\n      final Object value = BUILT_IN_VALUES.get(key);\n      if (value == null) {\n        throw new AssertionError(\"no implementation for \" + key);\n      }\n      if (key.structure == null) {\n        valueMap.put(key.mlName, value);\n      }\n      if (key.alias != null) {\n        valueMap.put(key.alias, value);\n      }\n    });\n    BuiltIn.forEachStructure(typeSystem, (structure, type) ->\n        valueMap.put(structure.name,\n            transformEager(structure.memberMap.values(), BUILT_IN_VALUES::get)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[EvalEnv]emptyEnv()", "name": "emptyEnv", "arg_nums": 0, "params": [], "return_type": "EvalEnv", "signature": "public static EvalEnv emptyEnv()", "original_string": "  public static EvalEnv emptyEnv() {\n    return EMPTY_ENV;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "EvalEnv", "classes": []}, "docstring": " Creates an empty evaluation environment."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[EvalEnv]emptyEnvWith(Session,Environment)", "name": "emptyEnvWith", "arg_nums": 2, "params": [{"name": "session", "type": "Session"}, {"name": "env", "type": "Environment"}], "return_type": "EvalEnv", "signature": "public static EvalEnv emptyEnvWith(Session session, Environment env)", "original_string": "  public static EvalEnv emptyEnvWith(Session session, Environment env) {\n    final Map<String, Object> map = EMPTY_ENV.valueMap();\n    env.forEachValue(map::put);\n    map.put(EvalEnv.SESSION, session);\n    return EvalEnvs.copyOf(map);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "EvalEnv", "classes": []}, "docstring": " Creates an evaluation environment that contains the bound values from a\ncompilation environment."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Environment]env(TypeSystem,Environment)", "name": "env", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "environment", "type": "Environment"}], "return_type": "Environment", "signature": "public static Environment env(TypeSystem typeSystem,\n      Environment environment)", "original_string": "  public static Environment env(TypeSystem typeSystem,\n      Environment environment) {\n    final Environment[] hEnv = {environment};\n    BUILT_IN_VALUES.forEach((key, value) -> {\n      final Type type = key.typeFunction.apply(typeSystem);\n      if (key.structure == null) {\n        final Core.IdPat idPat =\n            core.idPat(type, key.mlName, typeSystem.nameGenerator);\n        hEnv[0] = hEnv[0].bind(idPat, value);\n      }\n      if (key.alias != null) {\n        final Core.IdPat idPat =\n            core.idPat(type, key.alias, typeSystem.nameGenerator);\n        hEnv[0] = hEnv[0].bind(idPat, value);\n      }\n    });\n\n    final List<Object> valueList = new ArrayList<>();\n    BuiltIn.forEachStructure(typeSystem, (structure, type) -> {\n      valueList.clear();\n      structure.memberMap.values()\n          .forEach(builtIn -> valueList.add(BUILT_IN_VALUES.get(builtIn)));\n      final Core.IdPat idPat =\n          core.idPat(type, structure.name, typeSystem.nameGenerator);\n      hEnv[0] = hEnv[0].bind(idPat, ImmutableList.copyOf(valueList));\n    });\n    return hEnv[0];\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": " Creates a compilation environment."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Applicable]aggregate(Environment,Code,List<String>,Code)", "name": "aggregate", "arg_nums": 4, "params": [{"name": "env0", "type": "Environment"}, {"name": "aggregateCode", "type": "Code"}, {"name": "names", "type": "List<String>"}, {"name": "argumentCode", "type": "Code"}], "return_type": "Applicable", "signature": "public static Applicable aggregate(Environment env0, Code aggregateCode,\n      List<String> names, @Nullable Code argumentCode)", "original_string": "  public static Applicable aggregate(Environment env0, Code aggregateCode,\n      List<String> names, @Nullable Code argumentCode) {\n    return new ApplicableImpl(\"aggregate\") {\n      @Override public Object apply(EvalEnv env, Object arg) {\n        @SuppressWarnings(\"unchecked\") final List<Object> rows =\n            (List<Object>) arg;\n        final List<Object> argRows;\n        if (argumentCode != null) {\n          final MutableEvalEnv env2 = env.bindMutableArray(names);\n          argRows = new ArrayList<>(rows.size());\n          for (Object row : rows) {\n            env2.set(row);\n            argRows.add(argumentCode.eval(env2));\n          }\n        } else if (names.size() != 1) {\n          // Reconcile the fact that we internally represent rows as arrays when\n          // we're buffering for \"group\", lists at other times.\n          argRows = transform(rows, row -> Arrays.asList((Object []) row));\n        } else {\n          argRows = rows;\n        }\n        final Applicable aggregate = (Applicable) aggregateCode.eval(env);\n        return aggregate.apply(env, argRows);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[Map<Applicable, BuiltIn>]get()", "name": "get", "arg_nums": 0, "params": [], "return_type": "Map<Applicable, BuiltIn>", "signature": "private static Map<Applicable, BuiltIn> get()", "original_string": "  private static Map<Applicable, BuiltIn> get() {\n    final IdentityHashMap<Applicable, BuiltIn> b = new IdentityHashMap<>();\n    BUILT_IN_VALUES.forEach((builtIn, o) -> {\n      if (o instanceof Applicable) {\n        b.put((Applicable) o, builtIn);\n      }\n    });\n    return ImmutableMap.copyOf(b);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Map<Applicable, BuiltIn>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[EvalEnv]makeEmptyEnv()", "name": "makeEmptyEnv", "arg_nums": 0, "params": [], "return_type": "EvalEnv", "signature": "private static EvalEnv makeEmptyEnv()", "original_string": "  private static EvalEnv makeEmptyEnv() {\n    final Map<String, Object> map = new HashMap<>();\n    populateBuiltIns(map);\n    return EvalEnvs.copyOf(map);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "EvalEnv", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[StringBuilder]appendFloat(StringBuilder,float)", "name": "appendFloat", "arg_nums": 2, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "f", "type": "float"}], "return_type": "StringBuilder", "signature": "public static StringBuilder appendFloat(StringBuilder buf, float f)", "original_string": "  public static StringBuilder appendFloat(StringBuilder buf, float f) {\n    return buf.append(floatToString(f));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[String]floatToString(float)", "name": "floatToString", "arg_nums": 1, "params": [{"name": "f", "type": "float"}], "return_type": "String", "signature": "@VisibleForTesting\n  public static String floatToString(float f)", "original_string": "  @VisibleForTesting\n  public static String floatToString(float f) {\n    if (Float.isFinite(f)) {\n      final String s = FLOAT_TO_STRING.apply(f);\n      return s.replace('-', '~');\n    } else if (f == Float.POSITIVE_INFINITY) {\n      return \"inf\";\n    } else if (f == Float.NEGATIVE_INFINITY) {\n      return \"~inf\";\n    } else if (Float.isNaN(f)) {\n      return \"nan\";\n    } else {\n      throw new AssertionError(\"unknown float \" + f);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "@VisibleForTesting\n  public static", "marker_annotations": ["@VisibleForTesting"], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Converts a Java {@code float} to the format expected of Standard ML\n{@code real} values."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes.[String]floatToString0(float)", "name": "floatToString0", "arg_nums": 1, "params": [{"name": "f", "type": "float"}], "return_type": "String", "signature": "private static String floatToString0(float f)", "original_string": "  private static String floatToString0(float f) {\n    String s = Float.toString(f);\n    int lastDigit = s.indexOf(\"E\");\n    if (lastDigit < 0) {\n      lastDigit = s.length();\n    }\n    if (s.equals(\"1.17549435E-38\")) {\n      return \"1.1754944E-38\";\n    }\n    if (s.equals(\"1.23456795E12\")) {\n      return \"1.234568E12\";\n    }\n    if (s.equals(\"1.23456791E11\")) {\n      return \"1.2345679E11\";\n    }\n    if (s.equals(\"1.23456788E10\")) {\n      return \"1.2345679E10\";\n    }\n    if (s.equals(\"1.23456792E8\")) {\n      return \"1.2345679E8\";\n    }\n    return s;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Codes.java", "class_name": "Codes", "class_uri": "src/main/java/net/hydromatic/morel/eval/Codes.java.Codes", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java.MutableEvalEnv.[void]set(Object)", "name": "set", "arg_nums": 1, "params": [{"name": "value", "type": "Object"}], "return_type": "void", "signature": "void set(Object value)", "original_string": "  void set(Object value);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java", "class_name": "MutableEvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java.MutableEvalEnv", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Puts a value into this environment."}, {"uris": "src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java.MutableEvalEnv.[boolean]setOpt(Object)", "name": "setOpt", "arg_nums": 1, "params": [{"name": "value", "type": "Object"}], "return_type": "boolean", "signature": "default boolean setOpt(Object value)", "original_string": "  default boolean setOpt(Object value) {\n    set(value);\n    return true;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java", "class_name": "MutableEvalEnv", "class_uri": "src/main/java/net/hydromatic/morel/eval/MutableEvalEnv.java.MutableEvalEnv", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Puts a value into this environment in a way that may not succeed.\n\n<p>For example, if this environment is based on the pattern (x, 2)\nthen (1, 2) will succeed and will bind x to 1, but (3, 4) will fail.\n\n<p>The default implementation calls {@link #set} and always succeeds.\n"}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnvs.java.EvalEnvs.[EvalEnv]copyOf(Map<String, Object>)", "name": "copyOf", "arg_nums": 1, "params": [{"name": "valueMap", "type": "Map<String, Object>"}], "return_type": "EvalEnv", "signature": "public static EvalEnv copyOf(Map<String, Object> valueMap)", "original_string": "  public static EvalEnv copyOf(Map<String, Object> valueMap) {\n    return new MapEvalEnv(valueMap);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnvs.java", "class_name": "EvalEnvs", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnvs.java.EvalEnvs", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "EvalEnv", "classes": []}, "docstring": " Creates an evaluation environment with the given (name, value) map."}, {"uris": "src/main/java/net/hydromatic/morel/eval/EvalEnvs.java.EvalEnvs.[]EvalEnvs()", "name": "EvalEnvs", "arg_nums": 0, "params": [], "return_type": "", "signature": "private EvalEnvs()", "original_string": "  private EvalEnvs() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/EvalEnvs.java", "class_name": "EvalEnvs", "class_uri": "src/main/java/net/hydromatic/morel/eval/EvalEnvs.java.EvalEnvs", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[]Files()", "name": "Files", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Files()", "original_string": "  private Files() {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Files.java", "class_name": "Files", "class_uri": "src/main/java/net/hydromatic/morel/eval/Files.java.Files", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[File]create(java.io.File)", "name": "create", "arg_nums": 1, "params": [{"name": "ioFile", "type": "java.io.File"}], "return_type": "File", "signature": "public static File create(java.io.File ioFile)", "original_string": "  public static File create(java.io.File ioFile) {\n    return createUnknown(null, ioFile).expand();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Files.java", "class_name": "Files", "class_uri": "src/main/java/net/hydromatic/morel/eval/Files.java.Files", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "File", "classes": []}, "docstring": " Creates a file (or directory).\nNever returns null."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[UnknownFile]createUnknown(Directory,java.io.File)", "name": "createUnknown", "arg_nums": 2, "params": [{"name": "directory", "type": "Directory"}, {"name": "ioFile", "type": "java.io.File"}], "return_type": "UnknownFile", "signature": "static UnknownFile createUnknown(@Nullable Directory directory,\n      java.io.File ioFile)", "original_string": "  static UnknownFile createUnknown(@Nullable Directory directory,\n      java.io.File ioFile) {\n    FileType fileType;\n    if (ioFile.isDirectory()) {\n      fileType = FileType.DIRECTORY;\n    } else {\n      fileType = FileType.FILE;\n      for (FileType fileType2 : FileType.INSTANCES) {\n        if (ioFile.getName().endsWith(fileType2.suffix)) {\n          fileType = fileType2;\n          break;\n        }\n      }\n    }\n    if (directory != null) {\n      return new UnknownChildFile(directory, ioFile, fileType);\n    } else {\n      return new UnknownFile(ioFile, fileType);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Files.java", "class_name": "Files", "class_uri": "src/main/java/net/hydromatic/morel/eval/Files.java.Files", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "UnknownFile", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[String]removeSuffix(String,String)", "name": "removeSuffix", "arg_nums": 2, "params": [{"name": "s", "type": "String"}, {"name": "suffix", "type": "String"}], "return_type": "String", "signature": "private static String removeSuffix(String s, String suffix)", "original_string": "  private static String removeSuffix(String s, String suffix) {\n    if (!s.endsWith(suffix)) {\n      return s;\n    }\n    return s.substring(0, s.length() - suffix.length());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Files.java", "class_name": "Files", "class_uri": "src/main/java/net/hydromatic/morel/eval/Files.java.Files", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Returns a string without its suffix; for example,\n{@code removeSuffix(\"x.txt\", \".txt\")} returns {@code \"x\"}."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[PairList<String, Type.Key>]deduceFieldsCsv(BufferedReader)", "name": "deduceFieldsCsv", "arg_nums": 1, "params": [{"name": "r", "type": "BufferedReader"}], "return_type": "PairList<String, Type.Key>", "signature": "private static PairList<String, Type.Key> deduceFieldsCsv(BufferedReader r)", "original_string": "  private static PairList<String, Type.Key> deduceFieldsCsv(BufferedReader r)\n      throws IOException {\n    String firstLine = r.readLine();\n    if (firstLine == null) {\n      // File is empty. There will be no fields, and row type will be unit.\n      return ImmutablePairList.of();\n    }\n\n    final PairList<String, Type.Key> nameTypes = PairList.of();\n    for (String field : firstLine.split(\",\")) {\n      final String[] split = field.split(\":\");\n      final String subFieldName = split[0];\n      final String subFieldType =\n          split.length > 1 ? split[1] : \"string\";\n      Type.Key subType;\n      switch (subFieldType) {\n      case \"bool\":\n        subType = PrimitiveType.BOOL.key();\n        break;\n      case \"decimal\":\n      case \"double\":\n        subType = PrimitiveType.REAL.key();\n        break;\n      case \"int\":\n        subType = PrimitiveType.INT.key();\n        break;\n      default:\n        subType = PrimitiveType.STRING.key();\n        break;\n      }\n      nameTypes.add(subFieldName, subType);\n    }\n    return nameTypes;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Files.java", "class_name": "Files", "class_uri": "src/main/java/net/hydromatic/morel/eval/Files.java.Files", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "PairList<String, Type.Key>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[Function<String, Object>]parser(Type.Key)", "name": "parser", "arg_nums": 1, "params": [{"name": "type", "type": "Type.Key"}], "return_type": "Function<String, Object>", "signature": "static Function<String, Object> parser(Type.Key type)", "original_string": "  static Function<String, Object> parser(Type.Key type) {\n    switch (type.op) {\n    case DATA_TYPE:\n      switch (type.toString()) {\n      case \"int\":\n        return s -> s.equals(\"NULL\") ? 0 : Integer.parseInt(s);\n      case \"real\":\n        return s -> s.equals(\"NULL\") ? 0f : Float.parseFloat(s);\n      case \"string\":\n        return Files::unquoteString;\n      default:\n        throw new IllegalArgumentException(\"unknown type \" + type);\n      }\n    default:\n      throw new IllegalArgumentException(\"unknown type \" + type);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Files.java", "class_name": "Files", "class_uri": "src/main/java/net/hydromatic/morel/eval/Files.java.Files", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Function<String, Object>", "classes": []}, "docstring": " Creates a function that converts a string field value to the desired\ntype."}, {"uris": "src/main/java/net/hydromatic/morel/eval/Files.java.Files.[Object]unquoteString(String)", "name": "unquoteString", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "Object", "signature": "static Object unquoteString(String s)", "original_string": "  static Object unquoteString(String s) {\n    if (s.startsWith(\"'\")) {\n      return s.substring(1, s.length() - 1);\n    }\n    return s;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/eval/Files.java", "class_name": "Files", "class_uri": "src/main/java/net/hydromatic/morel/eval/Files.java.Files", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Object", "classes": []}, "docstring": " Converts \"abc\" to \"abc\" and \"'abc, def'\" to \"abc, def\"."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[]Relationalizer(TypeSystem,Environment)", "name": "Relationalizer", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}], "return_type": "", "signature": "private Relationalizer(TypeSystem typeSystem, Environment env)", "original_string": "  private Relationalizer(TypeSystem typeSystem, Environment env) {\n    super(typeSystem, env);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java", "class_name": "Relationalizer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": " Private constructor."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Relationalizer]of(TypeSystem,Environment)", "name": "of", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}], "return_type": "Relationalizer", "signature": "public static Relationalizer of(TypeSystem typeSystem, Environment env)", "original_string": "  public static Relationalizer of(TypeSystem typeSystem, Environment env) {\n    return new Relationalizer(typeSystem, env);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java", "class_name": "Relationalizer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Relationalizer", "classes": []}, "docstring": " Creates a Relationalizer."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Relationalizer]push(Environment)", "name": "push", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "Relationalizer", "signature": "@Override protected Relationalizer push(Environment env)", "original_string": "  @Override protected Relationalizer push(Environment env) {\n    return new Relationalizer(typeSystem, env);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java", "class_name": "Relationalizer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Relationalizer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Core.Exp]visit(Core.Apply)", "name": "visit", "arg_nums": 1, "params": [{"name": "apply", "type": "Core.Apply"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.Apply apply)", "original_string": "  @Override protected Core.Exp visit(Core.Apply apply) {\n    switch (apply.fn.op) {\n    case APPLY:\n      final Core.Apply apply2 = (Core.Apply) apply.fn;\n      switch (apply2.fn.op) {\n      case FN_LITERAL:\n        final Core.Literal literal = (Core.Literal) apply2.fn;\n        if (literal.value == BuiltIn.LIST_MAP) {\n          // List.map f list\n          //  =>\n          // from e in list yield (f e)\n          final Core.Exp f = apply2.arg;\n          final FnType fnType = (FnType) f.type;\n          final Core.From from = toFrom(apply.arg);\n          // TODO: if the last step is a non-record yield, there is no\n          // \"defaultYieldExp\", and therefore we cannot add another yield\n          // step. We will have to inline the yield expression as a let.\n          final Core.Yield yieldStep = core.yield_(typeSystem,\n              core.apply(apply.pos, fnType.resultType, f,\n                  core.implicitYieldExp(typeSystem, from.steps)));\n          return core.from(typeSystem, append(from.steps, yieldStep));\n        }\n        if (literal.value == BuiltIn.LIST_FILTER) {\n          // List.filter f list\n          //  =>\n          // from e in list where (f e)\n          final Core.Exp f = apply2.arg;\n          final FnType fnType = (FnType) f.type;\n          final Core.From from = toFrom(apply.arg);\n          final Core.Where whereStep =\n              core.where(core.lastBindings(from.steps),\n                  core.apply(apply.pos, fnType.resultType, f,\n                      core.implicitYieldExp(typeSystem, from.steps)));\n          return core.from(typeSystem, append(from.steps, whereStep));\n        }\n      }\n    }\n    return super.visit(apply);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java", "class_name": "Relationalizer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Core.From]toFrom(Core.Exp)", "name": "toFrom", "arg_nums": 1, "params": [{"name": "exp", "type": "Core.Exp"}], "return_type": "Core.From", "signature": "private Core.From toFrom(Core.Exp exp)", "original_string": "  private Core.From toFrom(Core.Exp exp) {\n    if (exp instanceof Core.From) {\n      return (Core.From) exp;\n    } else {\n      final ListType listType = (ListType) exp.type;\n      final String name = typeSystem.nameGenerator.get();\n      final Core.IdPat id =\n          core.idPat(listType.elementType, name, typeSystem.nameGenerator);\n      final List<Binding> bindings = new ArrayList<>();\n      Compiles.acceptBinding(typeSystem, id, bindings);\n      final Core.Scan scan =\n          core.scan(bindings, id, exp, core.boolLiteral(true));\n      return core.from(typeSystem, ImmutableList.of(scan));\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java", "class_name": "Relationalizer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.From", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer.[Core.Exp]visit(Core.From)", "name": "visit", "arg_nums": 1, "params": [{"name": "from", "type": "Core.From"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.From from)", "original_string": "  @Override protected Core.Exp visit(Core.From from) {\n    final Core.From from2 = (Core.From) super.visit(from);\n    if (!from2.steps.isEmpty()) {\n      final Core.FromStep step = from2.steps.get(0);\n      if (step instanceof Core.Scan\n          && ((Core.Scan) step).exp.op == Op.FROM\n          && ((Core.Scan) step).pat.op == Op.ID_PAT) {\n        final Core.From from3 = (Core.From) ((Core.Scan) step).exp;\n        final Core.IdPat idPat3 = (Core.IdPat) ((Core.Scan) step).pat;\n        final List<Core.FromStep> steps = new ArrayList<>(from3.steps);\n        final Core.Exp exp;\n        if (steps.isEmpty()) {\n          exp = core.unitLiteral();\n        } else if (getLast(steps) instanceof Core.Yield) {\n          exp = ((Core.Yield) steps.remove(steps.size() - 1)).exp;\n        } else {\n          exp = core.implicitYieldExp(typeSystem, from3.steps);\n        }\n        RecordLikeType recordType =\n            typeSystem.recordType(RecordType.map(idPat3.name, exp.type));\n        steps.add(\n            core.yield_(step.bindings, core.tuple(recordType, exp)));\n        steps.addAll(skip(from2.steps));\n        return core.from(typeSystem, steps);\n      }\n    }\n    return from2;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java", "class_name": "Relationalizer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Relationalizer.java.Relationalizer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/NameGenerator.java.NameGenerator.[String]get()", "name": "get", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String get()", "original_string": "  public String get() {\n    return \"v\" + id++;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/NameGenerator.java", "class_name": "NameGenerator", "class_uri": "src/main/java/net/hydromatic/morel/compile/NameGenerator.java.NameGenerator", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Generates a name that is unique in this program."}, {"uris": "src/main/java/net/hydromatic/morel/compile/NameGenerator.java.NameGenerator.[int]inc(String)", "name": "inc", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "int", "signature": "public int inc(String name)", "original_string": "  public int inc(String name) {\n    return nameCounts.computeIfAbsent(name, n -> new AtomicInteger(0))\n        .getAndIncrement();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/NameGenerator.java", "class_name": "NameGenerator", "class_uri": "src/main/java/net/hydromatic/morel/compile/NameGenerator.java.NameGenerator", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Returns the number of times that \"name\" has been used for a variable."}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[]CalciteCompiler(TypeSystem,Calcite)", "name": "CalciteCompiler", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "calcite", "type": "Calcite"}], "return_type": "", "signature": "public CalciteCompiler(TypeSystem typeSystem, Calcite calcite)", "original_string": "  public CalciteCompiler(TypeSystem typeSystem, Calcite calcite) {\n    super(typeSystem);\n    this.calcite = requireNonNull(calcite, \"calcite\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelNode]toRel(Environment,Core.Exp)", "name": "toRel", "arg_nums": 2, "params": [{"name": "env", "type": "Environment"}, {"name": "expression", "type": "Core.Exp"}], "return_type": "RelNode", "signature": "public @Nullable RelNode toRel(Environment env, Core.Exp expression)", "original_string": "  public @Nullable RelNode toRel(Environment env, Core.Exp expression) {\n    return toRel2(\n        new RelContext(env, null, calcite.relBuilder(),\n            ImmutableSortedMap.of(), 0),\n        expression);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "public @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RelNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelNode]toRel2(RelContext,Core.Exp)", "name": "toRel2", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "expression", "type": "Core.Exp"}], "return_type": "RelNode", "signature": "private RelNode toRel2(RelContext cx, Core.Exp expression)", "original_string": "  private RelNode toRel2(RelContext cx, Core.Exp expression) {\n    if (toRel3(cx, expression, false)) {\n      return cx.relBuilder.build();\n    } else {\n      return null;\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RelNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[boolean]toRel3(RelContext,Core.Exp,boolean)", "name": "toRel3", "arg_nums": 3, "params": [{"name": "cx", "type": "RelContext"}, {"name": "expression", "type": "Core.Exp"}, {"name": "aggressive", "type": "boolean"}], "return_type": "boolean", "signature": "boolean toRel3(RelContext cx, Core.Exp expression, boolean aggressive)", "original_string": "  boolean toRel3(RelContext cx, Core.Exp expression, boolean aggressive) {\n    final Code code = compile(cx, expression);\n    return code instanceof RelCode\n        && ((RelCode) code).toRel(cx, aggressive);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]toRel4(Environment,Code,Type)", "name": "toRel4", "arg_nums": 3, "params": [{"name": "env", "type": "Environment"}, {"name": "code", "type": "Code"}, {"name": "type", "type": "Type"}], "return_type": "Code", "signature": "Code toRel4(Environment env, Code code, Type type)", "original_string": "  Code toRel4(Environment env, Code code, Type type) {\n    if (!(code instanceof RelCode)) {\n      return code;\n    }\n    RelContext rx =\n        new RelContext(env, null, calcite.relBuilder(),\n            ImmutableSortedMap.of(), 0);\n    if (((RelCode) code).toRel(rx, false)) {\n      return calcite.code(rx.env, rx.relBuilder.build(), type);\n    }\n    return code;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[CalciteFunctions.Context]createContext(Environment)", "name": "createContext", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "CalciteFunctions.Context", "signature": "@Override protected CalciteFunctions.Context createContext(\n      Environment env)", "original_string": "  @Override protected CalciteFunctions.Context createContext(\n      Environment env) {\n    final Session dummySession = new Session(ImmutableMap.of());\n    return new CalciteFunctions.Context(dummySession, env, typeSystem,\n        calcite.dataContext.getTypeFactory());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "CalciteFunctions.Context", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]compileArg(Context,Core.Exp)", "name": "compileArg", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "expression", "type": "Core.Exp"}], "return_type": "Code", "signature": "@Override public Code compileArg(Context cx, Core.Exp expression)", "original_string": "  @Override public Code compileArg(Context cx, Core.Exp expression) {\n    Code code = super.compileArg(cx, expression);\n    if (code instanceof RelCode && !(cx instanceof RelContext)) {\n      final RelBuilder relBuilder = calcite.relBuilder();\n      final RelContext rx =\n          new RelContext(cx.env, null, relBuilder, ImmutableSortedMap.of(), 0);\n      if (toRel3(rx, expression, false)) {\n        return calcite.code(rx.env, rx.relBuilder.build(), expression.type);\n      }\n    }\n    return code;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]finishCompileLet(Context,List<Code>,Code,Type)", "name": "finishCompileLet", "arg_nums": 4, "params": [{"name": "cx", "type": "Context"}, {"name": "matchCodes_", "type": "List<Code>"}, {"name": "resultCode_", "type": "Code"}, {"name": "resultType", "type": "Type"}], "return_type": "Code", "signature": "@Override protected Code finishCompileLet(Context cx, List<Code> matchCodes_,\n      Code resultCode_, Type resultType)", "original_string": "  @Override protected Code finishCompileLet(Context cx, List<Code> matchCodes_,\n      Code resultCode_, Type resultType) {\n    final Code resultCode = toRel4(cx.env, resultCode_, resultType);\n    final List<Code> matchCodes = ImmutableList.copyOf(matchCodes_);\n    final Code code =\n        super.finishCompileLet(cx, matchCodes, resultCode, resultType);\n    return new RelCode() {\n      @Override public boolean toRel(RelContext cx, boolean aggressive) {\n        return false;\n      }\n\n      @Override public Object eval(EvalEnv evalEnv) {\n        return code.eval(evalEnv);\n      }\n\n      @Override public Describer describe(Describer describer) {\n        return describer.start(\"let\", d -> {\n          forEachIndexed(matchCodes, (matchCode, i) ->\n              d.arg(\"matchCode\" + i, matchCode));\n          d.arg(\"resultCode\", resultCode);\n        });\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelCode]compileApply(Context,Core.Apply)", "name": "compileApply", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "apply", "type": "Core.Apply"}], "return_type": "RelCode", "signature": "@Override protected RelCode compileApply(Context cx, Core.Apply apply)", "original_string": "  @Override protected RelCode compileApply(Context cx, Core.Apply apply) {\n    final Code code = super.compileApply(cx, apply);\n    return new RelCode() {\n      @Override public Describer describe(Describer describer) {\n        return code.describe(describer);\n      }\n\n      @Override public Object eval(EvalEnv env) {\n        return code.eval(env);\n      }\n\n      @Override public boolean toRel(RelContext cx, boolean aggressive) {\n        if (!(apply.type instanceof ListType)) {\n          return false;\n        }\n        switch (apply.fn.op) {\n        case RECORD_SELECTOR:\n          if (apply.arg instanceof Core.Id) {\n            // Something like '#emp scott', 'scott' is a foreign value\n            final Object o = code.eval(evalEnvOf(cx.env));\n            if (o instanceof RelList) {\n              cx.relBuilder.push(((RelList) o).rel);\n              return true;\n            }\n          }\n          break;\n\n        case FN_LITERAL:\n          final BuiltIn builtIn =\n              ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n          switch (builtIn) {\n          case Z_LIST:\n            final List<Core.Exp> args = apply.args();\n            if (args.isEmpty()) {\n              final RelDataType calciteType =\n                  Converters.toCalciteType(removeTypeVars(apply.type),\n                      cx.relBuilder.getTypeFactory());\n              cx.relBuilder.values(calciteType.getComponentType());\n            } else {\n              for (Core.Exp arg : args) {\n                cx.relBuilder.values(new String[]{\"T\"}, true);\n                yield_(cx, ImmutableList.of(), arg);\n              }\n              cx.relBuilder.union(true, args.size());\n            }\n            return true;\n\n          case OP_UNION:\n          case OP_EXCEPT:\n          case OP_INTERSECT:\n            // For example, '[1, 2, 3] union (from scott.dept yield deptno)'\n            final Core.Tuple tuple = (Core.Tuple) apply.arg;\n            for (Core.Exp arg : tuple.args) {\n              if (!CalciteCompiler.this.toRel3(cx, arg, false)) {\n                return false;\n              }\n            }\n            harmonizeRowTypes(cx.relBuilder, tuple.args.size());\n            switch (builtIn) {\n            case OP_UNION:\n              cx.relBuilder.union(true, tuple.args.size());\n              return true;\n            case OP_EXCEPT:\n              cx.relBuilder.minus(false, tuple.args.size());\n              return true;\n            case OP_INTERSECT:\n              cx.relBuilder.intersect(false, tuple.args.size());\n              return true;\n            default:\n              throw new AssertionError(builtIn);\n            }\n          }\n        }\n        final RelDataTypeFactory typeFactory = cx.relBuilder.getTypeFactory();\n        final RelDataType calciteType =\n            Converters.toCalciteType(apply.type, typeFactory);\n        final RelDataType rowType = calciteType.getComponentType();\n        if (rowType == null) {\n          return false;\n        }\n        if (!aggressive) {\n          return false;\n        }\n        final JsonBuilder jsonBuilder = new JsonBuilder();\n        final RelJson relJson = RelJson.create().withJsonBuilder(jsonBuilder);\n        final String jsonRowType =\n            jsonBuilder.toJsonString(relJson.toJson(rowType));\n        final String morelCode = apply.toString();\n        ThreadLocals.let(CalciteFunctions.THREAD_ENV,\n            new CalciteFunctions.Context(new Session(ImmutableMap.of()), cx.env,\n                typeSystem, cx.relBuilder.getTypeFactory()), () ->\n            cx.relBuilder.functionScan(CalciteFunctions.TABLE_OPERATOR, 0,\n                cx.relBuilder.literal(morelCode),\n                cx.relBuilder.literal(jsonRowType)));\n        return true;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "RelCode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Type]removeTypeVars(Type)", "name": "removeTypeVars", "arg_nums": 1, "params": [{"name": "type", "type": "Type"}], "return_type": "Type", "signature": "private Type removeTypeVars(Type type)", "original_string": "  private Type removeTypeVars(Type type) {\n    return type.copy(typeSystem,\n        t -> t instanceof TypeVar\n            ? typeSystem.recordType(RecordType.map(\"b\", PrimitiveType.BOOL))\n            : t);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Converts each type variable in a type to a dummy record type,\n{@code {b: bool}}."}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]finishCompileApply(Context,Code,Code,Type)", "name": "finishCompileApply", "arg_nums": 4, "params": [{"name": "cx", "type": "Context"}, {"name": "fnCode", "type": "Code"}, {"name": "argCode", "type": "Code"}, {"name": "argType", "type": "Type"}], "return_type": "Code", "signature": "@Override protected Code finishCompileApply(Context cx, Code fnCode,\n      Code argCode, Type argType)", "original_string": "  @Override protected Code finishCompileApply(Context cx, Code fnCode,\n      Code argCode, Type argType) {\n    if (argCode instanceof RelCode && cx instanceof RelContext) {\n      final RelContext rx = (RelContext) cx;\n      if (((RelCode) argCode).toRel(rx, false)) {\n        final Code argCode2 =\n            calcite.code(rx.env, rx.relBuilder.build(), argType);\n        return finishCompileApply(cx, fnCode, argCode2, argType);\n      }\n    }\n    return super.finishCompileApply(cx, fnCode, argCode, argType);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]finishCompileApply(Context,Applicable,Code,Type)", "name": "finishCompileApply", "arg_nums": 4, "params": [{"name": "cx", "type": "Context"}, {"name": "fnValue", "type": "Applicable"}, {"name": "argCode", "type": "Code"}, {"name": "argType", "type": "Type"}], "return_type": "Code", "signature": "@Override protected Code finishCompileApply(Context cx, Applicable fnValue,\n      Code argCode, Type argType)", "original_string": "  @Override protected Code finishCompileApply(Context cx, Applicable fnValue,\n      Code argCode, Type argType) {\n    if (argCode instanceof RelCode && cx instanceof RelContext) {\n      final RelContext rx = (RelContext) cx;\n      if (((RelCode) argCode).toRel(rx, false)) {\n        final Code argCode2 =\n            calcite.code(rx.env, rx.relBuilder.build(), argType);\n        return finishCompileApply(cx, fnValue, argCode2, argType);\n      }\n    }\n    return super.finishCompileApply(cx, fnValue, argCode, argType);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[void]harmonizeRowTypes(RelBuilder,int)", "name": "harmonizeRowTypes", "arg_nums": 2, "params": [{"name": "relBuilder", "type": "RelBuilder"}, {"name": "inputCount", "type": "int"}], "return_type": "void", "signature": "private static void harmonizeRowTypes(RelBuilder relBuilder, int inputCount)", "original_string": "  private static void harmonizeRowTypes(RelBuilder relBuilder, int inputCount) {\n    final List<RelNode> inputs = new ArrayList<>();\n    for (int i = 0; i < inputCount; i++) {\n      inputs.add(relBuilder.build());\n    }\n    final RelDataType rowType = relBuilder.getTypeFactory()\n        .leastRestrictive(transform(inputs, RelNode::getRowType));\n    for (RelNode input : Lists.reverse(inputs)) {\n      relBuilder.push(input)\n          .convert(rowType, false);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Code]compileFrom(Context,Core.From)", "name": "compileFrom", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "from", "type": "Core.From"}], "return_type": "Code", "signature": "@Override protected Code compileFrom(Context cx, Core.From from)", "original_string": "  @Override protected Code compileFrom(Context cx, Core.From from) {\n    final Code code = super.compileFrom(cx, from);\n    return new RelCode() {\n      @Override public Describer describe(Describer describer) {\n        return code.describe(describer);\n      }\n\n      @Override public Object eval(EvalEnv env) {\n        return code.eval(env);\n      }\n\n      @Override public boolean toRel(RelContext cx, boolean aggressive) {\n        if (from.steps.isEmpty()\n            || !(from.steps.get(0) instanceof Core.Scan)) {\n          // One row, zero columns\n          cx.relBuilder.values(ImmutableList.of(ImmutableList.of()),\n              cx.relBuilder.getTypeFactory().builder().build());\n        }\n        cx =\n            new RelContext(cx.env, cx, cx.relBuilder,\n                ImmutableSortedMap.of(), 1);\n        for (Ord<Core.FromStep> fromStep : Ord.zip(from.steps)) {\n          cx = step(cx, fromStep.i, fromStep.e);\n          if (cx == null) {\n            return false;\n          }\n        }\n        if (from.steps.isEmpty()\n            || getLast(from.steps).op != Op.YIELD) {\n          final Core.Exp implicitYieldExp =\n              core.implicitYieldExp(typeSystem, from.steps);\n          cx = yield_(cx, ImmutableList.of(), implicitYieldExp);\n        }\n        return true;\n      }\n\n      private RelContext step(RelContext cx, int i, Core.FromStep fromStep) {\n        switch (fromStep.op) {\n        case SCAN:\n          return join(cx, i, (Core.Scan) fromStep);\n        case WHERE:\n          return where(cx, (Core.Where) fromStep);\n        case SKIP:\n          return skip(cx, (Core.Skip) fromStep);\n        case TAKE:\n          return take(cx, (Core.Take) fromStep);\n        case ORDER:\n          return order(cx, (Core.Order) fromStep);\n        case GROUP:\n          return group(cx, (Core.Group) fromStep);\n        case YIELD:\n          return yield_(cx, (Core.Yield) fromStep);\n        default:\n          throw new AssertionError(fromStep);\n        }\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]yield_(RelContext,Core.Yield)", "name": "yield_", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "yield", "type": "Core.Yield"}], "return_type": "RelContext", "signature": "private RelContext yield_(RelContext cx, Core.Yield yield)", "original_string": "  private RelContext yield_(RelContext cx, Core.Yield yield) {\n    return yield_(cx, yield.bindings, yield.exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RelContext", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]yield_(RelContext,List<Binding>,Core.Exp)", "name": "yield_", "arg_nums": 3, "params": [{"name": "cx", "type": "RelContext"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "exp", "type": "Core.Exp"}], "return_type": "RelContext", "signature": "private RelContext yield_(RelContext cx, List<Binding> bindings,\n      Core.Exp exp)", "original_string": "  private RelContext yield_(RelContext cx, List<Binding> bindings,\n      Core.Exp exp) {\n    final Core.Tuple tuple;\n    switch (exp.op) {\n    case ID:\n      final Core.Id id = (Core.Id) exp;\n      tuple = toRecord(cx, id);\n      if (tuple != null) {\n        return yield_(cx, bindings, tuple);\n      }\n      break;\n\n    case TUPLE:\n      tuple = (Core.Tuple) exp;\n      final List<String> names =\n          ImmutableList.copyOf(tuple.type().argNameTypes().keySet());\n      cx.relBuilder.project(transform(tuple.args, e -> translate(cx, e)),\n          names);\n      return getRelContext(cx, cx.env.bindAll(bindings), names);\n    }\n    RexNode rex = translate(cx, exp);\n    cx.relBuilder.project(rex);\n    return cx;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RelContext", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RexNode]translate(RelContext,Core.Exp)", "name": "translate", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "exp", "type": "Core.Exp"}], "return_type": "RexNode", "signature": "private RexNode translate(RelContext cx, Core.Exp exp)", "original_string": "  private RexNode translate(RelContext cx, Core.Exp exp) {\n    final Core.Tuple record;\n    final RelDataTypeFactory.Builder builder;\n    final List<RexNode> operands;\n    switch (exp.op) {\n    case BOOL_LITERAL:\n    case CHAR_LITERAL:\n    case INT_LITERAL:\n    case REAL_LITERAL:\n    case STRING_LITERAL:\n    case UNIT_LITERAL:\n      final Core.Literal literal = (Core.Literal) exp;\n      switch (exp.op) {\n      case CHAR_LITERAL:\n        // convert from Character to singleton String\n        return cx.relBuilder.literal(literal.value + \"\");\n      case UNIT_LITERAL:\n        return cx.relBuilder.call(SqlStdOperatorTable.ROW);\n      default:\n        return cx.relBuilder.literal(literal.value);\n      }\n\n    case ID:\n      // In 'from e in emps yield e', 'e' expands to a record,\n      // '{e.deptno, e.ename}'\n      final Core.Id id = (Core.Id) exp;\n      final Binding binding = cx.env.getOpt(id.idPat);\n      if (binding != null && binding.value != Unit.INSTANCE) {\n        final Core.Literal coreLiteral =\n            core.literal((PrimitiveType) binding.id.type, binding.value);\n        return translate(cx, coreLiteral);\n      }\n      record = toRecord(cx, id);\n      if (record != null) {\n        return translate(cx, record);\n      }\n      if (cx.map.containsKey(id.idPat.name)) {\n        // Not a record, so must be a scalar. It is represented in Calcite\n        // as a record with one field.\n        final VarData fn = requireNonNull(cx.map.get(id.idPat.name));\n        return fn.apply(cx.relBuilder);\n      }\n      break;\n\n    case APPLY:\n      final Core.Apply apply = (Core.Apply) exp;\n      switch (apply.fn.op) {\n      case FN_LITERAL:\n        BuiltIn op = ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n\n        // Is it a unary operator with a Calcite equivalent? E.g. not => NOT\n        final SqlOperator unaryOp = UNARY_OPERATORS.get(op);\n        if (unaryOp != null) {\n          switch (op) {\n          case LIST_NULL:\n          case RELATIONAL_EXISTS:\n          case RELATIONAL_NOT_EXISTS:\n          case RELATIONAL_ONLY:\n            final RelNode r = toRel2(cx, apply.arg);\n            if (r != null) {\n              switch (op) {\n              case LIST_NULL:\n              case RELATIONAL_NOT_EXISTS:\n                return cx.relBuilder.not(RexSubQuery.exists(r));\n              case RELATIONAL_EXISTS:\n                return RexSubQuery.exists(r);\n              case RELATIONAL_ONLY:\n                return RexSubQuery.scalar(r);\n              default:\n                throw new AssertionError(\"unknown \" + op);\n              }\n            }\n          }\n          return cx.relBuilder.call(unaryOp, translate(cx, apply.arg));\n        }\n\n        // Is it a binary operator with a Calcite equivalent? E.g. + => PLUS\n        final SqlOperator binaryOp = BINARY_OPERATORS.get(op);\n        if (binaryOp != null) {\n          assert apply.arg.op == Op.TUPLE;\n          switch (op) {\n          case OP_ELEM:\n          case OP_NOT_ELEM:\n            final RelNode r = toRel2(cx, apply.args().get(1));\n            if (r != null) {\n              final RexNode e = translate(cx, apply.args().get(0));\n              final RexSubQuery in = RexSubQuery.in(r, ImmutableList.of(e));\n              return maybeNot(cx, in, op == BuiltIn.OP_NOT_ELEM);\n            }\n          }\n          return cx.relBuilder.call(binaryOp, translateList(cx, apply.args()));\n        }\n      }\n      if (apply.fn instanceof Core.RecordSelector\n          && apply.arg instanceof Core.Id) {\n        // Something like '#deptno e'\n        final Core.NamedPat idPat = ((Core.Id) apply.arg).idPat;\n        final @Nullable RexNode range = cx.var(idPat.name);\n        if (range != null) {\n          final Core.RecordSelector selector = (Core.RecordSelector) apply.fn;\n          return cx.relBuilder.field(range, selector.fieldName());\n        }\n      }\n      final Set<String> vars =\n          getRelationalVariables(cx.env, cx.map.keySet(), apply);\n      if (vars.isEmpty()) {\n        return morelScalar(cx, apply);\n      }\n      final RexNode fnRex = translate(cx, apply.fn);\n      final RexNode argRex = translate(cx, apply.arg);\n      return morelApply(cx, apply.type, apply.arg.type, fnRex, argRex);\n\n    case FROM:\n      final Core.From from = (Core.From) exp;\n      final RelNode r = toRel2(cx, from);\n      if (r != null && 1 != 2) {\n        // TODO: add RexSubQuery.array and RexSubQuery.multiset methods\n        return cx.relBuilder.call(SqlStdOperatorTable.ARRAY_QUERY,\n            RexSubQuery.scalar(r));\n      }\n      break;\n\n    case TUPLE:\n      final Core.Tuple tuple = (Core.Tuple) exp;\n      builder = cx.relBuilder.getTypeFactory().builder();\n      operands = new ArrayList<>();\n      forEachIndexed(tuple.args, (arg, i) -> {\n        final RexNode e = translate(cx, arg);\n        operands.add(e);\n        builder.add(Integer.toString(i), e.getType());\n      });\n      return cx.relBuilder.getRexBuilder().makeCall(builder.build(),\n          SqlStdOperatorTable.ROW, operands);\n    }\n\n    // Translate as a call to a scalar function\n    return morelScalar(cx, exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RexNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RexNode]maybeNot(RelContext,RexNode,boolean)", "name": "maybeNot", "arg_nums": 3, "params": [{"name": "cx", "type": "RelContext"}, {"name": "e", "type": "RexNode"}, {"name": "not", "type": "boolean"}], "return_type": "RexNode", "signature": "private RexNode maybeNot(RelContext cx, RexNode e, boolean not)", "original_string": "  private RexNode maybeNot(RelContext cx, RexNode e, boolean not) {\n    return not ? cx.relBuilder.not(e) : e;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RexNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Set<String>]getRelationalVariables(Environment,Set<String>,AstNode)", "name": "getRelationalVariables", "arg_nums": 3, "params": [{"name": "env", "type": "Environment"}, {"name": "nameSet", "type": "Set<String>"}, {"name": "node", "type": "AstNode"}], "return_type": "Set<String>", "signature": "private Set<String> getRelationalVariables(Environment env,\n      Set<String> nameSet, AstNode node)", "original_string": "  private Set<String> getRelationalVariables(Environment env,\n      Set<String> nameSet, AstNode node) {\n    final Set<String> varNames = new LinkedHashSet<>();\n    node.accept(new Visitor() {\n      @Override protected void visit(Core.Id id) {\n        if (nameSet.contains(id.idPat.name)) {\n          varNames.add(id.idPat.name);\n        }\n      }\n    });\n    return varNames;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Set<String>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RexNode]morelScalar(RelContext,Core.Exp)", "name": "morelScalar", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "exp", "type": "Core.Exp"}], "return_type": "RexNode", "signature": "private RexNode morelScalar(RelContext cx, Core.Exp exp)", "original_string": "  private RexNode morelScalar(RelContext cx, Core.Exp exp) {\n    final RelDataTypeFactory typeFactory = cx.relBuilder.getTypeFactory();\n    final RelDataType calciteType =\n        Converters.toCalciteType(exp.type, typeFactory);\n    final JsonBuilder jsonBuilder = new JsonBuilder();\n    final RelJson relJson = RelJson.create().withJsonBuilder(jsonBuilder);\n    final String jsonType =\n        jsonBuilder.toJsonString(relJson.toJson(calciteType));\n    final String morelCode = exp.toString();\n    return cx.relBuilder.getRexBuilder().makeCall(calciteType,\n        CalciteFunctions.SCALAR_OPERATOR,\n        Arrays.asList(cx.relBuilder.literal(morelCode),\n            cx.relBuilder.literal(jsonType)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RexNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RexNode]morelApply(RelContext,Type,Type,RexNode,RexNode)", "name": "morelApply", "arg_nums": 5, "params": [{"name": "cx", "type": "RelContext"}, {"name": "type", "type": "Type"}, {"name": "argType", "type": "Type"}, {"name": "fn", "type": "RexNode"}, {"name": "arg", "type": "RexNode"}], "return_type": "RexNode", "signature": "private RexNode morelApply(RelContext cx, Type type, Type argType, RexNode fn,\n      RexNode arg)", "original_string": "  private RexNode morelApply(RelContext cx, Type type, Type argType, RexNode fn,\n      RexNode arg) {\n    final RelDataTypeFactory typeFactory = cx.relBuilder.getTypeFactory();\n    final RelDataType calciteType =\n        Converters.toCalciteType(type, typeFactory);\n    final String morelArgType = argType.toString();\n    return cx.relBuilder.getRexBuilder().makeCall(calciteType,\n        CalciteFunctions.APPLY_OPERATOR,\n        Arrays.asList(cx.relBuilder.literal(morelArgType), fn, arg));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RexNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[Core.Tuple]toRecord(RelContext,Core.Id)", "name": "toRecord", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "id", "type": "Core.Id"}], "return_type": "Core.Tuple", "signature": "private Core.Tuple toRecord(RelContext cx, Core.Id id)", "original_string": "  private Core.Tuple toRecord(RelContext cx, Core.Id id) {\n    final Binding binding = cx.env.getOpt(id.idPat);\n    checkNotNull(binding, \"not found\", id);\n    final Type type = binding.id.type;\n    if (type instanceof RecordType) {\n      final RecordType recordType = (RecordType) type;\n      final List<Core.Exp> args = new ArrayList<>();\n      recordType.argNameTypes.forEach((field, fieldType) ->\n          args.add(\n              core.apply(Pos.ZERO, fieldType,\n                  core.recordSelector(typeSystem, recordType, field),\n                  id)));\n      return core.tuple(recordType, args);\n    }\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Tuple", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[List<RexNode>]translateList(RelContext,List<Core.Exp>)", "name": "translateList", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "exps", "type": "List<Core.Exp>"}], "return_type": "List<RexNode>", "signature": "private List<RexNode> translateList(RelContext cx, List<Core.Exp> exps)", "original_string": "  private List<RexNode> translateList(RelContext cx, List<Core.Exp> exps) {\n    return transformEager(exps, exp -> translate(cx, exp));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<RexNode>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]join(RelContext,int,Core.Scan)", "name": "join", "arg_nums": 3, "params": [{"name": "cx", "type": "RelContext"}, {"name": "i", "type": "int"}, {"name": "scan", "type": "Core.Scan"}], "return_type": "RelContext", "signature": "private RelContext join(RelContext cx, int i, Core.Scan scan)", "original_string": "  private RelContext join(RelContext cx, int i, Core.Scan scan) {\n    if (!toRel3(cx, scan.exp, true)) {\n      return null;\n    }\n\n    final SortedMap<String, VarData> varOffsets = new TreeMap<>(cx.map);\n    int offset = 0;\n    for (VarData varData : cx.map.values()) {\n      offset += varData.rowType.getFieldCount();\n    }\n    final Core.Pat pat = scan.pat;\n    final RelNode r = cx.relBuilder.peek();\n    if (pat instanceof Core.IdPat) {\n      final Core.IdPat idPat = (Core.IdPat) pat;\n      cx.relBuilder.as(idPat.name);\n      varOffsets.put(idPat.name, new VarData(pat.type, offset, r.getRowType()));\n    }\n    cx =\n        new RelContext(cx.env.bindAll(scan.bindings), cx, cx.relBuilder,\n            ImmutableSortedMap.copyOfSorted(varOffsets), cx.inputCount + 1);\n\n    if (i > 0) {\n      final JoinRelType joinRelType = joinRelType(scan.op);\n      cx.relBuilder.join(joinRelType, translate(cx, scan.condition));\n    }\n    return cx;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RelContext", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[JoinRelType]joinRelType(Op)", "name": "joinRelType", "arg_nums": 1, "params": [{"name": "op", "type": "Op"}], "return_type": "JoinRelType", "signature": "private static JoinRelType joinRelType(Op op)", "original_string": "  private static JoinRelType joinRelType(Op op) {\n    switch (op) {\n    case SCAN:\n      return JoinRelType.INNER;\n    default:\n      throw new AssertionError(op);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "JoinRelType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]where(RelContext,Core.Where)", "name": "where", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "where", "type": "Core.Where"}], "return_type": "RelContext", "signature": "private RelContext where(RelContext cx, Core.Where where)", "original_string": "  private RelContext where(RelContext cx, Core.Where where) {\n    cx.relBuilder.filter(cx.varList, translate(cx, where.exp));\n    return cx;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RelContext", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]skip(RelContext,Core.Skip)", "name": "skip", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "skip", "type": "Core.Skip"}], "return_type": "RelContext", "signature": "private RelContext skip(RelContext cx, Core.Skip skip)", "original_string": "  private RelContext skip(RelContext cx, Core.Skip skip) {\n    if (skip.exp.op != Op.INT_LITERAL) {\n      throw new AssertionError(\"skip requires literal: \" + skip.exp);\n    }\n    int offset = ((Core.Literal) skip.exp).unwrap(Integer.class);\n    int fetch = -1; // per Calcite: \"negative means no limit\"\n    cx.relBuilder.limit(offset, fetch);\n    return cx;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RelContext", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]take(RelContext,Core.Take)", "name": "take", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "take", "type": "Core.Take"}], "return_type": "RelContext", "signature": "private RelContext take(RelContext cx, Core.Take take)", "original_string": "  private RelContext take(RelContext cx, Core.Take take) {\n    if (take.exp.op != Op.INT_LITERAL) {\n      throw new AssertionError(\"take requires literal: \" + take.exp);\n    }\n    int offset = 0;\n    int fetch = ((Core.Literal) take.exp).unwrap(Integer.class);\n    cx.relBuilder.limit(offset, fetch);\n    return cx;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RelContext", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]order(RelContext,Core.Order)", "name": "order", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "order", "type": "Core.Order"}], "return_type": "RelContext", "signature": "private RelContext order(RelContext cx, Core.Order order)", "original_string": "  private RelContext order(RelContext cx, Core.Order order) {\n    final List<RexNode> exps = new ArrayList<>();\n    order.orderItems.forEach(i -> {\n      RexNode exp = translate(cx, i.exp);\n      if (i.direction == Ast.Direction.DESC) {\n        exp = cx.relBuilder.desc(exp);\n      }\n      exps.add(exp);\n    });\n    cx.relBuilder.sort(exps);\n    return cx;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RelContext", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]group(RelContext,Core.Group)", "name": "group", "arg_nums": 2, "params": [{"name": "cx", "type": "RelContext"}, {"name": "group", "type": "Core.Group"}], "return_type": "RelContext", "signature": "private RelContext group(RelContext cx, Core.Group group)", "original_string": "  private RelContext group(RelContext cx, Core.Group group) {\n    final List<Binding> bindings = new ArrayList<>();\n    final List<RexNode> nodes = new ArrayList<>();\n    final List<String> names = new ArrayList<>();\n    group.groupExps.forEach((idPat, exp) -> {\n      bindings.add(Binding.of(idPat));\n      nodes.add(translate(cx, exp));\n      names.add(idPat.name);\n    });\n    final RelBuilder.GroupKey groupKey = cx.relBuilder.groupKey(nodes);\n    final List<RelBuilder.AggCall> aggregateCalls = new ArrayList<>();\n    group.aggregates.forEach((idPat, aggregate) -> {\n      bindings.add(Binding.of(idPat));\n      final SqlAggFunction op = aggOp(aggregate.aggregate);\n      final ImmutableList.Builder<RexNode> args = ImmutableList.builder();\n      if (aggregate.argument != null) {\n        args.add(translate(cx, aggregate.argument));\n      }\n      aggregateCalls.add(\n          cx.relBuilder.aggregateCall(op, args.build()).as(idPat.name));\n      names.add(idPat.name);\n    });\n\n    // Create an Aggregate operator.\n    cx.relBuilder.aggregate(groupKey, aggregateCalls);\n    return getRelContext(cx, cx.env.bindAll(bindings), names);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "RelContext", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[RelContext]getRelContext(RelContext,Environment,List<String>)", "name": "getRelContext", "arg_nums": 3, "params": [{"name": "cx", "type": "RelContext"}, {"name": "env", "type": "Environment"}, {"name": "names", "type": "List<String>"}], "return_type": "RelContext", "signature": "private static RelContext getRelContext(RelContext cx, Environment env,\n      List<String> names)", "original_string": "  private static RelContext getRelContext(RelContext cx, Environment env,\n      List<String> names) {\n    // Permute the fields so that they are sorted by name, per Morel records.\n    final List<String> sortedNames =\n        Ordering.natural().immutableSortedCopy(names);\n    cx.relBuilder.rename(names)\n        .project(cx.relBuilder.fields(sortedNames));\n    final RelDataType rowType = cx.relBuilder.peek().getRowType();\n    final SortedMap<String, VarData> map = new TreeMap<>();\n    sortedNames.forEach(name ->\n        map.put(name,\n            new VarData(PrimitiveType.UNIT, map.size(), rowType)));\n\n    // Return a context containing a variable for each output field.\n    return new RelContext(env, cx, cx.relBuilder,\n        ImmutableSortedMap.copyOfSorted(map), 1);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "RelContext", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[SqlAggFunction]aggOp(Core.Exp)", "name": "aggOp", "arg_nums": 1, "params": [{"name": "aggregate", "type": "Core.Exp"}], "return_type": "SqlAggFunction", "signature": "@NonNull private SqlAggFunction aggOp(Core.Exp aggregate)", "original_string": "  @NonNull private SqlAggFunction aggOp(Core.Exp aggregate) {\n    if (aggregate instanceof Core.Literal) {\n      switch (((Core.Literal) aggregate).unwrap(BuiltIn.class)) {\n      case RELATIONAL_SUM:\n      case Z_SUM_INT:\n      case Z_SUM_REAL:\n        return SqlStdOperatorTable.SUM;\n      case RELATIONAL_COUNT:\n        return SqlStdOperatorTable.COUNT;\n      case RELATIONAL_MIN:\n        return SqlStdOperatorTable.MIN;\n      case RELATIONAL_MAX:\n        return SqlStdOperatorTable.MAX;\n      }\n    }\n    throw new AssertionError(\"unknown aggregate function: \" + aggregate);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "@NonNull private", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["private"], "comments": [], "return_type": "SqlAggFunction", "classes": []}, "docstring": " Returns the Calcite operator corresponding to a Morel built-in aggregate\nfunction.\n\n<p>Future work: rather than resolving by name, look up aggregate function\nin environment, and compare with standard implementation of \"sum\" etc.;\nsupport aggregate functions defined by expressions (e.g. lambdas)."}, {"uris": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler.[EvalEnv]evalEnvOf(Environment)", "name": "evalEnvOf", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "EvalEnv", "signature": "private static EvalEnv evalEnvOf(Environment env)", "original_string": "  private static EvalEnv evalEnvOf(Environment env) {\n    final Map<String, Object> map = new LinkedHashMap<>();\n    env.forEachValue(map::put);\n    EMPTY_ENV.visit(map::putIfAbsent);\n    return EvalEnvs.copyOf(map);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java", "class_name": "CalciteCompiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/CalciteCompiler.java.CalciteCompiler", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "EvalEnv", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CompiledStatement.java.CompiledStatement.[void]eval(Session,Environment,Consumer<String>,Consumer<Binding>)", "name": "eval", "arg_nums": 4, "params": [{"name": "session", "type": "Session"}, {"name": "environment", "type": "Environment"}, {"name": "outLines", "type": "Consumer<String>"}, {"name": "outBindings", "type": "Consumer<Binding>"}], "return_type": "void", "signature": "void eval(Session session, Environment environment, Consumer<String> outLines,\n      Consumer<Binding> outBindings)", "original_string": "  void eval(Session session, Environment environment, Consumer<String> outLines,\n      Consumer<Binding> outBindings);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CompiledStatement.java", "class_name": "CompiledStatement", "class_uri": "src/main/java/net/hydromatic/morel/compile/CompiledStatement.java.CompiledStatement", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Evaluates this statement, adding lines of feedback to {@code output}\nand writing bindings (values to variables, and types definitions) to\n{@code bindings}. The environment for the next statement can be\nconstructed from the bindings.\n\n@param session Session\n@param environment Evaluation environment\n@param outLines List to which to append lines of output\n@param outBindings List to which to append bound variables and types\n"}, {"uris": "src/main/java/net/hydromatic/morel/compile/CompiledStatement.java.CompiledStatement.[Type]getType()", "name": "getType", "arg_nums": 0, "params": [], "return_type": "Type", "signature": "Type getType()", "original_string": "  Type getType();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CompiledStatement.java", "class_name": "CompiledStatement", "class_uri": "src/main/java/net/hydromatic/morel/compile/CompiledStatement.java.CompiledStatement", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[]EnvShuttle(TypeSystem,Environment)", "name": "EnvShuttle", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}], "return_type": "", "signature": "protected EnvShuttle(TypeSystem typeSystem, Environment env)", "original_string": "  protected EnvShuttle(TypeSystem typeSystem, Environment env) {\n    super(typeSystem);\n    this.env = env;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates an EnvShuttle."}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[EnvShuttle]push(Environment)", "name": "push", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "EnvShuttle", "signature": "protected abstract EnvShuttle push(Environment env)", "original_string": "  protected abstract EnvShuttle push(Environment env);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "EnvShuttle", "classes": []}, "docstring": " Creates a shuttle the same as this but with a new environment."}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[EnvShuttle]bind(Binding)", "name": "bind", "arg_nums": 1, "params": [{"name": "binding", "type": "Binding"}], "return_type": "EnvShuttle", "signature": "protected EnvShuttle bind(Binding binding)", "original_string": "  protected EnvShuttle bind(Binding binding) {\n    return push(env.bind(binding));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "EnvShuttle", "classes": []}, "docstring": " Creates a shuttle the same as this but overriding a binding."}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[EnvShuttle]bind(List<Binding>)", "name": "bind", "arg_nums": 1, "params": [{"name": "bindingList", "type": "List<Binding>"}], "return_type": "EnvShuttle", "signature": "protected EnvShuttle bind(List<Binding> bindingList)", "original_string": "  protected EnvShuttle bind(List<Binding> bindingList) {\n    // The \"env2 != env\" check is an optimization. If you remove it, this method\n    // will have the same effect, just slower.\n    final Environment env2 = env.bindAll(bindingList);\n    if (env2 == env) {\n      return this;\n    }\n    return push(env2);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "EnvShuttle", "classes": []}, "docstring": " Creates a shuttle the same as this but with overriding bindings."}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Fn]visit(Core.Fn)", "name": "visit", "arg_nums": 1, "params": [{"name": "fn", "type": "Core.Fn"}], "return_type": "Core.Fn", "signature": "@Override protected Core.Fn visit(Core.Fn fn)", "original_string": "  @Override protected Core.Fn visit(Core.Fn fn) {\n    final Core.IdPat idPat2 = fn.idPat.accept(this);\n    final Binding binding = Binding.of(fn.idPat);\n    return fn.copy(idPat2, fn.exp.accept(bind(binding)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Fn", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Match]visit(Core.Match)", "name": "visit", "arg_nums": 1, "params": [{"name": "match", "type": "Core.Match"}], "return_type": "Core.Match", "signature": "@Override protected Core.Match visit(Core.Match match)", "original_string": "  @Override protected Core.Match visit(Core.Match match) {\n    final List<Binding> bindings = new ArrayList<>();\n    final Core.Pat pat2 = match.pat.accept(this);\n    Compiles.bindPattern(typeSystem, bindings, pat2);\n    return core.match(match.pos, pat2, match.exp.accept(bind(bindings)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Match", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Exp]visit(Core.Let)", "name": "visit", "arg_nums": 1, "params": [{"name": "let", "type": "Core.Let"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.Let let)", "original_string": "  @Override protected Core.Exp visit(Core.Let let) {\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindPattern(typeSystem, bindings, let.decl);\n    return let.copy(let.decl.accept(this), let.exp.accept(bind(bindings)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Exp]visit(Core.Local)", "name": "visit", "arg_nums": 1, "params": [{"name": "local", "type": "Core.Local"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.Local local)", "original_string": "  @Override protected Core.Exp visit(Core.Local local) {\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindDataType(typeSystem, bindings, local.dataType);\n    return local.copy(local.dataType, local.exp.accept(bind(bindings)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.RecValDecl]visit(Core.RecValDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "recValDecl", "type": "Core.RecValDecl"}], "return_type": "Core.RecValDecl", "signature": "@Override protected Core.RecValDecl visit(Core.RecValDecl recValDecl)", "original_string": "  @Override protected Core.RecValDecl visit(Core.RecValDecl recValDecl) {\n    final List<Binding> bindings = new ArrayList<>();\n    recValDecl.list.forEach(decl ->\n        Compiles.bindPattern(typeSystem, bindings, decl.pat));\n    return recValDecl.copy(bind(bindings).visitList(recValDecl.list));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.RecValDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle.[Core.Exp]visit(Core.From)", "name": "visit", "arg_nums": 1, "params": [{"name": "from", "type": "Core.From"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.From from)", "original_string": "  @Override protected Core.Exp visit(Core.From from) {\n    List<Binding> bindings = ImmutableList.of();\n    final List<Core.FromStep> steps = new ArrayList<>();\n    for (Core.FromStep step : from.steps) {\n      final Core.FromStep step2 = step.accept(bind(bindings));\n      steps.add(step2);\n      bindings = step2.bindings;\n    }\n\n    return from.copy(typeSystem, env, steps);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java", "class_name": "EnvShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvShuttle.java.EnvShuttle", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]empty()", "name": "empty", "arg_nums": 0, "params": [], "return_type": "Tracer", "signature": "public static Tracer empty()", "original_string": "  public static Tracer empty() {\n    return EmptyTracer.INSTANCE;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tracer", "classes": []}, "docstring": " Returns a tracer that does nothing."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnCore(Tracer,int,Consumer<Core.Decl>)", "name": "withOnCore", "arg_nums": 3, "params": [{"name": "tracer", "type": "Tracer"}, {"name": "pass", "type": "int"}, {"name": "consumer", "type": "Consumer<Core.Decl>"}], "return_type": "Tracer", "signature": "public static Tracer withOnCore(Tracer tracer, int pass,\n      Consumer<Core.Decl> consumer)", "original_string": "  public static Tracer withOnCore(Tracer tracer, int pass,\n      Consumer<Core.Decl> consumer) {\n    final int expectedPass = pass;\n    return new DelegatingTracer(tracer) {\n      @Override public void onCore(int pass, Core.Decl e) {\n        if (pass == expectedPass) {\n          consumer.accept(e);\n        }\n        super.onCore(pass, e);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tracer", "classes": []}, "docstring": " Returns a tracer that performs the given action on a declaration,\nthen calls the underlying tracer."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnPlan(Tracer,Consumer<Code>)", "name": "withOnPlan", "arg_nums": 2, "params": [{"name": "tracer", "type": "Tracer"}, {"name": "consumer", "type": "Consumer<Code>"}], "return_type": "Tracer", "signature": "public static Tracer withOnPlan(Tracer tracer, Consumer<Code> consumer)", "original_string": "  public static Tracer withOnPlan(Tracer tracer, Consumer<Code> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public void onPlan(Code code) {\n        consumer.accept(code);\n        super.onPlan(code);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tracer", "classes": []}, "docstring": " Returns a tracer that performs the given action on code,\nthen calls the underlying tracer."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnResult(Tracer,Consumer<Object>)", "name": "withOnResult", "arg_nums": 2, "params": [{"name": "tracer", "type": "Tracer"}, {"name": "consumer", "type": "Consumer<Object>"}], "return_type": "Tracer", "signature": "public static Tracer withOnResult(Tracer tracer, Consumer<Object> consumer)", "original_string": "  public static Tracer withOnResult(Tracer tracer, Consumer<Object> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public void onResult(Object o) {\n        consumer.accept(o);\n        super.onResult(o);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tracer", "classes": []}, "docstring": " Returns a tracer that performs the given action on the result of an\nevaluation, then calls the underlying tracer."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnWarnings(Tracer,Consumer<List<Throwable>>)", "name": "withOnWarnings", "arg_nums": 2, "params": [{"name": "tracer", "type": "Tracer"}, {"name": "consumer", "type": "Consumer<List<Throwable>>"}], "return_type": "Tracer", "signature": "public static Tracer withOnWarnings(Tracer tracer,\n      Consumer<List<Throwable>> consumer)", "original_string": "  public static Tracer withOnWarnings(Tracer tracer,\n      Consumer<List<Throwable>> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public void onWarnings(List<Throwable> warningList) {\n        consumer.accept(warningList);\n        super.onWarnings(warningList);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tracer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnException(Tracer,Consumer<@Nullable Throwable>)", "name": "withOnException", "arg_nums": 2, "params": [{"name": "tracer", "type": "Tracer"}, {"name": "consumer", "type": "Consumer<@Nullable Throwable>"}], "return_type": "Tracer", "signature": "public static Tracer withOnException(Tracer tracer,\n      Consumer<@Nullable Throwable> consumer)", "original_string": "  public static Tracer withOnException(Tracer tracer,\n      Consumer<@Nullable Throwable> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public boolean onException(@Nullable Throwable e) {\n        consumer.accept(e);\n        super.onException(e);\n        return true;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tracer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnCompileException(Tracer,Consumer<CompileException>)", "name": "withOnCompileException", "arg_nums": 2, "params": [{"name": "tracer", "type": "Tracer"}, {"name": "consumer", "type": "Consumer<CompileException>"}], "return_type": "Tracer", "signature": "public static Tracer withOnCompileException(Tracer tracer,\n      Consumer<CompileException> consumer)", "original_string": "  public static Tracer withOnCompileException(Tracer tracer,\n      Consumer<CompileException> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public boolean handleCompileException(\n          @Nullable CompileException e) {\n        consumer.accept(e);\n        super.handleCompileException(e);\n        return true;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tracer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers.[Tracer]withOnTypeException(Tracer,Consumer<TypeResolver.TypeException>)", "name": "withOnTypeException", "arg_nums": 2, "params": [{"name": "tracer", "type": "Tracer"}, {"name": "consumer", "type": "Consumer<TypeResolver.TypeException>"}], "return_type": "Tracer", "signature": "public static Tracer withOnTypeException(Tracer tracer,\n      Consumer<TypeResolver.TypeException> consumer)", "original_string": "  public static Tracer withOnTypeException(Tracer tracer,\n      Consumer<TypeResolver.TypeException> consumer) {\n    return new DelegatingTracer(tracer) {\n      @Override public boolean onTypeException(TypeResolver.TypeException e) {\n        consumer.accept(e);\n        super.onTypeException(e);\n        return true;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Tracer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[]EnvVisitor(TypeSystem,Environment,Deque<FromContext>)", "name": "EnvVisitor", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "fromStack", "type": "Deque<FromContext>"}], "return_type": "", "signature": "protected EnvVisitor(TypeSystem typeSystem, Environment env,\n      Deque<FromContext> fromStack)", "original_string": "  protected EnvVisitor(TypeSystem typeSystem, Environment env,\n      Deque<FromContext> fromStack) {\n    this.typeSystem = typeSystem;\n    this.env = env;\n    this.fromStack = fromStack;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates an EnvVisitor."}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[EnvVisitor]push(Environment)", "name": "push", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "EnvVisitor", "signature": "protected abstract EnvVisitor push(Environment env)", "original_string": "  protected abstract EnvVisitor push(Environment env);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "EnvVisitor", "classes": []}, "docstring": " Creates a visitor the same as this but with a new environment."}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[EnvVisitor]bind(Binding)", "name": "bind", "arg_nums": 1, "params": [{"name": "binding", "type": "Binding"}], "return_type": "EnvVisitor", "signature": "protected EnvVisitor bind(Binding binding)", "original_string": "  protected EnvVisitor bind(Binding binding) {\n    return push(env.bind(binding));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "EnvVisitor", "classes": []}, "docstring": " Creates a visitor the same as this but overriding a binding."}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[EnvVisitor]bind(Iterable<Binding>)", "name": "bind", "arg_nums": 1, "params": [{"name": "bindingList", "type": "Iterable<Binding>"}], "return_type": "EnvVisitor", "signature": "protected EnvVisitor bind(Iterable<Binding> bindingList)", "original_string": "  protected EnvVisitor bind(Iterable<Binding> bindingList)  {\n    // The \"env2 == env\" check is an optimization.\n    // If you remove it, this method will have the same effect, just slower.\n    final Environment env2 = env.bindAll(bindingList);\n    if (env2 != env) {\n      return push(env2);\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "EnvVisitor", "classes": []}, "docstring": " Creates a visitor the same as this but with overriding bindings."}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Fn)", "name": "visit", "arg_nums": 1, "params": [{"name": "fn", "type": "Core.Fn"}], "return_type": "void", "signature": "@Override protected void visit(Core.Fn fn)", "original_string": "  @Override protected void visit(Core.Fn fn) {\n    fn.idPat.accept(this);\n    fn.exp.accept(bind(Binding.of(fn.idPat)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Match)", "name": "visit", "arg_nums": 1, "params": [{"name": "match", "type": "Core.Match"}], "return_type": "void", "signature": "@Override protected void visit(Core.Match match)", "original_string": "  @Override protected void visit(Core.Match match) {\n    final List<Binding> bindings = new ArrayList<>();\n    match.pat.accept(this);\n    Compiles.bindPattern(typeSystem, bindings, match.pat);\n    match.exp.accept(bind(bindings));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Let)", "name": "visit", "arg_nums": 1, "params": [{"name": "let", "type": "Core.Let"}], "return_type": "void", "signature": "@Override protected void visit(Core.Let let)", "original_string": "  @Override protected void visit(Core.Let let) {\n    let.decl.accept(this);\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindPattern(typeSystem, bindings, let.decl);\n    let.exp.accept(bind(bindings));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Local)", "name": "visit", "arg_nums": 1, "params": [{"name": "local", "type": "Core.Local"}], "return_type": "void", "signature": "@Override protected void visit(Core.Local local)", "original_string": "  @Override protected void visit(Core.Local local) {\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindDataType(typeSystem, bindings, local.dataType);\n    local.exp.accept(bind(bindings));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.RecValDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "recValDecl", "type": "Core.RecValDecl"}], "return_type": "void", "signature": "@Override protected void visit(Core.RecValDecl recValDecl)", "original_string": "  @Override protected void visit(Core.RecValDecl recValDecl) {\n    final List<Binding> bindings = new ArrayList<>();\n    recValDecl.list.forEach(decl ->\n        Compiles.bindPattern(typeSystem, bindings, decl.pat));\n    final EnvVisitor v2 = bind(bindings);\n    recValDecl.list.forEach(v2::accept);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.From)", "name": "visit", "arg_nums": 1, "params": [{"name": "from", "type": "Core.From"}], "return_type": "void", "signature": "@Override protected void visit(Core.From from)", "original_string": "  @Override protected void visit(Core.From from) {\n    List<Binding> bindings = ImmutableList.of();\n    for (Core.FromStep step : from.steps) {\n      visitStep(step, bindings);\n      bindings = step.bindings;\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visitStep(Core.FromStep,List<Binding>)", "name": "visitStep", "arg_nums": 2, "params": [{"name": "step", "type": "Core.FromStep"}, {"name": "bindings", "type": "List<Binding>"}], "return_type": "void", "signature": "public void visitStep(Core.FromStep step, List<Binding> bindings)", "original_string": "  public void visitStep(Core.FromStep step, List<Binding> bindings) {\n    try {\n      fromStack.push(new FromContext(this, step));\n      step.accept(bind(bindings));\n    } finally {\n      fromStack.pop();\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor.[void]visit(Core.Aggregate)", "name": "visit", "arg_nums": 1, "params": [{"name": "aggregate", "type": "Core.Aggregate"}], "return_type": "void", "signature": "@Override protected void visit(Core.Aggregate aggregate)", "original_string": "  @Override protected void visit(Core.Aggregate aggregate) {\n    // Aggregates need an environment that includes the group keys.\n    // For example,\n    //   from (i, j) in [(1, 2), (2, 3)]\n    //     group k = i + 2\n    //     compute fn list => List.size list + j of i + j\n    // the aggregate \"fn list => List.size list + j\" needs an environment [k];\n    // the argument \"i + j\" needs an environment [i, j].\n    EnvVisitor v2 = fromStack.element().visitor;\n    Core.Group group = (Core.Group) fromStack.element().step;\n    EnvVisitor v3 = v2.bind(transform(group.groupExps.keySet(), Binding::of));\n    aggregate.aggregate.accept(v3);\n    if (aggregate.argument != null) {\n      aggregate.argument.accept(this);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java", "class_name": "EnvVisitor", "class_uri": "src/main/java/net/hydromatic/morel/compile/EnvVisitor.java.EnvVisitor", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[void]onCore(int,Core.Decl)", "name": "onCore", "arg_nums": 2, "params": [{"name": "pass", "type": "int"}, {"name": "e", "type": "Core.Decl"}], "return_type": "void", "signature": "void onCore(int pass, Core.Decl e)", "original_string": "  void onCore(int pass, Core.Decl e);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracer.java", "class_name": "Tracer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Called when the expression is converted to core."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[void]onPlan(Code)", "name": "onPlan", "arg_nums": 1, "params": [{"name": "code", "type": "Code"}], "return_type": "void", "signature": "void onPlan(Code code)", "original_string": "  void onPlan(Code code);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracer.java", "class_name": "Tracer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Called when code is generated."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[void]onResult(Object)", "name": "onResult", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "void", "signature": "void onResult(Object o)", "original_string": "  void onResult(Object o);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracer.java", "class_name": "Tracer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Called on the result of an evaluation."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[void]onWarnings(List<Throwable>)", "name": "onWarnings", "arg_nums": 1, "params": [{"name": "warningList", "type": "List<Throwable>"}], "return_type": "void", "signature": "void onWarnings(List<Throwable> warningList)", "original_string": "  void onWarnings(List<Throwable> warningList);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracer.java", "class_name": "Tracer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Called with the list of warnings after evaluation."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[boolean]onException(Throwable)", "name": "onException", "arg_nums": 1, "params": [{"name": "e", "type": "Throwable"}], "return_type": "boolean", "signature": "boolean onException(@Nullable Throwable e)", "original_string": "  boolean onException(@Nullable Throwable e);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracer.java", "class_name": "Tracer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Called with the exception thrown during evaluation, or null if no\nexception was thrown. Returns whether a handler was found."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[boolean]onTypeException(TypeResolver.TypeException)", "name": "onTypeException", "arg_nums": 1, "params": [{"name": "e", "type": "TypeResolver.TypeException"}], "return_type": "boolean", "signature": "boolean onTypeException(TypeResolver.TypeException e)", "original_string": "  boolean onTypeException(TypeResolver.TypeException e);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracer.java", "class_name": "Tracer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Called with the exception thrown during type resolution.\nReturns whether a handler was found."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer.[boolean]handleCompileException(CompileException)", "name": "handleCompileException", "arg_nums": 1, "params": [{"name": "e", "type": "CompileException"}], "return_type": "boolean", "signature": "boolean handleCompileException(@Nullable CompileException e)", "original_string": "  boolean handleCompileException(@Nullable CompileException e);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Tracer.java", "class_name": "Tracer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Tracer.java.Tracer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Called with the exception thrown during validation, or null if no\nexception was thrown. Returns whether a handler was found."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[]Inliner(TypeSystem,Environment,Analyzer.Analysis)", "name": "Inliner", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "analysis", "type": "Analyzer.Analysis"}], "return_type": "", "signature": "private Inliner(TypeSystem typeSystem, Environment env,\n      Analyzer.Analysis analysis)", "original_string": "  private Inliner(TypeSystem typeSystem, Environment env,\n      Analyzer.Analysis analysis) {\n    super(typeSystem, env);\n    this.analysis = analysis;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Inliner.java", "class_name": "Inliner", "class_uri": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": " Private constructor."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Inliner]of(TypeSystem,Environment,Analyzer.@Nullable Analysis)", "name": "of", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "analysis", "type": "Analyzer.@Nullable Analysis"}], "return_type": "Inliner", "signature": "public static Inliner of(TypeSystem typeSystem, Environment env,\n      Analyzer.@Nullable Analysis analysis)", "original_string": "  public static Inliner of(TypeSystem typeSystem, Environment env,\n      Analyzer.@Nullable Analysis analysis) {\n    return new Inliner(typeSystem, env, analysis);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Inliner.java", "class_name": "Inliner", "class_uri": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Inliner", "classes": []}, "docstring": " Creates an Inliner.\n\n<p>If {@code analysis} is null, no variables are inlined."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Inliner]push(Environment)", "name": "push", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "Inliner", "signature": "@Override protected Inliner push(Environment env)", "original_string": "  @Override protected Inliner push(Environment env) {\n    return new Inliner(typeSystem, env, analysis);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Inliner.java", "class_name": "Inliner", "class_uri": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Inliner", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Core.Exp]visit(Core.Id)", "name": "visit", "arg_nums": 1, "params": [{"name": "id", "type": "Core.Id"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.Id id)", "original_string": "  @Override protected Core.Exp visit(Core.Id id) {\n    final Binding binding = env.getOpt(id.idPat);\n    if (binding != null\n        && !binding.parameter) {\n      if (binding.exp != null) {\n        final Analyzer.Use use =\n            analysis == null ? Analyzer.Use.MULTI_UNSAFE\n                : requireNonNull(analysis.map.get(id.idPat));\n        switch (use) {\n        case ATOMIC:\n        case ONCE_SAFE:\n          return binding.exp.accept(this);\n        }\n      }\n      Object v = binding.value;\n      if (v instanceof Macro) {\n        final Macro macro = (Macro) binding.value;\n        final Core.Exp x =\n            macro.expand(typeSystem, env, ((FnType) id.type).paramType);\n        if (x instanceof Core.Literal) {\n          return x;\n        }\n      }\n      if (v != Unit.INSTANCE) {\n        switch (id.type.op()) {\n        case ID:\n          assert id.type instanceof PrimitiveType;\n          return core.literal((PrimitiveType) id.type, v);\n\n        case FUNCTION_TYPE:\n          assert v instanceof Applicable || v instanceof Macro : v;\n          final BuiltIn builtIn = Codes.BUILT_IN_MAP.get(v);\n          if (builtIn != null) {\n            return core.functionLiteral(typeSystem, builtIn);\n          }\n          // Applicable (including Closure) that does not map to a BuiltIn\n          // is not considered 'constant', mainly because it creates messy plans\n          break;\n\n        default:\n          if (v instanceof Code) {\n            v = ((Code) v).eval(Compiler.EMPTY_ENV);\n            if (v == null) {\n              // Cannot inline SYS_FILE; it requires a session.\n              break;\n            }\n          }\n          return core.valueLiteral(id, v);\n        }\n      }\n    }\n    return super.visit(id);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Inliner.java", "class_name": "Inliner", "class_uri": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Core.Exp]visit(Core.Apply)", "name": "visit", "arg_nums": 1, "params": [{"name": "apply", "type": "Core.Apply"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.Apply apply)", "original_string": "  @Override protected Core.Exp visit(Core.Apply apply) {\n    final Core.Apply apply2 = (Core.Apply) super.visit(apply);\n    if (apply2.fn.op == Op.RECORD_SELECTOR\n        && apply2.arg.op == Op.VALUE_LITERAL) {\n      final Core.RecordSelector selector = (Core.RecordSelector) apply2.fn;\n      @SuppressWarnings(\"rawtypes\")\n      final List list = ((Core.Literal) apply2.arg).unwrap(List.class);\n      final Object o = list.get(selector.slot);\n      if (o instanceof Applicable || o instanceof Macro) {\n        // E.g. apply is '#filter List', o is Codes.LIST_FILTER,\n        // builtIn is BuiltIn.LIST_FILTER.\n        final BuiltIn builtIn = Codes.BUILT_IN_MAP.get(o);\n        if (builtIn != null) {\n          return core.functionLiteral(typeSystem, builtIn);\n        }\n      }\n      return core.valueLiteral(apply2, o);\n    }\n    if (apply2.fn.op == Op.FN) {\n      // Beta-reduction:\n      //   (fn x => E) A\n      // becomes\n      //   let x = A in E end\n      final Core.Fn fn = (Core.Fn) apply2.fn;\n      return core.let(\n          core.nonRecValDecl(apply2.pos, fn.idPat, apply2.arg), fn.exp);\n    }\n    return apply2;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Inliner.java", "class_name": "Inliner", "class_uri": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Core.Exp]visit(Core.Case)", "name": "visit", "arg_nums": 1, "params": [{"name": "caseOf", "type": "Core.Case"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.Case caseOf)", "original_string": "  @Override protected Core.Exp visit(Core.Case caseOf) {\n    final Core.Exp exp = caseOf.exp.accept(this);\n    final List<Core.Match> matchList = visitList(caseOf.matchList);\n    if (matchList.size() == 1) {\n      final Map<Core.Id, Core.Id> substitution =\n          getSub(exp, matchList.get(0));\n      if (substitution != null) {\n        return Replacer.substitute(typeSystem, substitution,\n            matchList.get(0).exp);\n      }\n    }\n    return caseOf.copy(exp, matchList);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Inliner.java", "class_name": "Inliner", "class_uri": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Map<Core.Id, Core.Id>]getSub(Core.Exp,Core.Match)", "name": "getSub", "arg_nums": 2, "params": [{"name": "exp", "type": "Core.Exp"}, {"name": "match", "type": "Core.Match"}], "return_type": "Map<Core.Id, Core.Id>", "signature": "private @Nullable Map<Core.Id, Core.Id> getSub(Core.Exp exp,\n      Core.Match match)", "original_string": "  private @Nullable Map<Core.Id, Core.Id> getSub(Core.Exp exp,\n      Core.Match match) {\n    if (exp.op == Op.ID && match.pat.op == Op.ID_PAT) {\n      return ImmutableMap.of(core.id((Core.IdPat) match.pat), (Core.Id) exp);\n    }\n    if (exp.op == Op.TUPLE && match.pat.op == Op.TUPLE_PAT) {\n      final Core.Tuple tuple = (Core.Tuple) exp;\n      final Core.TuplePat tuplePat = (Core.TuplePat) match.pat;\n      if (tuple.args.stream().allMatch(arg -> arg.op == Op.ID)\n          && tuplePat.args.stream().allMatch(arg -> arg.op == Op.ID_PAT)) {\n        final ImmutableMap.Builder<Core.Id, Core.Id> builder =\n            ImmutableMap.builder();\n        forEach(tuple.args, tuplePat.args, (arg, pat) ->\n            builder.put(core.id((Core.IdPat) pat), (Core.Id) arg));\n        return builder.build();\n      }\n    }\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Inliner.java", "class_name": "Inliner", "class_uri": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner", "attributes": {"modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "return_type": "Map<Core.Id, Core.Id>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner.[Core.Exp]visit(Core.Let)", "name": "visit", "arg_nums": 1, "params": [{"name": "let", "type": "Core.Let"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.Let let)", "original_string": "  @Override protected Core.Exp visit(Core.Let let) {\n    final Analyzer.Use use =\n        analysis == null\n            ? Analyzer.Use.MULTI_UNSAFE\n            : let.decl instanceof Core.NonRecValDecl\n                ? requireNonNull(\n                    analysis.map.get(((Core.NonRecValDecl) let.decl).pat))\n                : Analyzer.Use.MULTI_UNSAFE;\n    switch (use) {\n    case DEAD:\n      // This declaration has no uses; remove it\n      return let.exp;\n\n    case ATOMIC:\n    case ONCE_SAFE:\n      // This declaration has one use; remove the declaration, and replace its\n      // use inside the expression.\n      final List<Binding> bindings = new ArrayList<>();\n      Compiles.bindPattern(typeSystem, bindings, let.decl);\n      return let.exp.accept(bind(bindings));\n    }\n    return super.visit(let);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Inliner.java", "class_name": "Inliner", "class_uri": "src/main/java/net/hydromatic/morel/compile/Inliner.java.Inliner", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[]PatternCoverageChecker(TypeSystem)", "name": "PatternCoverageChecker", "arg_nums": 1, "params": [{"name": "typeSystem", "type": "TypeSystem"}], "return_type": "", "signature": "private PatternCoverageChecker(TypeSystem typeSystem)", "original_string": "  private PatternCoverageChecker(TypeSystem typeSystem) {\n    this.typeSystem = requireNonNull(typeSystem, \"typeSystem\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a PatternCoverageChecker."}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[boolean]isCoveredBy(TypeSystem,List<Core.Pat>,Core.Pat)", "name": "isCoveredBy", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "prevPatList", "type": "List<Core.Pat>"}, {"name": "pat", "type": "Core.Pat"}], "return_type": "boolean", "signature": "static boolean isCoveredBy(TypeSystem typeSystem, List<Core.Pat> prevPatList,\n      Core.Pat pat)", "original_string": "  static boolean isCoveredBy(TypeSystem typeSystem, List<Core.Pat> prevPatList,\n      Core.Pat pat) {\n    if (prevPatList.isEmpty()) {\n      return false; // shortcut\n    }\n    // p isCoveredBy [p0 ... pN ]\n    //   iff\n    // (f ^ ~f0 ^ ... ^ ~fN) is not satisfiable\n    //   where f is the formula for p\n    //   and f0 is the formula for p0, etc.\n    return new PatternCoverageChecker(typeSystem).isCoveredBy(pat, prevPatList);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether every possible value that could be matched by\npattern {@code pat} would already have been matched by one or more of\n{@code prevPatList}.\n\n<p>For example, the pattern \"(1, b: bool)\" is covered by \"[(1, true),\n(_, false)]\" but not by \"[(1, true)]\" or \"[(_, false)]\"."}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[boolean]isExhaustive(TypeSystem,List<Core.Pat>)", "name": "isExhaustive", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "patList", "type": "List<Core.Pat>"}], "return_type": "boolean", "signature": "@SuppressWarnings(\"StaticPseudoFunctionalStyleMethod\")\n  static boolean isExhaustive(TypeSystem typeSystem, List<Core.Pat> patList)", "original_string": "  @SuppressWarnings(\"StaticPseudoFunctionalStyleMethod\")\n  static boolean isExhaustive(TypeSystem typeSystem, List<Core.Pat> patList) {\n    if (patList.isEmpty()) {\n      return false; // shortcut\n    }\n    if (Iterables.any(patList, p ->\n        p.op == Op.WILDCARD_PAT || p.op == Op.ID_PAT)) {\n      return true; // shortcut\n    }\n    final Core.WildcardPat wildcardPat =\n        core.wildcardPat(patList.get(0).type);\n    return isCoveredBy(typeSystem, patList, wildcardPat);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "@SuppressWarnings(\"StaticPseudoFunctionalStyleMethod\")\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"StaticPseudoFunctionalStyleMethod\")", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether a list of patterns covers every possible value.\nIf so, any pattern added to this list would be redundant."}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[Sat.Term]toTerm(Core.Pat)", "name": "toTerm", "arg_nums": 1, "params": [{"name": "pat", "type": "Core.Pat"}], "return_type": "Sat.Term", "signature": "private Sat.Term toTerm(Core.Pat pat)", "original_string": "  private Sat.Term toTerm(Core.Pat pat) {\n    final List<Sat.Term> terms = new ArrayList<>();\n    toTerm(pat, Path.ROOT, terms);\n    return terms.size() == 1 ? terms.get(0) : sat.and(terms);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Sat.Term", "classes": []}, "docstring": " Converts a pattern to a logical term."}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[void]toTerm(Core.Pat,Path,List<Sat.Term>)", "name": "toTerm", "arg_nums": 3, "params": [{"name": "pat", "type": "Core.Pat"}, {"name": "path", "type": "Path"}, {"name": "terms", "type": "List<Sat.Term>"}], "return_type": "void", "signature": "private void toTerm(Core.Pat pat, Path path, List<Sat.Term> terms)", "original_string": "  private void toTerm(Core.Pat pat, Path path, List<Sat.Term> terms) {\n    switch (pat.op) {\n    case WILDCARD_PAT:\n    case ID_PAT:\n      return; // no constraints to add\n\n    case AS_PAT:\n      toTerm(((Core.AsPat) pat).pat, path, terms);\n      return;\n\n    case BOOL_LITERAL_PAT:\n      // Transform false to FALSE and true to TRUE, constructor of the\n      // internal $bool datatype:\n      //   datatype $bool = FALSE | TRUE\n      // Knowing there are only two values allows us to\n      final DataType boolDataType =\n          (DataType) typeSystem.lookupInternal(\"$bool\");\n      final Core.LiteralPat literalPat0 = (Core.LiteralPat) pat;\n      final Boolean value = (Boolean) literalPat0.value;\n      toTerm(core.con0Pat(boolDataType, value ? \"TRUE\" : \"FALSE\"), path, terms);\n      return;\n\n    case CHAR_LITERAL_PAT:\n    case INT_LITERAL_PAT:\n    case REAL_LITERAL_PAT:\n    case STRING_LITERAL_PAT:\n      final Core.LiteralPat literalPat = (Core.LiteralPat) pat;\n      terms.add(sat.variable(path.toVar(literalPat.value.toString())));\n      return;\n\n    case CON0_PAT:\n      final Core.Con0Pat con0Pat = (Core.Con0Pat) pat;\n      terms.add(typeConstructorTerm(path, con0Pat.tyCon));\n      return;\n\n    case CON_PAT:\n      final Core.ConPat conPat = (Core.ConPat) pat;\n      terms.add(typeConstructorTerm(path, conPat.tyCon));\n      final int j =\n          ImmutableList.copyOf(\n              ((DataType) conPat.type).typeConstructors.keySet())\n              .indexOf(conPat.tyCon);\n      if (j < 0) {\n        throw new AssertionError(\"type constructor not found: \" + conPat);\n      }\n      toTerm(conPat.pat, path.sub(j), terms);\n      return;\n\n    case CONS_PAT:\n      final Core.ConPat consPat = (Core.ConPat) pat;\n      addConsTerms(path, terms, (Core.TuplePat) consPat.pat);\n      return;\n\n    case TUPLE_PAT:\n      final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n      forEachIndexed(tuplePat.args, (pat2, i) ->\n          toTerm(pat2, path.sub(i), terms));\n      return;\n\n    case RECORD_PAT:\n      final Core.RecordPat recordPat = (Core.RecordPat) pat;\n      forEachIndexed(recordPat.args, (pat2, i) ->\n          toTerm(pat2, path.sub(i), terms));\n      return;\n\n    case LIST_PAT:\n      // For list\n      //   [a, b, c]\n      // built terms as if they had written\n      //   CONS (a, CONS (b, CONS (c, NIL))\n      // namely\n      //   var(tag.0=CONS)\n      //   ^ var(tag.0.1=CONS)\n      //   ^ var(tag.0.1.1=CONS)\n      //   ^ var(tag.0.1.1.1=NIL\n      toTerm(listToCons((Core.ListPat) pat), path, terms);\n      return;\n\n    default:\n      throw new AssertionError(pat.op);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[Core.Pat]listToCons(Core.ListPat)", "name": "listToCons", "arg_nums": 1, "params": [{"name": "listPat", "type": "Core.ListPat"}], "return_type": "Core.Pat", "signature": "private Core.Pat listToCons(Core.ListPat listPat)", "original_string": "  private Core.Pat listToCons(Core.ListPat listPat) {\n    final Type listType = typeSystem.lookupInternal(\"$list\");\n    final DataType listDataType = (DataType) ((ForallType) listType).type;\n    return listToConsRecurse(listDataType, listPat.args);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": " Converts a list pattern into a pattern made up of the {@code CONS} and\n{@code NIL} constructors of the built-in {@code datatype list}.\n\n<p>For example, converts:\n\"[]\" to \"NIL\",\n\"[x]\" to \"CONS (x, NIL)\",\n\"[x, y]\" to \"CONS (x, CONS (y, NIL))\",\netc."}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[Core.Pat]listToConsRecurse(DataType,List<Core.Pat>)", "name": "listToConsRecurse", "arg_nums": 2, "params": [{"name": "listDataType", "type": "DataType"}, {"name": "args", "type": "List<Core.Pat>"}], "return_type": "Core.Pat", "signature": "private Core.Pat listToConsRecurse(DataType listDataType,\n      List<Core.Pat> args)", "original_string": "  private Core.Pat listToConsRecurse(DataType listDataType,\n      List<Core.Pat> args) {\n    if (args.isEmpty()) {\n      return core.con0Pat(listDataType, \"NIL\");\n    } else {\n      return core.consPat(listDataType, \"CONS\",\n          core.tuplePat(typeSystem,\n              ImmutableList.of(args.get(0),\n                  listToConsRecurse(listDataType, skip(args)))));\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[void]addConsTerms(Path,List<Sat.Term>,Core.TuplePat)", "name": "addConsTerms", "arg_nums": 3, "params": [{"name": "path", "type": "Path"}, {"name": "terms", "type": "List<Sat.Term>"}, {"name": "tuplePat", "type": "Core.TuplePat"}], "return_type": "void", "signature": "private void addConsTerms(Path path, List<Sat.Term> terms,\n      Core.TuplePat tuplePat)", "original_string": "  private void addConsTerms(Path path, List<Sat.Term> terms,\n      Core.TuplePat tuplePat) {\n    terms.add(typeConstructorTerm(path, \"CONS\"));\n    toTerm(tuplePat, path, terms);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[Sat.Variable]typeConstructorTerm(Path,String)", "name": "typeConstructorTerm", "arg_nums": 2, "params": [{"name": "path", "type": "Path"}, {"name": "con", "type": "String"}], "return_type": "Sat.Variable", "signature": "private Sat.Variable typeConstructorTerm(Path path, String con)", "original_string": "  private Sat.Variable typeConstructorTerm(Path path, String con) {\n    final Pair<DataType, Type.Key> pair = typeSystem.lookupTyCon(con);\n    final DataType dataType = pair.left;\n    DataTypeSlot slot =\n        pathSlots.computeIfAbsent(path,\n            p -> new DataTypeSlot(dataType, p, sat));\n    return slot.constructorMap.get(con);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Sat.Variable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker.[boolean]isCoveredBy(Core.Pat,List<Core.Pat>)", "name": "isCoveredBy", "arg_nums": 2, "params": [{"name": "pat", "type": "Core.Pat"}, {"name": "patList", "type": "List<Core.Pat>"}], "return_type": "boolean", "signature": "public boolean isCoveredBy(Core.Pat pat, List<Core.Pat> patList)", "original_string": "  public boolean isCoveredBy(Core.Pat pat, List<Core.Pat> patList) {\n    final List<Sat.Term> terms = new ArrayList<>();\n    patList.forEach(p -> terms.add(toTerm(p)));\n    final Sat.Term term = toTerm(pat);\n\n    final List<Sat.Term> terms1 = new ArrayList<>();\n    terms1.add(term);\n    terms.forEach(t -> terms1.add(sat.not(t)));\n\n    // Add constraints for tags, which are mutually exclusive.\n    // For example, for a type with constructors A, B, C\n    //   (tag=A or tag=B or tag=C)\n    // because at least one tag must be present, and\n    //   (not (tag=A or tag=B)\n    //   or not (tag=B or tag=C)\n    //   or not (tag=C or tag=A))\n    // because at most one tag must be present.\n    pathSlots.values().forEach(slot -> {\n      final List<Sat.Term> terms2 =\n          new ArrayList<>(slot.constructorMap.values());\n      terms1.add(sat.or(terms2));\n\n      final List<Sat.Term> terms3 = new ArrayList<>();\n      for (int i = 0; i < terms2.size(); i++) {\n        terms3.add(sat.not(sat.or(new ElideList<>(terms2, i))));\n      }\n      terms1.add(sat.or(terms3));\n    });\n    final Sat.Term formula = sat.and(terms1);\n    final Map<Sat.Variable, Boolean> solve = sat.solve(formula);\n    return solve == null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java", "class_name": "PatternCoverageChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/PatternCoverageChecker.java.PatternCoverageChecker", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether a pattern is covered by a list of patterns.\n\n<p>A pattern {@code pat} is said to be <dfn>covered by</dfn> a list of\npatterns {@code patList} if any possible value would be caught by one of\nthe patterns in {@code patList} before reaching {@code pat}. Thus\n{@code pat} is said to be <dfn>redundant</dfn> in that context, and could\nbe removed without affecting behavior."}, {"uris": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle.[]SuchThatShuttle(TypeSystem,Environment)", "name": "SuchThatShuttle", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}], "return_type": "", "signature": "SuchThatShuttle(TypeSystem typeSystem, @Nullable Environment env)", "original_string": "  SuchThatShuttle(TypeSystem typeSystem, @Nullable Environment env) {\n    super(typeSystem);\n    this.env = env;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java", "class_name": "SuchThatShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle.[boolean]containsUnbounded(Core.Decl)", "name": "containsUnbounded", "arg_nums": 1, "params": [{"name": "decl", "type": "Core.Decl"}], "return_type": "boolean", "signature": "static boolean containsUnbounded(Core.Decl decl)", "original_string": "  static boolean containsUnbounded(Core.Decl decl) {\n    final Holder<Boolean> found = Holder.of(false);\n    decl.accept(new Visitor() {\n      @Override protected void visit(Core.Scan scan) {\n        super.visit(scan);\n        if (Extents.isInfinite(scan.exp)) {\n          found.set(true);\n        }\n      }\n    });\n    return found.get();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java", "class_name": "SuchThatShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle.[Core.Exp]visit(Core.From)", "name": "visit", "arg_nums": 1, "params": [{"name": "from", "type": "Core.From"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.From from)", "original_string": "  @Override protected Core.Exp visit(Core.From from) {\n    final Core.From from2 = new FromVisitor(typeSystem, env).visit(from);\n    return from2.equals(from) ? from : from2;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java", "class_name": "SuchThatShuttle", "class_uri": "src/main/java/net/hydromatic/morel/compile/SuchThatShuttle.java.SuchThatShuttle", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[]Pretty(TypeSystem,int,int,int,int)", "name": "Pretty", "arg_nums": 5, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "lineWidth", "type": "int"}, {"name": "printLength", "type": "int"}, {"name": "printDepth", "type": "int"}, {"name": "stringDepth", "type": "int"}], "return_type": "", "signature": "Pretty(TypeSystem typeSystem, int lineWidth, int printLength, int printDepth,\n      int stringDepth)", "original_string": "  Pretty(TypeSystem typeSystem, int lineWidth, int printLength, int printDepth,\n      int stringDepth) {\n    this.typeSystem = requireNonNull(typeSystem);\n    this.lineWidth = lineWidth;\n    this.printLength = printLength;\n    this.printDepth = printDepth;\n    this.stringDepth = stringDepth;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "class_name": "Pretty", "class_uri": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]pretty(StringBuilder,Type,Object)", "name": "pretty", "arg_nums": 3, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "type", "type": "Type"}, {"name": "value", "type": "Object"}], "return_type": "StringBuilder", "signature": "StringBuilder pretty(@NonNull StringBuilder buf,\n      @NonNull Type type, @NonNull Object value)", "original_string": "  StringBuilder pretty(@NonNull StringBuilder buf,\n      @NonNull Type type, @NonNull Object value) {\n    int lineEnd = lineWidth < 0 ? -1 : (buf.length() + lineWidth);\n    return pretty1(buf, 0, new int[] {lineEnd}, 0, type, value, 0, 0);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "class_name": "Pretty", "class_uri": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": " Prints a value to a buffer."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]pretty1(StringBuilder,int,int[],int,Type,Object,int,int)", "name": "pretty1", "arg_nums": 8, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "indent", "type": "int"}, {"name": "lineEnd", "type": "int[]"}, {"name": "depth", "type": "int"}, {"name": "type", "type": "Type"}, {"name": "value", "type": "Object"}, {"name": "leftPrec", "type": "int"}, {"name": "rightPrec", "type": "int"}], "return_type": "StringBuilder", "signature": "private StringBuilder pretty1(@NonNull StringBuilder buf, int indent,\n      int[] lineEnd, int depth, @NonNull Type type, @NonNull Object value,\n      int leftPrec, int rightPrec)", "original_string": "  private StringBuilder pretty1(@NonNull StringBuilder buf, int indent,\n      int[] lineEnd, int depth, @NonNull Type type, @NonNull Object value,\n      int leftPrec, int rightPrec) {\n    final int start = buf.length();\n    final int end = lineEnd[0];\n    pretty2(buf, indent, lineEnd, depth, type, value, leftPrec, rightPrec);\n    if (end >= 0 && buf.length() > end) {\n      // Reset to start, remove trailing whitespace, add newline\n      buf.setLength(start);\n      while (buf.length() > 0\n          && (buf.charAt(buf.length() - 1) == ' '\n              || buf.charAt(buf.length() - 1) == '\\n')) {\n        buf.setLength(buf.length() - 1);\n      }\n      if (buf.length() > 0) {\n        buf.append(\"\\n\");\n      }\n\n      lineEnd[0] = lineWidth < 0 ? -1 : (buf.length() + lineWidth);\n      indent(buf, indent);\n      pretty2(buf, indent, lineEnd, depth, type, value, leftPrec, rightPrec);\n    }\n    return buf;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "class_name": "Pretty", "class_uri": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": " Prints a value to a buffer. If the first attempt goes beyond\n{@code lineEnd}, back-tracks, adds a newline and indent, and\ntries again one time."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[void]indent(StringBuilder,int)", "name": "indent", "arg_nums": 2, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "indent", "type": "int"}], "return_type": "void", "signature": "private static void indent(@NonNull StringBuilder buf, int indent)", "original_string": "  private static void indent(@NonNull StringBuilder buf, int indent) {\n    for (int i = 0; i < indent; i++) {\n      buf.append(' ');\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "class_name": "Pretty", "class_uri": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]pretty2(StringBuilder,int,int[],int,Type,Object,int,int)", "name": "pretty2", "arg_nums": 8, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "indent", "type": "int"}, {"name": "lineEnd", "type": "int[]"}, {"name": "depth", "type": "int"}, {"name": "type", "type": "Type"}, {"name": "value", "type": "Object"}, {"name": "leftPrec", "type": "int"}, {"name": "rightPrec", "type": "int"}], "return_type": "StringBuilder", "signature": "private StringBuilder pretty2(@NonNull StringBuilder buf,\n      int indent, int[] lineEnd, int depth, @NonNull Type type,\n      @NonNull Object value, int leftPrec, int rightPrec)", "original_string": "  private StringBuilder pretty2(@NonNull StringBuilder buf,\n      int indent, int[] lineEnd, int depth, @NonNull Type type,\n      @NonNull Object value, int leftPrec, int rightPrec) {\n    if (value instanceof TypedVal) {\n      final TypedVal typedVal = (TypedVal) value;\n      final StringBuilder buf2 = new StringBuilder(\"val \");\n      appendId(buf2, typedVal.name)\n          .append(\" = \");\n      pretty1(buf, indent, lineEnd, depth, PrimitiveType.BOOL,\n          buf2.toString(), 0, 0);\n      pretty1(buf, indent + 2, lineEnd, depth + 1, typedVal.type, typedVal.o,\n          0, 0);\n      buf.append(' ');\n      pretty1(buf, indent + 2, lineEnd, depth, PrimitiveType.BOOL,\n          new TypeVal(\": \", unqualified(typedVal.type)), 0, 0);\n      return buf;\n    }\n\n    if (value instanceof NamedVal) {\n      final NamedVal namedVal = (NamedVal) value;\n      appendId(buf, namedVal.name)\n          .append('=');\n      pretty1(buf, indent, lineEnd, depth, type, namedVal.o, 0, 0);\n      return buf;\n    }\n\n    if (value instanceof LabelVal) {\n      final LabelVal labelVal = (LabelVal) value;\n      final String prefix =\n          appendId(new StringBuilder(), labelVal.label)\n              .append(':')\n              .toString();\n      pretty1(buf, indent, lineEnd, depth, type,\n          new TypeVal(prefix, labelVal.type), 0, 0);\n      return buf;\n    }\n\n    if (value instanceof TypeVal) {\n      return prettyType(buf, indent, lineEnd, depth, type, (TypeVal) value,\n          leftPrec, rightPrec);\n    }\n\n    if (printDepth >= 0 && depth > printDepth) {\n      buf.append('#');\n      return buf;\n    }\n    final List<Object> list;\n    final int start;\n    String s;\n    switch (type.op()) {\n    case ID:\n      switch ((PrimitiveType) type) {\n      case UNIT:\n        return buf.append(\"()\");\n      case CHAR:\n        s = ((Character) value).toString();\n        return buf.append('#')\n            .append('\"')\n            .append(s.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\"))\n            .append('\"');\n      case STRING:\n        s = (String) value;\n        if (stringDepth >= 0 && s.length() > stringDepth) {\n          s = s.substring(0, stringDepth) + \"#\";\n        }\n        return buf.append('\"')\n            .append(s.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\"))\n            .append('\"');\n      case INT:\n        int i = (Integer) value;\n        if (i < 0) {\n          if (i == Integer.MIN_VALUE) {\n            return buf.append(\"~2147483648\");\n          }\n          buf.append('~');\n          i = -i;\n        }\n        return buf.append(i);\n      case REAL:\n        return Codes.appendFloat(buf, (Float) value);\n      default:\n        return buf.append(value);\n      }\n\n    case FUNCTION_TYPE:\n      return buf.append(\"fn\");\n\n    case LIST:\n      final ListType listType = (ListType) type;\n      list = toList(value);\n      if (list instanceof RelList) {\n        // Do not attempt to print the elements of a foreign list. It might be\n        // huge.\n        return buf.append(\"<relation>\");\n      }\n      if (value instanceof TypedValue) {\n        // A TypedValue is probably a field in a record that represents a\n        // database catalog or a directory of CSV files. If the user wishes to\n        // see the contents of each file they should use a query.\n        return buf.append(\"<relation>\");\n      }\n      return printList(buf, indent, lineEnd, depth, listType.elementType, list);\n\n    case RECORD_TYPE:\n      final RecordType recordType = (RecordType) type;\n      list = toList(value);\n      buf.append(\"{\");\n      start = buf.length();\n      forEachIndexed(list, recordType.argNameTypes.entrySet(),\n          (ordinal, o, nameType) -> {\n            if (buf.length() > start) {\n              buf.append(\",\");\n            }\n            pretty1(buf, indent + 1, lineEnd, depth + 1, nameType.getValue(),\n                new NamedVal(nameType.getKey(), o), 0, 0);\n          });\n      return buf.append(\"}\");\n\n    case TUPLE_TYPE:\n      final TupleType tupleType = (TupleType) type;\n      list = toList(value);\n      buf.append(\"(\");\n      start = buf.length();\n      forEachIndexed(list, tupleType.argTypes,\n          (ordinal, o, elementType) -> {\n            if (buf.length() > start) {\n              buf.append(\",\");\n            }\n            pretty1(buf, indent + 1, lineEnd, depth + 1, elementType, o, 0, 0);\n          });\n      return buf.append(\")\");\n\n    case FORALL_TYPE:\n      return pretty2(buf, indent, lineEnd, depth + 1, ((ForallType) type).type,\n          value, 0, 0);\n\n    case DATA_TYPE:\n      final DataType dataType = (DataType) type;\n      list = toList(value);\n      if (dataType.name.equals(\"vector\")) {\n        final Type argType = Iterables.getOnlyElement(dataType.arguments);\n        return printList(buf.append('#'), indent, lineEnd, depth, argType,\n            list);\n      }\n      final String tyConName = (String) list.get(0);\n      buf.append(tyConName);\n      final Type typeConArgType =\n          dataType.typeConstructors(typeSystem).get(tyConName);\n      requireNonNull(typeConArgType);\n      if (list.size() == 2) {\n        final Object arg = list.get(1);\n        buf.append(' ');\n        final boolean needParentheses =\n            typeConArgType.op() == Op.DATA_TYPE && arg instanceof List;\n        if (needParentheses) {\n          buf.append('(');\n        }\n        pretty2(buf, indent, lineEnd, depth + 1, typeConArgType, arg, 0, 0);\n        if (needParentheses) {\n          buf.append(')');\n        }\n      }\n      return buf;\n\n    default:\n      return buf.append(value);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "class_name": "Pretty", "class_uri": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]prettyType(StringBuilder,int,int[],int,Type,TypeVal,int,int)", "name": "prettyType", "arg_nums": 8, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "indent", "type": "int"}, {"name": "lineEnd", "type": "int[]"}, {"name": "depth", "type": "int"}, {"name": "type", "type": "Type"}, {"name": "typeVal", "type": "TypeVal"}, {"name": "leftPrec", "type": "int"}, {"name": "rightPrec", "type": "int"}], "return_type": "StringBuilder", "signature": "private StringBuilder prettyType(StringBuilder buf, int indent, int[] lineEnd,\n      int depth, Type type, TypeVal typeVal, int leftPrec, int rightPrec)", "original_string": "  private StringBuilder prettyType(StringBuilder buf, int indent, int[] lineEnd,\n      int depth, Type type, TypeVal typeVal, int leftPrec, int rightPrec) {\n    buf.append(typeVal.prefix);\n    final int indent2 = indent + typeVal.prefix.length();\n    final int start;\n    switch (typeVal.type.op()) {\n    case DATA_TYPE:\n    case ID:\n    case TY_VAR:\n      return pretty1(buf, indent2, lineEnd, depth, type,\n          typeVal.type.moniker(), 0, 0);\n\n    case LIST:\n      if (leftPrec > Op.LIST.left\n          || rightPrec > Op.LIST.right) {\n        pretty1(buf, indent2, lineEnd, depth, type, \"(\", 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, typeVal, 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, \")\", 0, 0);\n        return buf;\n      }\n      final ListType listType = (ListType) typeVal.type;\n      pretty1(buf, indent2, lineEnd, depth, type,\n          new TypeVal(\"\", listType.elementType), leftPrec, Op.LIST.left);\n      return buf.append(\" list\");\n\n    case TUPLE_TYPE:\n      if (leftPrec > Op.TUPLE_TYPE.left\n          || rightPrec > Op.TUPLE_TYPE.right) {\n        pretty1(buf, indent2, lineEnd, depth, type, \"(\", 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, typeVal, 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, \")\", 0, 0);\n        return buf;\n      }\n      final TupleType tupleType = (TupleType) typeVal.type;\n      start = buf.length();\n      List<Type> argTypes = tupleType.argTypes;\n      for (int i = 0; i < argTypes.size(); i++) {\n        Type argType = argTypes.get(i);\n        if (buf.length() > start) {\n          pretty1(buf, indent2, lineEnd, depth, type,\n              \" * \", 0, 0);\n        }\n        pretty1(buf, indent2, lineEnd, depth, type,\n            new TypeVal(\"\", argType),\n            i == 0 ? leftPrec : Op.TUPLE_TYPE.right,\n            i == argTypes.size() - 1 ? rightPrec : Op.TUPLE_TYPE.left);\n      }\n      return buf;\n\n    case RECORD_TYPE:\n    case PROGRESSIVE_RECORD_TYPE:\n      final RecordType recordType = (RecordType) typeVal.type;\n      final boolean progressive = typeVal.type.isProgressive();\n      buf.append(\"{\");\n      start = buf.length();\n      recordType.argNameTypes.forEach((name, elementType) -> {\n        if (buf.length() > start) {\n          buf.append(\", \");\n        }\n        pretty1(buf, indent2 + 1, lineEnd, depth, type,\n            new LabelVal(name, elementType), 0, 0);\n      });\n      if (progressive) {\n        if (buf.length() > start) {\n          buf.append(\", \");\n        }\n        pretty1(buf, indent2 + 1, lineEnd, depth, type, \"...\", 0, 0);\n      }\n      return buf.append(\"}\");\n\n    case FUNCTION_TYPE:\n      if (leftPrec > Op.FUNCTION_TYPE.left\n          || rightPrec > Op.FUNCTION_TYPE.right) {\n        pretty1(buf, indent2, lineEnd, depth, type, \"(\", 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, typeVal, 0, 0);\n        pretty1(buf, indent2, lineEnd, depth, type, \")\", 0, 0);\n        return buf;\n      }\n      final FnType fnType = (FnType) typeVal.type;\n      pretty1(buf, indent2 + 1, lineEnd, depth, type,\n          new TypeVal(\"\", fnType.paramType),\n          leftPrec, Op.FUNCTION_TYPE.left);\n      pretty1(buf, indent2 + 1, lineEnd, depth, type, \" -> \", 0, 0);\n      pretty1(buf, indent2 + 1, lineEnd, depth, type,\n          new TypeVal(\"\", fnType.resultType),\n          Op.FUNCTION_TYPE.right, rightPrec);\n      return buf;\n\n    default:\n      throw new AssertionError(\"unknown type \" + typeVal.type);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "class_name": "Pretty", "class_uri": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[List<Object>]toList(Object)", "name": "toList", "arg_nums": 1, "params": [{"name": "value", "type": "Object"}], "return_type": "List<Object>", "signature": "@SuppressWarnings(\"unchecked\")\n  private static List<Object> toList(Object value)", "original_string": "  @SuppressWarnings(\"unchecked\")\n  private static List<Object> toList(Object value) {\n    if (value instanceof TypedValue) {\n      TypedValue typedValue = (TypedValue) value;\n      return (List<Object>) typedValue.valueAs(List.class);\n    }\n    return (List<Object>) value;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "class_name": "Pretty", "class_uri": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  private static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "private", "static"], "comments": [], "return_type": "List<Object>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[Type]unqualified(Type)", "name": "unqualified", "arg_nums": 1, "params": [{"name": "type", "type": "Type"}], "return_type": "Type", "signature": "private static Type unqualified(Type type)", "original_string": "  private static Type unqualified(Type type) {\n    return type instanceof ForallType ? unqualified(((ForallType) type).type)\n        : type;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "class_name": "Pretty", "class_uri": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty.[StringBuilder]printList(StringBuilder,int,int[],int,Type,List<Object>)", "name": "printList", "arg_nums": 6, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "indent", "type": "int"}, {"name": "lineEnd", "type": "int[]"}, {"name": "depth", "type": "int"}, {"name": "elementType", "type": "Type"}, {"name": "list", "type": "List<Object>"}], "return_type": "StringBuilder", "signature": "private StringBuilder printList(@NonNull StringBuilder buf,\n      int indent, int[] lineEnd, int depth, @NonNull Type elementType,\n      @NonNull List<Object> list)", "original_string": "  private StringBuilder printList(@NonNull StringBuilder buf,\n      int indent, int[] lineEnd, int depth, @NonNull Type elementType,\n      @NonNull List<Object> list) {\n    buf.append(\"[\");\n    int start = buf.length();\n    for (Ord<Object> o : Ord.zip(list)) {\n      if (buf.length() > start) {\n        buf.append(\",\");\n      }\n      if (printLength >= 0 && o.i >= printLength) {\n        pretty1(buf, indent + 1, lineEnd, depth + 1, PrimitiveType.BOOL,\n            \"...\", 0, 0);\n        break;\n      } else {\n        pretty1(buf, indent + 1, lineEnd, depth + 1, elementType, o.e, 0, 0);\n      }\n    }\n    return buf.append(\"]\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Pretty.java", "class_name": "Pretty", "class_uri": "src/main/java/net/hydromatic/morel/compile/Pretty.java.Pretty", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[]Environments()", "name": "Environments", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Environments()", "original_string": "  private Environments() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environments.java", "class_name": "Environments", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[Environment]empty()", "name": "empty", "arg_nums": 0, "params": [], "return_type": "Environment", "signature": "public static Environment empty()", "original_string": "  public static Environment empty() {\n    return BASIC_ENVIRONMENT;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environments.java", "class_name": "Environments", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": " Creates an empty environment."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[Environment]env(TypeSystem,Session,Map<String, ForeignValue>)", "name": "env", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "session", "type": "Session"}, {"name": "valueMap", "type": "Map<String, ForeignValue>"}], "return_type": "Environment", "signature": "public static Environment env(TypeSystem typeSystem,\n      @Nullable Session session, Map<String, ForeignValue> valueMap)", "original_string": "  public static Environment env(TypeSystem typeSystem,\n      @Nullable Session session, Map<String, ForeignValue> valueMap) {\n    return env(EmptyEnvironment.INSTANCE, typeSystem, session, valueMap);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environments.java", "class_name": "Environments", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": " Creates an environment containing built-ins and the given foreign\nvalues."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[Environment]env(Environment,TypeSystem,Session,Map<String, ForeignValue>)", "name": "env", "arg_nums": 4, "params": [{"name": "environment", "type": "Environment"}, {"name": "typeSystem", "type": "TypeSystem"}, {"name": "session", "type": "Session"}, {"name": "valueMap", "type": "Map<String, ForeignValue>"}], "return_type": "Environment", "signature": "private static Environment env(Environment environment, TypeSystem typeSystem,\n      @Nullable Session session, Map<String, ForeignValue> valueMap)", "original_string": "  private static Environment env(Environment environment, TypeSystem typeSystem,\n      @Nullable Session session, Map<String, ForeignValue> valueMap) {\n    if (SKIP) {\n      return environment;\n    }\n    final List<Binding> bindings = new ArrayList<>();\n    BuiltIn.dataTypes(typeSystem, bindings);\n    final NameGenerator nameGen = typeSystem.nameGenerator;\n    Codes.BUILT_IN_VALUES.forEach((key, value) -> {\n      if (\"$\".equals(key.structure)) {\n        return; // ignore Z_ANDALSO, Z_LIST, etc.\n      }\n      final Type type = key.typeFunction.apply(typeSystem);\n      if (key.sessionValue != null) {\n        if (session == null) {\n          return;\n        }\n        value = key.sessionValue.apply(session);\n      }\n      if (key.structure == null) {\n        bindings.add(Binding.of(core.idPat(type, key.mlName, nameGen), value));\n      }\n      if (key.alias != null) {\n        bindings.add(Binding.of(core.idPat(type, key.alias, nameGen), value));\n      }\n    });\n\n    final EvalEnv emptyEnv = Codes.emptyEnv();\n    BuiltIn.forEachStructure(typeSystem, (structure, type) ->\n        bindings.add(\n            Binding.of(core.idPat(type, structure.name, nameGen),\n                emptyEnv.getOpt(structure.name))));\n\n    foreignBindings(typeSystem, valueMap, bindings);\n    return bind(environment, bindings);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environments.java", "class_name": "Environments", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": " Creates a compilation environment, including built-ins and foreign\nvalues."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[void]foreignBindings(TypeSystem,Map<String, ForeignValue>,List<Binding>)", "name": "foreignBindings", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "map", "type": "Map<String, ForeignValue>"}, {"name": "bindings", "type": "List<Binding>"}], "return_type": "void", "signature": "private static void foreignBindings(TypeSystem typeSystem,\n      Map<String, ForeignValue> map, List<Binding> bindings)", "original_string": "  private static void foreignBindings(TypeSystem typeSystem,\n      Map<String, ForeignValue> map, List<Binding> bindings) {\n    map.forEach((name, value) -> bindings.add(\n        Binding.of(\n            core.idPat(value.type(typeSystem), name, typeSystem.nameGenerator),\n            value.value())\n            .withParameter(true)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environments.java", "class_name": "Environments", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments.[Environment]bind(Environment,Iterable<Binding>)", "name": "bind", "arg_nums": 2, "params": [{"name": "env", "type": "Environment"}, {"name": "bindings", "type": "Iterable<Binding>"}], "return_type": "Environment", "signature": "static Environment bind(Environment env, Iterable<Binding> bindings)", "original_string": "  static Environment bind(Environment env, Iterable<Binding> bindings) {\n    if (shorterThan(bindings, 5)) {\n      for (Binding binding : bindings) {\n        env = env.bind(binding);\n      }\n      return env;\n    } else {\n      // We assume that the set of bindings does not include two Core.IdPat\n      // instances with the same name but different ordinals.\n      final ImmutableMap.Builder<Core.NamedPat, Binding> b =\n          ImmutableMap.builder();\n      bindings.forEach(binding -> b.put(binding.id, binding));\n      final ImmutableMap<Core.NamedPat, Binding> map = b.build();\n      final ImmutableSet<Core.NamedPat> names = map.keySet();\n      env = env.nearestAncestorNotObscuredBy(names);\n      return new MapEnvironment(env, map);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environments.java", "class_name": "Environments", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environments.java.Environments", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": " Creates an environment that is a given environment plus bindings."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[TypeResolver.Resolved]validateExpression(AstNode,Map<Prop, Object>,Map<String, ForeignValue>)", "name": "validateExpression", "arg_nums": 3, "params": [{"name": "statement", "type": "AstNode"}, {"name": "propMap", "type": "Map<Prop, Object>"}, {"name": "valueMap", "type": "Map<String, ForeignValue>"}], "return_type": "TypeResolver.Resolved", "signature": "public static TypeResolver.Resolved validateExpression(AstNode statement,\n      Map<Prop, Object> propMap, Map<String, ForeignValue> valueMap)", "original_string": "  public static TypeResolver.Resolved validateExpression(AstNode statement,\n      Map<Prop, Object> propMap, Map<String, ForeignValue> valueMap) {\n    final TypeSystem typeSystem = new TypeSystem();\n    final Session session = new Session(propMap);\n    final Environment env = Environments.env(typeSystem, session, valueMap);\n    return TypeResolver.deduceType(env, toDecl(statement), typeSystem);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "TypeResolver.Resolved", "classes": []}, "docstring": " Validates an expression or declaration, deducing its type and perhaps\nrewriting the expression to a form that can more easily be compiled.\n\n<p>Used for testing."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[CompiledStatement]prepareStatement(TypeSystem,Session,Environment,AstNode,Calcite,Consumer<CompileException>,Tracer)", "name": "prepareStatement", "arg_nums": 7, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "session", "type": "Session"}, {"name": "env", "type": "Environment"}, {"name": "statement", "type": "AstNode"}, {"name": "calcite", "type": "Calcite"}, {"name": "warningConsumer", "type": "Consumer<CompileException>"}, {"name": "tracer", "type": "Tracer"}], "return_type": "CompiledStatement", "signature": "public static CompiledStatement prepareStatement(TypeSystem typeSystem,\n      Session session, Environment env, AstNode statement,\n      @Nullable Calcite calcite, Consumer<CompileException> warningConsumer,\n      Tracer tracer)", "original_string": "  public static CompiledStatement prepareStatement(TypeSystem typeSystem,\n      Session session, Environment env, AstNode statement,\n      @Nullable Calcite calcite, Consumer<CompileException> warningConsumer,\n      Tracer tracer) {\n    Ast.Decl decl;\n    if (statement instanceof Ast.Exp) {\n      decl = toValDecl((Ast.Exp) statement);\n    } else {\n      decl = (Ast.Decl) statement;\n    }\n    return prepareDecl(typeSystem, session, env, calcite, decl,\n        warningConsumer, tracer);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "CompiledStatement", "classes": []}, "docstring": "\nValidates and compiles a statement (expression or declaration), and\ncompiles it to code that can be evaluated by the interpreter.\n"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[CompiledStatement]prepareDecl(TypeSystem,Session,Environment,Calcite,Ast.Decl,Consumer<CompileException>,Tracer)", "name": "prepareDecl", "arg_nums": 7, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "session", "type": "Session"}, {"name": "env", "type": "Environment"}, {"name": "calcite", "type": "Calcite"}, {"name": "decl", "type": "Ast.Decl"}, {"name": "warningConsumer", "type": "Consumer<CompileException>"}, {"name": "tracer", "type": "Tracer"}], "return_type": "CompiledStatement", "signature": "private static CompiledStatement prepareDecl(TypeSystem typeSystem,\n      Session session, Environment env, @Nullable Calcite calcite,\n      Ast.Decl decl,\n      Consumer<CompileException> warningConsumer, Tracer tracer)", "original_string": "  private static CompiledStatement prepareDecl(TypeSystem typeSystem,\n      Session session, Environment env, @Nullable Calcite calcite,\n      Ast.Decl decl,\n      Consumer<CompileException> warningConsumer, Tracer tracer) {\n    final TypeResolver.Resolved resolved =\n        TypeResolver.deduceType(env, decl, typeSystem);\n    final boolean hybrid = Prop.HYBRID.booleanValue(session.map);\n    final int inlinePassCount =\n        Math.max(Prop.INLINE_PASS_COUNT.intValue(session.map), 0);\n    final boolean relationalize =\n        Prop.RELATIONALIZE.booleanValue(session.map);\n\n    final Resolver resolver = Resolver.of(resolved.typeMap, env, session);\n    final Core.Decl coreDecl0 = resolver.toCore(resolved.node);\n    tracer.onCore(0, coreDecl0);\n\n    // Should we skip printing the root pattern?\n    // Yes, if they wrote 'val x = 1 and y = 2' and\n    // core became 'val it as (x, y) = (1, 2)'.\n    // No, if they actually wrote 'val (x, y) = (1, 2)'.\n    final Core.NamedPat skipPat = getSkipPat(resolved.node, coreDecl0);\n\n    // Check for exhaustive and redundant patterns, and throw errors or\n    // warnings.\n    final boolean matchCoverageEnabled =\n        Prop.MATCH_COVERAGE_ENABLED.booleanValue(session.map);\n    if (matchCoverageEnabled) {\n      checkPatternCoverage(typeSystem, coreDecl0, warningConsumer);\n    }\n\n    // Ensures that once we discover that there are no unbounded variables,\n    // we stop looking; makes things a bit more efficient.\n    boolean mayContainUnbounded = true;\n\n    Core.Decl coreDecl;\n    tracer.onCore(1, coreDecl0);\n    if (inlinePassCount == 0) {\n      // Inlining is disabled. Use the Inliner in a limited mode.\n      final Inliner inliner = Inliner.of(typeSystem, env, null);\n      coreDecl = coreDecl0.accept(inliner);\n    } else {\n      final @Nullable Relationalizer relationalizer =\n          relationalize ? Relationalizer.of(typeSystem, env)\n              : null;\n\n      // Inline few times, or until we reach fixed point, whichever is sooner.\n      coreDecl = coreDecl0;\n      for (int i = 0; i < inlinePassCount; i++) {\n        final Analyzer.Analysis analysis =\n            Analyzer.analyze(typeSystem, env, coreDecl);\n        final Inliner inliner = Inliner.of(typeSystem, env, analysis);\n        final Core.Decl coreDecl2 = coreDecl;\n        coreDecl = coreDecl2.accept(inliner);\n        if (relationalizer != null) {\n          coreDecl = coreDecl.accept(relationalizer);\n        }\n        if (coreDecl == coreDecl2) {\n          break;\n        }\n        tracer.onCore(i + 2, coreDecl);\n      }\n      for (int i = 0; i < inlinePassCount; i++) {\n        final Core.Decl coreDecl2 = coreDecl;\n        if (mayContainUnbounded) {\n          if (SuchThatShuttle.containsUnbounded(coreDecl)) {\n            coreDecl = coreDecl.accept(new SuchThatShuttle(typeSystem, env));\n          } else {\n            mayContainUnbounded = false;\n          }\n        }\n        coreDecl = Extents.infinitePats(typeSystem, coreDecl);\n        if (coreDecl == coreDecl2) {\n          break;\n        }\n        tracer.onCore(i + 2, coreDecl);\n      }\n    }\n    tracer.onCore(-1, coreDecl);\n    final Compiler compiler;\n    if (hybrid) {\n      if (calcite == null) {\n        calcite = Calcite.withDataSets(ImmutableMap.of());\n      }\n      compiler = new CalciteCompiler(typeSystem, calcite);\n    } else {\n      compiler = new Compiler(typeSystem);\n    }\n\n    // If the user wrote \"scott.depts\" we will print \"<relation>\";\n    // but if the user wrote \"from d in scott.depts\", they would like to see\n    // the full contents. Those two expressions may have been simplified to the\n    // same Core.Exp, but in the latter case we will 'wrap' the RelList value\n    // as a regular List so that it is printed in full.\n    final ImmutableSet.Builder<Core.Exp> queriesToWrap = ImmutableSet.builder();\n    if (resolved.originalNode instanceof Ast.ValDecl\n        && coreDecl instanceof Core.NonRecValDecl) {\n      final Ast.ValDecl valDecl = (Ast.ValDecl) resolved.originalNode;\n      final Ast.ValBind valBind = valDecl.valBinds.get(0);\n      final Core.NonRecValDecl nonRecValDecl = (Core.NonRecValDecl) coreDecl;\n      if (valBind.exp.op == Op.FROM) {\n        queriesToWrap.add(nonRecValDecl.exp);\n      }\n    }\n\n    return compiler.compileStatement(env, coreDecl, skipPat,\n        queriesToWrap.build());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "CompiledStatement", "classes": []}, "docstring": "\nValidates and compiles a declaration, and compiles it to\ncode that can be evaluated by the interpreter.\n"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Core.@Nullable NamedPat]getSkipPat(Ast.Decl,Core.Decl)", "name": "getSkipPat", "arg_nums": 2, "params": [{"name": "decl", "type": "Ast.Decl"}, {"name": "coreDecl", "type": "Core.Decl"}], "return_type": "Core.@Nullable NamedPat", "signature": "private static Core.@Nullable NamedPat getSkipPat(Ast.Decl decl,\n      Core.Decl coreDecl)", "original_string": "  private static Core.@Nullable NamedPat getSkipPat(Ast.Decl decl,\n      Core.Decl coreDecl) {\n    if (coreDecl instanceof Core.NonRecValDecl\n        && decl instanceof Ast.ValDecl) {\n      final Core.NonRecValDecl nonRecValDecl = (Core.NonRecValDecl) coreDecl;\n      final Ast.ValDecl valDecl = (Ast.ValDecl) decl;\n      if (nonRecValDecl.pat.name.equals(\"it\")) {\n        if (valDecl.valBinds.size() == 1) {\n          final Ast.Pat pat = valDecl.valBinds.get(0).pat;\n          if (pat instanceof Ast.AsPat\n              && ((Ast.AsPat) pat).id.name.equals(\"it\")) {\n            return null;\n          }\n          if (pat instanceof Ast.IdPat\n              && ((Ast.IdPat) pat).name.equals(\"it\")) {\n            return null;\n          }\n        }\n        return nonRecValDecl.pat;\n      }\n    }\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Core.@Nullable NamedPat", "classes": []}, "docstring": " Returns a pattern that should not be printed, or null.\n\n<p>Consider the two declarations:\n\n<blockquote><pre>{@code\n  val it as (x, y) = (5, 6);\n  val (x, y) = (5, 6);\n}</pre></blockquote>\n\n<p>{@code coreDecl} is the same for both. For the first, we should print\n\n<blockquote><pre>{@code\n  val it = (5,6) : int * int\n  val x = 5 : int\n  val x = 6 : int\n}</pre></blockquote>\n\n<p>but for the second we should skip {@code it}, as follows:\n\n<blockquote><pre>{@code\n  val x = 5 : int\n  val x = 6 : int\n}</pre></blockquote>\n"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]checkPatternCoverage(TypeSystem,Core.Decl,Consumer<CompileException>)", "name": "checkPatternCoverage", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "decl", "type": "Core.Decl"}, {"name": "warningConsumer", "type": "Consumer<CompileException>"}], "return_type": "void", "signature": "private static void checkPatternCoverage(TypeSystem typeSystem,\n      Core.Decl decl, final Consumer<CompileException> warningConsumer)", "original_string": "  private static void checkPatternCoverage(TypeSystem typeSystem,\n      Core.Decl decl, final Consumer<CompileException> warningConsumer) {\n    final List<CompileException> errorList = new ArrayList<>();\n    decl.accept(new Visitor() {\n      @Override protected void visit(Core.Case kase) {\n        super.visit(kase);\n        checkPatternCoverage(typeSystem, kase, errorList::add,\n            warningConsumer);\n      }\n    });\n    if (!errorList.isEmpty()) {\n      throw errorList.get(0);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Checks for exhaustive and redundant patterns, and throws if there are\nerrors/warnings."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]checkPatternCoverage(TypeSystem,Core.Case,Consumer<CompileException>,Consumer<CompileException>)", "name": "checkPatternCoverage", "arg_nums": 4, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "kase", "type": "Core.Case"}, {"name": "errorConsumer", "type": "Consumer<CompileException>"}, {"name": "warningConsumer", "type": "Consumer<CompileException>"}], "return_type": "void", "signature": "private static void checkPatternCoverage(TypeSystem typeSystem,\n      Core.Case kase, Consumer<CompileException> errorConsumer,\n      Consumer<CompileException> warningConsumer)", "original_string": "  private static void checkPatternCoverage(TypeSystem typeSystem,\n      Core.Case kase, Consumer<CompileException> errorConsumer,\n      Consumer<CompileException> warningConsumer) {\n    final List<Core.Pat> prevPatList = new ArrayList<>();\n    final List<Core.Match> redundantMatchList = new ArrayList<>();\n    for (Core.Match match : kase.matchList) {\n      if (PatternCoverageChecker.isCoveredBy(typeSystem, prevPatList,\n          match.pat)) {\n        redundantMatchList.add(match);\n      }\n      prevPatList.add(match.pat);\n    }\n    final boolean exhaustive =\n        PatternCoverageChecker.isExhaustive(typeSystem, prevPatList);\n    if (!redundantMatchList.isEmpty()) {\n      final String message = exhaustive\n          ? \"match redundant\"\n          : \"match redundant and nonexhaustive\";\n      errorConsumer.accept(\n          new CompileException(message, false,\n              redundantMatchList.get(0).pos));\n    } else if (!exhaustive) {\n      warningConsumer.accept(\n          new CompileException(\"match nonexhaustive\", true, kase.pos));\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Ast.ValDecl]toValDecl(Ast.Exp)", "name": "toValDecl", "arg_nums": 1, "params": [{"name": "statement", "type": "Ast.Exp"}], "return_type": "Ast.ValDecl", "signature": "public static Ast.ValDecl toValDecl(Ast.Exp statement)", "original_string": "  public static Ast.ValDecl toValDecl(Ast.Exp statement) {\n    final Pos pos = statement.pos;\n    return ast.valDecl(pos, false,\n        ImmutableList.of(ast.valBind(pos, ast.idPat(pos, \"it\"), statement)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Ast.ValDecl", "classes": []}, "docstring": " Converts {@code e} to {@code val = e}."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Ast.ValDecl]toValDecl(AstNode)", "name": "toValDecl", "arg_nums": 1, "params": [{"name": "statement", "type": "AstNode"}], "return_type": "Ast.ValDecl", "signature": "public static Ast.ValDecl toValDecl(AstNode statement)", "original_string": "  public static Ast.ValDecl toValDecl(AstNode statement) {\n    return statement instanceof Ast.ValDecl ? (Ast.ValDecl) statement\n        : toValDecl((Ast.Exp) statement);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Ast.ValDecl", "classes": []}, "docstring": " Converts an expression or value declaration to a value declaration."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Ast.Decl]toDecl(AstNode)", "name": "toDecl", "arg_nums": 1, "params": [{"name": "statement", "type": "AstNode"}], "return_type": "Ast.Decl", "signature": "public static Ast.Decl toDecl(AstNode statement)", "original_string": "  public static Ast.Decl toDecl(AstNode statement) {\n    return statement instanceof Ast.Decl ? (Ast.Decl) statement\n        : toValDecl((Ast.Exp) statement);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Ast.Decl", "classes": []}, "docstring": " Converts an expression or declaration to a declaration."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[Core.Exp]toExp(Core.NonRecValDecl)", "name": "toExp", "arg_nums": 1, "params": [{"name": "decl", "type": "Core.NonRecValDecl"}], "return_type": "Core.Exp", "signature": "public static Core.Exp toExp(Core.NonRecValDecl decl)", "original_string": "  public static Core.Exp toExp(Core.NonRecValDecl decl) {\n    return decl.exp;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": " Converts {@code val = e} to {@code e};\nthe converse of {@link #toValDecl(Ast.Exp)}."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindPattern(TypeSystem,List<Binding>,Core.DatatypeDecl)", "name": "bindPattern", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "datatypeDecl", "type": "Core.DatatypeDecl"}], "return_type": "void", "signature": "static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.DatatypeDecl datatypeDecl)", "original_string": "  static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.DatatypeDecl datatypeDecl) {\n    datatypeDecl.accept(binding(typeSystem, bindings));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindPattern(TypeSystem,List<Binding>,Core.ValDecl)", "name": "bindPattern", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "valDecl", "type": "Core.ValDecl"}], "return_type": "void", "signature": "static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.ValDecl valDecl)", "original_string": "  static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.ValDecl valDecl) {\n    valDecl.forEachBinding((pat, exp, pos) -> {\n      if (pat instanceof Core.IdPat) {\n        bindings.add(Binding.of(pat, exp));\n      }\n    });\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Richer than {@link #bindPattern(TypeSystem, List, Core.Pat)} because\nwe have the expression."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindPattern(TypeSystem,List<Binding>,Core.Pat)", "name": "bindPattern", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "pat", "type": "Core.Pat"}], "return_type": "void", "signature": "static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.Pat pat)", "original_string": "  static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.Pat pat) {\n    pat.accept(binding(typeSystem, bindings));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindPattern(TypeSystem,List<Binding>,Core.NamedPat)", "name": "bindPattern", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "namedPat", "type": "Core.NamedPat"}], "return_type": "void", "signature": "static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.NamedPat namedPat)", "original_string": "  static void bindPattern(TypeSystem typeSystem, List<Binding> bindings,\n      Core.NamedPat namedPat) {\n    bindings.add(Binding.of(namedPat));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]bindDataType(TypeSystem,List<Binding>,DataType)", "name": "bindDataType", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "dataType", "type": "DataType"}], "return_type": "void", "signature": "public static void bindDataType(TypeSystem typeSystem, List<Binding> bindings,\n      DataType dataType)", "original_string": "  public static void bindDataType(TypeSystem typeSystem, List<Binding> bindings,\n      DataType dataType) {\n    dataType.typeConstructors.keySet().forEach(name ->\n        bindings.add(typeSystem.bindTyCon(dataType, name)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[PatternBinder]binding(TypeSystem,List<Binding>)", "name": "binding", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "bindings", "type": "List<Binding>"}], "return_type": "PatternBinder", "signature": "static PatternBinder binding(TypeSystem typeSystem, List<Binding> bindings)", "original_string": "  static PatternBinder binding(TypeSystem typeSystem, List<Binding> bindings) {\n    return new PatternBinder(typeSystem, bindings);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "PatternBinder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles.[void]acceptBinding(TypeSystem,Core.Pat,List<Binding>)", "name": "acceptBinding", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "pat", "type": "Core.Pat"}, {"name": "bindings", "type": "List<Binding>"}], "return_type": "void", "signature": "public static void acceptBinding(TypeSystem typeSystem, Core.Pat pat,\n      List<Binding> bindings)", "original_string": "  public static void acceptBinding(TypeSystem typeSystem, Core.Pat pat,\n      List<Binding> bindings) {\n    pat.accept(binding(typeSystem, bindings));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiles.java", "class_name": "Compiles", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiles.java.Compiles", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Visits a pattern, adding bindings to a list.\n\n<p>If the pattern is an {@link net.hydromatic.morel.ast.Core.IdPat},\ndon't use this method: just bind directly."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Macro.java.Macro.[Core.Exp]expand(TypeSystem,Environment,Type)", "name": "expand", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "argType", "type": "Type"}], "return_type": "Core.Exp", "signature": "Core.Exp expand(TypeSystem typeSystem, Environment env, Type argType)", "original_string": "  Core.Exp expand(TypeSystem typeSystem, Environment env, Type argType);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Macro.java", "class_name": "Macro", "class_uri": "src/main/java/net/hydromatic/morel/compile/Macro.java.Macro", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[]Compiler(TypeSystem)", "name": "Compiler", "arg_nums": 1, "params": [{"name": "typeSystem", "type": "TypeSystem"}], "return_type": "", "signature": "public Compiler(TypeSystem typeSystem)", "original_string": "  public Compiler(TypeSystem typeSystem) {\n    this.typeSystem = requireNonNull(typeSystem, \"typeSystem\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[CompiledStatement]compileStatement(Environment,Core.Decl,Core.@Nullable NamedPat,Set<Core.Exp>)", "name": "compileStatement", "arg_nums": 4, "params": [{"name": "env", "type": "Environment"}, {"name": "decl", "type": "Core.Decl"}, {"name": "skipPat", "type": "Core.@Nullable NamedPat"}, {"name": "queriesToWrap", "type": "Set<Core.Exp>"}], "return_type": "CompiledStatement", "signature": "CompiledStatement compileStatement(Environment env, Core.Decl decl,\n      Core.@Nullable NamedPat skipPat, Set<Core.Exp> queriesToWrap)", "original_string": "  CompiledStatement compileStatement(Environment env, Core.Decl decl,\n      Core.@Nullable NamedPat skipPat, Set<Core.Exp> queriesToWrap) {\n    final List<Code> matchCodes = new ArrayList<>();\n    final List<Binding> bindings = new ArrayList<>();\n    final List<Action> actions = new ArrayList<>();\n    final Context cx = Context.of(env);\n    compileDecl(cx, decl, skipPat, queriesToWrap, matchCodes, bindings,\n        actions);\n    final Type type = decl instanceof Core.NonRecValDecl\n        ? ((Core.NonRecValDecl) decl).pat.type\n        : PrimitiveType.UNIT;\n    final CalciteFunctions.Context context = createContext(env);\n\n    return new CompiledStatement() {\n      public Type getType() {\n        return type;\n      }\n\n      public void eval(Session session, Environment env,\n          Consumer<String> outLines, Consumer<Binding> outBindings) {\n        ThreadLocals.let(CalciteFunctions.THREAD_ENV, context,\n            () -> {\n              final EvalEnv evalEnv = Codes.emptyEnvWith(session, env);\n              for (Action action : actions) {\n                action.apply(outLines, outBindings, evalEnv);\n              }\n            });\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "CompiledStatement", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[CalciteFunctions.Context]createContext(Environment)", "name": "createContext", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "CalciteFunctions.Context", "signature": "protected CalciteFunctions.Context createContext(Environment env)", "original_string": "  protected CalciteFunctions.Context createContext(Environment env) {\n    final Session dummySession = new Session(ImmutableMap.of());\n    return new CalciteFunctions.Context(dummySession, env, typeSystem, null);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "CalciteFunctions.Context", "classes": []}, "docstring": " Creates a context.\n\n<p>The whole way we provide compilation environments (including\nEnvironment) to generated code is a mess:\n<ul>\n<li>This method is protected so that CalciteCompiler can override and get\na Calcite type factory.\n<li>User-defined functions should have a 'prepare' phase, where they use\na type factory and environment, that is distinct from the 'eval' phase.\n<li>We should pass compile and runtime environments via parameters, not\nthread-locals.\n<li>The dummy session is there because session is mandatory, but we have\nnot created a session yet. Lifecycle confusion.\n</ul>"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compile(Environment,Core.Exp)", "name": "compile", "arg_nums": 2, "params": [{"name": "env", "type": "Environment"}, {"name": "expression", "type": "Core.Exp"}], "return_type": "Code", "signature": "public final Code compile(Environment env, Core.Exp expression)", "original_string": "  public final Code compile(Environment env, Core.Exp expression) {\n    return compile(Context.of(env), expression);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileArg(Context,Core.Exp)", "name": "compileArg", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "expression", "type": "Core.Exp"}], "return_type": "Code", "signature": "public Code compileArg(Context cx, Core.Exp expression)", "original_string": "  public Code compileArg(Context cx, Core.Exp expression) {\n    return compile(cx, expression);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Compiles the argument to \"apply\"."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[List<Code>]compileArgs(Context,Iterable<? extends Core.Exp>)", "name": "compileArgs", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "expressions", "type": "Iterable<? extends Core.Exp>"}], "return_type": "List<Code>", "signature": "public List<Code> compileArgs(Context cx,\n      Iterable<? extends Core.Exp> expressions)", "original_string": "  public List<Code> compileArgs(Context cx,\n      Iterable<? extends Core.Exp> expressions) {\n    return transformEager(expressions, e -> compile(cx, e));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Code>", "classes": []}, "docstring": " Compiles the tuple arguments to \"apply\"."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compile(Context,Core.Exp)", "name": "compile", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "expression", "type": "Core.Exp"}], "return_type": "Code", "signature": "public Code compile(Context cx, Core.Exp expression)", "original_string": "  public Code compile(Context cx, Core.Exp expression) {\n    final Core.Literal literal;\n    final Code argCode;\n    final List<Code> codes;\n    switch (expression.op) {\n    case BOOL_LITERAL:\n      literal = (Core.Literal) expression;\n      final Boolean boolValue = literal.unwrap(Boolean.class);\n      return Codes.constant(boolValue);\n\n    case CHAR_LITERAL:\n      literal = (Core.Literal) expression;\n      final Character charValue = literal.unwrap(Character.class);\n      return Codes.constant(charValue);\n\n    case INT_LITERAL:\n      literal = (Core.Literal) expression;\n      return Codes.constant(literal.unwrap(Integer.class));\n\n    case REAL_LITERAL:\n      literal = (Core.Literal) expression;\n      return Codes.constant(literal.unwrap(Float.class));\n\n    case STRING_LITERAL:\n      literal = (Core.Literal) expression;\n      final String stringValue = literal.unwrap(String.class);\n      return Codes.constant(stringValue);\n\n    case UNIT_LITERAL:\n      return Codes.constant(Unit.INSTANCE);\n\n    case FN_LITERAL:\n      literal = (Core.Literal) expression;\n      final BuiltIn builtIn = literal.unwrap(BuiltIn.class);\n      return Codes.constant(Codes.BUILT_IN_VALUES.get(builtIn));\n\n    case INTERNAL_LITERAL:\n    case VALUE_LITERAL:\n      literal = (Core.Literal) expression;\n      return Codes.constant(literal.unwrap(Object.class));\n\n    case LET:\n      return compileLet(cx, (Core.Let) expression);\n\n    case LOCAL:\n      return compileLocal(cx, (Core.Local) expression);\n\n    case FN:\n      final Core.Fn fn = (Core.Fn) expression;\n      return compileMatchList(cx,\n          ImmutableList.of(core.match(fn.pos, fn.idPat, fn.exp)));\n\n    case CASE:\n      final Core.Case case_ = (Core.Case) expression;\n      final Code matchCode = compileMatchList(cx, case_.matchList);\n      argCode = compile(cx, case_.exp);\n      return Codes.apply(matchCode, argCode);\n\n    case RECORD_SELECTOR:\n      final Core.RecordSelector recordSelector = (Core.RecordSelector) expression;\n      return Codes.nth(recordSelector.slot).asCode();\n\n    case APPLY:\n      return compileApply(cx, (Core.Apply) expression);\n\n    case FROM:\n      return compileFrom(cx, (Core.From) expression);\n\n    case ID:\n      final Core.Id id = (Core.Id) expression;\n      return compileFieldName(cx, id.idPat);\n\n    case TUPLE:\n      final Core.Tuple tuple = (Core.Tuple) expression;\n      codes = new ArrayList<>();\n      for (Core.Exp arg : tuple.args) {\n        codes.add(compile(cx, arg));\n      }\n      return Codes.tuple(codes);\n\n    default:\n      throw new AssertionError(\"op not handled: \" + expression.op);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileFieldName(Context,Core.NamedPat)", "name": "compileFieldName", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "idPat", "type": "Core.NamedPat"}], "return_type": "Code", "signature": "private Code compileFieldName(Context cx, Core.NamedPat idPat)", "original_string": "  private Code compileFieldName(Context cx, Core.NamedPat idPat) {\n    final Binding binding = cx.env.getOpt(idPat.name);\n    if (binding != null && binding.value instanceof Code) {\n      return (Code) binding.value;\n    }\n    return Codes.get(idPat.name);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileApply(Context,Core.Apply)", "name": "compileApply", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "apply", "type": "Core.Apply"}], "return_type": "Code", "signature": "protected Code compileApply(Context cx, Core.Apply apply)", "original_string": "  protected Code compileApply(Context cx, Core.Apply apply) {\n    // Is this is a call to a built-in operator?\n    switch (apply.fn.op) {\n    case FN_LITERAL:\n      final BuiltIn builtIn = ((Core.Literal) apply.fn).unwrap(BuiltIn.class);\n      return compileCall(cx, builtIn, apply.arg, apply.pos);\n    }\n    final Code argCode = compileArg(cx, apply.arg);\n    final Type argType = apply.arg.type;\n    final Applicable fnValue =\n        compileApplicable(cx, apply.fn, argType, apply.pos);\n    if (fnValue != null) {\n      return finishCompileApply(cx, fnValue, argCode, argType);\n    }\n    final Code fnCode = compile(cx, apply.fn);\n    return finishCompileApply(cx, fnCode, argCode, argType);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]finishCompileApply(Context,Applicable,Code,Type)", "name": "finishCompileApply", "arg_nums": 4, "params": [{"name": "cx", "type": "Context"}, {"name": "fnValue", "type": "Applicable"}, {"name": "argCode", "type": "Code"}, {"name": "argType", "type": "Type"}], "return_type": "Code", "signature": "protected Code finishCompileApply(Context cx, Applicable fnValue,\n      Code argCode, Type argType)", "original_string": "  protected Code finishCompileApply(Context cx, Applicable fnValue,\n      Code argCode, Type argType) {\n    return Codes.apply(fnValue, argCode);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]finishCompileApply(Context,Code,Code,Type)", "name": "finishCompileApply", "arg_nums": 4, "params": [{"name": "cx", "type": "Context"}, {"name": "fnCode", "type": "Code"}, {"name": "argCode", "type": "Code"}, {"name": "argType", "type": "Type"}], "return_type": "Code", "signature": "protected Code finishCompileApply(Context cx, Code fnCode, Code argCode,\n      Type argType)", "original_string": "  protected Code finishCompileApply(Context cx, Code fnCode, Code argCode,\n      Type argType) {\n    return Codes.apply(fnCode, argCode);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileFrom(Context,Core.From)", "name": "compileFrom", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "from", "type": "Core.From"}], "return_type": "Code", "signature": "protected Code compileFrom(Context cx, Core.From from)", "original_string": "  protected Code compileFrom(Context cx, Core.From from) {\n    Supplier<Codes.RowSink> rowSinkFactory =\n        createRowSinkFactory(cx, ImmutableList.of(), from.steps,\n            from.type().elementType);\n    return Codes.from(rowSinkFactory);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Supplier<Codes.RowSink>]createRowSinkFactory(Context,ImmutableList<Binding>,List<Core.FromStep>,Type)", "name": "createRowSinkFactory", "arg_nums": 4, "params": [{"name": "cx0", "type": "Context"}, {"name": "bindings", "type": "ImmutableList<Binding>"}, {"name": "steps", "type": "List<Core.FromStep>"}, {"name": "elementType", "type": "Type"}], "return_type": "Supplier<Codes.RowSink>", "signature": "protected Supplier<Codes.RowSink> createRowSinkFactory(Context cx0,\n      ImmutableList<Binding> bindings, List<Core.FromStep> steps,\n      Type elementType)", "original_string": "  protected Supplier<Codes.RowSink> createRowSinkFactory(Context cx0,\n      ImmutableList<Binding> bindings, List<Core.FromStep> steps,\n      Type elementType) {\n    final Context cx = cx0.bindAll(bindings);\n    if (steps.isEmpty()) {\n      final List<String> fieldNames =\n          bindings.stream().map(b -> b.id.name).sorted()\n              .collect(toImmutableList());\n      final Code code;\n      if (fieldNames.size() == 1\n          && getOnlyElement(bindings).id.type.equals(elementType)) {\n        code = Codes.get(fieldNames.get(0));\n      } else {\n        code = Codes.getTuple(fieldNames);\n      }\n      return () -> Codes.collectRowSink(code);\n    }\n    final Core.FromStep firstStep = steps.get(0);\n    final Supplier<Codes.RowSink> nextFactory =\n        createRowSinkFactory(cx, firstStep.bindings, skip(steps),\n            elementType);\n    switch (firstStep.op) {\n    case SCAN:\n      final Core.Scan scan = (Core.Scan) firstStep;\n      final Code code = compile(cx, scan.exp);\n      final Code conditionCode = compile(cx, scan.condition);\n      return () -> Codes.scanRowSink(firstStep.op, scan.pat, code,\n          conditionCode, nextFactory.get());\n\n    case WHERE:\n      final Core.Where where = (Core.Where) firstStep;\n      final Code filterCode = compile(cx, where.exp);\n      return () -> Codes.whereRowSink(filterCode, nextFactory.get());\n\n    case SKIP:\n      final Core.Skip skip = (Core.Skip) firstStep;\n      final Code skipCode = compile(cx, skip.exp);\n      return () -> Codes.skipRowSink(skipCode, nextFactory.get());\n\n    case TAKE:\n      final Core.Take take = (Core.Take) firstStep;\n      final Code takeCode = compile(cx, take.exp);\n      return () -> Codes.takeRowSink(takeCode, nextFactory.get());\n\n    case YIELD:\n      final Core.Yield yield = (Core.Yield) firstStep;\n      if (steps.size() == 1) {\n        // Last step. Use a Collect row sink, and we're done.\n        // Note that we don't use nextFactory.\n        final Code yieldCode = compile(cx, yield.exp);\n        return () -> Codes.collectRowSink(yieldCode);\n      } else if (yield.exp instanceof Core.Tuple) {\n        final Core.Tuple tuple = (Core.Tuple) yield.exp;\n        final RecordLikeType recordType = tuple.type();\n        final ImmutableSortedMap.Builder<String, Code> mapCodes =\n            ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n        forEach(tuple.args, recordType.argNameTypes().keySet(), (exp, name) ->\n            mapCodes.put(name, compile(cx, exp)));\n        return () -> Codes.yieldRowSink(mapCodes.build(), nextFactory.get());\n      } else {\n        final ImmutableSortedMap.Builder<String, Code> mapCodes =\n            ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n        final Binding binding = yield.bindings.get(0);\n        mapCodes.put(binding.id.name, compile(cx, yield.exp));\n        return () -> Codes.yieldRowSink(mapCodes.build(), nextFactory.get());\n      }\n\n    case ORDER:\n      final Core.Order order = (Core.Order) firstStep;\n      final PairList<Code, Boolean> codes = PairList.of();\n      order.orderItems.forEach(e ->\n          codes.add(compile(cx, e.exp), e.direction == DESC));\n      return () -> Codes.orderRowSink(codes, bindings, nextFactory.get());\n\n    case GROUP:\n      final Core.Group group = (Core.Group) firstStep;\n      final ImmutableList.Builder<Code> groupCodesB = ImmutableList.builder();\n      for (Core.Exp exp : group.groupExps.values()) {\n        groupCodesB.add(compile(cx, exp));\n      }\n      final ImmutableList.Builder<Code> valueCodesB = ImmutableList.builder();\n      final SortedMap<String, Binding> bindingMap = sortedBindingMap(bindings);\n      for (Binding binding : bindingMap.values()) {\n        valueCodesB.add(compile(cx, core.id(binding.id)));\n      }\n      final ImmutableList<String> names =\n          ImmutableList.copyOf(bindingMap.keySet());\n      final ImmutableList.Builder<Applicable> aggregateCodesB =\n          ImmutableList.builder();\n      for (Core.Aggregate aggregate : group.aggregates.values()) {\n        final Code argumentCode;\n        final Type argumentType;\n        if (aggregate.argument == null) {\n          final PairList<String, Type> argNameTypes = PairList.of();\n          bindings.forEach(b -> argNameTypes.add(b.id.name, b.id.type));\n          argumentType = typeSystem.recordOrScalarType(argNameTypes);\n          argumentCode = null;\n        } else {\n          argumentType = aggregate.argument.type;\n          argumentCode = compile(cx, aggregate.argument);\n        }\n        final Applicable aggregateApplicable =\n            compileApplicable(cx, aggregate.aggregate,\n                typeSystem.listType(argumentType), aggregate.pos);\n        final Code aggregateCode;\n        if (aggregateApplicable == null) {\n          aggregateCode = compile(cx, aggregate.aggregate);\n        } else {\n          aggregateCode = aggregateApplicable.asCode();\n        }\n        aggregateCodesB.add(\n            Codes.aggregate(cx.env, aggregateCode, names, argumentCode));\n      }\n      final ImmutableList<Code> groupCodes = groupCodesB.build();\n      final Code keyCode = Codes.tuple(groupCodes);\n      final ImmutableList<Applicable> aggregateCodes = aggregateCodesB.build();\n      final ImmutableList<String> outNames = bindingNames(firstStep.bindings);\n      final ImmutableList<String> keyNames =\n          outNames.subList(0, group.groupExps.size());\n      return () -> Codes.groupRowSink(keyCode, aggregateCodes, names, keyNames,\n          outNames, nextFactory.get());\n\n    default:\n      throw new AssertionError(\"unknown step type \" + firstStep.op);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Supplier<Codes.RowSink>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[ImmutableSortedMap<String, Binding>]sortedBindingMap(Iterable<Binding>)", "name": "sortedBindingMap", "arg_nums": 1, "params": [{"name": "bindings", "type": "Iterable<Binding>"}], "return_type": "ImmutableSortedMap<String, Binding>", "signature": "private ImmutableSortedMap<String, Binding> sortedBindingMap(\n      Iterable<Binding> bindings)", "original_string": "  private ImmutableSortedMap<String, Binding> sortedBindingMap(\n      Iterable<Binding> bindings) {\n    final ImmutableSortedMap.Builder<String, Binding> b =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    bindings.forEach(binding -> b.put(binding.id.name, binding));\n    return b.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ImmutableSortedMap<String, Binding>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[ImmutableList<String>]bindingNames(List<Binding>)", "name": "bindingNames", "arg_nums": 1, "params": [{"name": "bindings", "type": "List<Binding>"}], "return_type": "ImmutableList<String>", "signature": "private ImmutableList<String> bindingNames(List<Binding> bindings)", "original_string": "  private ImmutableList<String> bindingNames(List<Binding> bindings) {\n    return transformEager(bindings, b -> b.id.name);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ImmutableList<String>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Applicable]compileApplicable(Context,Core.Exp,Type,Pos)", "name": "compileApplicable", "arg_nums": 4, "params": [{"name": "cx", "type": "Context"}, {"name": "fn", "type": "Core.Exp"}, {"name": "argType", "type": "Type"}, {"name": "pos", "type": "Pos"}], "return_type": "Applicable", "signature": "private Applicable compileApplicable(Context cx, Core.Exp fn, Type argType,\n      Pos pos)", "original_string": "  private Applicable compileApplicable(Context cx, Core.Exp fn, Type argType,\n      Pos pos) {\n    switch (fn.op) {\n    case FN_LITERAL:\n      final BuiltIn builtIn = ((Core.Literal) fn).unwrap(BuiltIn.class);\n      final Object o = Codes.BUILT_IN_VALUES.get(builtIn);\n      return toApplicable(cx, o, argType, pos);\n\n    case VALUE_LITERAL:\n      final Core.Literal literal = (Core.Literal) fn;\n      return toApplicable(cx, literal.unwrap(Object.class), argType, pos);\n\n    case ID:\n      final Binding binding = cx.env.getOpt(((Core.Id) fn).idPat);\n      if (binding == null\n          || binding.value instanceof LinkCode\n          || binding.value == Unit.INSTANCE) {\n        return null;\n      }\n      return toApplicable(cx, binding.value, argType, pos);\n\n    case RECORD_SELECTOR:\n      final Core.RecordSelector recordSelector = (Core.RecordSelector) fn;\n      return Codes.nth(recordSelector.slot);\n\n    default:\n      return null;\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": " Compiles a function value to an {@link Applicable}, if possible, or\nreturns null."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Applicable]toApplicable(Context,Object,Type,Pos)", "name": "toApplicable", "arg_nums": 4, "params": [{"name": "cx", "type": "Context"}, {"name": "o", "type": "Object"}, {"name": "argType", "type": "Type"}, {"name": "pos", "type": "Pos"}], "return_type": "Applicable", "signature": "private @Nullable Applicable toApplicable(Context cx, Object o,\n      Type argType, Pos pos)", "original_string": "  private @Nullable Applicable toApplicable(Context cx, Object o,\n      Type argType, Pos pos) {\n    if (o instanceof Applicable) {\n      final Applicable applicable = (Applicable) o;\n      if (applicable instanceof Codes.Positioned) {\n        return ((Codes.Positioned) applicable).withPos(pos);\n      }\n      return applicable;\n    }\n    if (o instanceof Macro) {\n      final Macro value = (Macro) o;\n      final Core.Exp exp = value.expand(typeSystem, cx.env, argType);\n      switch (exp.op) {\n      case FN_LITERAL:\n        final Core.Literal literal = (Core.Literal) exp;\n        final BuiltIn builtIn = literal.unwrap(BuiltIn.class);\n        return (Applicable) Codes.BUILT_IN_VALUES.get(builtIn);\n      }\n      final Code code = compile(cx, exp);\n      return new Applicable() {\n        @Override public Describer describe(Describer describer) {\n          return code.describe(describer);\n        }\n\n        @Override public Object apply(EvalEnv evalEnv, Object arg) {\n          return code.eval(evalEnv);\n        }\n      };\n    }\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["private"], "comments": [], "return_type": "Applicable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileLet(Context,Core.Let)", "name": "compileLet", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "let", "type": "Core.Let"}], "return_type": "Code", "signature": "private Code compileLet(Context cx, Core.Let let)", "original_string": "  private Code compileLet(Context cx, Core.Let let) {\n    final List<Code> matchCodes = new ArrayList<>();\n    final List<Binding> bindings = new ArrayList<>();\n    compileValDecl(cx, let.decl, null, ImmutableSet.of(), matchCodes, bindings,\n        null);\n    Context cx2 = cx.bindAll(bindings);\n    final Code resultCode = compile(cx2, let.exp);\n    return finishCompileLet(cx2, matchCodes, resultCode, let.type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]finishCompileLet(Context,List<Code>,Code,Type)", "name": "finishCompileLet", "arg_nums": 4, "params": [{"name": "cx", "type": "Context"}, {"name": "matchCodes", "type": "List<Code>"}, {"name": "resultCode", "type": "Code"}, {"name": "resultType", "type": "Type"}], "return_type": "Code", "signature": "protected Code finishCompileLet(Context cx, List<Code> matchCodes,\n      Code resultCode, Type resultType)", "original_string": "  protected Code finishCompileLet(Context cx, List<Code> matchCodes,\n      Code resultCode, Type resultType) {\n    return Codes.let(matchCodes, resultCode);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileLocal(Context,Core.Local)", "name": "compileLocal", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "local", "type": "Core.Local"}], "return_type": "Code", "signature": "private Code compileLocal(Context cx, Core.Local local)", "original_string": "  private Code compileLocal(Context cx, Core.Local local) {\n    final List<Binding> bindings = new ArrayList<>();\n    compileDatatypeDecl(ImmutableList.of(local.dataType), bindings, null);\n    Context cx2 = cx.bindAll(bindings);\n    return compile(cx2, local.exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]compileDecl(Context,Core.Decl,Core.@Nullable NamedPat,Set<Core.Exp>,List<Code>,List<Binding>,List<Action>)", "name": "compileDecl", "arg_nums": 7, "params": [{"name": "cx", "type": "Context"}, {"name": "decl", "type": "Core.Decl"}, {"name": "skipPat", "type": "Core.@Nullable NamedPat"}, {"name": "queriesToWrap", "type": "Set<Core.Exp>"}, {"name": "matchCodes", "type": "List<Code>"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "actions", "type": "List<Action>"}], "return_type": "void", "signature": "void compileDecl(Context cx, Core.Decl decl, Core.@Nullable NamedPat skipPat,\n      Set<Core.Exp> queriesToWrap, List<Code> matchCodes,\n      List<Binding> bindings, List<Action> actions)", "original_string": "  void compileDecl(Context cx, Core.Decl decl, Core.@Nullable NamedPat skipPat,\n      Set<Core.Exp> queriesToWrap, List<Code> matchCodes,\n      List<Binding> bindings, List<Action> actions) {\n    switch (decl.op) {\n    case VAL_DECL:\n    case REC_VAL_DECL:\n      final Core.ValDecl valDecl = (Core.ValDecl) decl;\n      compileValDecl(cx, valDecl, skipPat, queriesToWrap, matchCodes, bindings,\n          actions);\n      break;\n\n    case DATATYPE_DECL:\n      final Core.DatatypeDecl datatypeDecl = (Core.DatatypeDecl) decl;\n      compileDatatypeDecl(datatypeDecl.dataTypes, bindings, actions);\n      break;\n\n    default:\n      throw new AssertionError(\"unknown \" + decl.op + \" [\" + decl + \"]\");\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]compileDatatypeDecl(List<DataType>,List<Binding>,List<Action>)", "name": "compileDatatypeDecl", "arg_nums": 3, "params": [{"name": "dataTypes", "type": "List<DataType>"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "actions", "type": "List<Action>"}], "return_type": "void", "signature": "private void compileDatatypeDecl(List<DataType> dataTypes,\n      List<Binding> bindings, List<Action> actions)", "original_string": "  private void compileDatatypeDecl(List<DataType> dataTypes,\n      List<Binding> bindings, List<Action> actions) {\n    for (DataType dataType : dataTypes) {\n      final List<Binding> newBindings = new TailList<>(bindings);\n      dataType.typeConstructors.keySet().forEach(name ->\n          bindings.add(typeSystem.bindTyCon(dataType, name)));\n      if (actions != null) {\n        final List<Binding> immutableBindings =\n            ImmutableList.copyOf(newBindings);\n        actions.add((outLines, outBindings, evalEnv) -> {\n          String line = dataType.describe(new StringBuilder()).toString();\n          outLines.accept(line);\n          immutableBindings.forEach(outBindings);\n        });\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileCall(Context,BuiltIn,Core.Exp,Pos)", "name": "compileCall", "arg_nums": 4, "params": [{"name": "cx", "type": "Context"}, {"name": "builtIn", "type": "BuiltIn"}, {"name": "arg", "type": "Core.Exp"}, {"name": "pos", "type": "Pos"}], "return_type": "Code", "signature": "private Code compileCall(Context cx, BuiltIn builtIn, Core.Exp arg, Pos pos)", "original_string": "  private Code compileCall(Context cx, BuiltIn builtIn, Core.Exp arg, Pos pos) {\n    final List<Code> argCodes;\n    switch (builtIn) {\n    case Z_ANDALSO:\n      // Argument for a built-in infix operator such as \"andalso\" is always a\n      // tuple; operators are never curried, nor do they evaluate an expression\n      // to yield the tuple of arguments.\n      argCodes = compileArgs(cx, ((Core.Tuple) arg).args);\n      return Codes.andAlso(argCodes.get(0), argCodes.get(1));\n    case Z_ORELSE:\n      argCodes = compileArgs(cx, ((Core.Tuple) arg).args);\n      return Codes.orElse(argCodes.get(0), argCodes.get(1));\n    case Z_LIST:\n      argCodes = compileArgs(cx, ((Core.Tuple) arg).args);\n      return Codes.list(argCodes);\n    default:\n      final Object o0 = Codes.BUILT_IN_VALUES.get(builtIn);\n      final Object o;\n      if (o0 instanceof Codes.Positioned) {\n        o = ((Codes.Positioned) o0).withPos(pos);\n      } else {\n        o = o0;\n      }\n      if (o instanceof Applicable) {\n        final Code argCode = compile(cx, arg);\n        if (argCode instanceof Codes.TupleCode) {\n          final Codes.TupleCode tupleCode = (Codes.TupleCode) argCode;\n          if (tupleCode.codes.size() == 2\n              && o instanceof Applicable2) {\n            //noinspection rawtypes\n            return Codes.apply2((Applicable2) o,\n                tupleCode.codes.get(0),\n                tupleCode.codes.get(1));\n          }\n          if (tupleCode.codes.size() == 3\n              && o instanceof Applicable3) {\n            //noinspection rawtypes\n            return Codes.apply3((Applicable3) o,\n                tupleCode.codes.get(0),\n                tupleCode.codes.get(1),\n                tupleCode.codes.get(2));\n          }\n        }\n        return Codes.apply((Applicable) o, argCode);\n      }\n      throw new AssertionError(\"unknown \" + builtIn);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Code", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[Code]compileMatchList(Context,List<Core.Match>)", "name": "compileMatchList", "arg_nums": 2, "params": [{"name": "cx", "type": "Context"}, {"name": "matchList", "type": "List<Core.Match>"}], "return_type": "Code", "signature": "private Code compileMatchList(Context cx,\n      List<Core.Match> matchList)", "original_string": "  private Code compileMatchList(Context cx,\n      List<Core.Match> matchList) {\n    final PairList<Core.Pat, Code> patCodes = PairList.of();\n    matchList.forEach(match -> compileMatch(cx, match, patCodes::add));\n    return new MatchCode(patCodes.immutable(), getLast(matchList).pos);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Compiles a {@code match} expression.\n\n@param cx Compile context\n@param matchList List of Match\n@return Code for match\n"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]compileMatch(Context,Core.Match,BiConsumer<Core.Pat, Code>)", "name": "compileMatch", "arg_nums": 3, "params": [{"name": "cx", "type": "Context"}, {"name": "match", "type": "Core.Match"}, {"name": "consumer", "type": "BiConsumer<Core.Pat, Code>"}], "return_type": "void", "signature": "private void compileMatch(Context cx, Core.Match match,\n      BiConsumer<Core.Pat, Code> consumer)", "original_string": "  private void compileMatch(Context cx, Core.Match match,\n      BiConsumer<Core.Pat, Code> consumer) {\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.bindPattern(typeSystem, bindings, match.pat);\n    final Code code = compile(cx.bindAll(bindings), match.exp);\n    consumer.accept(match.pat, code);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]compileValDecl(Context,Core.ValDecl,Core.@Nullable Pat,Set<Core.Exp>,List<Code>,List<Binding>,List<Action>)", "name": "compileValDecl", "arg_nums": 7, "params": [{"name": "cx", "type": "Context"}, {"name": "valDecl", "type": "Core.ValDecl"}, {"name": "skipPat", "type": "Core.@Nullable Pat"}, {"name": "queriesToWrap", "type": "Set<Core.Exp>"}, {"name": "matchCodes", "type": "List<Code>"}, {"name": "bindings", "type": "List<Binding>"}, {"name": "actions", "type": "List<Action>"}], "return_type": "void", "signature": "private void compileValDecl(Context cx, Core.ValDecl valDecl,\n      Core.@Nullable Pat skipPat,\n      Set<Core.Exp> queriesToWrap, List<Code> matchCodes,\n      List<Binding> bindings, List<Action> actions)", "original_string": "  private void compileValDecl(Context cx, Core.ValDecl valDecl,\n      Core.@Nullable Pat skipPat,\n      Set<Core.Exp> queriesToWrap, List<Code> matchCodes,\n      List<Binding> bindings, List<Action> actions) {\n    Compiles.bindPattern(typeSystem, bindings, valDecl);\n    final List<Binding> newBindings = new TailList<>(bindings);\n    final Map<Core.NamedPat, LinkCode> linkCodes = new HashMap<>();\n    if (valDecl.op == Op.REC_VAL_DECL) {\n      valDecl.forEachBinding((pat, exp, pos) -> {\n        final LinkCode linkCode = new LinkCode();\n        linkCodes.put(pat, linkCode);\n        bindings.add(Binding.of(pat, linkCode));\n      });\n    }\n\n    final Context cx1 = cx.bindAll(newBindings);\n    valDecl.forEachBinding((pat, exp, pos) -> {\n      // Using 'compileArg' rather than 'compile' encourages CalciteCompiler\n      // to use a pure Calcite implementation if possible, and has no effect\n      // in the basic Compiler.\n      final Code code0 = compileArg(cx1, exp);\n      final Code code =\n          queriesToWrap.contains(exp) ? Codes.wrapRelList(code0) : code0;\n      if (!linkCodes.isEmpty()) {\n        link(linkCodes, pat, code);\n      }\n      matchCodes.add(new MatchCode(ImmutablePairList.of(pat, code), pos));\n\n      if (actions != null) {\n        final Type type0 = exp.type;\n        final Type type = typeSystem.ensureClosed(type0);\n        actions.add((outLines, outBindings, evalEnv) -> {\n          final Session session = (Session) evalEnv.getOpt(EvalEnv.SESSION);\n          final StringBuilder buf = new StringBuilder();\n          final List<String> outs = new ArrayList<>();\n          try {\n            final Object o = code.eval(evalEnv);\n            final Map<Core.NamedPat, Object> pairs = new LinkedHashMap<>();\n            if (!Closure.bindRecurse(pat.withType(type), o, pairs::put)) {\n              throw new Codes.MorelRuntimeException(Codes.BuiltInExn.BIND, pos);\n            }\n            pairs.forEach((pat2, o2) -> {\n              outBindings.accept(Binding.of(pat2, o2));\n              if (pat2 != skipPat) {\n                int stringDepth = Prop.STRING_DEPTH.intValue(session.map);\n                int lineWidth = Prop.LINE_WIDTH.intValue(session.map);\n                int printDepth = Prop.PRINT_DEPTH.intValue(session.map);\n                int printLength = Prop.PRINT_LENGTH.intValue(session.map);\n                final Pretty pretty =\n                    new Pretty(typeSystem, lineWidth, printLength, printDepth,\n                        stringDepth);\n                final Pretty.TypedVal typedVal;\n                if (o2 instanceof TypedValue) {\n                  TypedValue typedValue = (TypedValue) o2;\n                  typedVal =\n                      new Pretty.TypedVal(pat2.name,\n                          typedValue.valueAs(Object.class),\n                          Keys.toProgressive(pat2.type().key())\n                              .toType(typeSystem));\n                } else {\n                  typedVal = new Pretty.TypedVal(pat2.name, o2, pat2.type);\n                }\n                pretty.pretty(buf, pat2.type, typedVal);\n                final String line = str(buf);\n                outs.add(line);\n                outLines.accept(line);\n              }\n            });\n          } catch (Codes.MorelRuntimeException e) {\n            session.handle(e, buf);\n            final String line = str(buf);\n            outs.add(line);\n            outLines.accept(line);\n          }\n          session.code = code;\n          session.out = ImmutableList.copyOf(outs);\n        });\n      }\n    });\n\n    newBindings.clear();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler.[void]link(Map<Core.NamedPat, LinkCode>,Core.Pat,Code)", "name": "link", "arg_nums": 3, "params": [{"name": "linkCodes", "type": "Map<Core.NamedPat, LinkCode>"}, {"name": "pat", "type": "Core.Pat"}, {"name": "code", "type": "Code"}], "return_type": "void", "signature": "private void link(Map<Core.NamedPat, LinkCode> linkCodes, Core.Pat pat,\n      Code code)", "original_string": "  private void link(Map<Core.NamedPat, LinkCode> linkCodes, Core.Pat pat,\n      Code code) {\n    if (pat instanceof Core.IdPat) {\n      final LinkCode linkCode = linkCodes.get(pat);\n      if (linkCode != null) {\n        linkCode.refCode = code; // link the reference to the definition\n      }\n    } else if (pat instanceof Core.TuplePat) {\n      if (code instanceof Codes.TupleCode) {\n        // Recurse into the tuple, binding names to code in parallel\n        final List<Code> codes = ((Codes.TupleCode) code).codes;\n        final List<Core.Pat> pats = ((Core.TuplePat) pat).args;\n        forEach(codes, pats, (code1, pat1) ->\n            link(linkCodes, pat1, code1));\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Compiler.java", "class_name": "Compiler", "class_uri": "src/main/java/net/hydromatic/morel/compile/Compiler.java.Compiler", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[]TypeResolver(TypeSystem)", "name": "TypeResolver", "arg_nums": 1, "params": [{"name": "typeSystem", "type": "TypeSystem"}], "return_type": "", "signature": "private TypeResolver(TypeSystem typeSystem)", "original_string": "  private TypeResolver(TypeSystem typeSystem) {\n    this.typeSystem = requireNonNull(typeSystem);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Resolved]deduceType(Environment,Ast.Decl,TypeSystem)", "name": "deduceType", "arg_nums": 3, "params": [{"name": "env", "type": "Environment"}, {"name": "decl", "type": "Ast.Decl"}, {"name": "typeSystem", "type": "TypeSystem"}], "return_type": "Resolved", "signature": "public static Resolved deduceType(Environment env, Ast.Decl decl,\n      TypeSystem typeSystem)", "original_string": "  public static Resolved deduceType(Environment env, Ast.Decl decl,\n      TypeSystem typeSystem) {\n    final TypeResolver typeResolver = new TypeResolver(typeSystem);\n    int attempt = 0;\n    for (;;) {\n      int original = typeSystem.expandCount.get();\n      final TypeResolver.Resolved resolved =\n          typeResolver.deduceType_(env, decl);\n      if (typeSystem.expandCount.get() == original\n          || attempt++ > 1) {\n        return resolved;\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Resolved", "classes": []}, "docstring": " Deduces the datatype of a declaration."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Type]toType(Ast.Type,TypeSystem)", "name": "toType", "arg_nums": 2, "params": [{"name": "type", "type": "Ast.Type"}, {"name": "typeSystem", "type": "TypeSystem"}], "return_type": "Type", "signature": "public static Type toType(Ast.Type type, TypeSystem typeSystem)", "original_string": "  public static Type toType(Ast.Type type, TypeSystem typeSystem) {\n    return typeSystem.typeFor(toTypeKey(type));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Converts a type AST to a type."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Type.Key]toTypeKey(Ast.Type)", "name": "toTypeKey", "arg_nums": 1, "params": [{"name": "type", "type": "Ast.Type"}], "return_type": "Type.Key", "signature": "public static Type.Key toTypeKey(Ast.Type type)", "original_string": "  public static Type.Key toTypeKey(Ast.Type type) {\n    return new Foo().toTypeKey(type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Converts a type AST to a type key."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Resolved]deduceType_(Environment,Ast.Decl)", "name": "deduceType_", "arg_nums": 2, "params": [{"name": "env", "type": "Environment"}, {"name": "decl", "type": "Ast.Decl"}], "return_type": "Resolved", "signature": "private Resolved deduceType_(Environment env, Ast.Decl decl)", "original_string": "  private Resolved deduceType_(Environment env, Ast.Decl decl) {\n    final TypeEnvHolder typeEnvs = new TypeEnvHolder(EmptyTypeEnv.INSTANCE);\n    BuiltIn.forEach(typeSystem, (builtIn, type) -> {\n      if (builtIn.structure == null) {\n        typeEnvs.accept(builtIn.mlName, type);\n      }\n      if (builtIn.alias != null) {\n        typeEnvs.accept(builtIn.alias, type);\n      }\n    });\n    BuiltIn.forEachStructure(typeSystem, (structure, type) ->\n        typeEnvs.accept(structure.name, type));\n    env.forEachType(typeSystem, typeEnvs);\n    final TypeEnv typeEnv = typeEnvs.typeEnv;\n    final Map<Ast.IdPat, Unifier.Term> termMap = new LinkedHashMap<>();\n    final Ast.Decl node2 = deduceDeclType(typeEnv, decl, termMap);\n    final boolean debug = false;\n    @SuppressWarnings(\"ConstantConditions\")\n    final Unifier.Tracer tracer = debug\n        ? Tracers.printTracer(System.out)\n        : Tracers.nullTracer();\n\n    // Deduce types. The loop will retry, just once, if there are certain kinds\n    // of errors.\n    tryAgain:\n    for (;;) {\n      final List<Unifier.TermTerm> termPairs = new ArrayList<>();\n      terms.forEach(tv ->\n          termPairs.add(new Unifier.TermTerm(tv.term, tv.variable)));\n      final Unifier.Result result =\n          unifier.unify(termPairs, actionMap, tracer);\n      if (!(result instanceof Unifier.Substitution)) {\n        final String extra = \";\\n\"\n            + \" term pairs:\\n\"\n            + join(\"\\n\", transform(terms, Object::toString));\n        throw new TypeException(\"Cannot deduce type: \" + result, Pos.ZERO);\n      }\n      final TypeMap typeMap =\n          new TypeMap(typeSystem, map, (Unifier.Substitution) result);\n      while (!preferredTypes.isEmpty()) {\n        Map.Entry<Unifier.Variable, PrimitiveType> x = preferredTypes.remove(0);\n        final Type type =\n            typeMap.termToType(typeMap.substitution.resultMap.get(x.getKey()));\n        if (type instanceof TypeVar) {\n          equiv(toTerm(x.getValue()), x.getKey());\n          continue tryAgain;\n        }\n      }\n\n      final AtomicBoolean progressive = new AtomicBoolean();\n      forEachUnresolvedField(node2, typeMap, apply -> {\n        final Type type = typeMap.getType(apply.arg);\n        if (type.isProgressive()) {\n          progressive.set(true);\n        }\n      }, apply -> {}, apply -> {});\n      if (progressive.get()) {\n        node2.accept(FieldExpander.create(typeSystem, env));\n      } else {\n        checkNoUnresolvedFieldRefs(node2, typeMap);\n      }\n      return Resolved.of(env, decl, node2, typeMap);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Resolved", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]checkNoUnresolvedFieldRefs(Ast.Decl,TypeMap)", "name": "checkNoUnresolvedFieldRefs", "arg_nums": 2, "params": [{"name": "decl", "type": "Ast.Decl"}, {"name": "typeMap", "type": "TypeMap"}], "return_type": "void", "signature": "private static void checkNoUnresolvedFieldRefs(Ast.Decl decl,\n      TypeMap typeMap)", "original_string": "  private static void checkNoUnresolvedFieldRefs(Ast.Decl decl,\n      TypeMap typeMap) {\n    forEachUnresolvedField(decl, typeMap,\n        apply -> {\n          throw new TypeException(\"unresolved flex record (can't tell \"\n              + \"what fields there are besides \" + apply.fn + \")\",\n              apply.arg.pos);\n        },\n        apply -> {\n          throw new TypeException(\"reference to field \"\n              + ((Ast.RecordSelector) apply.fn).name\n              + \" of non-record type \" + typeMap.getType(apply.arg),\n              apply.arg.pos);\n        },\n        apply -> {\n          throw new TypeException(\"no field '\"\n              + ((Ast.RecordSelector) apply.fn).name\n              + \"' in type '\" + typeMap.getType(apply.arg) + \"'\",\n              apply.arg.pos);\n        });\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Checks that there are no field references \"x.y\" or \"#y x\" where \"x\" has\nan unresolved type. Throws if there are unresolved field references."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]forEachUnresolvedField(Ast.Decl,TypeMap,Consumer<Ast.Apply>,Consumer<Ast.Apply>,Consumer<Ast.Apply>)", "name": "forEachUnresolvedField", "arg_nums": 5, "params": [{"name": "decl", "type": "Ast.Decl"}, {"name": "typeMap", "type": "TypeMap"}, {"name": "variableConsumer", "type": "Consumer<Ast.Apply>"}, {"name": "notRecordTypeConsumer", "type": "Consumer<Ast.Apply>"}, {"name": "noFieldConsumer", "type": "Consumer<Ast.Apply>"}], "return_type": "void", "signature": "private static void forEachUnresolvedField(Ast.Decl decl, TypeMap typeMap,\n      Consumer<Ast.Apply> variableConsumer,\n      Consumer<Ast.Apply> notRecordTypeConsumer,\n      Consumer<Ast.Apply> noFieldConsumer)", "original_string": "  private static void forEachUnresolvedField(Ast.Decl decl, TypeMap typeMap,\n      Consumer<Ast.Apply> variableConsumer,\n      Consumer<Ast.Apply> notRecordTypeConsumer,\n      Consumer<Ast.Apply> noFieldConsumer) {\n    decl.accept(\n        new Visitor() {\n          @Override protected void visit(Ast.Apply apply) {\n            if (apply.fn.op == Op.RECORD_SELECTOR) {\n              final Ast.RecordSelector recordSelector =\n                  (Ast.RecordSelector) apply.fn;\n              if (typeMap.typeIsVariable(apply.arg)) {\n                variableConsumer.accept(apply);\n              } else {\n                final Collection<String> fieldNames =\n                    typeMap.typeFieldNames(apply.arg);\n                if (fieldNames == null) {\n                  notRecordTypeConsumer.accept(apply);\n                } else {\n                  if (!fieldNames.contains(recordSelector.name)) {\n                    // \"#f r\" is valid if \"r\" is a record type with a field \"f\"\n                    noFieldConsumer.accept(apply);\n                  }\n                }\n              }\n            }\n            super.visit(apply);\n          }\n        });\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[E]reg(E,Unifier.Variable,Unifier.Term)", "name": "reg", "arg_nums": 3, "params": [{"name": "node", "type": "E"}, {"name": "variable", "type": "Unifier.Variable"}, {"name": "term", "type": "Unifier.Term"}], "return_type": "E", "signature": "private <E extends AstNode> E reg(E node,\n      Unifier.Variable variable, Unifier.Term term)", "original_string": "  private <E extends AstNode> E reg(E node,\n      Unifier.Variable variable, Unifier.Term term) {\n    requireNonNull(node);\n    requireNonNull(term);\n    map.put(node, term);\n    if (variable != null) {\n      equiv(term, variable);\n    }\n    return node;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]deduceType(TypeEnv,Ast.Exp,Unifier.Variable)", "name": "deduceType", "arg_nums": 3, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "node", "type": "Ast.Exp"}, {"name": "v", "type": "Unifier.Variable"}], "return_type": "Ast.Exp", "signature": "private Ast.Exp deduceType(TypeEnv env, Ast.Exp node, Unifier.Variable v)", "original_string": "  private Ast.Exp deduceType(TypeEnv env, Ast.Exp node, Unifier.Variable v) {\n    final List<Ast.Exp> args2;\n    final Unifier.Variable v2;\n    final Map<Ast.IdPat, Unifier.Term> termMap;\n    switch (node.op) {\n    case BOOL_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.BOOL));\n\n    case CHAR_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.CHAR));\n\n    case INT_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.INT));\n\n    case REAL_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.REAL));\n\n    case STRING_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.STRING));\n\n    case UNIT_LITERAL:\n      return reg(node, v, toTerm(PrimitiveType.UNIT));\n\n    case ANNOTATED_EXP:\n      final Ast.AnnotatedExp annotatedExp = (Ast.AnnotatedExp) node;\n      final Type type = toType(annotatedExp.type, typeSystem);\n      deduceType(env, annotatedExp.exp, v);\n      return reg(node, v, toTerm(type, Subst.EMPTY));\n\n    case ANDALSO:\n    case ORELSE:\n      return infix(env, (Ast.InfixCall) node, v, PrimitiveType.BOOL);\n\n    case TUPLE:\n      final Ast.Tuple tuple = (Ast.Tuple) node;\n      final List<Unifier.Term> types = new ArrayList<>();\n      args2 = new ArrayList<>();\n      for (Ast.Exp arg : tuple.args) {\n        final Unifier.Variable vArg = unifier.variable();\n        args2.add(deduceType(env, arg, vArg));\n        types.add(vArg);\n      }\n      return reg(tuple.copy(args2), v, tuple(types));\n\n    case LIST:\n      final Ast.ListExp list = (Ast.ListExp) node;\n      final Unifier.Variable vArg2 = unifier.variable();\n      args2 = new ArrayList<>();\n      for (Ast.Exp arg : list.args) {\n        args2.add(deduceType(env, arg, vArg2));\n      }\n      return reg(list.copy(args2), v, unifier.apply(LIST_TY_CON, vArg2));\n\n    case RECORD:\n      final Ast.Record record = (Ast.Record) node;\n      final NavigableMap<String, Unifier.Term> labelTypes = new TreeMap<>();\n      final NavigableMap<String, Ast.Exp> map2 = new TreeMap<>();\n      record.args.forEach((name, exp) -> {\n        final Unifier.Variable vArg = unifier.variable();\n        final Ast.Exp e2 = deduceType(env, exp, vArg);\n        labelTypes.put(name, vArg);\n        map2.put(name, e2);\n      });\n      return reg(record.copy(map2), v, record(labelTypes));\n\n    case LET:\n      final Ast.Let let = (Ast.Let) node;\n      termMap = new LinkedHashMap<>();\n      TypeEnv env2 = env;\n      final List<Ast.Decl> decls = new ArrayList<>();\n      for (Ast.Decl decl : let.decls) {\n        decls.add(deduceDeclType(env2, decl, termMap));\n        env2 = bindAll(env2, termMap);\n        termMap.clear();\n      }\n      final Ast.Exp e2 = deduceType(env2, let.exp, v);\n      final Ast.Let let2 = let.copy(decls, e2);\n      return reg(let2, null, v);\n\n    case RECORD_SELECTOR:\n      final Ast.RecordSelector recordSelector = (Ast.RecordSelector) node;\n      throw new RuntimeException(\"Error: unresolved flex record\\n\"\n          + \"   (can't tell what fields there are besides #\"\n          + recordSelector.name + \")\");\n\n    case IF:\n      // TODO: check that condition has type boolean\n      // TODO: check that ifTrue has same type as ifFalse\n      final Ast.If if_ = (Ast.If) node;\n      v2 = unifier.variable();\n      final Ast.Exp condition2 = deduceType(env, if_.condition, v2);\n      equiv(v2, toTerm(PrimitiveType.BOOL));\n      final Ast.Exp ifTrue2 = deduceType(env, if_.ifTrue, v);\n      final Ast.Exp ifFalse2 = deduceType(env, if_.ifFalse, v);\n      final Ast.If if2 = if_.copy(condition2, ifTrue2, ifFalse2);\n      return reg(if2, null, v);\n\n    case CASE:\n      final Ast.Case case_ = (Ast.Case) node;\n      v2 = unifier.variable();\n      final Ast.Exp e2b = deduceType(env, case_.exp, v2);\n      final NavigableSet<String> labelNames = new TreeSet<>();\n      final Unifier.Term argType = map.get(e2b);\n      if (argType instanceof Unifier.Sequence) {\n        final List<String> fieldList = fieldList((Unifier.Sequence) argType);\n        if (fieldList != null) {\n          labelNames.addAll(fieldList);\n        }\n      }\n      final List<Ast.Match> matchList2 =\n          deduceMatchListType(env, case_.matchList, labelNames, v2, v);\n      return reg(case_.copy(e2b, matchList2), null, v);\n\n    case FROM:\n      // \"(from exp: v50 as id: v60 [, exp: v51 as id: v61]...\n      //  [where filterExp: v5] [yield yieldExp: v4]): v\"\n      final Ast.From from = (Ast.From) node;\n      Unifier.Variable v3 = unifier.variable();\n      TypeEnv env3 = env;\n      final Map<Ast.Id, Unifier.Variable> fieldVars = new LinkedHashMap<>();\n      final List<Ast.FromStep> fromSteps = new ArrayList<>();\n      for (Ord<Ast.FromStep> step : Ord.zip(from.steps)) {\n        Pair<TypeEnv, Unifier.Variable> p =\n            deduceStepType(env, step.e, v3, env3, fieldVars, fromSteps);\n        if (step.i != from.steps.size() - 1) {\n          switch (step.e.op) {\n          case COMPUTE:\n            throw new IllegalArgumentException(\n                \"'compute' step must be last in 'from'\");\n          case INTO:\n            throw new CompileException(\"'into' step must be last in 'from'\",\n                false, step.e.pos);\n          }\n        }\n        env3 = p.left;\n        v3 = p.right;\n      }\n      final Ast.Exp yieldExp2;\n      if (from.implicitYieldExp != null) {\n        v3 = unifier.variable();\n        yieldExp2 = deduceType(env3, from.implicitYieldExp, v3);\n      } else {\n        requireNonNull(v3);\n        yieldExp2 = null;\n      }\n      final Ast.From from2 = from.copy(fromSteps, yieldExp2);\n      return reg(from2, v,\n          from.isCompute() || from.isInto() ? v3\n              : unifier.apply(LIST_TY_CON, v3));\n\n    case ID:\n      final Ast.Id id = (Ast.Id) node;\n      final Unifier.Term term = env.get(typeSystem, id.name, name ->\n          new CompileException(\"unbound variable or constructor: \" + name,\n              false, id.pos));\n      return reg(id, v, term);\n\n    case FN:\n      final Ast.Fn fn = (Ast.Fn) node;\n      final Unifier.Variable resultVariable = unifier.variable();\n      final List<Ast.Match> matchList = new ArrayList<>();\n      for (Ast.Match match : fn.matchList) {\n        matchList.add(\n            deduceMatchType(env, match, new HashMap<>(), v, resultVariable));\n      }\n      final Ast.Fn fn2b = fn.copy(matchList);\n      return reg(fn2b, null, v);\n\n    case APPLY:\n      final Ast.Apply apply = (Ast.Apply) node;\n      final Unifier.Variable vFn = unifier.variable();\n      final Unifier.Variable vArg = unifier.variable();\n      equiv(unifier.apply(FN_TY_CON, vArg, v), vFn);\n      final Ast.Exp arg2;\n      if (apply.arg instanceof Ast.RecordSelector) {\n        // node is \"f #field\" and has type \"v\"\n        // \"f\" has type \"vArg -> v\" and also \"vFn\"\n        // \"#field\" has type \"vArg\" and also \"vRec -> vField\"\n        // When we resolve \"vRec\" we can then deduce \"vField\".\n        final Unifier.Variable vRec = unifier.variable();\n        final Unifier.Variable vField = unifier.variable();\n        deduceRecordSelectorType(env, vField, vRec,\n            (Ast.RecordSelector) apply.arg);\n        arg2 = reg(apply.arg, vArg, unifier.apply(FN_TY_CON, vRec, vField));\n      } else {\n        arg2 = deduceType(env, apply.arg, vArg);\n      }\n      final Ast.Exp fn2;\n      if (apply.fn instanceof Ast.RecordSelector) {\n        // node is \"#field arg\" and has type \"v\"\n        // \"#field\" has type \"vArg -> v\"\n        // \"arg\" has type \"vArg\"\n        // When we resolve \"vArg\" we can then deduce \"v\".\n        deduceRecordSelectorType(env, v, vArg,\n            (Ast.RecordSelector) apply.fn);\n        fn2 = apply.fn;\n      } else {\n        fn2 = deduceType(env, apply.fn, vFn);\n      }\n      if (fn2 instanceof Ast.Id) {\n        final BuiltIn builtIn = BuiltIn.BY_ML_NAME.get(((Ast.Id) fn2).name);\n        if (builtIn != null) {\n          builtIn.prefer(t -> preferredTypes.add(v, t));\n        }\n      }\n      return reg(apply.copy(fn2, arg2), null, v);\n\n    case AT:\n    case CARET:\n    case COMPOSE:\n    case PLUS:\n    case MINUS:\n    case TIMES:\n    case DIVIDE:\n    case DIV:\n    case MOD:\n    case EQ:\n    case NE:\n    case GE:\n    case GT:\n    case LE:\n    case LT:\n    case ELEM:\n    case NOT_ELEM:\n    case CONS:\n    case UNION:\n    case INTERSECT:\n    case EXCEPT:\n      return infix(env, (Ast.InfixCall) node, v);\n\n    case NEGATE:\n      return prefix(env, (Ast.PrefixCall) node, v);\n\n    default:\n      throw new AssertionError(\"cannot deduce type for \" + node.op);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Pair<TypeEnv, Unifier.Variable>]deduceStepType(TypeEnv,Ast.FromStep,Unifier.Variable,TypeEnv,Map<Ast.Id, Unifier.Variable>,List<Ast.FromStep>)", "name": "deduceStepType", "arg_nums": 6, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "step", "type": "Ast.FromStep"}, {"name": "v", "type": "Unifier.Variable"}, {"name": "env2", "type": "TypeEnv"}, {"name": "fieldVars", "type": "Map<Ast.Id, Unifier.Variable>"}, {"name": "fromSteps", "type": "List<Ast.FromStep>"}], "return_type": "Pair<TypeEnv, Unifier.Variable>", "signature": "private Pair<TypeEnv, Unifier.Variable> deduceStepType(TypeEnv env,\n      Ast.FromStep step, Unifier.Variable v, final TypeEnv env2,\n      Map<Ast.Id, Unifier.Variable> fieldVars, List<Ast.FromStep> fromSteps)", "original_string": "  private Pair<TypeEnv, Unifier.Variable> deduceStepType(TypeEnv env,\n      Ast.FromStep step, Unifier.Variable v, final TypeEnv env2,\n      Map<Ast.Id, Unifier.Variable> fieldVars, List<Ast.FromStep> fromSteps) {\n    requireNonNull(v);\n    switch (step.op) {\n    case SCAN:\n      final Ast.Scan scan = (Ast.Scan) step;\n      final Ast.Exp scanExp;\n      final boolean eq;\n      final Ast.Exp scanExp3;\n      final Unifier.Variable v15 = unifier.variable();\n      final Unifier.Variable v16 = unifier.variable();\n      final Map<Ast.IdPat, Unifier.Term> termMap1 = new HashMap<>();\n      if (scan.exp == null) {\n        scanExp = null;\n        eq = false;\n        scanExp3 = null;\n      } else if (scan.exp.op == Op.FROM_EQ) {\n        scanExp = ((Ast.PrefixCall) scan.exp).a;\n        eq = true;\n        final Ast.Exp scanExp2 = deduceType(env2, scanExp, v15);\n        scanExp3 = ast.fromEq(scanExp2);\n      } else {\n        scanExp = scan.exp;\n        eq = false;\n        scanExp3 = deduceType(env2, scanExp, v15);\n      }\n      final Ast.Pat pat2 =\n          deducePatType(env2, scan.pat, termMap1, null, v16);\n      if (scanExp != null) {\n        reg(scanExp, v15, eq ? v16 : unifier.apply(LIST_TY_CON, v16));\n      }\n      TypeEnv env4 = env2;\n      for (Map.Entry<Ast.IdPat, Unifier.Term> e : termMap1.entrySet()) {\n        env4 = env4.bind(e.getKey().name, e.getValue());\n        fieldVars.put(ast.id(Pos.ZERO, e.getKey().name),\n            (Unifier.Variable) e.getValue());\n      }\n      v = fieldVar(fieldVars);\n      final Ast.Exp scanCondition2;\n      if (scan.condition != null) {\n        final Unifier.Variable v5 = unifier.variable();\n        scanCondition2 = deduceType(env4, scan.condition, v5);\n        equiv(v5, toTerm(PrimitiveType.BOOL));\n      } else {\n        scanCondition2 = null;\n      }\n      fromSteps.add(scan.copy(pat2, scanExp3, scanCondition2));\n      return Pair.of(env4, v);\n\n    case WHERE:\n      final Ast.Where where = (Ast.Where) step;\n      final Unifier.Variable v5 = unifier.variable();\n      final Ast.Exp filter2 = deduceType(env2, where.exp, v5);\n      equiv(v5, toTerm(PrimitiveType.BOOL));\n      fromSteps.add(where.copy(filter2));\n      return Pair.of(env2, v);\n\n    case SKIP:\n      final Ast.Skip skip = (Ast.Skip) step;\n      final Unifier.Variable v11 = unifier.variable();\n      final Ast.Exp skipCount = deduceType(env2, skip.exp, v11);\n      equiv(v11, toTerm(PrimitiveType.INT));\n      fromSteps.add(skip.copy(skipCount));\n      return Pair.of(env2, v);\n\n    case TAKE:\n      final Ast.Take take = (Ast.Take) step;\n      final Unifier.Variable v12 = unifier.variable();\n      final Ast.Exp takeCount = deduceType(env2, take.exp, v12);\n      equiv(v12, toTerm(PrimitiveType.INT));\n      fromSteps.add(take.copy(takeCount));\n      return Pair.of(env2, v);\n\n    case YIELD:\n      final Ast.Yield yield = (Ast.Yield) step;\n      final Unifier.Variable v6 = unifier.variable();\n      v = v6;\n      final Ast.Exp yieldExp2 = deduceType(env2, yield.exp, v6);\n      fromSteps.add(yield.copy(yieldExp2));\n      if (yieldExp2.op == Op.RECORD) {\n        final Unifier.Sequence sequence =\n            (Unifier.Sequence) map.get(yieldExp2);\n        final Ast.Record record2 = (Ast.Record) yieldExp2;\n        final TypeEnv[] envs = {env};\n        forEach(record2.args.keySet(), sequence.terms, (name, term) ->\n            envs[0] = envs[0].bind(name, term));\n        return Pair.of(envs[0], v);\n      } else {\n        return Pair.of(env2, v);\n      }\n\n    case ORDER:\n      final Ast.Order order = (Ast.Order) step;\n      final List<Ast.OrderItem> orderItems = new ArrayList<>();\n      for (Ast.OrderItem orderItem : order.orderItems) {\n        orderItems.add(\n            orderItem.copy(\n                deduceType(env2, orderItem.exp, unifier.variable()),\n                orderItem.direction));\n      }\n      fromSteps.add(order.copy(orderItems));\n      return Pair.of(env2, v);\n\n    case GROUP:\n    case COMPUTE:\n      final Ast.Group group = (Ast.Group) step;\n      validateGroup(group);\n      TypeEnv env3 = env;\n      fieldVars.clear();\n      final PairList<Ast.Id, Ast.Exp> groupExps = PairList.of();\n      for (Map.Entry<Ast.Id, Ast.Exp> groupExp : group.groupExps) {\n        final Ast.Id id = groupExp.getKey();\n        final Ast.Exp exp = groupExp.getValue();\n        final Unifier.Variable v7 = unifier.variable();\n        final Ast.Exp exp2 = deduceType(env2, exp, v7);\n        reg(id, null, v7);\n        env3 = env3.bind(id.name, v7);\n        fieldVars.put(id, v7);\n        groupExps.add(id, exp2);\n      }\n      final List<Ast.Aggregate> aggregates = new ArrayList<>();\n      for (Ast.Aggregate aggregate : group.aggregates) {\n        final Ast.Id id = aggregate.id;\n        final Unifier.Variable v8 = unifier.variable();\n        reg(id, null, v8);\n        final Unifier.Variable v9 = unifier.variable();\n        final Ast.Exp aggregateFn2 =\n            deduceType(env2, aggregate.aggregate, v9);\n        final Ast.Exp arg2;\n        final Unifier.Variable v10;\n        if (aggregate.argument == null) {\n          arg2 = null;\n          v10 = v;\n        } else {\n          v10 = unifier.variable();\n          arg2 = deduceType(env2, aggregate.argument, v10);\n        }\n        reg(aggregate.aggregate, null, v9);\n        equiv(unifier.apply(FN_TY_CON, unifier.apply(LIST_TY_CON, v10), v8),\n            v9);\n        env3 = env3.bind(id.name, v8);\n        fieldVars.put(id, v8);\n        final Ast.Aggregate aggregate2 =\n            aggregate.copy(aggregateFn2, arg2, aggregate.id);\n        aggregates.add(aggregate2);\n        reg(aggregate2, null, v8);\n      }\n      fromSteps.add(step.op == Op.GROUP\n          ? group.copy(groupExps, aggregates)\n          : ((Ast.Compute) step).copy(aggregates));\n      return Pair.of(env3, v);\n\n    case INTO:\n      // from i in [1,2,3] into f\n      //   f: int list -> string\n      //   expression: string\n      final Ast.Into into = (Ast.Into) step;\n      final Unifier.Variable v13 = unifier.variable();\n      final Unifier.Variable v14 = unifier.variable();\n      final Ast.Exp intoExp = deduceType(env2, into.exp, v14);\n      equiv(unifier.apply(FN_TY_CON, unifier.apply(LIST_TY_CON, v), v13),\n          v14);\n      fromSteps.add(into.copy(intoExp));\n      return Pair.of(EmptyTypeEnv.INSTANCE, v13);\n\n    case THROUGH:\n      // from i in [1,2,3] through p in f\n      //   f: int list -> string list\n      //   expression: string list\n      // v: int (i)\n      // v20: int list\n      // v17: int list -> string list (f)\n      // v18: string (p)\n      // v19: string list (from i in [1,2,3] through p in f)\n      final Ast.Through through = (Ast.Through) step;\n      final Unifier.Variable v17 = unifier.variable();\n      final Unifier.Variable v18 = unifier.variable();\n      final Unifier.Variable v19 = unifier.variable();\n      final Unifier.Variable v20 = unifier.variable();\n      equiv(unifier.apply(LIST_TY_CON, v), v20);\n\n      final Map<Ast.IdPat, Unifier.Term> termMap = new HashMap<>();\n      final Ast.Pat throughPat =\n          deducePatType(env, through.pat, termMap, null, v18);\n      final Ast.Exp throughExp = deduceType(env2, through.exp, v17);\n      equiv(unifier.apply(LIST_TY_CON, v18), v19);\n      equiv(unifier.apply(FN_TY_CON, v20, v19), v17);\n      fromSteps.add(through.copy(throughPat, throughExp));\n      TypeEnv env5 = env;\n      fieldVars.clear();\n      for (Map.Entry<Ast.IdPat, Unifier.Term> e : termMap.entrySet()) {\n        env5 = env5.bind(e.getKey().name, e.getValue());\n        fieldVars.put(ast.id(Pos.ZERO, e.getKey().name),\n            (Unifier.Variable) e.getValue());\n      }\n      return Pair.of(env5, v18);\n\n    default:\n      throw new AssertionError(\"unknown step type \" + step.op);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Pair<TypeEnv, Unifier.Variable>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]validateGroup(Ast.Group)", "name": "validateGroup", "arg_nums": 1, "params": [{"name": "group", "type": "Ast.Group"}], "return_type": "void", "signature": "private void validateGroup(Ast.Group group)", "original_string": "  private void validateGroup(Ast.Group group) {\n    final List<String> names = new ArrayList<>();\n    group.groupExps.leftList().forEach(id -> names.add(id.name));\n    group.aggregates.forEach(aggregate -> names.add(aggregate.id.name));\n    int duplicate = Util.firstDuplicate(names);\n    if (duplicate >= 0) {\n      throw new RuntimeException(\"Duplicate field name '\"\n          + names.get(duplicate) + \"' in group\");\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Validates a {@code Group}. Throws if there are duplicate names among\nthe keys and aggregates."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Variable]fieldVar(Map<Ast.Id, Unifier.Variable>)", "name": "fieldVar", "arg_nums": 1, "params": [{"name": "fieldVars", "type": "Map<Ast.Id, Unifier.Variable>"}], "return_type": "Unifier.Variable", "signature": "private Unifier.Variable fieldVar(Map<Ast.Id, Unifier.Variable> fieldVars)", "original_string": "  private Unifier.Variable fieldVar(Map<Ast.Id, Unifier.Variable> fieldVars) {\n    switch (fieldVars.size()) {\n    case 0:\n      return equiv(toTerm(PrimitiveType.UNIT), unifier.variable());\n    case 1:\n      return Iterables.getOnlyElement(fieldVars.values());\n    default:\n      final TreeMap<String, Unifier.Variable> map = new TreeMap<>();\n      fieldVars.forEach((k, v) -> map.put(k.name, v));\n      return equiv(record(map), unifier.variable());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Variable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Term]record(NavigableMap<String, ? extends Unifier.Term>)", "name": "record", "arg_nums": 1, "params": [{"name": "labelTypes", "type": "NavigableMap<String, ? extends Unifier.Term>"}], "return_type": "Unifier.Term", "signature": "private Unifier.Term record(\n      NavigableMap<String, ? extends Unifier.Term> labelTypes)", "original_string": "  private Unifier.Term record(\n      NavigableMap<String, ? extends Unifier.Term> labelTypes) {\n    if (labelTypes.isEmpty()) {\n      return toTerm(PrimitiveType.UNIT);\n    } else if (TypeSystem.areContiguousIntegers(labelTypes.navigableKeySet())\n        && labelTypes.size() != 1) {\n      return unifier.apply(TUPLE_TY_CON, labelTypes.values());\n    } else {\n      final StringBuilder b = new StringBuilder(RECORD_TY_CON);\n      for (String label : labelTypes.navigableKeySet()) {\n        b.append(':').append(label);\n      }\n      return unifier.apply(b.toString(), labelTypes.values());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Term", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Term]tuple(List<Unifier.Term>)", "name": "tuple", "arg_nums": 1, "params": [{"name": "types", "type": "List<Unifier.Term>"}], "return_type": "Unifier.Term", "signature": "private Unifier.Term tuple(List<Unifier.Term> types)", "original_string": "  private Unifier.Term tuple(List<Unifier.Term> types) {\n    if (types.isEmpty()) {\n      return toTerm(PrimitiveType.UNIT);\n    } else {\n      return unifier.apply(TUPLE_TY_CON, types);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Term", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.RecordSelector]deduceRecordSelectorType(TypeEnv,Unifier.Variable,Unifier.Variable,Ast.RecordSelector)", "name": "deduceRecordSelectorType", "arg_nums": 4, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "vResult", "type": "Unifier.Variable"}, {"name": "vArg", "type": "Unifier.Variable"}, {"name": "recordSelector", "type": "Ast.RecordSelector"}], "return_type": "Ast.RecordSelector", "signature": "private Ast.RecordSelector deduceRecordSelectorType(TypeEnv env,\n      Unifier.Variable vResult, Unifier.Variable vArg,\n      Ast.RecordSelector recordSelector)", "original_string": "  private Ast.RecordSelector deduceRecordSelectorType(TypeEnv env,\n      Unifier.Variable vResult, Unifier.Variable vArg,\n      Ast.RecordSelector recordSelector) {\n    final String fieldName = recordSelector.name;\n    actionMap.put(vArg, (v, t, substitution, termPairs) -> {\n      // We now know that the type arg, say \"{a: int, b: real}\".\n      // So, now we can declare that the type of vResult, say \"#b\", is\n      // \"real\".\n      if (t instanceof Unifier.Sequence) {\n        final Unifier.Sequence sequence = (Unifier.Sequence) t;\n        final List<String> fieldList = fieldList(sequence);\n        if (fieldList != null) {\n          int i = fieldList.indexOf(fieldName);\n          if (i >= 0) {\n            final Unifier.Term result2 = substitution.resolve(vResult);\n            final Unifier.Term term = sequence.terms.get(i);\n            final Unifier.Term term2 = substitution.resolve(term);\n            termPairs.add(new Unifier.TermTerm(result2, term2));\n          }\n        }\n      }\n    });\n    return recordSelector;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.RecordSelector", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[List<String>]fieldList(Unifier.Sequence)", "name": "fieldList", "arg_nums": 1, "params": [{"name": "sequence", "type": "Unifier.Sequence"}], "return_type": "List<String>", "signature": "static List<String> fieldList(final Unifier.Sequence sequence)", "original_string": "  static List<String> fieldList(final Unifier.Sequence sequence) {\n    if (sequence.operator.equals(RECORD_TY_CON)) {\n      return ImmutableList.of();\n    } else if (sequence.operator.startsWith(RECORD_TY_CON + \":\")) {\n      final String[] fields = sequence.operator.split(\":\");\n      return skip(Arrays.asList(fields));\n    } else if (sequence.operator.equals(TUPLE_TY_CON)) {\n      final int size = sequence.terms.size();\n      return TupleType.ordinalNames(size);\n    } else {\n      return null;\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "List<String>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Match]deduceMatchType(TypeEnv,Ast.Match,Map<Ast.IdPat, Unifier.Term>,Unifier.Variable,Unifier.Variable)", "name": "deduceMatchType", "arg_nums": 5, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "match", "type": "Ast.Match"}, {"name": "termMap", "type": "Map<Ast.IdPat, Unifier.Term>"}, {"name": "argVariable", "type": "Unifier.Variable"}, {"name": "resultVariable", "type": "Unifier.Variable"}], "return_type": "Ast.Match", "signature": "private Ast.Match deduceMatchType(TypeEnv env, Ast.Match match,\n      Map<Ast.IdPat, Unifier.Term> termMap, Unifier.Variable argVariable,\n      Unifier.Variable resultVariable)", "original_string": "  private Ast.Match deduceMatchType(TypeEnv env, Ast.Match match,\n      Map<Ast.IdPat, Unifier.Term> termMap, Unifier.Variable argVariable,\n      Unifier.Variable resultVariable) {\n    final Unifier.Variable vPat = unifier.variable();\n    Ast.Pat pat2 = deducePatType(env, match.pat, termMap, null, vPat);\n    TypeEnv env2 = bindAll(env, termMap);\n    Ast.Exp e2 = deduceType(env2, match.exp, resultVariable);\n    Ast.Match match2 = match.copy(pat2, e2);\n    return reg(match2, argVariable,\n        unifier.apply(FN_TY_CON, vPat, resultVariable));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.Match", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[List<Ast.Match>]deduceMatchListType(TypeEnv,List<Ast.Match>,NavigableSet<String>,Unifier.Variable,Unifier.Variable)", "name": "deduceMatchListType", "arg_nums": 5, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "matchList", "type": "List<Ast.Match>"}, {"name": "labelNames", "type": "NavigableSet<String>"}, {"name": "argVariable", "type": "Unifier.Variable"}, {"name": "resultVariable", "type": "Unifier.Variable"}], "return_type": "List<Ast.Match>", "signature": "private List<Ast.Match> deduceMatchListType(TypeEnv env, List<Ast.Match> matchList,\n      NavigableSet<String> labelNames, Unifier.Variable argVariable,\n      Unifier.Variable resultVariable)", "original_string": "  private List<Ast.Match> deduceMatchListType(TypeEnv env, List<Ast.Match> matchList,\n      NavigableSet<String> labelNames, Unifier.Variable argVariable,\n      Unifier.Variable resultVariable) {\n    for (Ast.Match match : matchList) {\n      if (match.pat instanceof Ast.RecordPat) {\n        labelNames.addAll(((Ast.RecordPat) match.pat).args.keySet());\n      }\n    }\n    final List<Ast.Match> matchList2 = new ArrayList<>();\n    for (Ast.Match match : matchList) {\n      final Map<Ast.IdPat, Unifier.Term> termMap = new HashMap<>();\n      final Ast.Pat pat2 =\n          deducePatType(env, match.pat, termMap, labelNames, argVariable);\n      final TypeEnv env2 = bindAll(env, termMap);\n      final Ast.Exp e2 = deduceType(env2, match.exp, resultVariable);\n      matchList2.add(match.copy(pat2, e2));\n    }\n    return matchList2;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<Ast.Match>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[AstNode]deduceValBindType(TypeEnv,Ast.ValBind,Map<Ast.IdPat, Unifier.Term>,Unifier.Variable,Unifier.Variable)", "name": "deduceValBindType", "arg_nums": 5, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "valBind", "type": "Ast.ValBind"}, {"name": "termMap", "type": "Map<Ast.IdPat, Unifier.Term>"}, {"name": "v", "type": "Unifier.Variable"}, {"name": "vPat", "type": "Unifier.Variable"}], "return_type": "AstNode", "signature": "private AstNode deduceValBindType(TypeEnv env, Ast.ValBind valBind,\n      Map<Ast.IdPat, Unifier.Term> termMap, Unifier.Variable v,\n      Unifier.Variable vPat)", "original_string": "  private AstNode deduceValBindType(TypeEnv env, Ast.ValBind valBind,\n      Map<Ast.IdPat, Unifier.Term> termMap, Unifier.Variable v,\n      Unifier.Variable vPat) {\n    deducePatType(env, valBind.pat, termMap, null, vPat);\n    final Ast.Exp e2 = deduceType(env, valBind.exp, vPat);\n    final Ast.ValBind valBind2 = valBind.copy(valBind.pat, e2);\n    return reg(valBind2, v, unifier.apply(FN_TY_CON, vPat, vPat));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[TypeEnv]bindAll(TypeEnv,Map<Ast.IdPat, Unifier.Term>)", "name": "bindAll", "arg_nums": 2, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "termMap", "type": "Map<Ast.IdPat, Unifier.Term>"}], "return_type": "TypeEnv", "signature": "private static TypeEnv bindAll(TypeEnv env,\n      Map<Ast.IdPat, Unifier.Term> termMap)", "original_string": "  private static TypeEnv bindAll(TypeEnv env,\n      Map<Ast.IdPat, Unifier.Term> termMap) {\n    for (Map.Entry<Ast.IdPat, Unifier.Term> entry : termMap.entrySet()) {\n      env = env.bind(entry.getKey().name, entry.getValue());\n    }\n    return env;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "TypeEnv", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Decl]deduceDeclType(TypeEnv,Ast.Decl,Map<Ast.IdPat, Unifier.Term>)", "name": "deduceDeclType", "arg_nums": 3, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "node", "type": "Ast.Decl"}, {"name": "termMap", "type": "Map<Ast.IdPat, Unifier.Term>"}], "return_type": "Ast.Decl", "signature": "private Ast.Decl deduceDeclType(TypeEnv env, Ast.Decl node,\n      Map<Ast.IdPat, Unifier.Term> termMap)", "original_string": "  private Ast.Decl deduceDeclType(TypeEnv env, Ast.Decl node,\n      Map<Ast.IdPat, Unifier.Term> termMap) {\n    switch (node.op) {\n    case VAL_DECL:\n      return deduceValDeclType(env, (Ast.ValDecl) node, termMap);\n\n    case FUN_DECL:\n      final Ast.ValDecl valDecl = toValDecl(env, (Ast.FunDecl) node);\n      return deduceValDeclType(env, valDecl, termMap);\n\n    case DATATYPE_DECL:\n      final Ast.DatatypeDecl datatypeDecl = (Ast.DatatypeDecl) node;\n      return deduceDataTypeDeclType(env, datatypeDecl, termMap);\n\n    default:\n      throw new AssertionError(\"cannot deduce type for \" + node.op + \" [\"\n          + node + \"]\");\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.Decl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Decl]deduceDataTypeDeclType(TypeEnv,Ast.DatatypeDecl,Map<Ast.IdPat, Unifier.Term>)", "name": "deduceDataTypeDeclType", "arg_nums": 3, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "datatypeDecl", "type": "Ast.DatatypeDecl"}, {"name": "termMap", "type": "Map<Ast.IdPat, Unifier.Term>"}], "return_type": "Ast.Decl", "signature": "private Ast.Decl deduceDataTypeDeclType(TypeEnv env,\n      Ast.DatatypeDecl datatypeDecl,\n      Map<Ast.IdPat, Unifier.Term> termMap)", "original_string": "  private Ast.Decl deduceDataTypeDeclType(TypeEnv env,\n      Ast.DatatypeDecl datatypeDecl,\n      Map<Ast.IdPat, Unifier.Term> termMap) {\n    final List<Keys.DataTypeKey> keys = new ArrayList<>();\n    for (Ast.DatatypeBind bind : datatypeDecl.binds) {\n      final Foo foo = new Foo();\n      bind.tyVars.forEach(foo::toTypeKey);\n\n      final SortedMap<String, Type.Key> tyCons = new TreeMap<>();\n      deduceDatatypeBindType(bind, tyCons);\n\n      keys.add(\n          Keys.datatype(bind.name.name, Keys.ordinals(foo.tyVarMap.size()),\n              tyCons));\n    }\n    final List<Type> types = typeSystem.dataTypes(keys);\n\n    forEach(datatypeDecl.binds, types, (datatypeBind, type) -> {\n      final DataType dataType =\n          (DataType) (type instanceof DataType ? type\n              : ((ForallType) type).type);\n      for (Ast.TyCon tyCon : datatypeBind.tyCons) {\n        final Type tyConType;\n        if (tyCon.type != null) {\n          final Type.Key conKey = toTypeKey(tyCon.type);\n          tyConType = typeSystem.fnType(conKey.toType(typeSystem), dataType);\n        } else {\n          tyConType = dataType;\n        }\n        termMap.put((Ast.IdPat) ast.idPat(tyCon.pos, tyCon.id.name),\n            toTerm(tyConType, Subst.EMPTY));\n        map.put(tyCon, toTerm(tyConType, Subst.EMPTY));\n      }\n    });\n\n    map.put(datatypeDecl, toTerm(PrimitiveType.UNIT));\n    return datatypeDecl;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.Decl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Decl]deduceValDeclType(TypeEnv,Ast.ValDecl,Map<Ast.IdPat, Unifier.Term>)", "name": "deduceValDeclType", "arg_nums": 3, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "valDecl", "type": "Ast.ValDecl"}, {"name": "termMap", "type": "Map<Ast.IdPat, Unifier.Term>"}], "return_type": "Ast.Decl", "signature": "private Ast.Decl deduceValDeclType(TypeEnv env, Ast.ValDecl valDecl,\n      Map<Ast.IdPat, Unifier.Term> termMap)", "original_string": "  private Ast.Decl deduceValDeclType(TypeEnv env, Ast.ValDecl valDecl,\n      Map<Ast.IdPat, Unifier.Term> termMap) {\n    final Holder<TypeEnv> envHolder = Holder.of(env);\n    final Map<Ast.ValBind, Supplier<Unifier.Variable>> map0 =\n        new LinkedHashMap<>();\n    //noinspection FunctionalExpressionCanBeFolded\n    valDecl.valBinds.forEach(b ->\n        map0.put(b, Suppliers.memoize(unifier::variable)::get));\n    map0.forEach((valBind, vPatSupplier) -> {\n      // If recursive, bind each value (presumably a function) to its type\n      // in the environment before we try to deduce the type of the expression.\n      if (valDecl.rec && valBind.pat instanceof Ast.IdPat) {\n        envHolder.set(\n            envHolder.get().bind(\n                ((Ast.IdPat) valBind.pat).name, vPatSupplier.get()));\n      }\n    });\n    final List<Ast.ValBind> valBinds = new ArrayList<>();\n    final TypeEnv env2 = envHolder.get();\n    map0.forEach((valBind, vPatSupplier) ->\n        valBinds.add((Ast.ValBind)\n            deduceValBindType(env2, valBind, termMap, unifier.variable(),\n                vPatSupplier.get())));\n    Ast.Decl node2 = valDecl.copy(valBinds);\n    map.put(node2, toTerm(PrimitiveType.UNIT));\n    return node2;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.Decl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]deduceDatatypeBindType(Ast.DatatypeBind,SortedMap<String, Type.Key>)", "name": "deduceDatatypeBindType", "arg_nums": 2, "params": [{"name": "datatypeBind", "type": "Ast.DatatypeBind"}, {"name": "tyCons", "type": "SortedMap<String, Type.Key>"}], "return_type": "void", "signature": "private void deduceDatatypeBindType(Ast.DatatypeBind datatypeBind,\n      SortedMap<String, Type.Key> tyCons)", "original_string": "  private void deduceDatatypeBindType(Ast.DatatypeBind datatypeBind,\n      SortedMap<String, Type.Key> tyCons) {\n    Foo foo = new Foo();\n    for (Ast.TyCon tyCon : datatypeBind.tyCons) {\n      tyCons.put(tyCon.id.name,\n          tyCon.type == null ? Keys.dummy() : foo.toTypeKey(tyCon.type));\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.ValDecl]toValDecl(TypeEnv,Ast.FunDecl)", "name": "toValDecl", "arg_nums": 2, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "funDecl", "type": "Ast.FunDecl"}], "return_type": "Ast.ValDecl", "signature": "private Ast.ValDecl toValDecl(TypeEnv env, Ast.FunDecl funDecl)", "original_string": "  private Ast.ValDecl toValDecl(TypeEnv env, Ast.FunDecl funDecl) {\n    final List<Ast.ValBind> valBindList = new ArrayList<>();\n    for (Ast.FunBind funBind : funDecl.funBinds) {\n      valBindList.add(toValBind(env, funBind));\n    }\n    return ast.valDecl(funDecl.pos, true, valBindList);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.ValDecl", "classes": []}, "docstring": " Converts a function declaration to a value declaration.\nIn other words, {@code fun} is syntactic sugar, and this\nis the de-sugaring machine.\n\n<p>For example, {@code fun inc x = x + 1}\nbecomes {@code val rec inc = fn x => x + 1}.\n\n<p>If there are multiple arguments, there is one {@code fn} for each\nargument: {@code fun sum x y = x + y}\nbecomes {@code val rec sum = fn x => fn y => x + y}.\n\n<p>If there are multiple clauses, we generate {@code case}:\n{@code fun gcd a 0 = a | gcd a b = gcd b (a mod b)}\nbecomes\n{@code val rec gcd = fn x => fn y =>\ncase (x, y) of\n    (a, 0) => a\n  | (a, b) = gcd b (a mod b)}.\n"}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.ValBind]toValBind(TypeEnv,Ast.FunBind)", "name": "toValBind", "arg_nums": 2, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "funBind", "type": "Ast.FunBind"}], "return_type": "Ast.ValBind", "signature": "private Ast.ValBind toValBind(TypeEnv env, Ast.FunBind funBind)", "original_string": "  private Ast.ValBind toValBind(TypeEnv env, Ast.FunBind funBind) {\n    final List<Ast.Pat> vars;\n    Ast.Exp exp;\n    Ast.Type returnType = null;\n    if (funBind.matchList.size() == 1) {\n      final Ast.FunMatch funMatch = funBind.matchList.get(0);\n      exp = funMatch.exp;\n      vars = funMatch.patList;\n      returnType = funMatch.returnType;\n    } else {\n      final List<String> varNames =\n          MapList.of(funBind.matchList.get(0).patList.size(),\n              index -> \"v\" + index);\n      vars = Lists.transform(varNames, v -> ast.idPat(Pos.ZERO, v));\n      final List<Ast.Match> matchList = new ArrayList<>();\n      Pos prevReturnTypePos = null;\n      for (Ast.FunMatch funMatch : funBind.matchList) {\n        matchList.add(\n            ast.match(funMatch.pos, patTuple(env, funMatch.patList),\n                funMatch.exp));\n        if (funMatch.returnType != null) {\n          if (returnType != null\n              && !returnType.equals(funMatch.returnType)) {\n            throw new CompileException(\"parameter or result constraints of \"\n                + \"clauses don't agree [tycon mismatch]\", false,\n                prevReturnTypePos.plus(funMatch.pos));\n          }\n          returnType = funMatch.returnType;\n          prevReturnTypePos = funMatch.pos;\n        }\n      }\n      exp = ast.caseOf(Pos.ZERO, idTuple(varNames), matchList);\n    }\n    if (returnType != null) {\n      exp = ast.annotatedExp(exp.pos, exp, returnType);\n    }\n    final Pos pos = funBind.pos;\n    for (Ast.Pat var : Lists.reverse(vars)) {\n      exp = ast.fn(pos, ast.match(pos, var, exp));\n    }\n    return ast.valBind(pos, ast.idPat(pos, funBind.name), exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.ValBind", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]idTuple(List<String>)", "name": "idTuple", "arg_nums": 1, "params": [{"name": "vars", "type": "List<String>"}], "return_type": "Ast.Exp", "signature": "private static Ast.Exp idTuple(List<String> vars)", "original_string": "  private static Ast.Exp idTuple(List<String> vars) {\n    final List<Ast.Id> idList =\n        Lists.transform(vars, v -> ast.id(Pos.ZERO, v));\n    if (idList.size() == 1) {\n      return idList.get(0);\n    }\n    return ast.tuple(Pos.ZERO, idList);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": " Converts a list of variable names to a variable or tuple.\n\n<p>For example, [\"x\"] becomes \"{@code x}\" (an {@link Ast.Id}),\nand [\"x\", \"y\"] becomes \"{@code (x, y)}\" (a {@link Ast.Tuple} of\n{@link Ast.Id Ids})."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Pat]patTuple(TypeEnv,List<Ast.Pat>)", "name": "patTuple", "arg_nums": 2, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "patList", "type": "List<Ast.Pat>"}], "return_type": "Ast.Pat", "signature": "@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n  private Ast.Pat patTuple(TypeEnv env, List<Ast.Pat> patList)", "original_string": "  @SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n  private Ast.Pat patTuple(TypeEnv env, List<Ast.Pat> patList) {\n    final List<Ast.Pat> list2 = new ArrayList<>();\n    for (int i = 0; i < patList.size(); i++) {\n      final Ast.Pat pat = patList.get(i);\n      switch (pat.op) {\n      case ID_PAT:\n        final Ast.IdPat idPat = (Ast.IdPat) pat;\n        if (env.has(idPat.name)\n            && typeSystem.lookupTyCon(idPat.name) != null) {\n          final Unifier.Term term = env.get(typeSystem, idPat.name, name ->\n              new RuntimeException(\"oops, should have \" + idPat.name));\n          if (term instanceof Unifier.Sequence\n              && ((Unifier.Sequence) term).operator.equals(FN_TY_CON)) {\n            list2.add(\n                ast.conPat(idPat.pos, ast.id(idPat.pos, idPat.name),\n                    patList.get(++i)));\n          } else {\n            list2.add(ast.con0Pat(idPat.pos, ast.id(idPat.pos, idPat.name)));\n          }\n          break;\n        }\n        // fall through\n      default:\n        list2.add(pat);\n      }\n    }\n    if (list2.size() == 1) {\n      return list2.get(0);\n    } else {\n      return ast.tuplePat(Pos.sum(list2), list2);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")\n  private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"SwitchStatementWithTooFewBranches\")", "private"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": " Converts a list of patterns to a singleton pattern or tuple pattern."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Pat]deducePatType(TypeEnv,Ast.Pat,Map<Ast.IdPat, Unifier.Term>,NavigableSet<String>,Unifier.Variable)", "name": "deducePatType", "arg_nums": 5, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "pat", "type": "Ast.Pat"}, {"name": "termMap", "type": "Map<Ast.IdPat, Unifier.Term>"}, {"name": "labelNames", "type": "NavigableSet<String>"}, {"name": "v", "type": "Unifier.Variable"}], "return_type": "Ast.Pat", "signature": "private Ast.Pat deducePatType(TypeEnv env, Ast.Pat pat,\n      Map<Ast.IdPat, Unifier.Term> termMap, NavigableSet<String> labelNames,\n      Unifier.Variable v)", "original_string": "  private Ast.Pat deducePatType(TypeEnv env, Ast.Pat pat,\n      Map<Ast.IdPat, Unifier.Term> termMap, NavigableSet<String> labelNames,\n      Unifier.Variable v) {\n    switch (pat.op) {\n    case BOOL_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.BOOL));\n\n    case CHAR_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.CHAR));\n\n    case INT_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.INT));\n\n    case REAL_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.REAL));\n\n    case STRING_LITERAL_PAT:\n      return reg(pat, v, toTerm(PrimitiveType.STRING));\n\n    case ID_PAT:\n      termMap.put((Ast.IdPat) pat, v);\n      // fall through\n\n    case WILDCARD_PAT:\n      return reg(pat, null, v);\n\n    case AS_PAT:\n      final Ast.AsPat asPat = (Ast.AsPat) pat;\n      termMap.put(asPat.id, v);\n      deducePatType(env, asPat.pat, termMap, null, v);\n      return reg(pat, null, v);\n\n    case ANNOTATED_PAT:\n      final Ast.AnnotatedPat annotatedPat = (Ast.AnnotatedPat) pat;\n      final Type type = toType(annotatedPat.type, typeSystem);\n      deducePatType(env, annotatedPat.pat, termMap, null, v);\n      return reg(pat, v, toTerm(type, Subst.EMPTY));\n\n    case TUPLE_PAT:\n      final List<Unifier.Term> typeTerms = new ArrayList<>();\n      final Ast.TuplePat tuple = (Ast.TuplePat) pat;\n      for (Ast.Pat arg : tuple.args) {\n        final Unifier.Variable vArg = unifier.variable();\n        deducePatType(env, arg, termMap, null, vArg);\n        typeTerms.add(vArg);\n      }\n      return reg(pat, v, tuple(typeTerms));\n\n    case RECORD_PAT:\n      // First, determine the set of field names.\n      //\n      // If the pattern is in a 'case', we know the field names from the\n      // argument. But it we are in a function, we require at least one of the\n      // patterns to not be a wildcard and not have an ellipsis. For example, in\n      //\n      //  fun f {a=1,...} = 1 | f {b=2,...} = 2\n      //\n      // we cannot deduce whether a 'c' field is allowed.\n      final Ast.RecordPat recordPat = (Ast.RecordPat) pat;\n      final NavigableMap<String, Unifier.Term> labelTerms =\n          RecordType.mutableMap();\n      if (labelNames == null) {\n        labelNames = new TreeSet<>(recordPat.args.keySet());\n      }\n      final SortedMap<String, Ast.Pat> args = RecordType.mutableMap();\n      for (String labelName : labelNames) {\n        final Unifier.Variable vArg = unifier.variable();\n        labelTerms.put(labelName, vArg);\n        final Ast.Pat argPat = recordPat.args.get(labelName);\n        if (argPat != null) {\n          args.put(labelName,\n              deducePatType(env, argPat, termMap, null, vArg));\n        }\n      }\n      final Unifier.Term record = record(labelTerms);\n      final Ast.RecordPat recordPat2 = recordPat.copy(recordPat.ellipsis, args);\n      if (!recordPat.ellipsis) {\n        return reg(recordPat2, v, record);\n      }\n      final Unifier.Variable v2 = unifier.variable();\n      equiv(record, v2);\n      actionMap.put(v, (v3, t, substitution, termPairs) -> {\n        // We now know the type of the source record, say \"{a: int, b: real}\".\n        // So, now we can fill out the ellipsis.\n        assert v == v3;\n        if (t instanceof Unifier.Sequence) {\n          final Unifier.Sequence sequence = (Unifier.Sequence) t;\n          final List<String> fieldList = fieldList(sequence);\n          if (fieldList != null) {\n            final NavigableMap<String, Unifier.Term> labelTerms2 =\n                RecordType.mutableMap();\n            forEachIndexed(fieldList, (fieldName, i) -> {\n              if (labelTerms.containsKey(fieldName)) {\n                labelTerms2.put(fieldName, sequence.terms.get(i));\n              }\n            });\n            final Unifier.Term result2 = substitution.resolve(v2);\n            final Unifier.Term term2 = record(labelTerms2);\n            termPairs.add(new Unifier.TermTerm(result2, term2));\n          }\n        }\n      });\n      return reg(recordPat2, null, record);\n\n    case CON_PAT:\n      final Ast.ConPat conPat = (Ast.ConPat) pat;\n      // e.g. \"SOME x\" has type \"int option\", \"x\" has type \"int\"\n      final Pair<DataType, Type.Key> pair =\n          typeSystem.lookupTyCon(conPat.tyCon.name);\n      if (pair == null) {\n        throw new AssertionError(\"not found: \" + conPat.tyCon.name);\n      }\n      final DataType dataType = pair.left;\n      final Type argType = pair.right.toType(typeSystem);\n      final Unifier.Variable vArg = unifier.variable();\n      deducePatType(env, conPat.pat, termMap, null, vArg);\n      final Unifier.Term argTerm = toTerm(argType, Subst.EMPTY);\n      equiv(vArg, argTerm);\n      final Unifier.Term term = toTerm(dataType, Subst.EMPTY);\n      if (argType instanceof TypeVar) {\n        // E.g. Suppose arg is \"NODE 'b\"\n        // (therefore argType is \"'b\", argTerm is \"T7\"),\n        // datatype is \"('a,'b) tree\"\n        // (therefore term is \"tree(T8,T9)\").\n        // We can say that argTerm (T7) is equivalent to\n        // the second type parameter (T9).\n        //\n        // TODO: handle more complex types, e.g. \"NODE (int * 'b)\"\n        equiv(argTerm,\n            ((Unifier.Sequence) term).terms.get(((TypeVar) argType).ordinal));\n      }\n      return reg(pat, v, term);\n\n    case CON0_PAT:\n      final Ast.Con0Pat con0Pat = (Ast.Con0Pat) pat;\n      final Pair<DataType, Type.Key> pair0 =\n          typeSystem.lookupTyCon(con0Pat.tyCon.name);\n      if (pair0 == null) {\n        throw new AssertionError();\n      }\n      final DataType dataType0 = pair0.left;\n      return reg(pat, v, toTerm(dataType0, Subst.EMPTY));\n\n    case LIST_PAT:\n      final Ast.ListPat list = (Ast.ListPat) pat;\n      final Unifier.Variable vArg2 = unifier.variable();\n      for (Ast.Pat arg : list.args) {\n        deducePatType(env, arg, termMap, null, vArg2);\n      }\n      return reg(list, v, unifier.apply(LIST_TY_CON, vArg2));\n\n    case CONS_PAT:\n      final Unifier.Variable elementType = unifier.variable();\n      final Ast.InfixPat call = (Ast.InfixPat) pat;\n      deducePatType(env, call.p0, termMap, null, elementType);\n      deducePatType(env, call.p1, termMap, null, v);\n      return reg(call, v, unifier.apply(LIST_TY_CON, elementType));\n\n    default:\n      throw new AssertionError(\"cannot deduce type for pattern \" + pat.op);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.Pat", "classes": []}, "docstring": " Derives a type term for a pattern, collecting the names of pattern\nvariables.\n\n@param env Compile-time environment\n@param pat Pattern AST\n@param termMap Map from names to bound terms, populated by this method\n@param labelNames List of names of labels in this pattern and sibling\n  patterns in a {@code |} match, or null if not a record pattern\n@param v Type variable that this method should equate the type term that it\n  derives for this pattern"}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]infix(TypeEnv,Ast.InfixCall,Unifier.Variable,Type)", "name": "infix", "arg_nums": 4, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "call", "type": "Ast.InfixCall"}, {"name": "v", "type": "Unifier.Variable"}, {"name": "type", "type": "Type"}], "return_type": "Ast.Exp", "signature": "private Ast.Exp infix(TypeEnv env, Ast.InfixCall call, Unifier.Variable v,\n      Type type)", "original_string": "  private Ast.Exp infix(TypeEnv env, Ast.InfixCall call, Unifier.Variable v,\n      Type type) {\n    final Unifier.Term term = toTerm(type, Subst.EMPTY);\n    final Ast.Exp a0 = deduceType(env, call.a0, v);\n    final Ast.Exp a1 = deduceType(env, call.a1, v);\n    return reg(call.copy(a0, a1), v, term);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": " Registers an infix operator whose type is a given type."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]infix(TypeEnv,Ast.InfixCall,Unifier.Variable)", "name": "infix", "arg_nums": 3, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "call", "type": "Ast.InfixCall"}, {"name": "v", "type": "Unifier.Variable"}], "return_type": "Ast.Exp", "signature": "private Ast.Exp infix(TypeEnv env, Ast.InfixCall call,\n      Unifier.Variable v)", "original_string": "  private Ast.Exp infix(TypeEnv env, Ast.InfixCall call,\n      Unifier.Variable v) {\n    return deduceType(env,\n        ast.apply(ast.id(Pos.ZERO, call.op.opName),\n            ast.tuple(Pos.ZERO, ImmutableList.of(call.a0, call.a1))), v);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": " Registers an infix operator."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Ast.Exp]prefix(TypeEnv,Ast.PrefixCall,Unifier.Variable)", "name": "prefix", "arg_nums": 3, "params": [{"name": "env", "type": "TypeEnv"}, {"name": "call", "type": "Ast.PrefixCall"}, {"name": "v", "type": "Unifier.Variable"}], "return_type": "Ast.Exp", "signature": "private Ast.Exp prefix(TypeEnv env, Ast.PrefixCall call, Unifier.Variable v)", "original_string": "  private Ast.Exp prefix(TypeEnv env, Ast.PrefixCall call, Unifier.Variable v) {\n    return deduceType(env,\n        ast.apply(ast.id(Pos.ZERO, call.op.opName), call.a), v);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Ast.Exp", "classes": []}, "docstring": " Registers a prefix operator."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Variable]equiv(Unifier.Term,Unifier.Variable)", "name": "equiv", "arg_nums": 2, "params": [{"name": "term", "type": "Unifier.Term"}, {"name": "v", "type": "Unifier.Variable"}], "return_type": "Unifier.Variable", "signature": "private Unifier.Variable equiv(Unifier.Term term, Unifier.Variable v)", "original_string": "  private Unifier.Variable equiv(Unifier.Term term, Unifier.Variable v) {\n    terms.add(new TermVariable(term, v));\n    return v;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Variable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[void]equiv(Unifier.Term,Unifier.Term)", "name": "equiv", "arg_nums": 2, "params": [{"name": "term", "type": "Unifier.Term"}, {"name": "term2", "type": "Unifier.Term"}], "return_type": "void", "signature": "private void equiv(Unifier.Term term, Unifier.Term term2)", "original_string": "  private void equiv(Unifier.Term term, Unifier.Term term2) {\n    if (term2 instanceof Unifier.Variable) {\n      equiv(term, (Unifier.Variable) term2);\n    } else if (term instanceof Unifier.Variable) {\n      equiv(term2, (Unifier.Variable) term);\n    } else {\n      final Unifier.Variable variable = unifier.variable();\n      equiv(term, variable);\n      equiv(term2, variable);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[List<Unifier.Term>]toTerms(Iterable<? extends Type>,Subst)", "name": "toTerms", "arg_nums": 2, "params": [{"name": "types", "type": "Iterable<? extends Type>"}, {"name": "subst", "type": "Subst"}], "return_type": "List<Unifier.Term>", "signature": "private List<Unifier.Term> toTerms(Iterable<? extends Type> types,\n      Subst subst)", "original_string": "  private List<Unifier.Term> toTerms(Iterable<? extends Type> types,\n      Subst subst) {\n    return transformEager(types, type -> toTerm(type, subst));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<Unifier.Term>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Term]toTerm(PrimitiveType)", "name": "toTerm", "arg_nums": 1, "params": [{"name": "type", "type": "PrimitiveType"}], "return_type": "Unifier.Term", "signature": "private Unifier.Term toTerm(PrimitiveType type)", "original_string": "  private Unifier.Term toTerm(PrimitiveType type) {\n    return unifier.atom(type.moniker);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Term", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver.[Unifier.Term]toTerm(Type,Subst)", "name": "toTerm", "arg_nums": 2, "params": [{"name": "type", "type": "Type"}, {"name": "subst", "type": "Subst"}], "return_type": "Unifier.Term", "signature": "private Unifier.Term toTerm(Type type, Subst subst)", "original_string": "  private Unifier.Term toTerm(Type type, Subst subst) {\n    switch (type.op()) {\n    case ID:\n      return toTerm((PrimitiveType) type);\n    case TY_VAR:\n      final Unifier.Variable variable = subst.get((TypeVar) type);\n      return variable != null ? variable : unifier.variable();\n    case DATA_TYPE:\n      final DataType dataType = (DataType) type;\n      return unifier.apply(dataType.name(), toTerms(dataType.arguments, subst));\n    case FUNCTION_TYPE:\n      final FnType fnType = (FnType) type;\n      return unifier.apply(FN_TY_CON, toTerm(fnType.paramType, subst),\n          toTerm(fnType.resultType, subst));\n    case TUPLE_TYPE:\n      final TupleType tupleType = (TupleType) type;\n      return unifier.apply(TUPLE_TY_CON,\n          transform(tupleType.argTypes, type1 -> toTerm(type1, subst)));\n    case RECORD_TYPE:\n      final RecordType recordType = (RecordType) type;\n      SortedMap<String, Type> argNameTypes = recordType.argNameTypes;\n      if (recordType.isProgressive()) {\n        argNameTypes = new TreeMap<>(argNameTypes);\n        argNameTypes.put(PROGRESSIVE_LABEL, PrimitiveType.UNIT);\n      }\n      @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n      final NavigableSet<String> labelNames =\n          (NavigableSet) argNameTypes.keySet();\n      final String result;\n      if (labelNames.isEmpty()) {\n        result = PrimitiveType.UNIT.name();\n      } else if (TypeSystem.areContiguousIntegers(labelNames)) {\n        result = TUPLE_TY_CON;\n      } else {\n        final StringBuilder b = new StringBuilder(RECORD_TY_CON);\n        for (String label : labelNames) {\n          b.append(':').append(label);\n        }\n        result = b.toString();\n      }\n      final List<Unifier.Term> args =\n          transformEager(argNameTypes.values(),\n              type1 -> toTerm(type1, subst));\n      return unifier.apply(result, args);\n    case LIST:\n      final ListType listType = (ListType) type;\n      return unifier.apply(LIST_TY_CON,\n          toTerm(listType.elementType, subst));\n    case FORALL_TYPE:\n      final ForallType forallType = (ForallType) type;\n      Subst subst2 = subst;\n      for (int i = 0; i < forallType.parameterCount; i++) {\n        subst2 = subst2.plus(typeSystem.typeVariable(i), unifier.variable());\n      }\n      return toTerm(forallType.type, subst2);\n    default:\n      throw new AssertionError(\"unknown type: \" + type.moniker());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java", "class_name": "TypeResolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeResolver.java.TypeResolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Unifier.Term", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer.[]Replacer(TypeSystem,Environment,Map<Core.Id, Core.Id>)", "name": "Replacer", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "substitution", "type": "Map<Core.Id, Core.Id>"}], "return_type": "", "signature": "private Replacer(TypeSystem typeSystem, Environment env,\n      Map<Core.Id, Core.Id> substitution)", "original_string": "  private Replacer(TypeSystem typeSystem, Environment env,\n      Map<Core.Id, Core.Id> substitution) {\n    super(typeSystem, env);\n    this.substitution = requireNonNull(substitution);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Replacer.java", "class_name": "Replacer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer.[Core.Exp]substitute(TypeSystem,Map<Core.Id, Core.Id>,Core.Exp)", "name": "substitute", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "substitution", "type": "Map<Core.Id, Core.Id>"}, {"name": "exp", "type": "Core.Exp"}], "return_type": "Core.Exp", "signature": "static Core.Exp substitute(TypeSystem typeSystem,\n      Map<Core.Id, Core.Id> substitution, Core.Exp exp)", "original_string": "  static Core.Exp substitute(TypeSystem typeSystem,\n      Map<Core.Id, Core.Id> substitution, Core.Exp exp) {\n    final Replacer replacer =\n        new Replacer(typeSystem, Environments.empty(), substitution);\n    return exp.accept(replacer);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Replacer.java", "class_name": "Replacer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer.[Replacer]push(Environment)", "name": "push", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "Replacer", "signature": "@Override protected Replacer push(Environment env)", "original_string": "  @Override protected Replacer push(Environment env) {\n    return new Replacer(typeSystem, env, substitution);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Replacer.java", "class_name": "Replacer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Replacer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer.[Core.Exp]visit(Core.Id)", "name": "visit", "arg_nums": 1, "params": [{"name": "id", "type": "Core.Id"}], "return_type": "Core.Exp", "signature": "@Override protected Core.Exp visit(Core.Id id)", "original_string": "  @Override protected Core.Exp visit(Core.Id id) {\n    final Core.Id id2 = substitution.get(id);\n    return id2 != null ? id2 : id;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Replacer.java", "class_name": "Replacer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Replacer.java.Replacer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker.[RefChecker]of(TypeSystem,Environment)", "name": "of", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}], "return_type": "RefChecker", "signature": "public static RefChecker of(TypeSystem typeSystem, Environment env)", "original_string": "  public static RefChecker of(TypeSystem typeSystem, Environment env) {\n    return new RefChecker(typeSystem, env, new ArrayDeque<>());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/RefChecker.java", "class_name": "RefChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RefChecker", "classes": []}, "docstring": " Creates a reference checker."}, {"uris": "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker.[]RefChecker(TypeSystem,Environment,Deque<FromContext>)", "name": "RefChecker", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "fromStack", "type": "Deque<FromContext>"}], "return_type": "", "signature": "private RefChecker(TypeSystem typeSystem, Environment env,\n      Deque<FromContext> fromStack)", "original_string": "  private RefChecker(TypeSystem typeSystem, Environment env,\n      Deque<FromContext> fromStack) {\n    super(typeSystem, env, fromStack);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/RefChecker.java", "class_name": "RefChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker.[RefChecker]push(Environment)", "name": "push", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "RefChecker", "signature": "@Override protected RefChecker push(Environment env)", "original_string": "  @Override protected RefChecker push(Environment env) {\n    return new RefChecker(typeSystem, env, fromStack);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/RefChecker.java", "class_name": "RefChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "RefChecker", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker.[void]visit(Core.Id)", "name": "visit", "arg_nums": 1, "params": [{"name": "id", "type": "Core.Id"}], "return_type": "void", "signature": "@Override protected void visit(Core.Id id)", "original_string": "  @Override protected void visit(Core.Id id) {\n    verifyNotNull(env.getOpt(id.idPat), \"not found\", id);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/RefChecker.java", "class_name": "RefChecker", "class_uri": "src/main/java/net/hydromatic/morel/compile/RefChecker.java.RefChecker", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[void]visit(Consumer<Binding>)", "name": "visit", "arg_nums": 1, "params": [{"name": "consumer", "type": "Consumer<Binding>"}], "return_type": "void", "signature": "abstract void visit(Consumer<Binding> consumer)", "original_string": "  abstract void visit(Consumer<Binding> consumer);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Visits every variable binding in this environment.\n\n<p>Bindings that are obscured by more recent bindings of the same name\nare visited, but after the more obscuring bindings."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[String]asString()", "name": "asString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String asString()", "original_string": "  public String asString() {\n    final StringBuilder b = new StringBuilder();\n    getValueMap().forEach((k, v) ->\n        b.append(v).append(\"\\n\"));\n    return b.toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Converts this environment to a string.\n\n<p>This method does not override the {@link #toString()} method; if we did,\ndebuggers would invoke it automatically, burning lots of CPU and memory."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Binding]getOpt(String)", "name": "getOpt", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Binding", "signature": "public abstract @Nullable Binding getOpt(String name)", "original_string": "  public abstract @Nullable Binding getOpt(String name);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "public abstract @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Binding", "classes": []}, "docstring": " Returns the binding of {@code name} if bound, null if not."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Binding]getOpt(Core.NamedPat)", "name": "getOpt", "arg_nums": 1, "params": [{"name": "id", "type": "Core.NamedPat"}], "return_type": "Binding", "signature": "public abstract @Nullable Binding getOpt(Core.NamedPat id)", "original_string": "  public abstract @Nullable Binding getOpt(Core.NamedPat id);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "public abstract @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Binding", "classes": []}, "docstring": " Returns the binding of {@code id} if bound, null if not."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]bind(Core.IdPat,Object)", "name": "bind", "arg_nums": 2, "params": [{"name": "id", "type": "Core.IdPat"}, {"name": "value", "type": "Object"}], "return_type": "Environment", "signature": "public Environment bind(Core.IdPat id, Object value)", "original_string": "  public Environment bind(Core.IdPat id, Object value) {\n    return bind(Binding.of(id, value));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": " Creates an environment that is the same as a given environment, plus one\nmore variable."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]bind(Binding)", "name": "bind", "arg_nums": 1, "params": [{"name": "binding", "type": "Binding"}], "return_type": "Environment", "signature": "protected Environment bind(Binding binding)", "original_string": "  protected Environment bind(Binding binding) {\n    return new Environments.SubEnvironment(this, binding);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[void]forEachType(TypeSystem,BiConsumer<String, Type>)", "name": "forEachType", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "consumer", "type": "BiConsumer<String, Type>"}], "return_type": "void", "signature": "public void forEachType(TypeSystem typeSystem,\n      BiConsumer<String, Type> consumer)", "original_string": "  public void forEachType(TypeSystem typeSystem,\n      BiConsumer<String, Type> consumer) {\n    final Set<String> names = new HashSet<>();\n    visit(binding -> {\n      if (names.add(binding.id.name)) {\n        final Type type =\n            binding.value instanceof TypedValue\n                ? ((TypedValue) binding.value).typeKey().toType(typeSystem)\n                : binding.id.type;\n        consumer.accept(binding.id.name, type);\n      }\n    });\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls a consumer for each variable and its type.\nDoes not visit obscured bindings."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[void]forEachValue(BiConsumer<String, Object>)", "name": "forEachValue", "arg_nums": 1, "params": [{"name": "consumer", "type": "BiConsumer<String, Object>"}], "return_type": "void", "signature": "public void forEachValue(BiConsumer<String, Object> consumer)", "original_string": "  public void forEachValue(BiConsumer<String, Object> consumer) {\n    final Set<String> names = new HashSet<>();\n    visit(binding -> {\n      if (names.add(binding.id.name) && binding.value != Unit.INSTANCE) {\n        consumer.accept(binding.id.name, binding.value);\n      }\n    });\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls a consumer for each variable and its value.\nDoes not visit obscured bindings, or bindings to {@link Unit#INSTANCE}."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Map<String, Binding>]getValueMap()", "name": "getValueMap", "arg_nums": 0, "params": [], "return_type": "Map<String, Binding>", "signature": "public final Map<String, Binding> getValueMap()", "original_string": "  public final Map<String, Binding> getValueMap() {\n    final Map<String, Binding> valueMap = new HashMap<>();\n    visit(binding -> valueMap.putIfAbsent(binding.id.name, binding));\n    return valueMap;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "Map<String, Binding>", "classes": []}, "docstring": " Returns a map of the values and bindings."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]bindAll(Iterable<Binding>)", "name": "bindAll", "arg_nums": 1, "params": [{"name": "bindings", "type": "Iterable<Binding>"}], "return_type": "Environment", "signature": "public final Environment bindAll(Iterable<Binding> bindings)", "original_string": "  public final Environment bindAll(Iterable<Binding> bindings) {\n    return Environments.bind(this, bindings);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": " Creates an environment that is the same as this, plus the\ngiven bindings."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]nearestAncestorNotObscuredBy(Set<Core.NamedPat>)", "name": "nearestAncestorNotObscuredBy", "arg_nums": 1, "params": [{"name": "names", "type": "Set<Core.NamedPat>"}], "return_type": "Environment", "signature": "abstract Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names)", "original_string": "  abstract Environment nearestAncestorNotObscuredBy(Set<Core.NamedPat> names);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": " If this environment only defines bindings in the given set, returns\nits parent. Never returns null. The empty environment returns itself."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[int]distance(int,Core.NamedPat)", "name": "distance", "arg_nums": 2, "params": [{"name": "soFar", "type": "int"}, {"name": "id", "type": "Core.NamedPat"}], "return_type": "int", "signature": "abstract int distance(int soFar, Core.NamedPat id)", "original_string": "  abstract int distance(int soFar, Core.NamedPat id);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment.[Environment]plus(Environment)", "name": "plus", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "Environment", "signature": "public Environment plus(Environment env)", "original_string": "  public Environment plus(Environment env) {\n    final List<Binding> bindingList = new ArrayList<>();\n    env.visit(bindingList::add);\n    return bindAll(reverse(bindingList));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Environment.java", "class_name": "Environment", "class_uri": "src/main/java/net/hydromatic/morel/compile/Environment.java.Environment", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Environment", "classes": []}, "docstring": " Returns this environment plus the bindings in the given environment."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[]Extents()", "name": "Extents", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Extents()", "original_string": "  private Extents() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Analysis]create(TypeSystem,Core.Pat,SortedMap<Core.NamedPat, Core.Exp>,Iterable<? extends Core.FromStep>,PairList<Core.IdPat, Core.Exp>)", "name": "create", "arg_nums": 5, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "pat", "type": "Core.Pat"}, {"name": "boundPats", "type": "SortedMap<Core.NamedPat, Core.Exp>"}, {"name": "followingSteps", "type": "Iterable<? extends Core.FromStep>"}, {"name": "idPats", "type": "PairList<Core.IdPat, Core.Exp>"}], "return_type": "Analysis", "signature": "public static Analysis create(TypeSystem typeSystem, Core.Pat pat,\n      SortedMap<Core.NamedPat, Core.Exp> boundPats,\n      Iterable<? extends Core.FromStep> followingSteps,\n      PairList<Core.IdPat, Core.Exp> idPats)", "original_string": "  public static Analysis create(TypeSystem typeSystem, Core.Pat pat,\n      SortedMap<Core.NamedPat, Core.Exp> boundPats,\n      Iterable<? extends Core.FromStep> followingSteps,\n      PairList<Core.IdPat, Core.Exp> idPats) {\n    final Extent extent = new Extent(typeSystem, pat, boundPats, idPats);\n    final List<Core.Exp> remainingFilters = new ArrayList<>();\n\n    final ExtentMap map = new ExtentMap();\n    for (Core.FromStep step : followingSteps) {\n      if (step instanceof Core.Where) {\n        extent.g3(map.map, ((Core.Where) step).exp);\n      }\n    }\n    extent.definitions.forEach((namedPat, exp) -> {\n      // Is this expression better than the existing one?\n      // Yes, if there's no existing expression,\n      // or if the existing expression is infinite.\n      // For example, 'dno = v.deptno' is better than 'dno > 25'.\n      if (!map.map.containsKey(namedPat)\n          || Extents.isInfinite(map.map.get(namedPat).left(0))) {\n        map.map.put(namedPat,\n            ImmutablePairList.of(core.list(typeSystem, exp),\n                core.equal(typeSystem, core.id(namedPat), exp)));\n      }\n    });\n    final PairList<Core.Exp, Core.Exp> foo = map.get(typeSystem, pat);\n    final Pair<Core.Exp, Core.Exp> extentFilter;\n    if (foo.isEmpty()) {\n      extentFilter =\n          Pair.of(\n              core.extent(typeSystem, pat.type,\n                  ImmutableRangeSet.of(Range.all())),\n              core.boolLiteral(true));\n    } else {\n      extentFilter = reduceAnd(typeSystem, foo);\n    }\n    return new Analysis(boundPats, extent.goalPats,\n        extentFilter.left, core.decomposeAnd(extentFilter.right),\n        remainingFilters);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Analysis", "classes": []}, "docstring": " Analyzes the extent of a pattern in an expression and creates an\n{@link Analysis}.\n\n<p>For example, given the program\n\n<blockquote><pre>{@code\n  let\n    fun f i = i elem [1, 2, 4]\n  in\n    from x where f x\n  end\n}</pre></blockquote>\n\n<p>we can deduce that the extent of \"x\" is \"[1, 2, 4]\".\n\n<p>We can also compute the extent of tuples. For the program\n\n<blockquote><pre>{@code\n  let\n    val edges = [(1, 2), (2, 3), (1, 4), (4, 2), (4, 3)]\n    fun edge (i, j) = (i, j) elem edges\n  in\n    from x, y, z\n    where edge (x, y) andalso edge (y, z) andalso x <> z\n  end\n}</pre></blockquote>\n\n<p>we could deduce that \"x\" has extent \"from e in edges group e.i\",\n\"y\" has extent \"from e in edges group e.j\"\n(\"from e in edges group e.i\" is also valid),\n\"z\" has extent \"from e in edges group e.j\",\nand therefore \"(x, y, z)\" has extent\n\n<blockquote><pre>{@code\nfrom x in (from e in edges group e.i),\n  y in (from e in edges group e.j),\n  z in (from e in edges group e.j)\n}</pre></blockquote>\n\n<p>but we can do better by computing the extent of (x, y) simultaneously:\n\n<blockquote><pre>{@code\nfrom (x, y) in (from e in edges),\n  z in (from e in edges group e.j)\n}</pre></blockquote>\n"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[List<Core.IdPat>]flatten(Core.Pat)", "name": "flatten", "arg_nums": 1, "params": [{"name": "pat", "type": "Core.Pat"}], "return_type": "List<Core.IdPat>", "signature": "private static List<Core.IdPat> flatten(Core.Pat pat)", "original_string": "  private static List<Core.IdPat> flatten(Core.Pat pat) {\n    switch (pat.op) {\n    case ID_PAT:\n      return ImmutableList.of((Core.IdPat) pat);\n\n    case TUPLE_PAT:\n      final Core.TuplePat tuplePat = (Core.TuplePat) pat;\n      for (Core.Pat arg : tuplePat.args) {\n        if (arg.op != Op.ID_PAT) {\n          throw new CompileException(\"must be id\", false, arg.pos);\n        }\n      }\n      //noinspection unchecked,rawtypes\n      return (List) tuplePat.args;\n\n    case RECORD_PAT:\n      final Core.RecordPat recordPat = (Core.RecordPat) pat;\n      for (Core.Pat arg : recordPat.args) {\n        if (arg.op != Op.ID_PAT) {\n          throw new CompileException(\"must be id\", false, arg.pos);\n        }\n      }\n      //noinspection unchecked,rawtypes\n      return (List) recordPat.args;\n\n    default:\n      throw new CompileException(\"must be id\", false, pat.pos);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<Core.IdPat>", "classes": []}, "docstring": " Converts a singleton id pattern \"x\" or tuple pattern \"(x, y)\"\nto a list of id patterns."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[boolean]isInfinite(Core.Exp)", "name": "isInfinite", "arg_nums": 1, "params": [{"name": "exp", "type": "Core.Exp"}], "return_type": "boolean", "signature": "public static boolean isInfinite(Core.Exp exp)", "original_string": "  public static boolean isInfinite(Core.Exp exp) {\n    if (!exp.isCallTo(BuiltIn.Z_EXTENT)) {\n      return false;\n    }\n    final Core.Apply apply = (Core.Apply) exp;\n    final Core.Literal literal = (Core.Literal) apply.arg;\n    final RangeExtent rangeExtent = literal.unwrap(RangeExtent.class);\n    return rangeExtent.iterable == null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether an expression is an infinite extent."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Core.Decl]infinitePats(TypeSystem,Core.Decl)", "name": "infinitePats", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "node", "type": "Core.Decl"}], "return_type": "Core.Decl", "signature": "public static Core.Decl infinitePats(TypeSystem typeSystem,\n      Core.Decl node)", "original_string": "  public static Core.Decl infinitePats(TypeSystem typeSystem,\n      Core.Decl node) {\n    return node.accept(\n        new Shuttle(typeSystem) {\n          @Override protected Core.From visit(Core.From from) {\n            for (Ord<Core.FromStep> step : Ord.zip(from.steps)) {\n              if (step.e instanceof Core.Scan) {\n                final Core.Scan scan = (Core.Scan) step.e;\n                if (isInfinite(scan.exp)) {\n                  final FromBuilder fromBuilder = core.fromBuilder(typeSystem);\n                  List<Core.FromStep> followingSteps =\n                      skip(from.steps, step.i + 1);\n                  final Analysis analysis =\n                      create(typeSystem, scan.pat, ImmutableSortedMap.of(),\n                          followingSteps, ImmutablePairList.of());\n                  for (Core.FromStep step2 : from.steps) {\n                    if (step2 == scan) {\n                      fromBuilder.scan(scan.pat, analysis.extentExp,\n                          scan.condition); // TODO\n                    } else if (step2 instanceof Core.Where) {\n                      fromBuilder.where(\n                          core.subTrue(typeSystem,\n                              ((Core.Where) step2).exp,\n                              analysis.satisfiedFilters));\n                    } else {\n                      fromBuilder.addAll(ImmutableList.of(step2));\n                    }\n                  }\n                  return fromBuilder.build();\n                }\n              }\n            }\n            return from; // unchanged\n          }\n        });\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Core.Decl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Map<String, ImmutableRangeSet<C>>]intersect(List<Map<String, ImmutableRangeSet<C>>>)", "name": "intersect", "arg_nums": 1, "params": [{"name": "rangeSetMaps", "type": "List<Map<String, ImmutableRangeSet<C>>>"}], "return_type": "Map<String, ImmutableRangeSet<C>>", "signature": "public static <C extends Comparable<C>>\n      Map<String, ImmutableRangeSet<C>> intersect(\n          List<Map<String, ImmutableRangeSet<C>>> rangeSetMaps)", "original_string": "  public static <C extends Comparable<C>>\n      Map<String, ImmutableRangeSet<C>> intersect(\n          List<Map<String, ImmutableRangeSet<C>>> rangeSetMaps) {\n    switch (rangeSetMaps.size()) {\n    case 0:\n      // No filters, therefore the extent allows all values.\n      // An empty map expresses this.\n      return ImmutableMap.of();\n\n    case 1:\n      return rangeSetMaps.get(0);\n\n    default:\n      final Multimap<String, ImmutableRangeSet<C>> rangeSetMultimap =\n          HashMultimap.create();\n      for (Map<String, ImmutableRangeSet<C>> rangeSetMap : rangeSetMaps) {\n        rangeSetMap.forEach(rangeSetMultimap::put);\n      }\n      final ImmutableMap.Builder<String, ImmutableRangeSet<C>> rangeSetMap =\n          ImmutableMap.builder();\n      rangeSetMultimap.asMap().forEach((path, rangeSets) ->\n          rangeSetMap.put(path, intersectRangeSets(rangeSets)));\n      return rangeSetMap.build();\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Map<String, ImmutableRangeSet<C>>", "classes": []}, "docstring": " Intersects a collection of range set maps\n(maps from prefix to {@link RangeSet}) into one."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Map<String, ImmutableRangeSet<C>>]union(List<Map<String, ImmutableRangeSet<C>>>)", "name": "union", "arg_nums": 1, "params": [{"name": "rangeSetMaps", "type": "List<Map<String, ImmutableRangeSet<C>>>"}], "return_type": "Map<String, ImmutableRangeSet<C>>", "signature": "public static <C extends Comparable<C>>\n      Map<String, ImmutableRangeSet<C>> union(\n          List<Map<String, ImmutableRangeSet<C>>> rangeSetMaps)", "original_string": "  public static <C extends Comparable<C>>\n      Map<String, ImmutableRangeSet<C>> union(\n          List<Map<String, ImmutableRangeSet<C>>> rangeSetMaps) {\n    switch (rangeSetMaps.size()) {\n    case 0:\n      // No filters, therefore the extent is empty.\n      // A map containing an empty RangeSet for path \"/\" expresses this.\n      return ImmutableMap.of(\"/\", ImmutableRangeSet.of());\n\n    case 1:\n      return rangeSetMaps.get(0);\n\n    default:\n      final Multimap<String, ImmutableRangeSet<C>> rangeSetMultimap =\n          HashMultimap.create();\n      for (Map<String, ImmutableRangeSet<C>> rangeSetMap : rangeSetMaps) {\n        rangeSetMap.forEach(rangeSetMultimap::put);\n      }\n      final ImmutableMap.Builder<String, ImmutableRangeSet<C>> rangeSetMap =\n          ImmutableMap.builder();\n      rangeSetMultimap.asMap().forEach((path, rangeSets) ->\n          rangeSetMap.put(path, unionRangeSets(rangeSets)));\n      return rangeSetMap.build();\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Map<String, ImmutableRangeSet<C>>", "classes": []}, "docstring": " Unions a collection of range set maps\n(maps from prefix to {@link RangeSet}) into one."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[ImmutableRangeSet<C>]intersectRangeSets(Collection<ImmutableRangeSet<C>>)", "name": "intersectRangeSets", "arg_nums": 1, "params": [{"name": "rangeSets", "type": "Collection<ImmutableRangeSet<C>>"}], "return_type": "ImmutableRangeSet<C>", "signature": "private static <C extends Comparable<C>> ImmutableRangeSet<C>\n      intersectRangeSets(Collection<ImmutableRangeSet<C>> rangeSets)", "original_string": "  private static <C extends Comparable<C>> ImmutableRangeSet<C>\n      intersectRangeSets(Collection<ImmutableRangeSet<C>> rangeSets) {\n    return rangeSets.stream().reduce(ImmutableRangeSet.of(Range.all()),\n        ImmutableRangeSet::intersection);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ImmutableRangeSet<C>", "classes": []}, "docstring": " Intersects a collection of {@link RangeSet} into one.\n\n@see ImmutableRangeSet#intersection(RangeSet)"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[ImmutableRangeSet<C>]unionRangeSets(Collection<ImmutableRangeSet<C>>)", "name": "unionRangeSets", "arg_nums": 1, "params": [{"name": "rangeSets", "type": "Collection<ImmutableRangeSet<C>>"}], "return_type": "ImmutableRangeSet<C>", "signature": "private static <C extends Comparable<C>> ImmutableRangeSet<C> unionRangeSets(\n      Collection<ImmutableRangeSet<C>> rangeSets)", "original_string": "  private static <C extends Comparable<C>> ImmutableRangeSet<C> unionRangeSets(\n      Collection<ImmutableRangeSet<C>> rangeSets) {\n    return rangeSets.stream().reduce(ImmutableRangeSet.of(),\n        ImmutableRangeSet::union);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "ImmutableRangeSet<C>", "classes": []}, "docstring": " Unions a collection of {@link RangeSet} into one.\n\n@see ImmutableRangeSet#union(RangeSet)"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Pair<Core.Exp, Core.Exp>]reduceAnd(TypeSystem,PairList<Core.Exp, Core.Exp>)", "name": "reduceAnd", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "extentFilters", "type": "PairList<Core.Exp, Core.Exp>"}], "return_type": "Pair<Core.Exp, Core.Exp>", "signature": "static Pair<Core.Exp, Core.Exp> reduceAnd(TypeSystem typeSystem,\n      PairList<Core.Exp, Core.Exp> extentFilters)", "original_string": "  static Pair<Core.Exp, Core.Exp> reduceAnd(TypeSystem typeSystem,\n      PairList<Core.Exp, Core.Exp> extentFilters) {\n    if (extentFilters.isEmpty()) {\n      // Empty list would require us to create an infinite extent, but we\n      // don't know the type. Caller must ensure that the list is non-empty.\n      throw new IllegalArgumentException();\n    }\n    final List<Core.Exp> extents = new ArrayList<>();\n    core.flattenAnds(extentFilters.leftList(), extents::add);\n    final Pair<Core.Exp, List<Core.Exp>> pair =\n        core.intersectExtents(typeSystem, extents);\n    return Pair.of(pair.left,\n        core.andAlso(typeSystem, extentFilters.rightList()));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Pair<Core.Exp, Core.Exp>", "classes": []}, "docstring": " Reduces a list of extent-filter pairs [e0, f0, e1, f1, ...]\nto an extent-filter pair [e0 intersect e1 ..., f0 andalso f1 ...].\n\n<p>If any of the e<sub>i</sub> are calls to\n{@link BuiltIn#Z_EXTENT extent}, merges them into a single extent.\nFor example, in\n\n<blockquote><pre>{@code\n[extent \"int: (0, inf)\", x > 0,\n  x elem primes, isPrime x,\n  extent \"int: (-inf, 10)\", x < 10]\n}</pre></blockquote>\n\n<p>the extents for \"(0, inf)\" and \"(-inf, 10)\" are merged into\nextent \"(0, 10)\":\n\n<blockquote><pre>{@code\n(extent \"int: (0, 10)\" intersect primes,\n  x > 0 andalso isPrime x andalso x < 10)\n}</pre></blockquote>\n"}, {"uris": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents.[Pair<Core.Exp, Core.Exp>]reduceOr(TypeSystem,PairList<Core.Exp, Core.Exp>)", "name": "reduceOr", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "extentFilters", "type": "PairList<Core.Exp, Core.Exp>"}], "return_type": "Pair<Core.Exp, Core.Exp>", "signature": "static Pair<Core.Exp, Core.Exp> reduceOr(TypeSystem typeSystem,\n      PairList<Core.Exp, Core.Exp> extentFilters)", "original_string": "  static Pair<Core.Exp, Core.Exp> reduceOr(TypeSystem typeSystem,\n      PairList<Core.Exp, Core.Exp> extentFilters) {\n    return Pair.of(core.union(typeSystem, extentFilters.leftList()),\n        core.orElse(typeSystem, extentFilters.rightList()));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Extents.java", "class_name": "Extents", "class_uri": "src/main/java/net/hydromatic/morel/compile/Extents.java.Extents", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Pair<Core.Exp, Core.Exp>", "classes": []}, "docstring": " Reduces a list of extent-filter pairs [e0, f0, e1, f1, ...]\nto an extent-filter pair [e0 union e1 ..., f0 orelse f1 ...]."}, {"uris": "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException.[]CompileException(String,boolean,Pos)", "name": "CompileException", "arg_nums": 3, "params": [{"name": "message", "type": "String"}, {"name": "warning", "type": "boolean"}, {"name": "pos", "type": "Pos"}], "return_type": "", "signature": "public CompileException(String message, boolean warning, Pos pos)", "original_string": "  public CompileException(String message, boolean warning, Pos pos) {\n    super(message);\n    this.warning = warning;\n    this.pos = pos;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CompileException.java", "class_name": "CompileException", "class_uri": "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return super.toString() + \" at \" + pos;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CompileException.java", "class_name": "CompileException", "class_uri": "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException.[Pos]pos()", "name": "pos", "arg_nums": 0, "params": [], "return_type": "Pos", "signature": "@Override public Pos pos()", "original_string": "  @Override public Pos pos() {\n    return pos;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CompileException.java", "class_name": "CompileException", "class_uri": "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException.[StringBuilder]describeTo(StringBuilder)", "name": "describeTo", "arg_nums": 1, "params": [{"name": "buf", "type": "StringBuilder"}], "return_type": "StringBuilder", "signature": "public StringBuilder describeTo(StringBuilder buf)", "original_string": "  public StringBuilder describeTo(StringBuilder buf) {\n    return pos.describeTo(buf)\n        .append(warning ? \" Warning: \" : \" Error: \")\n        .append(getMessage());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/CompileException.java", "class_name": "CompileException", "class_uri": "src/main/java/net/hydromatic/morel/compile/CompileException.java.CompileException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[]Resolver(TypeMap,NameGenerator,Map<Pair<Core.NamedPat, Type>, Core.NamedPat>,Environment,Session)", "name": "Resolver", "arg_nums": 5, "params": [{"name": "typeMap", "type": "TypeMap"}, {"name": "nameGenerator", "type": "NameGenerator"}, {"name": "variantIdMap", "type": "Map<Pair<Core.NamedPat, Type>, Core.NamedPat>"}, {"name": "env", "type": "Environment"}, {"name": "session", "type": "Session"}], "return_type": "", "signature": "private Resolver(TypeMap typeMap, NameGenerator nameGenerator,\n      Map<Pair<Core.NamedPat, Type>, Core.NamedPat> variantIdMap,\n      Environment env, @Nullable Session session)", "original_string": "  private Resolver(TypeMap typeMap, NameGenerator nameGenerator,\n      Map<Pair<Core.NamedPat, Type>, Core.NamedPat> variantIdMap,\n      Environment env, @Nullable Session session) {\n    this.typeMap = typeMap;\n    this.nameGenerator = nameGenerator;\n    this.variantIdMap = variantIdMap;\n    this.env = env;\n    this.session = session;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Resolver]of(TypeMap,Environment,Session)", "name": "of", "arg_nums": 3, "params": [{"name": "typeMap", "type": "TypeMap"}, {"name": "env", "type": "Environment"}, {"name": "session", "type": "Session"}], "return_type": "Resolver", "signature": "public static Resolver of(TypeMap typeMap, Environment env,\n      @Nullable Session session)", "original_string": "  public static Resolver of(TypeMap typeMap, Environment env,\n      @Nullable Session session) {\n    return new Resolver(typeMap, new NameGenerator(), new HashMap<>(), env,\n        session);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Resolver", "classes": []}, "docstring": " Creates a root Resolver."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Resolver]withEnv(Environment)", "name": "withEnv", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "Resolver", "signature": "public Resolver withEnv(Environment env)", "original_string": "  public Resolver withEnv(Environment env) {\n    return env == this.env ? this\n        : new Resolver(typeMap, nameGenerator, variantIdMap, env, session);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Resolver", "classes": []}, "docstring": " Binds a Resolver to a new environment."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Resolver]withEnv(Iterable<Binding>)", "name": "withEnv", "arg_nums": 1, "params": [{"name": "bindings", "type": "Iterable<Binding>"}], "return_type": "Resolver", "signature": "public final Resolver withEnv(Iterable<Binding> bindings)", "original_string": "  public final Resolver withEnv(Iterable<Binding> bindings) {\n    return withEnv(Environments.bind(env, bindings));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "Resolver", "classes": []}, "docstring": " Binds a Resolver to an environment that consists of the current\nenvironment plus some bindings."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Decl]toCore(Ast.Decl)", "name": "toCore", "arg_nums": 1, "params": [{"name": "node", "type": "Ast.Decl"}], "return_type": "Core.Decl", "signature": "public Core.Decl toCore(Ast.Decl node)", "original_string": "  public Core.Decl toCore(Ast.Decl node) {\n    switch (node.op) {\n    case VAL_DECL:\n      return toCore((Ast.ValDecl) node);\n\n    case DATATYPE_DECL:\n      return toCore((Ast.DatatypeDecl) node);\n\n    default:\n      throw new AssertionError(\"unknown decl [\" + node.op + \", \" + node + \"]\");\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Core.Decl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.ValDecl]toCore(Ast.ValDecl)", "name": "toCore", "arg_nums": 1, "params": [{"name": "valDecl", "type": "Ast.ValDecl"}], "return_type": "Core.ValDecl", "signature": "public Core.ValDecl toCore(Ast.ValDecl valDecl)", "original_string": "  public Core.ValDecl toCore(Ast.ValDecl valDecl) {\n    final List<Binding> bindings = new ArrayList<>(); // discard\n    final ResolvedValDecl resolvedValDecl = resolveValDecl(valDecl, bindings);\n    Core.NonRecValDecl nonRecValDecl =\n        core.nonRecValDecl(resolvedValDecl.patExps.get(0).pos,\n            resolvedValDecl.pat, resolvedValDecl.exp);\n    return resolvedValDecl.rec\n        ? core.recValDecl(ImmutableList.of(nonRecValDecl))\n        : nonRecValDecl;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Core.ValDecl", "classes": []}, "docstring": " Converts a simple {@link net.hydromatic.morel.ast.Ast.ValDecl},\nof the form {@code val v = e},\nto a Core {@link net.hydromatic.morel.ast.Core.ValDecl}.\n\n<p>Declarations such as {@code val (x, y) = (1, 2)}\nand {@code val emp :: rest = emps} are considered complex,\nand are not handled by this method.\n\n<p>Likewise recursive declarations."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.DatatypeDecl]toCore(Ast.DatatypeDecl)", "name": "toCore", "arg_nums": 1, "params": [{"name": "datatypeDecl", "type": "Ast.DatatypeDecl"}], "return_type": "Core.DatatypeDecl", "signature": "public Core.DatatypeDecl toCore(Ast.DatatypeDecl datatypeDecl)", "original_string": "  public Core.DatatypeDecl toCore(Ast.DatatypeDecl datatypeDecl) {\n    final List<Binding> bindings = new ArrayList<>(); // populated, never read\n    final ResolvedDatatypeDecl resolvedDatatypeDecl =\n        resolveDatatypeDecl(datatypeDecl, bindings);\n    return resolvedDatatypeDecl.toDecl();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Core.DatatypeDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[ResolvedDecl]resolve(Ast.Decl,List<Binding>)", "name": "resolve", "arg_nums": 2, "params": [{"name": "decl", "type": "Ast.Decl"}, {"name": "bindings", "type": "List<Binding>"}], "return_type": "ResolvedDecl", "signature": "private ResolvedDecl resolve(Ast.Decl decl, List<Binding> bindings)", "original_string": "  private ResolvedDecl resolve(Ast.Decl decl, List<Binding> bindings) {\n    if (decl instanceof Ast.DatatypeDecl) {\n      return resolveDatatypeDecl((Ast.DatatypeDecl) decl, bindings);\n    } else {\n      return resolveValDecl((Ast.ValDecl) decl, bindings);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ResolvedDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[ResolvedDatatypeDecl]resolveDatatypeDecl(Ast.DatatypeDecl,List<Binding>)", "name": "resolveDatatypeDecl", "arg_nums": 2, "params": [{"name": "decl", "type": "Ast.DatatypeDecl"}, {"name": "bindings", "type": "List<Binding>"}], "return_type": "ResolvedDatatypeDecl", "signature": "private ResolvedDatatypeDecl resolveDatatypeDecl(Ast.DatatypeDecl decl,\n      List<Binding> bindings)", "original_string": "  private ResolvedDatatypeDecl resolveDatatypeDecl(Ast.DatatypeDecl decl,\n      List<Binding> bindings) {\n    final List<DataType> dataTypes = new ArrayList<>();\n    for (Ast.DatatypeBind bind : decl.binds) {\n      final DataType dataType = toCore(bind);\n      dataTypes.add(dataType);\n      dataType.typeConstructors.keySet().forEach(name ->\n          bindings.add(typeMap.typeSystem.bindTyCon(dataType, name)));\n    }\n    return new ResolvedDatatypeDecl(ImmutableList.copyOf(dataTypes));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ResolvedDatatypeDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[ResolvedValDecl]resolveValDecl(Ast.ValDecl,List<Binding>)", "name": "resolveValDecl", "arg_nums": 2, "params": [{"name": "valDecl", "type": "Ast.ValDecl"}, {"name": "bindings", "type": "List<Binding>"}], "return_type": "ResolvedValDecl", "signature": "private ResolvedValDecl resolveValDecl(Ast.ValDecl valDecl,\n      List<Binding> bindings)", "original_string": "  private ResolvedValDecl resolveValDecl(Ast.ValDecl valDecl,\n      List<Binding> bindings) {\n    final boolean composite = valDecl.valBinds.size() > 1;\n    final Map<Ast.Pat, Ast.Exp> matches = new LinkedHashMap<>();\n    valDecl.valBinds.forEach(valBind ->\n        flatten(matches, composite, valBind.pat, valBind.exp));\n\n    final List<PatExp> patExps = new ArrayList<>();\n    if (valDecl.rec) {\n      final List<Core.Pat> pats = new ArrayList<>();\n      matches.forEach((pat, exp) -> pats.add(toCore(pat)));\n      pats.forEach(p -> Compiles.acceptBinding(typeMap.typeSystem, p, bindings));\n      final Resolver r = withEnv(bindings);\n      final Iterator<Core.Pat> patIter = pats.iterator();\n      matches.forEach((pat, exp) ->\n          patExps.add(\n              new PatExp(patIter.next(), r.toCore(exp),\n                  pat.pos.plus(exp.pos))));\n    } else {\n      matches.forEach((pat, exp) ->\n          patExps.add(\n              new PatExp(toCore(pat), toCore(exp), pat.pos.plus(exp.pos))));\n      patExps.forEach(x ->\n          Compiles.acceptBinding(typeMap.typeSystem, x.pat, bindings));\n    }\n\n    // Convert recursive to non-recursive if the bound variable is not\n    // referenced in its definition. For example,\n    //   val rec inc = fn i => i + 1\n    // can be converted to\n    //   val inc = fn i => i + 1\n    // because \"i + 1\" does not reference \"inc\".\n    boolean rec = valDecl.rec\n        && references(patExps);\n    // Transform \"let val v1 = E1 and v2 = E2 in E end\"\n    // to \"let val v = (v1, v2) in case v of (E1, E2) => E end\"\n    final Core.Pat pat0;\n    final Core.Exp exp;\n    if (composite) {\n      final List<Core.Pat> pats = transform(patExps, x -> x.pat);\n      final List<Core.Exp> exps = transform(patExps, x -> x.exp);\n      pat0 = core.tuplePat(typeMap.typeSystem, pats);\n      exp = core.tuple((RecordLikeType) pat0.type, exps);\n    } else {\n      final PatExp patExp = patExps.get(0);\n      pat0 = patExp.pat;\n      exp = patExp.exp;\n    }\n    final Core.NamedPat pat;\n    if (pat0 instanceof Core.NamedPat) {\n      pat = (Core.NamedPat) pat0;\n    } else {\n      pat = core.asPat(exp.type, \"it\", nameGenerator, pat0);\n    }\n\n    return new ResolvedValDecl(rec, ImmutableList.copyOf(patExps), pat, exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ResolvedValDecl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[boolean]references(List<PatExp>)", "name": "references", "arg_nums": 1, "params": [{"name": "patExps", "type": "List<PatExp>"}], "return_type": "boolean", "signature": "private boolean references(List<PatExp> patExps)", "original_string": "  private boolean references(List<PatExp> patExps) {\n    final Set<Core.NamedPat> refSet = new HashSet<>();\n    final ReferenceFinder finder =\n        new ReferenceFinder(typeMap.typeSystem, Environments.empty(), refSet,\n            new ArrayDeque<>());\n    patExps.forEach(x -> x.exp.accept(finder));\n\n    final Set<Core.NamedPat> defSet = new HashSet<>();\n    final Visitor v = new Visitor() {\n      @Override protected void visit(Core.IdPat idPat) {\n        defSet.add(idPat);\n      }\n    };\n    patExps.forEach(x -> x.pat.accept(v));\n\n    return intersects(refSet, defSet);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether any of the expressions in {@code exps} references\nand of the variables defined in {@code pats}.\n\n<p>This method is used to decide whether it is safe to convert a recursive\ndeclaration into a non-recursive one."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[DataType]toCore(Ast.DatatypeBind)", "name": "toCore", "arg_nums": 1, "params": [{"name": "bind", "type": "Ast.DatatypeBind"}], "return_type": "DataType", "signature": "private DataType toCore(Ast.DatatypeBind bind)", "original_string": "  private DataType toCore(Ast.DatatypeBind bind) {\n    final Type type = typeMap.typeSystem.lookup(bind.name.name);\n    return type instanceof ForallType\n        ? (DataType) ((ForallType) type).type\n        : (DataType) type;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "DataType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCore(Ast.Exp)", "name": "toCore", "arg_nums": 1, "params": [{"name": "exp", "type": "Ast.Exp"}], "return_type": "Core.Exp", "signature": "private Core.Exp toCore(Ast.Exp exp)", "original_string": "  private Core.Exp toCore(Ast.Exp exp) {\n    switch (exp.op) {\n    case BOOL_LITERAL:\n      return core.boolLiteral((Boolean) ((Ast.Literal) exp).value);\n    case CHAR_LITERAL:\n      return core.charLiteral((Character) ((Ast.Literal) exp).value);\n    case INT_LITERAL:\n      return core.intLiteral((BigDecimal) ((Ast.Literal) exp).value);\n    case REAL_LITERAL:\n      return ((Ast.Literal) exp).value instanceof BigDecimal\n          ? core.realLiteral((BigDecimal) ((Ast.Literal) exp).value)\n          : core.realLiteral((Float) ((Ast.Literal) exp).value);\n    case STRING_LITERAL:\n      return core.stringLiteral((String) ((Ast.Literal) exp).value);\n    case UNIT_LITERAL:\n      return core.unitLiteral();\n    case ANNOTATED_EXP:\n      return toCore(((Ast.AnnotatedExp) exp).exp);\n    case ID:\n      return toCore((Ast.Id) exp);\n    case ANDALSO:\n    case ORELSE:\n      return toCore((Ast.InfixCall) exp);\n    case APPLY:\n      return toCore((Ast.Apply) exp);\n    case FN:\n      return toCore((Ast.Fn) exp);\n    case IF:\n      return toCore((Ast.If) exp);\n    case CASE:\n      return toCore((Ast.Case) exp);\n    case LET:\n      return toCore((Ast.Let) exp);\n    case FROM:\n      return toCore((Ast.From) exp);\n    case TUPLE:\n      return toCore((Ast.Tuple) exp);\n    case RECORD:\n      return toCore((Ast.Record) exp);\n    case RECORD_SELECTOR:\n      return toCore((Ast.RecordSelector) exp);\n    case LIST:\n      return toCore((Ast.ListExp) exp);\n    case FROM_EQ:\n      return toCoreFromEq(((Ast.PrefixCall) exp).a);\n    default:\n      throw new AssertionError(\"unknown exp \" + exp.op);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Id]toCore(Ast.Id)", "name": "toCore", "arg_nums": 1, "params": [{"name": "id", "type": "Ast.Id"}], "return_type": "Core.Id", "signature": "private Core.Id toCore(Ast.Id id)", "original_string": "  private Core.Id toCore(Ast.Id id) {\n    final Binding binding = env.getOpt(id.name);\n    checkNotNull(binding, \"not found\", id);\n    final Core.NamedPat idPat = getIdPat(id, binding);\n    return core.id(idPat);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Id", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.IdPat]toCorePat(Ast.Id)", "name": "toCorePat", "arg_nums": 1, "params": [{"name": "id", "type": "Ast.Id"}], "return_type": "Core.IdPat", "signature": "private Core.IdPat toCorePat(Ast.Id id)", "original_string": "  private Core.IdPat toCorePat(Ast.Id id) {\n    final Type type = typeMap.getType(id);\n    return core.idPat(type, id.name, nameGenerator);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.IdPat", "classes": []}, "docstring": " Converts an id in a declaration to Core."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.NamedPat]getIdPat(Ast.Id,Binding)", "name": "getIdPat", "arg_nums": 2, "params": [{"name": "id", "type": "Ast.Id"}, {"name": "binding", "type": "Binding"}], "return_type": "Core.NamedPat", "signature": "private Core.NamedPat getIdPat(Ast.Id id, Binding binding)", "original_string": "  private Core.NamedPat getIdPat(Ast.Id id, Binding binding) {\n    final Type type = typeMap.getType(id);\n    if (type == binding.id.type) {\n      return binding.id;\n    }\n    // The required type is different from the binding type, presumably more\n    // specific. Create a new IdPat, reusing an existing IdPat if there was\n    // one for the same type.\n    return variantIdMap.computeIfAbsent(Pair.of(binding.id, type),\n        k -> k.left.withType(k.right));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.NamedPat", "classes": []}, "docstring": " Converts an Id that is a reference to a variable into an IdPat that\nrepresents its declaration."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Tuple]toCore(Ast.Tuple)", "name": "toCore", "arg_nums": 1, "params": [{"name": "tuple", "type": "Ast.Tuple"}], "return_type": "Core.Tuple", "signature": "private Core.Tuple toCore(Ast.Tuple tuple)", "original_string": "  private Core.Tuple toCore(Ast.Tuple tuple) {\n    return core.tuple((RecordLikeType) typeMap.getType(tuple),\n        transformEager(tuple.args, this::toCore));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Tuple", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Tuple]toCore(Ast.Record)", "name": "toCore", "arg_nums": 1, "params": [{"name": "record", "type": "Ast.Record"}], "return_type": "Core.Tuple", "signature": "private Core.Tuple toCore(Ast.Record record)", "original_string": "  private Core.Tuple toCore(Ast.Record record) {\n    return core.tuple((RecordLikeType) typeMap.getType(record),\n        transformEager(record.args(), this::toCore));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Tuple", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCore(Ast.ListExp)", "name": "toCore", "arg_nums": 1, "params": [{"name": "list", "type": "Ast.ListExp"}], "return_type": "Core.Exp", "signature": "private Core.Exp toCore(Ast.ListExp list)", "original_string": "  private Core.Exp toCore(Ast.ListExp list) {\n    final ListType type = (ListType) typeMap.getType(list);\n    return core.apply(list.pos, type,\n        core.functionLiteral(typeMap.typeSystem, BuiltIn.Z_LIST),\n        core.tuple(typeMap.typeSystem, null,\n            transformEager(list.args, this::toCore)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCoreFromEq(Ast.Exp)", "name": "toCoreFromEq", "arg_nums": 1, "params": [{"name": "exp", "type": "Ast.Exp"}], "return_type": "Core.Exp", "signature": "private Core.Exp toCoreFromEq(Ast.Exp exp)", "original_string": "  private Core.Exp toCoreFromEq(Ast.Exp exp) {\n    final Type type = typeMap.getType(exp);\n    final ListType listType = typeMap.typeSystem.listType(type);\n    return core.apply(exp.pos, listType,\n        core.functionLiteral(typeMap.typeSystem, BuiltIn.Z_LIST),\n        core.tuple(typeMap.typeSystem, toCore(exp)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": " Translates \"x\" in \"from e = x\". Desugar to the same as if they had\nwritten \"from e in [x]\"."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Apply]toCore(Ast.Apply)", "name": "toCore", "arg_nums": 1, "params": [{"name": "apply", "type": "Ast.Apply"}], "return_type": "Core.Apply", "signature": "private Core.Apply toCore(Ast.Apply apply)", "original_string": "  private Core.Apply toCore(Ast.Apply apply) {\n    Core.Exp coreArg = toCore(apply.arg);\n    Type type = typeMap.getType(apply);\n    Core.Exp coreFn;\n    if (apply.fn.op == Op.RECORD_SELECTOR) {\n      final Ast.RecordSelector recordSelector = (Ast.RecordSelector) apply.fn;\n      RecordLikeType recordType = (RecordLikeType) coreArg.type;\n      if (coreArg.type.isProgressive()) {\n        Object o = valueOf(env, coreArg);\n        if (o instanceof TypedValue) {\n          final TypedValue typedValue = (TypedValue) o;\n          TypedValue typedValue2 =\n              typedValue.discoverField(typeMap.typeSystem, recordSelector.name);\n          recordType =\n              (RecordLikeType) typedValue2.typeKey().toType(typeMap.typeSystem);\n        }\n      }\n      coreFn =\n          core.recordSelector(typeMap.typeSystem, recordType,\n              recordSelector.name);\n      if (type.op() == Op.TY_VAR\n              && coreFn.type.op() == Op.FUNCTION_TYPE\n          || type.isProgressive()\n          || type instanceof ListType\n              && ((ListType) type).elementType.isProgressive()) {\n        // If we are dereferencing a field in a progressive type, the type\n        // available now may be more precise than the deduced type.\n        type = ((FnType) coreFn.type).resultType;\n      }\n    } else {\n      coreFn = toCore(apply.fn);\n    }\n    return core.apply(apply.pos, type, coreFn, coreArg);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Apply", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Object]valueOf(Environment,Core.Exp)", "name": "valueOf", "arg_nums": 2, "params": [{"name": "env", "type": "Environment"}, {"name": "exp", "type": "Core.Exp"}], "return_type": "Object", "signature": "static Object valueOf(Environment env, Core.Exp exp)", "original_string": "  static Object valueOf(Environment env, Core.Exp exp) {\n    if (exp instanceof Core.Literal) {\n      return ((Core.Literal) exp).value;\n    }\n    if (exp.op == Op.ID) {\n      final Core.Id id = (Core.Id) exp;\n      Binding binding = env.getOpt(id.idPat);\n      if (binding != null) {\n        return binding.value;\n      }\n    }\n    if (exp.op == Op.APPLY) {\n      final Core.Apply apply = (Core.Apply) exp;\n      if (apply.fn.op == Op.RECORD_SELECTOR) {\n        final Core.RecordSelector recordSelector =\n            (Core.RecordSelector) apply.fn;\n        final Object o = valueOf(env, apply.arg);\n        if (o instanceof TypedValue) {\n          return ((TypedValue) o).fieldValueAs(recordSelector.slot,\n              Object.class);\n        } else if (o instanceof List) {\n          @SuppressWarnings(\"unchecked\") List<Object> list = (List<Object>) o;\n          return list.get(recordSelector.slot);\n        }\n      }\n    }\n    return null; // not constant\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.RecordSelector]toCore(Ast.RecordSelector)", "name": "toCore", "arg_nums": 1, "params": [{"name": "recordSelector", "type": "Ast.RecordSelector"}], "return_type": "Core.RecordSelector", "signature": "private Core.RecordSelector toCore(Ast.RecordSelector recordSelector)", "original_string": "  private Core.RecordSelector toCore(Ast.RecordSelector recordSelector) {\n    final FnType fnType = (FnType) typeMap.getType(recordSelector);\n    return core.recordSelector(typeMap.typeSystem,\n        (RecordLikeType) fnType.paramType, recordSelector.name);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.RecordSelector", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Apply]toCore(Ast.InfixCall)", "name": "toCore", "arg_nums": 1, "params": [{"name": "call", "type": "Ast.InfixCall"}], "return_type": "Core.Apply", "signature": "private Core.Apply toCore(Ast.InfixCall call)", "original_string": "  private Core.Apply toCore(Ast.InfixCall call) {\n    Core.Exp core0 = toCore(call.a0);\n    Core.Exp core1 = toCore(call.a1);\n    final BuiltIn builtIn = toBuiltIn(call.op);\n    return core.apply(call.pos, typeMap.getType(call),\n        core.functionLiteral(typeMap.typeSystem, builtIn),\n        core.tuple(typeMap.typeSystem, core0, core1));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Apply", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[BuiltIn]toBuiltIn(Op)", "name": "toBuiltIn", "arg_nums": 1, "params": [{"name": "op", "type": "Op"}], "return_type": "BuiltIn", "signature": "private BuiltIn toBuiltIn(Op op)", "original_string": "  private BuiltIn toBuiltIn(Op op) {\n    return OP_BUILT_IN_MAP.get(op);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "BuiltIn", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Fn]toCore(Ast.Fn)", "name": "toCore", "arg_nums": 1, "params": [{"name": "fn", "type": "Ast.Fn"}], "return_type": "Core.Fn", "signature": "private Core.Fn toCore(Ast.Fn fn)", "original_string": "  private Core.Fn toCore(Ast.Fn fn) {\n    final FnType type = (FnType) typeMap.getType(fn);\n    final List<Core.Match> matchList = transformEager(fn.matchList, this::toCore);\n    return core.fn(fn.pos, type, matchList, nameGenerator);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Fn", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Case]toCore(Ast.If)", "name": "toCore", "arg_nums": 1, "params": [{"name": "if_", "type": "Ast.If"}], "return_type": "Core.Case", "signature": "private Core.Case toCore(Ast.If if_)", "original_string": "  private Core.Case toCore(Ast.If if_) {\n    return core.ifThenElse(toCore(if_.condition), toCore(if_.ifTrue),\n        toCore(if_.ifFalse));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Case", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Case]toCore(Ast.Case)", "name": "toCore", "arg_nums": 1, "params": [{"name": "case_", "type": "Ast.Case"}], "return_type": "Core.Case", "signature": "private Core.Case toCore(Ast.Case case_)", "original_string": "  private Core.Case toCore(Ast.Case case_) {\n    return core.caseOf(case_.pos, typeMap.getType(case_), toCore(case_.exp),\n        transformEager(case_.matchList, this::toCore));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Case", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCore(Ast.Let)", "name": "toCore", "arg_nums": 1, "params": [{"name": "let", "type": "Ast.Let"}], "return_type": "Core.Exp", "signature": "private Core.Exp toCore(Ast.Let let)", "original_string": "  private Core.Exp toCore(Ast.Let let) {\n    return flattenLet(let.decls, let.exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]flattenLet(List<Ast.Decl>,Ast.Exp)", "name": "flattenLet", "arg_nums": 2, "params": [{"name": "decls", "type": "List<Ast.Decl>"}, {"name": "exp", "type": "Ast.Exp"}], "return_type": "Core.Exp", "signature": "private Core.Exp flattenLet(List<Ast.Decl> decls, Ast.Exp exp)", "original_string": "  private Core.Exp flattenLet(List<Ast.Decl> decls, Ast.Exp exp) {\n    //   flattenLet(val x :: xs = [1, 2, 3] and (y, z) = (2, 4), x + y)\n    // becomes\n    //   let v = ([1, 2, 3], (2, 4)) in case v of (x :: xs, (y, z)) => x + y end\n    if (decls.isEmpty()) {\n      return toCore(exp);\n    }\n    final Ast.Decl decl = decls.get(0);\n    final List<Binding> bindings = new ArrayList<>();\n    final ResolvedDecl resolvedDecl = resolve(decl, bindings);\n    final Core.Exp e2 = withEnv(bindings).flattenLet(skip(decls), exp);\n    return resolvedDecl.toExp(e2);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[void]flatten(Map<Ast.Pat, Ast.Exp>,boolean,Ast.Pat,Ast.Exp)", "name": "flatten", "arg_nums": 4, "params": [{"name": "matches", "type": "Map<Ast.Pat, Ast.Exp>"}, {"name": "flatten", "type": "boolean"}, {"name": "pat", "type": "Ast.Pat"}, {"name": "exp", "type": "Ast.Exp"}], "return_type": "void", "signature": "static void flatten(Map<Ast.Pat, Ast.Exp> matches, boolean flatten,\n      Ast.Pat pat, Ast.Exp exp)", "original_string": "  static void flatten(Map<Ast.Pat, Ast.Exp> matches, boolean flatten,\n      Ast.Pat pat, Ast.Exp exp) {\n    if (flatten && pat.op == Op.TUPLE_PAT && exp.op == Op.TUPLE) {\n      forEach(((Ast.TuplePat) pat).args, ((Ast.Tuple) exp).args,\n          (p, e) -> flatten(matches, true, p, e));\n    } else {\n      matches.put(pat, exp);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Pat]toCore(Ast.Pat)", "name": "toCore", "arg_nums": 1, "params": [{"name": "pat", "type": "Ast.Pat"}], "return_type": "Core.Pat", "signature": "private Core.Pat toCore(Ast.Pat pat)", "original_string": "  private Core.Pat toCore(Ast.Pat pat) {\n    final Type type = typeMap.getType(pat);\n    return toCore(pat, type, type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Pat]toCore(Ast.Pat,Type)", "name": "toCore", "arg_nums": 2, "params": [{"name": "pat", "type": "Ast.Pat"}, {"name": "targetType", "type": "Type"}], "return_type": "Core.Pat", "signature": "private Core.Pat toCore(Ast.Pat pat, Type targetType)", "original_string": "  private Core.Pat toCore(Ast.Pat pat, Type targetType) {\n    final Type type = typeMap.getType(pat);\n    return toCore(pat, type, targetType);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Pat]toCore(Ast.Pat,Type,Type)", "name": "toCore", "arg_nums": 3, "params": [{"name": "pat", "type": "Ast.Pat"}, {"name": "type", "type": "Type"}, {"name": "targetType", "type": "Type"}], "return_type": "Core.Pat", "signature": "private Core.Pat toCore(Ast.Pat pat, Type type, Type targetType)", "original_string": "  private Core.Pat toCore(Ast.Pat pat, Type type, Type targetType) {\n    final TupleType tupleType;\n    switch (pat.op) {\n    case BOOL_LITERAL_PAT:\n    case CHAR_LITERAL_PAT:\n    case INT_LITERAL_PAT:\n    case REAL_LITERAL_PAT:\n    case STRING_LITERAL_PAT:\n      return core.literalPat(pat.op, type, ((Ast.LiteralPat) pat).value);\n\n    case WILDCARD_PAT:\n      return core.wildcardPat(type);\n\n    case ID_PAT:\n      final Ast.IdPat idPat = (Ast.IdPat) pat;\n      if (type.op() == Op.DATA_TYPE\n          && ((DataType) type).typeConstructors.containsKey(idPat.name)) {\n        return core.con0Pat((DataType) type, idPat.name);\n      }\n      return core.idPat(type, idPat.name, nameGenerator);\n\n    case AS_PAT:\n      final Ast.AsPat asPat = (Ast.AsPat) pat;\n      return core.asPat(type, asPat.id.name, nameGenerator, toCore(asPat.pat));\n\n    case ANNOTATED_PAT:\n      // There is no annotated pat in core, because all patterns have types.\n      final Ast.AnnotatedPat annotatedPat = (Ast.AnnotatedPat) pat;\n      return toCore(annotatedPat.pat);\n\n    case CON_PAT:\n      final Ast.ConPat conPat = (Ast.ConPat) pat;\n      return core.conPat(type, conPat.tyCon.name, toCore(conPat.pat));\n\n    case CON0_PAT:\n      final Ast.Con0Pat con0Pat = (Ast.Con0Pat) pat;\n      return core.con0Pat((DataType) type, con0Pat.tyCon.name);\n\n    case CONS_PAT:\n      // Cons \"::\" is an infix operator in Ast, a type constructor in Core, so\n      // Ast.InfixPat becomes Core.ConPat.\n      final Ast.InfixPat infixPat = (Ast.InfixPat) pat;\n      final Type type0 = typeMap.getType(infixPat.p0);\n      final Type type1 = typeMap.getType(infixPat.p1);\n      tupleType = typeMap.typeSystem.tupleType(type0, type1);\n      return core.consPat(type, BuiltIn.OP_CONS.mlName,\n          core.tuplePat(tupleType, toCore(infixPat.p0), toCore(infixPat.p1)));\n\n    case LIST_PAT:\n      final Ast.ListPat listPat = (Ast.ListPat) pat;\n      return core.listPat(type, transformEager(listPat.args, this::toCore));\n\n    case RECORD_PAT:\n      final RecordType recordType = (RecordType) targetType;\n      final Ast.RecordPat recordPat = (Ast.RecordPat) pat;\n      final ImmutableList.Builder<Core.Pat> args = ImmutableList.builder();\n      recordType.argNameTypes.forEach((label, argType) -> {\n        final Ast.Pat argPat = recordPat.args.get(label);\n        final Core.Pat corePat = argPat != null ? toCore(argPat)\n            : core.wildcardPat(argType);\n        args.add(corePat);\n      });\n      return core.recordPat(recordType, args.build());\n\n    case TUPLE_PAT:\n      final Ast.TuplePat tuplePat = (Ast.TuplePat) pat;\n      final List<Core.Pat> argList = transformEager(tuplePat.args, this::toCore);\n      return core.tuplePat((RecordLikeType) type, argList);\n\n    default:\n      throw new AssertionError(\"unknown pat \" + pat.op);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Pat", "classes": []}, "docstring": " Converts a pattern to Core.\n\n<p>Expands a pattern if it is a record pattern that has an ellipsis\nor if the arguments are not in the same order as the labels in the type."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Match]toCore(Ast.Match)", "name": "toCore", "arg_nums": 1, "params": [{"name": "match", "type": "Ast.Match"}], "return_type": "Core.Match", "signature": "private Core.Match toCore(Ast.Match match)", "original_string": "  private Core.Match toCore(Ast.Match match) {\n    final Core.Pat pat = toCore(match.pat);\n    final List<Binding> bindings = new ArrayList<>();\n    Compiles.acceptBinding(typeMap.typeSystem, pat, bindings);\n    final Core.Exp exp = withEnv(bindings).toCore(match.exp);\n    return core.match(match.pos, pat, exp);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Match", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Exp]toCore(Ast.From)", "name": "toCore", "arg_nums": 1, "params": [{"name": "from", "type": "Ast.From"}], "return_type": "Core.Exp", "signature": "Core.Exp toCore(Ast.From from)", "original_string": "  Core.Exp toCore(Ast.From from) {\n    final Type type = typeMap.getType(from);\n    final Core.Exp coreFrom = new FromResolver().run(from);\n    checkArgument(subsumes(type, coreFrom.type()),\n        \"Conversion to core did not preserve type: expected [%s] \"\n            + \"actual [%s] from [%s]\", type, coreFrom.type, coreFrom);\n    return coreFrom;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Core.Exp", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[boolean]subsumes(Type,Type)", "name": "subsumes", "arg_nums": 2, "params": [{"name": "actualType", "type": "Type"}, {"name": "expectedType", "type": "Type"}], "return_type": "boolean", "signature": "private static boolean subsumes(Type actualType, Type expectedType)", "original_string": "  private static boolean subsumes(Type actualType, Type expectedType) {\n    switch (actualType.op()) {\n    case LIST:\n      if (expectedType.op() != Op.LIST) {\n        return false;\n      }\n      return subsumes(((ListType) actualType).elementType,\n          ((ListType) expectedType).elementType);\n    case RECORD_TYPE:\n      if (expectedType.op() != Op.RECORD_TYPE) {\n        return false;\n      }\n      if (actualType.isProgressive()) {\n        return true;\n      }\n      final SortedMap<String, Type> actualMap =\n          ((RecordType) actualType).argNameTypes();\n      final SortedMap<String, Type> expectedMap =\n          ((RecordType) expectedType).argNameTypes();\n      final Iterator<Map.Entry<String, Type>> actualIterator =\n          actualMap.entrySet().iterator();\n      final Iterator<Map.Entry<String, Type>> expectedIterator =\n          expectedMap.entrySet().iterator();\n      for (;;) {\n        if (actualIterator.hasNext()) {\n          if (!expectedIterator.hasNext()) {\n            // expected had fewer entries than actual\n            return false;\n          }\n        } else {\n          if (!expectedIterator.hasNext()) {\n            // expected and actual had same number of entries\n            return true;\n          }\n        }\n        final Map.Entry<String, Type> actual = actualIterator.next();\n        final Map.Entry<String, Type> expected = expectedIterator.next();\n        if (!actual.getKey().equals(expected.getKey())) {\n          return false;\n        }\n        if (!subsumes(actual.getValue(), expected.getValue())) {\n          return false;\n        }\n      }\n      // fall through\n    default:\n      return actualType.equals(expectedType);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " An actual type subsumes an expected type if it is equal\nor if progressive record types have been expanded."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.Aggregate]toCore(Ast.Aggregate,Collection<? extends Core.IdPat>)", "name": "toCore", "arg_nums": 2, "params": [{"name": "aggregate", "type": "Ast.Aggregate"}, {"name": "groupKeys", "type": "Collection<? extends Core.IdPat>"}], "return_type": "Core.Aggregate", "signature": "private Core.Aggregate toCore(Ast.Aggregate aggregate,\n      Collection<? extends Core.IdPat> groupKeys)", "original_string": "  private Core.Aggregate toCore(Ast.Aggregate aggregate,\n      Collection<? extends Core.IdPat> groupKeys) {\n    final Resolver resolver = withEnv(transform(groupKeys, Binding::of));\n    return core.aggregate(typeMap.getType(aggregate),\n        resolver.toCore(aggregate.aggregate),\n        aggregate.argument == null ? null : toCore(aggregate.argument));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.Aggregate", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver.[Core.OrderItem]toCore(Ast.OrderItem)", "name": "toCore", "arg_nums": 1, "params": [{"name": "orderItem", "type": "Ast.OrderItem"}], "return_type": "Core.OrderItem", "signature": "private Core.OrderItem toCore(Ast.OrderItem orderItem)", "original_string": "  private Core.OrderItem toCore(Ast.OrderItem orderItem) {\n    return core.orderItem(toCore(orderItem.exp), orderItem.direction);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Resolver.java", "class_name": "Resolver", "class_uri": "src/main/java/net/hydromatic/morel/compile/Resolver.java.Resolver", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Core.OrderItem", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[Analyzer]of(TypeSystem,Environment)", "name": "of", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}], "return_type": "Analyzer", "signature": "private static Analyzer of(TypeSystem typeSystem, Environment env)", "original_string": "  private static Analyzer of(TypeSystem typeSystem, Environment env) {\n    return new Analyzer(typeSystem, env, new HashMap<>(), new ArrayDeque<>());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Analyzer", "classes": []}, "docstring": " Creates an Analyzer."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[]Analyzer(TypeSystem,Environment,Map<Core.NamedPat, MutableUse>,Deque<FromContext>)", "name": "Analyzer", "arg_nums": 4, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "map", "type": "Map<Core.NamedPat, MutableUse>"}, {"name": "fromStack", "type": "Deque<FromContext>"}], "return_type": "", "signature": "private Analyzer(TypeSystem typeSystem, Environment env,\n      Map<Core.NamedPat, MutableUse> map, Deque<FromContext> fromStack)", "original_string": "  private Analyzer(TypeSystem typeSystem, Environment env,\n      Map<Core.NamedPat, MutableUse> map, Deque<FromContext> fromStack) {\n    super(typeSystem, env, fromStack);\n    this.map = map;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": " Private constructor."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[Analysis]analyze(TypeSystem,Environment,AstNode)", "name": "analyze", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "env", "type": "Environment"}, {"name": "node", "type": "AstNode"}], "return_type": "Analysis", "signature": "public static Analysis analyze(TypeSystem typeSystem, Environment env,\n      AstNode node)", "original_string": "  public static Analysis analyze(TypeSystem typeSystem, Environment env,\n      AstNode node) {\n    final Analyzer analyzer = of(typeSystem, env);\n\n    // Mark all top-level bindings so that they will not be removed\n    if (node instanceof Core.NonRecValDecl) {\n      analyzer.use(((Core.NonRecValDecl) node).pat).top = true;\n    }\n    node.accept(analyzer);\n    return analyzer.result();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Analysis", "classes": []}, "docstring": " Analyzes an expression."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[Analysis]result()", "name": "result", "arg_nums": 0, "params": [], "return_type": "Analysis", "signature": "private Analysis result()", "original_string": "  private Analysis result() {\n    final ImmutableMap.Builder<Core.NamedPat, Use> b = ImmutableMap.builder();\n    map.forEach((k, v) -> b.put(k, v.fix()));\n    return new Analysis(b.build());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Analysis", "classes": []}, "docstring": " Returns the result of an analysis."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[Analyzer]push(Environment)", "name": "push", "arg_nums": 1, "params": [{"name": "env", "type": "Environment"}], "return_type": "Analyzer", "signature": "@Override protected Analyzer push(Environment env)", "original_string": "  @Override protected Analyzer push(Environment env) {\n    return new Analyzer(typeSystem, env, map, fromStack);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Analyzer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[void]visit(Core.IdPat)", "name": "visit", "arg_nums": 1, "params": [{"name": "idPat", "type": "Core.IdPat"}], "return_type": "void", "signature": "@Override protected void visit(Core.IdPat idPat)", "original_string": "  @Override protected void visit(Core.IdPat idPat) {\n    use(idPat);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[void]visit(Core.Id)", "name": "visit", "arg_nums": 1, "params": [{"name": "id", "type": "Core.Id"}], "return_type": "void", "signature": "@Override protected void visit(Core.Id id)", "original_string": "  @Override protected void visit(Core.Id id) {\n    use(id.idPat).useCount++;\n    super.visit(id);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[MutableUse]use(Core.NamedPat)", "name": "use", "arg_nums": 1, "params": [{"name": "name", "type": "Core.NamedPat"}], "return_type": "MutableUse", "signature": "private MutableUse use(Core.NamedPat name)", "original_string": "  private MutableUse use(Core.NamedPat name) {\n    return map.computeIfAbsent(name, k -> new MutableUse());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "MutableUse", "classes": []}, "docstring": " Gets or creates a {@link MutableUse} for a given name."}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[void]visit(Core.NonRecValDecl)", "name": "visit", "arg_nums": 1, "params": [{"name": "valDecl", "type": "Core.NonRecValDecl"}], "return_type": "void", "signature": "@Override protected void visit(Core.NonRecValDecl valDecl)", "original_string": "  @Override protected void visit(Core.NonRecValDecl valDecl) {\n    super.visit(valDecl);\n    if (isAtom(valDecl.exp)) {\n      use(valDecl.pat).atomic = true;\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[boolean]isAtom(Core.Exp)", "name": "isAtom", "arg_nums": 1, "params": [{"name": "exp", "type": "Core.Exp"}], "return_type": "boolean", "signature": "private static boolean isAtom(Core.Exp exp)", "original_string": "  private static boolean isAtom(Core.Exp exp) {\n    switch (exp.op) {\n    case ID:\n    case BOOL_LITERAL:\n    case CHAR_LITERAL:\n    case INT_LITERAL:\n    case REAL_LITERAL:\n    case STRING_LITERAL:\n    case UNIT_LITERAL:\n      return true;\n    default:\n      return false;\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer.[void]visit(Core.Case)", "name": "visit", "arg_nums": 1, "params": [{"name": "case_", "type": "Core.Case"}], "return_type": "void", "signature": "@Override protected void visit(Core.Case case_)", "original_string": "  @Override protected void visit(Core.Case case_) {\n    case_.exp.accept(this);\n    if (case_.matchList.size() == 1) {\n      // When there is a single branch, we don't need to check for a single use\n      // on multiple branches, so we can expedite.\n      case_.matchList.get(0).accept(this);\n    } else {\n      // Create a multimap of all uses of bindings along the separate\n      // branches. Example:\n      //  case e of\n      //    1 => a + c\n      //  | 2 => a + b + a\n      //  | _ => c\n      //\n      // a has use counts [1, 2] and is therefore MULTI_UNSAFE\n      // b has use counts [1] and is therefore ONCE_SAFE\n      // c has use counts [1, 1] and is therefore MULTI_SAFE\n      final Multimap<Core.NamedPat, MutableUse> multimap =\n          HashMultimap.create();\n      final Map<Core.NamedPat, MutableUse> subMap = new HashMap<>();\n      final Analyzer analyzer =\n          new Analyzer(typeSystem, env, subMap, new ArrayDeque<>());\n      case_.matchList.forEach(e -> {\n        subMap.clear();\n        e.accept(analyzer);\n        subMap.forEach(multimap::put);\n      });\n      multimap.asMap().forEach((id, uses) -> {\n        final MutableUse baseUse = use(id);\n        int maxCount = MutableUse.max(uses);\n        if (uses.size() > 1) {\n          baseUse.parallel = true;\n        }\n        baseUse.useCount += maxCount;\n      });\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/Analyzer.java", "class_name": "Analyzer", "class_uri": "src/main/java/net/hydromatic/morel/compile/Analyzer.java.Analyzer", "attributes": {"modifiers": "@Override protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[]TypeMap(TypeSystem,Map<AstNode, Unifier.Term>,Unifier.Substitution)", "name": "TypeMap", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "nodeTypeTerms", "type": "Map<AstNode, Unifier.Term>"}, {"name": "substitution", "type": "Unifier.Substitution"}], "return_type": "", "signature": "TypeMap(TypeSystem typeSystem, Map<AstNode, Unifier.Term> nodeTypeTerms,\n      Unifier.Substitution substitution)", "original_string": "  TypeMap(TypeSystem typeSystem, Map<AstNode, Unifier.Term> nodeTypeTerms,\n      Unifier.Substitution substitution) {\n    this.typeSystem = requireNonNull(typeSystem);\n    this.nodeTypeTerms = ImmutableMap.copyOf(nodeTypeTerms);\n    this.substitution = requireNonNull(substitution.resolve());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeMap.java", "class_name": "TypeMap", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    final StringBuilder b = new StringBuilder();\n    b.append(\"terms:\\n\");\n    final List<Map.Entry<AstNode, Unifier.Term>> nodeTerms =\n        new ArrayList<>(nodeTypeTerms.entrySet());\n    nodeTerms.sort(Comparator.comparing(o -> o.getValue().toString()));\n    nodeTerms.forEach(pair ->\n        b.append(pair.getValue()).append(\": \").append(pair.getKey())\n            .append('\\n'));\n    b.append(\"substitution:\\n\");\n    substitution.accept(b);\n    return b.toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeMap.java", "class_name": "TypeMap", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[Type]termToType(Unifier.Term)", "name": "termToType", "arg_nums": 1, "params": [{"name": "term", "type": "Unifier.Term"}], "return_type": "Type", "signature": "Type termToType(Unifier.Term term)", "original_string": "  Type termToType(Unifier.Term term) {\n    return term.accept(new TermToTypeConverter(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeMap.java", "class_name": "TypeMap", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[Type]getType(AstNode)", "name": "getType", "arg_nums": 1, "params": [{"name": "node", "type": "AstNode"}], "return_type": "Type", "signature": "public Type getType(AstNode node)", "original_string": "  public Type getType(AstNode node) {\n    final Unifier.Term term = requireNonNull(nodeTypeTerms.get(node));\n    return termToType(term);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeMap.java", "class_name": "TypeMap", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Returns the type of an AST node."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[Type]getTypeOpt(AstNode)", "name": "getTypeOpt", "arg_nums": 1, "params": [{"name": "node", "type": "AstNode"}], "return_type": "Type", "signature": "public @Nullable Type getTypeOpt(AstNode node)", "original_string": "  public @Nullable Type getTypeOpt(AstNode node) {\n    final Unifier.Term term = nodeTypeTerms.get(node);\n    return term == null ? null : termToType(term);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeMap.java", "class_name": "TypeMap", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap", "attributes": {"modifiers": "public @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Returns an AST node's type, or null if no type is known."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[boolean]typeIsVariable(AstNode)", "name": "typeIsVariable", "arg_nums": 1, "params": [{"name": "node", "type": "AstNode"}], "return_type": "boolean", "signature": "public boolean typeIsVariable(AstNode node)", "original_string": "  public boolean typeIsVariable(AstNode node) {\n    final Unifier.Term term = nodeTypeTerms.get(node);\n    if (term instanceof Unifier.Variable) {\n      final Type type = termToType(term);\n      return type instanceof TypeVar\n          || type.isProgressive();\n    }\n    return false;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeMap.java", "class_name": "TypeMap", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether an AST node's type will be a type variable."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[boolean]hasType(AstNode)", "name": "hasType", "arg_nums": 1, "params": [{"name": "node", "type": "AstNode"}], "return_type": "boolean", "signature": "public boolean hasType(AstNode node)", "original_string": "  public boolean hasType(AstNode node) {\n    return nodeTypeTerms.containsKey(node);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeMap.java", "class_name": "TypeMap", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether an AST node has a type.\n\n<p>If it does not, perhaps it was ignored by the unification algorithm\nbecause it is not relevant to the program."}, {"uris": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap.[SortedSet<String>]typeFieldNames(AstNode)", "name": "typeFieldNames", "arg_nums": 1, "params": [{"name": "node", "type": "AstNode"}], "return_type": "SortedSet<String>", "signature": "@Nullable SortedSet<String> typeFieldNames(AstNode node)", "original_string": "  @Nullable SortedSet<String> typeFieldNames(AstNode node) {\n    // The term might be a sequence or a variable. We only materialize a type\n    // if it is a variable. Materializing a type for every sequence allocated\n    // lots of temporary type variables, and created a lot of noise in ref logs.\n    final Unifier.Term term = nodeTypeTerms.get(node);\n    if (term instanceof Unifier.Sequence) {\n      final Unifier.Sequence sequence = (Unifier.Sequence) term;\n      // E.g. \"record:a:b\" becomes record type \"{a:t0, b:t1}\".\n      final List<String> fieldList = TypeResolver.fieldList(sequence);\n      if (fieldList != null) {\n        return ImmutableSortedSet.copyOf(RecordType.ORDERING, fieldList);\n      }\n    }\n    if (term instanceof Unifier.Variable) {\n      final Type type = termToType(term);\n      if (type instanceof RecordLikeType) {\n        return (SortedSet<String>)\n            ((RecordLikeType) type).argNameTypes().keySet();\n      }\n    }\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/compile/TypeMap.java", "class_name": "TypeMap", "class_uri": "src/main/java/net/hydromatic/morel/compile/TypeMap.java.TypeMap", "attributes": {"modifiers": "@Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": [], "comments": [], "return_type": "SortedSet<String>", "classes": []}, "docstring": " Returns the field names if an AST node has a type that is a record or a\ntuple, otherwise null."}, {"uris": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[Result]unify(List<TermTerm>,Map<Variable, Action>,Tracer)", "name": "unify", "arg_nums": 3, "params": [{"name": "termPairs", "type": "List<TermTerm>"}, {"name": "termActions", "type": "Map<Variable, Action>"}, {"name": "tracer", "type": "Tracer"}], "return_type": "Result", "signature": "public @NonNull Result unify(List<TermTerm> termPairs,\n      Map<Variable, Action> termActions, Tracer tracer)", "original_string": "  public @NonNull Result unify(List<TermTerm> termPairs,\n      Map<Variable, Action> termActions, Tracer tracer) {\n\n    // delete: G u { t = t }\n    //   => G\n\n    // decompose: G u { f(s0, ..., sk) = f(t0, ..., tk) }\n    //   => G u {s0 = t0, ..., sk = tk}\n\n    // conflict: G u { f(s0, ..., sk) = g(t0, ..., tm) }\n    //   => fail\n    // if f <> g or k <> m\n\n    // swap: G u { f(s0, ..., sk) = x }\n    //  => G u { x = f(s0, ..., sk) }\n\n    // eliminate: G u { x = t }\n    //  => G { x |-> t } u { x = t }\n    // if x not in vars(t) and x in vars(G)\n\n    // check: G u { x = f(s0, ..., sk)}\n    //  => fail\n    // if x in vars(f(s0, ..., sk))\n\n    termPairs = new ArrayList<>(termPairs);\n    final Map<Variable, Term> result = new LinkedHashMap<>();\n    for (;;) {\n      if (termPairs.isEmpty()) {\n        return SubstitutionResult.create(result);\n      }\n      int i = findDelete(termPairs);\n      if (i >= 0) {\n        final TermTerm pair = termPairs.remove(i); // delete\n        tracer.onDelete(pair.left, pair.right);\n        continue;\n      }\n\n      i = findSeqSeq(termPairs);\n      if (i >= 0) {\n        final TermTerm pair = termPairs.get(i);\n        final Sequence left = (Sequence) pair.left;\n        final Sequence right = (Sequence) pair.right;\n\n        if (!left.operator.equals(right.operator)\n            || left.terms.size() != right.terms.size()) {\n          tracer.onConflict(left, right);\n          return failure(\"conflict: \" + left + \" vs \" + right);\n        }\n        termPairs.remove(i); // decompose\n        tracer.onSequence(left, right);\n        for (int j = 0; j < left.terms.size(); j++) {\n          termPairs.add(new TermTerm(left.terms.get(j), right.terms.get(j)));\n        }\n        continue;\n      }\n\n      i = findNonVarVar(termPairs);\n      if (i >= 0) {\n        final TermTerm pair = termPairs.get(i);\n        termPairs.set(i, new TermTerm(pair.right, pair.left));\n        tracer.onSwap(pair.left, pair.right);\n        continue; // swap\n      }\n\n      i = findVarAny(termPairs);\n      if (i >= 0) {\n        final TermTerm pair = termPairs.remove(i);\n        final Variable variable = (Variable) pair.left;\n        final Term term = pair.right;\n        if (term.contains(variable)) {\n          tracer.onCycle(variable, term);\n          return failure(\"cycle: variable \" + variable + \" in \" + term);\n        }\n        tracer.onVariable(variable, term);\n        result.put(variable, term);\n        act(variable, term, termPairs, new Substitution(result),\n            termActions, 0);\n        substituteList(termPairs, tracer, ImmutableMap.of(variable, term));\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java", "class_name": "MartelliUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier", "attributes": {"modifiers": "public @NonNull", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Result", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[void]substituteList(List<TermTerm>,Tracer,Map<Variable, Term>)", "name": "substituteList", "arg_nums": 3, "params": [{"name": "termPairs", "type": "List<TermTerm>"}, {"name": "tracer", "type": "Tracer"}, {"name": "map", "type": "Map<Variable, Term>"}], "return_type": "void", "signature": "private void substituteList(List<TermTerm> termPairs, Tracer tracer,\n      Map<Variable, Term> map)", "original_string": "  private void substituteList(List<TermTerm> termPairs, Tracer tracer,\n      Map<Variable, Term> map) {\n    for (int j = 0; j < termPairs.size(); j++) {\n      final TermTerm pair2 = termPairs.get(j);\n      final Term left2 = pair2.left.apply(map);\n      final Term right2 = pair2.right.apply(map);\n      if (left2 != pair2.left\n          || right2 != pair2.right) {\n        tracer.onSubstitute(pair2.left, pair2.right, left2, right2);\n        termPairs.set(j, new TermTerm(left2, right2));\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java", "class_name": "MartelliUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Applies a mapping to all term pairs in a list, modifying them in place."}, {"uris": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[void]act(Variable,Term,List<TermTerm>,Substitution,Map<Variable, Action>,int)", "name": "act", "arg_nums": 6, "params": [{"name": "variable", "type": "Variable"}, {"name": "term", "type": "Term"}, {"name": "termPairs", "type": "List<TermTerm>"}, {"name": "substitution", "type": "Substitution"}, {"name": "termActions", "type": "Map<Variable, Action>"}, {"name": "depth", "type": "int"}], "return_type": "void", "signature": "private void act(Variable variable, Term term, List<TermTerm> termPairs,\n      Substitution substitution, Map<Variable, Action> termActions,\n      int depth)", "original_string": "  private void act(Variable variable, Term term, List<TermTerm> termPairs,\n      Substitution substitution, Map<Variable, Action> termActions,\n      int depth) {\n    final Action action = termActions.get(variable);\n    if (action != null) {\n      action.accept(variable, term, substitution, termPairs);\n    }\n    if (term instanceof Variable) {\n      // Copy list to prevent concurrent modification, in case the action\n      // appends to the list. Limit on depth, to prevent infinite recursion.\n      final List<TermTerm> termPairsCopy = new ArrayList<>(termPairs);\n      termPairsCopy.forEach(termPair -> {\n        if (termPair.left.equals(term) && depth < 2) {\n          act(variable, termPair.right, termPairs, substitution, termActions,\n              depth + 1);\n        }\n      });\n      // If the term is a variable, recurse to see whether there is an\n      // action for that variable. Limit on depth to prevent swapping back.\n      if (depth < 1) {\n        act((Variable) term, variable, termPairs, substitution, termActions,\n            depth + 1);\n      }\n    }\n    substitution.resultMap.forEach((variable2, v) -> {\n      // Substitution contains \"variable2 -> variable\"; call the actions of\n      // \"variable2\", because it too has just been unified.\n      if (v.equals(variable)) {\n        act(variable2, term, termPairs, substitution, termActions,\n            depth + 1);\n      }\n    });\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java", "class_name": "MartelliUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[int]findDelete(List<TermTerm>)", "name": "findDelete", "arg_nums": 1, "params": [{"name": "termPairs", "type": "List<TermTerm>"}], "return_type": "int", "signature": "private int findDelete(List<TermTerm> termPairs)", "original_string": "  private int findDelete(List<TermTerm> termPairs) {\n    for (int i = 0; i < termPairs.size(); i++) {\n      TermTerm termTerm = termPairs.get(i);\n      if (termTerm.left.equals(termTerm.right)) {\n        return i;\n      }\n    }\n    return -1;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java", "class_name": "MartelliUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[int]findSeqSeq(List<TermTerm>)", "name": "findSeqSeq", "arg_nums": 1, "params": [{"name": "termPairs", "type": "List<TermTerm>"}], "return_type": "int", "signature": "private int findSeqSeq(List<TermTerm> termPairs)", "original_string": "  private int findSeqSeq(List<TermTerm> termPairs) {\n    for (int i = 0; i < termPairs.size(); i++) {\n      TermTerm termTerm = termPairs.get(i);\n      if (termTerm.left instanceof Sequence\n          && termTerm.right instanceof Sequence) {\n        return i;\n      }\n    }\n    return -1;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java", "class_name": "MartelliUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[int]findNonVarVar(List<TermTerm>)", "name": "findNonVarVar", "arg_nums": 1, "params": [{"name": "termPairs", "type": "List<TermTerm>"}], "return_type": "int", "signature": "private int findNonVarVar(List<TermTerm> termPairs)", "original_string": "  private int findNonVarVar(List<TermTerm> termPairs) {\n    for (int i = 0; i < termPairs.size(); i++) {\n      TermTerm termTerm = termPairs.get(i);\n      if (!(termTerm.left instanceof Variable)\n          && termTerm.right instanceof Variable) {\n        return i;\n      }\n    }\n    return -1;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java", "class_name": "MartelliUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier.[int]findVarAny(List<TermTerm>)", "name": "findVarAny", "arg_nums": 1, "params": [{"name": "termPairs", "type": "List<TermTerm>"}], "return_type": "int", "signature": "private int findVarAny(List<TermTerm> termPairs)", "original_string": "  private int findVarAny(List<TermTerm> termPairs) {\n    for (int i = 0; i < termPairs.size(); i++) {\n      TermTerm termTerm = termPairs.get(i);\n      if (termTerm.left instanceof Variable) {\n        return i;\n      }\n    }\n    return -1;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java", "class_name": "MartelliUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/MartelliUnifier.java.MartelliUnifier", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MapList.java.MapList.[]MapList(int,IntFunction<E>)", "name": "MapList", "arg_nums": 2, "params": [{"name": "size", "type": "int"}, {"name": "fn", "type": "IntFunction<E>"}], "return_type": "", "signature": "private MapList(int size, IntFunction<E> fn)", "original_string": "  private MapList(int size, IntFunction<E> fn) {\n    this.size = size;\n    this.fn = fn;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapList.java", "class_name": "MapList", "class_uri": "src/main/java/net/hydromatic/morel/util/MapList.java.MapList", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MapList.java.MapList.[MapList<E>]of(int,IntFunction<E>)", "name": "of", "arg_nums": 2, "params": [{"name": "size", "type": "int"}, {"name": "fn", "type": "IntFunction<E>"}], "return_type": "MapList<E>", "signature": "public static <E> MapList<E> of(int size, IntFunction<E> fn)", "original_string": "  public static <E> MapList<E> of(int size, IntFunction<E> fn) {\n    return new MapList<>(size, fn);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapList.java", "class_name": "MapList", "class_uri": "src/main/java/net/hydromatic/morel/util/MapList.java.MapList", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "MapList<E>", "classes": []}, "docstring": " Creates a MapList."}, {"uris": "src/main/java/net/hydromatic/morel/util/MapList.java.MapList.[E]get(int)", "name": "get", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "E", "signature": "public E get(int index)", "original_string": "  public E get(int index) {\n    return fn.apply(index);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapList.java", "class_name": "MapList", "class_uri": "src/main/java/net/hydromatic/morel/util/MapList.java.MapList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MapList.java.MapList.[int]size()", "name": "size", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int size()", "original_string": "  public int size() {\n    return size;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapList.java", "class_name": "MapList", "class_uri": "src/main/java/net/hydromatic/morel/util/MapList.java.MapList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[]Ord(int,E)", "name": "Ord", "arg_nums": 2, "params": [{"name": "i", "type": "int"}, {"name": "e", "type": "E"}], "return_type": "", "signature": "private Ord(int i, E e)", "original_string": "  private Ord(int i, E e) {\n    this.i = i;\n    this.e = e;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an Ord.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Ord<E>]of(int,E)", "name": "of", "arg_nums": 2, "params": [{"name": "n", "type": "int"}, {"name": "e", "type": "E"}], "return_type": "Ord<E>", "signature": "public static <E> Ord<E> of(int n, E e)", "original_string": "  public static <E> Ord<E> of(int n, E e) {\n    return new Ord<>(n, e);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Ord<E>", "classes": []}, "docstring": "\nCreates an Ord.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Iterable<Ord<E>>]zip(Iterable<? extends E>)", "name": "zip", "arg_nums": 1, "params": [{"name": "iterable", "type": "Iterable<? extends E>"}], "return_type": "Iterable<Ord<E>>", "signature": "public static <E> Iterable<Ord<E>> zip(final Iterable<? extends E> iterable)", "original_string": "  public static <E> Iterable<Ord<E>> zip(final Iterable<? extends E> iterable) {\n    return () -> zip(iterable.iterator());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<Ord<E>>", "classes": []}, "docstring": "\nCreates an iterable of {@code Ord}s over an iterable.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Iterator<Ord<E>>]zip(Iterator<? extends E>)", "name": "zip", "arg_nums": 1, "params": [{"name": "iterator", "type": "Iterator<? extends E>"}], "return_type": "Iterator<Ord<E>>", "signature": "public static <E> Iterator<Ord<E>> zip(final Iterator<? extends E> iterator)", "original_string": "  public static <E> Iterator<Ord<E>> zip(final Iterator<? extends E> iterator) {\n    return new Iterator<Ord<E>>() {\n      int n = 0;\n\n      public boolean hasNext() {\n        return iterator.hasNext();\n      }\n\n      public Ord<E> next() {\n        return Ord.of(n++, iterator.next());\n      }\n\n      public void remove() {\n        iterator.remove();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterator<Ord<E>>", "classes": []}, "docstring": "\nCreates an iterator of {@code Ord}s over an iterator.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[List<Ord<E>>]zip(E[])", "name": "zip", "arg_nums": 1, "params": [{"name": "elements", "type": "E[]"}], "return_type": "List<Ord<E>>", "signature": "public static <E> List<Ord<E>> zip(final E[] elements)", "original_string": "  public static <E> List<Ord<E>> zip(final E[] elements) {\n    return new OrdArrayList<>(elements);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Ord<E>>", "classes": []}, "docstring": "\nReturns a numbered list based on an array.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[List<Ord<E>>]zip(List<? extends E>)", "name": "zip", "arg_nums": 1, "params": [{"name": "elements", "type": "List<? extends E>"}], "return_type": "List<Ord<E>>", "signature": "public static <E> List<Ord<E>> zip(final List<? extends E> elements)", "original_string": "  public static <E> List<Ord<E>> zip(final List<? extends E> elements) {\n    return elements instanceof RandomAccess\n        ? new OrdRandomAccessList<>(elements)\n        : new OrdList<>(elements);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Ord<E>>", "classes": []}, "docstring": "\nReturns a numbered list.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[void]forEachIndexed(Iterable<E>,ObjIntConsumer<E>)", "name": "forEachIndexed", "arg_nums": 2, "params": [{"name": "iterable", "type": "Iterable<E>"}, {"name": "consumer", "type": "ObjIntConsumer<E>"}], "return_type": "void", "signature": "public static <E> void forEachIndexed(final Iterable<E> iterable,\n      ObjIntConsumer<E> consumer)", "original_string": "  public static <E> void forEachIndexed(final Iterable<E> iterable,\n      ObjIntConsumer<E> consumer) {\n    int i = 0;\n    for (E e : iterable) {\n      consumer.accept(e, i++);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms the given action for each element of the {@code Iterable}.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[void]forEach(List<E>,ObjIntConsumer<E>)", "name": "forEach", "arg_nums": 2, "params": [{"name": "list", "type": "List<E>"}, {"name": "consumer", "type": "ObjIntConsumer<E>"}], "return_type": "void", "signature": "public static <E> void forEach(final List<E> list,\n      ObjIntConsumer<E> consumer)", "original_string": "  public static <E> void forEach(final List<E> list,\n      ObjIntConsumer<E> consumer) {\n    for (int i = 0; i < list.size(); i++) {\n      consumer.accept(list.get(i), i);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms the given action for each element of the {@code List}.\n\n<p>More efficient than {@link #forEachIndexed(Iterable, ObjIntConsumer)}\nif the list implements {@link RandomAccess}.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[void]forEachIndexed(Map<K, V>,IntObjObjConsumer<K, V>)", "name": "forEachIndexed", "arg_nums": 2, "params": [{"name": "map", "type": "Map<K, V>"}, {"name": "consumer", "type": "IntObjObjConsumer<K, V>"}], "return_type": "void", "signature": "public static <K, V> void forEachIndexed(final Map<K, V> map,\n      IntObjObjConsumer<K, V> consumer)", "original_string": "  public static <K, V> void forEachIndexed(final Map<K, V> map,\n      IntObjObjConsumer<K, V> consumer) {\n    int i = 0;\n    for (Map.Entry<K, V> e : map.entrySet()) {\n      consumer.accept(i++, e.getKey(), e.getValue());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms the given action for each entry of a {@code Map}.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Iterable<Ord<E>>]reverse()", "name": "reverse", "arg_nums": 0, "params": [], "return_type": "Iterable<Ord<E>>", "signature": "public static <E> Iterable<Ord<E>> reverse(E... elements)", "original_string": "  public static <E> Iterable<Ord<E>> reverse(E... elements) {\n    return reverse(ImmutableList.copyOf(elements));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<Ord<E>>", "classes": []}, "docstring": "\nIterates over an array in reverse order.\n\n<p>Given the array [\"a\", \"b\", \"c\"], returns (2, \"c\") then (1, \"b\") then\n(0, \"a\").\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Iterable<Ord<E>>]reverse(Iterable<? extends E>)", "name": "reverse", "arg_nums": 1, "params": [{"name": "elements", "type": "Iterable<? extends E>"}], "return_type": "Iterable<Ord<E>>", "signature": "public static <E> Iterable<Ord<E>> reverse(Iterable<? extends E> elements)", "original_string": "  public static <E> Iterable<Ord<E>> reverse(Iterable<? extends E> elements) {\n    final ImmutableList<E> elementList = ImmutableList.copyOf(elements);\n    return () -> new Iterator<Ord<E>>() {\n      int i = elementList.size() - 1;\n\n      public boolean hasNext() {\n        return i >= 0;\n      }\n\n      public Ord<E> next() {\n        return Ord.of(i, elementList.get(i--));\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<Ord<E>>", "classes": []}, "docstring": "\nIterates over a list in reverse order.\n\n<p>Given the list [\"a\", \"b\", \"c\"], returns (2, \"c\") then (1, \"b\") then\n(0, \"a\").\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[Integer]getKey()", "name": "getKey", "arg_nums": 0, "params": [], "return_type": "Integer", "signature": "public Integer getKey()", "original_string": "  public Integer getKey() {\n    return i;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[E]getValue()", "name": "getValue", "arg_nums": 0, "params": [], "return_type": "E", "signature": "public E getValue()", "original_string": "  public E getValue() {\n    return e;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord.[E]setValue(E)", "name": "setValue", "arg_nums": 1, "params": [{"name": "value", "type": "E"}], "return_type": "E", "signature": "public E setValue(E value)", "original_string": "  public E setValue(E value) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Ord.java", "class_name": "Ord", "class_uri": "src/main/java/net/hydromatic/morel/util/Ord.java.Ord", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[List<E>]of(E,List<? extends E>)", "name": "of", "arg_nums": 2, "params": [{"name": "first", "type": "E"}, {"name": "rest", "type": "List<? extends E>"}], "return_type": "List<E>", "signature": "public static <E> List<E> of(E first, List<? extends E> rest)", "original_string": "  public static <E> List<E> of(E first, List<? extends E> rest) {\n    if (rest instanceof ConsList\n        || rest instanceof ImmutableList\n        && !rest.isEmpty()) {\n      //noinspection unchecked\n      return new ConsList<>(first, (List<E>) rest);\n    } else {\n      return ImmutableList.<E>builder().add(first).addAll(rest).build();\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": " Creates a ConsList.\nIt consists of an element pre-pended to another list.\nIf the other list is mutable, creates an immutable copy."}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[]ConsList(E,List<E>)", "name": "ConsList", "arg_nums": 2, "params": [{"name": "first", "type": "E"}, {"name": "rest", "type": "List<E>"}], "return_type": "", "signature": "private ConsList(E first, List<E> rest)", "original_string": "  private ConsList(E first, List<E> rest) {\n    this.first = first;\n    this.rest = rest;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[E]get(int)", "name": "get", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "E", "signature": "public E get(int index)", "original_string": "  public E get(int index) {\n    for (ConsList<E> c = this;; c = (ConsList<E>) c.rest) {\n      if (index == 0) {\n        return c.first;\n      }\n      --index;\n      if (!(c.rest instanceof ConsList)) {\n        return c.rest.get(index);\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[int]size()", "name": "size", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@SuppressWarnings(\"rawtypes\")\n  public int size()", "original_string": "  @SuppressWarnings(\"rawtypes\")\n  public int size() {\n    int s = 1;\n    for (ConsList c = this;; c = (ConsList) c.rest, ++s) {\n      if (!(c.rest instanceof ConsList)) {\n        return s + c.rest.size();\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "@SuppressWarnings(\"rawtypes\")\n  public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override public int hashCode()", "original_string": "  @Override public int hashCode() {\n    return toList().hashCode();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "boolean", "signature": "@Override public boolean equals(Object o)", "original_string": "  @Override public boolean equals(Object o) {\n    return o == this\n        || o instanceof List\n        && toList().equals(o);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return toList().toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[List<E>]toList()", "name": "toList", "arg_nums": 0, "params": [], "return_type": "List<E>", "signature": "protected final List<E> toList()", "original_string": "  protected final List<E> toList() {\n    final List<E> list = new ArrayList<>();\n    for (ConsList<E> c = this;; c = (ConsList<E>) c.rest) {\n      list.add(c.first);\n      if (!(c.rest instanceof ConsList)) {\n        list.addAll(c.rest);\n        return list;\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[ListIterator<E>]listIterator()", "name": "listIterator", "arg_nums": 0, "params": [], "return_type": "ListIterator<E>", "signature": "@Override @NonNull public ListIterator<E> listIterator()", "original_string": "  @Override @NonNull public ListIterator<E> listIterator() {\n    return toList().listIterator();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "@Override @NonNull public", "marker_annotations": ["@Override", "@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[Iterator<E>]iterator()", "name": "iterator", "arg_nums": 0, "params": [], "return_type": "Iterator<E>", "signature": "@Override @NonNull public Iterator<E> iterator()", "original_string": "  @Override @NonNull public Iterator<E> iterator() {\n    return toList().iterator();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "@Override @NonNull public", "marker_annotations": ["@Override", "@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[ListIterator<E>]listIterator(int)", "name": "listIterator", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "ListIterator<E>", "signature": "@Override @NonNull public ListIterator<E> listIterator(int index)", "original_string": "  @Override @NonNull public ListIterator<E> listIterator(int index) {\n    return toList().listIterator(index);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "@Override @NonNull public", "marker_annotations": ["@Override", "@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[Object @NonNull[]]toArray()", "name": "toArray", "arg_nums": 0, "params": [], "return_type": "Object @NonNull[]", "signature": "public @Nullable Object @NonNull[] toArray()", "original_string": "  public @Nullable Object @NonNull[] toArray() {\n    return toList().toArray();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "public @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object @NonNull[]", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[T @NonNull[]]toArray(T @NonNull[])", "name": "toArray", "arg_nums": 1, "params": [{"name": "a", "type": "T @NonNull[]"}], "return_type": "T @NonNull[]", "signature": "@SuppressWarnings(\"rawtypes\")\n  public <T> @Nullable T @NonNull[] toArray(@Nullable T @NonNull[] a)", "original_string": "  @SuppressWarnings(\"rawtypes\")\n  public <T> @Nullable T @NonNull[] toArray(@Nullable T @NonNull[] a) {\n    final int s = size();\n    if (s > a.length) {\n      a = Arrays.copyOf(a, s);\n    } else if (s < a.length) {\n      a[s] = null;\n    }\n    int i = 0;\n    for (ConsList c = this;; c = (ConsList) c.rest) {\n      //noinspection unchecked\n      a[i++] = (T) c.first;\n      if (!(c.rest instanceof ConsList)) {\n        Object[] a2 = c.rest.toArray();\n        //noinspection SuspiciousSystemArraycopy\n        System.arraycopy(a2, 0, a, i, a2.length);\n        return a;\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "@SuppressWarnings(\"rawtypes\")\n  public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public"], "comments": [], "return_type": "T @NonNull[]", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[int]indexOf(Object)", "name": "indexOf", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "int", "signature": "public int indexOf(Object o)", "original_string": "  public int indexOf(Object o) {\n    return toList().indexOf(o);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList.[int]lastIndexOf(Object)", "name": "lastIndexOf", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "int", "signature": "public int lastIndexOf(Object o)", "original_string": "  public int lastIndexOf(Object o) {\n    return toList().lastIndexOf(o);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ConsList.java", "class_name": "ConsList", "class_uri": "src/main/java/net/hydromatic/morel/util/ConsList.java.ConsList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[]TailList(List<E>,int)", "name": "TailList", "arg_nums": 2, "params": [{"name": "list", "type": "List<E>"}, {"name": "start", "type": "int"}], "return_type": "", "signature": "public TailList(List<E> list, int start)", "original_string": "  public TailList(List<E> list, int start) {\n    this.list = requireNonNull(list);\n    this.start = start;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a list that reads elements from a given backing list\nafter a given start point.\n\n@param list Backing list\n@param start Start point\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[]TailList(List<E>)", "name": "TailList", "arg_nums": 1, "params": [{"name": "list", "type": "List<E>"}], "return_type": "", "signature": "public TailList(List<E> list)", "original_string": "  public TailList(List<E> list) {\n    this(list, list.size());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a list whose start is the current size of the backing list.\n\n<p>Thus only elements appended to the backing list after creation will\nappear in this list."}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[E]get(int)", "name": "get", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "E", "signature": "@Override public E get(int index)", "original_string": "  @Override public E get(int index) {\n    return list.get(start + index);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[int]size()", "name": "size", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override public int size()", "original_string": "  @Override public int size() {\n    return list.size() - start;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[void]clear()", "name": "clear", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override public void clear()", "original_string": "  @Override public void clear() {\n    while (list.size() > start) {\n      list.remove(list.size() - 1);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[boolean]add(E)", "name": "add", "arg_nums": 1, "params": [{"name": "e", "type": "E"}], "return_type": "boolean", "signature": "@Override public boolean add(E e)", "original_string": "  @Override public boolean add(E e) {\n    return list.add(e);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[void]add(int,E)", "name": "add", "arg_nums": 2, "params": [{"name": "index", "type": "int"}, {"name": "element", "type": "E"}], "return_type": "void", "signature": "@Override public void add(int index, E element)", "original_string": "  @Override public void add(int index, E element) {\n    list.add(start + index, element);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[boolean]addAll(int,Collection<? extends E>)", "name": "addAll", "arg_nums": 2, "params": [{"name": "index", "type": "int"}, {"name": "c", "type": "Collection<? extends E>"}], "return_type": "boolean", "signature": "@Override public boolean addAll(int index, Collection<? extends E> c)", "original_string": "  @Override public boolean addAll(int index, Collection<? extends E> c) {\n    return list.addAll(start + index, c);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[boolean]addAll(Collection<? extends E>)", "name": "addAll", "arg_nums": 1, "params": [{"name": "c", "type": "Collection<? extends E>"}], "return_type": "boolean", "signature": "@Override public boolean addAll(Collection<? extends E> c)", "original_string": "  @Override public boolean addAll(Collection<? extends E> c) {\n    return list.addAll(c);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[E]remove(int)", "name": "remove", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "E", "signature": "@Override public E remove(int index)", "original_string": "  @Override public E remove(int index) {\n    return list.remove(start + index);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList.[E]set(int,E)", "name": "set", "arg_nums": 2, "params": [{"name": "index", "type": "int"}, {"name": "element", "type": "E"}], "return_type": "E", "signature": "@Override public E set(int index, E element)", "original_string": "  @Override public E set(int index, E element) {\n    return list.set(start + index, element);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/TailList.java", "class_name": "TailList", "class_uri": "src/main/java/net/hydromatic/morel/util/TailList.java.TailList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[]Folder(E)", "name": "Folder", "arg_nums": 1, "params": [{"name": "e", "type": "E"}], "return_type": "", "signature": "Folder(E e)", "original_string": "  Folder(E e) {\n    this.e = requireNonNull(e);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Folder.java", "class_name": "Folder", "class_uri": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[E]combine(List<Folder<E>>)", "name": "combine", "arg_nums": 1, "params": [{"name": "list", "type": "List<Folder<E>>"}], "return_type": "E", "signature": "abstract E combine(List<Folder<E>> list)", "original_string": "  abstract E combine(List<Folder<E>> list);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Folder.java", "class_name": "Folder", "class_uri": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[E]combineAll(List<Folder<E>>)", "name": "combineAll", "arg_nums": 1, "params": [{"name": "list", "type": "List<Folder<E>>"}], "return_type": "E", "signature": "public static <E> E combineAll(List<Folder<E>> list)", "original_string": "  public static <E> E combineAll(List<Folder<E>> list) {\n    if (list.size() == 0) {\n      throw new AssertionError();\n    }\n    final Folder<E> head = list.get(0);\n    final List<Folder<E>> tail = skip(list);\n    return head.combine(tail);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Folder.java", "class_name": "Folder", "class_uri": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[Folder<E>]end(E)", "name": "end", "arg_nums": 1, "params": [{"name": "e", "type": "E"}], "return_type": "Folder<E>", "signature": "private static <E> Folder<E> end(E e)", "original_string": "  private static <E> Folder<E> end(E e) {\n    return new End<>(e);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Folder.java", "class_name": "Folder", "class_uri": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Folder<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[void]at(List<Folder<Ast.Exp>>,Ast.Exp)", "name": "at", "arg_nums": 2, "params": [{"name": "list", "type": "List<Folder<Ast.Exp>>"}, {"name": "exp", "type": "Ast.Exp"}], "return_type": "void", "signature": "public static void at(List<Folder<Ast.Exp>> list, Ast.Exp exp)", "original_string": "  public static void at(List<Folder<Ast.Exp>> list, Ast.Exp exp) {\n    append(list, exp, e1 -> op(e1, Op.AT));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Folder.java", "class_name": "Folder", "class_uri": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Appends an element using \"@\"."}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[void]cons(List<Folder<Ast.Exp>>,Ast.Exp)", "name": "cons", "arg_nums": 2, "params": [{"name": "list", "type": "List<Folder<Ast.Exp>>"}, {"name": "exp", "type": "Ast.Exp"}], "return_type": "void", "signature": "public static void cons(List<Folder<Ast.Exp>> list, Ast.Exp exp)", "original_string": "  public static void cons(List<Folder<Ast.Exp>> list, Ast.Exp exp) {\n    append(list, exp, e1 -> op(e1, Op.CONS));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Folder.java", "class_name": "Folder", "class_uri": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Appends an element using \"::\"."}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[void]start(List<Folder<E>>,E)", "name": "start", "arg_nums": 2, "params": [{"name": "list", "type": "List<Folder<E>>"}, {"name": "e", "type": "E"}], "return_type": "void", "signature": "public static <E> void start(List<Folder<E>> list, E e)", "original_string": "  public static <E> void start(List<Folder<E>> list, E e) {\n    if (!list.isEmpty()) {\n      throw new AssertionError();\n    }\n    list.add(end(e));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Folder.java", "class_name": "Folder", "class_uri": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Adds an element to an empty list."}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[void]append(List<Folder<E>>,E,Function<E, Folder<E>>)", "name": "append", "arg_nums": 3, "params": [{"name": "list", "type": "List<Folder<E>>"}, {"name": "e", "type": "E"}, {"name": "fn", "type": "Function<E, Folder<E>>"}], "return_type": "void", "signature": "private static <E> void append(List<Folder<E>> list, E e,\n      Function<E, Folder<E>> fn)", "original_string": "  private static <E> void append(List<Folder<E>> list, E e,\n      Function<E, Folder<E>> fn) {\n    if (list.isEmpty()) {\n      throw new AssertionError();\n    }\n    @SuppressWarnings(\"unchecked\")\n    final End<E> end = (End) list.get(list.size() - 1);\n    list.set(list.size() - 1, fn.apply(end.e));\n    list.add(end(e));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Folder.java", "class_name": "Folder", "class_uri": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Adds an element and operator to a non-empty list."}, {"uris": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder.[Folder<Ast.Exp>]op(Ast.Exp,Op)", "name": "op", "arg_nums": 2, "params": [{"name": "exp", "type": "Ast.Exp"}, {"name": "at", "type": "Op"}], "return_type": "Folder<Ast.Exp>", "signature": "private static Folder<Ast.Exp> op(Ast.Exp exp, final Op at)", "original_string": "  private static Folder<Ast.Exp> op(Ast.Exp exp, final Op at) {\n    return new Folder<Ast.Exp>(exp) {\n      Ast.Exp combine(List<Folder<Ast.Exp>> list) {\n        final Ast.Exp rest = combineAll(list);\n        return ast.infixCall(e.pos.plus(rest.pos), at, e, rest);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Folder.java", "class_name": "Folder", "class_uri": "src/main/java/net/hydromatic/morel/util/Folder.java.Folder", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Folder<Ast.Exp>", "classes": []}, "docstring": " Creates a folder that combines an expression with whatever follows\nusing an infix operator."}, {"uris": "src/main/java/net/hydromatic/morel/util/MorelException.java.MorelException.[Pos]pos()", "name": "pos", "arg_nums": 0, "params": [], "return_type": "Pos", "signature": "Pos pos()", "original_string": "  Pos pos();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MorelException.java", "class_name": "MorelException", "class_uri": "src/main/java/net/hydromatic/morel/util/MorelException.java.MorelException", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Pos", "classes": []}, "docstring": " Returns the position."}, {"uris": "src/main/java/net/hydromatic/morel/util/MorelException.java.MorelException.[StringBuilder]describeTo(StringBuilder)", "name": "describeTo", "arg_nums": 1, "params": [{"name": "buf", "type": "StringBuilder"}], "return_type": "StringBuilder", "signature": "StringBuilder describeTo(StringBuilder buf)", "original_string": "  StringBuilder describeTo(StringBuilder buf);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MorelException.java", "class_name": "MorelException", "class_uri": "src/main/java/net/hydromatic/morel/util/MorelException.java.MorelException", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": " Writes a description of this exception."}, {"uris": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[]MapEntry(T,U)", "name": "MapEntry", "arg_nums": 2, "params": [{"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "return_type": "", "signature": "public MapEntry(T t, U u)", "original_string": "  public MapEntry(T t, U u) {\n    this.t = t;\n    this.u = u;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapEntry.java", "class_name": "MapEntry", "class_uri": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a MapEntry."}, {"uris": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return \"<\" + t + \", \" + u + \">\";\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapEntry.java", "class_name": "MapEntry", "class_uri": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "boolean", "signature": "@SuppressWarnings(\"unchecked\")\n  @Override public boolean equals(@Nullable Object o)", "original_string": "  @SuppressWarnings(\"unchecked\")\n  @Override public boolean equals(@Nullable Object o) {\n    return this == o\n        || o instanceof Map.Entry\n        && Objects.equals(this.t, ((Map.Entry<T, U>) o).getKey())\n        && Objects.equals(this.u, ((Map.Entry<T, U>) o).getValue());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapEntry.java", "class_name": "MapEntry", "class_uri": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  @Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n\n<p>Compares equal to any {@link Map.Entry} with the equal key and value.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override public int hashCode()", "original_string": "  @Override public int hashCode() {\n    int keyHash = t == null ? 0 : t.hashCode();\n    int valueHash = u == null ? 0 : u.hashCode();\n    return keyHash ^ valueHash;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapEntry.java", "class_name": "MapEntry", "class_uri": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n\n<p>Computes hash code consistent with\n{@link Map.Entry#hashCode()}.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[T]getKey()", "name": "getKey", "arg_nums": 0, "params": [], "return_type": "T", "signature": "@Override public T getKey()", "original_string": "  @Override public T getKey() {\n    return t;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapEntry.java", "class_name": "MapEntry", "class_uri": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[U]getValue()", "name": "getValue", "arg_nums": 0, "params": [], "return_type": "U", "signature": "@Override public U getValue()", "original_string": "  @Override public U getValue() {\n    return u;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapEntry.java", "class_name": "MapEntry", "class_uri": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "U", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry.[U]setValue(U)", "name": "setValue", "arg_nums": 1, "params": [{"name": "value", "type": "U"}], "return_type": "U", "signature": "@Override public U setValue(U value)", "original_string": "  @Override public U setValue(U value) {\n    throw new UnsupportedOperationException(\"setValue\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/MapEntry.java", "class_name": "MapEntry", "class_uri": "src/main/java/net/hydromatic/morel/util/MapEntry.java.MapEntry", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "U", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers.[]Tracers()", "name": "Tracers", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Tracers()", "original_string": "  private Tracers() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers.[Unifier.Tracer]nullTracer()", "name": "nullTracer", "arg_nums": 0, "params": [], "return_type": "Unifier.Tracer", "signature": "public static Unifier.Tracer nullTracer()", "original_string": "  public static Unifier.Tracer nullTracer() {\n    return NULL_TRACER;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Unifier.Tracer", "classes": []}, "docstring": " Returns a tracer that does nothing."}, {"uris": "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers.[Unifier.Tracer]printTracer(PrintWriter)", "name": "printTracer", "arg_nums": 1, "params": [{"name": "w", "type": "PrintWriter"}], "return_type": "Unifier.Tracer", "signature": "public static Unifier.Tracer printTracer(PrintWriter w)", "original_string": "  public static Unifier.Tracer printTracer(PrintWriter w) {\n    return new PrintTracer(w);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Unifier.Tracer", "classes": []}, "docstring": " Returns a tracer that writes debugging messages to a writer."}, {"uris": "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers.[Unifier.Tracer]printTracer(OutputStream)", "name": "printTracer", "arg_nums": 1, "params": [{"name": "stream", "type": "OutputStream"}], "return_type": "Unifier.Tracer", "signature": "public static Unifier.Tracer printTracer(OutputStream stream)", "original_string": "  public static Unifier.Tracer printTracer(OutputStream stream) {\n    return printTracer(new PrintWriter(stream));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Tracers.java", "class_name": "Tracers", "class_uri": "src/main/java/net/hydromatic/morel/util/Tracers.java.Tracers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Unifier.Tracer", "classes": []}, "docstring": " Returns a tracer that writes debugging messages to a stream."}, {"uris": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier.[Map<Variable, Term>]compose(Map<Variable, Term>,Map<Variable, Term>)", "name": "compose", "arg_nums": 2, "params": [{"name": "s1", "type": "Map<Variable, Term>"}, {"name": "s2", "type": "Map<Variable, Term>"}], "return_type": "Map<Variable, Term>", "signature": "static Map<Variable, Term> compose(Map<Variable, Term> s1,\n      Map<Variable, Term> s2)", "original_string": "  static Map<Variable, Term> compose(Map<Variable, Term> s1,\n      Map<Variable, Term> s2) {\n    Map<Variable, Term> composed = new HashMap<>(s1);\n    s2.forEach((key, value) -> composed.put(key, value.apply(s1)));\n    return composed;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java", "class_name": "RobinsonUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Map<Variable, Term>", "classes": []}, "docstring": "\nApplies s1 to the elements of s2 and adds them into a single list.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier.[Result]sequenceUnify(Sequence,Sequence)", "name": "sequenceUnify", "arg_nums": 2, "params": [{"name": "lhs", "type": "Sequence"}, {"name": "rhs", "type": "Sequence"}], "return_type": "Result", "signature": "private @NonNull Result sequenceUnify(Sequence lhs,\n      Sequence rhs)", "original_string": "  private @NonNull Result sequenceUnify(Sequence lhs,\n      Sequence rhs) {\n    if (lhs.terms.size() != rhs.terms.size()) {\n      return failure(\"sequences have different length: \" + lhs + \", \" + rhs);\n    }\n    if (!lhs.operator.equals(rhs.operator)) {\n      return failure(\"sequences have different operator: \" + lhs + \", \" + rhs);\n    }\n    if (lhs.terms.isEmpty()) {\n      return SubstitutionResult.EMPTY;\n    }\n    Term firstLhs = lhs.terms.get(0);\n    Term firstRhs = rhs.terms.get(0);\n    final Result r1 = unify(firstLhs, firstRhs);\n    if (!(r1 instanceof Substitution)) {\n      return r1;\n    }\n    final Substitution subs1 = (Substitution) r1;\n    Sequence restLhs =\n        sequenceApply(lhs.operator, subs1.resultMap, skip(lhs.terms));\n    Sequence restRhs =\n        sequenceApply(rhs.operator, subs1.resultMap, skip(rhs.terms));\n    final Result r2 = sequenceUnify(restLhs, restRhs);\n    if (!(r2 instanceof Substitution)) {\n      return r2;\n    }\n    final Substitution subs2 = (Substitution) r2;\n    final Map<Variable, Term> joined =\n        ImmutableSortedMap.<Variable, Term>naturalOrder()\n            .putAll(subs1.resultMap)\n            .putAll(subs2.resultMap)\n            .build();\n    return SubstitutionResult.create(joined);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java", "class_name": "RobinsonUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier", "attributes": {"modifiers": "private @NonNull", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["private"], "comments": [], "return_type": "Result", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier.[Result]unify(List<TermTerm>,Map<Variable, Action>,Tracer)", "name": "unify", "arg_nums": 3, "params": [{"name": "termPairs", "type": "List<TermTerm>"}, {"name": "termActions", "type": "Map<Variable, Action>"}, {"name": "tracer", "type": "Tracer"}], "return_type": "Result", "signature": "public @NonNull Result unify(List<TermTerm> termPairs,\n      Map<Variable, Action> termActions, Tracer tracer)", "original_string": "  public @NonNull Result unify(List<TermTerm> termPairs,\n      Map<Variable, Action> termActions, Tracer tracer) {\n    switch (termPairs.size()) {\n    case 1:\n      return unify(termPairs.get(0).left, termPairs.get(0).right);\n    default:\n      throw new AssertionError();\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java", "class_name": "RobinsonUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier", "attributes": {"modifiers": "public @NonNull", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Result", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier.[Result]unify(Term,Term)", "name": "unify", "arg_nums": 2, "params": [{"name": "lhs", "type": "Term"}, {"name": "rhs", "type": "Term"}], "return_type": "Result", "signature": "public @NonNull Result unify(Term lhs, Term rhs)", "original_string": "  public @NonNull Result unify(Term lhs, Term rhs) {\n    if (lhs instanceof Variable) {\n      return SubstitutionResult.create((Variable) lhs, rhs);\n    }\n    if (rhs instanceof Variable) {\n      return SubstitutionResult.create((Variable) rhs, lhs);\n    }\n    if (lhs instanceof Sequence && rhs instanceof Sequence) {\n      return sequenceUnify((Sequence) lhs, (Sequence) rhs);\n    }\n    return failure(\"terms have different types: \" + lhs + \", \" + rhs);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java", "class_name": "RobinsonUnifier", "class_uri": "src/main/java/net/hydromatic/morel/util/RobinsonUnifier.java.RobinsonUnifier", "attributes": {"modifiers": "public @NonNull", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Result", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[]Pair(T1,T2)", "name": "Pair", "arg_nums": 2, "params": [{"name": "left", "type": "T1"}, {"name": "right", "type": "T2"}], "return_type": "", "signature": "public Pair(T1 left, T2 right)", "original_string": "  public Pair(T1 left, T2 right) {\n    this.left = left;\n    this.right = right;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a Pair.\n\n@param left  left value\n@param right right value\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Pair<T1, T2>]of(T1,T2)", "name": "of", "arg_nums": 2, "params": [{"name": "left", "type": "T1"}, {"name": "right", "type": "T2"}], "return_type": "Pair<T1, T2>", "signature": "public static <T1, T2> Pair<T1, T2> of(T1 left, T2 right)", "original_string": "  public static <T1, T2> Pair<T1, T2> of(T1 left, T2 right) {\n    return new Pair<>(left, right);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Pair<T1, T2>", "classes": []}, "docstring": "\nCreates a Pair of appropriate type.\n\n<p>This is a shorthand that allows you to omit implicit types. For\nexample, you can write:\n<blockquote>return Pair.of(s, n);</blockquote>\ninstead of\n<blockquote>return new Pair&lt;String, Integer&gt;(s, n);</blockquote>\n\n@param left  left value\n@param right right value\n@return A Pair\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Pair<K, V>]of(Map.Entry<K, V>)", "name": "of", "arg_nums": 1, "params": [{"name": "entry", "type": "Map.Entry<K, V>"}], "return_type": "Pair<K, V>", "signature": "public static <K, V> Pair<K, V> of(Map.Entry<K, V> entry)", "original_string": "  public static <K, V> Pair<K, V> of(Map.Entry<K, V> entry) {\n    return of(entry.getKey(), entry.getValue());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Pair<K, V>", "classes": []}, "docstring": " Creates a {@code Pair} from a {@link java.util.Map.Entry}."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@SuppressWarnings(\"rawtypes\")\n  public boolean equals(Object obj)", "original_string": "  @SuppressWarnings(\"rawtypes\")\n  public boolean equals(Object obj) {\n    return this == obj\n        || obj instanceof Map.Entry\n        && Objects.equals(this.left, ((Map.Entry) obj).getKey())\n        && Objects.equals(this.right, ((Map.Entry) obj).getValue());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "@SuppressWarnings(\"rawtypes\")\n  public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "~ Methods ----------------------------------------------------------------"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override public int hashCode()", "original_string": "  @Override public int hashCode() {\n    int keyHash = left == null ? 0 : left.hashCode();\n    int valueHash = right == null ? 0 : right.hashCode();\n    return keyHash ^ valueHash;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": " {@inheritDoc}\n\n<p>Computes hash code consistent with\n{@link java.util.Map.Entry#hashCode()}."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[int]compareTo(Pair<T1, T2>)", "name": "compareTo", "arg_nums": 1, "params": [{"name": "that", "type": "Pair<T1, T2>"}], "return_type": "int", "signature": "@SuppressWarnings(\"rawtypes\")\n  public int compareTo(@NonNull Pair<T1, T2> that)", "original_string": "  @SuppressWarnings(\"rawtypes\")\n  public int compareTo(@NonNull Pair<T1, T2> that) {\n    //noinspection unchecked\n    int c = compare((Comparable) this.left, (Comparable) that.left);\n    if (c == 0) {\n      //noinspection unchecked\n      c = compare((Comparable) this.right, (Comparable) that.right);\n    }\n    return c;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "@SuppressWarnings(\"rawtypes\")\n  public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toString()", "original_string": "  public String toString() {\n    return left + \"=\" + right;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[T1]getKey()", "name": "getKey", "arg_nums": 0, "params": [], "return_type": "T1", "signature": "public T1 getKey()", "original_string": "  public T1 getKey() {\n    return left;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T1", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[T2]getValue()", "name": "getValue", "arg_nums": 0, "params": [], "return_type": "T2", "signature": "public T2 getValue()", "original_string": "  public T2 getValue() {\n    return right;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T2", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[T2]setValue(T2)", "name": "setValue", "arg_nums": 1, "params": [{"name": "value", "type": "T2"}], "return_type": "T2", "signature": "public T2 setValue(T2 value)", "original_string": "  public T2 setValue(T2 value) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T2", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[int]compare(C,C)", "name": "compare", "arg_nums": 2, "params": [{"name": "c1", "type": "C"}, {"name": "c2", "type": "C"}], "return_type": "int", "signature": "private static <C extends Comparable<C>> int compare(C c1, C c2)", "original_string": "  private static <C extends Comparable<C>> int compare(C c1, C c2) {\n    if (c1 == null) {\n      if (c2 == null) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (c2 == null) {\n      return 1;\n    } else {\n      return c1.compareTo(c2);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nCompares a pair of comparable values of the same type. Null collates\nless than everything else, but equal to itself.\n\n@param c1 First value\n@param c2 Second value\n@return a negative integer, zero, or a positive integer if c1\nis less than, equal to, or greater than c2.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Map<K, V>]toMap(Iterable<Pair<K, V>>)", "name": "toMap", "arg_nums": 1, "params": [{"name": "pairs", "type": "Iterable<Pair<K, V>>"}], "return_type": "Map<K, V>", "signature": "public static <K, V> Map<K, V> toMap(Iterable<Pair<K, V>> pairs)", "original_string": "  public static <K, V> Map<K, V> toMap(Iterable<Pair<K, V>> pairs) {\n    final Map<K, V> map = new HashMap<>();\n    for (Pair<K, V> pair : pairs) {\n      map.put(pair.left, pair.right);\n    }\n    return map;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "docstring": "\nConverts a collection of Pairs into a Map.\n\n<p>This is an obvious thing to do because Pair is similar in structure to\n{@link java.util.Map.Entry}.\n\n<p>The map contains a copy of the collection of Pairs; if you change the\ncollection, the map does not change.\n\n@param pairs Collection of Pair objects\n@return map with the same contents as the collection\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<Pair<K, V>>]zip(List<K>,List<V>)", "name": "zip", "arg_nums": 2, "params": [{"name": "ks", "type": "List<K>"}, {"name": "vs", "type": "List<V>"}], "return_type": "List<Pair<K, V>>", "signature": "public static <K, V> List<Pair<K, V>> zip(List<K> ks, List<V> vs)", "original_string": "  public static <K, V> List<Pair<K, V>> zip(List<K> ks, List<V> vs) {\n    return zip(ks, vs, false);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Pair<K, V>>", "classes": []}, "docstring": "\nConverts two lists into a list of {@link Pair}s,\nwhose length is the lesser of the lengths of the\nsource lists.\n\n@param ks Left list\n@param vs Right list\n@return List of pairs\n@see Ord#zip(java.util.List)\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<Pair<K, V>>]zip(List<K>,List<V>,boolean)", "name": "zip", "arg_nums": 3, "params": [{"name": "ks", "type": "List<K>"}, {"name": "vs", "type": "List<V>"}, {"name": "strict", "type": "boolean"}], "return_type": "List<Pair<K, V>>", "signature": "public static <K, V> List<Pair<K, V>> zip(\n      final List<K> ks,\n      final List<V> vs,\n      boolean strict)", "original_string": "  public static <K, V> List<Pair<K, V>> zip(\n      final List<K> ks,\n      final List<V> vs,\n      boolean strict) {\n    final int size;\n    if (strict) {\n      if (ks.size() != vs.size()) {\n        throw new AssertionError();\n      }\n      size = ks.size();\n    } else {\n      size = Math.min(ks.size(), vs.size());\n    }\n    return new ZipList<>(ks, vs, size);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Pair<K, V>>", "classes": []}, "docstring": "\nConverts two lists into a list of {@link Pair}s.\n\n<p>The length of the combined list is the lesser of the lengths of the\nsource lists. But typically the source lists will be the same length.\n\n@param ks     Left list\n@param vs     Right list\n@param strict Whether to fail if lists have different size\n@return List of pairs\n@see Ord#zip(java.util.List)\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[boolean]allMatch(Iterable<K>,Iterable<V>,BiPredicate<K, V>)", "name": "allMatch", "arg_nums": 3, "params": [{"name": "ks", "type": "Iterable<K>"}, {"name": "vs", "type": "Iterable<V>"}, {"name": "predicate", "type": "BiPredicate<K, V>"}], "return_type": "boolean", "signature": "public static <K, V> boolean allMatch(Iterable<K> ks, Iterable<V> vs,\n      BiPredicate<K, V> predicate)", "original_string": "  public static <K, V> boolean allMatch(Iterable<K> ks, Iterable<V> vs,\n      BiPredicate<K, V> predicate) {\n    final Iterator<K> ki = ks.iterator();\n    final Iterator<V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      if (!predicate.test(ki.next(), vi.next())) {\n        return false;\n      }\n    }\n    return true;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether all pairs match a given predicate."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[boolean]noneMatch(Iterable<K>,Iterable<V>,BiPredicate<K, V>)", "name": "noneMatch", "arg_nums": 3, "params": [{"name": "ks", "type": "Iterable<K>"}, {"name": "vs", "type": "Iterable<V>"}, {"name": "predicate", "type": "BiPredicate<K, V>"}], "return_type": "boolean", "signature": "public static <K, V> boolean noneMatch(Iterable<K> ks, Iterable<V> vs,\n      BiPredicate<K, V> predicate)", "original_string": "  public static <K, V> boolean noneMatch(Iterable<K> ks, Iterable<V> vs,\n      BiPredicate<K, V> predicate) {\n    final Iterator<K> ki = ks.iterator();\n    final Iterator<V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      if (predicate.test(ki.next(), vi.next())) {\n        return false;\n      }\n    }\n    return true;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether no pair matches a given predicate."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[boolean]anyMatch(Iterable<K>,Iterable<V>,BiPredicate<K, V>)", "name": "anyMatch", "arg_nums": 3, "params": [{"name": "ks", "type": "Iterable<K>"}, {"name": "vs", "type": "Iterable<V>"}, {"name": "predicate", "type": "BiPredicate<K, V>"}], "return_type": "boolean", "signature": "public static <K, V> boolean anyMatch(Iterable<K> ks, Iterable<V> vs,\n      BiPredicate<K, V> predicate)", "original_string": "  public static <K, V> boolean anyMatch(Iterable<K> ks, Iterable<V> vs,\n      BiPredicate<K, V> predicate) {\n    final Iterator<K> ki = ks.iterator();\n    final Iterator<V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      if (predicate.test(ki.next(), vi.next())) {\n        return true;\n      }\n    }\n    return false;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether any pair matches a given predicate."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEach(Iterable<K>,Iterable<V>,BiConsumer<K, V>)", "name": "forEach", "arg_nums": 3, "params": [{"name": "ks", "type": "Iterable<K>"}, {"name": "vs", "type": "Iterable<V>"}, {"name": "consumer", "type": "BiConsumer<K, V>"}], "return_type": "void", "signature": "public static <K, V> void forEach(Iterable<K> ks, Iterable<V> vs,\n      BiConsumer<K, V> consumer)", "original_string": "  public static <K, V> void forEach(Iterable<K> ks, Iterable<V> vs,\n      BiConsumer<K, V> consumer) {\n    final Iterator<K> ki = ks.iterator();\n    final Iterator<V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      consumer.accept(ki.next(), vi.next());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls a consumer for each pair of items in two iterables."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEachIndexed(Iterable<? extends K>,Iterable<? extends V>,PairWithOrdinalConsumer<K, V>)", "name": "forEachIndexed", "arg_nums": 3, "params": [{"name": "ks", "type": "Iterable<? extends K>"}, {"name": "vs", "type": "Iterable<? extends V>"}, {"name": "consumer", "type": "PairWithOrdinalConsumer<K, V>"}], "return_type": "void", "signature": "public static <K, V> void forEachIndexed(Iterable<? extends K> ks,\n      Iterable<? extends V> vs, PairWithOrdinalConsumer<K, V> consumer)", "original_string": "  public static <K, V> void forEachIndexed(Iterable<? extends K> ks,\n      Iterable<? extends V> vs, PairWithOrdinalConsumer<K, V> consumer) {\n    int i = 0;\n    final Iterator<? extends K> ki = ks.iterator();\n    final Iterator<? extends V> vi = vs.iterator();\n    while (ki.hasNext() && vi.hasNext()) {\n      consumer.accept(i++, ki.next(), vi.next());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls a consumer with an ordinal for each pair of items in two\niterables."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEachIndexed(List<? extends K>,List<? extends V>,PairWithOrdinalConsumer<K, V>)", "name": "forEachIndexed", "arg_nums": 3, "params": [{"name": "ks", "type": "List<? extends K>"}, {"name": "vs", "type": "List<? extends V>"}, {"name": "consumer", "type": "PairWithOrdinalConsumer<K, V>"}], "return_type": "void", "signature": "public static <K, V> void forEachIndexed(List<? extends K> ks,\n      List<? extends V> vs, PairWithOrdinalConsumer<K, V> consumer)", "original_string": "  public static <K, V> void forEachIndexed(List<? extends K> ks,\n      List<? extends V> vs, PairWithOrdinalConsumer<K, V> consumer) {\n    for (int i = 0, j = Math.min(ks.size(), vs.size()); i < j; i++) {\n      consumer.accept(i, ks.get(i), vs.get(i));\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls a consumer with an ordinal for each pair of items in two\nlists."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEachIndexed(Iterable<? extends Map.Entry<K, V>>,PairWithOrdinalConsumer<K, V>)", "name": "forEachIndexed", "arg_nums": 2, "params": [{"name": "pairs", "type": "Iterable<? extends Map.Entry<K, V>>"}, {"name": "consumer", "type": "PairWithOrdinalConsumer<K, V>"}], "return_type": "void", "signature": "public static <K, V> void forEachIndexed(\n      Iterable<? extends Map.Entry<K, V>> pairs,\n      PairWithOrdinalConsumer<K, V> consumer)", "original_string": "  public static <K, V> void forEachIndexed(\n      Iterable<? extends Map.Entry<K, V>> pairs,\n      PairWithOrdinalConsumer<K, V> consumer) {\n    int i = 0;\n    for (Map.Entry<K, V> pair : pairs) {\n      consumer.accept(i++, pair.getKey(), pair.getValue());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls a consumer with an ordinal for each pair of items in an iterable\nof pairs."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEachIndexed(Map<K, V>,PairWithOrdinalConsumer<K, V>)", "name": "forEachIndexed", "arg_nums": 2, "params": [{"name": "map", "type": "Map<K, V>"}, {"name": "consumer", "type": "PairWithOrdinalConsumer<K, V>"}], "return_type": "void", "signature": "public static <K, V> void forEachIndexed(Map<K, V> map,\n      PairWithOrdinalConsumer<K, V> consumer)", "original_string": "  public static <K, V> void forEachIndexed(Map<K, V> map,\n      PairWithOrdinalConsumer<K, V> consumer) {\n    forEachIndexed(map.entrySet(), consumer);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls a consumer for each entry in a map."}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<Pair<K, V>>]zip(Iterable<? extends K>,Iterable<? extends V>)", "name": "zip", "arg_nums": 2, "params": [{"name": "ks", "type": "Iterable<? extends K>"}, {"name": "vs", "type": "Iterable<? extends V>"}], "return_type": "Iterable<Pair<K, V>>", "signature": "public static <K, V> Iterable<Pair<K, V>> zip(\n      final Iterable<? extends K> ks,\n      final Iterable<? extends V> vs)", "original_string": "  public static <K, V> Iterable<Pair<K, V>> zip(\n      final Iterable<? extends K> ks,\n      final Iterable<? extends V> vs) {\n    return () -> {\n      final Iterator<? extends K> kIterator = ks.iterator();\n      final Iterator<? extends V> vIterator = vs.iterator();\n\n      return new ZipIterator<>(kIterator, vIterator);\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<Pair<K, V>>", "classes": []}, "docstring": "\nConverts two iterables into an iterable of {@link Pair}s.\n\n<p>The resulting iterator ends whenever the first of the input iterators\nends. But typically the source iterators will be the same length.\n\n@param ks Left iterable\n@param vs Right iterable\n@return Iterable over pairs\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<Pair<K, V>>]zip(K[],V[])", "name": "zip", "arg_nums": 2, "params": [{"name": "ks", "type": "K[]"}, {"name": "vs", "type": "V[]"}], "return_type": "List<Pair<K, V>>", "signature": "public static <K, V> List<Pair<K, V>> zip(\n      final K[] ks,\n      final V[] vs)", "original_string": "  public static <K, V> List<Pair<K, V>> zip(\n      final K[] ks,\n      final V[] vs) {\n    return new AbstractList<Pair<K, V>>() {\n      public Pair<K, V> get(int index) {\n        return Pair.of(ks[index], vs[index]);\n      }\n\n      public int size() {\n        return Math.min(ks.length, vs.length);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Pair<K, V>>", "classes": []}, "docstring": "\nConverts two arrays into a list of {@link Pair}s.\n\n<p>The length of the combined list is the lesser of the lengths of the\nsource arrays. But typically the source arrays will be the same\nlength.\n\n@param ks Left array\n@param vs Right array\n@return List of pairs\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<Pair<K, V>>]zipMutable(List<K>,List<V>)", "name": "zipMutable", "arg_nums": 2, "params": [{"name": "ks", "type": "List<K>"}, {"name": "vs", "type": "List<V>"}], "return_type": "List<Pair<K, V>>", "signature": "public static <K, V> List<Pair<K, V>> zipMutable(\n      final List<K> ks,\n      final List<V> vs)", "original_string": "  public static <K, V> List<Pair<K, V>> zipMutable(\n      final List<K> ks,\n      final List<V> vs) {\n    return new MutableZipList<>(ks, vs);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Pair<K, V>>", "classes": []}, "docstring": " Returns a mutable list of pairs backed by a pair of mutable lists.\n\n<p>Modifications to this list are reflected in the backing lists, and vice\nversa.\n\n@param <K> Key (left) value type\n@param <V> Value (right) value type"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[void]forEach(Iterable<? extends Map.Entry<? extends K, ? extends V>>,BiConsumer<K, V>)", "name": "forEach", "arg_nums": 2, "params": [{"name": "entries", "type": "Iterable<? extends Map.Entry<? extends K, ? extends V>>"}, {"name": "consumer", "type": "BiConsumer<K, V>"}], "return_type": "void", "signature": "public static <K, V> void forEach(\n      final Iterable<? extends Map.Entry<? extends K, ? extends V>> entries,\n      BiConsumer<K, V> consumer)", "original_string": "  public static <K, V> void forEach(\n      final Iterable<? extends Map.Entry<? extends K, ? extends V>> entries,\n      BiConsumer<K, V> consumer) {\n    for (Map.Entry<? extends K, ? extends V> entry : entries) {\n      consumer.accept(entry.getKey(), entry.getValue());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Applies an action to every element of an iterable of pairs.\n\n@see Map#forEach(java.util.function.BiConsumer)\n\n@param entries Pairs\n@param consumer The action to be performed for each element\n\n@param <K> Left type\n@param <V> Right type\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<L>]left(Iterable<? extends Map.Entry<L, R>>)", "name": "left", "arg_nums": 1, "params": [{"name": "iterable", "type": "Iterable<? extends Map.Entry<L, R>>"}], "return_type": "Iterable<L>", "signature": "public static <L, R> Iterable<L> left(\n      final Iterable<? extends Map.Entry<L, R>> iterable)", "original_string": "  public static <L, R> Iterable<L> left(\n      final Iterable<? extends Map.Entry<L, R>> iterable) {\n    return () -> new LeftIterator<>(iterable.iterator());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<L>", "classes": []}, "docstring": "\nReturns an iterable over the left slice of an iterable.\n\n@param iterable Iterable over pairs\n@param <L>      Left type\n@param <R>      Right type\n@return Iterable over the left elements\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<R>]right(Iterable<? extends Map.Entry<L, R>>)", "name": "right", "arg_nums": 1, "params": [{"name": "iterable", "type": "Iterable<? extends Map.Entry<L, R>>"}], "return_type": "Iterable<R>", "signature": "public static <L, R> Iterable<R> right(\n      final Iterable<? extends Map.Entry<L, R>> iterable)", "original_string": "  public static <L, R> Iterable<R> right(\n      final Iterable<? extends Map.Entry<L, R>> iterable) {\n    return () -> new RightIterator<>(iterable.iterator());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<R>", "classes": []}, "docstring": "\nReturns an iterable over the right slice of an iterable.\n\n@param iterable Iterable over pairs\n@param <L>      right type\n@param <R>      Right type\n@return Iterable over the right elements\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<K>]left(List<? extends Map.Entry<K, V>>)", "name": "left", "arg_nums": 1, "params": [{"name": "pairs", "type": "List<? extends Map.Entry<K, V>>"}], "return_type": "List<K>", "signature": "public static <K, V> List<K> left(\n      final List<? extends Map.Entry<K, V>> pairs)", "original_string": "  public static <K, V> List<K> left(\n      final List<? extends Map.Entry<K, V>> pairs) {\n    return new AbstractList<K>() {\n      public K get(int index) {\n        return pairs.get(index).getKey();\n      }\n\n      public int size() {\n        return pairs.size();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<K>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[List<V>]right(List<? extends Map.Entry<K, V>>)", "name": "right", "arg_nums": 1, "params": [{"name": "pairs", "type": "List<? extends Map.Entry<K, V>>"}], "return_type": "List<V>", "signature": "public static <K, V> List<V> right(\n      final List<? extends Map.Entry<K, V>> pairs)", "original_string": "  public static <K, V> List<V> right(\n      final List<? extends Map.Entry<K, V>> pairs) {\n    return new AbstractList<V>() {\n      public V get(int index) {\n        return pairs.get(index).getValue();\n      }\n\n      public int size() {\n        return pairs.size();\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<V>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<Pair<T, T>>]adjacents(Iterable<T>)", "name": "adjacents", "arg_nums": 1, "params": [{"name": "iterable", "type": "Iterable<T>"}], "return_type": "Iterable<Pair<T, T>>", "signature": "public static <T> Iterable<Pair<T, T>> adjacents(final Iterable<T> iterable)", "original_string": "  public static <T> Iterable<Pair<T, T>> adjacents(final Iterable<T> iterable) {\n    return () -> {\n      final Iterator<T> iterator = iterable.iterator();\n      if (!iterator.hasNext()) {\n        return Collections.emptyIterator();\n      }\n      return new AdjacentIterator<>(iterator);\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<Pair<T, T>>", "classes": []}, "docstring": "\nReturns an iterator that iterates over (i, i + 1) pairs in an iterable.\n\n<p>For example, {@code adjacents([3, 5, 7])} returns [(3, 5), (5, 7)].\n\n@param iterable Source collection\n@param <T> Element type\n@return Iterable over adjacent element pairs\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair.[Iterable<Pair<T, T>>]firstAnd(Iterable<T>)", "name": "firstAnd", "arg_nums": 1, "params": [{"name": "iterable", "type": "Iterable<T>"}], "return_type": "Iterable<Pair<T, T>>", "signature": "public static <T> Iterable<Pair<T, T>> firstAnd(final Iterable<T> iterable)", "original_string": "  public static <T> Iterable<Pair<T, T>> firstAnd(final Iterable<T> iterable) {\n    return () -> {\n      final Iterator<T> iterator = iterable.iterator();\n      if (!iterator.hasNext()) {\n        return Collections.emptyIterator();\n      }\n      final T first = iterator.next();\n      return new FirstAndIterator<>(iterator, first);\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Pair.java", "class_name": "Pair", "class_uri": "src/main/java/net/hydromatic/morel/util/Pair.java.Pair", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<Pair<T, T>>", "classes": []}, "docstring": "\nReturns an iterator that iterates over (0, i) pairs in an iterable for\ni &gt; 0.\n\n<p>For example, {@code firstAnd([3, 5, 7])} returns [(3, 5), (3, 7)].\n\n@param iterable Source collection\n@param <T> Element type\n@return Iterable over pairs of the first element and all other elements\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[List<E>]toList()", "name": "toList", "arg_nums": 0, "params": [], "return_type": "List<E>", "signature": "protected abstract List<E> toList()", "original_string": "  protected abstract List<E> toList();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[Iterator<E>]iterator()", "name": "iterator", "arg_nums": 0, "params": [], "return_type": "Iterator<E>", "signature": "@NonNull public Iterator<E> iterator()", "original_string": "  @NonNull public Iterator<E> iterator() {\n    return toList().iterator();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "@NonNull public", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[ListIterator<E>]listIterator()", "name": "listIterator", "arg_nums": 0, "params": [], "return_type": "ListIterator<E>", "signature": "@NonNull public ListIterator<E> listIterator()", "original_string": "  @NonNull public ListIterator<E> listIterator() {\n    return toList().listIterator();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "@NonNull public", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]isEmpty()", "name": "isEmpty", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isEmpty()", "original_string": "  public boolean isEmpty() {\n    return false;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]add(E)", "name": "add", "arg_nums": 1, "params": [{"name": "t", "type": "E"}], "return_type": "boolean", "signature": "public boolean add(E t)", "original_string": "  public boolean add(E t) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]addAll(Collection<? extends E>)", "name": "addAll", "arg_nums": 1, "params": [{"name": "c", "type": "Collection<? extends E>"}], "return_type": "boolean", "signature": "public boolean addAll(@NonNull Collection<? extends E> c)", "original_string": "  public boolean addAll(@NonNull Collection<? extends E> c) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]addAll(int,Collection<? extends E>)", "name": "addAll", "arg_nums": 2, "params": [{"name": "index", "type": "int"}, {"name": "c", "type": "Collection<? extends E>"}], "return_type": "boolean", "signature": "public boolean addAll(int index, @NonNull Collection<? extends E> c)", "original_string": "  public boolean addAll(int index, @NonNull Collection<? extends E> c) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]removeAll(Collection<?>)", "name": "removeAll", "arg_nums": 1, "params": [{"name": "c", "type": "Collection<?>"}], "return_type": "boolean", "signature": "public boolean removeAll(@NonNull Collection<?> c)", "original_string": "  public boolean removeAll(@NonNull Collection<?> c) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]retainAll(Collection<?>)", "name": "retainAll", "arg_nums": 1, "params": [{"name": "c", "type": "Collection<?>"}], "return_type": "boolean", "signature": "public boolean retainAll(@NonNull Collection<?> c)", "original_string": "  public boolean retainAll(@NonNull Collection<?> c) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[void]clear()", "name": "clear", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void clear()", "original_string": "  public void clear() {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[E]set(int,E)", "name": "set", "arg_nums": 2, "params": [{"name": "index", "type": "int"}, {"name": "element", "type": "E"}], "return_type": "E", "signature": "public E set(int index, E element)", "original_string": "  public E set(int index, E element) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[void]add(int,E)", "name": "add", "arg_nums": 2, "params": [{"name": "index", "type": "int"}, {"name": "element", "type": "E"}], "return_type": "void", "signature": "public void add(int index, E element)", "original_string": "  public void add(int index, E element) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[E]remove(int)", "name": "remove", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "E", "signature": "public E remove(int index)", "original_string": "  public E remove(int index) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[ListIterator<E>]listIterator(int)", "name": "listIterator", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "ListIterator<E>", "signature": "@NonNull public ListIterator<E> listIterator(int index)", "original_string": "  @NonNull public ListIterator<E> listIterator(int index) {\n    return toList().listIterator(index);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "@NonNull public", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[List<E>]subList(int,int)", "name": "subList", "arg_nums": 2, "params": [{"name": "fromIndex", "type": "int"}, {"name": "toIndex", "type": "int"}], "return_type": "List<E>", "signature": "@NonNull public List<E> subList(int fromIndex, int toIndex)", "original_string": "  @NonNull public List<E> subList(int fromIndex, int toIndex) {\n    return toList().subList(fromIndex, toIndex);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "@NonNull public", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]contains(Object)", "name": "contains", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "boolean", "signature": "public boolean contains(Object o)", "original_string": "  public boolean contains(Object o) {\n    return indexOf(o) >= 0;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]containsAll(Collection<?>)", "name": "containsAll", "arg_nums": 1, "params": [{"name": "c", "type": "Collection<?>"}], "return_type": "boolean", "signature": "public boolean containsAll(@NonNull Collection<?> c)", "original_string": "  public boolean containsAll(@NonNull Collection<?> c) {\n    for (Object o : c) {\n      if (!contains(o)) {\n        return false;\n      }\n    }\n    return true;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList.[boolean]remove(Object)", "name": "remove", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "boolean", "signature": "public boolean remove(Object o)", "original_string": "  public boolean remove(Object o) {\n    throw new UnsupportedOperationException();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java", "class_name": "AbstractImmutableList", "class_uri": "src/main/java/net/hydromatic/morel/util/AbstractImmutableList.java.AbstractImmutableList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]of()", "name": "of", "arg_nums": 0, "params": [], "return_type": "PairList<T, U>", "signature": "static <T, U> PairList<T, U> of()", "original_string": "  static <T, U> PairList<T, U> of() {\n    return new PairLists.MutablePairList<>(new ArrayList<>());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "PairList<T, U>", "classes": []}, "docstring": " Creates an empty PairList."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]of(T,U)", "name": "of", "arg_nums": 2, "params": [{"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "return_type": "PairList<T, U>", "signature": "@SuppressWarnings(\"RedundantCast\")\n  static <T, U> PairList<T, U> of(T t, U u)", "original_string": "  @SuppressWarnings(\"RedundantCast\")\n  static <T, U> PairList<T, U> of(T t, U u) {\n    final List<@Nullable Object> list = new ArrayList<>();\n    list.add((Object) t);\n    list.add((Object) u);\n    return new PairLists.MutablePairList<>(list);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "@SuppressWarnings(\"RedundantCast\")\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"RedundantCast\")", "static"], "comments": [], "return_type": "PairList<T, U>", "classes": []}, "docstring": " Creates a singleton PairList."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]copyOf(T,U)", "name": "copyOf", "arg_nums": 2, "params": [{"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "return_type": "PairList<T, U>", "signature": "static <T, U> PairList<T, U> copyOf(T t, U u, Object... rest)", "original_string": "  static <T, U> PairList<T, U> copyOf(T t, U u, Object... rest) {\n    checkArgument(rest.length % 2 == 0, \"even number\");\n    final List<Object> list = Lists.asList(t, u, rest);\n    return new PairLists.MutablePairList<>(new ArrayList<>(list));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "PairList<T, U>", "classes": []}, "docstring": " Creates a PairList with one or more entries."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]withCapacity(int)", "name": "withCapacity", "arg_nums": 1, "params": [{"name": "initialCapacity", "type": "int"}], "return_type": "PairList<T, U>", "signature": "static <T, U> PairList<T, U> withCapacity(int initialCapacity)", "original_string": "  static <T, U> PairList<T, U> withCapacity(int initialCapacity) {\n    return backedBy(new ArrayList<>(initialCapacity));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "PairList<T, U>", "classes": []}, "docstring": " Creates an empty PairList with a specified initial capacity."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]backedBy(List<@Nullable Object>)", "name": "backedBy", "arg_nums": 1, "params": [{"name": "list", "type": "List<@Nullable Object>"}], "return_type": "PairList<T, U>", "signature": "static <T, U> PairList<T, U> backedBy(List<@Nullable Object> list)", "original_string": "  static <T, U> PairList<T, U> backedBy(List<@Nullable Object> list) {\n    return new PairLists.MutablePairList<>(list);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "PairList<T, U>", "classes": []}, "docstring": " Creates a PairList backed by a given list.\n\n<p>Changes to the backing list will be reflected in the PairList.\nIf the backing list is immutable, this PairList will be also."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[PairList<T, U>]of(Map<T, U>)", "name": "of", "arg_nums": 1, "params": [{"name": "map", "type": "Map<T, U>"}], "return_type": "PairList<T, U>", "signature": "@SuppressWarnings(\"RedundantCast\")\n  static <T, U> PairList<T, U> of(Map<T, U> map)", "original_string": "  @SuppressWarnings(\"RedundantCast\")\n  static <T, U> PairList<T, U> of(Map<T, U> map) {\n    final List<@Nullable Object> list = new ArrayList<>(map.size() * 2);\n    map.forEach((t, u) -> {\n      list.add((Object) t);\n      list.add((Object) u);\n    });\n    return new PairLists.MutablePairList<>(list);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "@SuppressWarnings(\"RedundantCast\")\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"RedundantCast\")", "static"], "comments": [], "return_type": "PairList<T, U>", "classes": []}, "docstring": " Creates a PairList from a Map."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[Builder<T, U>]builder()", "name": "builder", "arg_nums": 0, "params": [], "return_type": "Builder<T, U>", "signature": "static <T, U> Builder<T, U> builder()", "original_string": "  static <T, U> Builder<T, U> builder() {\n    return new Builder<>();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Builder<T, U>", "classes": []}, "docstring": " Creates a Builder."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[void]add(T,U)", "name": "add", "arg_nums": 2, "params": [{"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "return_type": "void", "signature": "default void add(T t, U u)", "original_string": "  default void add(T t, U u) {\n    throw new UnsupportedOperationException(\"add\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Adds a pair to this list."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[void]add(int,T,U)", "name": "add", "arg_nums": 3, "params": [{"name": "index", "type": "int"}, {"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "return_type": "void", "signature": "default void add(int index, T t, U u)", "original_string": "  default void add(int index, T t, U u) {\n    throw new UnsupportedOperationException(\"add\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Adds a pair to this list at a given position."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]addAll(PairList<T, U>)", "name": "addAll", "arg_nums": 1, "params": [{"name": "list2", "type": "PairList<T, U>"}], "return_type": "boolean", "signature": "default boolean addAll(PairList<T, U> list2)", "original_string": "  default boolean addAll(PairList<T, U> list2) {\n    throw new UnsupportedOperationException(\"addAll\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Adds to this list the contents of another PairList.\n\n<p>Equivalent to {@link #addAll(Collection)}, but more efficient."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]addAll(int,PairList<T, U>)", "name": "addAll", "arg_nums": 2, "params": [{"name": "index", "type": "int"}, {"name": "list2", "type": "PairList<T, U>"}], "return_type": "boolean", "signature": "default boolean addAll(int index, PairList<T, U> list2)", "original_string": "  default boolean addAll(int index, PairList<T, U> list2) {\n    throw new UnsupportedOperationException(\"addAll\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Adds to this list, at a given index, the contents of another PairList.\n\n<p>Equivalent to {@link #addAll(int, Collection)}, but more efficient."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[Map.Entry<T, U>]set(int,Map.Entry<T, U>)", "name": "set", "arg_nums": 2, "params": [{"name": "index", "type": "int"}, {"name": "entry", "type": "Map.Entry<T, U>"}], "return_type": "Map.Entry<T, U>", "signature": "@Override default Map.Entry<T, U> set(int index, Map.Entry<T, U> entry)", "original_string": "  @Override default Map.Entry<T, U> set(int index, Map.Entry<T, U> entry) {\n    return set(index, entry.getKey(), entry.getValue());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "@Override default", "marker_annotations": ["@Override"], "non_marker_annotations": ["default"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[Map.Entry<T, U>]set(int,T,U)", "name": "set", "arg_nums": 3, "params": [{"name": "index", "type": "int"}, {"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "return_type": "Map.Entry<T, U>", "signature": "default Map.Entry<T, U> set(int index, T t, U u)", "original_string": "  default Map.Entry<T, U> set(int index, T t, U u) {\n    throw new UnsupportedOperationException(\"set\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "docstring": " Sets the entry at position {@code index} to the pair {@code (t, u)}."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[Map.Entry<T, U>]remove(int)", "name": "remove", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "Map.Entry<T, U>", "signature": "@Override default Map.Entry<T, U> remove(int index)", "original_string": "  @Override default Map.Entry<T, U> remove(int index) {\n    throw new UnsupportedOperationException(\"remove\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "@Override default", "marker_annotations": ["@Override"], "non_marker_annotations": ["default"], "comments": [], "return_type": "Map.Entry<T, U>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[T]left(int)", "name": "left", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "T", "signature": "T left(int index)", "original_string": "  T left(int index);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "docstring": " Returns the left part of the {@code index}th pair."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[U]right(int)", "name": "right", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "U", "signature": "U right(int index)", "original_string": "  U right(int index);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "U", "classes": []}, "docstring": " Returns the right part of the {@code index}th pair."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[List<T>]leftList()", "name": "leftList", "arg_nums": 0, "params": [], "return_type": "List<T>", "signature": "List<T> leftList()", "original_string": "  List<T> leftList();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<T>", "classes": []}, "docstring": " Returns an unmodifiable list view consisting of the left entry of each\npair."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[List<U>]rightList()", "name": "rightList", "arg_nums": 0, "params": [], "return_type": "List<U>", "signature": "List<U> rightList()", "original_string": "  List<U> rightList();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<U>", "classes": []}, "docstring": " Returns an unmodifiable list view consisting of the right entry of each\npair."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[void]forEach(BiConsumer<T, U>)", "name": "forEach", "arg_nums": 1, "params": [{"name": "consumer", "type": "BiConsumer<T, U>"}], "return_type": "void", "signature": "void forEach(BiConsumer<T, U> consumer)", "original_string": "  void forEach(BiConsumer<T, U> consumer);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls a BiConsumer with each pair in this list."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[void]forEachIndexed(IndexedBiConsumer<T, U>)", "name": "forEachIndexed", "arg_nums": 1, "params": [{"name": "consumer", "type": "IndexedBiConsumer<T, U>"}], "return_type": "void", "signature": "void forEachIndexed(IndexedBiConsumer<T, U> consumer)", "original_string": "  void forEachIndexed(IndexedBiConsumer<T, U> consumer);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Calls a BiConsumer with each pair in this list."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[ImmutableMap<T, U>]toImmutableMap()", "name": "toImmutableMap", "arg_nums": 0, "params": [], "return_type": "ImmutableMap<T, U>", "signature": "default ImmutableMap<T, U> toImmutableMap()", "original_string": "  default ImmutableMap<T, U> toImmutableMap() {\n    final ImmutableMap.Builder<T, U> b = ImmutableMap.builder();\n    forEach((t, u) -> b.put(t, u));\n    return b.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "ImmutableMap<T, U>", "classes": []}, "docstring": " Creates an {@link ImmutableMap} whose entries are the pairs in this list.\nThrows if keys are not unique."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[ImmutablePairList<T, U>]immutable()", "name": "immutable", "arg_nums": 0, "params": [], "return_type": "ImmutablePairList<T, U>", "signature": "ImmutablePairList<T, U> immutable()", "original_string": "  ImmutablePairList<T, U> immutable();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ImmutablePairList<T, U>", "classes": []}, "docstring": " Returns an ImmutablePairList whose contents are the same as this\nPairList."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[List<R>]transform(BiFunction<T, U, R>)", "name": "transform", "arg_nums": 1, "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "return_type": "List<R>", "signature": "<R> List<R> transform(BiFunction<T, U, R> function)", "original_string": "  <R> List<R> transform(BiFunction<T, U, R> function);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<R>", "classes": []}, "docstring": " Applies a mapping function to each element of this list."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[ImmutableList<R>]transform2(BiFunction<T, U, R>)", "name": "transform2", "arg_nums": 1, "params": [{"name": "function", "type": "BiFunction<T, U, R>"}], "return_type": "ImmutableList<R>", "signature": "<R> ImmutableList<R> transform2(BiFunction<T, U, R> function)", "original_string": "  <R> ImmutableList<R> transform2(BiFunction<T, U, R> function);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ImmutableList<R>", "classes": []}, "docstring": " Applies a mapping function to each element of this list."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]anyMatch(BiPredicate<T, U>)", "name": "anyMatch", "arg_nums": 1, "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "return_type": "boolean", "signature": "boolean anyMatch(BiPredicate<T, U> predicate)", "original_string": "  boolean anyMatch(BiPredicate<T, U> predicate);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether the predicate is true for at least one pair\nin this list."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]allMatch(BiPredicate<T, U>)", "name": "allMatch", "arg_nums": 1, "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "return_type": "boolean", "signature": "boolean allMatch(BiPredicate<T, U> predicate)", "original_string": "  boolean allMatch(BiPredicate<T, U> predicate);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether the predicate is true for all pairs\nin this list."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[int]firstMatch(BiPredicate<T, U>)", "name": "firstMatch", "arg_nums": 1, "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "return_type": "int", "signature": "int firstMatch(BiPredicate<T, U> predicate)", "original_string": "  int firstMatch(BiPredicate<T, U> predicate);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": " Returns the index of the first match of a predicate."}, {"uris": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList.[boolean]noMatch(BiPredicate<T, U>)", "name": "noMatch", "arg_nums": 1, "params": [{"name": "predicate", "type": "BiPredicate<T, U>"}], "return_type": "boolean", "signature": "boolean noMatch(BiPredicate<T, U> predicate)", "original_string": "  boolean noMatch(BiPredicate<T, U> predicate);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairList.java", "class_name": "PairList", "class_uri": "src/main/java/net/hydromatic/morel/util/PairList.java.PairList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether the predicate is true for no pairs\nin this list."}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[boolean]occurs()", "name": "occurs", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean occurs()", "original_string": "  public boolean occurs() {\n    return false;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Whether this unifier checks for cycles in substitutions."}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Sequence]apply(String)", "name": "apply", "arg_nums": 1, "params": [{"name": "operator", "type": "String"}], "return_type": "Sequence", "signature": "public Sequence apply(String operator, Term... args)", "original_string": "  public Sequence apply(String operator, Term... args) {\n    return apply(operator, ImmutableList.copyOf(args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Sequence", "classes": []}, "docstring": " Creates a sequence, or returns an existing one with the same terms."}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Sequence]apply(String,Iterable<? extends Term>)", "name": "apply", "arg_nums": 2, "params": [{"name": "operator", "type": "String"}, {"name": "args", "type": "Iterable<? extends Term>"}], "return_type": "Sequence", "signature": "public Sequence apply(String operator, Iterable<? extends Term> args)", "original_string": "  public Sequence apply(String operator, Iterable<? extends Term> args) {\n    final Sequence sequence =\n        new Sequence(operator, ImmutableList.copyOf(args));\n    return sequenceMap.computeIfAbsent(sequence.toString(), n -> sequence);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Sequence", "classes": []}, "docstring": " Creates a sequence, or returns an existing one with the same terms."}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Variable]variable(String)", "name": "variable", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Variable", "signature": "public Variable variable(String name)", "original_string": "  public Variable variable(String name) {\n    return variableMap.computeIfAbsent(name, Variable::new);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Variable", "classes": []}, "docstring": " Creates a variable, or returns an existing one with the same name."}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Variable]variable(int)", "name": "variable", "arg_nums": 1, "params": [{"name": "ordinal", "type": "int"}], "return_type": "Variable", "signature": "public Variable variable(int ordinal)", "original_string": "  public Variable variable(int ordinal) {\n    String name = \"T\" + ordinal;\n    return variableMap.computeIfAbsent(name, name2 -> new Variable(ordinal));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Variable", "classes": []}, "docstring": " Creates a variable, or returns an existing one with the same ordinal."}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Variable]variable()", "name": "variable", "arg_nums": 0, "params": [], "return_type": "Variable", "signature": "public Variable variable()", "original_string": "  public Variable variable() {\n    for (;;) {\n      final int ordinal = varId++;\n      final String name = \"T\" + ordinal;\n      if (!variableMap.containsKey(name)) {\n        final Variable variable = new Variable(ordinal);\n        assert variable.name.equals(name);\n        variableMap.put(name, variable);\n        return variable;\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Variable", "classes": []}, "docstring": " Creates a new variable, with a new name."}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Term]atom(String)", "name": "atom", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Term", "signature": "public Term atom(String name)", "original_string": "  public Term atom(String name) {\n    return atomMap.computeIfAbsent(name, Sequence::new);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Term", "classes": []}, "docstring": " Creates an atom, or returns an existing one with the same name."}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Substitution]substitution()", "name": "substitution", "arg_nums": 0, "params": [], "return_type": "Substitution", "signature": "public Substitution substitution(Term... varTerms)", "original_string": "  public Substitution substitution(Term... varTerms) {\n    final ImmutableMap.Builder<Variable, Term> mapBuilder =\n        ImmutableMap.builder();\n    if (varTerms.length % 2 != 0) {\n      throw new AssertionError();\n    }\n    for (int i = 0; i < varTerms.length; i += 2) {\n      mapBuilder.put((Variable) varTerms[i + 1], varTerms[i]);\n    }\n    return new Substitution(mapBuilder.build());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Substitution", "classes": []}, "docstring": " Creates a substitution.\n\n<p>The arguments are alternating variable / term pairs. For example,\n{@code substitution(a, x, b, y)} becomes [a/X, b/Y]."}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Sequence]sequenceApply(String,Map<Variable, Term>,Iterable<Term>)", "name": "sequenceApply", "arg_nums": 3, "params": [{"name": "operator", "type": "String"}, {"name": "substitutions", "type": "Map<Variable, Term>"}, {"name": "terms", "type": "Iterable<Term>"}], "return_type": "Sequence", "signature": "static Sequence sequenceApply(String operator,\n      Map<Variable, Term> substitutions, Iterable<Term> terms)", "original_string": "  static Sequence sequenceApply(String operator,\n      Map<Variable, Term> substitutions, Iterable<Term> terms) {\n    final ImmutableList.Builder<Term> newTerms = ImmutableList.builder();\n    for (Term term : terms) {\n      newTerms.add(term.apply(substitutions));\n    }\n    return new Sequence(operator, newTerms.build());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Sequence", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Result]unify(List<TermTerm>,Map<Variable, Action>,Tracer)", "name": "unify", "arg_nums": 3, "params": [{"name": "termPairs", "type": "List<TermTerm>"}, {"name": "termActions", "type": "Map<Variable, Action>"}, {"name": "tracer", "type": "Tracer"}], "return_type": "Result", "signature": "public abstract @NonNull Result unify(List<TermTerm> termPairs,\n      Map<Variable, Action> termActions, Tracer tracer)", "original_string": "  public abstract @NonNull Result unify(List<TermTerm> termPairs,\n      Map<Variable, Action> termActions, Tracer tracer);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "public abstract @NonNull", "marker_annotations": ["@NonNull"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Result", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[void]checkCycles(Map<Variable, Term>,Map<Variable, Variable>)", "name": "checkCycles", "arg_nums": 2, "params": [{"name": "map", "type": "Map<Variable, Term>"}, {"name": "active", "type": "Map<Variable, Variable>"}], "return_type": "void", "signature": "private static void checkCycles(Map<Variable, Term> map,\n      Map<Variable, Variable> active)", "original_string": "  private static void checkCycles(Map<Variable, Term> map,\n      Map<Variable, Variable> active) throws CycleException {\n    for (Term term : map.values()) {\n      term.checkCycle(map, active);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier.[Failure]failure(String)", "name": "failure", "arg_nums": 1, "params": [{"name": "reason", "type": "String"}], "return_type": "Failure", "signature": "protected Failure failure(String reason)", "original_string": "  protected Failure failure(String reason) {\n    return new Failure() {\n      @Override public String toString() {\n        return reason;\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Unifier.java", "class_name": "Unifier", "class_uri": "src/main/java/net/hydromatic/morel/util/Unifier.java.Unifier", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Failure", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion.[]JavaVersion(List<Integer>)", "name": "JavaVersion", "arg_nums": 1, "params": [{"name": "components", "type": "List<Integer>"}], "return_type": "", "signature": "private JavaVersion(List<Integer> components)", "original_string": "  private JavaVersion(List<Integer> components) {\n    this.components = ImmutableList.copyOf(components);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/JavaVersion.java", "class_name": "JavaVersion", "class_uri": "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": " Private constructor."}, {"uris": "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion.[JavaVersion]of()", "name": "of", "arg_nums": 0, "params": [], "return_type": "JavaVersion", "signature": "public static JavaVersion of(int... components)", "original_string": "  public static JavaVersion of(int... components) {\n    List<Integer> list = new ArrayList<>();\n    for (int component : components) {\n      list.add(component);\n    }\n    return of(list);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/JavaVersion.java", "class_name": "JavaVersion", "class_uri": "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "JavaVersion", "classes": []}, "docstring": " Creates a version."}, {"uris": "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion.[JavaVersion]of(List<Integer>)", "name": "of", "arg_nums": 1, "params": [{"name": "componentList", "type": "List<Integer>"}], "return_type": "JavaVersion", "signature": "public static JavaVersion of(List<Integer> componentList)", "original_string": "  public static JavaVersion of(List<Integer> componentList) {\n    if (componentList.size() >= 2\n        && componentList.get(0) == 1\n        && componentList.get(1) <= 9) {\n      // JDK 1.8.x -> 8.x\n      componentList = componentList.subList(1, componentList.size());\n    }\n    return new JavaVersion(ImmutableList.copyOf(componentList));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/JavaVersion.java", "class_name": "JavaVersion", "class_uri": "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "JavaVersion", "classes": []}, "docstring": " Creates a version."}, {"uris": "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion.[int]compareTo(JavaVersion)", "name": "compareTo", "arg_nums": 1, "params": [{"name": "o", "type": "JavaVersion"}], "return_type": "int", "signature": "@Override public int compareTo(JavaVersion o)", "original_string": "  @Override public int compareTo(JavaVersion o) {\n    return COMPARATOR.compare(components, o.components);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/JavaVersion.java", "class_name": "JavaVersion", "class_uri": "src/main/java/net/hydromatic/morel/util/JavaVersion.java.JavaVersion", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[]Static()", "name": "Static", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Static()", "original_string": "  private Static() {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[boolean]getBooleanProperty(String,boolean)", "name": "getBooleanProperty", "arg_nums": 2, "params": [{"name": "prop", "type": "String"}, {"name": "defaultVal", "type": "boolean"}], "return_type": "boolean", "signature": "@SuppressWarnings(\"SimplifiableConditionalExpression\")\n  private static boolean getBooleanProperty(String prop, boolean defaultVal)", "original_string": "  @SuppressWarnings(\"SimplifiableConditionalExpression\")\n  private static boolean getBooleanProperty(String prop, boolean defaultVal) {\n    final String value = System.getProperty(prop);\n    if (value == null) {\n      return defaultVal;\n    }\n    final String low = value.toLowerCase(Locale.ROOT);\n    return low.equals(\"true\") || low.equals(\"1\") || low.isEmpty() ? true\n        : low.equals(\"false\") || low.equals(\"0\") ? false\n        : defaultVal;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "@SuppressWarnings(\"SimplifiableConditionalExpression\")\n  private static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"SimplifiableConditionalExpression\")", "private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns the value of a system property, converted into a boolean value.\n\n<p>Values \"\", \"true\", \"TRUE\" and \"1\" are treated as true;\n\"false\", \"FALSE\" and \"0\" treated as false;\nfor {@code null} and other values, returns {@code defaultVal}.\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[Collector<T, ImmutableList.Builder<T>, ImmutableList<T>>]toImmutableList()", "name": "toImmutableList", "arg_nums": 0, "params": [], "return_type": "Collector<T, ImmutableList.Builder<T>, ImmutableList<T>>", "signature": "public static <T> Collector<T, ImmutableList.Builder<T>, ImmutableList<T>>\n      toImmutableList()", "original_string": "  public static <T> Collector<T, ImmutableList.Builder<T>, ImmutableList<T>>\n      toImmutableList() {\n    return Collector.of(ImmutableList::builder, ImmutableList.Builder::add,\n        (t, u) -> {\n          t.addAll(u.build());\n          return t;\n        },\n        ImmutableList.Builder::build);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Collector<T, ImmutableList.Builder<T>, ImmutableList<T>>", "classes": []}, "docstring": "\nReturns a {@code Collector} that accumulates the input elements into a\nGuava {@link ImmutableList} via a {@link ImmutableList.Builder}.\n\n<p>It will be obsolete when we move to Guava 21.0,\nwhich has {@code ImmutableList.toImmutableList()}.\n\n@param <T> Type of the input elements\n\n@return a {@code Collector} that collects all the input elements into an\n{@link ImmutableList}, in encounter order\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[boolean]shorterThan(Iterable<E>,int)", "name": "shorterThan", "arg_nums": 2, "params": [{"name": "iterable", "type": "Iterable<E>"}, {"name": "n", "type": "int"}], "return_type": "boolean", "signature": "public static <E> boolean shorterThan(Iterable<E> iterable, int n)", "original_string": "  public static <E> boolean shorterThan(Iterable<E> iterable, int n) {\n    if (iterable instanceof Collection) {\n      return ((Collection<E>) iterable).size() < n;\n    }\n    if (n <= 0) {\n      return false;\n    }\n    int i = 0;\n    for (Iterator<E> iterator = iterable.iterator(); iterator.hasNext();\n         iterator.next()) {\n      if (++i == n) {\n        return false;\n      }\n    }\n    return true;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether an {@link Iterable} has fewer than {@code n} elements.\n\n@param <E> Element type\n"}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]skip(List<E>)", "name": "skip", "arg_nums": 1, "params": [{"name": "list", "type": "List<E>"}], "return_type": "List<E>", "signature": "public static <E> List<E> skip(List<E> list)", "original_string": "  public static <E> List<E> skip(List<E> list) {\n    return skip(list, 1);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": " Returns all but the first element of a list."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]skip(List<E>,int)", "name": "skip", "arg_nums": 2, "params": [{"name": "list", "type": "List<E>"}, {"name": "count", "type": "int"}], "return_type": "List<E>", "signature": "public static <E> List<E> skip(List<E> list, int count)", "original_string": "  public static <E> List<E> skip(List<E> list, int count) {\n    return list.subList(count, list.size());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": " Returns all but the first {@code count} elements of a list."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]append(List<E>,E)", "name": "append", "arg_nums": 2, "params": [{"name": "list", "type": "List<E>"}, {"name": "e", "type": "E"}], "return_type": "List<E>", "signature": "public static <E> List<E> append(List<E> list, E e)", "original_string": "  public static <E> List<E> append(List<E> list, E e) {\n    return ImmutableList.<E>builder().addAll(list).add(e).build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": " Returns a list with one element appended.\n\n@see ConsList"}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]plus(E,List<E>)", "name": "plus", "arg_nums": 2, "params": [{"name": "e", "type": "E"}, {"name": "list", "type": "List<E>"}], "return_type": "List<E>", "signature": "public static <E> List<E> plus(E e, List<E> list)", "original_string": "  public static <E> List<E> plus(E e, List<E> list) {\n    return ConsList.of(e, list);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": " Prepends an element to a list."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]minus(List<E>,E)", "name": "minus", "arg_nums": 2, "params": [{"name": "list", "type": "List<E>"}, {"name": "e", "type": "E"}], "return_type": "List<E>", "signature": "public static <E> List<E> minus(List<E> list, E e)", "original_string": "  public static <E> List<E> minus(List<E> list, E e) {\n    final ImmutableList.Builder<E> builder = ImmutableList.builder();\n    list.forEach(e2 -> {\n      if (!e2.equals(e)) {\n        builder.add(e2);\n      }\n    });\n    return builder.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": " Removes all occurrences of an element from a list."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[Map<K, V>]plus(Map<K, V>,K,V)", "name": "plus", "arg_nums": 3, "params": [{"name": "map", "type": "Map<K, V>"}, {"name": "k", "type": "K"}, {"name": "v", "type": "V"}], "return_type": "Map<K, V>", "signature": "public static <K, V> Map<K, V> plus(Map<K, V> map, K k, V v)", "original_string": "  public static <K, V> Map<K, V> plus(Map<K, V> map, K k, V v) {\n    return ImmutableMap.<K, V>builder()\n        .putAll(map)\n        .put(k, v)\n        .build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "docstring": " Adds an element to a map."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[SortedMap<K, V>]plus(SortedMap<K, V>,K,V)", "name": "plus", "arg_nums": 3, "params": [{"name": "map", "type": "SortedMap<K, V>"}, {"name": "k", "type": "K"}, {"name": "v", "type": "V"}], "return_type": "SortedMap<K, V>", "signature": "public static <K extends Comparable<K>, V> SortedMap<K, V> plus(\n      SortedMap<K, V> map, K k, V v)", "original_string": "  public static <K extends Comparable<K>, V> SortedMap<K, V> plus(\n      SortedMap<K, V> map, K k, V v) {\n    return new ImmutableSortedMap.Builder<K, V>(map.comparator())\n        .putAll(map)\n        .put(k, v)\n        .build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "docstring": " Adds an element to a sorted map."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[int]nextPowerOfTwo(int)", "name": "nextPowerOfTwo", "arg_nums": 1, "params": [{"name": "n", "type": "int"}], "return_type": "int", "signature": "public static int nextPowerOfTwo(int n)", "original_string": "  public static int nextPowerOfTwo(int n) {\n    final int p = Integer.numberOfLeadingZeros(n);\n    return 1 << (Integer.SIZE - p);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Next power of two."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<T>]transform(List<? extends E>,Function<E, T>)", "name": "transform", "arg_nums": 2, "params": [{"name": "elements", "type": "List<? extends E>"}, {"name": "mapper", "type": "Function<E, T>"}], "return_type": "List<T>", "signature": "public static <E, T> List<T> transform(List<? extends E> elements,\n      Function<E, T> mapper)", "original_string": "  public static <E, T> List<T> transform(List<? extends E> elements,\n      Function<E, T> mapper) {\n    return Util.transform(elements, mapper);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<T>", "classes": []}, "docstring": " Lazily transforms a list, applying a mapping function to each element."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[Iterable<T>]transform(Iterable<? extends E>,Function<E, T>)", "name": "transform", "arg_nums": 2, "params": [{"name": "elements", "type": "Iterable<? extends E>"}, {"name": "mapper", "type": "Function<E, T>"}], "return_type": "Iterable<T>", "signature": "public static <E, T> Iterable<T> transform(Iterable<? extends E> elements,\n      Function<E, T> mapper)", "original_string": "  public static <E, T> Iterable<T> transform(Iterable<? extends E> elements,\n      Function<E, T> mapper) {\n    return Iterables.transform(elements, mapper::apply);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<T>", "classes": []}, "docstring": " Lazily transforms an Iterable, applying a mapping function to each\nelement."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[ImmutableList<T>]transformEager(Iterable<? extends E>,Function<E, T>)", "name": "transformEager", "arg_nums": 2, "params": [{"name": "elements", "type": "Iterable<? extends E>"}, {"name": "mapper", "type": "Function<E, T>"}], "return_type": "ImmutableList<T>", "signature": "public static <E, T> ImmutableList<T> transformEager(\n      Iterable<? extends E> elements, Function<E, T> mapper)", "original_string": "  public static <E, T> ImmutableList<T> transformEager(\n      Iterable<? extends E> elements, Function<E, T> mapper) {\n    if (Iterables.isEmpty(elements)) {\n      // Save ourselves the effort of creating a Builder.\n      return ImmutableList.of();\n    }\n    final ImmutableList.Builder<T> b = ImmutableList.builder();\n    elements.forEach(e -> b.add(mapper.apply(e)));\n    return b.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ImmutableList<T>", "classes": []}, "docstring": " Eagerly converts an Iterable to an ImmutableList, applying a mapping\nfunction to each element."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[int]find(List<? extends E>,Predicate<E>)", "name": "find", "arg_nums": 2, "params": [{"name": "list", "type": "List<? extends E>"}, {"name": "predicate", "type": "Predicate<E>"}], "return_type": "int", "signature": "public static <E> int find(List<? extends E> list, Predicate<E> predicate)", "original_string": "  public static <E> int find(List<? extends E> list, Predicate<E> predicate) {\n    if (list instanceof RandomAccess) {\n      for (int i = 0; i < list.size(); i++) {\n        if (predicate.test(list.get(i))) {\n          return i;\n        }\n      }\n    } else {\n      int i = 0;\n      for (E e : list) {\n        if (predicate.test(e)) {\n          return i;\n        }\n        ++i;\n      }\n    }\n    return -1;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Returns the first index in a list where a predicate is true, or -1."}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[List<E>]intersect(List<E>,Iterable<? extends E>)", "name": "intersect", "arg_nums": 2, "params": [{"name": "list0", "type": "List<E>"}, {"name": "list1", "type": "Iterable<? extends E>"}], "return_type": "List<E>", "signature": "public static <E> List<E> intersect(List<E> list0,\n      Iterable<? extends E> list1)", "original_string": "  public static <E> List<E> intersect(List<E> list0,\n      Iterable<? extends E> list1) {\n    final ImmutableList.Builder<E> list2 = ImmutableList.builder();\n    final Set<E> set = new HashSet<>(list0);\n    for (E e : list1) {\n      if (set.contains(e)) {\n        list2.add(e);\n      }\n    }\n    return list2.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Static.java.Static.[String]str(StringBuilder)", "name": "str", "arg_nums": 1, "params": [{"name": "b", "type": "StringBuilder"}], "return_type": "String", "signature": "public static String str(StringBuilder b)", "original_string": "  public static String str(StringBuilder b) {\n    String s = b.toString();\n    b.setLength(0);\n    return s;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Static.java", "class_name": "Static", "class_uri": "src/main/java/net/hydromatic/morel/util/Static.java.Static", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Flushes a builder and returns its contents."}, {"uris": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Map<Variable, Boolean>]solve(Term)", "name": "solve", "arg_nums": 1, "params": [{"name": "term", "type": "Term"}], "return_type": "Map<Variable, Boolean>", "signature": "public @Nullable Map<Variable, Boolean> solve(Term term)", "original_string": "  public @Nullable Map<Variable, Boolean> solve(Term term) {\n    final List<List<Assignment>> allAssignments = new ArrayList<>();\n    for (Variable variable : variablesById.values()) {\n      allAssignments.add(\n          ImmutableList.of(new Assignment(variable, false),\n              new Assignment(variable, true)));\n    }\n\n    final boolean[] env = new boolean[nextVariable];\n    for (List<Assignment> assignments\n        : Lists.cartesianProduct(allAssignments)) {\n      assignments.forEach(a -> env[a.variable.id] = a.value);\n      if (term.evaluate(env)) {\n        final ImmutableMap.Builder<Variable, Boolean> builder =\n            ImmutableMap.builder();\n        assignments.forEach(a -> builder.put(a.variable, a.value));\n        return builder.build();\n      }\n    }\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Sat.java", "class_name": "Sat", "class_uri": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat", "attributes": {"modifiers": "public @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<Variable, Boolean>", "classes": []}, "docstring": " Finds an assignment of variables such that a term evaluates to true,\nor null if there is no solution."}, {"uris": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Variable]variable(String)", "name": "variable", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Variable", "signature": "public Variable variable(String name)", "original_string": "  public Variable variable(String name) {\n    Variable variable = variablesByName.get(name);\n    if (variable != null) {\n      return variable;\n    }\n    int id = nextVariable++;\n    variable = new Variable(id, name);\n    variablesById.put(id, variable);\n    variablesByName.put(name, variable);\n    return variable;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Sat.java", "class_name": "Sat", "class_uri": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Variable", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]not(Term)", "name": "not", "arg_nums": 1, "params": [{"name": "term", "type": "Term"}], "return_type": "Term", "signature": "public Term not(Term term)", "original_string": "  public Term not(Term term) {\n    return new Not(term);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Sat.java", "class_name": "Sat", "class_uri": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Term", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]and()", "name": "and", "arg_nums": 0, "params": [], "return_type": "Term", "signature": "public Term and(Term... terms)", "original_string": "  public Term and(Term... terms) {\n    return new And(ImmutableList.copyOf(terms));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Sat.java", "class_name": "Sat", "class_uri": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Term", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]and(Iterable<?extends Term>)", "name": "and", "arg_nums": 1, "params": [{"name": "terms", "type": "Iterable<?extends Term>"}], "return_type": "Term", "signature": "public Term and(Iterable<?extends Term> terms)", "original_string": "  public Term and(Iterable<?extends Term> terms) {\n    return new And(ImmutableList.copyOf(terms));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Sat.java", "class_name": "Sat", "class_uri": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Term", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]or()", "name": "or", "arg_nums": 0, "params": [], "return_type": "Term", "signature": "public Term or(Term... terms)", "original_string": "  public Term or(Term... terms) {\n    return new Or(ImmutableList.copyOf(terms));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Sat.java", "class_name": "Sat", "class_uri": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Term", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat.[Term]or(Iterable<?extends Term>)", "name": "or", "arg_nums": 1, "params": [{"name": "terms", "type": "Iterable<?extends Term>"}], "return_type": "Term", "signature": "public Term or(Iterable<?extends Term> terms)", "original_string": "  public Term or(Iterable<?extends Term> terms) {\n    return new Or(ImmutableList.copyOf(terms));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/Sat.java", "class_name": "Sat", "class_uri": "src/main/java/net/hydromatic/morel/util/Sat.java.Sat", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Term", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[ImmutablePairList<T, U>]of()", "name": "of", "arg_nums": 0, "params": [], "return_type": "ImmutablePairList<T, U>", "signature": "@SuppressWarnings(\"unchecked\")\n  static <T, U> ImmutablePairList<T, U> of()", "original_string": "  @SuppressWarnings(\"unchecked\")\n  static <T, U> ImmutablePairList<T, U> of() {\n    return (ImmutablePairList<T, U>) PairLists.EMPTY;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java", "class_name": "ImmutablePairList", "class_uri": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "static"], "comments": [], "return_type": "ImmutablePairList<T, U>", "classes": []}, "docstring": " Creates an empty ImmutablePairList."}, {"uris": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[ImmutablePairList<T, U>]of(T,U)", "name": "of", "arg_nums": 2, "params": [{"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "return_type": "ImmutablePairList<T, U>", "signature": "static <T, U> ImmutablePairList<T, U> of(T t, U u)", "original_string": "  static <T, U> ImmutablePairList<T, U> of(T t, U u) {\n    return new PairLists.SingletonImmutablePairList<>(t, u);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java", "class_name": "ImmutablePairList", "class_uri": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "ImmutablePairList<T, U>", "classes": []}, "docstring": " Creates a singleton ImmutablePairList."}, {"uris": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[PairList<T, U>]copyOf(T,U)", "name": "copyOf", "arg_nums": 2, "params": [{"name": "t", "type": "T"}, {"name": "u", "type": "U"}], "return_type": "PairList<T, U>", "signature": "static <T, U> PairList<T, U> copyOf(T t, U u, Object... rest)", "original_string": "  static <T, U> PairList<T, U> copyOf(T t, U u, Object... rest) {\n    checkArgument(rest.length % 2 == 0, \"even number\");\n    if (rest.length == 0) {\n      return new PairLists.SingletonImmutablePairList<>(t, u);\n    }\n    Object[] elements = new Object[rest.length + 2];\n    elements[0] = t;\n    elements[1] = u;\n    System.arraycopy(rest, 0, elements, 2, rest.length);\n    return new PairLists.ArrayImmutablePairList<>(elements);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java", "class_name": "ImmutablePairList", "class_uri": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "PairList<T, U>", "classes": []}, "docstring": " Creates an ImmutablePairList with one or more entries."}, {"uris": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[ImmutablePairList<T, U>]copyOf(Iterable<? extends Map.Entry<T, U>>)", "name": "copyOf", "arg_nums": 1, "params": [{"name": "iterable", "type": "Iterable<? extends Map.Entry<T, U>>"}], "return_type": "ImmutablePairList<T, U>", "signature": "@SuppressWarnings(\"unchecked\")\n  static <T, U> ImmutablePairList<T, U> copyOf(\n      Iterable<? extends Map.Entry<T, U>> iterable)", "original_string": "  @SuppressWarnings(\"unchecked\")\n  static <T, U> ImmutablePairList<T, U> copyOf(\n      Iterable<? extends Map.Entry<T, U>> iterable) {\n    // Every PairList - mutable and immutable - knows how to quickly make\n    // itself immutable.\n    if (iterable instanceof PairList) {\n      return ((PairList<T, U>) iterable).immutable();\n    }\n\n    // If it's a collection, we know its size, and therefore can create an\n    // array directly, without an intermediate ArrayList.\n    if (iterable instanceof Collection) {\n      final Collection<? extends Map.Entry<T, U>> collection =\n          (Collection<? extends Map.Entry<T, U>>) iterable;\n      switch (collection.size()) {\n      case 0:\n        return of();\n\n      case 1:\n        // Use of iterator is suboptimal. If we knew this was a list we could\n        // call get(0), but the special case doesn't seem worth the effort.\n        final Map.Entry<T, U> entry = iterable.iterator().next();\n        return of(entry.getKey(), entry.getValue());\n\n      default:\n        Object[] elements = new Object[2 * collection.size()];\n        int i = 0;\n        for (Map.Entry<T, U> entry2 : iterable) {\n          elements[i++] = entry2.getKey();\n          elements[i++] = entry2.getValue();\n        }\n        return new PairLists.ArrayImmutablePairList<>(elements);\n      }\n    }\n\n    // Not a collection, so we don't know its size in advance.\n    final List<Object> list = new ArrayList<>();\n    iterable.forEach(entry -> {\n      list.add(entry.getKey());\n      list.add(entry.getValue());\n    });\n    return PairLists.immutableBackedBy(list);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java", "class_name": "ImmutablePairList", "class_uri": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "static"], "comments": [], "return_type": "ImmutablePairList<T, U>", "classes": []}, "docstring": " Creates an ImmutablePairList whose contents are a copy of a given\ncollection."}, {"uris": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList.[ImmutablePairList<T, U>]immutable()", "name": "immutable", "arg_nums": 0, "params": [], "return_type": "ImmutablePairList<T, U>", "signature": "@Override default ImmutablePairList<T, U> immutable()", "original_string": "  @Override default ImmutablePairList<T, U> immutable() {\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java", "class_name": "ImmutablePairList", "class_uri": "src/main/java/net/hydromatic/morel/util/ImmutablePairList.java.ImmutablePairList", "attributes": {"modifiers": "@Override default", "marker_annotations": ["@Override"], "non_marker_annotations": ["default"], "comments": [], "return_type": "ImmutablePairList<T, U>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists.[]PairLists()", "name": "PairLists", "arg_nums": 0, "params": [], "return_type": "", "signature": "private PairLists()", "original_string": "  private PairLists() {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairLists.java", "class_name": "PairLists", "class_uri": "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists.[ImmutablePairList<T, U>]immutableBackedBy(List<Object>)", "name": "immutableBackedBy", "arg_nums": 1, "params": [{"name": "list", "type": "List<Object>"}], "return_type": "ImmutablePairList<T, U>", "signature": "@SuppressWarnings(\"unchecked\")\n  static <T, U> ImmutablePairList<T, U> immutableBackedBy(List<Object> list)", "original_string": "  @SuppressWarnings(\"unchecked\")\n  static <T, U> ImmutablePairList<T, U> immutableBackedBy(List<Object> list) {\n    switch (list.size()) {\n    case 0:\n      return ImmutablePairList.of();\n    case 2:\n      return new SingletonImmutablePairList<>((T) list.get(0), (U) list.get(1));\n    default:\n      return new ArrayImmutablePairList<>(list.toArray());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairLists.java", "class_name": "PairLists", "class_uri": "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "static"], "comments": [], "return_type": "ImmutablePairList<T, U>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists.[Object[]]checkElementsNotNull()", "name": "checkElementsNotNull", "arg_nums": 0, "params": [], "return_type": "Object[]", "signature": "@CanIgnoreReturnValue\n  static Object[] checkElementsNotNull(Object... elements)", "original_string": "  @CanIgnoreReturnValue\n  static Object[] checkElementsNotNull(Object... elements) {\n    for (int i = 0; i < elements.length; i++) {\n      checkElementNotNull(i, elements[i]);\n    }\n    return elements;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairLists.java", "class_name": "PairLists", "class_uri": "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists", "attributes": {"modifiers": "@CanIgnoreReturnValue\n  static", "marker_annotations": ["@CanIgnoreReturnValue"], "non_marker_annotations": ["static"], "comments": [], "return_type": "Object[]", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists.[void]checkElementNotNull(int,Object)", "name": "checkElementNotNull", "arg_nums": 2, "params": [{"name": "i", "type": "int"}, {"name": "element", "type": "Object"}], "return_type": "void", "signature": "static void checkElementNotNull(int i, Object element)", "original_string": "  static void checkElementNotNull(int i, Object element) {\n    if (element == null) {\n      throw new NullPointerException((i % 2 == 0 ? \"key\" : \"value\")\n          + \" at index \" + (i / 2));\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/PairLists.java", "class_name": "PairLists", "class_uri": "src/main/java/net/hydromatic/morel/util/PairLists.java.PairLists", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[]ComparableSingletonList(E)", "name": "ComparableSingletonList", "arg_nums": 1, "params": [{"name": "element", "type": "E"}], "return_type": "", "signature": "ComparableSingletonList(E element)", "original_string": "  ComparableSingletonList(E element) {\n    this.element = requireNonNull(element);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java", "class_name": "ComparableSingletonList", "class_uri": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[ComparableSingletonList<E>]of(E)", "name": "of", "arg_nums": 1, "params": [{"name": "e", "type": "E"}], "return_type": "ComparableSingletonList<E>", "signature": "public static <E extends Comparable<E>> ComparableSingletonList<E> of(E e)", "original_string": "  public static <E extends Comparable<E>> ComparableSingletonList<E> of(E e) {\n    return new ComparableSingletonList<>(e);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java", "class_name": "ComparableSingletonList", "class_uri": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ComparableSingletonList<E>", "classes": []}, "docstring": " Creates a ComparableSingletonList."}, {"uris": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[E]get(int)", "name": "get", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "E", "signature": "@Override public E get(int index)", "original_string": "  @Override public E get(int index) {\n    assert index == 0;\n    return element;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java", "class_name": "ComparableSingletonList", "class_uri": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[int]size()", "name": "size", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override public int size()", "original_string": "  @Override public int size() {\n    return 1;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java", "class_name": "ComparableSingletonList", "class_uri": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList.[int]compareTo(ComparableSingletonList<E>)", "name": "compareTo", "arg_nums": 1, "params": [{"name": "o", "type": "ComparableSingletonList<E>"}], "return_type": "int", "signature": "@Override public int compareTo(ComparableSingletonList<E> o)", "original_string": "  @Override public int compareTo(ComparableSingletonList<E> o) {\n    return element.compareTo(o.element);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java", "class_name": "ComparableSingletonList", "class_uri": "src/main/java/net/hydromatic/morel/util/ComparableSingletonList.java.ComparableSingletonList", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[]ThreadLocals()", "name": "ThreadLocals", "arg_nums": 0, "params": [], "return_type": "", "signature": "private ThreadLocals()", "original_string": "  private ThreadLocals() {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java", "class_name": "ThreadLocals", "class_uri": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[void]let(ThreadLocal<T>,T,Runnable)", "name": "let", "arg_nums": 3, "params": [{"name": "threadLocal", "type": "ThreadLocal<T>"}, {"name": "value", "type": "T"}, {"name": "runnable", "type": "Runnable"}], "return_type": "void", "signature": "public static <T> void let(ThreadLocal<T> threadLocal, T value,\n      Runnable runnable)", "original_string": "  public static <T> void let(ThreadLocal<T> threadLocal, T value,\n      Runnable runnable) {\n    final T originalValue = threadLocal.get();\n    threadLocal.set(value);\n    try {\n      runnable.run();\n    } finally {\n      // Restore the original value. I wish there were a way to know that the\n      // original value was present because threadLocal was initially not set.\n      threadLocal.set(originalValue);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java", "class_name": "ThreadLocals", "class_uri": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Performs an action with a thread-local set to a particular value."}, {"uris": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[R]let(ThreadLocal<T>,T,Supplier<R>)", "name": "let", "arg_nums": 3, "params": [{"name": "threadLocal", "type": "ThreadLocal<T>"}, {"name": "value", "type": "T"}, {"name": "supplier", "type": "Supplier<R>"}], "return_type": "R", "signature": "public static <T, R> R let(ThreadLocal<T> threadLocal, T value,\n      Supplier<R> supplier)", "original_string": "  public static <T, R> R let(ThreadLocal<T> threadLocal, T value,\n      Supplier<R> supplier) {\n    final T originalValue = threadLocal.get();\n    threadLocal.set(value);\n    try {\n      return supplier.get();\n    } finally {\n      // Restore the original value. I wish there were a way to know that the\n      // original value was present because threadLocal was initially not set.\n      threadLocal.set(originalValue);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java", "class_name": "ThreadLocals", "class_uri": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Performs an action with a thread-local set to a particular value,\nand returns the result."}, {"uris": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[void]mutate(ThreadLocal<T>,UnaryOperator<T>,Runnable)", "name": "mutate", "arg_nums": 3, "params": [{"name": "threadLocal", "type": "ThreadLocal<T>"}, {"name": "transform", "type": "UnaryOperator<T>"}, {"name": "runnable", "type": "Runnable"}], "return_type": "void", "signature": "public static <T> void mutate(ThreadLocal<T> threadLocal,\n      UnaryOperator<T> transform, Runnable runnable)", "original_string": "  public static <T> void mutate(ThreadLocal<T> threadLocal,\n      UnaryOperator<T> transform, Runnable runnable) {\n    let(threadLocal, transform.apply(threadLocal.get()), runnable);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java", "class_name": "ThreadLocals", "class_uri": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Performs an action with a thread-local set to a value derived from its\ncurrent value via a transformer."}, {"uris": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals.[R]mutate(ThreadLocal<T>,UnaryOperator<T>,Supplier<R>)", "name": "mutate", "arg_nums": 3, "params": [{"name": "threadLocal", "type": "ThreadLocal<T>"}, {"name": "transform", "type": "UnaryOperator<T>"}, {"name": "supplier", "type": "Supplier<R>"}], "return_type": "R", "signature": "public static <T, R> R mutate(ThreadLocal<T> threadLocal,\n      UnaryOperator<T> transform, Supplier<R> supplier)", "original_string": "  public static <T, R> R mutate(ThreadLocal<T> threadLocal,\n      UnaryOperator<T> transform, Supplier<R> supplier) {\n    return let(threadLocal, transform.apply(threadLocal.get()), supplier);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java", "class_name": "ThreadLocals", "class_uri": "src/main/java/net/hydromatic/morel/util/ThreadLocals.java.ThreadLocals", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Performs an action with a thread-local set to a value derived from its\ncurrent value via a transformer,\nand returns the result."}, {"uris": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[]ParameterizedType(Op,String,String,int)", "name": "ParameterizedType", "arg_nums": 4, "params": [{"name": "op", "type": "Op"}, {"name": "name", "type": "String"}, {"name": "moniker", "type": "String"}, {"name": "parameterCount", "type": "int"}], "return_type": "", "signature": "ParameterizedType(Op op, String name, String moniker, int parameterCount)", "original_string": "  ParameterizedType(Op op, String name, String moniker, int parameterCount) {\n    super(op);\n    this.name = requireNonNull(name);\n    this.moniker = requireNonNull(moniker);\n    this.parameterTypes = MapList.of(parameterCount, TypeVar::new);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java", "class_name": "ParameterizedType", "class_uri": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a ParameterizedType."}, {"uris": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[String]name()", "name": "name", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String name()", "original_string": "  public String name() {\n    return name;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java", "class_name": "ParameterizedType", "class_uri": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[String]moniker()", "name": "moniker", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String moniker()", "original_string": "  @Override public String moniker() {\n    return moniker;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java", "class_name": "ParameterizedType", "class_uri": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return moniker;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java", "class_name": "ParameterizedType", "class_uri": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType.[String]computeMoniker(String,List<? extends Type>)", "name": "computeMoniker", "arg_nums": 2, "params": [{"name": "name", "type": "String"}, {"name": "typeVars", "type": "List<? extends Type>"}], "return_type": "String", "signature": "static String computeMoniker(String name, List<? extends Type> typeVars)", "original_string": "  static String computeMoniker(String name, List<? extends Type> typeVars) {\n    if (typeVars.isEmpty()) {\n      return name;\n    }\n    final StringBuilder b = new StringBuilder();\n    if (typeVars.size() > 1) {\n      b.append('(');\n    }\n    forEachIndexed(typeVars, (t, i) -> {\n      if (i > 0) {\n        b.append(\",\");\n      }\n      if (t instanceof TupleType) {\n        b.append('(').append(t.moniker()).append(')');\n      } else {\n        b.append(t.moniker());\n      }\n    });\n    if (typeVars.size() > 1) {\n      b.append(')');\n    }\n    return b.append(' ').append(name).toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java", "class_name": "ParameterizedType", "class_uri": "src/main/java/net/hydromatic/morel/type/ParameterizedType.java.ParameterizedType", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType.[SortedMap<String, Type>]argNameTypes()", "name": "argNameTypes", "arg_nums": 0, "params": [], "return_type": "SortedMap<String, Type>", "signature": "SortedMap<String, Type> argNameTypes()", "original_string": "  SortedMap<String, Type> argNameTypes();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java", "class_name": "RecordLikeType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "SortedMap<String, Type>", "classes": []}, "docstring": " Returns a map of the field types, keyed by field names."}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType.[List<Type>]argTypes()", "name": "argTypes", "arg_nums": 0, "params": [], "return_type": "List<Type>", "signature": "default List<Type> argTypes()", "original_string": "  default List<Type> argTypes() {\n    return ImmutableList.copyOf(argNameTypes().values());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java", "class_name": "RecordLikeType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "List<Type>", "classes": []}, "docstring": " Returns a list of field types, ordered by field names."}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType.[Type]argType(int)", "name": "argType", "arg_nums": 1, "params": [{"name": "i", "type": "int"}], "return_type": "Type", "signature": "Type argType(int i)", "original_string": "  Type argType(int i);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java", "class_name": "RecordLikeType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Returns the type of the {@code i}th field, or throws."}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType.[TypedValue]asTypedValue()", "name": "asTypedValue", "arg_nums": 0, "params": [], "return_type": "TypedValue", "signature": "default @Nullable TypedValue asTypedValue()", "original_string": "  default @Nullable TypedValue asTypedValue() {\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java", "class_name": "RecordLikeType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordLikeType.java.RecordLikeType", "attributes": {"modifiers": "default @Nullable", "marker_annotations": ["@Nullable"], "non_marker_annotations": ["default"], "comments": [], "return_type": "TypedValue", "classes": []}, "docstring": " Returns a {@link TypedValue} if this\ntype wraps a single dynamically typed value, otherwise null."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[]TypeVar(int)", "name": "TypeVar", "arg_nums": 1, "params": [{"name": "ordinal", "type": "int"}], "return_type": "", "signature": "public TypeVar(int ordinal)", "original_string": "  public TypeVar(int ordinal) {\n    checkArgument(ordinal >= 0);\n    this.ordinal = ordinal;\n    try {\n      this.name = requireNonNull(NAME_CACHE.get(ordinal));\n    } catch (ExecutionException e) {\n      throw new RuntimeException(e.getCause());\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a type variable with a given ordinal.\n\n<p>TypeVar.of(0) returns \"'a\"; TypeVar.of(1) returns \"'b\", etc."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override public int hashCode()", "original_string": "  @Override public int hashCode() {\n    return ordinal + 6563;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override public boolean equals(Object obj)", "original_string": "  @Override public boolean equals(Object obj) {\n    return obj == this\n        || obj instanceof TypeVar\n        && this.ordinal == ((TypeVar) obj).ordinal;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return name;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Returns a string for debugging."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[R]accept(TypeVisitor<R>)", "name": "accept", "arg_nums": 1, "params": [{"name": "typeVisitor", "type": "TypeVisitor<R>"}], "return_type": "R", "signature": "public <R> R accept(TypeVisitor<R> typeVisitor)", "original_string": "  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[String]name(int)", "name": "name", "arg_nums": 1, "params": [{"name": "i", "type": "int"}], "return_type": "String", "signature": "static String name(int i)", "original_string": "  static String name(int i) {\n    if (i < 0) {\n      throw new IllegalArgumentException();\n    }\n    final StringBuilder s = new StringBuilder();\n    for (;;) {\n      final int mod = i % 26;\n      s.append(ALPHAS[mod]);\n      i /= 26;\n      if (i == 0) {\n        return s.append(\"'\").reverse().toString();\n      }\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Generates a name for a type variable.\n\n<p>0 &rarr; 'a, 1 &rarr; 'b, 26 &rarr; 'z, 27 &rarr; 'ba, 28 &rarr; 'bb,\n675 &rarr; 'zz, 676 &rarr; 'baa, etc. (Think of it is a base 26 number,\nwith \"a\" as 0, \"z\" as 25.)"}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[Key]key()", "name": "key", "arg_nums": 0, "params": [], "return_type": "Key", "signature": "@Override public Key key()", "original_string": "  @Override public Key key() {\n    return Keys.ordinal(ordinal);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Key", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[Op]op()", "name": "op", "arg_nums": 0, "params": [], "return_type": "Op", "signature": "@Override public Op op()", "original_string": "  @Override public Op op() {\n    return Op.TY_VAR;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Op", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[Type]copy(TypeSystem,UnaryOperator<Type>)", "name": "copy", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "transform", "type": "UnaryOperator<Type>"}], "return_type": "Type", "signature": "@Override public Type copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform)", "original_string": "  @Override public Type copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    return transform.apply(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar.[Type]substitute(TypeSystem,List<? extends Type>)", "name": "substitute", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "types", "type": "List<? extends Type>"}], "return_type": "Type", "signature": "@Override public Type substitute(TypeSystem typeSystem,\n      List<? extends Type> types)", "original_string": "  @Override public Type substitute(TypeSystem typeSystem,\n      List<? extends Type> types) {\n    return types.get(ordinal);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVar.java", "class_name": "TypeVar", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVar.java.TypeVar", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Type.java.Type.[Key]key()", "name": "key", "arg_nums": 0, "params": [], "return_type": "Key", "signature": "Key key()", "original_string": "  Key key();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Type.java", "class_name": "Type", "class_uri": "src/main/java/net/hydromatic/morel/type/Type.java.Type", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Key", "classes": []}, "docstring": " Description of the type, e.g. \"{@code int}\", \"{@code int -> int}\",\n\"{@code NONE | SOME of 'a}\"."}, {"uris": "src/main/java/net/hydromatic/morel/type/Type.java.Type.[String]moniker()", "name": "moniker", "arg_nums": 0, "params": [], "return_type": "String", "signature": "default String moniker()", "original_string": "  default String moniker() {\n    return key().toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Type.java", "class_name": "Type", "class_uri": "src/main/java/net/hydromatic/morel/type/Type.java.Type", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Key of the type.\n\n<p>Often the same as {@link #key()}, but an exception is datatype.\nFor example, datatype \"{@code 'a option}\" has moniker and name\n\"{@code option}\" and description \"{@code NONE | SOME of 'a}\".\n\n<p>Use the description if you are looking for a type that is structurally\nequivalent. Use the moniker to identify it when printing."}, {"uris": "src/main/java/net/hydromatic/morel/type/Type.java.Type.[Op]op()", "name": "op", "arg_nums": 0, "params": [], "return_type": "Op", "signature": "Op op()", "original_string": "  Op op();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Type.java", "class_name": "Type", "class_uri": "src/main/java/net/hydromatic/morel/type/Type.java.Type", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Op", "classes": []}, "docstring": " Type operator."}, {"uris": "src/main/java/net/hydromatic/morel/type/Type.java.Type.[Type]copy(TypeSystem,UnaryOperator<Type>)", "name": "copy", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "transform", "type": "UnaryOperator<Type>"}], "return_type": "Type", "signature": "Type copy(TypeSystem typeSystem, UnaryOperator<Type> transform)", "original_string": "  Type copy(TypeSystem typeSystem, UnaryOperator<Type> transform);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Type.java", "class_name": "Type", "class_uri": "src/main/java/net/hydromatic/morel/type/Type.java.Type", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Copies this type, applying a given transform to component types,\nand returning the original type if the component types are unchanged."}, {"uris": "src/main/java/net/hydromatic/morel/type/Type.java.Type.[R]accept(TypeVisitor<R>)", "name": "accept", "arg_nums": 1, "params": [{"name": "typeVisitor", "type": "TypeVisitor<R>"}], "return_type": "R", "signature": "<R> R accept(TypeVisitor<R> typeVisitor)", "original_string": "  <R> R accept(TypeVisitor<R> typeVisitor);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Type.java", "class_name": "Type", "class_uri": "src/main/java/net/hydromatic/morel/type/Type.java.Type", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Type.java.Type.[Type]substitute(TypeSystem,List<? extends Type>)", "name": "substitute", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "types", "type": "List<? extends Type>"}], "return_type": "Type", "signature": "default Type substitute(TypeSystem typeSystem, List<? extends Type> types)", "original_string": "  default Type substitute(TypeSystem typeSystem, List<? extends Type> types) {\n    if (types.isEmpty()) {\n      return this;\n    }\n    return accept(\n        new TypeShuttle(typeSystem) {\n          @Override public Type visit(TypeVar typeVar) {\n            return types.get(typeVar.ordinal);\n          }\n        });\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Type.java", "class_name": "Type", "class_uri": "src/main/java/net/hydromatic/morel/type/Type.java.Type", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Returns a copy of this type, specialized by substituting type\nparameters."}, {"uris": "src/main/java/net/hydromatic/morel/type/Type.java.Type.[boolean]isProgressive()", "name": "isProgressive", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "default boolean isProgressive()", "original_string": "  default boolean isProgressive() {\n    return false;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Type.java", "class_name": "Type", "class_uri": "src/main/java/net/hydromatic/morel/type/Type.java.Type", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether this type is progressive.\n\n<p>Progressive types are records, but can have additional fields each time\nyou look.\n\n<p>The \"file\" value is an example."}, {"uris": "src/main/java/net/hydromatic/morel/type/Type.java.Type.[boolean]isFinite()", "name": "isFinite", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "default boolean isFinite()", "original_string": "  default boolean isFinite() {\n    return false;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Type.java", "class_name": "Type", "class_uri": "src/main/java/net/hydromatic/morel/type/Type.java.Type", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Whether this type has a small, fixed set of instances.\nTrue for {@code bool}, data types on finite types."}, {"uris": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[]Binding(Core.NamedPat,Core.Exp,Object,boolean)", "name": "Binding", "arg_nums": 4, "params": [{"name": "id", "type": "Core.NamedPat"}, {"name": "exp", "type": "Core.Exp"}, {"name": "value", "type": "Object"}, {"name": "parameter", "type": "boolean"}], "return_type": "", "signature": "private Binding(Core.NamedPat id, Core.Exp exp, Object value,\n      boolean parameter)", "original_string": "  private Binding(Core.NamedPat id, Core.Exp exp, Object value,\n      boolean parameter) {\n    this.id = requireNonNull(id);\n    this.exp = exp;\n    this.value = requireNonNull(value);\n    assert !(value instanceof Core.IdPat);\n    this.parameter = parameter;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Binding.java", "class_name": "Binding", "class_uri": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[Binding]of(Core.NamedPat)", "name": "of", "arg_nums": 1, "params": [{"name": "id", "type": "Core.NamedPat"}], "return_type": "Binding", "signature": "public static Binding of(Core.NamedPat id)", "original_string": "  public static Binding of(Core.NamedPat id) {\n    return new Binding(id, null, Unit.INSTANCE, false);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Binding.java", "class_name": "Binding", "class_uri": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Binding", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[Binding]of(Core.NamedPat,Core.Exp)", "name": "of", "arg_nums": 2, "params": [{"name": "id", "type": "Core.NamedPat"}, {"name": "exp", "type": "Core.Exp"}], "return_type": "Binding", "signature": "public static Binding of(Core.NamedPat id, Core.Exp exp)", "original_string": "  public static Binding of(Core.NamedPat id, Core.Exp exp) {\n    return new Binding(id, exp, Unit.INSTANCE, false);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Binding.java", "class_name": "Binding", "class_uri": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Binding", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[Binding]of(Core.NamedPat,Object)", "name": "of", "arg_nums": 2, "params": [{"name": "id", "type": "Core.NamedPat"}, {"name": "value", "type": "Object"}], "return_type": "Binding", "signature": "public static Binding of(Core.NamedPat id, Object value)", "original_string": "  public static Binding of(Core.NamedPat id, Object value) {\n    return new Binding(id, null, value, false);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Binding.java", "class_name": "Binding", "class_uri": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Binding", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override public int hashCode()", "original_string": "  @Override public int hashCode() {\n    return Objects.hash(id, exp, value);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Binding.java", "class_name": "Binding", "class_uri": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "boolean", "signature": "@Override public boolean equals(Object o)", "original_string": "  @Override public boolean equals(Object o) {\n    return this == o\n        || o instanceof Binding\n        && id.equals(((Binding) o).id)\n        && Objects.equals(exp, ((Binding) o).exp)\n        && value.equals(((Binding) o).value);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Binding.java", "class_name": "Binding", "class_uri": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[Binding]withParameter(boolean)", "name": "withParameter", "arg_nums": 1, "params": [{"name": "parameter", "type": "boolean"}], "return_type": "Binding", "signature": "public Binding withParameter(boolean parameter)", "original_string": "  public Binding withParameter(boolean parameter) {\n    return new Binding(id, exp, value, parameter);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Binding.java", "class_name": "Binding", "class_uri": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Binding", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    if (exp != null) {\n      return id + \" = \" + exp;\n    } else if (value == Unit.INSTANCE) {\n      return id + \" : \" + id.type.moniker();\n    } else {\n      return id + \" = \" + value + \" : \" + id.type.moniker();\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Binding.java", "class_name": "Binding", "class_uri": "src/main/java/net/hydromatic/morel/type/Binding.java.Binding", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[]TypeSystem()", "name": "TypeSystem", "arg_nums": 0, "params": [], "return_type": "", "signature": "public TypeSystem()", "original_string": "  public TypeSystem() {\n    for (PrimitiveType primitiveType : PrimitiveType.values()) {\n      typeByName.put(primitiveType.moniker, primitiveType);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Binding]bindTyCon(DataType,String)", "name": "bindTyCon", "arg_nums": 2, "params": [{"name": "dataType", "type": "DataType"}, {"name": "tyConName", "type": "String"}], "return_type": "Binding", "signature": "public Binding bindTyCon(DataType dataType, String tyConName)", "original_string": "  public Binding bindTyCon(DataType dataType, String tyConName) {\n    final Type type = dataType.typeConstructors(this).get(tyConName);\n    if (type == DummyType.INSTANCE) {\n      return Binding.of(core.idPat(dataType, tyConName, 0),\n          Codes.constant(ComparableSingletonList.of(tyConName)));\n    } else {\n      final Type type2 = wrap(dataType, fnType(type, dataType));\n      return Binding.of(core.idPat(type2, tyConName, 0),\n          Codes.tyCon(dataType, tyConName));\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Binding", "classes": []}, "docstring": " Creates a binding of a type constructor value."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]wrap(DataType,Type)", "name": "wrap", "arg_nums": 2, "params": [{"name": "dataType", "type": "DataType"}, {"name": "type", "type": "Type"}], "return_type": "Type", "signature": "private Type wrap(DataType dataType, Type type)", "original_string": "  private Type wrap(DataType dataType, Type type) {\n    final List<TypeVar> typeVars =\n        dataType.parameterTypes.stream().filter(t -> t instanceof TypeVar)\n            .map(t -> (TypeVar) t)\n            .collect(toImmutableList());\n    return typeVars.isEmpty() ? type : forallType(typeVars.size(), type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]lookupInternal(String)", "name": "lookupInternal", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Type", "signature": "public Type lookupInternal(String name)", "original_string": "  public Type lookupInternal(String name) {\n    final Type type = internalTypeByName.get(name);\n    if (type == null) {\n      throw new AssertionError(\"unknown type: \" + name);\n    }\n    return type;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Looks up an internal type by name."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]lookup(String)", "name": "lookup", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Type", "signature": "public Type lookup(String name)", "original_string": "  public Type lookup(String name) {\n    final Type type = typeByName.get(name);\n    if (type == null) {\n      throw new AssertionError(\"unknown type: \" + name);\n    }\n    return type;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Looks up a type by name."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]lookupOpt(String)", "name": "lookupOpt", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Type", "signature": "public Type lookupOpt(String name)", "original_string": "  public Type lookupOpt(String name) {\n    // TODO: only use this for names, e.g. 'option',\n    // not monikers e.g. 'int option';\n    // assert !name.contains(\" \") : name;\n    return typeByName.get(name);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Looks up a type by name, returning null if not found."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]typeFor(Key)", "name": "typeFor", "arg_nums": 1, "params": [{"name": "key", "type": "Key"}], "return_type": "Type", "signature": "public Type typeFor(Key key)", "original_string": "  public Type typeFor(Key key) {\n    Type type = typeByKey.get(key);\n    if (type == null) {\n      type = key.toType(this);\n      typeByKey.putIfAbsent(key, type);\n    }\n    return type;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Gets a type that matches a key, creating if necessary."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[List<Type>]typesFor(Iterable<? extends Key>)", "name": "typesFor", "arg_nums": 1, "params": [{"name": "keys", "type": "Iterable<? extends Key>"}], "return_type": "List<Type>", "signature": "public List<Type> typesFor(Iterable<? extends Key> keys)", "original_string": "  public List<Type> typesFor(Iterable<? extends Key> keys) {\n    return transformEager(keys, key -> key.toType(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Type>", "classes": []}, "docstring": " Converts a list of keys to a list of types."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[SortedMap<String, Type>]typesFor(Map<String, ? extends Key>)", "name": "typesFor", "arg_nums": 1, "params": [{"name": "keys", "type": "Map<String, ? extends Key>"}], "return_type": "SortedMap<String, Type>", "signature": "public SortedMap<String, Type> typesFor(Map<String, ? extends Key> keys)", "original_string": "  public SortedMap<String, Type> typesFor(Map<String, ? extends Key> keys) {\n    final ImmutableSortedMap.Builder<String, Type> types =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    keys.forEach((name, key) -> types.put(name, typeFor(key)));\n    return types.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<String, Type>", "classes": []}, "docstring": " Converts a map of keys to a map of types."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]fnType(Type,Type,Type)", "name": "fnType", "arg_nums": 3, "params": [{"name": "paramType", "type": "Type"}, {"name": "type1", "type": "Type"}, {"name": "type2", "type": "Type"}], "return_type": "Type", "signature": "public Type fnType(Type paramType, Type type1, Type type2,\n      Type... moreTypes)", "original_string": "  public Type fnType(Type paramType, Type type1, Type type2,\n      Type... moreTypes) {\n    final List<Type> types = ImmutableList.<Type>builder()\n        .add(paramType).add(type1).add(type2).add(moreTypes).build();\n    Type t = null;\n    for (Type type : Lists.reverse(types)) {\n      if (t == null) {\n        t = type;\n      } else {\n        t = fnType(type, t);\n      }\n    }\n    return requireNonNull(t);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Creates a multi-step function type.\n\n<p>For example, {@code fnType(a, b, c, d)} returns the same as\n{@code fnType(a, fnType(b, fnType(c, d)))},\nviz <code>a &rarr; b &rarr; c &rarr; d</code>."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[FnType]fnType(Type,Type)", "name": "fnType", "arg_nums": 2, "params": [{"name": "paramType", "type": "Type"}, {"name": "resultType", "type": "Type"}], "return_type": "FnType", "signature": "public FnType fnType(Type paramType, Type resultType)", "original_string": "  public FnType fnType(Type paramType, Type resultType) {\n    return (FnType) typeFor(Keys.fn(paramType.key(), resultType.key()));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FnType", "classes": []}, "docstring": " Creates a function type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[TupleType]tupleType(Type)", "name": "tupleType", "arg_nums": 1, "params": [{"name": "argType0", "type": "Type"}], "return_type": "TupleType", "signature": "public TupleType tupleType(Type argType0, Type... argTypes)", "original_string": "  public TupleType tupleType(Type argType0, Type... argTypes) {\n    return (TupleType) tupleType(Lists.asList(argType0, argTypes));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TupleType", "classes": []}, "docstring": " Creates a tuple type from an array of types."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[RecordLikeType]tupleType(List<? extends Type>)", "name": "tupleType", "arg_nums": 1, "params": [{"name": "argTypes", "type": "List<? extends Type>"}], "return_type": "RecordLikeType", "signature": "public RecordLikeType tupleType(List<? extends Type> argTypes)", "original_string": "  public RecordLikeType tupleType(List<? extends Type> argTypes) {\n    return (RecordLikeType) typeFor(Keys.tuple(Keys.toKeys(argTypes)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordLikeType", "classes": []}, "docstring": " Creates a tuple type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[ListType]listType(Type)", "name": "listType", "arg_nums": 1, "params": [{"name": "elementType", "type": "Type"}], "return_type": "ListType", "signature": "public ListType listType(Type elementType)", "original_string": "  public ListType listType(Type elementType) {\n    return (ListType) typeFor(Keys.list(elementType.key()));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListType", "classes": []}, "docstring": " Creates a list type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[List<Type>]dataTypes(List<Keys.DataTypeKey>)", "name": "dataTypes", "arg_nums": 1, "params": [{"name": "keys", "type": "List<Keys.DataTypeKey>"}], "return_type": "List<Type>", "signature": "public List<Type> dataTypes(List<Keys.DataTypeKey> keys)", "original_string": "  public List<Type> dataTypes(List<Keys.DataTypeKey> keys) {\n    final Map<Type.Key, DataType> dataTypeMap = new LinkedHashMap<>();\n    keys.forEach(key -> {\n      final DataType dataType = key.toType(this);\n      final Key nameKey = Keys.name(dataType.name);\n      typeByKey.put(nameKey, dataType);\n\n      dataType.typeConstructors.forEach((name, typeKey) ->\n          typeConstructorByName.put(name, Pair.of(dataType, typeKey)));\n      dataTypeMap.put(nameKey, dataType);\n    });\n\n    final ImmutableList.Builder<Type> types = ImmutableList.builder();\n    dataTypeMap.values().forEach(dataType -> {\n      // We have just created an entry for the moniker (e.g. \"'a option\"),\n      // so now create an entry for the name (e.g. \"option\").\n      Type t =\n          dataType.arguments.isEmpty() ? dataType\n              : forallType(dataType.arguments.size(), dataType);\n      typeByName.put(dataType.name, t);\n      types.add(t);\n    });\n    return types.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Type>", "classes": []}, "docstring": " Creates several data types simultaneously."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[DataType]dataType(String,List<? extends Type>,SortedMap<String, Key>)", "name": "dataType", "arg_nums": 3, "params": [{"name": "name", "type": "String"}, {"name": "argumentTypes", "type": "List<? extends Type>"}, {"name": "tyCons", "type": "SortedMap<String, Key>"}], "return_type": "DataType", "signature": "DataType dataType(String name, List<? extends Type> argumentTypes,\n      SortedMap<String, Key> tyCons)", "original_string": "  DataType dataType(String name, List<? extends Type> argumentTypes,\n      SortedMap<String, Key> tyCons) {\n    final String moniker = DataType.computeMoniker(name, argumentTypes);\n    final DataType dataType =\n        new DataType(Op.DATA_TYPE, name, moniker, argumentTypes, tyCons);\n    if (argumentTypes.isEmpty()) {\n      // There are no type parameters, therefore there will be no ForallType to\n      // register its type constructors, so this DataType needs to register.\n      tyCons.forEach((name3, typeKey) ->\n          typeConstructorByName.put(name3, Pair.of(dataType, typeKey)));\n    }\n    return dataType;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "DataType", "classes": []}, "docstring": " Creates an algebraic type.\n\n<p>Parameter types is empty unless this is a type scheme.\nFor example,\n\n<ul>\n  <li>{@code datatype 'a option = NONE | SOME of 'a} has\n  parameter types and argument types {@code ['a]},\n  type constructors {@code [NONE: dummy, SOME: 'a]};\n  <li>{@code int option} has empty parameter types,\n  argument types {@code [int]},\n  type constructors {@code [NONE: dummy, SOME: int]};\n  <li>{@code datatype color = RED | GREEN} has\n  empty parameter types and argument types,\n  type constructors {@code [RED: dummy, GREEN: dummy]}.\n</ul>\n\n@param name Name (e.g. \"option\")\n@param argumentTypes Argument types\n@param tyCons Type constructors\n"}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[void]setInternal(String)", "name": "setInternal", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "void", "signature": "public void setInternal(String name)", "original_string": "  public void setInternal(String name) {\n    final Type type = typeByName.remove(name);\n    internalTypeByName.put(name, type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Converts a regular type to an internal type. Throws if the type is not\nknown."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]dataTypeScheme(String,List<TypeVar>,SortedMap<String, Type.Key>)", "name": "dataTypeScheme", "arg_nums": 3, "params": [{"name": "name", "type": "String"}, {"name": "parameters", "type": "List<TypeVar>"}, {"name": "tyCons", "type": "SortedMap<String, Type.Key>"}], "return_type": "Type", "signature": "public Type dataTypeScheme(String name, List<TypeVar> parameters,\n      SortedMap<String, Type.Key> tyCons)", "original_string": "  public Type dataTypeScheme(String name, List<TypeVar> parameters,\n      SortedMap<String, Type.Key> tyCons) {\n    final List<Key> keys = Keys.toKeys(parameters);\n    final Keys.DataTypeKey key = Keys.datatype(name, keys, tyCons);\n    return dataTypes(ImmutableList.of(key)).get(0);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Creates a data type scheme: a datatype if there are no type arguments\n(e.g. \"{@code ordering}\"), or a forall type if there are type arguments\n(e.g. \"{@code forall 'a . 'a option}\")."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]recordOrScalarType(Collection<Map.Entry<String, Type>>)", "name": "recordOrScalarType", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "Collection<Map.Entry<String, Type>>"}], "return_type": "Type", "signature": "public Type recordOrScalarType(\n      Collection<Map.Entry<String, Type>> argNameTypes)", "original_string": "  public Type recordOrScalarType(\n      Collection<Map.Entry<String, Type>> argNameTypes) {\n    switch (argNameTypes.size()) {\n    case 1:\n      return Iterables.getOnlyElement(argNameTypes).getValue();\n    default:\n      return recordType(argNameTypes);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Creates a record type, or returns a scalar type if {@code argNameTypes}\nhas one entry."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[RecordLikeType]recordType(Collection<Map.Entry<String, Type>>)", "name": "recordType", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "Collection<Map.Entry<String, Type>>"}], "return_type": "RecordLikeType", "signature": "public RecordLikeType recordType(\n      Collection<Map.Entry<String, Type>> argNameTypes)", "original_string": "  public RecordLikeType recordType(\n      Collection<Map.Entry<String, Type>> argNameTypes) {\n    return recordType(\n        ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordLikeType", "classes": []}, "docstring": " Creates a record type. (Or a tuple type if the fields are named \"1\", \"2\"\netc.; or \"unit\" if the field list is empty.)"}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[RecordLikeType]recordType(SortedMap<String, ? extends Type>)", "name": "recordType", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "SortedMap<String, ? extends Type>"}], "return_type": "RecordLikeType", "signature": "public RecordLikeType recordType(\n      SortedMap<String, ? extends Type> argNameTypes)", "original_string": "  public RecordLikeType recordType(\n      SortedMap<String, ? extends Type> argNameTypes) {\n    final ImmutableSortedMap<String, Type> argNameTypes2 =\n        ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING);\n    if (argNameTypes2.isEmpty()) {\n      return PrimitiveType.UNIT;\n    }\n    if (areContiguousIntegers(argNameTypes2.keySet())\n        && argNameTypes2.size() != 1) {\n      return tupleType(ImmutableList.copyOf(argNameTypes2.values()));\n    }\n    return (RecordLikeType) typeFor(Keys.record(Keys.toKeys(argNameTypes2)));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordLikeType", "classes": []}, "docstring": " Creates a record type. (Or a tuple type if the fields are named \"1\", \"2\"\netc.; or \"unit\" if the field list is empty.)"}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[boolean]areContiguousIntegers(Iterable<String>)", "name": "areContiguousIntegers", "arg_nums": 1, "params": [{"name": "strings", "type": "Iterable<String>"}], "return_type": "boolean", "signature": "public static boolean areContiguousIntegers(Iterable<String> strings)", "original_string": "  public static boolean areContiguousIntegers(Iterable<String> strings) {\n    int i = 1;\n    for (String string : strings) {\n      if (!string.equals(Integer.toString(i++))) {\n        return false;\n      }\n    }\n    return true;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Returns whether the collection is [\"1\", \"2\", ... n]."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[ProgressiveRecordType]progressiveRecordType(Collection<Map.Entry<String, Type>>)", "name": "progressiveRecordType", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "Collection<Map.Entry<String, Type>>"}], "return_type": "ProgressiveRecordType", "signature": "public ProgressiveRecordType progressiveRecordType(\n      Collection<Map.Entry<String, Type>> argNameTypes)", "original_string": "  public ProgressiveRecordType progressiveRecordType(\n      Collection<Map.Entry<String, Type>> argNameTypes) {\n    return progressiveRecordType(\n        ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ProgressiveRecordType", "classes": []}, "docstring": " Creates a progressive record type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[ProgressiveRecordType]progressiveRecordType(SortedMap<String, Type>)", "name": "progressiveRecordType", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "SortedMap<String, Type>"}], "return_type": "ProgressiveRecordType", "signature": "public ProgressiveRecordType progressiveRecordType(\n      SortedMap<String, Type> argNameTypes)", "original_string": "  public ProgressiveRecordType progressiveRecordType(\n      SortedMap<String, Type> argNameTypes) {\n    final ImmutableSortedMap<String, Type> argNameTypes2 =\n        ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING);\n    Key key = Keys.progressiveRecord(Keys.toKeys(argNameTypes2));\n    return (ProgressiveRecordType) typeFor(key);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ProgressiveRecordType", "classes": []}, "docstring": " Creates a progressive record type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]forallType(int,Function<ForallHelper, Type>)", "name": "forallType", "arg_nums": 2, "params": [{"name": "typeCount", "type": "int"}, {"name": "builder", "type": "Function<ForallHelper, Type>"}], "return_type": "Type", "signature": "public Type forallType(int typeCount, Function<ForallHelper, Type> builder)", "original_string": "  public Type forallType(int typeCount, Function<ForallHelper, Type> builder) {\n    final ForallHelper helper = new ForallHelper() {\n      public TypeVar get(int i) {\n        return typeVariable(i);\n      }\n\n      public ListType list(int i) {\n        return listType(get(i));\n      }\n\n      public Type vector(int i) {\n        return TypeSystem.this.vector(get(i));\n      }\n\n      public Type option(int i) {\n        return TypeSystem.this.option(get(i));\n      }\n\n      public FnType predicate(int i) {\n        return fnType(get(i), PrimitiveType.BOOL);\n      }\n    };\n    final Type type = builder.apply(helper);\n    return forallType(typeCount, type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Creates a \"forall\" type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[ForallType]forallType(int,Type)", "name": "forallType", "arg_nums": 2, "params": [{"name": "typeCount", "type": "int"}, {"name": "type", "type": "Type"}], "return_type": "ForallType", "signature": "public ForallType forallType(int typeCount, Type type)", "original_string": "  public ForallType forallType(int typeCount, Type type) {\n    final Key key = Keys.forall(type, typeCount);\n    return (ForallType) typeFor(key);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ForallType", "classes": []}, "docstring": " Creates a \"for all\" type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[StringBuilder]unparseList(StringBuilder,Op,int,int,Collection<? extends Type.Key>)", "name": "unparseList", "arg_nums": 5, "params": [{"name": "builder", "type": "StringBuilder"}, {"name": "op", "type": "Op"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}, {"name": "argTypes", "type": "Collection<? extends Type.Key>"}], "return_type": "StringBuilder", "signature": "static StringBuilder unparseList(StringBuilder builder, Op op, int left,\n      int right, Collection<? extends Type.Key> argTypes)", "original_string": "  static StringBuilder unparseList(StringBuilder builder, Op op, int left,\n      int right, Collection<? extends Type.Key> argTypes) {\n    if (op == Op.COMMA && argTypes.size() != 1 && !(left == 0 && right == 0)) {\n      builder.append('(');\n      unparseList(builder, op, 0, 0, argTypes);\n      builder.append(')');\n    } else {\n      forEachIndexed(argTypes, (type, i) -> {\n        if (i > 0) {\n          builder.append(op.padded);\n        }\n        unparse(builder, type,\n            i == 0 ? left : op.right,\n            i == argTypes.size() - 1 ? right : op.left);\n      });\n    }\n    return builder;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[StringBuilder]unparse(StringBuilder,Type.Key,int,int)", "name": "unparse", "arg_nums": 4, "params": [{"name": "builder", "type": "StringBuilder"}, {"name": "type", "type": "Type.Key"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}], "return_type": "StringBuilder", "signature": "static StringBuilder unparse(StringBuilder builder, Type.Key type, int left,\n      int right)", "original_string": "  static StringBuilder unparse(StringBuilder builder, Type.Key type, int left,\n      int right) {\n    if (left > type.op.left || type.op.right < right) {\n      builder.append(\"(\");\n      unparse(builder, type, 0, 0);\n      return builder.append(\")\");\n    } else {\n      return type.describe(builder, left, right);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[List<TypeVar>]typeVariables(int)", "name": "typeVariables", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "List<TypeVar>", "signature": "public List<TypeVar> typeVariables(int size)", "original_string": "  public List<TypeVar> typeVariables(int size) {\n    return new AbstractList<TypeVar>() {\n      public int size() {\n        return size;\n      }\n\n      public TypeVar get(int index) {\n        return typeVariable(index);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<TypeVar>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Pair<DataType, Type.Key>]lookupTyCon(String)", "name": "lookupTyCon", "arg_nums": 1, "params": [{"name": "tyConName", "type": "String"}], "return_type": "Pair<DataType, Type.Key>", "signature": "public Pair<DataType, Type.Key> lookupTyCon(String tyConName)", "original_string": "  public Pair<DataType, Type.Key> lookupTyCon(String tyConName) {\n    return typeConstructorByName.get(tyConName);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pair<DataType, Type.Key>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]apply(Type)", "name": "apply", "arg_nums": 1, "params": [{"name": "type", "type": "Type"}], "return_type": "Type", "signature": "public Type apply(Type type, Type... types)", "original_string": "  public Type apply(Type type, Type... types) {\n    return apply(type, ImmutableList.copyOf(types));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]apply(Type,List<Type>)", "name": "apply", "arg_nums": 2, "params": [{"name": "type", "type": "Type"}, {"name": "types", "type": "List<Type>"}], "return_type": "Type", "signature": "public Type apply(Type type, List<Type> types)", "original_string": "  public Type apply(Type type, List<Type> types) {\n    if (type instanceof ForallType) {\n      final ForallType forallType = (ForallType) type;\n      return forallType.substitute(this, types);\n    }\n    if (type instanceof DataType) {\n      final DataType dataType = (DataType) type;\n      return dataType.substitute(this, types);\n    }\n    throw new AssertionError();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[TypeVar]typeVariable(int)", "name": "typeVariable", "arg_nums": 1, "params": [{"name": "ordinal", "type": "int"}], "return_type": "TypeVar", "signature": "public TypeVar typeVariable(int ordinal)", "original_string": "  public TypeVar typeVariable(int ordinal) {\n    return (TypeVar) typeFor(Keys.ordinal(ordinal));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TypeVar", "classes": []}, "docstring": " Creates a type variable."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]option(Type)", "name": "option", "arg_nums": 1, "params": [{"name": "type", "type": "Type"}], "return_type": "Type", "signature": "public Type option(Type type)", "original_string": "  public Type option(Type type) {\n    final Type optionType = lookup(\"option\");\n    return apply(optionType, type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Creates an \"option\" type.\n\n<p>\"option(type)\" is shorthand for \"apply(lookup(\"option\"), type)\"."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]vector(Type)", "name": "vector", "arg_nums": 1, "params": [{"name": "type", "type": "Type"}], "return_type": "Type", "signature": "public Type vector(Type type)", "original_string": "  public Type vector(Type type) {\n    final Type vectorType = lookup(\"vector\");\n    return apply(vectorType, type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Creates a \"vector\" type.\n\n<p>\"vector(type)\" is shorthand for \"apply(lookup(\"vector\"), type)\"."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem.[Type]ensureClosed(Type)", "name": "ensureClosed", "arg_nums": 1, "params": [{"name": "type", "type": "Type"}], "return_type": "Type", "signature": "public Type ensureClosed(Type type)", "original_string": "  public Type ensureClosed(Type type) {\n    final VariableCollector collector = new VariableCollector();\n    type.accept(collector);\n    if (collector.vars.isEmpty()) {\n      return type;\n    }\n    final TypeSystem ts = this;\n    return forallType(collector.vars.size(), h ->\n        type.copy(ts, t ->\n            t instanceof TypeVar ? h.get(((TypeVar) t).ordinal) : t));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeSystem.java", "class_name": "TypeSystem", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeSystem.java.TypeSystem", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": " Converts a type into a {@link ForallType} if it has free type\nvariables."}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[]TupleType(List<? extends Type>)", "name": "TupleType", "arg_nums": 1, "params": [{"name": "argTypes", "type": "List<? extends Type>"}], "return_type": "", "signature": "TupleType(List<? extends Type> argTypes)", "original_string": "  TupleType(List<? extends Type> argTypes) {\n    super(Op.TUPLE_TYPE);\n    this.argTypes = ImmutableList.copyOf(argTypes);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[SortedMap<String, Type>]argNameTypes()", "name": "argNameTypes", "arg_nums": 0, "params": [], "return_type": "SortedMap<String, Type>", "signature": "@Override public SortedMap<String, Type> argNameTypes()", "original_string": "  @Override public SortedMap<String, Type> argNameTypes() {\n    final ImmutableSortedMap.Builder<String, Type> map =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    forEachIndexed(argTypes, (t, i) -> map.put(Integer.toString(i + 1), t));\n    return map.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<String, Type>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[List<Type>]argTypes()", "name": "argTypes", "arg_nums": 0, "params": [], "return_type": "List<Type>", "signature": "@Override public List<Type> argTypes()", "original_string": "  @Override public List<Type> argTypes() {\n    return argTypes;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Type>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[Type]argType(int)", "name": "argType", "arg_nums": 1, "params": [{"name": "i", "type": "int"}], "return_type": "Type", "signature": "@Override public Type argType(int i)", "original_string": "  @Override public Type argType(int i) {\n    return argTypes.get(i);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[R]accept(TypeVisitor<R>)", "name": "accept", "arg_nums": 1, "params": [{"name": "typeVisitor", "type": "TypeVisitor<R>"}], "return_type": "R", "signature": "public <R> R accept(TypeVisitor<R> typeVisitor)", "original_string": "  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[Key]key()", "name": "key", "arg_nums": 0, "params": [], "return_type": "Key", "signature": "public Key key()", "original_string": "  public Key key() {\n    return Keys.record(toArgNameTypeKeys(argTypes));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Key", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[TupleType]copy(TypeSystem,UnaryOperator<Type>)", "name": "copy", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "transform", "type": "UnaryOperator<Type>"}], "return_type": "TupleType", "signature": "@Override public TupleType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform)", "original_string": "  @Override public TupleType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    int differenceCount = 0;\n    final ImmutableList.Builder<Type> argTypes2 = ImmutableList.builder();\n    for (Type argType : argTypes) {\n      final Type argType2 = transform.apply(argType);\n      if (argType != argType2) {\n        ++differenceCount;\n      }\n      argTypes2.add(argType2);\n    }\n    return differenceCount == 0\n        ? this\n        : new TupleType(argTypes2.build());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "TupleType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[String]str(int)", "name": "str", "arg_nums": 1, "params": [{"name": "i", "type": "int"}], "return_type": "String", "signature": "private static String str(int i)", "original_string": "  private static String str(int i) {\n    return i >= 0 && i < INT_STRINGS.length ? INT_STRINGS[i]\n        : Integer.toString(i);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Converts an integer to its string representation, using a cached value\nif possible."}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[List<String>]ordinalNames(int)", "name": "ordinalNames", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "List<String>", "signature": "public static List<String> ordinalNames(int size)", "original_string": "  public static List<String> ordinalNames(int size) {\n    return new AbstractList<String>() {\n      public int size() {\n        return size;\n      }\n\n      public String get(int index) {\n        return str(index + 1);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<String>", "classes": []}, "docstring": " Returns a list of strings [\"1\", ..., \"size\"]."}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[ImmutableSortedMap<String, E>]recordMap(List<? extends E>)", "name": "recordMap", "arg_nums": 1, "params": [{"name": "argTypes", "type": "List<? extends E>"}], "return_type": "ImmutableSortedMap<String, E>", "signature": "static <E> ImmutableSortedMap<String, E> recordMap(\n      List<? extends E> argTypes)", "original_string": "  static <E> ImmutableSortedMap<String, E> recordMap(\n      List<? extends E> argTypes) {\n    final ImmutableSortedMap.Builder<String, E> b =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    forEachIndexed(argTypes, (t, i) ->\n        b.put(Integer.toString(i + 1), t));\n    return b.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "ImmutableSortedMap<String, E>", "classes": []}, "docstring": " Given a list of types [t1, t2, ..., tn] returns a sorted map [\"1\" : t1,\n\"2\" : t2, ... \"n\" : tn]."}, {"uris": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType.[ImmutableSortedMap<String, Type.Key>]toArgNameTypeKeys(List<? extends Type>)", "name": "toArgNameTypeKeys", "arg_nums": 1, "params": [{"name": "argTypes", "type": "List<? extends Type>"}], "return_type": "ImmutableSortedMap<String, Type.Key>", "signature": "static ImmutableSortedMap<String, Type.Key> toArgNameTypeKeys(\n      List<? extends Type> argTypes)", "original_string": "  static ImmutableSortedMap<String, Type.Key> toArgNameTypeKeys(\n      List<? extends Type> argTypes) {\n    return recordMap(transform(argTypes, Type::key));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TupleType.java", "class_name": "TupleType", "class_uri": "src/main/java/net/hydromatic/morel/type/TupleType.java.TupleType", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "ImmutableSortedMap<String, Type.Key>", "classes": []}, "docstring": " Given a list of types [t1, t2, ..., tn] returns a sorted map\n[\"1\" : t1.key, \"2\" : t2.key, ... \"n\" : tn.key]."}, {"uris": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[]DataType(String,String,List<? extends Type>,SortedMap<String, Key>)", "name": "DataType", "arg_nums": 4, "params": [{"name": "name", "type": "String"}, {"name": "moniker", "type": "String"}, {"name": "arguments", "type": "List<? extends Type>"}, {"name": "typeConstructors", "type": "SortedMap<String, Key>"}], "return_type": "", "signature": "DataType(String name, String moniker, List<? extends Type> arguments,\n      SortedMap<String, Key> typeConstructors)", "original_string": "  DataType(String name, String moniker, List<? extends Type> arguments,\n      SortedMap<String, Key> typeConstructors) {\n    this(Op.DATA_TYPE, name, moniker, arguments, typeConstructors);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/DataType.java", "class_name": "DataType", "class_uri": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a DataType.\n\n<p>Called only from {@link TypeSystem#dataTypes(List)}.\n\n<p>If the {@code typeSystem} argument is specified, canonizes the types\ninside type-constructors. This also allows temporary types (necessary while\ncreating self-referential data types) to be replaced with real DataType\ninstances.\n\n<p>During replacement, if a type matches {@code placeholderType} it is\nreplaced with {@code this}. This allows cyclic graphs to be copied."}, {"uris": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[]DataType(Op,String,String,List<? extends Type>,SortedMap<String, Key>)", "name": "DataType", "arg_nums": 5, "params": [{"name": "op", "type": "Op"}, {"name": "name", "type": "String"}, {"name": "moniker", "type": "String"}, {"name": "arguments", "type": "List<? extends Type>"}, {"name": "typeConstructors", "type": "SortedMap<String, Key>"}], "return_type": "", "signature": "protected DataType(Op op, String name, String moniker,\n      List<? extends Type> arguments, SortedMap<String, Key> typeConstructors)", "original_string": "  protected DataType(Op op, String name, String moniker,\n      List<? extends Type> arguments, SortedMap<String, Key> typeConstructors) {\n    super(op, name, moniker, arguments.size());\n    this.arguments = ImmutableList.copyOf(arguments);\n    this.typeConstructors = ImmutableSortedMap.copyOf(typeConstructors);\n    checkArgument(typeConstructors.comparator() == null\n        || typeConstructors.comparator() == Ordering.natural());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/DataType.java", "class_name": "DataType", "class_uri": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": " Called only from DataType constructor."}, {"uris": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[Key]key()", "name": "key", "arg_nums": 0, "params": [], "return_type": "Key", "signature": "@Override public Key key()", "original_string": "  @Override public Key key() {\n    return Keys.datatype(name, Keys.toKeys(arguments), typeConstructors);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/DataType.java", "class_name": "DataType", "class_uri": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Key", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[R]accept(TypeVisitor<R>)", "name": "accept", "arg_nums": 1, "params": [{"name": "typeVisitor", "type": "TypeVisitor<R>"}], "return_type": "R", "signature": "public <R> R accept(TypeVisitor<R> typeVisitor)", "original_string": "  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/DataType.java", "class_name": "DataType", "class_uri": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[SortedMap<String, Type>]typeConstructors(TypeSystem)", "name": "typeConstructors", "arg_nums": 1, "params": [{"name": "typeSystem", "type": "TypeSystem"}], "return_type": "SortedMap<String, Type>", "signature": "public SortedMap<String, Type> typeConstructors(TypeSystem typeSystem)", "original_string": "  public SortedMap<String, Type> typeConstructors(TypeSystem typeSystem) {\n    return Maps.transformValues(typeConstructors,\n        k -> k.copy(t -> t.substitute(arguments)).toType(typeSystem));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/DataType.java", "class_name": "DataType", "class_uri": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<String, Type>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[DataType]copy(TypeSystem,UnaryOperator<Type>)", "name": "copy", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "transform", "type": "UnaryOperator<Type>"}], "return_type": "DataType", "signature": "@Override public DataType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform)", "original_string": "  @Override public DataType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    final List<Type> arguments = transformEager(this.arguments, transform);\n    if (arguments.equals(this.arguments)) {\n      return this;\n    }\n    return new DataType(name, moniker, arguments, typeConstructors);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/DataType.java", "class_name": "DataType", "class_uri": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DataType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType.[StringBuilder]describe(StringBuilder)", "name": "describe", "arg_nums": 1, "params": [{"name": "buf", "type": "StringBuilder"}], "return_type": "StringBuilder", "signature": "public StringBuilder describe(StringBuilder buf)", "original_string": "  public StringBuilder describe(StringBuilder buf) {\n    buf.append(\"datatype \")\n        .append(moniker)\n        .append(\" = \");\n    final int initialSize = buf.length();\n    typeConstructors.forEach((name, typeKey) -> {\n      if (buf.length() > initialSize) {\n        buf.append(\" | \");\n      }\n      buf.append(name);\n      if (typeKey.op != Op.DUMMY_TYPE) {\n        buf.append(\" of \");\n        typeKey.describe(buf, 0, 0);\n      }\n    });\n    return buf;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/DataType.java", "class_name": "DataType", "class_uri": "src/main/java/net/hydromatic/morel/type/DataType.java.DataType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": " Writes out the definition of the datatype. For example,\n\n<blockquote>{@code\ndatatype ('a,'b) tree =\n    Empty\n  | Node of ('a,'b) tree * 'b * 'a * ('a,'b) tree\n}</blockquote>\n"}, {"uris": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[]BaseType(Op)", "name": "BaseType", "arg_nums": 1, "params": [{"name": "op", "type": "Op"}], "return_type": "", "signature": "protected BaseType(Op op)", "original_string": "  protected BaseType(Op op) {\n    this.op = requireNonNull(op);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/BaseType.java", "class_name": "BaseType", "class_uri": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[Op]op()", "name": "op", "arg_nums": 0, "params": [], "return_type": "Op", "signature": "public Op op()", "original_string": "  public Op op() {\n    return op;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/BaseType.java", "class_name": "BaseType", "class_uri": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Op", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    return key().toString();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/BaseType.java", "class_name": "BaseType", "class_uri": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "boolean", "signature": "@Override public boolean equals(Object o)", "original_string": "  @Override public boolean equals(Object o) {\n    return this == o\n        || o instanceof BaseType\n        && key().equals(((BaseType) o).key());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/BaseType.java", "class_name": "BaseType", "class_uri": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override public int hashCode()", "original_string": "  @Override public int hashCode() {\n    return key().hashCode();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/BaseType.java", "class_name": "BaseType", "class_uri": "src/main/java/net/hydromatic/morel/type/BaseType.java.BaseType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/NamedType.java.NamedType.[String]name()", "name": "name", "arg_nums": 0, "params": [], "return_type": "String", "signature": "String name()", "original_string": "  String name();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/NamedType.java", "class_name": "NamedType", "class_uri": "src/main/java/net/hydromatic/morel/type/NamedType.java.NamedType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "docstring": " Name of the type."}, {"uris": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[]ForallType(int,Type)", "name": "ForallType", "arg_nums": 2, "params": [{"name": "parameterCount", "type": "int"}, {"name": "type", "type": "Type"}], "return_type": "", "signature": "ForallType(int parameterCount, Type type)", "original_string": "  ForallType(int parameterCount, Type type) {\n    super(Op.FORALL_TYPE);\n    this.parameterCount = parameterCount;\n    this.type = requireNonNull(type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ForallType.java", "class_name": "ForallType", "class_uri": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[Key]key()", "name": "key", "arg_nums": 0, "params": [], "return_type": "Key", "signature": "public Key key()", "original_string": "  public Key key() {\n    return Keys.forall(type, parameterCount);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ForallType.java", "class_name": "ForallType", "class_uri": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Key", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[R]accept(TypeVisitor<R>)", "name": "accept", "arg_nums": 1, "params": [{"name": "typeVisitor", "type": "TypeVisitor<R>"}], "return_type": "R", "signature": "public <R> R accept(TypeVisitor<R> typeVisitor)", "original_string": "  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ForallType.java", "class_name": "ForallType", "class_uri": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[ForallType]copy(TypeSystem,UnaryOperator<Type>)", "name": "copy", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "transform", "type": "UnaryOperator<Type>"}], "return_type": "ForallType", "signature": "@Override public ForallType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform)", "original_string": "  @Override public ForallType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    final Type type2 = type.copy(typeSystem, transform);\n    return type2 == type\n        ? this\n        : typeSystem.forallType(parameterCount, type2);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ForallType.java", "class_name": "ForallType", "class_uri": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ForallType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType.[Type]substitute(TypeSystem,List<? extends Type>)", "name": "substitute", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "types", "type": "List<? extends Type>"}], "return_type": "Type", "signature": "@Override public Type substitute(TypeSystem typeSystem,\n      List<? extends Type> types)", "original_string": "  @Override public Type substitute(TypeSystem typeSystem,\n      List<? extends Type> types) {\n    switch (type.op()) {\n    case DATA_TYPE:\n      final DataType dataType = (DataType) type;\n      Key key =\n          Keys.datatype(dataType.name, Keys.toKeys(types),\n              Maps.transformValues(dataType.typeConstructors,\n                  k -> k.substitute(types)));\n      return typeSystem.typeFor(key);\n\n    case FUNCTION_TYPE:\n      return type.substitute(typeSystem, types);\n\n    default:\n      throw new AssertionError(type.op() + \": \" + type);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ForallType.java", "class_name": "ForallType", "class_uri": "src/main/java/net/hydromatic/morel/type/ForallType.java.ForallType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[]Keys()", "name": "Keys", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Keys()", "original_string": "  private Keys() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]name(String)", "name": "name", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "Type.Key", "signature": "public static Type.Key name(String name)", "original_string": "  public static Type.Key name(String name) {\n    return new NameKey(name);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key that identifies types by name."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]dummy()", "name": "dummy", "arg_nums": 0, "params": [], "return_type": "Type.Key", "signature": "public static Type.Key dummy()", "original_string": "  public static Type.Key dummy() {\n    return name(\"\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key to the dummy type."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]ordinal(int)", "name": "ordinal", "arg_nums": 1, "params": [{"name": "ordinal", "type": "int"}], "return_type": "Type.Key", "signature": "public static Type.Key ordinal(int ordinal)", "original_string": "  public static Type.Key ordinal(int ordinal) {\n    return new OrdinalKey(ordinal);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key that identifies types (especially\n{@link TypeVar type variables}) by ordinal."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[List<Type.Key>]ordinals(int)", "name": "ordinals", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "List<Type.Key>", "signature": "public static List<Type.Key> ordinals(int size)", "original_string": "  public static List<Type.Key> ordinals(int size) {\n    return new AbstractList<Type.Key>() {\n      public int size() {\n        return size;\n      }\n\n      public Type.Key get(int index) {\n        return new OrdinalKey(index);\n      }\n    };\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Type.Key>", "classes": []}, "docstring": " Returns a list of keys for type variables 0 through size - 1.\n\n@see TypeSystem#typeVariables(int)"}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]apply(Type.Key,Iterable<? extends Type.Key>)", "name": "apply", "arg_nums": 2, "params": [{"name": "type", "type": "Type.Key"}, {"name": "args", "type": "Iterable<? extends Type.Key>"}], "return_type": "Type.Key", "signature": "public static Type.Key apply(Type.Key type,\n      Iterable<? extends Type.Key> args)", "original_string": "  public static Type.Key apply(Type.Key type,\n      Iterable<? extends Type.Key> args) {\n    return new ApplyKey(type, ImmutableList.copyOf(args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key that applies a polymorphic type to arguments."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]record(SortedMap<String, ? extends Type.Key>)", "name": "record", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "SortedMap<String, ? extends Type.Key>"}], "return_type": "Type.Key", "signature": "public static Type.Key record(SortedMap<String, ? extends Type.Key> argNameTypes)", "original_string": "  public static Type.Key record(SortedMap<String, ? extends Type.Key> argNameTypes) {\n    return new RecordKey(ImmutableSortedMap.copyOfSorted(argNameTypes));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key that identifies a {@link RecordType}\n(or a {@link TupleType} if the field names are ascending integers,\nor {@link PrimitiveType#UNIT unit} if the fields are empty)."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]record(Iterable<Map.Entry<String, ? extends Type.Key>>)", "name": "record", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "Iterable<Map.Entry<String, ? extends Type.Key>>"}], "return_type": "Type.Key", "signature": "public static Type.Key record(\n      Iterable<Map.Entry<String, ? extends Type.Key>> argNameTypes)", "original_string": "  public static Type.Key record(\n      Iterable<Map.Entry<String, ? extends Type.Key>> argNameTypes) {\n    return record(ImmutableSortedMap.copyOf(argNameTypes, RecordType.ORDERING));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " As {@link #record(SortedMap)} but an {@link Iterable} argument."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]tuple(List<? extends Type.Key>)", "name": "tuple", "arg_nums": 1, "params": [{"name": "args", "type": "List<? extends Type.Key>"}], "return_type": "Type.Key", "signature": "public static Type.Key tuple(List<? extends Type.Key> args)", "original_string": "  public static Type.Key tuple(List<? extends Type.Key> args) {\n    return new RecordKey(TupleType.recordMap(args));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key that identifies a {@link TupleType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]progressiveRecord(SortedMap<String, ? extends Type.Key>)", "name": "progressiveRecord", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "SortedMap<String, ? extends Type.Key>"}], "return_type": "Type.Key", "signature": "public static Type.Key progressiveRecord(\n      SortedMap<String, ? extends Type.Key> argNameTypes)", "original_string": "  public static Type.Key progressiveRecord(\n      SortedMap<String, ? extends Type.Key> argNameTypes) {\n    return new ProgressiveRecordKey(\n        ImmutableSortedMap.copyOfSorted(argNameTypes));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key that identifies a {@link ProgressiveRecordType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]fn(Type.Key,Type.Key)", "name": "fn", "arg_nums": 2, "params": [{"name": "paramType", "type": "Type.Key"}, {"name": "resultType", "type": "Type.Key"}], "return_type": "Type.Key", "signature": "public static Type.Key fn(Type.Key paramType, Type.Key resultType)", "original_string": "  public static Type.Key fn(Type.Key paramType, Type.Key resultType) {\n    return new OpKey(Op.FN, ImmutableList.of(paramType, resultType));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key that identifies a {@link FnType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]list(Type.Key)", "name": "list", "arg_nums": 1, "params": [{"name": "elementType", "type": "Type.Key"}], "return_type": "Type.Key", "signature": "public static Type.Key list(Type.Key elementType)", "original_string": "  public static Type.Key list(Type.Key elementType) {\n    return new OpKey(Op.LIST, ImmutableList.of(elementType));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key that identifies a {@link ListType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]forall(Type,int)", "name": "forall", "arg_nums": 2, "params": [{"name": "type", "type": "Type"}, {"name": "parameterCount", "type": "int"}], "return_type": "Type.Key", "signature": "public static Type.Key forall(Type type, int parameterCount)", "original_string": "  public static Type.Key forall(Type type, int parameterCount) {\n    return new ForallKey(type, parameterCount);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Returns a key that identifies a {@link ForallType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[DataTypeKey]datatype(String,List<? extends Type.Key>,SortedMap<String, Type.Key>)", "name": "datatype", "arg_nums": 3, "params": [{"name": "name", "type": "String"}, {"name": "arguments", "type": "List<? extends Type.Key>"}, {"name": "typeConstructors", "type": "SortedMap<String, Type.Key>"}], "return_type": "DataTypeKey", "signature": "public static DataTypeKey datatype(String name,\n      List<? extends Type.Key> arguments,\n      SortedMap<String, Type.Key> typeConstructors)", "original_string": "  public static DataTypeKey datatype(String name,\n      List<? extends Type.Key> arguments,\n      SortedMap<String, Type.Key> typeConstructors) {\n    return new DataTypeKey(name, arguments, typeConstructors);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "DataTypeKey", "classes": []}, "docstring": " Returns a key that identifies a {@link DataType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[SortedMap<String, Type.Key>]toKeys(SortedMap<String, ? extends Type>)", "name": "toKeys", "arg_nums": 1, "params": [{"name": "nameTypes", "type": "SortedMap<String, ? extends Type>"}], "return_type": "SortedMap<String, Type.Key>", "signature": "public static SortedMap<String, Type.Key> toKeys(\n      SortedMap<String, ? extends Type> nameTypes)", "original_string": "  public static SortedMap<String, Type.Key> toKeys(\n      SortedMap<String, ? extends Type> nameTypes) {\n    final ImmutableSortedMap.Builder<String, Type.Key> keys =\n        ImmutableSortedMap.orderedBy(RecordType.ORDERING);\n    nameTypes.forEach((name, t) -> keys.put(name, t.key()));\n    return keys.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SortedMap<String, Type.Key>", "classes": []}, "docstring": " Converts a map of types to a map of keys."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[List<Type.Key>]toKeys(List<? extends Type>)", "name": "toKeys", "arg_nums": 1, "params": [{"name": "types", "type": "List<? extends Type>"}], "return_type": "List<Type.Key>", "signature": "public static List<Type.Key> toKeys(List<? extends Type> types)", "original_string": "  public static List<Type.Key> toKeys(List<? extends Type> types) {\n    return transformEager(types, Type::key);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<Type.Key>", "classes": []}, "docstring": " Converts a list of types to a list of keys."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[StringBuilder]describeRecordType(StringBuilder,int,int,SortedMap<String, Type.Key>,Op)", "name": "describeRecordType", "arg_nums": 5, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "left", "type": "int"}, {"name": "right", "type": "int"}, {"name": "argNameTypes", "type": "SortedMap<String, Type.Key>"}, {"name": "op", "type": "Op"}], "return_type": "StringBuilder", "signature": "static StringBuilder describeRecordType(StringBuilder buf, int left,\n      int right, SortedMap<String, Type.Key> argNameTypes, Op op)", "original_string": "  static StringBuilder describeRecordType(StringBuilder buf, int left,\n      int right, SortedMap<String, Type.Key> argNameTypes, Op op) {\n    switch (argNameTypes.size()) {\n    case 0:\n      return buf.append(op == Op.PROGRESSIVE_RECORD_TYPE ? \"{...}\" : \"()\");\n\n    default:\n      if (op == Op.TUPLE_TYPE) {\n        return TypeSystem.unparseList(buf, Op.TIMES, left, right,\n            argNameTypes.values());\n      }\n      // fall through\n    case 1:\n      buf.append('{');\n      int i = 0;\n      for (Map.Entry<String, Type.Key> entry : argNameTypes.entrySet()) {\n        String name = entry.getKey();\n        Type.Key typeKey = entry.getValue();\n        if (i++ > 0) {\n          buf.append(\", \");\n        }\n        appendId(buf, name)\n            .append(':')\n            .append(typeKey);\n      }\n      if (op == Op.PROGRESSIVE_RECORD_TYPE) {\n        if (i > 0) {\n          buf.append(\", \");\n        }\n        buf.append(\"...\");\n      }\n      return buf.append('}');\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": " Describes a record, progressive record, or tuple type."}, {"uris": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys.[Type.Key]toProgressive(Type.Key)", "name": "toProgressive", "arg_nums": 1, "params": [{"name": "key", "type": "Type.Key"}], "return_type": "Type.Key", "signature": "public static Type.Key toProgressive(Type.Key key)", "original_string": "  public static Type.Key toProgressive(Type.Key key) {\n    if (key instanceof RecordKey) {\n      return progressiveRecord(\n          ((RecordKey) key).argNameTypes);\n    }\n    return key;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/Keys.java", "class_name": "Keys", "class_uri": "src/main/java/net/hydromatic/morel/type/Keys.java.Keys", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Converts a record key to a progressive record key,\nleaves other keys unchanged."}, {"uris": "src/main/java/net/hydromatic/morel/type/ListType.java.ListType.[]ListType(Type)", "name": "ListType", "arg_nums": 1, "params": [{"name": "elementType", "type": "Type"}], "return_type": "", "signature": "ListType(Type elementType)", "original_string": "  ListType(Type elementType) {\n    super(Op.LIST);\n    this.elementType = requireNonNull(elementType);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ListType.java", "class_name": "ListType", "class_uri": "src/main/java/net/hydromatic/morel/type/ListType.java.ListType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ListType.java.ListType.[Key]key()", "name": "key", "arg_nums": 0, "params": [], "return_type": "Key", "signature": "@Override public Key key()", "original_string": "  @Override public Key key() {\n    return Keys.list(elementType.key());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ListType.java", "class_name": "ListType", "class_uri": "src/main/java/net/hydromatic/morel/type/ListType.java.ListType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Key", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ListType.java.ListType.[R]accept(TypeVisitor<R>)", "name": "accept", "arg_nums": 1, "params": [{"name": "typeVisitor", "type": "TypeVisitor<R>"}], "return_type": "R", "signature": "public <R> R accept(TypeVisitor<R> typeVisitor)", "original_string": "  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ListType.java", "class_name": "ListType", "class_uri": "src/main/java/net/hydromatic/morel/type/ListType.java.ListType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ListType.java.ListType.[ListType]copy(TypeSystem,UnaryOperator<Type>)", "name": "copy", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "transform", "type": "UnaryOperator<Type>"}], "return_type": "ListType", "signature": "@Override public ListType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform)", "original_string": "  @Override public ListType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    final Type elementType2 = elementType.copy(typeSystem, transform);\n    return elementType2 == elementType\n        ? this\n        : typeSystem.listType(elementType2);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ListType.java", "class_name": "ListType", "class_uri": "src/main/java/net/hydromatic/morel/type/ListType.java.ListType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[]TypeShuttle(TypeSystem)", "name": "TypeShuttle", "arg_nums": 1, "params": [{"name": "typeSystem", "type": "TypeSystem"}], "return_type": "", "signature": "protected TypeShuttle(TypeSystem typeSystem)", "original_string": "  protected TypeShuttle(TypeSystem typeSystem) {\n    this.typeSystem = typeSystem;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[Type]visit(TypeVar)", "name": "visit", "arg_nums": 1, "params": [{"name": "typeVar", "type": "TypeVar"}], "return_type": "Type", "signature": "@Override public Type visit(TypeVar typeVar)", "original_string": "  @Override public Type visit(TypeVar typeVar) {\n    return typeVar.copy(typeSystem, t -> t.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[ListType]visit(ListType)", "name": "visit", "arg_nums": 1, "params": [{"name": "listType", "type": "ListType"}], "return_type": "ListType", "signature": "@Override public ListType visit(ListType listType)", "original_string": "  @Override public ListType visit(ListType listType) {\n    return listType.copy(typeSystem, t -> t.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[FnType]visit(FnType)", "name": "visit", "arg_nums": 1, "params": [{"name": "fnType", "type": "FnType"}], "return_type": "FnType", "signature": "@Override public FnType visit(FnType fnType)", "original_string": "  @Override public FnType visit(FnType fnType) {\n    return fnType.copy(typeSystem, t -> t.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "FnType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[TupleType]visit(TupleType)", "name": "visit", "arg_nums": 1, "params": [{"name": "tupleType", "type": "TupleType"}], "return_type": "TupleType", "signature": "@Override public TupleType visit(TupleType tupleType)", "original_string": "  @Override public TupleType visit(TupleType tupleType) {\n    return tupleType.copy(typeSystem, t -> t.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "TupleType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[RecordType]visit(RecordType)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordType", "type": "RecordType"}], "return_type": "RecordType", "signature": "@Override public RecordType visit(RecordType recordType)", "original_string": "  @Override public RecordType visit(RecordType recordType) {\n    return recordType.copy(typeSystem, t -> t.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[Type]visit(DataType)", "name": "visit", "arg_nums": 1, "params": [{"name": "dataType", "type": "DataType"}], "return_type": "Type", "signature": "@Override public Type visit(DataType dataType)", "original_string": "  @Override public Type visit(DataType dataType) {\n    return dataType.copy(typeSystem, t -> t.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[PrimitiveType]visit(PrimitiveType)", "name": "visit", "arg_nums": 1, "params": [{"name": "primitiveType", "type": "PrimitiveType"}], "return_type": "PrimitiveType", "signature": "@Override public PrimitiveType visit(PrimitiveType primitiveType)", "original_string": "  @Override public PrimitiveType visit(PrimitiveType primitiveType) {\n    return primitiveType.copy(typeSystem, t -> t.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "PrimitiveType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[ForallType]visit(ForallType)", "name": "visit", "arg_nums": 1, "params": [{"name": "forallType", "type": "ForallType"}], "return_type": "ForallType", "signature": "@Override public ForallType visit(ForallType forallType)", "original_string": "  @Override public ForallType visit(ForallType forallType) {\n    return forallType.copy(typeSystem, t -> t.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ForallType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle.[DummyType]visit(DummyType)", "name": "visit", "arg_nums": 1, "params": [{"name": "dummyType", "type": "DummyType"}], "return_type": "DummyType", "signature": "@Override public DummyType visit(DummyType dummyType)", "original_string": "  @Override public DummyType visit(DummyType dummyType) {\n    return dummyType.copy(typeSystem, t -> t.accept(this));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java", "class_name": "TypeShuttle", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeShuttle.java.TypeShuttle", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DummyType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(TypeVar)", "name": "visit", "arg_nums": 1, "params": [{"name": "typeVar", "type": "TypeVar"}], "return_type": "R", "signature": "public R visit(TypeVar typeVar)", "original_string": "  public R visit(TypeVar typeVar) {\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "class_name": "TypeVisitor", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Visits a {@link TypeVar}."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(ListType)", "name": "visit", "arg_nums": 1, "params": [{"name": "listType", "type": "ListType"}], "return_type": "R", "signature": "public R visit(ListType listType)", "original_string": "  public R visit(ListType listType) {\n    return listType.elementType.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "class_name": "TypeVisitor", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Visits a {@link ListType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(FnType)", "name": "visit", "arg_nums": 1, "params": [{"name": "fnType", "type": "FnType"}], "return_type": "R", "signature": "public R visit(FnType fnType)", "original_string": "  public R visit(FnType fnType) {\n    R r = fnType.paramType.accept(this);\n    return fnType.resultType.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "class_name": "TypeVisitor", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Visits a {@link FnType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(TupleType)", "name": "visit", "arg_nums": 1, "params": [{"name": "tupleType", "type": "TupleType"}], "return_type": "R", "signature": "public R visit(TupleType tupleType)", "original_string": "  public R visit(TupleType tupleType) {\n    R r = null;\n    for (Type argType : tupleType.argTypes) {\n      r = argType.accept(this);\n    }\n    return r;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "class_name": "TypeVisitor", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Visits a {@link TupleType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(RecordType)", "name": "visit", "arg_nums": 1, "params": [{"name": "recordType", "type": "RecordType"}], "return_type": "R", "signature": "public R visit(RecordType recordType)", "original_string": "  public R visit(RecordType recordType) {\n    R r = null;\n    for (Type type : recordType.argNameTypes.values()) {\n      r = type.accept(this);\n    }\n    return r;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "class_name": "TypeVisitor", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Visits a {@link RecordType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(DataType)", "name": "visit", "arg_nums": 1, "params": [{"name": "dataType", "type": "DataType"}], "return_type": "R", "signature": "public R visit(DataType dataType)", "original_string": "  public R visit(DataType dataType) {\n    dataType.parameterTypes.forEach(t -> t.accept(this));\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "class_name": "TypeVisitor", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Visits a {@link DataType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(PrimitiveType)", "name": "visit", "arg_nums": 1, "params": [{"name": "primitiveType", "type": "PrimitiveType"}], "return_type": "R", "signature": "public R visit(PrimitiveType primitiveType)", "original_string": "  public R visit(PrimitiveType primitiveType) {\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "class_name": "TypeVisitor", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Visits a {@link PrimitiveType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(ForallType)", "name": "visit", "arg_nums": 1, "params": [{"name": "forallType", "type": "ForallType"}], "return_type": "R", "signature": "public R visit(ForallType forallType)", "original_string": "  public R visit(ForallType forallType) {\n    return forallType.type.accept(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "class_name": "TypeVisitor", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Visits a {@link ForallType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor.[R]visit(DummyType)", "name": "visit", "arg_nums": 1, "params": [{"name": "dummyType", "type": "DummyType"}], "return_type": "R", "signature": "public R visit(DummyType dummyType)", "original_string": "  public R visit(DummyType dummyType) {\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java", "class_name": "TypeVisitor", "class_uri": "src/main/java/net/hydromatic/morel/type/TypeVisitor.java.TypeVisitor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": " Visits a {@link DummyType}."}, {"uris": "src/main/java/net/hydromatic/morel/type/FnType.java.FnType.[]FnType(Type,Type)", "name": "FnType", "arg_nums": 2, "params": [{"name": "paramType", "type": "Type"}, {"name": "resultType", "type": "Type"}], "return_type": "", "signature": "FnType(Type paramType, Type resultType)", "original_string": "  FnType(Type paramType, Type resultType) {\n    super(Op.FUNCTION_TYPE);\n    this.paramType = paramType;\n    this.resultType = resultType;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/FnType.java", "class_name": "FnType", "class_uri": "src/main/java/net/hydromatic/morel/type/FnType.java.FnType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/FnType.java.FnType.[Key]key()", "name": "key", "arg_nums": 0, "params": [], "return_type": "Key", "signature": "public Key key()", "original_string": "  public Key key() {\n    return Keys.fn(paramType.key(), resultType.key());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/FnType.java", "class_name": "FnType", "class_uri": "src/main/java/net/hydromatic/morel/type/FnType.java.FnType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Key", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/FnType.java.FnType.[R]accept(TypeVisitor<R>)", "name": "accept", "arg_nums": 1, "params": [{"name": "typeVisitor", "type": "TypeVisitor<R>"}], "return_type": "R", "signature": "public <R> R accept(TypeVisitor<R> typeVisitor)", "original_string": "  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/FnType.java", "class_name": "FnType", "class_uri": "src/main/java/net/hydromatic/morel/type/FnType.java.FnType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/FnType.java.FnType.[FnType]copy(TypeSystem,UnaryOperator<Type>)", "name": "copy", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "transform", "type": "UnaryOperator<Type>"}], "return_type": "FnType", "signature": "@Override public FnType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform)", "original_string": "  @Override public FnType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    final Type paramType2 = paramType.copy(typeSystem, transform);\n    final Type resultType2 = resultType.copy(typeSystem, transform);\n    return paramType2 == paramType\n        && resultType2 == resultType\n        ? this\n        : typeSystem.fnType(paramType2, resultType2);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/FnType.java", "class_name": "FnType", "class_uri": "src/main/java/net/hydromatic/morel/type/FnType.java.FnType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "FnType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[V]valueAs(Class<V>)", "name": "valueAs", "arg_nums": 1, "params": [{"name": "clazz", "type": "Class<V>"}], "return_type": "V", "signature": "<V> V valueAs(Class<V> clazz)", "original_string": "  <V> V valueAs(Class<V> clazz);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypedValue.java", "class_name": "TypedValue", "class_uri": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "V", "classes": []}, "docstring": " Returns the value cast as a particular type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[V]fieldValueAs(String,Class<V>)", "name": "fieldValueAs", "arg_nums": 2, "params": [{"name": "fieldName", "type": "String"}, {"name": "clazz", "type": "Class<V>"}], "return_type": "V", "signature": "default <V> V fieldValueAs(String fieldName, Class<V> clazz)", "original_string": "  default <V> V fieldValueAs(String fieldName, Class<V> clazz) {\n    throw new UnsupportedOperationException(\"not a record\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypedValue.java", "class_name": "TypedValue", "class_uri": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "V", "classes": []}, "docstring": " Returns the value of a field, identified by name,\ncast as a particular type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[V]fieldValueAs(int,Class<V>)", "name": "fieldValueAs", "arg_nums": 2, "params": [{"name": "fieldIndex", "type": "int"}, {"name": "clazz", "type": "Class<V>"}], "return_type": "V", "signature": "default <V> V fieldValueAs(int fieldIndex, Class<V> clazz)", "original_string": "  default <V> V fieldValueAs(int fieldIndex, Class<V> clazz) {\n    throw new UnsupportedOperationException(\"not a record\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypedValue.java", "class_name": "TypedValue", "class_uri": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "V", "classes": []}, "docstring": " Returns the value of a field, identified by ordinal,\ncast as a particular type."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[Type.Key]typeKey()", "name": "typeKey", "arg_nums": 0, "params": [], "return_type": "Type.Key", "signature": "Type.Key typeKey()", "original_string": "  Type.Key typeKey();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypedValue.java", "class_name": "TypedValue", "class_uri": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Type.Key", "classes": []}, "docstring": " Key from which the type of this value can be constructed."}, {"uris": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue.[TypedValue]discoverField(TypeSystem,String)", "name": "discoverField", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "fieldName", "type": "String"}], "return_type": "TypedValue", "signature": "default TypedValue discoverField(TypeSystem typeSystem, String fieldName)", "original_string": "  default TypedValue discoverField(TypeSystem typeSystem, String fieldName) {\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/TypedValue.java", "class_name": "TypedValue", "class_uri": "src/main/java/net/hydromatic/morel/type/TypedValue.java.TypedValue", "attributes": {"modifiers": "default", "marker_annotations": [], "non_marker_annotations": ["default"], "comments": [], "return_type": "TypedValue", "classes": []}, "docstring": " Tries to expand the type to include the given field name.\n\n<p>Returns this value or an expanded value."}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[]RecordType(SortedMap<String, Type>)", "name": "RecordType", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "SortedMap<String, Type>"}], "return_type": "", "signature": "RecordType(SortedMap<String, Type> argNameTypes)", "original_string": "  RecordType(SortedMap<String, Type> argNameTypes) {\n    super(Op.RECORD_TYPE);\n    this.argNameTypes = ImmutableSortedMap.copyOfSorted(argNameTypes);\n    checkArgument(argNameTypes.comparator() == ORDERING);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[SortedMap<String, Type>]argNameTypes()", "name": "argNameTypes", "arg_nums": 0, "params": [], "return_type": "SortedMap<String, Type>", "signature": "@Override public SortedMap<String, Type> argNameTypes()", "original_string": "  @Override public SortedMap<String, Type> argNameTypes() {\n    return argNameTypes;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<String, Type>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[Type]argType(int)", "name": "argType", "arg_nums": 1, "params": [{"name": "i", "type": "int"}], "return_type": "Type", "signature": "@Override public Type argType(int i)", "original_string": "  @Override public Type argType(int i) {\n    // No copy is made: values() is already a list.\n    return ImmutableList.copyOf(argNameTypes.values()).get(i);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[R]accept(TypeVisitor<R>)", "name": "accept", "arg_nums": 1, "params": [{"name": "typeVisitor", "type": "TypeVisitor<R>"}], "return_type": "R", "signature": "public <R> R accept(TypeVisitor<R> typeVisitor)", "original_string": "  public <R> R accept(TypeVisitor<R> typeVisitor) {\n    return typeVisitor.visit(this);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "R", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[Key]key()", "name": "key", "arg_nums": 0, "params": [], "return_type": "Key", "signature": "public Key key()", "original_string": "  public Key key() {\n    return Keys.record(Keys.toKeys(argNameTypes));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Key", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[RecordType]copy(TypeSystem,UnaryOperator<Type>)", "name": "copy", "arg_nums": 2, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "transform", "type": "UnaryOperator<Type>"}], "return_type": "RecordType", "signature": "@Override public RecordType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform)", "original_string": "  @Override public RecordType copy(TypeSystem typeSystem,\n      UnaryOperator<Type> transform) {\n    int differenceCount = 0;\n    final PairList<String, Type> argNameTypes2 = PairList.of();\n    for (Map.Entry<String, Type> entry : argNameTypes.entrySet()) {\n      final Type type = entry.getValue();\n      final Type type2 = type.copy(typeSystem, transform);\n      if (type != type2) {\n        ++differenceCount;\n      }\n      argNameTypes2.add(entry.getKey(), type2);\n    }\n    return differenceCount == 0\n        ? this\n        : (RecordType) typeSystem.recordType(argNameTypes2);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "RecordType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[SortedMap<String, V>]map(String,V)", "name": "map", "arg_nums": 2, "params": [{"name": "name", "type": "String"}, {"name": "v0", "type": "V"}], "return_type": "SortedMap<String, V>", "signature": "@SuppressWarnings(\"unchecked\")\n  public static <V> SortedMap<String, V> map(String name, V v0,\n      Object... entries)", "original_string": "  @SuppressWarnings(\"unchecked\")\n  public static <V> SortedMap<String, V> map(String name, V v0,\n      Object... entries) {\n    final ImmutableSortedMap.Builder<String, V> builder =\n        ImmutableSortedMap.orderedBy(ORDERING);\n    builder.put(name, v0);\n    for (int i = 0; i < entries.length / 2; i += 2) {\n      builder.put((String) entries[i], (V) entries[i + 1]);\n    }\n    return builder.build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public", "static"], "comments": [], "return_type": "SortedMap<String, V>", "classes": []}, "docstring": " Creates a constant map, sorted by {@link #ORDERING}."}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[NavigableMap<String, V>]mutableMap()", "name": "mutableMap", "arg_nums": 0, "params": [], "return_type": "NavigableMap<String, V>", "signature": "public static <V> NavigableMap<String, V> mutableMap()", "original_string": "  public static <V> NavigableMap<String, V> mutableMap() {\n    return new TreeMap<>(ORDERING);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "NavigableMap<String, V>", "classes": []}, "docstring": " Creates a mutable map, sorted by {@link #ORDERING}."}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[int]compareNames(String,String)", "name": "compareNames", "arg_nums": 2, "params": [{"name": "o1", "type": "String"}, {"name": "o2", "type": "String"}], "return_type": "int", "signature": "public static int compareNames(String o1, String o2)", "original_string": "  public static int compareNames(String o1, String o2) {\n    int i1 = parseInt(o1);\n    int i2 = parseInt(o2);\n    int c = Integer.compare(i1, i2);\n    if (c != 0) {\n      return c;\n    }\n    return o1.compareTo(o2);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Helper for {@link #ORDERING}."}, {"uris": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType.[int]parseInt(String)", "name": "parseInt", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "int", "signature": "private static int parseInt(String s)", "original_string": "  private static int parseInt(String s) {\n    final int length = s.length();\n    if (length > 9) {\n      // We treat values that are 1 billion (1,000,000,000) or higher as if they\n      // are Integer.MAX_VALUE (2,147,483,648). Therefore, we do not need to\n      // check for overflow in the loop below.\n      return Integer.MAX_VALUE;\n    }\n    int n = 0;\n    for (int i = 0; i < length; i++) {\n      char c = s.charAt(i);\n      if (c < '0' || c > '9') {\n        return Integer.MAX_VALUE;\n      }\n      int digit = c - '0';\n      n = n * 10 + digit;\n    }\n    return n;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RecordType.java", "class_name": "RecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/RecordType.java.RecordType", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Parses a string that contains an integer value; returns\n{@link Integer#MAX_VALUE} if the string does not contain an integer,\nor if the value is less than zero,\nor if the value is greater than or equal to 1 billion.\n\n<p>This approach is much faster for our purposes than\n{@link Integer#parseInt(String)}, which has to create and throw an\nexception if the value is not an integer."}, {"uris": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType.[]ProgressiveRecordType(SortedMap<String, Type>)", "name": "ProgressiveRecordType", "arg_nums": 1, "params": [{"name": "argNameTypes", "type": "SortedMap<String, Type>"}], "return_type": "", "signature": "ProgressiveRecordType(SortedMap<String, Type> argNameTypes)", "original_string": "  ProgressiveRecordType(SortedMap<String, Type> argNameTypes) {\n    super(argNameTypes);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java", "class_name": "ProgressiveRecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a ProgressiveRecordType."}, {"uris": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType.[boolean]isProgressive()", "name": "isProgressive", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override public boolean isProgressive()", "original_string": "  @Override public boolean isProgressive() {\n    return true;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java", "class_name": "ProgressiveRecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType.[Key]key()", "name": "key", "arg_nums": 0, "params": [], "return_type": "Key", "signature": "@Override public Key key()", "original_string": "  @Override public Key key() {\n    return Keys.progressiveRecord(Keys.toKeys(argNameTypes));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java", "class_name": "ProgressiveRecordType", "class_uri": "src/main/java/net/hydromatic/morel/type/ProgressiveRecordType.java.ProgressiveRecordType", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Key", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[]RangeExtent(TypeSystem,Type,Map<String, ImmutableRangeSet>)", "name": "RangeExtent", "arg_nums": 3, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "type", "type": "Type"}, {"name": "rangeSetMap", "type": "Map<String, ImmutableRangeSet>"}], "return_type": "", "signature": "@SuppressWarnings(\"unchecked\")\n  public RangeExtent(TypeSystem typeSystem, Type type,\n      Map<String, ImmutableRangeSet> rangeSetMap)", "original_string": "  @SuppressWarnings(\"unchecked\")\n  public RangeExtent(TypeSystem typeSystem, Type type,\n      Map<String, ImmutableRangeSet> rangeSetMap) {\n    this.rangeSetMap =\n        ImmutableMap.copyOf(\n            Maps.transformValues(rangeSetMap,\n                r -> ImmutableRangeSet.copyOf(r)));\n    this.type = type;\n    this.iterable = toList(type, typeSystem);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RangeExtent.java", "class_name": "RangeExtent", "class_uri": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a RangeExtent."}, {"uris": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override public String toString()", "original_string": "  @Override public String toString() {\n    if (isUnbounded()) {\n      return type.toString(); // range set is unconstrained; don't print it\n    }\n    return type + \" \" + rangeSetMap;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RangeExtent.java", "class_name": "RangeExtent", "class_uri": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[boolean]isUnbounded()", "name": "isUnbounded", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isUnbounded()", "original_string": "  public boolean isUnbounded() {\n    return rangeSetMap.isEmpty();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RangeExtent.java", "class_name": "RangeExtent", "class_uri": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Whether this extent returns all, or an unbounded number of, the values of\nits type.\n\n<p>Examples:\n\"(-inf,+inf)\" (true),\n\"(-inf,0]\" (x &le; 0),\n\"{(-inf,3),(10,+inf)}\" (x &lt; 3 or x &gt; 10) are unbounded;\n\"{}\" (false),\n\"{3, 10}\" (x in [3, 10]),\n\"(3, 10)\" (x &ge; 3 andalso x &le; 10) are bounded."}, {"uris": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[Iterable<E>]toList(Type,TypeSystem)", "name": "toList", "arg_nums": 2, "params": [{"name": "type", "type": "Type"}, {"name": "typeSystem", "type": "TypeSystem"}], "return_type": "Iterable<E>", "signature": "private <E extends Comparable<E>> Iterable<E> toList(Type type,\n      TypeSystem typeSystem)", "original_string": "  private <E extends Comparable<E>> Iterable<E> toList(Type type,\n      TypeSystem typeSystem) {\n    final List<E> list = new ArrayList<>();\n    if (populate(typeSystem, type, \"/\", rangeSetMap, (Consumer<E>) list::add)) {\n      return list;\n    }\n    return null;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RangeExtent.java", "class_name": "RangeExtent", "class_uri": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Iterable<E>", "classes": []}, "docstring": " Derives the collection of values in the range, or returns empty if\nthe range is infinite."}, {"uris": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent.[boolean]populate(TypeSystem,Type,String,Map<String, ImmutableRangeSet>,Consumer<E>)", "name": "populate", "arg_nums": 5, "params": [{"name": "typeSystem", "type": "TypeSystem"}, {"name": "type", "type": "Type"}, {"name": "path", "type": "String"}, {"name": "rangeSetMap", "type": "Map<String, ImmutableRangeSet>"}, {"name": "consumer", "type": "Consumer<E>"}], "return_type": "boolean", "signature": "@SuppressWarnings(\"unchecked\")\n  private <E extends Comparable<E>> boolean populate(TypeSystem typeSystem,\n      Type type, String path, Map<String, ImmutableRangeSet> rangeSetMap,\n      Consumer<E> consumer)", "original_string": "  @SuppressWarnings(\"unchecked\")\n  private <E extends Comparable<E>> boolean populate(TypeSystem typeSystem,\n      Type type, String path, Map<String, ImmutableRangeSet> rangeSetMap,\n      Consumer<E> consumer) {\n    final RangeSet<E> rangeSet = rangeSetMap.get(path);\n    final Consumer<E> filteredConsumer;\n    if (rangeSet != null) {\n      filteredConsumer = e -> {\n        if (rangeSet.contains(e)) {\n          consumer.accept(e);\n        }\n      };\n    } else {\n      filteredConsumer = consumer;\n    }\n    switch (type.op()) {\n    case ID:\n      switch ((PrimitiveType) type) {\n      case BOOL:\n        filteredConsumer.accept((E) Boolean.FALSE);\n        filteredConsumer.accept((E) Boolean.TRUE);\n        return true;\n\n      case UNIT:\n        filteredConsumer.accept((E) Unit.INSTANCE);\n        return true;\n\n      case CHAR:\n        for (int i = 0; i < 256; i++) {\n          filteredConsumer.accept((E) Character.valueOf((char) i));\n        }\n        return true;\n\n      case INT:\n        if (rangeSet != null) {\n          for (Range<E> range : rangeSet.asRanges()) {\n            if (!range.hasLowerBound() || !range.hasUpperBound()) {\n              return false;\n            }\n            final int lower =\n                ((BigDecimal) range.lowerEndpoint()).intValue()\n                    + (range.lowerBoundType() == BoundType.OPEN ? 1 : 0);\n            final int upper =\n                ((BigDecimal) range.upperEndpoint()).intValue()\n                - (range.upperBoundType() == BoundType.OPEN ? 1 : 0);\n            for (int i = lower; i <= upper; i++) {\n              consumer.accept((E) Integer.valueOf(i));\n            }\n          }\n          return true;\n        }\n        // fall through\n      }\n      return false;\n\n    case DUMMY_TYPE:\n      assert type == DummyType.INSTANCE;\n      filteredConsumer.accept((E) Unit.INSTANCE);\n      return true;\n\n    case DATA_TYPE:\n      final DataType dataType = (DataType) type;\n      for (Map.Entry<String, Type> entry\n          : dataType.typeConstructors(typeSystem).entrySet()) {\n        final String name = entry.getKey();\n        final Type type2 = entry.getValue();\n        final Consumer<E> consumer2 =\n            type2.op() == Op.DUMMY_TYPE\n                ? v -> filteredConsumer.accept((E) FlatLists.of(name))\n                : v -> filteredConsumer.accept((E) FlatLists.of(name, v));\n        if (!populate(typeSystem, type2, path + name + \"/\", rangeSetMap,\n            consumer2)) {\n          return false;\n        }\n      }\n      return true;\n\n    case RECORD_TYPE:\n    case TUPLE_TYPE:\n      final RecordLikeType recordType = (RecordLikeType) type;\n      final List<List<E>> listList = new ArrayList<>();\n      for (Map.Entry<String, Type> entry\n          : recordType.argNameTypes().entrySet()) {\n        final String name = entry.getKey();\n        final Type type2 = entry.getValue();\n        final List<E> list2 = new ArrayList<>();\n        final Consumer<E> consumer2 = list2::add;\n        if (!populate(typeSystem, type2, path + name + '/', rangeSetMap,\n            consumer2)) {\n          return false;\n        }\n        listList.add(list2);\n      }\n      Lists.cartesianProduct(listList)\n          .forEach(list ->\n              filteredConsumer.accept((E) FlatLists.ofComparable((List) list)));\n      return true;\n\n    default:\n      // All other types are not enumerable\n      return false;\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/type/RangeExtent.java", "class_name": "RangeExtent", "class_uri": "src/main/java/net/hydromatic/morel/type/RangeExtent.java.RangeExtent", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Populates a list (or other consumer) with all values of this type. Returns\nfalse if this type is not finite and the range is open above or below."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[]Converters()", "name": "Converters", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Converters()", "original_string": "  private Converters() {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofRow(RelDataType)", "name": "ofRow", "arg_nums": 1, "params": [{"name": "rowType", "type": "RelDataType"}], "return_type": "Converter<Object[]>", "signature": "public static Converter<Object[]> ofRow(RelDataType rowType)", "original_string": "  public static Converter<Object[]> ofRow(RelDataType rowType) {\n    final List<RelDataTypeField> fields = rowType.getFieldList();\n    final ImmutableList.Builder<Converter<Object[]>> converters =\n        ImmutableList.builder();\n    forEachIndexed(fields, (field, i) ->\n        converters.add(ofField(field.getType(), i)));\n    return new RecordConverter(converters.build());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Converter<Object[]>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofRow2(RelDataType,RecordLikeType)", "name": "ofRow2", "arg_nums": 2, "params": [{"name": "rowType", "type": "RelDataType"}, {"name": "type", "type": "RecordLikeType"}], "return_type": "Converter<Object[]>", "signature": "public static Converter<Object[]> ofRow2(RelDataType rowType,\n      RecordLikeType type)", "original_string": "  public static Converter<Object[]> ofRow2(RelDataType rowType,\n      RecordLikeType type) {\n    return ofRow3(rowType.getFieldList().iterator(),\n        new AtomicInteger(), Linq4j.enumerator(type.argTypes()));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Converter<Object[]>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofRow3(Iterator<RelDataTypeField>,AtomicInteger,Enumerator<Type>)", "name": "ofRow3", "arg_nums": 3, "params": [{"name": "fields", "type": "Iterator<RelDataTypeField>"}, {"name": "ordinal", "type": "AtomicInteger"}, {"name": "types", "type": "Enumerator<Type>"}], "return_type": "Converter<Object[]>", "signature": "static Converter<Object[]> ofRow3(Iterator<RelDataTypeField> fields,\n      AtomicInteger ordinal, Enumerator<Type> types)", "original_string": "  static Converter<Object[]> ofRow3(Iterator<RelDataTypeField> fields,\n      AtomicInteger ordinal, Enumerator<Type> types) {\n    final ImmutableList.Builder<Converter<Object[]>> converters =\n        ImmutableList.builder();\n    while (types.moveNext()) {\n      converters.add(ofField2(fields, ordinal, types.current()));\n    }\n    return new RecordConverter(converters.build());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Converter<Object[]>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofField(RelDataType,int)", "name": "ofField", "arg_nums": 2, "params": [{"name": "type", "type": "RelDataType"}, {"name": "ordinal", "type": "int"}], "return_type": "Converter<Object[]>", "signature": "public static Converter<Object[]> ofField(RelDataType type, int ordinal)", "original_string": "  public static Converter<Object[]> ofField(RelDataType type, int ordinal) {\n    final FieldConverter fieldConverter = FieldConverter.toType(type);\n    return values -> fieldConverter.convertFrom(values[ordinal]);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Converter<Object[]>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofField2(Iterator<RelDataTypeField>,AtomicInteger,Type)", "name": "ofField2", "arg_nums": 3, "params": [{"name": "fields", "type": "Iterator<RelDataTypeField>"}, {"name": "ordinal", "type": "AtomicInteger"}, {"name": "type", "type": "Type"}], "return_type": "Converter<Object[]>", "signature": "static Converter<Object[]> ofField2(Iterator<RelDataTypeField> fields,\n      AtomicInteger ordinal, Type type)", "original_string": "  static Converter<Object[]> ofField2(Iterator<RelDataTypeField> fields,\n      AtomicInteger ordinal, Type type) {\n    final RelDataTypeField field = fields.next();\n    if (type instanceof RecordType) {\n      if (field.getType().isStruct()) {\n        return offset(ordinal.getAndIncrement(),\n            ofRow3(field.getType().getFieldList().iterator(),\n                new AtomicInteger(),\n                Linq4j.enumerator(((RecordType) type).argNameTypes.values())));\n      } else {\n        return ofRow3(fields, ordinal,\n            Linq4j.enumerator(((RecordType) type).argNameTypes.values()));\n      }\n    }\n    return ofField3(field, ordinal, type);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Converter<Object[]>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]offset(int,Converter<Object[]>)", "name": "offset", "arg_nums": 2, "params": [{"name": "i", "type": "int"}, {"name": "converter", "type": "Converter<Object[]>"}], "return_type": "Converter<Object[]>", "signature": "static Converter<Object[]> offset(int i, Converter<Object[]> converter)", "original_string": "  static Converter<Object[]> offset(int i, Converter<Object[]> converter) {\n    return values -> converter.apply((Object[]) values[i]);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Converter<Object[]>", "classes": []}, "docstring": " Creates a converter that applies to the {@code i}th field of the input\narray."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Converter<Object[]>]ofField3(RelDataTypeField,AtomicInteger,Type)", "name": "ofField3", "arg_nums": 3, "params": [{"name": "field", "type": "RelDataTypeField"}, {"name": "ordinal", "type": "AtomicInteger"}, {"name": "type", "type": "Type"}], "return_type": "Converter<Object[]>", "signature": "static Converter<Object[]> ofField3(RelDataTypeField field,\n      AtomicInteger ordinal, Type type)", "original_string": "  static Converter<Object[]> ofField3(RelDataTypeField field,\n      AtomicInteger ordinal, Type type) {\n    if (field.getType().isStruct()) {\n      return ofRow3(field.getType().getFieldList().iterator(), ordinal,\n          Linq4j.singletonEnumerator(type));\n    }\n    final FieldConverter fieldConverter =\n        FieldConverter.toType(field.getType());\n    final int i = ordinal.getAndIncrement();\n    return values -> fieldConverter.convertFrom(values[i]);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Converter<Object[]>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<Enumerable<Object[]>, List<Object>>]fromEnumerable(RelNode,Type)", "name": "fromEnumerable", "arg_nums": 2, "params": [{"name": "rel", "type": "RelNode"}, {"name": "type", "type": "Type"}], "return_type": "Function<Enumerable<Object[]>, List<Object>>", "signature": "@SuppressWarnings(\"unchecked\")\n  public static Function<Enumerable<Object[]>, List<Object>>\n      fromEnumerable(RelNode rel, Type type)", "original_string": "  @SuppressWarnings(\"unchecked\")\n  public static Function<Enumerable<Object[]>, List<Object>>\n      fromEnumerable(RelNode rel, Type type) {\n    final ListType listType = (ListType) type;\n    final RelDataType rowType = rel.getRowType();\n    final Function<Object[], Object> elementConverter =\n        forType(rowType, listType.elementType);\n    return enumerable -> enumerable.select(elementConverter::apply).toList();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public", "static"], "comments": [], "return_type": "Function<Enumerable<Object[]>, List<Object>>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<E, Object>]forType(RelDataType,Type)", "name": "forType", "arg_nums": 2, "params": [{"name": "fromType", "type": "RelDataType"}, {"name": "type", "type": "Type"}], "return_type": "Function<E, Object>", "signature": "@SuppressWarnings(\"unchecked\")\n  public static <E> Function<E, Object> forType(RelDataType fromType, Type type)", "original_string": "  @SuppressWarnings(\"unchecked\")\n  public static <E> Function<E, Object> forType(RelDataType fromType, Type type) {\n    if (type == PrimitiveType.UNIT) {\n      return o -> Unit.INSTANCE;\n    }\n    if (type instanceof PrimitiveType) {\n      RelDataTypeField field =\n          Iterables.getOnlyElement(fromType.getFieldList());\n      return (Converter<E>) ofField(field.getType(), 0);\n    }\n    if (type instanceof RecordLikeType) {\n      return (Converter<E>) ofRow2(fromType, (RecordLikeType) type);\n    }\n    if (fromType.isNullable()) {\n      return o -> o == null ? BigDecimal.ZERO : o;\n    }\n    return o -> o;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n  public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public", "static"], "comments": [], "return_type": "Function<E, Object>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Type]fieldType(RelDataTypeField)", "name": "fieldType", "arg_nums": 1, "params": [{"name": "field", "type": "RelDataTypeField"}], "return_type": "Type", "signature": "public static Type fieldType(RelDataTypeField field)", "original_string": "  public static Type fieldType(RelDataTypeField field) {\n    return FieldConverter.toType(field.getType()).mlType;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[RelDataType]toCalciteType(Type,RelDataTypeFactory)", "name": "toCalciteType", "arg_nums": 2, "params": [{"name": "type", "type": "Type"}, {"name": "typeFactory", "type": "RelDataTypeFactory"}], "return_type": "RelDataType", "signature": "public static RelDataType toCalciteType(Type type,\n      RelDataTypeFactory typeFactory)", "original_string": "  public static RelDataType toCalciteType(Type type,\n      RelDataTypeFactory typeFactory) {\n    return C2m.forMorel(type, typeFactory, false, true).calciteType;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RelDataType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<Object, Enumerable<Object[]>>]toCalciteEnumerable(Type,RelDataTypeFactory)", "name": "toCalciteEnumerable", "arg_nums": 2, "params": [{"name": "type", "type": "Type"}, {"name": "typeFactory", "type": "RelDataTypeFactory"}], "return_type": "Function<Object, Enumerable<Object[]>>", "signature": "public static Function<Object, Enumerable<Object[]>> toCalciteEnumerable(\n      Type type, RelDataTypeFactory typeFactory)", "original_string": "  public static Function<Object, Enumerable<Object[]>> toCalciteEnumerable(\n      Type type, RelDataTypeFactory typeFactory) {\n    final C2m converter =\n        C2m.forMorel(type, typeFactory, false, false);\n    return converter::toCalciteEnumerable;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Function<Object, Enumerable<Object[]>>", "classes": []}, "docstring": " Returns a function that converts from Morel objects to an Enumerable\nover Calcite rows."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<Object, Object>]toCalcite(Type,RelDataTypeFactory)", "name": "toCalcite", "arg_nums": 2, "params": [{"name": "type", "type": "Type"}, {"name": "typeFactory", "type": "RelDataTypeFactory"}], "return_type": "Function<Object, Object>", "signature": "public static Function<Object, Object> toCalcite(Type type,\n      RelDataTypeFactory typeFactory)", "original_string": "  public static Function<Object, Object> toCalcite(Type type,\n      RelDataTypeFactory typeFactory) {\n    final C2m converter =\n        C2m.forMorel(type, typeFactory, false, true);\n    return converter::toCalciteObject;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Function<Object, Object>", "classes": []}, "docstring": " Returns a function that converts from Morel objects to Calcite objects."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters.[Function<Object, Object>]toMorel(Type,RelDataTypeFactory)", "name": "toMorel", "arg_nums": 2, "params": [{"name": "type", "type": "Type"}, {"name": "typeFactory", "type": "RelDataTypeFactory"}], "return_type": "Function<Object, Object>", "signature": "public static Function<Object, Object> toMorel(Type type,\n      RelDataTypeFactory typeFactory)", "original_string": "  public static Function<Object, Object> toMorel(Type type,\n      RelDataTypeFactory typeFactory) {\n    final C2m converter =\n        C2m.forMorel(type, typeFactory, false, true);\n    return converter.toMorelObjectFunction();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Converters.java", "class_name": "Converters", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Converters.java.Converters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Function<Object, Object>", "classes": []}, "docstring": " Returns a function that converts from Calcite objects to Morel objects."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java.CalciteFunctions.[]CalciteFunctions()", "name": "CalciteFunctions", "arg_nums": 0, "params": [], "return_type": "", "signature": "private CalciteFunctions()", "original_string": "  private CalciteFunctions() {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java", "class_name": "CalciteFunctions", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java.CalciteFunctions", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java.CalciteFunctions.[RelDataType]inferReturnType(SqlOperatorBinding)", "name": "inferReturnType", "arg_nums": 1, "params": [{"name": "b", "type": "SqlOperatorBinding"}], "return_type": "RelDataType", "signature": "private static RelDataType inferReturnType(SqlOperatorBinding b)", "original_string": "  private static RelDataType inferReturnType(SqlOperatorBinding b) {\n    return b.getTypeFactory().createSqlType(SqlTypeName.INTEGER);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java", "class_name": "CalciteFunctions", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteFunctions.java.CalciteFunctions", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "RelDataType", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/DataSet.java.DataSet.[ForeignValue]foreignValue(Calcite)", "name": "foreignValue", "arg_nums": 1, "params": [{"name": "calcite", "type": "Calcite"}], "return_type": "ForeignValue", "signature": "ForeignValue foreignValue(Calcite calcite)", "original_string": "  ForeignValue foreignValue(Calcite calcite);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/DataSet.java", "class_name": "DataSet", "class_uri": "src/main/java/net/hydromatic/morel/foreign/DataSet.java.DataSet", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "ForeignValue", "classes": []}, "docstring": " Returns this data set as a foreign value."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList.[]RelList(RelNode,DataContext,Function<Object[], Object>)", "name": "RelList", "arg_nums": 3, "params": [{"name": "rel", "type": "RelNode"}, {"name": "dataContext", "type": "DataContext"}, {"name": "converter", "type": "Function<Object[], Object>"}], "return_type": "", "signature": "RelList(RelNode rel, DataContext dataContext,\n      Function<Object[], Object> converter)", "original_string": "  RelList(RelNode rel, DataContext dataContext,\n      Function<Object[], Object> converter) {\n    this.rel = rel;\n    //noinspection FunctionalExpressionCanBeFolded\n    supplier = Suppliers.memoize(() ->\n        new Interpreter(dataContext, rel)\n            .select(converter::apply)\n            .toList())::get;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/RelList.java", "class_name": "RelList", "class_uri": "src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList.[Object]get(int)", "name": "get", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "Object", "signature": "public Object get(int index)", "original_string": "  public Object get(int index) {\n    return supplier.get().get(index);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/RelList.java", "class_name": "RelList", "class_uri": "src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList.[int]size()", "name": "size", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int size()", "original_string": "  public int size() {\n    return supplier.get().size();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/RelList.java", "class_name": "RelList", "class_uri": "src/main/java/net/hydromatic/morel/foreign/RelList.java.RelList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[]Calcite()", "name": "Calcite", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected Calcite()", "original_string": "  protected Calcite() {\n    rootSchema = CalciteSchema.createRootSchema(false).plus();\n    relBuilder = RelBuilder.create(Frameworks.newConfigBuilder()\n        .defaultSchema(rootSchema)\n        .build());\n    typeFactory = (JavaTypeFactory) relBuilder.getTypeFactory();\n    dataContext = new EmptyDataContext(typeFactory, rootSchema);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Calcite.java", "class_name": "Calcite", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[Map<String, ForeignValue>]foreignValues()", "name": "foreignValues", "arg_nums": 0, "params": [], "return_type": "Map<String, ForeignValue>", "signature": "public Map<String, ForeignValue> foreignValues()", "original_string": "  public Map<String, ForeignValue> foreignValues() {\n    return ImmutableMap.of();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Calcite.java", "class_name": "Calcite", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, ForeignValue>", "classes": []}, "docstring": " Returns foreign values."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[Calcite]withDataSets(Map<String, DataSet>)", "name": "withDataSets", "arg_nums": 1, "params": [{"name": "dataSetMap", "type": "Map<String, DataSet>"}], "return_type": "Calcite", "signature": "public static Calcite withDataSets(Map<String, DataSet> dataSetMap)", "original_string": "  public static Calcite withDataSets(Map<String, DataSet> dataSetMap) {\n    return new CalciteMap(dataSetMap);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Calcite.java", "class_name": "Calcite", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Calcite", "classes": []}, "docstring": " Creates a runtime context with the given data sets."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[RelBuilder]relBuilder()", "name": "relBuilder", "arg_nums": 0, "params": [], "return_type": "RelBuilder", "signature": "public RelBuilder relBuilder()", "original_string": "  public RelBuilder relBuilder() {\n    return relBuilder.transform(c -> c);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Calcite.java", "class_name": "Calcite", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RelBuilder", "classes": []}, "docstring": " Creates an empty RelBuilder."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite.[Code]code(Environment,RelNode,Type)", "name": "code", "arg_nums": 3, "params": [{"name": "env", "type": "Environment"}, {"name": "rel", "type": "RelNode"}, {"name": "type", "type": "Type"}], "return_type": "Code", "signature": "public Code code(Environment env, RelNode rel, Type type)", "original_string": "  public Code code(Environment env, RelNode rel, Type type) {\n    // Transform the relational expression, converting sub-queries. For example,\n    // RexSubQuery.IN becomes a Join.\n    final Program program =\n        Programs.sequence(\n            Programs.subQuery(DefaultRelMetadataProvider.INSTANCE),\n            new DecorrelateProgram());\n    final RelOptPlanner planner = rel.getCluster().getPlanner();\n    final RelTraitSet traitSet = rel.getCluster().traitSet();\n    final RelNode rel2 = program.run(planner, rel, traitSet,\n        ImmutableList.of(), ImmutableList.of());\n\n    final Function<Enumerable<Object[]>, List<Object>> converter =\n        Converters.fromEnumerable(rel, type);\n    return new CalciteCode(dataContext, rel2, env, converter);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/Calcite.java", "class_name": "Calcite", "class_uri": "src/main/java/net/hydromatic/morel/foreign/Calcite.java.Calcite", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Code", "classes": []}, "docstring": " Creates a {@code Code} that evaluates a Calcite relational expression,\nconverting it to Morel list type {@code type}."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[]CalciteForeignValue(Calcite,SchemaPlus,boolean)", "name": "CalciteForeignValue", "arg_nums": 3, "params": [{"name": "calcite", "type": "Calcite"}, {"name": "schema", "type": "SchemaPlus"}, {"name": "lower", "type": "boolean"}], "return_type": "", "signature": "public CalciteForeignValue(Calcite calcite, SchemaPlus schema, boolean lower)", "original_string": "  public CalciteForeignValue(Calcite calcite, SchemaPlus schema, boolean lower) {\n    this.calcite = requireNonNull(calcite);\n    this.schema = requireNonNull(schema);\n    this.lower = lower;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "class_name": "CalciteForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Creates a CalciteForeignValue."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[Type]type(TypeSystem)", "name": "type", "arg_nums": 1, "params": [{"name": "typeSystem", "type": "TypeSystem"}], "return_type": "Type", "signature": "public Type type(TypeSystem typeSystem)", "original_string": "  public Type type(TypeSystem typeSystem) {\n    return toType(schema, typeSystem);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "class_name": "CalciteForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[Type]toType(SchemaPlus,TypeSystem)", "name": "toType", "arg_nums": 2, "params": [{"name": "schema", "type": "SchemaPlus"}, {"name": "typeSystem", "type": "TypeSystem"}], "return_type": "Type", "signature": "private Type toType(SchemaPlus schema, TypeSystem typeSystem)", "original_string": "  private Type toType(SchemaPlus schema, TypeSystem typeSystem) {\n    final SortedMap<String, Type> fields = RecordType.mutableMap();\n    schema.getTableNames().forEach(tableName -> {\n      Table table = requireNonNull(schema.getTable(tableName));\n      fields.put(convert(tableName), toType(table, typeSystem));\n    });\n    schema.getSubSchemaNames().forEach(subSchemaName -> {\n      final SchemaPlus subSchema =\n          requireNonNull(schema.getSubSchema(subSchemaName));\n      fields.put(convert(subSchemaName), toType(subSchema, typeSystem));\n    });\n\n    return typeSystem.recordType(fields);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "class_name": "CalciteForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[Type]toType(Table,TypeSystem)", "name": "toType", "arg_nums": 2, "params": [{"name": "table", "type": "Table"}, {"name": "typeSystem", "type": "TypeSystem"}], "return_type": "Type", "signature": "private Type toType(Table table, TypeSystem typeSystem)", "original_string": "  private Type toType(Table table, TypeSystem typeSystem) {\n    final PairList<String, Type> fields = PairList.of();\n    table.getRowType(calcite.typeFactory)\n        .getFieldList()\n        .forEach(field ->\n            fields.add(convert(field.getName()), Converters.fieldType(field)));\n    return typeSystem.listType(typeSystem.recordType(fields));\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "class_name": "CalciteForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[String]convert(String)", "name": "convert", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "String", "signature": "private String convert(String name)", "original_string": "  private String convert(String name) {\n    return convert(lower, name);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "class_name": "CalciteForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[String]convert(boolean,String)", "name": "convert", "arg_nums": 2, "params": [{"name": "lower", "type": "boolean"}, {"name": "name", "type": "String"}], "return_type": "String", "signature": "private static String convert(boolean lower, String name)", "original_string": "  private static String convert(boolean lower, String name) {\n    return lower ? name.toLowerCase(Locale.ROOT) : name;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "class_name": "CalciteForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[Object]value()", "name": "value", "arg_nums": 0, "params": [], "return_type": "Object", "signature": "public Object value()", "original_string": "  public Object value() {\n    return valueFor(schema);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "class_name": "CalciteForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[ImmutableList<Object>]valueFor(SchemaPlus)", "name": "valueFor", "arg_nums": 1, "params": [{"name": "schema", "type": "SchemaPlus"}], "return_type": "ImmutableList<Object>", "signature": "private ImmutableList<Object> valueFor(SchemaPlus schema)", "original_string": "  private ImmutableList<Object> valueFor(SchemaPlus schema) {\n    final SortedMap<String, Object> fieldValues = RecordType.mutableMap();\n    final List<String> names = Schemas.path(schema).names();\n    schema.getTableNames().forEach(tableName -> {\n      final RelBuilder b = calcite.relBuilder;\n      b.scan(plus(names, tableName));\n      final List<RexNode> exprList = b.peek().getRowType()\n          .getFieldList().stream()\n          .map(f -> Ord.of(f.getIndex(), convert(f.getName())))\n          .sorted(Map.Entry.comparingByValue())\n          .map(p -> b.alias(b.field(p.i), p.e))\n          .collect(Collectors.toList());\n      b.project(exprList, ImmutableList.of(), true);\n      final RelNode rel = b.build();\n      final Converter<Object[]> converter = Converters.ofRow(rel.getRowType());\n      fieldValues.put(convert(tableName),\n          new RelList(rel, calcite.dataContext, converter));\n    });\n\n    // Recursively walk sub-schemas and add their tables to fieldValues\n    schema.getSubSchemaNames().forEach(subSchemaName -> {\n      final SchemaPlus subSchema =\n          requireNonNull(schema.getSubSchema(subSchemaName));\n      fieldValues.put(convert(subSchemaName),\n          valueFor(subSchema));\n    });\n    return ImmutableList.copyOf(fieldValues.values());\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "class_name": "CalciteForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "ImmutableList<Object>", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue.[List<E>]plus(List<E>,E)", "name": "plus", "arg_nums": 2, "params": [{"name": "list", "type": "List<E>"}, {"name": "e", "type": "E"}], "return_type": "List<E>", "signature": "private static <E> List<E> plus(List<E> list, E e)", "original_string": "  private static <E> List<E> plus(List<E> list, E e) {\n    return ImmutableList.<E>builder().addAll(list).add(e).build();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java", "class_name": "CalciteForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/CalciteForeignValue.java.CalciteForeignValue", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<E>", "classes": []}, "docstring": " Returns a copy of a list with one element appended."}, {"uris": "src/main/java/net/hydromatic/morel/foreign/ForeignValue.java.ForeignValue.[Type]type(TypeSystem)", "name": "type", "arg_nums": 1, "params": [{"name": "typeSystem", "type": "TypeSystem"}], "return_type": "Type", "signature": "Type type(TypeSystem typeSystem)", "original_string": "  Type type(TypeSystem typeSystem);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/ForeignValue.java", "class_name": "ForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/ForeignValue.java.ForeignValue", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Type", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/foreign/ForeignValue.java.ForeignValue.[Object]value()", "name": "value", "arg_nums": 0, "params": [], "return_type": "Object", "signature": "Object value()", "original_string": "  Object value();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/foreign/ForeignValue.java", "class_name": "ForeignValue", "class_uri": "src/main/java/net/hydromatic/morel/foreign/ForeignValue.java.ForeignValue", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/parse/MorelParser.java.MorelParser.[Pos]pos()", "name": "pos", "arg_nums": 0, "params": [], "return_type": "Pos", "signature": "Pos pos()", "original_string": "  Pos pos();", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/MorelParser.java", "class_name": "MorelParser", "class_uri": "src/main/java/net/hydromatic/morel/parse/MorelParser.java.MorelParser", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Pos", "classes": []}, "docstring": " Returns the position of the last token returned by the parser."}, {"uris": "src/main/java/net/hydromatic/morel/parse/MorelParser.java.MorelParser.[void]zero(String)", "name": "zero", "arg_nums": 1, "params": [{"name": "file", "type": "String"}], "return_type": "void", "signature": "void zero(String file)", "original_string": "  void zero(String file);", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/MorelParser.java", "class_name": "MorelParser", "class_uri": "src/main/java/net/hydromatic/morel/parse/MorelParser.java.MorelParser", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Sets the current file, and sets the current line to zero."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[]Parsers()", "name": "Parsers", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Parsers()", "original_string": "  private Parsers() {\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Parsers.java", "class_name": "Parsers", "class_uri": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[String]unquoteIdentifier(String)", "name": "unquoteIdentifier", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "String", "signature": "public static String unquoteIdentifier(String s)", "original_string": "  public static String unquoteIdentifier(String s) {\n    assert s.charAt(0) == '`';\n    assert s.charAt(s.length() - 1) == '`';\n    return s.substring(1, s.length() - 1)\n        .replace(\"``\", \"`\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Parsers.java", "class_name": "Parsers", "class_uri": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Given quoted identifier {@code `abc`} returns {@code abc}.\nConverts any doubled back-ticks to a single back-tick.\nAssumes there are no single back-ticks."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[String]unquoteString(String)", "name": "unquoteString", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "String", "signature": "public static String unquoteString(String s)", "original_string": "  public static String unquoteString(String s) {\n    assert s.charAt(0) == '\"';\n    assert s.charAt(s.length() - 1) == '\"';\n    return s.substring(1, s.length() - 1)\n        .replace(\"\\\\\\\\\", \"\\\\\")\n        .replace(\"\\\\\\\"\", \"\\\"\");\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Parsers.java", "class_name": "Parsers", "class_uri": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Given quoted string {@code \"abc\"} returns {@code abc}."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[char]unquoteCharLiteral(String)", "name": "unquoteCharLiteral", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "char", "signature": "public static char unquoteCharLiteral(String s)", "original_string": "  public static char unquoteCharLiteral(String s) {\n    assert s.charAt(0) == '#';\n    assert s.charAt(1) == '\"';\n    assert s.charAt(s.length() - 1) == '\"';\n    String image = s.substring(2, s.length() - 1)\n        .replace(\"\\\\\\\\\", \"\\\\\")\n        .replace(\"\\\\\\\"\", \"\\\"\");\n    if (image.length() != 1) {\n      throw new RuntimeException(\"Error: character constant not length 1\");\n    }\n    return image.charAt(0);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Parsers.java", "class_name": "Parsers", "class_uri": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "char", "classes": []}, "docstring": " Given quoted char literal {@code #\"a\"} returns {@code a}."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers.[StringBuilder]appendId(StringBuilder,String)", "name": "appendId", "arg_nums": 2, "params": [{"name": "buf", "type": "StringBuilder"}, {"name": "id", "type": "String"}], "return_type": "StringBuilder", "signature": "public static StringBuilder appendId(StringBuilder buf, String id)", "original_string": "  public static StringBuilder appendId(StringBuilder buf, String id) {\n    if (id.contains(\"`\") || id.contains(\" \")) {\n      return buf.append(\"`\")\n          .append(id.replaceAll(\"`\", \"``\"))\n          .append(\"`\");\n    } else {\n      return buf.append(id);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Parsers.java", "class_name": "Parsers", "class_uri": "src/main/java/net/hydromatic/morel/parse/Parsers.java.Parsers", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "StringBuilder", "classes": []}, "docstring": " Appends an identifier. Encloses it in back-ticks if necessary."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[]Span()", "name": "Span", "arg_nums": 0, "params": [], "return_type": "", "signature": "private Span()", "original_string": "  private Span() {}", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": " Use one of the {@link #of} methods."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of()", "name": "of", "arg_nums": 0, "params": [], "return_type": "Span", "signature": "public static Span of()", "original_string": "  public static Span of() {\n    return new Span();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Creates an empty Span."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of(Pos)", "name": "of", "arg_nums": 1, "params": [{"name": "p", "type": "Pos"}], "return_type": "Span", "signature": "public static Span of(Pos p)", "original_string": "  public static Span of(Pos p) {\n    return new Span().add(p);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Creates a Span with one position."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of(AstNode)", "name": "of", "arg_nums": 1, "params": [{"name": "n", "type": "AstNode"}], "return_type": "Span", "signature": "public static Span of(AstNode n)", "original_string": "  public static Span of(AstNode n) {\n    return new Span().add(n);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Creates a Span of one node."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of(AstNode,AstNode)", "name": "of", "arg_nums": 2, "params": [{"name": "n0", "type": "AstNode"}, {"name": "n1", "type": "AstNode"}], "return_type": "Span", "signature": "public static Span of(AstNode n0, AstNode n1)", "original_string": "  public static Span of(AstNode n0, AstNode n1) {\n    return new Span().add(n0).add(n1);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Creates a Span between two nodes."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]of(Collection<? extends AstNode>)", "name": "of", "arg_nums": 1, "params": [{"name": "nodes", "type": "Collection<? extends AstNode>"}], "return_type": "Span", "signature": "public static Span of(Collection<? extends AstNode> nodes)", "original_string": "  public static Span of(Collection<? extends AstNode> nodes) {\n    return new Span().addAll(nodes);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Creates a Span of a list of nodes."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]add(AstNode)", "name": "add", "arg_nums": 1, "params": [{"name": "n", "type": "AstNode"}], "return_type": "Span", "signature": "public Span add(AstNode n)", "original_string": "  public Span add(AstNode n) {\n    return add(n.pos);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Adds a node's position to the list,\nand returns this Span."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]addIf(AstNode)", "name": "addIf", "arg_nums": 1, "params": [{"name": "n", "type": "AstNode"}], "return_type": "Span", "signature": "public Span addIf(AstNode n)", "original_string": "  public Span addIf(AstNode n) {\n    return n == null ? this : add(n);\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Adds a node's position to the list if the node is not null,\nand returns this Span."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]add(Pos)", "name": "add", "arg_nums": 1, "params": [{"name": "pos", "type": "Pos"}], "return_type": "Span", "signature": "public Span add(Pos pos)", "original_string": "  public Span add(Pos pos) {\n    posList.add(pos);\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Adds a position to the list,\nand returns this Span."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]addAll(Iterable<? extends AstNode>)", "name": "addAll", "arg_nums": 1, "params": [{"name": "nodes", "type": "Iterable<? extends AstNode>"}], "return_type": "Span", "signature": "public Span addAll(Iterable<? extends AstNode> nodes)", "original_string": "  public Span addAll(Iterable<? extends AstNode> nodes) {\n    for (AstNode node : nodes) {\n      add(node);\n    }\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Adds the positions of a collection of nodes to the list,\nand returns this Span."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]add(MorelParser)", "name": "add", "arg_nums": 1, "params": [{"name": "parser", "type": "MorelParser"}], "return_type": "Span", "signature": "public Span add(MorelParser parser)", "original_string": "  public Span add(MorelParser parser) {\n    try {\n      final Pos pos = parser.pos();\n      return add(pos);\n    } catch (Exception e) {\n      // getPos does not really throw an exception\n      throw new AssertionError(e);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Adds the position of the last token emitted by a parser to the list,\nand returns this Span."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Pos]pos()", "name": "pos", "arg_nums": 0, "params": [], "return_type": "Pos", "signature": "public Pos pos()", "original_string": "  public Pos pos() {\n    switch (posList.size()) {\n    case 0:\n      throw new AssertionError();\n    case 1:\n      return posList.get(0);\n    default:\n      return Pos.sum(posList);\n    }\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": " Returns a position spanning the earliest position to the latest.\nDoes not assume that the positions are sorted.\nThrows if the list is empty."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Pos]end(MorelParser)", "name": "end", "arg_nums": 1, "params": [{"name": "parser", "type": "MorelParser"}], "return_type": "Pos", "signature": "public Pos end(MorelParser parser)", "original_string": "  public Pos end(MorelParser parser) {\n    return add(parser).pos();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": " Adds the position of the last token emitted by a parser to the list,\nand returns a position that covers the whole range."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Pos]end(AstNode)", "name": "end", "arg_nums": 1, "params": [{"name": "n", "type": "AstNode"}], "return_type": "Pos", "signature": "public Pos end(AstNode n)", "original_string": "  public Pos end(AstNode n) {\n    return add(n).pos();\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": " Adds a node's position to the list,\nand returns a position that covers the whole range."}, {"uris": "src/main/java/net/hydromatic/morel/parse/Span.java.Span.[Span]clear()", "name": "clear", "arg_nums": 0, "params": [], "return_type": "Span", "signature": "public Span clear()", "original_string": "  public Span clear() {\n    posList.clear();\n    return this;\n  }", "default_arguments": null, "file": "src/main/java/net/hydromatic/morel/parse/Span.java", "class_name": "Span", "class_uri": "src/main/java/net/hydromatic/morel/parse/Span.java.Span", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Span", "classes": []}, "docstring": " Clears the contents of this Span, and returns this Span."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]setTabSize(int)", "name": "setTabSize", "arg_nums": 1, "params": [{"name": "tabSize", "type": "int"}], "return_type": "void", "signature": "public void setTabSize(int tabSize)", "original_string": "  public void setTabSize(int tabSize) {\n    jj_input_stream.setTabSize(tabSize);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pos]pos()", "name": "pos", "arg_nums": 0, "params": [], "return_type": "Pos", "signature": "public Pos pos()", "original_string": "  public Pos pos() {\n    return new Pos(file,\n        token.beginLine - lineOffset, token.beginColumn,\n        token.endLine - lineOffset, token.endColumn + 1);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Pos", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]zero(String)", "name": "zero", "arg_nums": 1, "params": [{"name": "file", "type": "String"}], "return_type": "void", "signature": "public void zero(String file)", "original_string": "  public void zero(String file) {\n    this.file = file;\n    if (jj_input_stream.bufpos >= 0) {\n      this.lineOffset = jj_input_stream.bufline[jj_input_stream.bufpos];\n    }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]debug_message1()", "name": "debug_message1", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void debug_message1()", "original_string": "  void debug_message1() throws ParseException {LOGGER.info(\"{} , {}\", getToken(0).image, getToken(1).image);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]literal()", "name": "literal", "arg_nums": 0, "params": [], "return_type": "Literal", "signature": "final public Literal literal()", "original_string": "  final public Literal literal() throws ParseException {final Ast.Literal e;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:{\n      e = numericLiteral();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case QUOTED_STRING:{\n      e = stringLiteral();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case CHAR_LITERAL:{\n      e = charLiteral();\n{if (\"\" != null) return e;}\n      break;\n      }\n    default:\n      jj_la1[0] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Literal", "classes": []}, "docstring": " Parses a literal expression."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]literalEof()", "name": "literalEof", "arg_nums": 0, "params": [], "return_type": "Literal", "signature": "final public Literal literalEof()", "original_string": "  final public Literal literalEof() throws ParseException {final Literal n;\n    n = literal();\n    jj_consume_token(0);\n{if (\"\" != null) return n;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Literal", "classes": []}, "docstring": " Parses a literal expression followed by end-of-file."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]numericLiteral()", "name": "numericLiteral", "arg_nums": 0, "params": [], "return_type": "Literal", "signature": "final public Literal numericLiteral()", "original_string": "  final public Literal numericLiteral() throws ParseException {final BigDecimal d;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:{\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case NON_NEGATIVE_INTEGER_LITERAL:{\n        jj_consume_token(NON_NEGATIVE_INTEGER_LITERAL);\n        break;\n        }\n      case NEGATIVE_INTEGER_LITERAL:{\n        jj_consume_token(NEGATIVE_INTEGER_LITERAL);\n        break;\n        }\n      default:\n        jj_la1[1] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\nif (token.image.startsWith(\"~\")) {\n      d = new BigDecimal(token.image.substring(1)).negate();\n    } else {\n      d = new BigDecimal(token.image);\n    }\n    {if (\"\" != null) return ast.intLiteral(pos(), d);}\n      break;\n      }\n    case REAL_LITERAL:{\n      jj_consume_token(REAL_LITERAL);\nif (token.image.startsWith(\"~\")) {\n      d = new BigDecimal(token.image.substring(1)).negate();\n      if (d.compareTo(BigDecimal.ZERO) == 0) {\n        // In IEEE floating point, and ML's 'real' type, negative zero is\n        // different from positive zero.\n        {if (\"\" != null) return ast.realLiteral(pos(), -0.f);}\n      }\n    } else {\n      d = new BigDecimal(token.image);\n    }\n    {if (\"\" != null) return ast.realLiteral(pos(), d);}\n      break;\n      }\n    case SCIENTIFIC_LITERAL:{\n      jj_consume_token(SCIENTIFIC_LITERAL);\nfinal int e = Math.max(token.image.indexOf(\"e\"),\n      token.image.indexOf(\"E\"));\n    if (token.image.startsWith(\"~\")) {\n      d = new BigDecimal(token.image.substring(1, e)).negate();\n      if (d.compareTo(BigDecimal.ZERO) == 0) {\n        // In IEEE floating point, and ML's 'real' type, negative zero is\n        // different from positive zero.\n        {if (\"\" != null) return ast.realLiteral(pos(), -0.f);}\n      }\n    } else {\n      d = new BigDecimal(token.image.substring(0, e));\n    }\n    final int exponent;\n    if (token.image.startsWith(\"~\", e + 1)) {\n      exponent = -Integer.parseInt(token.image.substring(e + 2));\n    } else {\n      exponent = Integer.parseInt(token.image.substring(e + 1));\n    }\n    {if (\"\" != null) return ast.realLiteral(pos(), d.scaleByPowerOfTen(exponent));}\n      break;\n      }\n    default:\n      jj_la1[2] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Literal", "classes": []}, "docstring": " Parses a numeric literal"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]stringLiteral()", "name": "stringLiteral", "arg_nums": 0, "params": [], "return_type": "Literal", "signature": "final public Literal stringLiteral()", "original_string": "  final public Literal stringLiteral() throws ParseException {\n    jj_consume_token(QUOTED_STRING);\n{if (\"\" != null) return ast.stringLiteral(pos(), unquoteString(token.image));}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Literal", "classes": []}, "docstring": " Parses a string literal."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Literal]charLiteral()", "name": "charLiteral", "arg_nums": 0, "params": [], "return_type": "Literal", "signature": "final public Literal charLiteral()", "original_string": "  final public Literal charLiteral() throws ParseException {\n    jj_consume_token(CHAR_LITERAL);\n{if (\"\" != null) return ast.charLiteral(pos(), unquoteCharLiteral(token.image));}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Literal", "classes": []}, "docstring": " Parses a char literal."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Id]identifier()", "name": "identifier", "arg_nums": 0, "params": [], "return_type": "Id", "signature": "final public Id identifier()", "original_string": "  final public Id identifier() throws ParseException {\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:{\n      jj_consume_token(IDENTIFIER);\n{if (\"\" != null) return ast.id(pos(), token.image);}\n      break;\n      }\n    case QUOTED_IDENTIFIER:{\n      jj_consume_token(QUOTED_IDENTIFIER);\n{if (\"\" != null) return ast.id(pos(), unquoteIdentifier(token.image));}\n      break;\n      }\n    default:\n      jj_la1[3] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Id", "classes": []}, "docstring": " Parses an identifier."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[RecordSelector]recordSelector()", "name": "recordSelector", "arg_nums": 0, "params": [], "return_type": "RecordSelector", "signature": "final public RecordSelector recordSelector()", "original_string": "  final public RecordSelector recordSelector() throws ParseException {\n    jj_consume_token(LABEL);\nassert token.image.startsWith(\"#\");\n    {if (\"\" != null) return ast.recordSelector(pos(), token.image.substring(1));}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "RecordSelector", "classes": []}, "docstring": " Parses a record selector, e.g. \"{@code #empno}\".\n\n<p>You use it as a function to extract a field of a record;\nfor example <code>#empno {empno=10, name=\"Fred\"}</code>\nyields {@code 10}."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[TyVar]tyVar()", "name": "tyVar", "arg_nums": 0, "params": [], "return_type": "TyVar", "signature": "final public TyVar tyVar()", "original_string": "  final public TyVar tyVar() throws ParseException {\n    jj_consume_token(TY_VAR);\nassert token.image.startsWith(\"'\");\n    {if (\"\" != null) return ast.tyVar(pos(), token.image);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "TyVar", "classes": []}, "docstring": " Parses a type variable, e.g. \"{@code 'a}\"."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[List<TyVar>]tyVarOptionalList()", "name": "tyVarOptionalList", "arg_nums": 0, "params": [], "return_type": "List<TyVar>", "signature": "final public List<TyVar> tyVarOptionalList()", "original_string": "  final public List<TyVar> tyVarOptionalList() throws ParseException {TyVar tyVar;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case TY_VAR:{\n      tyVar = tyVar();\n{if (\"\" != null) return ImmutableList.of(tyVar);}\n      break;\n      }\n    case LPAREN:{\n      jj_consume_token(LPAREN);\nList<TyVar> tyVars = new ArrayList<>();\n      tyVar = tyVar();\ntyVars.add(tyVar);\n      label_1:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case COMMA:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[4] = jj_gen;\n          break label_1;\n        }\n        jj_consume_token(COMMA);\n        tyVar = tyVar();\ntyVars.add(tyVar);\n      }\n{if (\"\" != null) return tyVars;}\n      break;\n      }\n    default:\n      jj_la1[5] = jj_gen;\n{if (\"\" != null) return ImmutableList.of();}\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "List<TyVar>", "classes": []}, "docstring": " Parses a type variable, or a list of 1 or more type variables in\n parentheses, or empty. Valid examples: \"\", \"'a\", \"('a)\", \"('a, 'b)\"."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[RecordType]recordType()", "name": "recordType", "arg_nums": 0, "params": [], "return_type": "RecordType", "signature": "final public RecordType recordType()", "original_string": "  final public RecordType recordType() throws ParseException {final Span span;\n    jj_consume_token(LBRACE);\nspan = Span.of(pos());\n  final Map<String, Type> map = new LinkedHashMap<>();\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      fieldType(map);\n      label_2:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case COMMA:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[6] = jj_gen;\n          break label_2;\n        }\n        jj_consume_token(COMMA);\n        fieldType(map);\n      }\n      break;\n      }\n    default:\n      jj_la1[7] = jj_gen;\n      ;\n    }\n    jj_consume_token(RBRACE);\n{if (\"\" != null) return ast.recordType(span.end(this), map);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "RecordType", "classes": []}, "docstring": " Parses a record type, e.g. \"{@code {a:int,b:string} }\"."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]fieldType(Map<String, Type>)", "name": "fieldType", "arg_nums": 1, "params": [{"name": "map", "type": "Map<String, Type>"}], "return_type": "void", "signature": "final public void fieldType(Map<String, Type> map)", "original_string": "  final public void fieldType(Map<String, Type> map) throws ParseException {final Id id;\n  final Type type;\n    id = identifier();\n    jj_consume_token(COLON);\n    type = type();\nmap.put(id.name, type);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]ifThenElse()", "name": "ifThenElse", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp ifThenElse()", "original_string": "  final public Exp ifThenElse() throws ParseException {final Span span;\n  final Exp condition;\n  final Exp ifTrue;\n  final Exp ifFalse;\n    jj_consume_token(IF);\nspan = Span.of(pos());\n    condition = expression();\n    jj_consume_token(THEN);\n    ifTrue = expression();\n    jj_consume_token(ELSE);\n    ifFalse = expression();\n{if (\"\" != null) return ast.ifThenElse(span.end(this), condition, ifTrue, ifFalse);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses a \"if ... then ... else ...\" expression."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]let()", "name": "let", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp let()", "original_string": "  final public Exp let() throws ParseException {final Span span;\n  final Exp e;\n  Decl decl;\n  final List<Decl> declList = new ArrayList<>();\n    jj_consume_token(LET);\nspan = Span.of(pos());\n    label_3:\n    while (true) {\n      decl = decl();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case SEMICOLON:{\n        jj_consume_token(SEMICOLON);\n        break;\n        }\n      default:\n        jj_la1[8] = jj_gen;\n        ;\n      }\ndeclList.add(decl);\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case DATATYPE:\n      case FUN:\n      case VAL:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[9] = jj_gen;\n        break label_3;\n      }\n    }\n    jj_consume_token(IN);\n    e = expression();\n    jj_consume_token(END);\n{if (\"\" != null) return ast.let(span.end(this), declList, e);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses a \"let ... in expression end\" expression."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]caseOf()", "name": "caseOf", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp caseOf()", "original_string": "  final public Exp caseOf() throws ParseException {final Span span;\n  final Exp exp;\n  final List<Match> matchList;\n    jj_consume_token(CASE);\nspan = Span.of(pos());\n    exp = expression();\n    jj_consume_token(OF);\n    matchList = matchList();\n{if (\"\" != null) return ast.caseOf(span.end(this), exp, matchList);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses a \"{@code case exp of pat => exp | pat => exp}\" expression."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]from()", "name": "from", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp from()", "original_string": "  final public Exp from() throws ParseException {final Span span;\n  Span stepSpan;\n  final List<FromStep> steps = new ArrayList<>();\n    jj_consume_token(FROM);\nspan = Span.of(pos());\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case 1:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      fromFirstScan(steps);\n      label_4:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case COMMA:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[10] = jj_gen;\n          break label_4;\n        }\n        jj_consume_token(COMMA);\n        fromScan(steps);\n      }\n      break;\n      }\n    default:\n      jj_la1[11] = jj_gen;\n      ;\n    }\n    label_5:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMPUTE:\n      case GROUP:\n      case INTO:\n      case JOIN:\n      case ORDER:\n      case SKIP_:\n      case TAKE:\n      case THROUGH:\n      case WHERE:\n      case YIELD:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[12] = jj_gen;\n        break label_5;\n      }\n      fromStep(steps);\n    }\n{if (\"\" != null) return ast.from(span.end(this), steps);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses a \"{@code from id in exp yield exp}\" expression."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]fromFirstScan(List<FromStep>)", "name": "fromFirstScan", "arg_nums": 1, "params": [{"name": "steps", "type": "List<FromStep>"}], "return_type": "void", "signature": "final public void fromFirstScan(List<FromStep> steps)", "original_string": "  final public void fromFirstScan(List<FromStep> steps) throws ParseException {final Pair<Pat, Exp> patExp;\n    patExp = fromSource();\nfinal Span span =\n        patExp.right != null\n          ? Span.of(patExp.left, patExp.right)\n          : Span.of(patExp.left);\n    steps.add(ast.scan(span.pos(), patExp.left, patExp.right, null));\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]fromScan(List<FromStep>)", "name": "fromScan", "arg_nums": 1, "params": [{"name": "steps", "type": "List<FromStep>"}], "return_type": "void", "signature": "final public void fromScan(List<FromStep> steps)", "original_string": "  final public void fromScan(List<FromStep> steps) throws ParseException {final Pair<Pat, Exp> patExp;\n  final Exp condition;\n    patExp = fromSource();\nfinal Span span =\n        patExp.right != null\n          ? Span.of(patExp.left, patExp.right)\n          : Span.of(patExp.left);\n    if (jj_2_1(2)) {\n      jj_consume_token(ON);\n      condition = expression();\n    } else {\ncondition = null;\n    }\nsteps.add(ast.scan(span.end(this), patExp.left, patExp.right, condition));\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]fromStep(List<FromStep>)", "name": "fromStep", "arg_nums": 1, "params": [{"name": "steps", "type": "List<FromStep>"}], "return_type": "void", "signature": "final public void fromStep(List<FromStep> steps)", "original_string": "  final public void fromStep(List<FromStep> steps) throws ParseException {final Span span;\n  final Op op;\n  final Exp filterExp;\n  final Exp intoExp;\n  final Exp skipExp;\n  final Exp throughExp;\n  final Exp takeExp;\n  final Exp yieldExp;\n  final PairList<Id, Exp> groupExps;\n  final Pat pat;\n  final List<Aggregate> aggregates;\n  final List<OrderItem> orderItems;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case JOIN:{\n      jj_consume_token(JOIN);\n      fromScan(steps);\n      label_6:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case COMMA:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[13] = jj_gen;\n          break label_6;\n        }\n        jj_consume_token(COMMA);\n        fromScan(steps);\n      }\n      break;\n      }\n    case WHERE:{\n      jj_consume_token(WHERE);\nspan = Span.of(pos());\n      filterExp = expression();\nsteps.add(ast.where(span.end(this), filterExp));\n      break;\n      }\n    case GROUP:{\n      jj_consume_token(GROUP);\nspan = Span.of(pos());\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        groupExps = namedExpressionCommaList();\n        break;\n        }\n      default:\n        jj_la1[14] = jj_gen;\ngroupExps = ImmutablePairList.of();\n      }\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMPUTE:{\n        jj_consume_token(COMPUTE);\n        aggregates = aggregateCommaList();\n        break;\n        }\n      default:\n        jj_la1[15] = jj_gen;\naggregates = ImmutableList.of();\n      }\nsteps.add(ast.group(span.end(this), groupExps, aggregates));\n      break;\n      }\n    case COMPUTE:{\n      jj_consume_token(COMPUTE);\nspan = Span.of(pos());\n      aggregates = aggregateCommaList();\nsteps.add(ast.compute(span.end(this), aggregates));\n      break;\n      }\n    case INTO:{\n      jj_consume_token(INTO);\nspan = Span.of(pos());\n      intoExp = expression();\nsteps.add(ast.into(span.end(this), intoExp));\n      break;\n      }\n    case ORDER:{\n      jj_consume_token(ORDER);\nspan = Span.of(pos());\n      orderItems = orderItemCommaList();\nsteps.add(ast.order(span.end(this), orderItems));\n      break;\n      }\n    case SKIP_:{\n      jj_consume_token(SKIP_);\nspan = Span.of(pos());\n      skipExp = expression();\nsteps.add(ast.skip(span.end(this), skipExp));\n      break;\n      }\n    case TAKE:{\n      jj_consume_token(TAKE);\nspan = Span.of(pos());\n      takeExp = expression();\nsteps.add(ast.take(span.end(this), takeExp));\n      break;\n      }\n    case THROUGH:{\n      jj_consume_token(THROUGH);\nspan = Span.of(pos());\n      pat = pat();\n      jj_consume_token(IN);\n      throughExp = expression();\nsteps.add(ast.through(span.end(this), pat, throughExp));\n      break;\n      }\n    case YIELD:{\n      jj_consume_token(YIELD);\nspan = Span.of(pos());\n      yieldExp = expression();\nsteps.add(ast.yield(span.end(this), yieldExp));\n      break;\n      }\n    default:\n      jj_la1[16] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pair<Pat, Exp>]fromSource()", "name": "fromSource", "arg_nums": 0, "params": [], "return_type": "Pair<Pat, Exp>", "signature": "final public Pair<Pat, Exp> fromSource()", "original_string": "  final public Pair<Pat, Exp> fromSource() throws ParseException {final Id id;\n  final Exp exp;\n  final Pat pat;\n    if (jj_2_2(2147483647)) {\n      id = identifier();\n{if (\"\" != null) return Pair.of(ast.idPat(id.pos, id.name), null);}\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        pat = pat();\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case IN:{\n          jj_consume_token(IN);\n          exp = expression();\n{if (\"\" != null) return Pair.of(pat, exp);}\n          break;\n          }\n        case EQ:{\n          jj_consume_token(EQ);\n          exp = expression();\n{if (\"\" != null) return Pair.of(pat, ast.fromEq(exp));}\n          break;\n          }\n        default:\n          jj_la1[17] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n        }\n      default:\n        jj_la1[18] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Pair<Pat, Exp>", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[List<Aggregate>]aggregateCommaList()", "name": "aggregateCommaList", "arg_nums": 0, "params": [], "return_type": "List<Aggregate>", "signature": "final public List<Aggregate> aggregateCommaList()", "original_string": "  final public List<Aggregate> aggregateCommaList() throws ParseException {final List<Aggregate> list = new ArrayList<>();\n  Aggregate e;\n    e = aggregate();\nlist.add(e);\n    label_7:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMMA:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[19] = jj_gen;\n        break label_7;\n      }\n      jj_consume_token(COMMA);\n      e = aggregate();\nlist.add(e);\n    }\n{if (\"\" != null) return list;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "List<Aggregate>", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Aggregate]aggregate()", "name": "aggregate", "arg_nums": 0, "params": [], "return_type": "Aggregate", "signature": "final public Aggregate aggregate()", "original_string": "  final public Aggregate aggregate() throws ParseException {final PairList<Id, Exp> aggregateIds = PairList.of();\n  final Exp argument;\n    namedExpression(aggregateIds);\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case OF:{\n      jj_consume_token(OF);\n      argument = expression();\n      break;\n      }\n    default:\n      jj_la1[20] = jj_gen;\nargument = null;\n    }\nfinal Id id = aggregateIds.get(0).getKey();\n    final Exp aggregate = aggregateIds.get(0).getValue();\n    {if (\"\" != null) return ast.aggregate(id.pos.plus(pos()), aggregate, argument, id);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Aggregate", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[List<OrderItem>]orderItemCommaList()", "name": "orderItemCommaList", "arg_nums": 0, "params": [], "return_type": "List<OrderItem>", "signature": "final public List<OrderItem> orderItemCommaList()", "original_string": "  final public List<OrderItem> orderItemCommaList() throws ParseException {final List<OrderItem> list = new ArrayList<>();\n  OrderItem i;\n    i = orderItem();\nlist.add(i);\n    label_8:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMMA:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[21] = jj_gen;\n        break label_8;\n      }\n      jj_consume_token(COMMA);\n      i = orderItem();\nlist.add(i);\n    }\n{if (\"\" != null) return list;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "List<OrderItem>", "classes": []}, "docstring": " List of order items \"e1 desc, e2, e3 desc\"."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[OrderItem]orderItem()", "name": "orderItem", "arg_nums": 0, "params": [], "return_type": "OrderItem", "signature": "final public OrderItem orderItem()", "original_string": "  final public OrderItem orderItem() throws ParseException {final Span span;\n  final Exp exp;\n    exp = expression();\nspan = Span.of(pos());\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case DESC:{\n      jj_consume_token(DESC);\n{if (\"\" != null) return ast.orderItem(span.end(this), exp, Ast.Direction.DESC);}\n      break;\n      }\n    default:\n      jj_la1[22] = jj_gen;\n{if (\"\" != null) return ast.orderItem(span.end(this), exp, Ast.Direction.ASC);}\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "OrderItem", "classes": []}, "docstring": " Order item. An expression optionally followed by \"desc\"."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]fn()", "name": "fn", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp fn()", "original_string": "  final public Exp fn() throws ParseException {final Span span;\n  final Match match;\n    jj_consume_token(FN);\nspan = Span.of(pos());\n    match = match();\n{if (\"\" != null) return ast.fn(span.end(this), match);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses a \"{@code fn arg => expression}\" lambda expression."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[List<Match>]matchList()", "name": "matchList", "arg_nums": 0, "params": [], "return_type": "List<Match>", "signature": "final public List<Match> matchList()", "original_string": "  final public List<Match> matchList() throws ParseException {Match match;\n  final List<Match> matchList = new ArrayList<>();\n    match = match();\nmatchList.add(match);\n    label_9:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case BAR:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[23] = jj_gen;\n        break label_9;\n      }\n      jj_consume_token(BAR);\n      match = match();\nmatchList.add(match);\n    }\n{if (\"\" != null) return matchList;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "List<Match>", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Match]match()", "name": "match", "arg_nums": 0, "params": [], "return_type": "Match", "signature": "final public Match match()", "original_string": "  final public Match match() throws ParseException {final Pat pat;\n  final Exp e;\n    pat = pat();\n    jj_consume_token(RARROW);\n    e = expression();\n{if (\"\" != null) return ast.match(pat.pos.plus(e.pos), pat, e);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Match", "classes": []}, "docstring": " Parses a \"{@code pat => expression}\" match."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression9()", "name": "expression9", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression9()", "original_string": "  final public Exp expression9() throws ParseException {Exp e;\n  Id id;\n    e = atom();\n    label_10:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case DOT:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[24] = jj_gen;\n        break label_10;\n      }\n      jj_consume_token(DOT);\n      id = identifier();\nfinal Exp s = ast.recordSelector(pos(), id.name);\n      e = ast.apply(s, e);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an expression.\n\n<p>8 is the highest level of precedence in standard ML,\nand the '.field' extension is at level 9.\nThe full list is as follows:\n\n<ul>\n<li>infix 9 {@code .}\n<li>infix 8 (application)\n<li>infix 7 {@code * / div mod intersect}\n<li>infix 6 {@code + - ^ union except}\n<li>infixr 5 {@code :: @}\n<li>infix 4 {@code = <> > >= < <=}\n<li>infix 3 {@code := o}\n<li>infix 0 {@code before}\n</ul>\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression8()", "name": "expression8", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression8()", "original_string": "  final public Exp expression8() throws ParseException {Exp e;\n  Exp e2;\n    e = expression9();\n    label_11:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[25] = jj_gen;\n        break label_11;\n      }\n      e2 = expression9();\ne = ast.apply(e, e2);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an expression of precedence level 8 (function application)."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression7()", "name": "expression7", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression7()", "original_string": "  final public Exp expression7() throws ParseException {Exp e;\n  Exp e2;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case TILDE:{\n      jj_consume_token(TILDE);\n      e = expression7();\n{if (\"\" != null) return ast.negate(pos(), e);}\n      break;\n      }\n    case CASE:\n    case FN:\n    case IF:\n    case LET:\n    case FROM:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:\n    case LABEL:{\n      e = expression8();\n      label_12:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case DIV:\n        case INTERSECT:\n        case MOD:\n        case STAR:\n        case SLASH:{\n          ;\n          break;\n          }\n        default:\n          jj_la1[26] = jj_gen;\n          break label_12;\n        }\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case STAR:{\n          jj_consume_token(STAR);\n          e2 = expression8();\ne = ast.times(e, e2);\n          break;\n          }\n        case SLASH:{\n          jj_consume_token(SLASH);\n          e2 = expression8();\ne = ast.divide(e, e2);\n          break;\n          }\n        case DIV:{\n          jj_consume_token(DIV);\n          e2 = expression8();\ne = ast.div(e, e2);\n          break;\n          }\n        case INTERSECT:{\n          jj_consume_token(INTERSECT);\n          e2 = expression8();\ne = ast.intersect(e, e2);\n          break;\n          }\n        case MOD:{\n          jj_consume_token(MOD);\n          e2 = expression8();\ne = ast.mod(e, e2);\n          break;\n          }\n        default:\n          jj_la1[27] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n      }\n{if (\"\" != null) return e;}\n      break;\n      }\n    default:\n      jj_la1[28] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an expression of precedence level 7 (*, /, div, mod)."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression6()", "name": "expression6", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression6()", "original_string": "  final public Exp expression6() throws ParseException {Exp e;\n  Exp e2;\n    e = expression7();\n    label_13:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case EXCEPT:\n      case UNION:\n      case PLUS:\n      case MINUS:\n      case CARET:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[29] = jj_gen;\n        break label_13;\n      }\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case PLUS:{\n        jj_consume_token(PLUS);\n        e2 = expression7();\ne = ast.plus(e, e2);\n        break;\n        }\n      case MINUS:{\n        jj_consume_token(MINUS);\n        e2 = expression7();\ne = ast.minus(e, e2);\n        break;\n        }\n      case CARET:{\n        jj_consume_token(CARET);\n        e2 = expression7();\ne = ast.caret(e, e2);\n        break;\n        }\n      case EXCEPT:{\n        jj_consume_token(EXCEPT);\n        e2 = expression7();\ne = ast.except(e, e2);\n        break;\n        }\n      case UNION:{\n        jj_consume_token(UNION);\n        e2 = expression7();\ne = ast.union(e, e2);\n        break;\n        }\n      default:\n        jj_la1[30] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an expression of precedence level 6 (+, -, ^, except, union)."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression5()", "name": "expression5", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression5()", "original_string": "  final public Exp expression5() throws ParseException {Exp e;\n  final List<Folder<Exp>> list = new ArrayList<>();\n    e = expression6();\nFolder.start(list, e);\n    label_14:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CONS:\n      case AT:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[31] = jj_gen;\n        break label_14;\n      }\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AT:{\n        jj_consume_token(AT);\n        e = expression6();\nFolder.at(list, e);\n        break;\n        }\n      case CONS:{\n        jj_consume_token(CONS);\n        e = expression6();\nFolder.cons(list, e);\n        break;\n        }\n      default:\n        jj_la1[32] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n{if (\"\" != null) return Folder.combineAll(list);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an expression of precedence level 5 ({@code ::}),\nright-associative."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression4()", "name": "expression4", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression4()", "original_string": "  final public Exp expression4() throws ParseException {Exp e;\n  Exp e2;\n    e = expression5();\n    label_15:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ELEM:\n      case NOT_ELEM:\n      case EQ:\n      case GT:\n      case LT:\n      case LE:\n      case GE:\n      case NE:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[33] = jj_gen;\n        break label_15;\n      }\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case EQ:{\n        jj_consume_token(EQ);\n        e2 = expression5();\ne = ast.equal(e, e2);\n        break;\n        }\n      case NE:{\n        jj_consume_token(NE);\n        e2 = expression5();\ne = ast.notEqual(e, e2);\n        break;\n        }\n      case LT:{\n        jj_consume_token(LT);\n        e2 = expression5();\ne = ast.lessThan(e, e2);\n        break;\n        }\n      case GT:{\n        jj_consume_token(GT);\n        e2 = expression5();\ne = ast.greaterThan(e, e2);\n        break;\n        }\n      case LE:{\n        jj_consume_token(LE);\n        e2 = expression5();\ne = ast.lessThanOrEqual(e, e2);\n        break;\n        }\n      case GE:{\n        jj_consume_token(GE);\n        e2 = expression5();\ne = ast.greaterThanOrEqual(e, e2);\n        break;\n        }\n      case ELEM:{\n        jj_consume_token(ELEM);\n        e2 = expression5();\ne = ast.elem(e, e2);\n        break;\n        }\n      case NOT_ELEM:{\n        jj_consume_token(NOT_ELEM);\n        e2 = expression5();\ne = ast.notElem(e, e2);\n        break;\n        }\n      default:\n        jj_la1[34] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an expression of precedence level 4 ({@code =}, {@code <>},\n{@code >}, {@code >=}, {@code <}, {@code <=})."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression3()", "name": "expression3", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression3()", "original_string": "  final public Exp expression3() throws ParseException {Exp e;\n  Exp e2;\n    e = expression4();\n    label_16:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case O:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[35] = jj_gen;\n        break label_16;\n      }\n      jj_consume_token(O);\n      e2 = expression4();\ne = ast.o(e, e2);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an expression of precedence level 3 (o)."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression2()", "name": "expression2", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression2()", "original_string": "  final public Exp expression2() throws ParseException {Exp e;\n  Exp e2;\n    e = expression3();\n    label_17:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ANDALSO:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[36] = jj_gen;\n        break label_17;\n      }\n      jj_consume_token(ANDALSO);\n      e2 = expression3();\ne = ast.andAlso(e, e2);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an expression of precedence level 2 (andalso)."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression1()", "name": "expression1", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression1()", "original_string": "  final public Exp expression1() throws ParseException {Exp e;\n  Exp e2;\n    e = expression2();\n    label_18:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case ORELSE:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[37] = jj_gen;\n        break label_18;\n      }\n      jj_consume_token(ORELSE);\n      e2 = expression2();\ne = ast.orElse(e, e2);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an expression of precedence level 1 (orelse)."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]expression()", "name": "expression", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp expression()", "original_string": "  final public Exp expression() throws ParseException {Exp e;\n  Type t;\n    e = expression1();\n    label_19:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COLON:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[38] = jj_gen;\n        break label_19;\n      }\n      jj_consume_token(COLON);\n      t = type();\ne = ast.annotatedExp(e.pos.plus(t.pos), e, t);\n    }\n{if (\"\" != null) return e;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[PairList<Id, Exp>]namedExpressionCommaList()", "name": "namedExpressionCommaList", "arg_nums": 0, "params": [], "return_type": "PairList<Id, Exp>", "signature": "final public PairList<Id, Exp> namedExpressionCommaList()", "original_string": "  final public PairList<Id, Exp> namedExpressionCommaList() throws ParseException {final PairList<Id, Exp> list = PairList.of();\n  Pair<Id, Exp> p;\n    namedExpression(list);\n    label_20:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COMMA:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[39] = jj_gen;\n        break label_20;\n      }\n      jj_consume_token(COMMA);\n      namedExpression(list);\n    }\n{if (\"\" != null) return list;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "PairList<Id, Exp>", "classes": []}, "docstring": " List of expressions \"e1 as id1, e2 as id2, e3 as id3\"."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]namedExpression(PairList<Id, Exp>)", "name": "namedExpression", "arg_nums": 1, "params": [{"name": "list", "type": "PairList<Id, Exp>"}], "return_type": "void", "signature": "final public void namedExpression(PairList<Id, Exp> list)", "original_string": "  final public void namedExpression(PairList<Id, Exp> list) throws ParseException {final Exp exp;\n  final Id id;\n    if (jj_2_3(2147483647)) {\n      id = identifier();\n      jj_consume_token(EQ);\n      exp = expression();\nlist.add(id, exp);\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        exp = expression();\nfinal String name = ast.implicitLabel(exp);\n    list.add(ast.id(exp.pos, name), exp);\n        break;\n        }\n      default:\n        jj_la1[40] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Expression with optional \"id =\", e.g. \"id1 = e1\";\n\"#deptno e\" and \"e.deptno\" are equivalent to \"deptno = e.deptno\";\n\"x\" is equivalent to \"x = x\"."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Exp]atom()", "name": "atom", "arg_nums": 0, "params": [], "return_type": "Exp", "signature": "final public Exp atom()", "original_string": "  final public Exp atom() throws ParseException {final Exp e;\n  final Span span;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      e = identifier();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case LABEL:{\n      e = recordSelector();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:{\n      e = literal();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case LET:{\n      e = let();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case FN:{\n      e = fn();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case IF:{\n      e = ifThenElse();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case CASE:{\n      e = caseOf();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case FROM:{\n      e = from();\n{if (\"\" != null) return e;}\n      break;\n      }\n    case LPAREN:{\n      jj_consume_token(LPAREN);\nspan = Span.of(pos());\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case RPAREN:{\n        jj_consume_token(RPAREN);\n{if (\"\" != null) return ast.unitLiteral(span.end(this));}\n        break;\n        }\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        e = expression();\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case RPAREN:{\n          jj_consume_token(RPAREN);\n{if (\"\" != null) return e;}\n          break;\n          }\n        case COMMA:{\nfinal List<Exp> list = new ArrayList<>();\n        list.add(e);\n        Exp e2;\n          label_21:\n          while (true) {\n            jj_consume_token(COMMA);\n            e2 = expression();\nlist.add(e2);\n            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n            case COMMA:{\n              ;\n              break;\n              }\n            default:\n              jj_la1[41] = jj_gen;\n              break label_21;\n            }\n          }\n          jj_consume_token(RPAREN);\n{if (\"\" != null) return ast.tuple(span.end(this), list);}\n          break;\n          }\n        default:\n          jj_la1[42] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n        }\n      default:\n        jj_la1[43] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n      break;\n      }\n    case LBRACKET:{\n      jj_consume_token(LBRACKET);\nspan = Span.of(pos());\n    final List<Exp> list = new ArrayList<>();\n    Exp e2;\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        e2 = expression();\nlist.add(e2);\n        label_22:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[44] = jj_gen;\n            break label_22;\n          }\n          jj_consume_token(COMMA);\n          e2 = expression();\nlist.add(e2);\n        }\n        break;\n        }\n      default:\n        jj_la1[45] = jj_gen;\n        ;\n      }\n      jj_consume_token(RBRACKET);\n{if (\"\" != null) return ast.list(span.end(this), list);}\n      break;\n      }\n    case LBRACE:{\n      jj_consume_token(LBRACE);\nspan = Span.of(pos());\n    final PairList<String, Exp> nameExps = PairList.of();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        recordExp(nameExps);\n        label_23:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[46] = jj_gen;\n            break label_23;\n          }\n          jj_consume_token(COMMA);\n          recordExp(nameExps);\n        }\n        break;\n        }\n      default:\n        jj_la1[47] = jj_gen;\n        ;\n      }\n      jj_consume_token(RBRACE);\n{if (\"\" != null) return ast.record(span.end(this), nameExps);}\n      break;\n      }\n    default:\n      jj_la1[48] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Exp", "classes": []}, "docstring": " Parses an atomic expression."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]recordExp(PairList<String, Exp>)", "name": "recordExp", "arg_nums": 1, "params": [{"name": "nameExps", "type": "PairList<String, Exp>"}], "return_type": "void", "signature": "final public void recordExp(PairList<String, Exp> nameExps)", "original_string": "  final public void recordExp(PairList<String, Exp> nameExps) throws ParseException {final String id;\n  final Ast.Exp exp;\n    if (jj_2_4(2147483647)) {\n      jj_consume_token(NON_NEGATIVE_INTEGER_LITERAL);\nid = token.image;\n      jj_consume_token(EQ);\n      exp = expression();\nnameExps.add(id, exp);\n    } else if (jj_2_5(2147483647)) {\n      jj_consume_token(IDENTIFIER);\nid = token.image;\n      jj_consume_token(EQ);\n      exp = expression();\nnameExps.add(id, exp);\n    } else if (jj_2_6(2147483647)) {\n      jj_consume_token(QUOTED_IDENTIFIER);\nid = unquoteIdentifier(token.image);\n      jj_consume_token(EQ);\n      exp = expression();\nnameExps.add(id, exp);\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CASE:\n      case FN:\n      case IF:\n      case LET:\n      case FROM:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case TILDE:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:\n      case LABEL:{\n        exp = expression();\nfinal String label = ast.implicitLabel(exp);\n    nameExps.add(label, exp);\n        break;\n        }\n      default:\n        jj_la1[49] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n    }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Parses a \"label = expression\" inside a record."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]addValDecl(List)", "name": "addValDecl", "arg_nums": 1, "params": [{"name": "decls", "type": "List"}], "return_type": "void", "signature": "final public void addValDecl(List decls)", "original_string": "  final public void addValDecl(List decls) throws ParseException {final ValDecl decl;\n    decl = valDecl();\ndecls.add(decl);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Parses a value declaration, and adds it to a list."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[ValDecl]valDecl()", "name": "valDecl", "arg_nums": 0, "params": [], "return_type": "ValDecl", "signature": "final public ValDecl valDecl()", "original_string": "  final public ValDecl valDecl() throws ParseException {final Span span;\n  boolean rec = false;\n  final List<Ast.ValBind> valBinds = new ArrayList<>();\n    jj_consume_token(VAL);\nspan = Span.of(pos());\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case REC:{\n      jj_consume_token(REC);\nrec = true;\n      break;\n      }\n    default:\n      jj_la1[50] = jj_gen;\n      ;\n    }\n    valBind(valBinds);\n    label_24:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AND:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[51] = jj_gen;\n        break label_24;\n      }\n      jj_consume_token(AND);\n      valBind(valBinds);\n    }\n{if (\"\" != null) return ast.valDecl(span.end(this), rec, valBinds);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "ValDecl", "classes": []}, "docstring": " Parses a value declaration."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]valBind(List<Ast.ValBind>)", "name": "valBind", "arg_nums": 1, "params": [{"name": "valBinds", "type": "List<Ast.ValBind>"}], "return_type": "void", "signature": "final public void valBind(List<Ast.ValBind> valBinds)", "original_string": "  final public void valBind(List<Ast.ValBind> valBinds) throws ParseException {final Pat pat;\n  final Exp e;\n    pat = pat();\n    jj_consume_token(EQ);\n    e = expression();\nvalBinds.add(ast.valBind(pat.pos.plus(e.pos), pat, e));\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Decl]decl()", "name": "decl", "arg_nums": 0, "params": [], "return_type": "Ast.Decl", "signature": "final public Ast.Decl decl()", "original_string": "  final public Ast.Decl decl() throws ParseException {final Ast.Decl n;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case DATATYPE:{\n      n = datatypeDecl();\n{if (\"\" != null) return n;}\n      break;\n      }\n    case VAL:{\n      n = valDecl();\n{if (\"\" != null) return n;}\n      break;\n      }\n    case FUN:{\n      n = funDecl();\n{if (\"\" != null) return n;}\n      break;\n      }\n    default:\n      jj_la1[52] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.Decl", "classes": []}, "docstring": " Parses a declaration."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Decl]declEof()", "name": "declEof", "arg_nums": 0, "params": [], "return_type": "Ast.Decl", "signature": "final public Ast.Decl declEof()", "original_string": "  final public Ast.Decl declEof() throws ParseException {Ast.Decl d;\n    d = decl();\n    jj_consume_token(0);\n{if (\"\" != null) return d;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.Decl", "classes": []}, "docstring": " Parses a declaration followed by end-of-file."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.DatatypeDecl]datatypeDecl()", "name": "datatypeDecl", "arg_nums": 0, "params": [], "return_type": "Ast.DatatypeDecl", "signature": "final public Ast.DatatypeDecl datatypeDecl()", "original_string": "  final public Ast.DatatypeDecl datatypeDecl() throws ParseException {final Span span;\n  final List<DatatypeBind> binds = new ArrayList<>();\n    jj_consume_token(DATATYPE);\nspan = Span.of(pos());\n    datatypeBind(binds);\n    label_25:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AND:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[53] = jj_gen;\n        break label_25;\n      }\n      jj_consume_token(AND);\n      datatypeBind(binds);\n    }\n{if (\"\" != null) return ast.datatypeDecl(span.end(this), binds);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.DatatypeDecl", "classes": []}, "docstring": " Parses a type declaration, e.g.\n{@code datatype 'a option = NONE | SOME of 'a}\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]datatypeBind(List<Ast.DatatypeBind>)", "name": "datatypeBind", "arg_nums": 1, "params": [{"name": "datatypeBinds", "type": "List<Ast.DatatypeBind>"}], "return_type": "void", "signature": "final public void datatypeBind(List<Ast.DatatypeBind> datatypeBinds)", "original_string": "  final public void datatypeBind(List<Ast.DatatypeBind> datatypeBinds) throws ParseException {final List<TyVar> tyVars = new ArrayList<>();\n  TyVar tyVar;\n  final Ast.Id id;\n  final List<TyCon> tyCons = new ArrayList<>();\n  TyCon tyCon;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case LPAREN:\n    case TY_VAR:{\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case TY_VAR:{\n        tyVar = tyVar();\ntyVars.add(tyVar);\n        break;\n        }\n      case LPAREN:{\n        jj_consume_token(LPAREN);\n        tyVar = tyVar();\ntyVars.add(tyVar);\n        label_26:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[54] = jj_gen;\n            break label_26;\n          }\n          jj_consume_token(COMMA);\n          tyVar = tyVar();\ntyVars.add(tyVar);\n        }\n        jj_consume_token(RPAREN);\n        break;\n        }\n      default:\n        jj_la1[55] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n      break;\n      }\n    default:\n      jj_la1[56] = jj_gen;\n      ;\n    }\n    id = identifier();\n    jj_consume_token(EQ);\n    tyCon = typeConstructor();\ntyCons.add(tyCon);\n    label_27:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case BAR:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[57] = jj_gen;\n        break label_27;\n      }\n      jj_consume_token(BAR);\n      tyCon = typeConstructor();\ntyCons.add(tyCon);\n    }\nfinal List<AstNode> nodes = ImmutableList.<AstNode>builder().addAll(tyVars)\n        .add(id).addAll(tyCons).build();\n    datatypeBinds.add(ast.datatypeBind(Pos.sum(nodes), id, tyVars, tyCons));\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.TyCon]typeConstructor()", "name": "typeConstructor", "arg_nums": 0, "params": [], "return_type": "Ast.TyCon", "signature": "final public Ast.TyCon typeConstructor()", "original_string": "  final public Ast.TyCon typeConstructor() throws ParseException {final Ast.Id tag;\n  final Ast.Type type;\n    tag = identifier();\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case OF:{\n      jj_consume_token(OF);\n      type = type();\n      break;\n      }\n    default:\n      jj_la1[58] = jj_gen;\ntype = null;\n    }\nfinal Pos pos = type == null ? tag.pos : tag.pos.plus(type.pos);\n    {if (\"\" != null) return ast.typeConstructor(pos, tag, type);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.TyCon", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.FunDecl]funDecl()", "name": "funDecl", "arg_nums": 0, "params": [], "return_type": "Ast.FunDecl", "signature": "final public Ast.FunDecl funDecl()", "original_string": "  final public Ast.FunDecl funDecl() throws ParseException {final Span span;\n  final List<FunBind> funBindList = new ArrayList<>();\n    jj_consume_token(FUN);\nspan = Span.of(pos());\n    funBind(funBindList);\n    label_28:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AND:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[59] = jj_gen;\n        break label_28;\n      }\n      jj_consume_token(AND);\n      funBind(funBindList);\n    }\n{if (\"\" != null) return ast.funDecl(span.end(this), funBindList);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.FunDecl", "classes": []}, "docstring": " Parses a function declaration, e.g.\n{@code fun f 1 y = y + 1 | f x y = 0 and g x = 0}."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]funBind(List<FunBind>)", "name": "funBind", "arg_nums": 1, "params": [{"name": "list", "type": "List<FunBind>"}], "return_type": "void", "signature": "final public void funBind(List<FunBind> list)", "original_string": "  final public void funBind(List<FunBind> list) throws ParseException {final List<FunMatch> matchList = new ArrayList<>();\n    funMatch(matchList);\n    label_29:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case BAR:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[60] = jj_gen;\n        break label_29;\n      }\n      jj_consume_token(BAR);\n      funMatch(matchList);\n    }\nlist.add(ast.funBind(Pos.sum(matchList), matchList));\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Parses a function binding, e.g.\n{@code f 1 y = y + 1 | f x y = 0},\nand adds it to a list."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]funMatch(List<FunMatch>)", "name": "funMatch", "arg_nums": 1, "params": [{"name": "list", "type": "List<FunMatch>"}], "return_type": "void", "signature": "final public void funMatch(List<FunMatch> list)", "original_string": "  final public void funMatch(List<FunMatch> list) throws ParseException {final Ast.Id id;\n  Ast.Pat pat;\n  final List<Ast.Pat> patList = new ArrayList<>();\n  final Ast.Exp expression;\n  Ast.Type returnType = null;\n    id = identifier();\n    label_30:\n    while (true) {\n      pat = atomPat();\npatList.add(pat);\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[61] = jj_gen;\n        break label_30;\n      }\n    }\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case COLON:{\n      jj_consume_token(COLON);\n      returnType = type();\n      break;\n      }\n    default:\n      jj_la1[62] = jj_gen;\n      ;\n    }\n    jj_consume_token(EQ);\n    expression = expression();\nlist.add(\n        ast.funMatch(id.pos.plus(expression.pos), id.name, patList, returnType,\n            expression));\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Parses a function match, e.g.\n{@code f 1 y = y + 1},\nand adds it to a list."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pat]pat()", "name": "pat", "arg_nums": 0, "params": [], "return_type": "Pat", "signature": "final public Pat pat()", "original_string": "  final public Pat pat() throws ParseException {Pat pat;\n  Type type;\n    pat = pat5();\n    label_31:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case COLON:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[63] = jj_gen;\n        break label_31;\n      }\n      jj_consume_token(COLON);\n      type = type();\npat = ast.annotatedPat(pat.pos.plus(type.pos), pat, type);\n    }\n{if (\"\" != null) return pat;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Pat", "classes": []}, "docstring": " Parses a pattern."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pat]pat5()", "name": "pat5", "arg_nums": 0, "params": [], "return_type": "Pat", "signature": "final public Pat pat5()", "original_string": "  final public Pat pat5() throws ParseException {Pat pat;\n  final List<Pat> list = new ArrayList<>();\n    pat = pat4();\nlist.add(pat);\n    label_32:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case CONS:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[64] = jj_gen;\n        break label_32;\n      }\n      jj_consume_token(CONS);\n      pat = pat4();\nlist.add(pat);\n    }\npat = list.get(list.size() - 1);\n    for (int i = list.size() - 2; i >= 0; i--) {\n      pat = ast.consPat(list.get(i), pat);\n    }\n    {if (\"\" != null) return pat;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Pat", "classes": []}, "docstring": " Parses a pattern of precedence level 5 ({@code ::}),\nright-associative."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pat]pat4()", "name": "pat4", "arg_nums": 0, "params": [], "return_type": "Pat", "signature": "final public Pat pat4()", "original_string": "  final public Pat pat4() throws ParseException {final Id id;\n  final Pat pat;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      id = identifier();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case AS:{\n        jj_consume_token(AS);\n        pat = pat();\n{if (\"\" != null) return ast.asPat(id.pos.plus(pat.pos),\n          (Ast.IdPat) ast.idPat(id.pos, id.name), pat);}\n        break;\n        }\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        pat = pat();\n{if (\"\" != null) return ast.conPat(id.pos.plus(pat.pos), id, pat);}\n        break;\n        }\n      default:\n        jj_la1[65] = jj_gen;\n{if (\"\" != null) return ast.idPat(id.pos, id.name);}\n      }\n      break;\n      }\n    case 1:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:{\n      pat = atomPat();\n{if (\"\" != null) return pat;}\n      break;\n      }\n    default:\n      jj_la1[66] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Pat", "classes": []}, "docstring": " Parses a pattern that is a type constructor (an identifier) followed by a\npattern. For now, assume that it has precedence level 4."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Pat]atomPat()", "name": "atomPat", "arg_nums": 0, "params": [], "return_type": "Pat", "signature": "final public Pat atomPat()", "original_string": "  final public Pat atomPat() throws ParseException {final Span span;\n  final Ast.Id id;\n  final Ast.Literal literal;\n  Ast.Pat p;\n  final List<Pat> list = new ArrayList<>();\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:{\n      id = identifier();\n{if (\"\" != null) return ast.idPat(id.pos, id.name);}\n      break;\n      }\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:{\n      literal = literal();\n{if (\"\" != null) return ast.literalPat(literal.pos, literal.op.toPat(), literal.value);}\n      break;\n      }\n    case 1:{\n      jj_consume_token(1);\n{if (\"\" != null) return ast.wildcardPat(pos());}\n      break;\n      }\n    case LPAREN:{\n      jj_consume_token(LPAREN);\nspan = Span.of(pos());\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        p = pat();\nlist.add(p);\n        label_33:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[67] = jj_gen;\n            break label_33;\n          }\n          jj_consume_token(COMMA);\n          p = pat();\nlist.add(p);\n        }\n        break;\n        }\n      default:\n        jj_la1[68] = jj_gen;\n        ;\n      }\n      jj_consume_token(RPAREN);\nif (list.size() == 1) {\n      {if (\"\" != null) return list.get(0);}\n    } else {\n      {if (\"\" != null) return ast.tuplePat(span.end(this), list);}\n    }\n      break;\n      }\n    case LBRACKET:{\n      jj_consume_token(LBRACKET);\nspan = Span.of(pos());\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case 1:\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case NEGATIVE_INTEGER_LITERAL:\n      case REAL_LITERAL:\n      case SCIENTIFIC_LITERAL:\n      case QUOTED_STRING:\n      case CHAR_LITERAL:\n      case LPAREN:\n      case LBRACE:\n      case LBRACKET:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        p = pat();\nlist.add(p);\n        label_34:\n        while (true) {\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[69] = jj_gen;\n            break label_34;\n          }\n          jj_consume_token(COMMA);\n          p = pat();\nlist.add(p);\n        }\n        break;\n        }\n      default:\n        jj_la1[70] = jj_gen;\n        ;\n      }\n      jj_consume_token(RBRACKET);\n{if (\"\" != null) return ast.listPat(span.end(this), list);}\n      break;\n      }\n    case LBRACE:{\n      jj_consume_token(LBRACE);\nspan = Span.of(pos());\n    final Map<String, Pat> map = new LinkedHashMap<>();\n    boolean ellipsis = false;\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case NON_NEGATIVE_INTEGER_LITERAL:\n      case ELLIPSIS:\n      case IDENTIFIER:\n      case QUOTED_IDENTIFIER:{\n        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n        case ELLIPSIS:{\n          jj_consume_token(ELLIPSIS);\nellipsis = true;\n          break;\n          }\n        case NON_NEGATIVE_INTEGER_LITERAL:\n        case IDENTIFIER:\n        case QUOTED_IDENTIFIER:{\n          recordPat(map);\n          label_35:\n          while (true) {\n            if (jj_2_7(2)) {\n              ;\n            } else {\n              break label_35;\n            }\n            jj_consume_token(COMMA);\n            recordPat(map);\n          }\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            jj_consume_token(COMMA);\n            jj_consume_token(ELLIPSIS);\nellipsis = true;\n            break;\n            }\n          default:\n            jj_la1[71] = jj_gen;\n            ;\n          }\n          break;\n          }\n        default:\n          jj_la1[72] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n        break;\n        }\n      default:\n        jj_la1[73] = jj_gen;\n        ;\n      }\n      jj_consume_token(RBRACE);\n{if (\"\" != null) return ast.recordPat(span.end(this), ellipsis, map);}\n      break;\n      }\n    default:\n      jj_la1[74] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Pat", "classes": []}, "docstring": " Parses an atomic pattern."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]recordPat(Map<String, Pat>)", "name": "recordPat", "arg_nums": 1, "params": [{"name": "map", "type": "Map<String, Pat>"}], "return_type": "void", "signature": "final public void recordPat(Map<String, Pat> map)", "original_string": "  final public void recordPat(Map<String, Pat> map) throws ParseException {final String id;\n  final Ast.Pat pat;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case NON_NEGATIVE_INTEGER_LITERAL:{\n      jj_consume_token(NON_NEGATIVE_INTEGER_LITERAL);\nid = token.image;\n      break;\n      }\n    case IDENTIFIER:{\n      jj_consume_token(IDENTIFIER);\nid = token.image;\n      break;\n      }\n    case QUOTED_IDENTIFIER:{\n      jj_consume_token(QUOTED_IDENTIFIER);\nid = unquoteIdentifier(token.image);\n      break;\n      }\n    default:\n      jj_la1[75] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case EQ:{\n      jj_consume_token(EQ);\n      pat = pat();\nmap.put(id, pat);\n      break;\n      }\n    default:\n      jj_la1[76] = jj_gen;\nmap.put(id, ast.idPat(pos(), id));\n    }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Parses a \"label = pat\" inside a record pattern."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]atomicType()", "name": "atomicType", "arg_nums": 0, "params": [], "return_type": "Ast.Type", "signature": "final public Ast.Type atomicType()", "original_string": "  final public Ast.Type atomicType() throws ParseException {final Span span;\n  final Type type;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case TY_VAR:{\n      type = tyVar();\n{if (\"\" != null) return type;}\n      break;\n      }\n    case IDENTIFIER:{\n      type = namedType();\n{if (\"\" != null) return type;}\n      break;\n      }\n    case LBRACE:{\n      type = recordType();\n{if (\"\" != null) return type;}\n      break;\n      }\n    case LPAREN:{\n      jj_consume_token(LPAREN);\nspan = Span.of(pos());\n      type = type();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case RPAREN:{\n        jj_consume_token(RPAREN);\n{if (\"\" != null) return type;}\n        break;\n        }\n      case COMMA:{\nfinal List<Type> list = new ArrayList<>();\n      list.add(type);\n      Type type2;\n        label_36:\n        while (true) {\n          jj_consume_token(COMMA);\n          type2 = type();\nlist.add(type2);\n          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n          case COMMA:{\n            ;\n            break;\n            }\n          default:\n            jj_la1[77] = jj_gen;\n            break label_36;\n          }\n        }\n        jj_consume_token(RPAREN);\n{if (\"\" != null) return ast.compositeType(span.end(this), list);}\n        break;\n        }\n      default:\n        jj_la1[78] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n      break;\n      }\n    default:\n      jj_la1[79] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.Type", "classes": []}, "docstring": " Parses a type."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]type7()", "name": "type7", "arg_nums": 0, "params": [], "return_type": "Ast.Type", "signature": "final public Ast.Type type7()", "original_string": "  final public Ast.Type type7() throws ParseException {Type t;\n    t = atomicType();\n    label_37:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case IDENTIFIER:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[80] = jj_gen;\n        break label_37;\n      }\n      jj_consume_token(IDENTIFIER);\nfinal List<Type> types =\n        t instanceof Ast.CompositeType\n          ? ((Ast.CompositeType) t).types\n          : ImmutableList.of(t);\n      t = ast.namedType(t.pos.plus(pos()), types, token.image);\n    }\n{if (\"\" != null) return t;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.Type", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]type6()", "name": "type6", "arg_nums": 0, "params": [], "return_type": "Ast.Type", "signature": "final public Ast.Type type6()", "original_string": "  final public Ast.Type type6() throws ParseException {final List<Type> types = new ArrayList<>();\n  Type t;\n    t = type7();\ntypes.add(t);\n    label_38:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case STAR:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[81] = jj_gen;\n        break label_38;\n      }\n      jj_consume_token(STAR);\n      t = type7();\ntypes.add(t);\n    }\n{if (\"\" != null) return types.size() == 1 ? t\n      : ast.tupleType(Pos.sum(types), types);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.Type", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]type()", "name": "type", "arg_nums": 0, "params": [], "return_type": "Ast.Type", "signature": "final public Ast.Type type()", "original_string": "  final public Ast.Type type() throws ParseException {final List<Type> types = new ArrayList<>();\n  Type t;\n    t = type6();\ntypes.add(t);\n    label_39:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case RTHINARROW:{\n        ;\n        break;\n        }\n      default:\n        jj_la1[82] = jj_gen;\n        break label_39;\n      }\n      jj_consume_token(RTHINARROW);\n      t = type6();\ntypes.add(t);\n    }\n{if (\"\" != null) return types.size() == 1 ? t\n        : ast.foldFunctionType(types);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.Type", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Ast.Type]namedType()", "name": "namedType", "arg_nums": 0, "params": [], "return_type": "Ast.Type", "signature": "final public Ast.Type namedType()", "original_string": "  final public Ast.Type namedType() throws ParseException {\n    jj_consume_token(IDENTIFIER);\n{if (\"\" != null) return ast.namedType(pos(), ImmutableList.of(), token.image);}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Ast.Type", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[AstNode]statement()", "name": "statement", "arg_nums": 0, "params": [], "return_type": "AstNode", "signature": "final public AstNode statement()", "original_string": "  final public AstNode statement() throws ParseException {final AstNode n;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case CASE:\n    case FN:\n    case IF:\n    case LET:\n    case FROM:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:\n    case TILDE:\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:\n    case LABEL:{\n      n = expression();\n{if (\"\" != null) return n;}\n      break;\n      }\n    case DATATYPE:\n    case FUN:\n    case VAL:{\n      n = decl();\n{if (\"\" != null) return n;}\n      break;\n      }\n    default:\n      jj_la1[83] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[AstNode]statementSemicolon()", "name": "statementSemicolon", "arg_nums": 0, "params": [], "return_type": "AstNode", "signature": "final public AstNode statementSemicolon()", "original_string": "  final public AstNode statementSemicolon() throws ParseException {final AstNode n;\n    n = statement();\n    jj_consume_token(SEMICOLON);\n{if (\"\" != null) return n;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[AstNode]statementSemicolonOrEof()", "name": "statementSemicolonOrEof", "arg_nums": 0, "params": [], "return_type": "AstNode", "signature": "final public AstNode statementSemicolonOrEof()", "original_string": "  final public AstNode statementSemicolonOrEof() throws ParseException {final AstNode n;\n    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n    case 0:{\n      jj_consume_token(0);\n{if (\"\" != null) return null;}\n      break;\n      }\n    case CASE:\n    case DATATYPE:\n    case FN:\n    case FUN:\n    case IF:\n    case LET:\n    case VAL:\n    case FROM:\n    case NON_NEGATIVE_INTEGER_LITERAL:\n    case NEGATIVE_INTEGER_LITERAL:\n    case REAL_LITERAL:\n    case SCIENTIFIC_LITERAL:\n    case QUOTED_STRING:\n    case CHAR_LITERAL:\n    case LPAREN:\n    case LBRACE:\n    case LBRACKET:\n    case TILDE:\n    case IDENTIFIER:\n    case QUOTED_IDENTIFIER:\n    case LABEL:{\n      n = statement();\n      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {\n      case SEMICOLON:{\n        jj_consume_token(SEMICOLON);\n        break;\n        }\n      case 0:{\n        jj_consume_token(0);\n        break;\n        }\n      default:\n        jj_la1[84] = jj_gen;\n        jj_consume_token(-1);\n        throw new ParseException();\n      }\n{if (\"\" != null) return n;}\n      break;\n      }\n    default:\n      jj_la1[85] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": " Parses a statement followed by semicolon or end-of-file.\nReturns null if there is no statement."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[AstNode]statementEof()", "name": "statementEof", "arg_nums": 0, "params": [], "return_type": "AstNode", "signature": "final public AstNode statementEof()", "original_string": "  final public AstNode statementEof() throws ParseException {final AstNode n;\n    n = statement();\n    jj_consume_token(0);\n{if (\"\" != null) return n;}\n    throw new Error(\"Missing return statement in function\");\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "AstNode", "classes": []}, "docstring": " Parses a statement followed by end-of-file."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_1(int)", "name": "jj_2_1", "arg_nums": 1, "params": [{"name": "xla", "type": "int"}], "return_type": "boolean", "signature": "private boolean jj_2_1(int xla)", "original_string": "  private boolean jj_2_1(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_1()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(0, xla); }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_2(int)", "name": "jj_2_2", "arg_nums": 1, "params": [{"name": "xla", "type": "int"}], "return_type": "boolean", "signature": "private boolean jj_2_2(int xla)", "original_string": "  private boolean jj_2_2(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_2()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(1, xla); }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_3(int)", "name": "jj_2_3", "arg_nums": 1, "params": [{"name": "xla", "type": "int"}], "return_type": "boolean", "signature": "private boolean jj_2_3(int xla)", "original_string": "  private boolean jj_2_3(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_3()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(2, xla); }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_4(int)", "name": "jj_2_4", "arg_nums": 1, "params": [{"name": "xla", "type": "int"}], "return_type": "boolean", "signature": "private boolean jj_2_4(int xla)", "original_string": "  private boolean jj_2_4(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_4()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(3, xla); }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_5(int)", "name": "jj_2_5", "arg_nums": 1, "params": [{"name": "xla", "type": "int"}], "return_type": "boolean", "signature": "private boolean jj_2_5(int xla)", "original_string": "  private boolean jj_2_5(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_5()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(4, xla); }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_6(int)", "name": "jj_2_6", "arg_nums": 1, "params": [{"name": "xla", "type": "int"}], "return_type": "boolean", "signature": "private boolean jj_2_6(int xla)", "original_string": "  private boolean jj_2_6(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_6()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(5, xla); }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_2_7(int)", "name": "jj_2_7", "arg_nums": 1, "params": [{"name": "xla", "type": "int"}], "return_type": "boolean", "signature": "private boolean jj_2_7(int xla)", "original_string": "  private boolean jj_2_7(int xla)\n {\n    jj_la = xla; jj_lastpos = jj_scanpos = token;\n    try { return (!jj_3_7()); }\n    catch(LookaheadSuccess ls) { return true; }\n    finally { jj_save(6, xla); }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_3()", "name": "jj_3_3", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3_3()", "original_string": "  private boolean jj_3_3()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(89)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(90)) return true;\n    }\n    if (jj_scan_token(EQ)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_4()", "name": "jj_3_4", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3_4()", "original_string": "  private boolean jj_3_4()\n {\n    if (jj_scan_token(NON_NEGATIVE_INTEGER_LITERAL)) return true;\n    if (jj_scan_token(EQ)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_charLiteral_183_3_83()", "name": "jj_3R_charLiteral_183_3_83", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_charLiteral_183_3_83()", "original_string": "  private boolean jj_3R_charLiteral_183_3_83()\n {\n    if (jj_scan_token(CHAR_LITERAL)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_1()", "name": "jj_3_1", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3_1()", "original_string": "  private boolean jj_3_1()\n {\n    if (jj_scan_token(ON)) return true;\n    if (jj_3R_expression_807_3_40()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_2()", "name": "jj_3_2", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3_2()", "original_string": "  private boolean jj_3_2()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(89)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(90)) return true;\n    }\n    xsp = jj_scanpos;\n    if (jj_scan_token(57)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(32)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(38)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(30)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(27)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(35)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(36)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(39)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(0)) return true;\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_stringLiteral_173_3_82()", "name": "jj_3R_stringLiteral_173_3_82", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_stringLiteral_173_3_82()", "original_string": "  private boolean jj_3R_stringLiteral_173_3_82()\n {\n    if (jj_scan_token(QUOTED_STRING)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_fn_546_3_72()", "name": "jj_3R_fn_546_3_72", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_fn_546_3_72()", "original_string": "  private boolean jj_3R_fn_546_3_72()\n {\n    if (jj_scan_token(FN)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression7_634_3_53()", "name": "jj_3R_expression7_634_3_53", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression7_634_3_53()", "original_string": "  private boolean jj_3R_expression7_634_3_53()\n {\n    if (jj_3R_expression8_616_3_54()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression7_632_3_51()", "name": "jj_3R_expression7_632_3_51", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression7_632_3_51()", "original_string": "  private boolean jj_3R_expression7_632_3_51()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_expression7_632_3_52()) {\n    jj_scanpos = xsp;\n    if (jj_3R_expression7_634_3_53()) return true;\n    }\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression7_632_3_52()", "name": "jj_3R_expression7_632_3_52", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression7_632_3_52()", "original_string": "  private boolean jj_3R_expression7_632_3_52()\n {\n    if (jj_scan_token(TILDE)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_913_3_67()", "name": "jj_3R_atom_913_3_67", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_913_3_67()", "original_string": "  private boolean jj_3R_atom_913_3_67()\n {\n    if (jj_scan_token(LBRACE)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression4_716_3_48()", "name": "jj_3R_expression4_716_3_48", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression4_716_3_48()", "original_string": "  private boolean jj_3R_expression4_716_3_48()\n {\n    if (jj_3R_expression5_699_3_49()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_numericLiteral_145_3_86()", "name": "jj_3R_numericLiteral_145_3_86", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_numericLiteral_145_3_86()", "original_string": "  private boolean jj_3R_numericLiteral_145_3_86()\n {\n    if (jj_scan_token(SCIENTIFIC_LITERAL)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordPat_1283_5_45()", "name": "jj_3R_recordPat_1283_5_45", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_recordPat_1283_5_45()", "original_string": "  private boolean jj_3R_recordPat_1283_5_45()\n {\n    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordPat_1282_5_44()", "name": "jj_3R_recordPat_1282_5_44", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_recordPat_1282_5_44()", "original_string": "  private boolean jj_3R_recordPat_1282_5_44()\n {\n    if (jj_scan_token(IDENTIFIER)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordPat_1281_5_43()", "name": "jj_3R_recordPat_1281_5_43", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_recordPat_1281_5_43()", "original_string": "  private boolean jj_3R_recordPat_1281_5_43()\n {\n    if (jj_scan_token(NON_NEGATIVE_INTEGER_LITERAL)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_from_332_3_75()", "name": "jj_3R_from_332_3_75", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_from_332_3_75()", "original_string": "  private boolean jj_3R_from_332_3_75()\n {\n    if (jj_scan_token(FROM)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression_807_3_40()", "name": "jj_3R_expression_807_3_40", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression_807_3_40()", "original_string": "  private boolean jj_3R_expression_807_3_40()\n {\n    if (jj_3R_expression1_792_3_42()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression8_616_3_54()", "name": "jj_3R_expression8_616_3_54", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression8_616_3_54()", "original_string": "  private boolean jj_3R_expression8_616_3_54()\n {\n    if (jj_3R_expression9_599_3_55()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordPat_1281_3_41()", "name": "jj_3R_recordPat_1281_3_41", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_recordPat_1281_3_41()", "original_string": "  private boolean jj_3R_recordPat_1281_3_41()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_recordPat_1281_5_43()) {\n    jj_scanpos = xsp;\n    if (jj_3R_recordPat_1282_5_44()) {\n    jj_scanpos = xsp;\n    if (jj_3R_recordPat_1283_5_45()) return true;\n    }\n    }\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_898_3_66()", "name": "jj_3R_atom_898_3_66", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_898_3_66()", "original_string": "  private boolean jj_3R_atom_898_3_66()\n {\n    if (jj_scan_token(LBRACKET)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_numericLiteral_131_3_85()", "name": "jj_3R_numericLiteral_131_3_85", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_numericLiteral_131_3_85()", "original_string": "  private boolean jj_3R_numericLiteral_131_3_85()\n {\n    if (jj_scan_token(REAL_LITERAL)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression5_699_3_49()", "name": "jj_3R_expression5_699_3_49", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression5_699_3_49()", "original_string": "  private boolean jj_3R_expression5_699_3_49()\n {\n    if (jj_3R_expression6_666_3_50()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_caseOf_318_3_74()", "name": "jj_3R_caseOf_318_3_74", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_caseOf_318_3_74()", "original_string": "  private boolean jj_3R_caseOf_318_3_74()\n {\n    if (jj_scan_token(CASE)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_7()", "name": "jj_3_7", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3_7()", "original_string": "  private boolean jj_3_7()\n {\n    if (jj_scan_token(COMMA)) return true;\n    if (jj_3R_recordPat_1281_3_41()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression1_792_3_42()", "name": "jj_3R_expression1_792_3_42", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression1_792_3_42()", "original_string": "  private boolean jj_3R_expression1_792_3_42()\n {\n    if (jj_3R_expression2_776_3_46()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression9_599_3_55()", "name": "jj_3R_expression9_599_3_55", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression9_599_3_55()", "original_string": "  private boolean jj_3R_expression9_599_3_55()\n {\n    if (jj_3R_atom_858_3_56()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_numericLiteral_122_3_84()", "name": "jj_3R_numericLiteral_122_3_84", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_numericLiteral_122_3_84()", "original_string": "  private boolean jj_3R_numericLiteral_122_3_84()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_scan_token(40)) {\n    jj_scanpos = xsp;\n    if (jj_scan_token(41)) return true;\n    }\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_numericLiteral_122_3_81()", "name": "jj_3R_numericLiteral_122_3_81", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_numericLiteral_122_3_81()", "original_string": "  private boolean jj_3R_numericLiteral_122_3_81()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_numericLiteral_122_3_84()) {\n    jj_scanpos = xsp;\n    if (jj_3R_numericLiteral_131_3_85()) {\n    jj_scanpos = xsp;\n    if (jj_3R_numericLiteral_145_3_86()) return true;\n    }\n    }\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_recordSelector_210_3_69()", "name": "jj_3R_recordSelector_210_3_69", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_recordSelector_210_3_69()", "original_string": "  private boolean jj_3R_recordSelector_210_3_69()\n {\n    if (jj_scan_token(LABEL)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_874_3_65()", "name": "jj_3R_atom_874_3_65", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_874_3_65()", "original_string": "  private boolean jj_3R_atom_874_3_65()\n {\n    if (jj_scan_token(LPAREN)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_let_303_3_71()", "name": "jj_3R_let_303_3_71", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_let_303_3_71()", "original_string": "  private boolean jj_3R_let_303_3_71()\n {\n    if (jj_scan_token(LET)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_872_3_64()", "name": "jj_3R_atom_872_3_64", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_872_3_64()", "original_string": "  private boolean jj_3R_atom_872_3_64()\n {\n    if (jj_3R_from_332_3_75()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression2_776_3_46()", "name": "jj_3R_expression2_776_3_46", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression2_776_3_46()", "original_string": "  private boolean jj_3R_expression2_776_3_46()\n {\n    if (jj_3R_expression3_760_3_47()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_870_3_63()", "name": "jj_3R_atom_870_3_63", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_870_3_63()", "original_string": "  private boolean jj_3R_atom_870_3_63()\n {\n    if (jj_3R_caseOf_318_3_74()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_868_3_62()", "name": "jj_3R_atom_868_3_62", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_868_3_62()", "original_string": "  private boolean jj_3R_atom_868_3_62()\n {\n    if (jj_3R_ifThenElse_287_3_73()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_866_3_61()", "name": "jj_3R_atom_866_3_61", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_866_3_61()", "original_string": "  private boolean jj_3R_atom_866_3_61()\n {\n    if (jj_3R_fn_546_3_72()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_literal_104_3_80()", "name": "jj_3R_literal_104_3_80", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_literal_104_3_80()", "original_string": "  private boolean jj_3R_literal_104_3_80()\n {\n    if (jj_3R_charLiteral_183_3_83()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_864_3_60()", "name": "jj_3R_atom_864_3_60", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_864_3_60()", "original_string": "  private boolean jj_3R_atom_864_3_60()\n {\n    if (jj_3R_let_303_3_71()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_literal_102_3_79()", "name": "jj_3R_literal_102_3_79", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_literal_102_3_79()", "original_string": "  private boolean jj_3R_literal_102_3_79()\n {\n    if (jj_3R_stringLiteral_173_3_82()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_862_3_59()", "name": "jj_3R_atom_862_3_59", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_862_3_59()", "original_string": "  private boolean jj_3R_atom_862_3_59()\n {\n    if (jj_3R_literal_100_3_70()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_identifier_196_3_77()", "name": "jj_3R_identifier_196_3_77", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_identifier_196_3_77()", "original_string": "  private boolean jj_3R_identifier_196_3_77()\n {\n    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_literal_100_3_78()", "name": "jj_3R_literal_100_3_78", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_literal_100_3_78()", "original_string": "  private boolean jj_3R_literal_100_3_78()\n {\n    if (jj_3R_numericLiteral_122_3_81()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_literal_100_3_70()", "name": "jj_3R_literal_100_3_70", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_literal_100_3_70()", "original_string": "  private boolean jj_3R_literal_100_3_70()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_literal_100_3_78()) {\n    jj_scanpos = xsp;\n    if (jj_3R_literal_102_3_79()) {\n    jj_scanpos = xsp;\n    if (jj_3R_literal_104_3_80()) return true;\n    }\n    }\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_860_3_58()", "name": "jj_3R_atom_860_3_58", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_860_3_58()", "original_string": "  private boolean jj_3R_atom_860_3_58()\n {\n    if (jj_3R_recordSelector_210_3_69()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_identifier_193_3_76()", "name": "jj_3R_identifier_193_3_76", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_identifier_193_3_76()", "original_string": "  private boolean jj_3R_identifier_193_3_76()\n {\n    if (jj_scan_token(IDENTIFIER)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_identifier_193_3_68()", "name": "jj_3R_identifier_193_3_68", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_identifier_193_3_68()", "original_string": "  private boolean jj_3R_identifier_193_3_68()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_identifier_193_3_76()) {\n    jj_scanpos = xsp;\n    if (jj_3R_identifier_196_3_77()) return true;\n    }\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_858_3_56()", "name": "jj_3R_atom_858_3_56", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_858_3_56()", "original_string": "  private boolean jj_3R_atom_858_3_56()\n {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_atom_858_3_57()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_860_3_58()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_862_3_59()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_864_3_60()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_866_3_61()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_868_3_62()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_870_3_63()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_872_3_64()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_874_3_65()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_898_3_66()) {\n    jj_scanpos = xsp;\n    if (jj_3R_atom_913_3_67()) return true;\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    }\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_atom_858_3_57()", "name": "jj_3R_atom_858_3_57", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_atom_858_3_57()", "original_string": "  private boolean jj_3R_atom_858_3_57()\n {\n    if (jj_3R_identifier_193_3_68()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_6()", "name": "jj_3_6", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3_6()", "original_string": "  private boolean jj_3_6()\n {\n    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;\n    if (jj_scan_token(EQ)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_ifThenElse_287_3_73()", "name": "jj_3R_ifThenElse_287_3_73", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_ifThenElse_287_3_73()", "original_string": "  private boolean jj_3R_ifThenElse_287_3_73()\n {\n    if (jj_scan_token(IF)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression6_666_3_50()", "name": "jj_3R_expression6_666_3_50", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression6_666_3_50()", "original_string": "  private boolean jj_3R_expression6_666_3_50()\n {\n    if (jj_3R_expression7_632_3_51()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3R_expression3_760_3_47()", "name": "jj_3R_expression3_760_3_47", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3R_expression3_760_3_47()", "original_string": "  private boolean jj_3R_expression3_760_3_47()\n {\n    if (jj_3R_expression4_716_3_48()) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_3_5()", "name": "jj_3_5", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean jj_3_5()", "original_string": "  private boolean jj_3_5()\n {\n    if (jj_scan_token(IDENTIFIER)) return true;\n    if (jj_scan_token(EQ)) return true;\n    return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_la1_init_0()", "name": "jj_la1_init_0", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private static void jj_la1_init_0()", "original_string": " private static void jj_la1_init_0() {\n\t   jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4002040,0x0,0x2,0xc8000000,0x0,0x20025020,0x8000000,0xc8000000,0x8000,0x2,0x0,0x200000,0x0,0x10000000,0x0,0x0,0x20025020,0x50080,0x50080,0x20025020,0x2000400,0x2000400,0x0,0x0,0x80100,0x80100,0x100000,0x8,0x400000,0x0,0x0,0x20025020,0x0,0x0,0x20025020,0x0,0x20025020,0x0,0x20025020,0x20025020,0x20025020,0x800000,0x4,0x4002040,0x4,0x0,0x0,0x0,0x0,0x200000,0x4,0x0,0x2,0x0,0x0,0x0,0x12,0x2,0x0,0x2,0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x24027060,0x1,0x24027061,};\n\t}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_la1_init_1()", "name": "jj_la1_init_1", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private static void jj_la1_init_1()", "original_string": " private static void jj_la1_init_1() {\n\t   jj_la1_1 = new int[] {0xcf00,0x300,0xf00,0x0,0x2000000,0x10000,0x2000000,0x0,0x400000,0x0,0x2000000,0x15cf00,0xfd,0x2000000,0x15cf00,0x0,0xfd,0x10000000,0x15cf00,0x2000000,0x0,0x2000000,0x0,0x800000,0x1000000,0x15cf00,0x0,0x0,0x15cf00,0x0,0x0,0x0,0x0,0x70000000,0x70000000,0x0,0x0,0x0,0x80000000,0x2000000,0x15cf00,0x2000000,0x2020000,0x17cf00,0x2000000,0x15cf00,0x2000000,0x15cf00,0x15cf00,0x15cf00,0x0,0x0,0x0,0x0,0x2000000,0x10000,0x10000,0x800000,0x0,0x0,0x800000,0x15cf00,0x80000000,0x80000000,0x0,0x15cf00,0x15cf00,0x2000000,0x15cf00,0x2000000,0x15cf00,0x2000000,0x100,0x100,0x15cf00,0x100,0x10000000,0x2000000,0x2020000,0x50000,0x0,0x0,0x8000000,0x15cf00,0x400000,0x15cf00,};\n\t}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_la1_init_2()", "name": "jj_la1_init_2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private static void jj_la1_init_2()", "original_string": " private static void jj_la1_init_2() {\n\t   jj_la1_2 = new int[] {0x0,0x0,0x0,0x6000000,0x0,0x8000000,0x0,0x6000000,0x0,0x0,0x0,0x6000000,0x0,0x0,0x16000100,0x0,0x0,0x0,0x6000000,0x0,0x0,0x0,0x0,0x0,0x0,0x16000000,0xc0,0xc0,0x16000100,0x38,0x38,0x600,0x600,0x7,0x7,0x0,0x0,0x0,0x0,0x0,0x16000100,0x0,0x0,0x16000100,0x0,0x16000100,0x0,0x16000100,0x16000000,0x16000100,0x0,0x0,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x6000000,0x0,0x0,0x200,0x6000000,0x6000000,0x0,0x6000000,0x0,0x6000000,0x0,0x6000800,0x6000800,0x6000000,0x6000000,0x0,0x0,0x0,0xa000000,0x2000000,0x40,0x0,0x16000100,0x0,0x16000100,};\n\t}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[]MorelParserImpl(java.io.InputStream)", "name": "MorelParserImpl", "arg_nums": 1, "params": [{"name": "stream", "type": "java.io.InputStream"}], "return_type": "", "signature": "public MorelParserImpl(java.io.InputStream stream)", "original_string": "  public MorelParserImpl(java.io.InputStream stream) {\n\t  this(stream, null);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor with InputStream."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[]MorelParserImpl(java.io.InputStream,String)", "name": "MorelParserImpl", "arg_nums": 2, "params": [{"name": "stream", "type": "java.io.InputStream"}, {"name": "encoding", "type": "String"}], "return_type": "", "signature": "public MorelParserImpl(java.io.InputStream stream, String encoding)", "original_string": "  public MorelParserImpl(java.io.InputStream stream, String encoding) {\n\t try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n\t token_source = new MorelParserImplTokenManager(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor with InputStream and supplied encoding"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]ReInit(java.io.InputStream)", "name": "ReInit", "arg_nums": 1, "params": [{"name": "stream", "type": "java.io.InputStream"}], "return_type": "void", "signature": "public void ReInit(java.io.InputStream stream)", "original_string": "  public void ReInit(java.io.InputStream stream) {\n\t  ReInit(stream, null);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]ReInit(java.io.InputStream,String)", "name": "ReInit", "arg_nums": 2, "params": [{"name": "stream", "type": "java.io.InputStream"}, {"name": "encoding", "type": "String"}], "return_type": "void", "signature": "public void ReInit(java.io.InputStream stream, String encoding)", "original_string": "  public void ReInit(java.io.InputStream stream, String encoding) {\n\t try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }\n\t token_source.ReInit(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[]MorelParserImpl(java.io.Reader)", "name": "MorelParserImpl", "arg_nums": 1, "params": [{"name": "stream", "type": "java.io.Reader"}], "return_type": "", "signature": "public MorelParserImpl(java.io.Reader stream)", "original_string": "  public MorelParserImpl(java.io.Reader stream) {\n\t jj_input_stream = new SimpleCharStream(stream, 1, 1);\n\t token_source = new MorelParserImplTokenManager(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]ReInit(java.io.Reader)", "name": "ReInit", "arg_nums": 1, "params": [{"name": "stream", "type": "java.io.Reader"}], "return_type": "void", "signature": "public void ReInit(java.io.Reader stream)", "original_string": "  public void ReInit(java.io.Reader stream) {\n\tif (jj_input_stream == null) {\n\t   jj_input_stream = new SimpleCharStream(stream, 1, 1);\n\t} else {\n\t   jj_input_stream.ReInit(stream, 1, 1);\n\t}\n\tif (token_source == null) {\n token_source = new MorelParserImplTokenManager(jj_input_stream);\n\t}\n\n\t token_source.ReInit(jj_input_stream);\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[]MorelParserImpl(MorelParserImplTokenManager)", "name": "MorelParserImpl", "arg_nums": 1, "params": [{"name": "tm", "type": "MorelParserImplTokenManager"}], "return_type": "", "signature": "public MorelParserImpl(MorelParserImplTokenManager tm)", "original_string": "  public MorelParserImpl(MorelParserImplTokenManager tm) {\n\t token_source = tm;\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor with generated Token Manager."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]ReInit(MorelParserImplTokenManager)", "name": "ReInit", "arg_nums": 1, "params": [{"name": "tm", "type": "MorelParserImplTokenManager"}], "return_type": "void", "signature": "public void ReInit(MorelParserImplTokenManager tm)", "original_string": "  public void ReInit(MorelParserImplTokenManager tm) {\n\t token_source = tm;\n\t token = new Token();\n\t jj_ntk = -1;\n\t jj_gen = 0;\n\t for (int i = 0; i < 86; i++) jj_la1[i] = -1;\n\t for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Token]jj_consume_token(int)", "name": "jj_consume_token", "arg_nums": 1, "params": [{"name": "kind", "type": "int"}], "return_type": "Token", "signature": "private Token jj_consume_token(int kind)", "original_string": "  private Token jj_consume_token(int kind) throws ParseException {\n\t Token oldToken;\n\t if ((oldToken = token).next != null) token = token.next;\n\t else token = token.next = token_source.getNextToken();\n\t jj_ntk = -1;\n\t if (token.kind == kind) {\n\t   jj_gen++;\n\t   if (++jj_gc > 100) {\n\t\t jj_gc = 0;\n\t\t for (int i = 0; i < jj_2_rtns.length; i++) {\n\t\t   JJCalls c = jj_2_rtns[i];\n\t\t   while (c != null) {\n\t\t\t if (c.gen < jj_gen) c.first = null;\n\t\t\t c = c.next;\n\t\t   }\n\t\t }\n\t   }\n\t   return token;\n\t }\n\t token = oldToken;\n\t jj_kind = kind;\n\t throw generateParseException();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Token", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]jj_scan_token(int)", "name": "jj_scan_token", "arg_nums": 1, "params": [{"name": "kind", "type": "int"}], "return_type": "boolean", "signature": "private boolean jj_scan_token(int kind)", "original_string": "  private boolean jj_scan_token(int kind) {\n\t if (jj_scanpos == jj_lastpos) {\n\t   jj_la--;\n\t   if (jj_scanpos.next == null) {\n\t\t jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();\n\t   } else {\n\t\t jj_lastpos = jj_scanpos = jj_scanpos.next;\n\t   }\n\t } else {\n\t   jj_scanpos = jj_scanpos.next;\n\t }\n\t if (jj_rescan) {\n\t   int i = 0; Token tok = token;\n\t   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }\n\t   if (tok != null) jj_add_error_token(kind, i);\n\t }\n\t if (jj_scanpos.kind != kind) return true;\n\t if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;\n\t return false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Token]getNextToken()", "name": "getNextToken", "arg_nums": 0, "params": [], "return_type": "Token", "signature": "final public Token getNextToken()", "original_string": "  final public Token getNextToken() {\n\t if (token.next != null) token = token.next;\n\t else token = token.next = token_source.getNextToken();\n\t jj_ntk = -1;\n\t jj_gen++;\n\t return token;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Token", "classes": []}, "docstring": " Get the next Token."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[Token]getToken(int)", "name": "getToken", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "Token", "signature": "final public Token getToken(int index)", "original_string": "  final public Token getToken(int index) {\n\t Token t = token;\n\t for (int i = 0; i < index; i++) {\n\t   if (t.next != null) t = t.next;\n\t   else t = t.next = token_source.getNextToken();\n\t }\n\t return t;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "Token", "classes": []}, "docstring": " Get the specific Token."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[int]jj_ntk_f()", "name": "jj_ntk_f", "arg_nums": 0, "params": [], "return_type": "int", "signature": "private int jj_ntk_f()", "original_string": "  private int jj_ntk_f() {\n\t if ((jj_nt=token.next) == null)\n\t   return (jj_ntk = (token.next=token_source.getNextToken()).kind);\n\t else\n\t   return (jj_ntk = jj_nt.kind);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_add_error_token(int,int)", "name": "jj_add_error_token", "arg_nums": 2, "params": [{"name": "kind", "type": "int"}, {"name": "pos", "type": "int"}], "return_type": "void", "signature": "private void jj_add_error_token(int kind, int pos)", "original_string": "  private void jj_add_error_token(int kind, int pos) {\n\t if (pos >= 100) {\n\t\treturn;\n\t }\n\n\t if (pos == jj_endpos + 1) {\n\t   jj_lasttokens[jj_endpos++] = kind;\n\t } else if (jj_endpos != 0) {\n\t   jj_expentry = new int[jj_endpos];\n\n\t   for (int i = 0; i < jj_endpos; i++) {\n\t\t jj_expentry[i] = jj_lasttokens[i];\n\t   }\n\n\t   for (int[] oldentry : jj_expentries) {\n\t\t if (oldentry.length == jj_expentry.length) {\n\t\t   boolean isMatched = true;\n\n\t\t   for (int i = 0; i < jj_expentry.length; i++) {\n\t\t\t if (oldentry[i] != jj_expentry[i]) {\n\t\t\t   isMatched = false;\n\t\t\t   break;\n\t\t\t }\n\n\t\t   }\n\t\t   if (isMatched) {\n\t\t\t jj_expentries.add(jj_expentry);\n\t\t\t break;\n\t\t   }\n\t\t }\n\t   }\n\n\t   if (pos != 0) {\n\t\t jj_lasttokens[(jj_endpos = pos) - 1] = kind;\n\t   }\n\t }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[ParseException]generateParseException()", "name": "generateParseException", "arg_nums": 0, "params": [], "return_type": "ParseException", "signature": "public ParseException generateParseException()", "original_string": "  public ParseException generateParseException() {\n\t jj_expentries.clear();\n\t boolean[] la1tokens = new boolean[95];\n\t if (jj_kind >= 0) {\n\t   la1tokens[jj_kind] = true;\n\t   jj_kind = -1;\n\t }\n\t for (int i = 0; i < 86; i++) {\n\t   if (jj_la1[i] == jj_gen) {\n\t\t for (int j = 0; j < 32; j++) {\n\t\t   if ((jj_la1_0[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[j] = true;\n\t\t   }\n\t\t   if ((jj_la1_1[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[32+j] = true;\n\t\t   }\n\t\t   if ((jj_la1_2[i] & (1<<j)) != 0) {\n\t\t\t la1tokens[64+j] = true;\n\t\t   }\n\t\t }\n\t   }\n\t }\n\t for (int i = 0; i < 95; i++) {\n\t   if (la1tokens[i]) {\n\t\t jj_expentry = new int[1];\n\t\t jj_expentry[0] = i;\n\t\t jj_expentries.add(jj_expentry);\n\t   }\n\t }\n\t jj_endpos = 0;\n\t jj_rescan_token();\n\t jj_add_error_token(0, 0);\n\t int[][] exptokseq = new int[jj_expentries.size()][];\n\t for (int i = 0; i < jj_expentries.size(); i++) {\n\t   exptokseq[i] = jj_expentries.get(i);\n\t }\n\t return new ParseException(token, exptokseq, tokenImage);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ParseException", "classes": []}, "docstring": " Generate ParseException."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[boolean]trace_enabled()", "name": "trace_enabled", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "final public boolean trace_enabled()", "original_string": "  final public boolean trace_enabled() {\n\t return trace_enabled;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": " Trace enabled."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]enable_tracing()", "name": "enable_tracing", "arg_nums": 0, "params": [], "return_type": "void", "signature": "final public void enable_tracing()", "original_string": "  final public void enable_tracing() {\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Enable tracing."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]disable_tracing()", "name": "disable_tracing", "arg_nums": 0, "params": [], "return_type": "void", "signature": "final public void disable_tracing()", "original_string": "  final public void disable_tracing() {\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "final public", "marker_annotations": [], "non_marker_annotations": ["final", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Disable tracing."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_rescan_token()", "name": "jj_rescan_token", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void jj_rescan_token()", "original_string": "  private void jj_rescan_token() {\n\t jj_rescan = true;\n\t for (int i = 0; i < 7; i++) {\n\t   try {\n\t\t JJCalls p = jj_2_rtns[i];\n\n\t\t do {\n\t\t   if (p.gen > jj_gen) {\n\t\t\t jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;\n\t\t\t switch (i) {\n\t\t\t   case 0: jj_3_1(); break;\n\t\t\t   case 1: jj_3_2(); break;\n\t\t\t   case 2: jj_3_3(); break;\n\t\t\t   case 3: jj_3_4(); break;\n\t\t\t   case 4: jj_3_5(); break;\n\t\t\t   case 5: jj_3_6(); break;\n\t\t\t   case 6: jj_3_7(); break;\n\t\t\t }\n\t\t   }\n\t\t   p = p.next;\n\t\t } while (p != null);\n\n\t\t } catch(LookaheadSuccess ls) { }\n\t }\n\t jj_rescan = false;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl.[void]jj_save(int,int)", "name": "jj_save", "arg_nums": 2, "params": [{"name": "index", "type": "int"}, {"name": "xla", "type": "int"}], "return_type": "void", "signature": "private void jj_save(int index, int xla)", "original_string": "  private void jj_save(int index, int xla) {\n\t JJCalls p = jj_2_rtns[index];\n\t while (p.gen > jj_gen) {\n\t   if (p.next == null) { p = p.next = new JJCalls(); break; }\n\t   p = p.next;\n\t }\n\n\t p.gen = jj_gen + xla - jj_la; \n\t p.first = token;\n\t p.arg = xla;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java", "class_name": "MorelParserImpl", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImpl.java.MorelParserImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[String]addEscapes(String)", "name": "addEscapes", "arg_nums": 1, "params": [{"name": "str", "type": "String"}], "return_type": "String", "signature": "protected static final String addEscapes(String str)", "original_string": "  protected static final String addEscapes(String str) {\n    StringBuilder retval = new StringBuilder();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n      switch (str.charAt(i))\n      {\n        case '\\b':\n          retval.append(\"\\\\b\");\n          continue;\n        case '\\t':\n          retval.append(\"\\\\t\");\n          continue;\n        case '\\n':\n          retval.append(\"\\\\n\");\n          continue;\n        case '\\f':\n          retval.append(\"\\\\f\");\n          continue;\n        case '\\r':\n          retval.append(\"\\\\r\");\n          continue;\n        case '\\\"':\n          retval.append(\"\\\\\\\"\");\n          continue;\n        case '\\'':\n          retval.append(\"\\\\\\'\");\n          continue;\n        case '\\\\':\n          retval.append(\"\\\\\\\\\");\n          continue;\n        default:\n          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n            String s = \"0000\" + Integer.toString(ch, 16);\n            retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n          } else {\n            retval.append(ch);\n          }\n          continue;\n      }\n    }\n    return retval.toString();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java", "class_name": "TokenMgrError", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError", "attributes": {"modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReplaces unprintable characters by their escaped (or unicode escaped)\nequivalents in the given string\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[String]LexicalErr(boolean,int,int,int,String,int)", "name": "LexicalErr", "arg_nums": 6, "params": [{"name": "EOFSeen", "type": "boolean"}, {"name": "lexState", "type": "int"}, {"name": "errorLine", "type": "int"}, {"name": "errorColumn", "type": "int"}, {"name": "errorAfter", "type": "String"}, {"name": "curChar", "type": "int"}], "return_type": "String", "signature": "protected static String LexicalErr(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, int curChar)", "original_string": "  protected static String LexicalErr(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, int curChar) {\n    return(\"Lexical error at line \" + //\n          errorLine + \", column \" + //\n          errorColumn + \".  Encountered: \" + //\n          (EOFSeen ? \"<EOF>\" : (\"'\" + addEscapes(String.valueOf((char) curChar)) + \"' (\" + curChar + \"),\")) + //\n          (errorAfter == null || errorAfter.length() == 0 ? \"\" : \" after prefix \\\"\" + addEscapes(errorAfter) + \"\\\"\")) + //\n          (lexState == 0 ? \"\" : \" (in lexical state \" + lexState + \")\");\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java", "class_name": "TokenMgrError", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a detailed message for the Error when it is thrown by the\ntoken manager to indicate a lexical error.\nParameters :\n   EOFSeen     : indicates if EOF caused the lexical error\n   lexState    : lexical state in which this error occurred\n   errorLine   : line number when the error occurred\n   errorColumn : column number when the error occurred\n   errorAfter  : prefix that was seen before this error occurred\n   curchar     : the offending character\nNote: You can customize the lexical error message by modifying this method.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[String]getMessage()", "name": "getMessage", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n  public String getMessage()", "original_string": "  @Override\n  public String getMessage() {\n    return super.getMessage();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java", "class_name": "TokenMgrError", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nYou can also modify the body of this method to customize your error messages.\nFor example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not\nof end-users concern, so you can return something like :\n\n    \"Internal Error : Please file a bug report .... \"\n\nfrom this method for such cases in the release version of your parser.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[]TokenMgrError()", "name": "TokenMgrError", "arg_nums": 0, "params": [], "return_type": "", "signature": "public TokenMgrError()", "original_string": "  public TokenMgrError() {\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java", "class_name": "TokenMgrError", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " No arg constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[]TokenMgrError(String,int)", "name": "TokenMgrError", "arg_nums": 2, "params": [{"name": "message", "type": "String"}, {"name": "reason", "type": "int"}], "return_type": "", "signature": "public TokenMgrError(String message, int reason)", "original_string": "  public TokenMgrError(String message, int reason) {\n    super(message);\n    errorCode = reason;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java", "class_name": "TokenMgrError", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor with message and reason."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError.[]TokenMgrError(boolean,int,int,int,String,int,int)", "name": "TokenMgrError", "arg_nums": 7, "params": [{"name": "EOFSeen", "type": "boolean"}, {"name": "lexState", "type": "int"}, {"name": "errorLine", "type": "int"}, {"name": "errorColumn", "type": "int"}, {"name": "errorAfter", "type": "String"}, {"name": "curChar", "type": "int"}, {"name": "reason", "type": "int"}], "return_type": "", "signature": "public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, int curChar, int reason)", "original_string": "  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, int curChar, int reason) {\n    this(LexicalErr(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java", "class_name": "TokenMgrError", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/TokenMgrError.java.TokenMgrError", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Full Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[]ParseException(Token,int[][],String[])", "name": "ParseException", "arg_nums": 3, "params": [{"name": "currentTokenVal", "type": "Token"}, {"name": "expectedTokenSequencesVal", "type": "int[][]"}, {"name": "tokenImageVal", "type": "String[]"}], "return_type": "", "signature": "public ParseException(Token currentTokenVal,\n                        int[][] expectedTokenSequencesVal,\n                        String[] tokenImageVal\n                       )", "original_string": "  public ParseException(Token currentTokenVal,\n                        int[][] expectedTokenSequencesVal,\n                        String[] tokenImageVal\n                       )\n  {\n    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));\n    currentToken = currentTokenVal;\n    expectedTokenSequences = expectedTokenSequencesVal;\n    tokenImage = tokenImageVal;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java", "class_name": "ParseException", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nThis constructor is used by the method \"generateParseException\"\nin the generated parser.  Calling this constructor generates\na new object of this type with the fields \"currentToken\",\n\"expectedTokenSequences\", and \"tokenImage\" set.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[]ParseException()", "name": "ParseException", "arg_nums": 0, "params": [], "return_type": "", "signature": "public ParseException()", "original_string": "  public ParseException() {\n    super();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java", "class_name": "ParseException", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nThe following constructors are for use by you for whatever\npurpose you can think of.  Constructing the exception in this\nmanner makes the exception behave in the normal way - i.e., as\ndocumented in the class \"Throwable\".  The fields \"errorToken\",\n\"expectedTokenSequences\", and \"tokenImage\" do not contain\nrelevant information.  The JavaCC generated code does not use\nthese constructors.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[]ParseException(String)", "name": "ParseException", "arg_nums": 1, "params": [{"name": "message", "type": "String"}], "return_type": "", "signature": "public ParseException(String message)", "original_string": "  public ParseException(String message) {\n    super(message);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java", "class_name": "ParseException", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor with message."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[String]initialise(Token,int[][],String[])", "name": "initialise", "arg_nums": 3, "params": [{"name": "currentToken", "type": "Token"}, {"name": "expectedTokenSequences", "type": "int[][]"}, {"name": "tokenImage", "type": "String[]"}], "return_type": "String", "signature": "private static String initialise(Token currentToken,\n                           int[][] expectedTokenSequences,\n                           String[] tokenImage)", "original_string": "  private static String initialise(Token currentToken,\n                           int[][] expectedTokenSequences,\n                           String[] tokenImage) {\n\n    StringBuilder expected = new StringBuilder();\n    int maxSize = 0;\n    for (int i = 0; i < expectedTokenSequences.length; i++) {\n      if (maxSize < expectedTokenSequences[i].length) {\n        maxSize = expectedTokenSequences[i].length;\n      }\n      for (int j = 0; j < expectedTokenSequences[i].length; j++) {\n        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');\n      }\n      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {\n        expected.append(\"...\");\n      }\n      expected.append(EOL).append(\"    \");\n    }\n    String retval = \"Encountered \\\"\";\n    Token tok = currentToken.next;\n    for (int i = 0; i < maxSize; i++) {\n      if (i != 0) retval += \" \";\n      if (tok.kind == 0) {\n        retval += tokenImage[0];\n        break;\n      }\n      retval += \" \" + tokenImage[tok.kind];\n      retval += \" \\\"\";\n      retval += add_escapes(tok.image);\n      retval += \" \\\"\";\n      tok = tok.next;\n    }\n    if (currentToken.next != null) {\n      retval += \"\\\" at line \" + currentToken.next.beginLine + \", column \" + currentToken.next.beginColumn;\n    }\n    retval += \".\" + EOL;\n    \n    \n    if (expectedTokenSequences.length == 0) {\n        // Nothing to add here\n    } else {\n\t    if (expectedTokenSequences.length == 1) {\n\t      retval += \"Was expecting:\" + EOL + \"    \";\n\t    } else {\n\t      retval += \"Was expecting one of:\" + EOL + \"    \";\n\t    }\n\t    retval += expected.toString();\n    }\n    \n    return retval;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java", "class_name": "ParseException", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nIt uses \"currentToken\" and \"expectedTokenSequences\" to generate a parse\nerror message and returns it.  If this object has been created\ndue to a parse error, and you do not catch it (it gets thrown\nfrom the parser) the correct error message\ngets displayed.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException.[String]add_escapes(String)", "name": "add_escapes", "arg_nums": 1, "params": [{"name": "str", "type": "String"}], "return_type": "String", "signature": "static String add_escapes(String str)", "original_string": "  static String add_escapes(String str) {\n      StringBuilder retval = new StringBuilder();\n      char ch;\n      for (int i = 0; i < str.length(); i++) {\n        switch (str.charAt(i))\n        {\n           case '\\b':\n              retval.append(\"\\\\b\");\n              continue;\n           case '\\t':\n              retval.append(\"\\\\t\");\n              continue;\n           case '\\n':\n              retval.append(\"\\\\n\");\n              continue;\n           case '\\f':\n              retval.append(\"\\\\f\");\n              continue;\n           case '\\r':\n              retval.append(\"\\\\r\");\n              continue;\n           case '\\\"':\n              retval.append(\"\\\\\\\"\");\n              continue;\n           case '\\'':\n              retval.append(\"\\\\\\'\");\n              continue;\n           case '\\\\':\n              retval.append(\"\\\\\\\\\");\n              continue;\n           default:\n              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n                 String s = \"0000\" + Integer.toString(ch, 16);\n                 retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n              } else {\n                 retval.append(ch);\n              }\n              continue;\n        }\n      }\n      return retval.toString();\n   }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java", "class_name": "ParseException", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/ParseException.java.ParseException", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nUsed to convert raw characters to their escaped version\nwhen these raw version cannot be used as part of an ASCII\nstring literal.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[Object]getValue()", "name": "getValue", "arg_nums": 0, "params": [], "return_type": "Object", "signature": "public Object getValue()", "original_string": "  public Object getValue() {\n    return null;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java", "class_name": "Token", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": "\nAn optional attribute value of the Token.\nTokens which are not used as syntactic sugar will often contain\nmeaningful values that will be used later on by the compiler or\ninterpreter. This attribute value is often different from the image.\nAny subclass of Token that actually wants to return a non-null value can\noverride this method as appropriate.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[]Token()", "name": "Token", "arg_nums": 0, "params": [], "return_type": "", "signature": "public Token()", "original_string": "  public Token() {}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java", "class_name": "Token", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nNo-argument constructor\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[]Token(int)", "name": "Token", "arg_nums": 1, "params": [{"name": "kind", "type": "int"}], "return_type": "", "signature": "public Token(int kind)", "original_string": "  public Token(int kind)\n  {\n    this(kind, null);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java", "class_name": "Token", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs a new token for the specified Image.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[]Token(int,String)", "name": "Token", "arg_nums": 2, "params": [{"name": "kind", "type": "int"}, {"name": "image", "type": "String"}], "return_type": "", "signature": "public Token(int kind, String image)", "original_string": "  public Token(int kind, String image)\n  {\n    this.kind = kind;\n    this.image = image;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java", "class_name": "Token", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs a new token for the specified Image and Kind.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n  public String toString()", "original_string": "  @Override\n  public String toString()\n  {\n    return image;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java", "class_name": "Token", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token", "attributes": {"modifiers": "@Override\n  public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the image.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[Token]newToken(int,String)", "name": "newToken", "arg_nums": 2, "params": [{"name": "ofKind", "type": "int"}, {"name": "image", "type": "String"}], "return_type": "Token", "signature": "public static Token newToken(int ofKind, String image)", "original_string": "  public static Token newToken(int ofKind, String image)\n  {\n    switch(ofKind)\n    {\n      default : return new Token(ofKind, image);\n    }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java", "class_name": "Token", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Token", "classes": []}, "docstring": "\nReturns a new Token object, by default. However, if you want, you\ncan create and return subclass objects based on the value of ofKind.\nSimply add the cases to the switch for all those special cases.\nFor example, if you have a subclass of Token called IDToken that\nyou want to create if ofKind is ID, simply add something like :\n\n   case MyParserConstants.ID : return new IDToken(ofKind, image);\n\nto the following switch statement. Then you can cast matchedToken\nvariable to the appropriate type and use sit in your lexical actions.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token.[Token]newToken(int)", "name": "newToken", "arg_nums": 1, "params": [{"name": "ofKind", "type": "int"}], "return_type": "Token", "signature": "public static Token newToken(int ofKind)", "original_string": "  public static Token newToken(int ofKind)\n  {\n    return newToken(ofKind, null);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java", "class_name": "Token", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/Token.java.Token", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Token", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]pushState()", "name": "pushState", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void pushState()", "original_string": "    void pushState() {\n      lexicalStateStack.add(curLexState);\n    }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]popState()", "name": "popState", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void popState()", "original_string": "    void popState() {\n      SwitchTo(lexicalStateStack.remove(lexicalStateStack.size() - 1));\n    }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]setDebugStream(java.io.PrintStream)", "name": "setDebugStream", "arg_nums": 1, "params": [{"name": "ds", "type": "java.io.PrintStream"}], "return_type": "void", "signature": "public  void setDebugStream(java.io.PrintStream ds)", "original_string": "  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Set debug output."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjStopStringLiteralDfa_0(int,long,long)", "name": "jjStopStringLiteralDfa_0", "arg_nums": 3, "params": [{"name": "pos", "type": "int"}, {"name": "active0", "type": "long"}, {"name": "active1", "type": "long"}], "return_type": "int", "signature": "private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1)", "original_string": "private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1){\n   switch (pos)\n   {\n      case 0:\n         if ((active1 & 0x2000L) != 0L)\n            return 39;\n         if ((active0 & 0x600700000L) != 0L)\n            return 40;\n         if ((active0 & 0xf9ff8ffffcL) != 0L)\n         {\n            jjmatchedKind = 89;\n            return 40;\n         }\n         if ((active1 & 0x1000L) != 0L)\n            return 17;\n         if ((active1 & 0x100L) != 0L)\n            return 41;\n         return -1;\n      case 1:\n         if ((active0 & 0xfd7fce2fecL) != 0L)\n         {\n            if (jjmatchedPos != 1)\n            {\n               jjmatchedKind = 89;\n               jjmatchedPos = 1;\n            }\n            return 40;\n         }\n         if ((active0 & 0x28021d010L) != 0L)\n            return 40;\n         return -1;\n      case 2:\n         if ((active0 & 0x486288cL) != 0L)\n            return 40;\n         if ((active0 & 0xfdfb490760L) != 0L)\n         {\n            if (jjmatchedPos != 2)\n            {\n               jjmatchedKind = 89;\n               jjmatchedPos = 2;\n            }\n            return 40;\n         }\n         return -1;\n      case 3:\n         if ((active0 & 0xe44a490448L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 3;\n            return 40;\n         }\n         if ((active0 & 0x19b1000320L) != 0L)\n            return 40;\n         return -1;\n      case 4:\n         if ((active0 & 0xc442000000L) != 0L)\n            return 40;\n         if ((active0 & 0x2008490448L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 4;\n            return 40;\n         }\n         return -1;\n      case 5:\n         if ((active0 & 0x400400L) != 0L)\n            return 40;\n         if ((active0 & 0x2008090048L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 5;\n            return 40;\n         }\n         return -1;\n      case 6:\n         if ((active0 & 0x10040L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 6;\n            return 40;\n         }\n         if ((active0 & 0x2008080008L) != 0L)\n            return 40;\n         return -1;\n      case 7:\n         if ((active0 & 0x40L) != 0L)\n            return 40;\n         if ((active0 & 0x10000L) != 0L)\n         {\n            jjmatchedKind = 89;\n            jjmatchedPos = 7;\n            return 40;\n         }\n         return -1;\n      default :\n         return -1;\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjStartNfa_0(int,long,long)", "name": "jjStartNfa_0", "arg_nums": 3, "params": [{"name": "pos", "type": "int"}, {"name": "active0", "type": "long"}, {"name": "active1", "type": "long"}], "return_type": "int", "signature": "private final int jjStartNfa_0(int pos, long active0, long active1)", "original_string": "private final int jjStartNfa_0(int pos, long active0, long active1){\n   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjStopAtPos(int,int)", "name": "jjStopAtPos", "arg_nums": 2, "params": [{"name": "pos", "type": "int"}, {"name": "kind", "type": "int"}], "return_type": "int", "signature": "private int jjStopAtPos(int pos, int kind)", "original_string": "private int jjStopAtPos(int pos, int kind)\n{\n   jjmatchedKind = kind;\n   jjmatchedPos = pos;\n   return pos + 1;\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa0_0()", "name": "jjMoveStringLiteralDfa0_0", "arg_nums": 0, "params": [], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa0_0()", "original_string": "private int jjMoveStringLiteralDfa0_0(){\n   switch(curChar)\n   {\n      case 34:\n         return jjStartNfaWithStates_0(0, 77, 39);\n      case 39:\n         return jjStartNfaWithStates_0(0, 76, 17);\n      case 40:\n         jjmatchedKind = 48;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x180000L);\n      case 41:\n         return jjStopAtPos(0, 49);\n      case 42:\n         return jjStopAtPos(0, 70);\n      case 43:\n         return jjStopAtPos(0, 67);\n      case 44:\n         return jjStopAtPos(0, 57);\n      case 45:\n         jjmatchedKind = 68;\n         return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L);\n      case 46:\n         jjmatchedKind = 56;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x800L);\n      case 47:\n         return jjStopAtPos(0, 71);\n      case 58:\n         jjmatchedKind = 63;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x200L);\n      case 59:\n         return jjStopAtPos(0, 54);\n      case 60:\n         jjmatchedKind = 62;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x5L);\n      case 61:\n         jjmatchedKind = 60;\n         return jjMoveStringLiteralDfa1_0(0x400000000000000L, 0x0L);\n      case 62:\n         jjmatchedKind = 61;\n         return jjMoveStringLiteralDfa1_0(0x0L, 0x2L);\n      case 64:\n         return jjStopAtPos(0, 74);\n      case 91:\n         return jjStopAtPos(0, 52);\n      case 93:\n         return jjStopAtPos(0, 53);\n      case 94:\n         return jjStopAtPos(0, 69);\n      case 95:\n         return jjStopAtPos(0, 1);\n      case 97:\n         return jjMoveStringLiteralDfa1_0(0x1cL, 0x0L);\n      case 99:\n         return jjMoveStringLiteralDfa1_0(0x8000020L, 0x0L);\n      case 100:\n         return jjMoveStringLiteralDfa1_0(0x100000c0L, 0x0L);\n      case 101:\n         return jjMoveStringLiteralDfa1_0(0xf00L, 0x0L);\n      case 102:\n         return jjMoveStringLiteralDfa1_0(0x20003000L, 0x0L);\n      case 103:\n         return jjMoveStringLiteralDfa1_0(0x40000000L, 0x0L);\n      case 105:\n         return jjMoveStringLiteralDfa1_0(0x8001c000L, 0x0L);\n      case 106:\n         return jjMoveStringLiteralDfa1_0(0x100000000L, 0x0L);\n      case 108:\n         return jjMoveStringLiteralDfa1_0(0x20000L, 0x0L);\n      case 109:\n         return jjMoveStringLiteralDfa1_0(0x40000L, 0x0L);\n      case 110:\n         return jjMoveStringLiteralDfa1_0(0x80000L, 0x0L);\n      case 111:\n         jjmatchedKind = 20;\n         return jjMoveStringLiteralDfa1_0(0x600600000L, 0x0L);\n      case 114:\n         return jjMoveStringLiteralDfa1_0(0x800000L, 0x0L);\n      case 115:\n         return jjMoveStringLiteralDfa1_0(0x800000000L, 0x0L);\n      case 116:\n         return jjMoveStringLiteralDfa1_0(0x3001000000L, 0x0L);\n      case 117:\n         return jjMoveStringLiteralDfa1_0(0x2000000L, 0x0L);\n      case 118:\n         return jjMoveStringLiteralDfa1_0(0x4000000L, 0x0L);\n      case 119:\n         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x0L);\n      case 121:\n         return jjMoveStringLiteralDfa1_0(0x8000000000L, 0x0L);\n      case 123:\n         return jjStopAtPos(0, 50);\n      case 124:\n         return jjStopAtPos(0, 55);\n      case 125:\n         return jjStopAtPos(0, 51);\n      case 126:\n         return jjStartNfaWithStates_0(0, 72, 41);\n      default :\n         return jjMoveNfa_0(11, 0);\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa1_0(long,long)", "name": "jjMoveStringLiteralDfa1_0", "arg_nums": 2, "params": [{"name": "active0", "type": "long"}, {"name": "active1", "type": "long"}], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa1_0(long active0, long active1)", "original_string": "private int jjMoveStringLiteralDfa1_0(long active0, long active1){\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(0, active0, active1);\n      return 1;\n   }\n   switch(curChar)\n   {\n      case 42:\n         if ((active1 & 0x100000L) != 0L)\n         {\n            jjmatchedKind = 84;\n            jjmatchedPos = 1;\n         }\n         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x80000L);\n      case 46:\n         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x800L);\n      case 58:\n         if ((active1 & 0x200L) != 0L)\n            return jjStopAtPos(1, 73);\n         break;\n      case 61:\n         if ((active1 & 0x1L) != 0L)\n            return jjStopAtPos(1, 64);\n         else if ((active1 & 0x2L) != 0L)\n            return jjStopAtPos(1, 65);\n         break;\n      case 62:\n         if ((active0 & 0x400000000000000L) != 0L)\n            return jjStopAtPos(1, 58);\n         else if ((active0 & 0x800000000000000L) != 0L)\n            return jjStopAtPos(1, 59);\n         else if ((active1 & 0x4L) != 0L)\n            return jjStopAtPos(1, 66);\n         break;\n      case 97:\n         return jjMoveStringLiteralDfa2_0(active0, 0x1004000060L, active1, 0L);\n      case 101:\n         return jjMoveStringLiteralDfa2_0(active0, 0x10820000L, active1, 0L);\n      case 102:\n         if ((active0 & 0x4000L) != 0L)\n            return jjStartNfaWithStates_0(1, 14, 40);\n         else if ((active0 & 0x200000L) != 0L)\n            return jjStartNfaWithStates_0(1, 21, 40);\n         break;\n      case 104:\n         return jjMoveStringLiteralDfa2_0(active0, 0x6001000000L, active1, 0L);\n      case 105:\n         return jjMoveStringLiteralDfa2_0(active0, 0x8000000080L, active1, 0L);\n      case 107:\n         return jjMoveStringLiteralDfa2_0(active0, 0x800000000L, active1, 0L);\n      case 108:\n         return jjMoveStringLiteralDfa2_0(active0, 0x300L, active1, 0L);\n      case 110:\n         if ((active0 & 0x1000L) != 0L)\n            return jjStartNfaWithStates_0(1, 12, 40);\n         else if ((active0 & 0x8000L) != 0L)\n         {\n            jjmatchedKind = 15;\n            jjmatchedPos = 1;\n         }\n         else if ((active0 & 0x200000000L) != 0L)\n            return jjStartNfaWithStates_0(1, 33, 40);\n         return jjMoveStringLiteralDfa2_0(active0, 0x8201080cL, active1, 0L);\n      case 111:\n         return jjMoveStringLiteralDfa2_0(active0, 0x1080c0000L, active1, 0L);\n      case 114:\n         return jjMoveStringLiteralDfa2_0(active0, 0x460400000L, active1, 0L);\n      case 115:\n         if ((active0 & 0x10L) != 0L)\n            return jjStartNfaWithStates_0(1, 4, 40);\n         break;\n      case 117:\n         return jjMoveStringLiteralDfa2_0(active0, 0x2000L, active1, 0L);\n      case 120:\n         return jjMoveStringLiteralDfa2_0(active0, 0x400L, active1, 0L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(0, active0, active1);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa2_0(long,long,long,long)", "name": "jjMoveStringLiteralDfa2_0", "arg_nums": 4, "params": [{"name": "old0", "type": "long"}, {"name": "active0", "type": "long"}, {"name": "old1", "type": "long"}, {"name": "active1", "type": "long"}], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1)", "original_string": "private int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1){\n   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n      return jjStartNfa_0(0, old0, old1);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(1, active0, active1);\n      return 2;\n   }\n   switch(curChar)\n   {\n      case 41:\n         if ((active1 & 0x80000L) != 0L)\n            return jjStopAtPos(2, 83);\n         break;\n      case 46:\n         if ((active1 & 0x800L) != 0L)\n            return jjStopAtPos(2, 75);\n         break;\n      case 99:\n         if ((active0 & 0x800000L) != 0L)\n            return jjStartNfaWithStates_0(2, 23, 40);\n         return jjMoveStringLiteralDfa3_0(active0, 0x400L, active1, 0L);\n      case 100:\n         if ((active0 & 0x4L) != 0L)\n         {\n            jjmatchedKind = 2;\n            jjmatchedPos = 2;\n         }\n         else if ((active0 & 0x800L) != 0L)\n            return jjStartNfaWithStates_0(2, 11, 40);\n         else if ((active0 & 0x40000L) != 0L)\n            return jjStartNfaWithStates_0(2, 18, 40);\n         return jjMoveStringLiteralDfa3_0(active0, 0x400000008L, active1, 0L);\n      case 101:\n         return jjMoveStringLiteralDfa3_0(active0, 0xc001400100L, active1, 0L);\n      case 105:\n         return jjMoveStringLiteralDfa3_0(active0, 0x902000000L, active1, 0L);\n      case 107:\n         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0L);\n      case 108:\n         if ((active0 & 0x4000000L) != 0L)\n            return jjStartNfaWithStates_0(2, 26, 40);\n         break;\n      case 109:\n         return jjMoveStringLiteralDfa3_0(active0, 0x8000000L, active1, 0L);\n      case 110:\n         if ((active0 & 0x2000L) != 0L)\n            return jjStartNfaWithStates_0(2, 13, 40);\n         break;\n      case 111:\n         return jjMoveStringLiteralDfa3_0(active0, 0x60000000L, active1, 0L);\n      case 114:\n         return jjMoveStringLiteralDfa3_0(active0, 0x2000000000L, active1, 0L);\n      case 115:\n         return jjMoveStringLiteralDfa3_0(active0, 0x10000220L, active1, 0L);\n      case 116:\n         if ((active0 & 0x20000L) != 0L)\n            return jjStartNfaWithStates_0(2, 17, 40);\n         return jjMoveStringLiteralDfa3_0(active0, 0x80090040L, active1, 0L);\n      case 118:\n         if ((active0 & 0x80L) != 0L)\n            return jjStartNfaWithStates_0(2, 7, 40);\n         break;\n      default :\n         break;\n   }\n   return jjStartNfa_0(1, active0, active1);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa3_0(long,long,long,long)", "name": "jjMoveStringLiteralDfa3_0", "arg_nums": 4, "params": [{"name": "old0", "type": "long"}, {"name": "active0", "type": "long"}, {"name": "old1", "type": "long"}, {"name": "active1", "type": "long"}], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1)", "original_string": "private int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1){\n   if (((active0 &= old0) | (active1 &= old1)) == 0L)\n      return jjStartNfa_0(1, old0, old1);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(2, active0, 0L);\n      return 3;\n   }\n   switch(curChar)\n   {\n      case 97:\n         return jjMoveStringLiteralDfa4_0(active0, 0x48L);\n      case 99:\n         if ((active0 & 0x10000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 28, 40);\n         break;\n      case 101:\n         if ((active0 & 0x20L) != 0L)\n            return jjStartNfaWithStates_0(3, 5, 40);\n         else if ((active0 & 0x200L) != 0L)\n            return jjStartNfaWithStates_0(3, 9, 40);\n         else if ((active0 & 0x1000000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 36, 40);\n         return jjMoveStringLiteralDfa4_0(active0, 0x400090400L);\n      case 108:\n         return jjMoveStringLiteralDfa4_0(active0, 0x8000400000L);\n      case 109:\n         if ((active0 & 0x100L) != 0L)\n            return jjStartNfaWithStates_0(3, 8, 40);\n         else if ((active0 & 0x20000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 29, 40);\n         break;\n      case 110:\n         if ((active0 & 0x1000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 24, 40);\n         else if ((active0 & 0x100000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 32, 40);\n         break;\n      case 111:\n         if ((active0 & 0x80000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 31, 40);\n         return jjMoveStringLiteralDfa4_0(active0, 0x2002000000L);\n      case 112:\n         if ((active0 & 0x800000000L) != 0L)\n            return jjStartNfaWithStates_0(3, 35, 40);\n         return jjMoveStringLiteralDfa4_0(active0, 0x8000000L);\n      case 114:\n         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000L);\n      case 117:\n         return jjMoveStringLiteralDfa4_0(active0, 0x40000000L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(2, active0, 0L);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa4_0(long,long)", "name": "jjMoveStringLiteralDfa4_0", "arg_nums": 2, "params": [{"name": "old0", "type": "long"}, {"name": "active0", "type": "long"}], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa4_0(long old0, long active0)", "original_string": "private int jjMoveStringLiteralDfa4_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(2, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(3, active0, 0L);\n      return 4;\n   }\n   switch(curChar)\n   {\n      case 100:\n         if ((active0 & 0x8000000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 39, 40);\n         break;\n      case 101:\n         if ((active0 & 0x4000000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 38, 40);\n         break;\n      case 108:\n         return jjMoveStringLiteralDfa5_0(active0, 0x80008L);\n      case 110:\n         if ((active0 & 0x2000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 25, 40);\n         break;\n      case 112:\n         if ((active0 & 0x40000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 30, 40);\n         return jjMoveStringLiteralDfa5_0(active0, 0x400L);\n      case 114:\n         if ((active0 & 0x400000000L) != 0L)\n            return jjStartNfaWithStates_0(4, 34, 40);\n         return jjMoveStringLiteralDfa5_0(active0, 0x10000L);\n      case 115:\n         return jjMoveStringLiteralDfa5_0(active0, 0x400000L);\n      case 116:\n         return jjMoveStringLiteralDfa5_0(active0, 0x40L);\n      case 117:\n         return jjMoveStringLiteralDfa5_0(active0, 0x2008000000L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(3, active0, 0L);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa5_0(long,long)", "name": "jjMoveStringLiteralDfa5_0", "arg_nums": 2, "params": [{"name": "old0", "type": "long"}, {"name": "active0", "type": "long"}], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa5_0(long old0, long active0)", "original_string": "private int jjMoveStringLiteralDfa5_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(3, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(4, active0, 0L);\n      return 5;\n   }\n   switch(curChar)\n   {\n      case 101:\n         if ((active0 & 0x400000L) != 0L)\n            return jjStartNfaWithStates_0(5, 22, 40);\n         return jjMoveStringLiteralDfa6_0(active0, 0x80000L);\n      case 103:\n         return jjMoveStringLiteralDfa6_0(active0, 0x2000000000L);\n      case 115:\n         return jjMoveStringLiteralDfa6_0(active0, 0x10008L);\n      case 116:\n         if ((active0 & 0x400L) != 0L)\n            return jjStartNfaWithStates_0(5, 10, 40);\n         return jjMoveStringLiteralDfa6_0(active0, 0x8000000L);\n      case 121:\n         return jjMoveStringLiteralDfa6_0(active0, 0x40L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(4, active0, 0L);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa6_0(long,long)", "name": "jjMoveStringLiteralDfa6_0", "arg_nums": 2, "params": [{"name": "old0", "type": "long"}, {"name": "active0", "type": "long"}], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa6_0(long old0, long active0)", "original_string": "private int jjMoveStringLiteralDfa6_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(4, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(5, active0, 0L);\n      return 6;\n   }\n   switch(curChar)\n   {\n      case 101:\n         if ((active0 & 0x8000000L) != 0L)\n            return jjStartNfaWithStates_0(6, 27, 40);\n         return jjMoveStringLiteralDfa7_0(active0, 0x10000L);\n      case 104:\n         if ((active0 & 0x2000000000L) != 0L)\n            return jjStartNfaWithStates_0(6, 37, 40);\n         break;\n      case 109:\n         if ((active0 & 0x80000L) != 0L)\n            return jjStartNfaWithStates_0(6, 19, 40);\n         break;\n      case 111:\n         if ((active0 & 0x8L) != 0L)\n            return jjStartNfaWithStates_0(6, 3, 40);\n         break;\n      case 112:\n         return jjMoveStringLiteralDfa7_0(active0, 0x40L);\n      default :\n         break;\n   }\n   return jjStartNfa_0(5, active0, 0L);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa7_0(long,long)", "name": "jjMoveStringLiteralDfa7_0", "arg_nums": 2, "params": [{"name": "old0", "type": "long"}, {"name": "active0", "type": "long"}], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa7_0(long old0, long active0)", "original_string": "private int jjMoveStringLiteralDfa7_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(5, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(6, active0, 0L);\n      return 7;\n   }\n   switch(curChar)\n   {\n      case 99:\n         return jjMoveStringLiteralDfa8_0(active0, 0x10000L);\n      case 101:\n         if ((active0 & 0x40L) != 0L)\n            return jjStartNfaWithStates_0(7, 6, 40);\n         break;\n      default :\n         break;\n   }\n   return jjStartNfa_0(6, active0, 0L);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa8_0(long,long)", "name": "jjMoveStringLiteralDfa8_0", "arg_nums": 2, "params": [{"name": "old0", "type": "long"}, {"name": "active0", "type": "long"}], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa8_0(long old0, long active0)", "original_string": "private int jjMoveStringLiteralDfa8_0(long old0, long active0){\n   if (((active0 &= old0)) == 0L)\n      return jjStartNfa_0(6, old0, 0L);\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) {\n      jjStopStringLiteralDfa_0(7, active0, 0L);\n      return 8;\n   }\n   switch(curChar)\n   {\n      case 116:\n         if ((active0 & 0x10000L) != 0L)\n            return jjStartNfaWithStates_0(8, 16, 40);\n         break;\n      default :\n         break;\n   }\n   return jjStartNfa_0(7, active0, 0L);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjStartNfaWithStates_0(int,int,int)", "name": "jjStartNfaWithStates_0", "arg_nums": 3, "params": [{"name": "pos", "type": "int"}, {"name": "kind", "type": "int"}, {"name": "state", "type": "int"}], "return_type": "int", "signature": "private int jjStartNfaWithStates_0(int pos, int kind, int state)", "original_string": "private int jjStartNfaWithStates_0(int pos, int kind, int state)\n{\n   jjmatchedKind = kind;\n   jjmatchedPos = pos;\n   try { curChar = input_stream.readChar(); }\n   catch(java.io.IOException e) { return pos + 1; }\n   return jjMoveNfa_0(state, pos + 1);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveNfa_0(int,int)", "name": "jjMoveNfa_0", "arg_nums": 2, "params": [{"name": "startState", "type": "int"}, {"name": "curPos", "type": "int"}], "return_type": "int", "signature": "private int jjMoveNfa_0(int startState, int curPos)", "original_string": "private int jjMoveNfa_0(int startState, int curPos)\n{\n   int startsAt = 0;\n   jjnewStateCnt = 39;\n   int i = 1;\n   jjstateSet[0] = startState;\n   int kind = 0x7fffffff;\n   for (;;)\n   {\n      if (++jjround == 0x7fffffff)\n         ReInitRounds();\n      if (curChar < 64)\n      {\n         long l = 1L << curChar;\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 40:\n                  if ((0x7ff600000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(6, 7); }\n                  else if (curChar == 36)\n                     jjstateSet[jjnewStateCnt++] = 8;\n                  if ((0x3ff008000000000L & l) != 0L)\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 39:\n                  if ((0xfffffffbffffffffL & l) != 0L)\n                     { jjCheckNAddStates(3, 5); }\n                  else if (curChar == 34)\n                  {\n                     if (kind > 46)\n                        kind = 46;\n                  }\n                  break;\n               case 41:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(6, 8); }\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(21, 22); }\n                  if ((0x3ff000000000000L & l) != 0L)\n                  {\n                     if (kind > 41)\n                        kind = 41;\n                     { jjCheckNAdd(31); }\n                  }\n                  break;\n               case 11:\n                  if ((0x3ff000000000000L & l) != 0L)\n                  {\n                     if (kind > 40)\n                        kind = 40;\n                     { jjCheckNAddStates(9, 14); }\n                  }\n                  else if (curChar == 35)\n                     { jjCheckNAddTwoStates(33, 38); }\n                  else if (curChar == 39)\n                     jjstateSet[jjnewStateCnt++] = 17;\n                  else if (curChar == 34)\n                     { jjCheckNAddStates(3, 5); }\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 0:\n                  if (curChar == 34)\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 1:\n                  if ((0xfffffffbffffffffL & l) != 0L)\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 2:\n                  if (curChar == 34 && kind > 46)\n                     kind = 46;\n                  break;\n               case 5:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 6:\n                  if ((0x7ff600000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(6, 7); }\n                  break;\n               case 7:\n                  if (curChar == 36)\n                     jjstateSet[jjnewStateCnt++] = 8;\n                  break;\n               case 9:\n                  if (curChar == 36)\n                     { jjCheckNAdd(10); }\n                  break;\n               case 10:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  { jjCheckNAdd(10); }\n                  break;\n               case 12:\n                  if ((0x3ff008000000000L & l) == 0L)\n                     break;\n                  if (kind > 89)\n                     kind = 89;\n                  { jjCheckNAdd(12); }\n                  break;\n               case 14:\n                  { jjAddStates(15, 16); }\n                  break;\n               case 16:\n                  if (curChar == 39)\n                     jjstateSet[jjnewStateCnt++] = 17;\n                  break;\n               case 18:\n                  if ((0x3ff008000000000L & l) == 0L)\n                     break;\n                  if (kind > 91)\n                     kind = 91;\n                  jjstateSet[jjnewStateCnt++] = 18;\n                  break;\n               case 19:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 40)\n                     kind = 40;\n                  { jjCheckNAddStates(9, 14); }\n                  break;\n               case 20:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 40)\n                     kind = 40;\n                  { jjCheckNAdd(20); }\n                  break;\n               case 21:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(21, 22); }\n                  break;\n               case 22:\n                  if (curChar == 46)\n                     { jjCheckNAdd(23); }\n                  break;\n               case 23:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 42)\n                     kind = 42;\n                  { jjCheckNAdd(23); }\n                  break;\n               case 24:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddStates(6, 8); }\n                  break;\n               case 25:\n                  if (curChar == 46)\n                     { jjCheckNAdd(26); }\n                  break;\n               case 26:\n                  if ((0x3ff000000000000L & l) != 0L)\n                     { jjCheckNAddTwoStates(26, 27); }\n                  break;\n               case 29:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 43)\n                     kind = 43;\n                  jjstateSet[jjnewStateCnt++] = 29;\n                  break;\n               case 31:\n                  if ((0x3ff000000000000L & l) == 0L)\n                     break;\n                  if (kind > 41)\n                     kind = 41;\n                  { jjCheckNAdd(31); }\n                  break;\n               case 32:\n                  if (curChar == 35)\n                     { jjCheckNAddTwoStates(33, 38); }\n                  break;\n               case 33:\n                  if (curChar == 34)\n                     { jjCheckNAddStates(17, 19); }\n                  break;\n               case 34:\n                  if ((0xfffffffbffffffffL & l) != 0L)\n                     { jjCheckNAddStates(17, 19); }\n                  break;\n               case 35:\n                  if (curChar == 34 && kind > 47)\n                     kind = 47;\n                  break;\n               case 38:\n                  if ((0x3ff008000000000L & l) == 0L)\n                     break;\n                  if (kind > 92)\n                     kind = 92;\n                  { jjCheckNAdd(38); }\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else if (curChar < 128)\n      {\n         long l = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 40:\n                  if ((0x7fffffe87fffffeL & l) != 0L)\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  if ((0x7fffffe87fffffeL & l) != 0L)\n                     { jjCheckNAddTwoStates(6, 7); }\n                  if ((0x7fffffe07fffffeL & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 39:\n                  if ((0xffffffffefffffffL & l) != 0L)\n                     { jjCheckNAddStates(3, 5); }\n                  else if (curChar == 92)\n                     { jjAddStates(20, 21); }\n                  break;\n               case 11:\n                  if ((0x7fffffe07fffffeL & l) != 0L)\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  else if (curChar == 126)\n                     { jjAddStates(22, 24); }\n                  else if (curChar == 96)\n                     { jjCheckNAddTwoStates(14, 15); }\n                  if ((0x7fffffe07fffffeL & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 1:\n                  if ((0xffffffffefffffffL & l) != 0L)\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 3:\n                  if (curChar == 92)\n                     { jjAddStates(20, 21); }\n                  break;\n               case 4:\n                  if (curChar == 92)\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 5:\n                  if ((0x7fffffe07fffffeL & l) != 0L)\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 6:\n                  if ((0x7fffffe87fffffeL & l) != 0L)\n                     { jjCheckNAddTwoStates(6, 7); }\n                  break;\n               case 8:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  { jjAddStates(25, 26); }\n                  break;\n               case 10:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  jjstateSet[jjnewStateCnt++] = 10;\n                  break;\n               case 12:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 89)\n                     kind = 89;\n                  { jjCheckNAdd(12); }\n                  break;\n               case 13:\n                  if (curChar == 96)\n                     { jjCheckNAddTwoStates(14, 15); }\n                  break;\n               case 14:\n                  if ((0xfffffffeffffffffL & l) != 0L)\n                     { jjCheckNAddTwoStates(14, 15); }\n                  break;\n               case 15:\n                  if (curChar != 96)\n                     break;\n                  if (kind > 90)\n                     kind = 90;\n                  jjstateSet[jjnewStateCnt++] = 13;\n                  break;\n               case 17:\n                  if ((0x7fffffe07fffffeL & l) == 0L)\n                     break;\n                  if (kind > 91)\n                     kind = 91;\n                  { jjCheckNAdd(18); }\n                  break;\n               case 18:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 91)\n                     kind = 91;\n                  { jjCheckNAdd(18); }\n                  break;\n               case 27:\n                  if ((0x2000000020L & l) != 0L)\n                     { jjCheckNAddTwoStates(28, 29); }\n                  break;\n               case 28:\n                  if (curChar == 126)\n                     { jjCheckNAdd(29); }\n                  break;\n               case 30:\n                  if (curChar == 126)\n                     { jjAddStates(22, 24); }\n                  break;\n               case 34:\n                  if ((0xffffffffefffffffL & l) != 0L)\n                     { jjCheckNAddStates(17, 19); }\n                  break;\n               case 36:\n                  if (curChar == 92)\n                     { jjAddStates(27, 28); }\n                  break;\n               case 37:\n                  if (curChar == 92)\n                     { jjCheckNAddStates(17, 19); }\n                  break;\n               case 38:\n                  if ((0x7fffffe87fffffeL & l) == 0L)\n                     break;\n                  if (kind > 92)\n                     kind = 92;\n                  jjstateSet[jjnewStateCnt++] = 38;\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else\n      {\n         int hiByte = (curChar >> 8);\n         int i1 = hiByte >> 6;\n         long l1 = 1L << (hiByte & 077);\n         int i2 = (curChar & 0xff) >> 6;\n         long l2 = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 40:\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddStates(0, 2); }\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddTwoStates(6, 7); }\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  break;\n               case 39:\n               case 1:\n                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddStates(3, 5); }\n                  break;\n               case 11:\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddStates(0, 2); }\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                  {\n                     if (kind > 89)\n                        kind = 89;\n                     { jjCheckNAdd(12); }\n                  }\n                  break;\n               case 5:\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddStates(0, 2); }\n                  break;\n               case 6:\n                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     { jjCheckNAddTwoStates(6, 7); }\n                  break;\n               case 8:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  { jjAddStates(25, 26); }\n                  break;\n               case 10:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 88)\n                     kind = 88;\n                  jjstateSet[jjnewStateCnt++] = 10;\n                  break;\n               case 12:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 89)\n                     kind = 89;\n                  { jjCheckNAdd(12); }\n                  break;\n               case 14:\n                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                     { jjAddStates(15, 16); }\n                  break;\n               case 17:\n               case 18:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 91)\n                     kind = 91;\n                  { jjCheckNAdd(18); }\n                  break;\n               case 34:\n                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                     { jjAddStates(17, 19); }\n                  break;\n               case 38:\n                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))\n                     break;\n                  if (kind > 92)\n                     kind = 92;\n                  jjstateSet[jjnewStateCnt++] = 38;\n                  break;\n               default : if (i1 == 0 || l1 == 0 || i2 == 0 ||  l2 == 0) break; else break;\n            }\n         } while(i != startsAt);\n      }\n      if (kind != 0x7fffffff)\n      {\n         jjmatchedKind = kind;\n         jjmatchedPos = curPos;\n         kind = 0x7fffffff;\n      }\n      ++curPos;\n      if ((i = jjnewStateCnt) == (startsAt = 39 - (jjnewStateCnt = startsAt)))\n         return curPos;\n      try { curChar = input_stream.readChar(); }\n      catch(java.io.IOException e) { return curPos; }\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa0_1()", "name": "jjMoveStringLiteralDfa0_1", "arg_nums": 0, "params": [], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa0_1()", "original_string": "private int jjMoveStringLiteralDfa0_1()\n{\n   return jjMoveNfa_1(0, 0);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveNfa_1(int,int)", "name": "jjMoveNfa_1", "arg_nums": 2, "params": [{"name": "startState", "type": "int"}, {"name": "curPos", "type": "int"}], "return_type": "int", "signature": "private int jjMoveNfa_1(int startState, int curPos)", "original_string": "private int jjMoveNfa_1(int startState, int curPos)\n{\n   int startsAt = 0;\n   jjnewStateCnt = 3;\n   int i = 1;\n   jjstateSet[0] = startState;\n   int kind = 0x7fffffff;\n   for (;;)\n   {\n      if (++jjround == 0x7fffffff)\n         ReInitRounds();\n      if (curChar < 64)\n      {\n         long l = 1L << curChar;\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 0:\n                  if ((0x2400L & l) != 0L)\n                  {\n                     if (kind > 85)\n                        kind = 85;\n                  }\n                  if (curChar == 13)\n                     jjstateSet[jjnewStateCnt++] = 1;\n                  break;\n               case 1:\n                  if (curChar == 10 && kind > 85)\n                     kind = 85;\n                  break;\n               case 2:\n                  if (curChar == 13)\n                     jjstateSet[jjnewStateCnt++] = 1;\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else if (curChar < 128)\n      {\n         long l = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else\n      {\n         int hiByte = (curChar >> 8);\n         int i1 = hiByte >> 6;\n         long l1 = 1L << (hiByte & 077);\n         int i2 = (curChar & 0xff) >> 6;\n         long l2 = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               default : if (i1 == 0 || l1 == 0 || i2 == 0 ||  l2 == 0) break; else break;\n            }\n         } while(i != startsAt);\n      }\n      if (kind != 0x7fffffff)\n      {\n         jjmatchedKind = kind;\n         jjmatchedPos = curPos;\n         kind = 0x7fffffff;\n      }\n      ++curPos;\n      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))\n         return curPos;\n      try { curChar = input_stream.readChar(); }\n      catch(java.io.IOException e) { return curPos; }\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveStringLiteralDfa0_2()", "name": "jjMoveStringLiteralDfa0_2", "arg_nums": 0, "params": [], "return_type": "int", "signature": "private int jjMoveStringLiteralDfa0_2()", "original_string": "private int jjMoveStringLiteralDfa0_2()\n{\n   return jjMoveNfa_2(0, 0);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[int]jjMoveNfa_2(int,int)", "name": "jjMoveNfa_2", "arg_nums": 2, "params": [{"name": "startState", "type": "int"}, {"name": "curPos", "type": "int"}], "return_type": "int", "signature": "private int jjMoveNfa_2(int startState, int curPos)", "original_string": "private int jjMoveNfa_2(int startState, int curPos)\n{\n   int startsAt = 0;\n   jjnewStateCnt = 3;\n   int i = 1;\n   jjstateSet[0] = startState;\n   int kind = 0x7fffffff;\n   for (;;)\n   {\n      if (++jjround == 0x7fffffff)\n         ReInitRounds();\n      if (curChar < 64)\n      {\n         long l = 1L << curChar;\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 0:\n                  if ((0xfffffeffffffffffL & l) != 0L)\n                     jjstateSet[jjnewStateCnt++] = 2;\n                  break;\n               case 1:\n                  if (curChar == 41 && kind > 86)\n                     kind = 86;\n                  break;\n               case 2:\n                  if (curChar == 42)\n                     jjstateSet[jjnewStateCnt++] = 1;\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else if (curChar < 128)\n      {\n         long l = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 0:\n                  jjstateSet[jjnewStateCnt++] = 2;\n                  break;\n               default : break;\n            }\n         } while(i != startsAt);\n      }\n      else\n      {\n         int hiByte = (curChar >> 8);\n         int i1 = hiByte >> 6;\n         long l1 = 1L << (hiByte & 077);\n         int i2 = (curChar & 0xff) >> 6;\n         long l2 = 1L << (curChar & 077);\n         do\n         {\n            switch(jjstateSet[--i])\n            {\n               case 0:\n                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n                     jjstateSet[jjnewStateCnt++] = 2;\n                  break;\n               default : if (i1 == 0 || l1 == 0 || i2 == 0 ||  l2 == 0) break; else break;\n            }\n         } while(i != startsAt);\n      }\n      if (kind != 0x7fffffff)\n      {\n         jjmatchedKind = kind;\n         jjmatchedPos = curPos;\n         kind = 0x7fffffff;\n      }\n      ++curPos;\n      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))\n         return curPos;\n      try { curChar = input_stream.readChar(); }\n      catch(java.io.IOException e) { return curPos; }\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[Token]jjFillToken()", "name": "jjFillToken", "arg_nums": 0, "params": [], "return_type": "Token", "signature": "protected Token jjFillToken()", "original_string": "protected Token jjFillToken()\n{\n   final Token t;\n   final String curTokenImage;\n   final int beginLine;\n   final int endLine;\n   final int beginColumn;\n   final int endColumn;\n   String im = jjstrLiteralImages[jjmatchedKind];\n   curTokenImage = (im == null) ? input_stream.GetImage() : im;\n   beginLine = input_stream.getBeginLine();\n   beginColumn = input_stream.getBeginColumn();\n   endLine = input_stream.getEndLine();\n   endColumn = input_stream.getEndColumn();\n   t = Token.newToken(jjmatchedKind, curTokenImage);\n\n   t.beginLine = beginLine;\n   t.endLine = endLine;\n   t.beginColumn = beginColumn;\n   t.endColumn = endColumn;\n\n   return t;\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Token", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[boolean]jjCanMove_0(int,int,int,long,long)", "name": "jjCanMove_0", "arg_nums": 5, "params": [{"name": "hiByte", "type": "int"}, {"name": "i1", "type": "int"}, {"name": "i2", "type": "int"}, {"name": "l1", "type": "long"}, {"name": "l2", "type": "long"}], "return_type": "boolean", "signature": "private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)", "original_string": "private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n{\n   switch(hiByte)\n   {\n      case 0:\n         return ((jjbitVec2[i2] & l2) != 0L);\n      default :\n         if ((jjbitVec0[i1] & l1) != 0L)\n            return true;\n         return false;\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[boolean]jjCanMove_1(int,int,int,long,long)", "name": "jjCanMove_1", "arg_nums": 5, "params": [{"name": "hiByte", "type": "int"}, {"name": "i1", "type": "int"}, {"name": "i2", "type": "int"}, {"name": "l1", "type": "long"}, {"name": "l2", "type": "long"}], "return_type": "boolean", "signature": "private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)", "original_string": "private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)\n{\n   switch(hiByte)\n   {\n      case 0:\n         return ((jjbitVec4[i2] & l2) != 0L);\n      case 48:\n         return ((jjbitVec5[i2] & l2) != 0L);\n      case 49:\n         return ((jjbitVec6[i2] & l2) != 0L);\n      case 51:\n         return ((jjbitVec7[i2] & l2) != 0L);\n      case 61:\n         return ((jjbitVec8[i2] & l2) != 0L);\n      default :\n         if ((jjbitVec3[i1] & l1) != 0L)\n            return true;\n         return false;\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[Token]getNextToken()", "name": "getNextToken", "arg_nums": 0, "params": [], "return_type": "Token", "signature": "public Token getNextToken()", "original_string": "public Token getNextToken() \n{\n  Token specialToken = null;\n  Token matchedToken;\n  int curPos = 0;\n\n  EOFLoop :\n  for (;;)\n  {\n   try\n   {\n      curChar = input_stream.BeginToken();\n   }\n   catch(Exception e)\n   {\n      jjmatchedKind = 0;\n      jjmatchedPos = -1;\n      matchedToken = jjFillToken();\n      matchedToken.specialToken = specialToken;\n      return matchedToken;\n   }\n   image = jjimage;\n   image.setLength(0);\n   jjimageLen = 0;\n\n   for (;;)\n   {\n     switch(curLexState)\n     {\n       case 0:\n         try { input_stream.backup(0);\n            while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L)\n               curChar = input_stream.BeginToken();\n         }\n         catch (java.io.IOException e1) { continue EOFLoop; }\n         jjmatchedKind = 0x7fffffff;\n         jjmatchedPos = 0;\n         curPos = jjMoveStringLiteralDfa0_0();\n         break;\n       case 1:\n         jjmatchedKind = 0x7fffffff;\n         jjmatchedPos = 0;\n         curPos = jjMoveStringLiteralDfa0_1();\n         if (jjmatchedPos == 0 && jjmatchedKind > 87)\n         {\n            jjmatchedKind = 87;\n         }\n         break;\n       case 2:\n         jjmatchedKind = 0x7fffffff;\n         jjmatchedPos = 0;\n         curPos = jjMoveStringLiteralDfa0_2();\n         if (jjmatchedPos == 0 && jjmatchedKind > 87)\n         {\n            jjmatchedKind = 87;\n         }\n         break;\n     }\n     if (jjmatchedKind != 0x7fffffff)\n     {\n        if (jjmatchedPos + 1 < curPos)\n           input_stream.backup(curPos - jjmatchedPos - 1);\n        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n        {\n           matchedToken = jjFillToken();\n           matchedToken.specialToken = specialToken;\n       if (jjnewLexState[jjmatchedKind] != -1)\n         curLexState = jjnewLexState[jjmatchedKind];\n           return matchedToken;\n        }\n        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n        {\n           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)\n           {\n              matchedToken = jjFillToken();\n              if (specialToken == null)\n                 specialToken = matchedToken;\n              else\n              {\n                 matchedToken.specialToken = specialToken;\n                 specialToken = (specialToken.next = matchedToken);\n              }\n              SkipLexicalActions(matchedToken);\n           }\n           else\n              SkipLexicalActions(null);\n         if (jjnewLexState[jjmatchedKind] != -1)\n           curLexState = jjnewLexState[jjmatchedKind];\n           continue EOFLoop;\n        }\n        MoreLexicalActions();\n      if (jjnewLexState[jjmatchedKind] != -1)\n        curLexState = jjnewLexState[jjmatchedKind];\n        curPos = 0;\n        jjmatchedKind = 0x7fffffff;\n        try {\n           curChar = input_stream.readChar();\n           continue;\n        }\n        catch (java.io.IOException e1) { }\n     }\n     int error_line = input_stream.getEndLine();\n     int error_column = input_stream.getEndColumn();\n     String error_after = null;\n     boolean EOFSeen = false;\n     try { input_stream.readChar(); input_stream.backup(1); }\n     catch (java.io.IOException e1) {\n        EOFSeen = true;\n        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n        if (curChar == '\\n' || curChar == '\\r') {\n           error_line++;\n           error_column = 0;\n        }\n        else\n           error_column++;\n     }\n     if (!EOFSeen) {\n        input_stream.backup(1);\n        error_after = curPos <= 1 ? \"\" : input_stream.GetImage();\n     }\n     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);\n   }\n  }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Token", "classes": []}, "docstring": " Get the next Token."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]SkipLexicalActions(Token)", "name": "SkipLexicalActions", "arg_nums": 1, "params": [{"name": "matchedToken", "type": "Token"}], "return_type": "void", "signature": "void SkipLexicalActions(Token matchedToken)", "original_string": "void SkipLexicalActions(Token matchedToken)\n{\n   switch(jjmatchedKind)\n   {\n      case 85 :\n         image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));\n                                                   popState();\n         break;\n      case 86 :\n         image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));\n                                   popState();\n         break;\n      default :\n         break;\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]MoreLexicalActions()", "name": "MoreLexicalActions", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void MoreLexicalActions()", "original_string": "void MoreLexicalActions()\n{\n   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);\n   switch(jjmatchedKind)\n   {\n      case 83 :\n         image.append(input_stream.GetSuffix(jjimageLen));\n         jjimageLen = 0;\n            pushState();\n         break;\n      case 84 :\n         image.append(input_stream.GetSuffix(jjimageLen));\n         jjimageLen = 0;\n           pushState();\n         break;\n      default :\n         break;\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]TokenLexicalActions(Token)", "name": "TokenLexicalActions", "arg_nums": 1, "params": [{"name": "matchedToken", "type": "Token"}], "return_type": "void", "signature": "void TokenLexicalActions(Token matchedToken)", "original_string": "void TokenLexicalActions(Token matchedToken)\n{\n   switch(jjmatchedKind)\n   {\n      default :\n         break;\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]jjCheckNAdd(int)", "name": "jjCheckNAdd", "arg_nums": 1, "params": [{"name": "state", "type": "int"}], "return_type": "void", "signature": "private void jjCheckNAdd(int state)", "original_string": "private void jjCheckNAdd(int state)\n{\n   if (jjrounds[state] != jjround)\n   {\n      jjstateSet[jjnewStateCnt++] = state;\n      jjrounds[state] = jjround;\n   }\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]jjAddStates(int,int)", "name": "jjAddStates", "arg_nums": 2, "params": [{"name": "start", "type": "int"}, {"name": "end", "type": "int"}], "return_type": "void", "signature": "private void jjAddStates(int start, int end)", "original_string": "private void jjAddStates(int start, int end)\n{\n   do {\n      jjstateSet[jjnewStateCnt++] = jjnextStates[start];\n   } while (start++ != end);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]jjCheckNAddTwoStates(int,int)", "name": "jjCheckNAddTwoStates", "arg_nums": 2, "params": [{"name": "state1", "type": "int"}, {"name": "state2", "type": "int"}], "return_type": "void", "signature": "private void jjCheckNAddTwoStates(int state1, int state2)", "original_string": "private void jjCheckNAddTwoStates(int state1, int state2)\n{\n   jjCheckNAdd(state1);\n   jjCheckNAdd(state2);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]jjCheckNAddStates(int,int)", "name": "jjCheckNAddStates", "arg_nums": 2, "params": [{"name": "start", "type": "int"}, {"name": "end", "type": "int"}], "return_type": "void", "signature": "private void jjCheckNAddStates(int start, int end)", "original_string": "private void jjCheckNAddStates(int start, int end)\n{\n   do {\n      jjCheckNAdd(jjnextStates[start]);\n   } while (start++ != end);\n}", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[]MorelParserImplTokenManager(SimpleCharStream)", "name": "MorelParserImplTokenManager", "arg_nums": 1, "params": [{"name": "stream", "type": "SimpleCharStream"}], "return_type": "", "signature": "public MorelParserImplTokenManager(SimpleCharStream stream)", "original_string": "    public MorelParserImplTokenManager(SimpleCharStream stream){\n\n      if (SimpleCharStream.staticFlag)\n            throw new Error(\"ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.\");\n\n    input_stream = stream;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[]MorelParserImplTokenManager(SimpleCharStream,int)", "name": "MorelParserImplTokenManager", "arg_nums": 2, "params": [{"name": "stream", "type": "SimpleCharStream"}, {"name": "lexState", "type": "int"}], "return_type": "", "signature": "public MorelParserImplTokenManager (SimpleCharStream stream, int lexState)", "original_string": "  public MorelParserImplTokenManager (SimpleCharStream stream, int lexState){\n    ReInit(stream);\n    SwitchTo(lexState);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]ReInit(SimpleCharStream)", "name": "ReInit", "arg_nums": 1, "params": [{"name": "stream", "type": "SimpleCharStream"}], "return_type": "void", "signature": "public void ReInit(SimpleCharStream stream)", "original_string": "  public void ReInit(SimpleCharStream stream)\n  {\n\n\n    jjmatchedPos =\n    jjnewStateCnt =\n    0;\n    curLexState = defaultLexState;\n    input_stream = stream;\n    ReInitRounds();\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise parser."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]ReInitRounds()", "name": "ReInitRounds", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void ReInitRounds()", "original_string": "  private void ReInitRounds()\n  {\n    int i;\n    jjround = 0x80000001;\n    for (i = 39; i-- > 0;)\n      jjrounds[i] = 0x80000000;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]ReInit(SimpleCharStream,int)", "name": "ReInit", "arg_nums": 2, "params": [{"name": "stream", "type": "SimpleCharStream"}, {"name": "lexState", "type": "int"}], "return_type": "void", "signature": "public void ReInit(SimpleCharStream stream, int lexState)", "original_string": "  public void ReInit(SimpleCharStream stream, int lexState)\n  \n  {\n    ReInit(stream);\n    SwitchTo(lexState);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise parser."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager.[void]SwitchTo(int)", "name": "SwitchTo", "arg_nums": 1, "params": [{"name": "lexState", "type": "int"}], "return_type": "void", "signature": "public void SwitchTo(int lexState)", "original_string": "  public void SwitchTo(int lexState)\n  {\n    if (lexState >= 3 || lexState < 0)\n      throw new TokenMgrError(\"Error: Ignoring invalid lexical state : \" + lexState + \". State unchanged.\", TokenMgrError.INVALID_LEXICAL_STATE);\n    else\n      curLexState = lexState;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java", "class_name": "MorelParserImplTokenManager", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/MorelParserImplTokenManager.java.MorelParserImplTokenManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Switch to specified lex state."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]setTabSize(int)", "name": "setTabSize", "arg_nums": 1, "params": [{"name": "i", "type": "int"}], "return_type": "void", "signature": "public void setTabSize(int i)", "original_string": "  public void setTabSize(int i) { tabSize = i; }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getTabSize()", "name": "getTabSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getTabSize()", "original_string": "  public int getTabSize() { return tabSize; }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ExpandBuff(boolean)", "name": "ExpandBuff", "arg_nums": 1, "params": [{"name": "wrapAround", "type": "boolean"}], "return_type": "void", "signature": "protected void ExpandBuff(boolean wrapAround)", "original_string": "  protected void ExpandBuff(boolean wrapAround)\n  {\n    char[] newbuffer = new char[bufsize + 2048];\n    int newbufline[] = new int[bufsize + 2048];\n    int newbufcolumn[] = new int[bufsize + 2048];\n\n    try\n    {\n      if (wrapAround)\n      {\n        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);\n        buffer = newbuffer;\n\n        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);\n        bufline = newbufline;\n\n        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);\n        bufcolumn = newbufcolumn;\n\n        maxNextCharInd = (bufpos += (bufsize - tokenBegin));\n      }\n      else\n      {\n        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);\n        buffer = newbuffer;\n\n        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);\n        bufline = newbufline;\n\n        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);\n        bufcolumn = newbufcolumn;\n\n        maxNextCharInd = (bufpos -= tokenBegin);\n      }\n    }\n    catch (Throwable t)\n    {\n      throw new Error(t.getMessage());\n    }\n\n\n    bufsize += 2048;\n    available = bufsize;\n    tokenBegin = 0;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]FillBuff()", "name": "FillBuff", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void FillBuff()", "original_string": "  protected void FillBuff() throws java.io.IOException\n  {\n    if (maxNextCharInd == available)\n    {\n      if (available == bufsize)\n      {\n        if (tokenBegin > 2048)\n        {\n          bufpos = maxNextCharInd = 0;\n          available = tokenBegin;\n        }\n        else if (tokenBegin < 0)\n          bufpos = maxNextCharInd = 0;\n        else\n          ExpandBuff(false);\n      }\n      else if (available > tokenBegin)\n        available = bufsize;\n      else if ((tokenBegin - available) < 2048)\n        ExpandBuff(true);\n      else\n        available = tokenBegin;\n    }\n\n    int i;\n    try {\n      if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1)\n      {\n        inputStream.close();\n        throw new java.io.IOException();\n      }\n      else\n        maxNextCharInd += i;\n      return;\n    }\n    catch(java.io.IOException e) {\n      --bufpos;\n      backup(0);\n      if (tokenBegin == -1)\n        tokenBegin = bufpos;\n      throw e;\n    }\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[char]BeginToken()", "name": "BeginToken", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char BeginToken()", "original_string": "  public char BeginToken() throws java.io.IOException\n  {\n    tokenBegin = -1;\n    char c = readChar();\n    tokenBegin = bufpos;\n\n    return c;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": " Start."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]UpdateLineColumn(char)", "name": "UpdateLineColumn", "arg_nums": 1, "params": [{"name": "c", "type": "char"}], "return_type": "void", "signature": "protected void UpdateLineColumn(char c)", "original_string": "  protected void UpdateLineColumn(char c)\n  {\n    column++;\n\n    if (prevCharIsLF)\n    {\n      prevCharIsLF = false;\n      line += (column = 1);\n    }\n    else if (prevCharIsCR)\n    {\n      prevCharIsCR = false;\n      if (c == '\\n')\n      {\n        prevCharIsLF = true;\n      }\n      else\n        line += (column = 1);\n    }\n\n    switch (c)\n    {\n      case '\\r' :\n        prevCharIsCR = true;\n        break;\n      case '\\n' :\n        prevCharIsLF = true;\n        break;\n      case '\\t' :\n        column--;\n        column += (tabSize - (column % tabSize));\n        break;\n      default :\n        break;\n    }\n\n    bufline[bufpos] = line;\n    bufcolumn[bufpos] = column;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[char]readChar()", "name": "readChar", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char readChar()", "original_string": "  public char readChar() throws java.io.IOException\n  {\n    if (inBuf > 0)\n    {\n      --inBuf;\n\n      if (++bufpos == bufsize)\n        bufpos = 0;\n\n      return buffer[bufpos];\n    }\n\n    if (++bufpos >= maxNextCharInd)\n      FillBuff();\n\n    char c = buffer[bufpos];\n\n    UpdateLineColumn(c);\n    return c;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": " Read a character."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getColumn()", "name": "getColumn", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Deprecated\n  public int getColumn()", "original_string": "  @Deprecated\n  public int getColumn() {\n    return bufcolumn[bufpos];\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "@Deprecated\n  public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n@deprecated\n@see #getEndColumn\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getLine()", "name": "getLine", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Deprecated\n  public int getLine()", "original_string": "  @Deprecated\n  public int getLine() {\n    return bufline[bufpos];\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "@Deprecated\n  public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n@deprecated\n@see #getEndLine\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getEndColumn()", "name": "getEndColumn", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getEndColumn()", "original_string": "  public int getEndColumn() {\n    return bufcolumn[bufpos];\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Get token end column number."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getEndLine()", "name": "getEndLine", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getEndLine()", "original_string": "  public int getEndLine() {\n     return bufline[bufpos];\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Get token end line number."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getBeginColumn()", "name": "getBeginColumn", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getBeginColumn()", "original_string": "  public int getBeginColumn() {\n    return bufcolumn[tokenBegin];\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Get token beginning column number."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[int]getBeginLine()", "name": "getBeginLine", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getBeginLine()", "original_string": "  public int getBeginLine() {\n    return bufline[tokenBegin];\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": " Get token beginning line number."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]backup(int)", "name": "backup", "arg_nums": 1, "params": [{"name": "amount", "type": "int"}], "return_type": "void", "signature": "public void backup(int amount)", "original_string": "  public void backup(int amount) {\n\n    inBuf += amount;\n    if ((bufpos -= amount) < 0)\n      bufpos += bufsize;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Backup a number of characters."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.Reader,int,int,int)", "name": "SimpleCharStream", "arg_nums": 4, "params": [{"name": "dstream", "type": "java.io.Reader"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}, {"name": "buffersize", "type": "int"}], "return_type": "", "signature": "public SimpleCharStream(java.io.Reader dstream, int startline,\n  int startcolumn, int buffersize)", "original_string": "  public SimpleCharStream(java.io.Reader dstream, int startline,\n  int startcolumn, int buffersize)\n  {\n    inputStream = dstream;\n    line = startline;\n    column = startcolumn - 1;\n\n    available = bufsize = buffersize;\n    buffer = new char[buffersize];\n    bufline = new int[buffersize];\n    bufcolumn = new int[buffersize];\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.Reader,int,int)", "name": "SimpleCharStream", "arg_nums": 3, "params": [{"name": "dstream", "type": "java.io.Reader"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}], "return_type": "", "signature": "public SimpleCharStream(java.io.Reader dstream, int startline,\n                          int startcolumn)", "original_string": "  public SimpleCharStream(java.io.Reader dstream, int startline,\n                          int startcolumn)\n  {\n    this(dstream, startline, startcolumn, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.Reader)", "name": "SimpleCharStream", "arg_nums": 1, "params": [{"name": "dstream", "type": "java.io.Reader"}], "return_type": "", "signature": "public SimpleCharStream(java.io.Reader dstream)", "original_string": "  public SimpleCharStream(java.io.Reader dstream)\n  {\n    this(dstream, 1, 1, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.Reader,int,int,int)", "name": "ReInit", "arg_nums": 4, "params": [{"name": "dstream", "type": "java.io.Reader"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}, {"name": "buffersize", "type": "int"}], "return_type": "void", "signature": "public void ReInit(java.io.Reader dstream, int startline,\n  int startcolumn, int buffersize)", "original_string": "  public void ReInit(java.io.Reader dstream, int startline,\n  int startcolumn, int buffersize)\n  {\n    inputStream = dstream;\n    line = startline;\n    column = startcolumn - 1;\n\n    if (buffer == null || buffersize != buffer.length)\n    {\n      available = bufsize = buffersize;\n      buffer = new char[buffersize];\n      bufline = new int[buffersize];\n      bufcolumn = new int[buffersize];\n    }\n    prevCharIsLF = prevCharIsCR = false;\n    tokenBegin = inBuf = maxNextCharInd = 0;\n    bufpos = -1;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.Reader,int,int)", "name": "ReInit", "arg_nums": 3, "params": [{"name": "dstream", "type": "java.io.Reader"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}], "return_type": "void", "signature": "public void ReInit(java.io.Reader dstream, int startline,\n                     int startcolumn)", "original_string": "  public void ReInit(java.io.Reader dstream, int startline,\n                     int startcolumn)\n  {\n    ReInit(dstream, startline, startcolumn, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.Reader)", "name": "ReInit", "arg_nums": 1, "params": [{"name": "dstream", "type": "java.io.Reader"}], "return_type": "void", "signature": "public void ReInit(java.io.Reader dstream)", "original_string": "  public void ReInit(java.io.Reader dstream)\n  {\n    ReInit(dstream, 1, 1, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,String,int,int,int)", "name": "SimpleCharStream", "arg_nums": 5, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "encoding", "type": "String"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}, {"name": "buffersize", "type": "int"}], "return_type": "", "signature": "public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n  int startcolumn, int buffersize)", "original_string": "  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n  {\n    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,int,int,int)", "name": "SimpleCharStream", "arg_nums": 4, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}, {"name": "buffersize", "type": "int"}], "return_type": "", "signature": "public SimpleCharStream(java.io.InputStream dstream, int startline,\n  int startcolumn, int buffersize)", "original_string": "  public SimpleCharStream(java.io.InputStream dstream, int startline,\n  int startcolumn, int buffersize)\n  {\n    this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,String,int,int)", "name": "SimpleCharStream", "arg_nums": 4, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "encoding", "type": "String"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}], "return_type": "", "signature": "public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n                          int startcolumn)", "original_string": "  public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline,\n                          int startcolumn) throws java.io.UnsupportedEncodingException\n  {\n    this(dstream, encoding, startline, startcolumn, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,int,int)", "name": "SimpleCharStream", "arg_nums": 3, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}], "return_type": "", "signature": "public SimpleCharStream(java.io.InputStream dstream, int startline,\n                          int startcolumn)", "original_string": "  public SimpleCharStream(java.io.InputStream dstream, int startline,\n                          int startcolumn)\n  {\n    this(dstream, startline, startcolumn, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream,String)", "name": "SimpleCharStream", "arg_nums": 2, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "encoding", "type": "String"}], "return_type": "", "signature": "public SimpleCharStream(java.io.InputStream dstream, String encoding)", "original_string": "  public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n  {\n    this(dstream, encoding, 1, 1, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[]SimpleCharStream(java.io.InputStream)", "name": "SimpleCharStream", "arg_nums": 1, "params": [{"name": "dstream", "type": "java.io.InputStream"}], "return_type": "", "signature": "public SimpleCharStream(java.io.InputStream dstream)", "original_string": "  public SimpleCharStream(java.io.InputStream dstream)\n  {\n    this(dstream, 1, 1, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": " Constructor."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,String,int,int,int)", "name": "ReInit", "arg_nums": 5, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "encoding", "type": "String"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}, {"name": "buffersize", "type": "int"}], "return_type": "void", "signature": "public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n                          int startcolumn, int buffersize)", "original_string": "  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n                          int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n  {\n    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,int,int,int)", "name": "ReInit", "arg_nums": 4, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}, {"name": "buffersize", "type": "int"}], "return_type": "void", "signature": "public void ReInit(java.io.InputStream dstream, int startline,\n                          int startcolumn, int buffersize)", "original_string": "  public void ReInit(java.io.InputStream dstream, int startline,\n                          int startcolumn, int buffersize)\n  {\n    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,String)", "name": "ReInit", "arg_nums": 2, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "encoding", "type": "String"}], "return_type": "void", "signature": "public void ReInit(java.io.InputStream dstream, String encoding)", "original_string": "  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException\n  {\n    ReInit(dstream, encoding, 1, 1, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream)", "name": "ReInit", "arg_nums": 1, "params": [{"name": "dstream", "type": "java.io.InputStream"}], "return_type": "void", "signature": "public void ReInit(java.io.InputStream dstream)", "original_string": "  public void ReInit(java.io.InputStream dstream)\n  {\n    ReInit(dstream, 1, 1, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,String,int,int)", "name": "ReInit", "arg_nums": 4, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "encoding", "type": "String"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}], "return_type": "void", "signature": "public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n                     int startcolumn)", "original_string": "  public void ReInit(java.io.InputStream dstream, String encoding, int startline,\n                     int startcolumn) throws java.io.UnsupportedEncodingException\n  {\n    ReInit(dstream, encoding, startline, startcolumn, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]ReInit(java.io.InputStream,int,int)", "name": "ReInit", "arg_nums": 3, "params": [{"name": "dstream", "type": "java.io.InputStream"}, {"name": "startline", "type": "int"}, {"name": "startcolumn", "type": "int"}], "return_type": "void", "signature": "public void ReInit(java.io.InputStream dstream, int startline,\n                     int startcolumn)", "original_string": "  public void ReInit(java.io.InputStream dstream, int startline,\n                     int startcolumn)\n  {\n    ReInit(dstream, startline, startcolumn, 4096);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reinitialise."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[String]GetImage()", "name": "GetImage", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String GetImage()", "original_string": "  public String GetImage()\n  {\n    if (bufpos >= tokenBegin)\n      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);\n    else\n      return new String(buffer, tokenBegin, bufsize - tokenBegin) +\n                            new String(buffer, 0, bufpos + 1);\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Get token literal value."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[char[]]GetSuffix(int)", "name": "GetSuffix", "arg_nums": 1, "params": [{"name": "len", "type": "int"}], "return_type": "char[]", "signature": "public char[] GetSuffix(int len)", "original_string": "  public char[] GetSuffix(int len)\n  {\n    char[] ret = new char[len];\n\n    if ((bufpos + 1) >= len)\n      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);\n    else\n    {\n      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,\n                                                        len - bufpos - 1);\n      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);\n    }\n\n    return ret;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char[]", "classes": []}, "docstring": " Get the suffix."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]Done()", "name": "Done", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void Done()", "original_string": "  public void Done()\n  {\n    buffer = null;\n    bufline = null;\n    bufcolumn = null;\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Reset buffer when finished."}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]adjustBeginLineColumn(int,int)", "name": "adjustBeginLineColumn", "arg_nums": 2, "params": [{"name": "newLine", "type": "int"}, {"name": "newCol", "type": "int"}], "return_type": "void", "signature": "public void adjustBeginLineColumn(int newLine, int newCol)", "original_string": "  public void adjustBeginLineColumn(int newLine, int newCol)\n  {\n    int start = tokenBegin;\n    int len;\n\n    if (bufpos >= tokenBegin)\n    {\n      len = bufpos - tokenBegin + inBuf + 1;\n    }\n    else\n    {\n      len = bufsize - tokenBegin + bufpos + 1 + inBuf;\n    }\n\n    int i = 0, j = 0, k = 0;\n    int nextColDiff = 0, columnDiff = 0;\n\n    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])\n    {\n      bufline[j] = newLine;\n      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\n      bufcolumn[j] = newCol + columnDiff;\n      columnDiff = nextColDiff;\n      i++;\n    }\n\n    if (i < len)\n    {\n      bufline[j] = newLine++;\n      bufcolumn[j] = newCol + columnDiff;\n\n      while (i++ < len)\n      {\n        if (bufline[j = start % bufsize] != bufline[++start % bufsize])\n          bufline[j] = newLine++;\n        else\n          bufline[j] = newLine;\n      }\n    }\n\n    line = bufline[j];\n    column = bufcolumn[j];\n  }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMethod to adjust line and column numbers for the start of a token.\n"}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[boolean]getTrackLineColumn()", "name": "getTrackLineColumn", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "boolean getTrackLineColumn()", "original_string": "  boolean getTrackLineColumn() { return trackLineColumn; }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream.[void]setTrackLineColumn(boolean)", "name": "setTrackLineColumn", "arg_nums": 1, "params": [{"name": "tlc", "type": "boolean"}], "return_type": "void", "signature": "void setTrackLineColumn(boolean tlc)", "original_string": "  void setTrackLineColumn(boolean tlc) { trackLineColumn = tlc; }", "default_arguments": null, "file": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java", "class_name": "SimpleCharStream", "class_uri": "target/generated-sources/javacc/net/hydromatic/morel/parse/SimpleCharStream.java.SimpleCharStream", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}]