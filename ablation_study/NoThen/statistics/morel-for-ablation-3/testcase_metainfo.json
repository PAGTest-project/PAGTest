[{"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testBasic()", "name": "testBasic", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testBasic()", "original_string": "  @Test void testBasic() {\n    // from i in [1, 2]\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, f.list12);\n\n    final Core.From from = fromBuilder.build();\n    assertThat(from, hasToString(\"from i in [1, 2]\"));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, hasToString(\"[1, 2]\"));\n\n    // \"from i in [1, 2] yield i\" --> \"[1, 2]\"\n    fromBuilder.yield_(f.iId);\n    final Core.From from2 = fromBuilder.build();\n    assertThat(from2, is(from));\n    final Core.Exp e2 = fromBuilder.buildSimplify();\n    assertThat(e2, is(e));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testWhereOrder()", "name": "testWhereOrder", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testWhereOrder()", "original_string": "  @Test void testWhereOrder() {\n    // from i in [1, 2] where i < 2 order i desc\n    //  ==>\n    // from i in [1, 2]\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, f.list12)\n        .where(core.lessThan(f.typeSystem, f.iId, f.intLiteral(2)))\n        .order(ImmutableList.of(core.orderItem(f.iId, Ast.Direction.DESC)));\n\n    final Core.From from = fromBuilder.build();\n    assertThat(from.toString(),\n        is(\"from i in [1, 2] where i < 2 order i desc\"));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n\n    // \"where true\" and \"order {}\" are ignored\n    fromBuilder.where(core.boolLiteral(true))\n        .order(ImmutableList.of())\n        .where(core.greaterThan(f.typeSystem, f.iId, f.intLiteral(1)));\n    final Core.From from2 = fromBuilder.build();\n    assertThat(from2.toString(),\n        is(\"from i in [1, 2] where i < 2 order i desc where i > 1\"));\n    final Core.Exp e2 = fromBuilder.buildSimplify();\n    assertThat(e2, is(from2));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testTrivialYield()", "name": "testTrivialYield", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTrivialYield()", "original_string": "  @Test void testTrivialYield() {\n    // from i in [1, 2] where i < 2 yield i\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, f.list12)\n        .where(core.lessThan(f.typeSystem, f.iId, f.intLiteral(2)))\n        .yield_(f.iId);\n\n    final Core.From from = fromBuilder.build();\n    assertThat(from, hasToString(\"from i in [1, 2] where i < 2\"));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testTrivialYield2()", "name": "testTrivialYield2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTrivialYield2()", "original_string": "  @Test void testTrivialYield2() {\n    // from j in [1, 2], i in [3, 4] where i < 2 yield {i, j}\n    //   ==>\n    // from j in [1, 2], i in [3, 4] where i < 2\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.jPat, f.list12)\n        .scan(f.iPat, f.list34)\n        .where(core.lessThan(f.typeSystem, f.iId, f.intLiteral(2)))\n        .yield_(f.record(f.iId, f.jId));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from j in [1, 2] \"\n        + \"join i in [3, 4] \"\n        + \"where i < 2\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testTrivialYield3()", "name": "testTrivialYield3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTrivialYield3()", "original_string": "  @Test void testTrivialYield3() {\n    // from j in [1, 2] yield {j} join i in [3, 4]\n    //   ==>\n    // from j in [1, 2] join i in [3, 4]\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.jPat, f.list12)\n        .yield_(f.record(f.jId))\n        .scan(f.iPat, f.list34);\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from j in [1, 2] \"\n        + \"join i in [3, 4]\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testNested()", "name": "testNested", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNested()", "original_string": "  @Test void testNested() {\n    // from i in (from j in [1, 2] where j < 2) where i > 1\n    //   ==>\n    // from j in [1, 2] where j < 2 yield {i = j} where i > 1\n    final Fixture f = new Fixture();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(f.jPat, f.list12)\n            .where(core.lessThan(f.typeSystem, f.jId, f.intLiteral(2)))\n            .build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, innerFrom)\n        .where(core.greaterThan(f.typeSystem, f.iId, f.intLiteral(1)));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from j in [1, 2] \"\n        + \"where j < 2 \"\n        + \"yield {i = j} \"\n        + \"where i > 1\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testNested3()", "name": "testNested3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNested3()", "original_string": "  @Test void testNested3() {\n    // from i in (from j in [1, 2]) where i > 1\n    //   ==>\n    // from j in [1, 2] yield {i = j} where i > 1\n    final Fixture f = new Fixture();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(f.jPat, f.list12)\n            .build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, innerFrom)\n        .where(core.greaterThan(f.typeSystem, f.iId, f.intLiteral(1)));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from j in [1, 2] yield {i = j} where i > 1\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n\n    // from j in (from j in [1, 2]) where j > 1\n    //   ==>\n    // from j in [1, 2] where j > 1\n    final FromBuilder fromBuilder2 = f.fromBuilder();\n    fromBuilder2.scan(f.jPat, innerFrom)\n        .where(core.greaterThan(f.typeSystem, f.jId, f.intLiteral(1)));\n\n    final Core.From from2 = fromBuilder2.build();\n    final String expected2 = \"from j in [1, 2] where j > 1\";\n    assertThat(from2, hasToString(expected2));\n    final Core.Exp e2 = fromBuilder2.buildSimplify();\n    assertThat(e2, is(from2));\n\n    // from i in (from j in [1, 2])\n    //   ==>\n    // from j in [1, 2]\n    //   ==> simplification\n    // [1, 2]\n    final FromBuilder fromBuilder3 = f.fromBuilder();\n    fromBuilder3.scan(f.iPat, innerFrom);\n\n    final Core.From from3 = fromBuilder3.build();\n    final String expected3 = \"from j in [1, 2]\";\n    assertThat(from3, hasToString(expected3));\n    final Core.Exp e3 = fromBuilder3.buildSimplify();\n    assertThat(e3, is(f.list12));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testNested4()", "name": "testNested4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNested4()", "original_string": "  @Test void testNested4() {\n    // from d in [(1, 2), (3, 4)]\n    // join i in (from i in [#1 d])\n    //   ==>\n    // from d in [(1, 2), (3, 4)]\n    // join i in [#1 d]\n    final Fixture f = new Fixture();\n    final Function<List<Binding>, Core.From> innerFrom = bindings ->\n        core.fromBuilder(f.typeSystem,\n                Environments.empty().bindAll(bindings))\n            .scan(f.iPat,\n                core.list(f.typeSystem,\n                    core.field(f.typeSystem, f.dId, 0)))\n            .build();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder\n        .scan(f.dPat,\n            core.list(f.typeSystem, f.tuple12, f.tuple34))\n        .scan(f.iPat, innerFrom.apply(fromBuilder.bindings()));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from d in [(1, 2), (3, 4)] \"\n        + \"join i in [#1 d]\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n\n    // from d in [(1, 2), (3, 4)]\n    // join j in (from i in [#1 d])\n    // where j > #1 d\n    //   ==>\n    // from d in [(1, 2), (3, 4)]\n    // join i in [#1 d]\n    // yield {d, j = i}\n    // where j > #1 d\n    final FromBuilder fromBuilder2 = f.fromBuilder();\n    fromBuilder2\n        .scan(f.dPat,\n            core.list(f.typeSystem, f.tuple12, f.tuple34))\n        .scan(f.jPat, innerFrom.apply(fromBuilder.bindings()))\n        .where(\n            core.greaterThan(f.typeSystem, f.jId,\n                core.field(f.typeSystem, f.dId, 0)));\n\n    final Core.From from2 = fromBuilder2.build();\n    final String expected2 = \"from d in [(1, 2), (3, 4)] \"\n        + \"join i in [#1 d] \"\n        + \"yield {d = d, j = i} \"\n        + \"where j > #1 d\";\n    assertThat(from2, hasToString(expected2));\n    final Core.Exp e2 = fromBuilder2.buildSimplify();\n    assertThat(e2, is(from2));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testNestedSameName()", "name": "testNestedSameName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNestedSameName()", "original_string": "  @Test void testNestedSameName() {\n    // from i in (from i in [1, 2] where i < 2) where i > 1\n    //   ==>\n    // from i in [1, 2] where i < 2 where i > 1\n    final Fixture f = new Fixture();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(f.iPat, f.list12)\n            .where(core.lessThan(f.typeSystem, f.iId, f.intLiteral(2)))\n            .build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, innerFrom)\n        .where(core.greaterThan(f.typeSystem, f.iId, f.intLiteral(1)));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from i in [1, 2] \"\n        + \"where i < 2 \"\n        + \"where i > 1\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testNested()} but inner and outer variables have the same\nname, and therefore no yield is required."}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testNested0()", "name": "testNested0", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNested0()", "original_string": "  @Test void testNested0() {\n    // from u in (from)\n    //   ==>\n    // from\n    final Fixture f = new Fixture();\n    final Core.From innerFrom = f.fromBuilder().build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.uPat, innerFrom);\n\n    final Core.From from = fromBuilder.build();\n    assertThat(from, hasToString(\"from u in (from)\"));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, hasToString(\"from\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testNested2()", "name": "testNested2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNested2()", "original_string": "  @Test void testNested2() {\n    // from {i = a, j = b} in (from a in [1, 2], b in [3, 4] where a < 2)\n    //   where i < j\n    //   ==>\n    // from a in [1, 2], b in [3, 4] where a < 2 yield {i = a, j = b}\n    //   where i < j\n    final Fixture f = new Fixture();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(f.aPat, f.list12)\n            .scan(f.bPat, f.list34)\n            .where(core.lessThan(f.typeSystem, f.aId, f.intLiteral(2)))\n            .build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(\n        core.recordPat(f.typeSystem, ImmutableSet.of(\"i\", \"j\"),\n            ImmutableList.of(f.aPat, f.bPat)),\n            innerFrom)\n        .where(core.lessThan(f.typeSystem, f.iId, f.jId));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from a in [1, 2] \"\n        + \"join b in [3, 4] \"\n        + \"where a < 2 \"\n        + \"yield {i = a, j = b} \"\n        + \"where i < j\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest.[void]testNestedFromTuple()", "name": "testNestedFromTuple", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNestedFromTuple()", "original_string": "  @Test void testNestedFromTuple() {\n    // from (a, b) in\n    //   (from (a, b) in\n    //     (from a in [1, 2] join b in [3, 4]))\n    // where a > b andalso b = 10\n    // yield b\n    //   ==>\n    // from a in [1, 2]\n    // join b in [3, 4]\n    // where a > b andalso a = 10\n    // yield b\n    final Fixture f = new Fixture();\n    final Core.Pat abPat =\n        core.tuplePat(f.typeSystem, Arrays.asList(f.aPat, f.bPat));\n\n    final Core.From innermostFrom =\n        f.fromBuilder()\n            .scan(f.aPat, f.list12)\n            .scan(f.bPat, f.list34)\n            .build();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(abPat, innermostFrom)\n            .build();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder\n        .scan(abPat, innerFrom)\n        .where(\n            core.andAlso(f.typeSystem,\n                core.greaterThan(f.typeSystem, f.aId, f.bId),\n                core.equal(f.typeSystem, f.aId,\n                    core.intLiteral(BigDecimal.TEN))))\n        .yield_(f.bId);\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from a in [1, 2] \"\n        + \"join b in [3, 4] \"\n        + \"where a > b andalso a = 10 \"\n        + \"yield b\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n\n    // Tuple where variables are not in alphabetical order. Requires\n    // a 'yield' step to re-order variables.\n    //\n    // from (b, a) in\n    //   (from a in [1, 2] join b in [3, 4])\n    // where a > b andalso b = 10\n    // yield b\n    //   ==>\n    // from a in [1, 2]\n    // join b in [3, 4]\n    // yield {a = b, b = a}\n    // where a > b andalso a = 10\n    // yield b\n    final Core.Pat baPat =\n        core.tuplePat(f.typeSystem, Arrays.asList(f.bPat, f.aPat));\n    final FromBuilder fromBuilder2 = f.fromBuilder();\n    fromBuilder2\n        .scan(baPat, innermostFrom)\n        .where(\n            core.andAlso(f.typeSystem,\n                core.greaterThan(f.typeSystem, f.aId, f.bId),\n                core.equal(f.typeSystem, f.aId,\n                    core.intLiteral(BigDecimal.TEN))))\n        .yield_(f.bId);\n\n    final Core.From from2 = fromBuilder2.build();\n    final String expected2 = \"from a in [1, 2] \"\n        + \"join b in [3, 4] \"\n        + \"yield {a = b, b = a} \"\n        + \"where a > b andalso a = 10 \"\n        + \"yield b\";\n    assertThat(from2, hasToString(expected2));\n    final Core.Exp e2 = fromBuilder2.buildSimplify();\n    assertThat(e2, is(from2));\n\n    // from (i, j) in\n    //   (from a in [1, 2] join b in [3, 4])\n    // where i > j andalso j = 10\n    // yield i\n    //   ==>\n    // from a in [1, 2]\n    // join b in [3, 4]\n    // yield {i = a, j = b}\n    // where i > j andalso j = 10\n    // yield i\n    final Core.Pat ijPat =\n        core.tuplePat(f.typeSystem, Arrays.asList(f.iPat, f.jPat));\n    final FromBuilder fromBuilder3 = f.fromBuilder();\n    fromBuilder3\n        .scan(ijPat, innermostFrom)\n        .where(\n            core.andAlso(f.typeSystem,\n                core.greaterThan(f.typeSystem, f.iId, f.jId),\n                core.equal(f.typeSystem, f.jId,\n                    core.intLiteral(BigDecimal.TEN))))\n        .yield_(f.jId);\n\n    final Core.From from3 = fromBuilder3.build();\n    final String expected3 = \"from a in [1, 2] \"\n        + \"join b in [3, 4] \"\n        + \"yield {i = a, j = b} \"\n        + \"where i > j andalso j = 10 \"\n        + \"yield j\";\n    assertThat(from3, hasToString(expected3));\n    final Core.Exp e3 = fromBuilder3.buildSimplify();\n    assertThat(e3, is(from3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "class_name": "FromBuilderTest", "class_uri": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testShell()", "name": "testShell", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testShell()", "original_string": "  @Test void testShell() {\n    final List<String> argList = Collections.singletonList(\"--system=false\");\n    fixture().withArgList(argList)\n        .withInputString(\"\")\n        .assertOutput(containsString(\"morel version\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Shell} with empty input."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testShellNoBanner()", "name": "testShellNoBanner", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testShellNoBanner()", "original_string": "  @Test void testShellNoBanner() {\n    fixture()\n        .withInputString(\"\")\n        .assertOutput(containsString(\"- \\r\\r\\n\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Shell} with empty input and banner disabled."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testOneLine()", "name": "testOneLine", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testOneLine()", "original_string": "  @Test void testOneLine() {\n    assumeNotInCi();\n    final String in = \"1 + 2;\\n\";\n    final String expected = \"1 + 2;\\r\\n\"\n        + \"- 1 + 2;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 3 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Shell} with one line."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testTwoLines()", "name": "testTwoLines", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTwoLines()", "original_string": "  @Test void testTwoLines() {\n    assumeNotInCi();\n    final String in = \"1 +\\n\"\n        + \"2;\\n\";\n    final String expected = \"1 +\\r\\n\"\n        + \"2;\\r\\n\"\n        + \"- 1 +\\r\\r\\n\"\n        + \"\\u001B[?2004l= 2;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 3 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Shell} with a continued line."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testReal()", "name": "testReal", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testReal()", "original_string": "  @Test void testReal() {\n    final String in = \"val nan = Real.posInf / Real.negInf;\\n\"\n        + \"(nan, Real.posInf, Real.negInf, 0.0, ~0.0);\\n\";\n    final String expected = \"val nan = nan : real\\n\"\n        + \"val it = (nan,inf,~inf,0.0,~0.0) : real * real * real * real * real\\n\";\n    fixture().withRaw(true).withInputString(in).assertOutput(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Shell} printing some tricky real values."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testEmptyLines()", "name": "testEmptyLines", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEmptyLines()", "original_string": "  @Test void testEmptyLines() {\n    assumeNotInCi();\n    final String in = \"(* a comment followed by empty *)\\n\"\n        + \"\\n\"\n        + \";\\n\";\n    final String expected = \"(* a comment followed by empty *)\\r\\n\"\n        + \"\\r\\n\"\n        + \";\\r\\n\"\n        + \"- (* a comment followed by empty *)\\r\\r\\n\"\n        + \"\\u001B[?2004l- \\r\\r\\n\"\n        + \"\\u001B[?2004l- ;\\r\\r\\n\"\n        + \"\\u001B[?2004l- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Shell} with a line that is a comment, another that is empty,\n and another that has only a semicolon; all are treated as empty."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testSingleLineComment()", "name": "testSingleLineComment", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testSingleLineComment()", "original_string": "  @Test void testSingleLineComment() {\n    assumeNotInCi();\n    final String in = \"(*) line comment\\n\"\n        + \"1 + 2;\\n\";\n    final String expected = \"(*) line comment\\r\\n\"\n        + \"1 + 2;\\r\\n\"\n        + \"- (*) line comment\\r\\r\\n\"\n        + \"\\u001B[?2004l- 1 + 2;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 3 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Shell} with a single-line comment."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testSingleLineCommentWithQuote()", "name": "testSingleLineCommentWithQuote", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testSingleLineCommentWithQuote()", "original_string": "  @Test void testSingleLineCommentWithQuote() {\n    assumeNotInCi();\n    final String in = \"(*) it's a single-line comment with a quote\\n\"\n        + \"2 + 3;\\n\";\n    final String expected = \"(*) it's a single-line comment with a quote\\r\\n\"\n        + \"2 + 3;\\r\\n\"\n        + \"- (*) it's a single-line comment with a quote\\r\\r\\n\"\n        + \"\\u001B[?2004l- 2 + 3;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 5 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Shell} with a single-line comment that contains a quote."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testMultiLineLet()", "name": "testMultiLineLet", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMultiLineLet()", "original_string": "  @Test void testMultiLineLet() {\n    assumeNotInCi();\n    final String in = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"in\\n\"\n        + \"  x + 2\\n\"\n        + \"end;\\n\";\n    final String expected = \"let\\r\\n\"\n        + \"  val x = 1\\r\\n\"\n        + \"in\\r\\n\"\n        + \"  x + 2\\r\\n\"\n        + \"end;\\r\\n\"\n        + \"- let\\r\\r\\n\"\n        + \"\\u001B[?2004l=   val x = 1\\r\\r\\n\"\n        + \"\\u001B[?2004l= in\\r\\r\\n\"\n        + \"\\u001B[?2004l=   x + 2\\r\\r\\n\"\n        + \"\\u001B[?2004l= end;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 3 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Shell} with {@code let} statement spread over multiple\nlines."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testUse()", "name": "testUse", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testUse()", "original_string": "  @Test void testUse() {\n    assumeNotInCi();\n    // In SML-NJ, given x.sml as follows:\n    //   val x = 2;\n    //   val y = x + 3;\n    //   x + y;\n    //   use \"z.sml\";\n    //   x + y + z;\n    // and z.sml as follows:\n    //   val z = 7;\n    //   val x = 1;\n    //   x + z;\n    // running\n    //   use \"x.sml\";\n    //   x;\n    // gives\n    //   - use \"x.sml\";\n    //   [opening x.sml]\n    //   val x = 2 : int\n    //   val y = 5 : int\n    //   val it = 7 : int\n    //   [opening z.sml]\n    //   val z = 7 : int\n    //   val x = 1 : int\n    //   val it = 8 : int\n    //   val it = () : unit\n    //   val it = 13 : int\n    //   val it = () : unit\n    //   val it = 1;\n    // Note that x = 1 after /tmp/x.sml has finished;\n    // and that z has been assigned after /tmp/z.sml has finished.\n    final String in = \"use \\\"x.sml\\\";\\n\";\n    final String expected = \"use \\\"x.sml\\\";\\r\\n\"\n        + \"- use \\\"x.sml\\\";\\r\\r\\n\"\n        + \"\\u001B[?2004l[opening x.sml]\\r\\n\"\n        + \"val x = 2 : int\\r\\n\"\n        + \"val y = 5 : int\\r\\n\"\n        + \"val it = 7 : int\\r\\n\"\n        + \"[opening z.sml]\\r\\n\"\n        + \"val z = 7 : int\\r\\n\"\n        + \"val x = 1 : int\\r\\n\"\n        + \"val it = 8 : int\\r\\n\"\n        + \"val it = () : unit\\r\\n\"\n        + \"val it = 13 : int\\r\\n\"\n        + \"val it = () : unit\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture()\n        .withArgListPlusDirectory()\n        .withInputString(in)\n        .assertOutput(is2(expected));\n\n    final String expectedRaw = \"[opening x.sml]\\n\"\n        + \"val x = 2 : int\\n\"\n        + \"val y = 5 : int\\n\"\n        + \"val it = 7 : int\\n\"\n        + \"[opening z.sml]\\n\"\n        + \"val z = 7 : int\\n\"\n        + \"val x = 1 : int\\n\"\n        + \"val it = 8 : int\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = 13 : int\\n\"\n        + \"val it = () : unit\\n\";\n    fixture()\n        .withRaw(true)\n        .withArgListPlusDirectory()\n        .withInputString(in)\n        .assertOutput(is(expectedRaw));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests the {@code use} function."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testMatchWarning()", "name": "testMatchWarning", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchWarning()", "original_string": "  @Test void testMatchWarning() {\n    final String in = \"fun f 1 = 1;\\n\"\n        + \"f 1;\\n\";\n    final String expected = \"stdIn:1.5-1.12 Warning: match nonexhaustive\\n\"\n        + \"  raised at: stdIn:1.5-1.12\\n\"\n        + \"val f = fn : int -> int\\n\"\n        + \"val it = 1 : int\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(in)\n        .assertOutput(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a warning."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testUseEmpty()", "name": "testUseEmpty", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testUseEmpty()", "original_string": "  @Test void testUseEmpty() {\n    assumeNotInCi();\n    final String in = \"use \\\"empty.sml\\\";\\n\";\n    final String expected = \"use \\\"empty.sml\\\";\\r\\n\"\n        + \"- use \\\"empty.sml\\\";\\r\\r\\n\"\n        + \"\\u001B[?2004l[opening empty.sml]\\r\\n\"\n        + \"val it = () : unit\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture()\n        .withArgListPlusDirectory()\n        .withInputString(in)\n        .assertOutput(is2(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests the {@code use} function on an empty file."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testUseMissing()", "name": "testUseMissing", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testUseMissing()", "original_string": "  @Test void testUseMissing() {\n    assumeNotInCi();\n    // SML-NJ gives:\n    //   [opening missing.sml]\n    //   [use failed: Io: openIn failed on \"missing.sml\", No such file or\n    //   directory]\n    //   uncaught exception Error\n    //     raised at: ../compiler/TopLevel/interact/interact.sml:24.14-24.28\n\n    final String in = \"use \\\"missing.sml\\\";\\n\";\n    final String expected = \"use \\\"missing.sml\\\";\\r\\n\"\n        + \"- use \\\"missing.sml\\\";\\r\\r\\n\"\n        + \"\\u001B[?2004l[opening missing.sml]\\r\\n\"\n        + \"[use failed: Io: openIn failed on missing.sml,\"\n        + \" No such file or directory]\\r\\n\"\n        + \"uncaught exception Error\\r\\n\"\n        + \"  raised at: stdIn:1.1-1.18\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture()\n        .withArgListPlusDirectory()\n        .withInputString(in)\n        .assertOutput(is2(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests the {@code use} function on a missing file."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testUseSelfReferential()", "name": "testUseSelfReferential", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testUseSelfReferential()", "original_string": "  @Test void testUseSelfReferential() {\n    assumeNotInCi();\n    // SML-NJ gives:\n    //   [opening self-referential.sml]\n    //   [use failed: Io: openIn failed on \"self-referential.sml\", Too many\n    //   open files]\n    //   uncaught exception Error\n    //     raised at: ../compiler/TopLevel/interact/interact.sml:24.14-24.28\n\n    final String in = \"use \\\"self-referential.sml\\\";\\n\";\n    final String expected = \"use \\\"self-referential.sml\\\";\\r\\n\"\n        + \"- use \\\"self-referential.sml\\\";\\r\\r\\n\"\n        + \"\\u001B[?2004l[opening self-referential.sml]\\r\\n\"\n        + \"[opening self-referential.sml]\\r\\n\"\n        + \"[opening self-referential.sml]\\r\\n\"\n        + \"[opening self-referential.sml]\\r\\n\"\n        + \"[use failed: Io: openIn failed on self-referential.sml,\"\n        + \" Too many open files]\\r\\n\"\n        + \"uncaught exception Error\\r\\n\"\n        + \"  raised at: stdIn:1.1-1.27\\r\\n\"\n        + \"val it = () : unit\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture()\n        .withArgListPlusDirectory()\n        .withArgList(list -> plus(list, \"--maxUseDepth=3\"))\n        .withInputString(in)\n        .assertOutput(is2(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests the {@code use} function on a file that uses itself."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testRaw()", "name": "testRaw", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRaw()", "original_string": "  @Test void testRaw() {\n    String inputString = \"val x = 2;\\n\"\n        + \"x + 3;\\n\";\n    String expected = \"val x = 2 : int\\n\"\n        + \"val it = 5 : int\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a script running in raw mode.\nIt uses {@link Main} rather than {@link Shell}."}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testStringDepth()", "name": "testStringDepth", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testStringDepth()", "original_string": "  @Test void testStringDepth() {\n    String inputString = \"val s = \\\"a string that is 35 characters long\\\";\\n\"\n        + \"val c = #\\\"a\\\";\\n\"\n        + \"Sys.set (\\\"stringDepth\\\", 20);\\n\"\n        + \"s;\\n\"\n        + \"c;\\n\"\n        + \"\\\"abc\\\";\\n\"\n        + \"Sys.set (\\\"stringDepth\\\", 1);\\n\"\n        + \"s;\\n\"\n        + \"c;\\n\"\n        + \"Sys.set (\\\"stringDepth\\\", 0);\\n\"\n        + \"s;\\n\"\n        + \"c;\\n\"\n        + \"Sys.set (\\\"stringDepth\\\", 5);\\n\"\n        + \"\\\"a\\\\\\\\b\\\\\\\"cdef\\\";\";\n    String expected = \"val s = \\\"a string that is 35 characters long\\\" : string\\n\"\n        + \"val c = #\\\"a\\\" : char\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = \\\"a string that is 35 #\\\" : string\\n\"\n        + \"val it = #\\\"a\\\" : char\\n\"\n        + \"val it = \\\"abc\\\" : string\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = \\\"a#\\\" : string\\n\"\n        + \"val it = #\\\"a\\\" : char\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = \\\"#\\\" : string\\n\"\n        + \"val it = #\\\"a\\\" : char\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = \\\"a\\\\\\\\b\\\\\\\"c#\\\" : string\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testPrintDepth()", "name": "testPrintDepth", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testPrintDepth()", "original_string": "  @Test void testPrintDepth() {\n    String inputString = \"Sys.set (\\\"lineWidth\\\", 70);\\n\"\n        + \"val x = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=7,h=[8],i={j=[9]}}]}]};\\n\"\n        + \"Sys.set (\\\"printDepth\\\", 6);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 5);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 4);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 3);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 2);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 1);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 0);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", ~1);\\n\"\n        + \"x;\";\n    // TODO: wrap types linke this:\n    // val it = ...\n    //  : {a:int, b:int list,\n    //     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\n    String expected = \"val it = () : unit\\n\"\n        + \"val x = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=#,h=#,i=#}]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=7,h=[#],i={j=#}}]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=#,h=#,i=#}]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=4,e=[#,#],f=[#]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=#,e=#,f=#}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[#,#],c=[#]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=#,b=#,c=#}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = # : unit\\n\"\n        + \"val it = #\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=7,h=[8],i={j=[9]}}]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testPrintLength()", "name": "testPrintLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testPrintLength()", "original_string": "  @Test void testPrintLength() {\n    String inputString = \"Sys.set (\\\"printLength\\\", 10);\\n\"\n        + \"val x = [[1,2,3], [4,5], [6], []];\\n\"\n        + \"Sys.set (\\\"printLength\\\", 4);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", 3);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", 2);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", 1);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", 0);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", ~1);\\n\"\n        + \"x;\\n\";\n    String expected = \"val it = () : unit\\n\"\n        + \"val x = [[1,2,3],[4,5],[6],[]] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,2,3],[4,5],[6],[]] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,2,3],[4,5],[6],...] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,2,...],[4,5],...] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,...],...] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [...] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,2,3],[4,5],[6],[]] : int list list\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]testLineWidth()", "name": "testLineWidth", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLineWidth()", "original_string": "  @Test void testLineWidth() {\n    String inputString = \"Sys.set (\\\"lineWidth\\\", 100);\\n\"\n        + \"100;\"\n        + \"val x = [[1,2,3], [4,5], [6], []];\\n\"\n        + \"val y = ([1,2,3], [4,5], [6], []);\\n\"\n        + \"val z = {a=[1,2,3], b=[4,5], c=[6], d=()};\\n\"\n        + \"val r = {x=x,y=y,z=z};\\n\"\n        + \"val f = fn s => String.size s;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", 40);\\n\"\n        + \"40;\\n\"\n        + \"x;\\n\"\n        + \"y;\\n\"\n        + \"z;\\n\"\n        + \"r;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", 20);\\n\"\n        + \"20;\\n\"\n        + \"x;\\n\"\n        + \"y;\\n\"\n        + \"z;\\n\"\n        + \"f;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", 1);\\n\"\n        + \"1;\\n\"\n        + \"x;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", 0);\\n\"\n        + \"0;\\n\"\n        + \"x;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", ~1);\\n\"\n        + \"~1;\\n\"\n        + \"x;\\n\";\n    String[] lines = {\n        // width 100\n        \"val it = () : unit\",\n        \"val it = 100 : int\",\n        \"val x = [[1,2,3],[4,5],[6],[]] : int list list\",\n        \"val y = ([1,2,3],[4,5],[6],[])\"\n            + \" : int list * int list * int list * 'a list\",\n        \"val z = {a=[1,2,3],b=[4,5],c=[6],d=()}\"\n            + \" : {a:int list, b:int list, c:int list, d:unit}\",\n        \"val r = {x=[[1,2,3],[4,5],[6],[]],y=([1,2,3],[4,5],[6],[]),\"\n            + \"z={a=[1,2,3],b=[4,5],c=[6],d=()}}\",\n        \"  : {x:int list list, y:int list * int list * int list * 'a list,\",\n        \"     z:{a:int list, b:int list, c:int list, d:unit}}\",\n        \"val f = fn : string -> int\",\n        // width 40\n        \"val it = () : unit\",\n        \"val it = 40 : int\",\n        \"val it = [[1,2,3],[4,5],[6],[]]\",\n        \"  : int list list\",\n        \"val it = ([1,2,3],[4,5],[6],[])\",\n        \"  : int list * int list * int list *\",\n        \"    'a list\",\n        \"val it = {a=[1,2,3],b=[4,5],c=[6],d=()}\",\n        \"  : {a:int list, b:int list, c:int list,\",\n        \"     d:unit}\",\n        \"val it =\",\n        \"  {x=[[1,2,3],[4,5],[6],[]],\",\n        \"   y=([1,2,3],[4,5],[6],[]),\",\n        \"   z={a=[1,2,3],b=[4,5],c=[6],d=()}}\",\n        \"  : {x:int list list,\",\n        \"     y:int list * int list * int list *\",\n        \"       'a list,\",\n        \"     z:{a:int list, b:int list,\",\n        \"        c:int list, d:unit}}\",\n        // width 20\n        \"val it = () : unit\",\n        \"val it = 20 : int\",\n        \"val it =\",\n        \"  [[1,2,3],[4,5],[6],\",\n        \"   []]\",\n        \"  : int list list\",\n        \"val it =\",\n        \"  ([1,2,3],[4,5],[6],\",\n        \"   [])\",\n        \"  : int list *\",\n        \"    int list *\",\n        \"    int list *\",\n        \"    'a list\",\n        \"val it =\",\n        \"  {a=[1,2,3],b=[4,5],\",\n        \"   c=[6],d=()}\",\n        \"  : {a:int list,\",\n        \"     b:int list,\",\n        \"     c:int list,\",\n        \"     d:unit}\",\n        \"val it = fn\",\n        \"  : string -> int\",\n        // width 1\n        \"val it =\",\n        \"  ()\",\n        \"  :\",\n        \"    unit\",\n        \"val it =\",\n        \"  1\",\n        \"  :\",\n        \"    int\",\n        \"val it =\",\n        \"  [\",\n        \"   [\",\n        \"    1,\",\n        \"    2,\",\n        \"    3],\",\n        \"   [\",\n        \"    4,\",\n        \"    5],\",\n        \"   [\",\n        \"    6],\",\n        \"   []]\",\n        \"  :\",\n        \"    int list list\",\n        // width 0\n        \"val it =\",\n        \"  ()\",\n        \"  :\",\n        \"    unit\",\n        \"val it =\",\n        \"  0\",\n        \"  :\",\n        \"    int\",\n        \"val it =\",\n        \"  [\",\n        \"   [\",\n        \"    1,\",\n        \"    2,\",\n        \"    3],\",\n        \"   [\",\n        \"    4,\",\n        \"    5],\",\n        \"   [\",\n        \"    6],\",\n        \"   []]\",\n        \"  :\",\n        \"    int list list\",\n        // width ~1\n        \"val it = () : unit\",\n        \"val it = ~1 : int\",\n        \"val it = [[1,2,3],[4,5],[6],[]] : int list list\",\n        \"\",\n    };\n    String expected = String.join(\"\\n\", lines);\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ShellTest.java", "class_name": "ShellTest", "class_uri": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/LintTest.java.LintTest.[void]testLint()", "name": "testLint", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLint()", "original_string": "  @Test void testLint() {\n    assumeTrue(TestUnsafe.haveGit(), \"Invalid git environment\");\n\n    final Puffin.Program<GlobalState> program = makeProgram();\n    final List<File> javaFiles = TestUnsafe.getTextFiles();\n\n    final GlobalState g;\n    StringWriter b = new StringWriter();\n    try (PrintWriter pw = new PrintWriter(b)) {\n      g = program.execute(javaFiles.parallelStream().map(Sources::of), pw);\n    }\n\n    assertThat(\"Lint violations:\\n\" + b, g.messages, empty());\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/LintTest.java", "class_name": "LintTest", "class_uri": "src/test/java/net/hydromatic/morel/LintTest.java.LintTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that source code has no flaws."}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testTailList()", "name": "testTailList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTailList()", "original_string": "  @Test void testTailList() {\n    final List<String> list = new ArrayList<>();\n    list.add(\"a\");\n    list.add(\"b\");\n\n    final List<String> tailList = new TailList<>(list);\n    assertThat(tailList.size(), is(0));\n    list.add(\"c\");\n    assertThat(tailList.size(), is(1));\n    assertThat(tailList.get(0), is(\"c\"));\n    assertThat(tailList, hasToString(\"[c]\"));\n\n    tailList.set(0, \"d\");\n    assertThat(tailList, hasToString(\"[d]\"));\n\n    tailList.add(0, \"e\");\n    assertThat(tailList, hasToString(\"[e, d]\"));\n\n    final StringBuilder s = new StringBuilder();\n    for (String item : tailList) {\n      s.append(item);\n    }\n    assertThat(s, hasToString(\"ed\"));\n\n    tailList.add(\"f\");\n    assertThat(tailList, hasToString(\"[e, d, f]\"));\n    assertThat(list.size(), is(5));\n\n    tailList.addAll(Arrays.asList(\"x\", \"y\", \"z\"));\n    assertThat(tailList, hasToString(\"[e, d, f, x, y, z]\"));\n\n    tailList.clear();\n    assertThat(tailList.size(), is(0));\n    assertThat(tailList.isEmpty(), is(true));\n    assertThat(list.size(), is(2));\n    assertThat(list.isEmpty(), is(false));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link TailList}."}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testOrd()", "name": "testOrd", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testOrd()", "original_string": "  @Test void testOrd() {\n    final List<String> abc = Arrays.asList(\"a\", \"b\", \"c\");\n    final StringBuilder buf = new StringBuilder();\n    forEachIndexed(abc, (e, i) ->\n        buf.append(i).append(\"#\").append(e).append(\";\"));\n    assertThat(buf, hasToString(\"0#a;1#b;2#c;\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testMapList()", "name": "testMapList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMapList()", "original_string": "  @Test void testMapList() {\n    final List<String> abc =\n        MapList.of(3, i -> \"\" + (char) ('a' + i));\n    assertThat(abc.size(), is(3));\n    assertThat(abc.get(0), is(\"a\"));\n    assertThat(abc.get(2), is(\"c\"));\n    assertThat(String.join(\",\", abc), is(\"a,b,c\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testFolder()", "name": "testFolder", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFolder()", "original_string": "  @Test void testFolder() {\n    final List<Folder<Ast.Exp>> list = new ArrayList<>();\n    Folder.start(list, ast.stringLiteral(Pos.ZERO, \"a\"));\n    Folder.at(list, ast.stringLiteral(Pos.ZERO, \"b\"));\n    Folder.at(list, ast.stringLiteral(Pos.ZERO, \"c\"));\n    assertThat(Folder.combineAll(list), hasToString(\"\\\"a\\\" @ \\\"b\\\" @ \\\"c\\\"\"));\n\n    list.clear();\n    Folder.start(list, ast.stringLiteral(Pos.ZERO, \"a\"));\n    Folder.cons(list, ast.stringLiteral(Pos.ZERO, \"b\"));\n    assertThat(Folder.combineAll(list), hasToString(\"\\\"a\\\" :: \\\"b\\\"\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testShorterThan()", "name": "testShorterThan", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testShorterThan()", "original_string": "  @Test void testShorterThan() {\n    // A list of length n is shorter than n + 1, but not shorter than n\n    final List<Integer> list2 = Arrays.asList(0, 1);\n    assertThat(Static.shorterThan(list2, 1), is(false));\n    assertThat(Static.shorterThan(list2, 2), is(false));\n    assertThat(Static.shorterThan(list2, 3), is(true));\n\n    // Collections of length 3\n    final List<Integer> list3 = ImmutableIntList.identity(3);\n    final HashSet<Integer> set3 = new HashSet<>(list3);\n    final Iterable<Integer> iterable3 = list3::iterator;\n    assertThat(iterable3, not(instanceOf(Collection.class)));\n    checkShorterThan(list3, 3);\n    checkShorterThan(set3, 3);\n    checkShorterThan(iterable3, 3);\n\n    // Collections of length 1\n    final Set<String> set1 = Collections.singleton(\"x\");\n    final List<String> list1 = new ArrayList<>(set1);\n    final Iterable<String> iterable1 = list1::iterator;\n    assertThat(iterable1, not(instanceOf(Collection.class)));\n    checkShorterThan(list1, 1);\n    checkShorterThan(set1, 1);\n    checkShorterThan(iterable1, 1);\n\n    // Empty collections\n    final Set<String> set0 = Collections.emptySet();\n    final List<String> list0 = Collections.emptyList();\n    final Iterable<String> iterable0 = set0::iterator;\n    assertThat(iterable0, not(instanceOf(Collection.class)));\n    checkShorterThan(list0, 0);\n    checkShorterThan(set0, 0);\n    checkShorterThan(iterable0, 0);\n\n    // Very large collections (too large to materialize)\n    final int bigSize = Integer.MAX_VALUE - 10;\n    final List<Integer> listBig = Util.range(bigSize);\n    final Iterable<Integer> iterableBig = listBig::iterator;\n    assertThat(iterableBig, not(instanceOf(Collection.class)));\n    checkShorterThan(listBig, bigSize);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Static#shorterThan(Iterable, int)}."}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testFind()", "name": "testFind", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFind()", "original_string": "  @Test void testFind() {\n    final List<Integer> list = Arrays.asList(1, 7, 3);\n    final List<Integer> emptyList = Collections.emptyList();\n    assertThat(Static.find(list, i -> i > 0), is(0));\n    assertThat(Static.find(list, i -> i > 1), is(1));\n    assertThat(Static.find(list, i -> i > 10), is(-1));\n    assertThat(Static.find(emptyList, i -> i > 0), is(-1));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Static#find(List, Predicate)}."}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testPos()", "name": "testPos", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testPos()", "original_string": "  @Test void testPos() {\n    final BiConsumer<String, String> check = (s, posString) -> {\n      final Pair<String, Pos> pos = Pos.split(s, '$', \"stdIn\");\n      assertThat(pos.left, is(\"abcdefgh\"));\n      assertThat(pos.right, notNullValue());\n      assertThat(pos.right, hasToString(posString));\n    };\n    // starts and ends in middle\n    check.accept(\"abc$def$gh\", \"stdIn:1.4-1.7\");\n    // ends at end\n    check.accept(\"abc$defgh$\", \"stdIn:1.4-1.9\");\n    // starts at start\n    check.accept(\"$abc$defgh\", \"stdIn:1.1-1.4\");\n    // one character long\n    check.accept(\"abc$d$efgh\", \"stdIn:1.4\");\n\n    final BiConsumer<String, String> check2 = (s, posString) -> {\n      final Pair<String, Pos> pos = Pos.split(s, '$', \"stdIn\");\n      assertThat(pos.left,\n          is(\"abc\\n\"\n              + \"de\\n\"\n              + \"\\n\"\n              + \"fgh\"));\n      assertThat(pos.right, notNullValue());\n      assertThat(pos.right, hasToString(posString));\n    };\n    // start of line\n    check2.accept(\"abc\\n\"\n        + \"$de$\\n\"\n        + \"\\n\"\n        + \"fgh\", \"stdIn:2.1-2.3\");\n    // spans multiple lines\n    check2.accept(\"abc\\n\"\n        + \"d$e\\n\"\n        + \"\\n\"\n        + \"fg$h\", \"stdIn:2.2-4.3\");\n\n    // too many, too few\n    Consumer<String> checkTooFew = s -> {\n      try {\n        final Pair<String, Pos> pos4 = Pos.split(s, '$', \"stdIn\");\n        fail(\"expected error, got \" + pos4);\n      } catch (IllegalArgumentException e) {\n        assertThat(e.getMessage(),\n            is(\"expected exactly two occurrences of delimiter, '$'\"));\n      }\n    };\n    checkTooFew.accept(\"$abc$de$f\");\n    checkTooFew.accept(\"abc$def\");\n    checkTooFew.accept(\"abcdef\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Unit tests for {@link Pos}."}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testPower()", "name": "testPower", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testPower()", "original_string": "  @Test void testPower() {\n    assertThat(nextPowerOfTwo(0), is(1));\n    assertThat(nextPowerOfTwo(-1), is(1)); // 2^16\n    assertThat(nextPowerOfTwo(-2), is(1)); // 2^16\n    assertThat(nextPowerOfTwo(-3), is(1)); // 2^16\n    assertThat(nextPowerOfTwo(-4), is(1)); // 2^16\n    assertThat(nextPowerOfTwo(-65_536), is(1)); // 2^16\n\n    assertThat(nextPowerOfTwo(1), is(2));\n    assertThat(nextPowerOfTwo(2), is(4));\n    assertThat(nextPowerOfTwo(3), is(4));\n    assertThat(nextPowerOfTwo(4), is(8));\n    assertThat(nextPowerOfTwo(5), is(8));\n\n    assertThat(nextPowerOfTwo(16_383), is(16_384)); // 2^14\n    assertThat(nextPowerOfTwo(16_384), is(32_768)); // 2^15\n    assertThat(nextPowerOfTwo(16_384), is(32_768));\n    assertThat(nextPowerOfTwo(32_768), is(65_536)); // 2^16\n\n    assertThat(nextPowerOfTwo(1_073_741_823), is(1_073_741_824)); // 2^31\n    assertThat(nextPowerOfTwo(1_073_741_824), is(-2_147_483_648)); // 2^32\n    assertThat(nextPowerOfTwo(2_147_483_647), is(-2_147_483_648)); // 2^32\n    assertThat(nextPowerOfTwo(-2_147_483_648), is(1)); // 2^0\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link Static#nextPowerOfTwo(int)}."}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testTransform()", "name": "testTransform", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTransform()", "original_string": "  @Test void testTransform() {\n    final List<String> list = Arrays.asList(\"john\", \"paul\", \"george\", \"ringo\");\n    assertThat(transform(list, String::length), is(Arrays.asList(4, 4, 6, 5)));\n    assertThat(transform(Collections.emptyList(), String::length),\n        is(Collections.emptyList()));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testToString()", "name": "testToString", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testToString()", "original_string": "  @Test void testToString() {\n    Function<String, String> fn = s -> {\n      float f = Float.parseFloat(s);\n      return Codes.floatToString(f);\n    };\n    assertThat(fn.apply(\"1.17549435E-38\"), is(\"1.1754944E~38\"));\n    assertThat(fn.apply(\"1.1754944E-38\"), is(\"1.1754944E~38\"));\n\n    assertThat(fn.apply(\"1.23456795E12\"), is(\"1.234568E12\"));\n    assertThat(fn.apply(\"1.234568E12\"), is(\"1.234568E12\"));\n\n    assertThat(fn.apply(\"1.23456791E11\"), is(\"1.2345679E11\"));\n    assertThat(fn.apply(\"1.2345679E11\"), is(\"1.2345679E11\"));\n\n    assertThat(fn.apply(\"1.23456788E10\"), is(\"1.2345679E10\"));\n    assertThat(fn.apply(\"1.2345679E10\"), is(\"1.2345679E10\"));\n\n    assertThat(fn.apply(\"1.23456792E8\"), is(\"1.2345679E8\"));\n    assertThat(fn.apply(\"1.2345679E8\"), is(\"1.2345679E8\"));\n\n    assertThat(fn.apply(\"1.0\"), is(\"1.0\"));\n    assertThat(fn.apply(\"-1.234\"), is(\"~1.234\"));\n    assertThat(fn.apply(\"-1.234e-10\"), is(\"~1.234E~10\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that {@code Real.toString} returns values consistent with JDK 19 and\nlater, incorporating the fix to\n<a href=\"https://bugs.openjdk.org/browse/JDK-4511638\">[JDK-4511638]\nDouble.toString(double) sometimes produces incorrect results</a>."}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testFloatBit()", "name": "testFloatBit", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@SuppressWarnings(\"ConstantValue\")\n  @Test void testFloatBit()", "original_string": "  @SuppressWarnings(\"ConstantValue\")\n  @Test void testFloatBit() {\n    assertThat(isNegative(0f), is(false));\n    assertThat(isNegative(3.5f), is(false));\n    assertThat(isNegative(Float.POSITIVE_INFINITY), is(false));\n    assertThat(isNegative(-0f), is(true));\n    assertThat(isNegative(-10.25f), is(true));\n    assertThat(isNegative(Float.NEGATIVE_INFINITY), is(true));\n\n    // The standard basis library is unclear, but in SMLNJ and Mlton\n    // nan is negative, and we do the same.\n    assertThat(isNegative(Float.NaN), is(true));\n    // In SMLNJ and Mlton ~nan is positive, and we do the same.\n    assertThat(isNegative(Codes.NEGATIVE_NAN), is(false));\n    assertThat(Float.isNaN(Float.NaN), is(true));\n    assertThat(Float.isNaN(Codes.NEGATIVE_NAN), is(true));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@SuppressWarnings(\"ConstantValue\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"ConstantValue\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests the {@link Codes#isNegative(float)} function,\nwhich is used to implement {@code Real.signBit}."}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testPairAllMatch()", "name": "testPairAllMatch", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testPairAllMatch()", "original_string": "  @Test void testPairAllMatch() {\n    final List<Integer> list1 = Arrays.asList(1, 3, 5);\n    final List<Integer> list2 = Arrays.asList(2, 3, 4);\n    final List<Integer> list0 = Collections.emptyList();\n    assertThat(Pair.anyMatch(list1, list2, Objects::equals), is(true));\n    assertThat(Pair.allMatch(list1, list2, Objects::equals), is(false));\n    assertThat(Pair.noneMatch(list1, list2, Objects::equals), is(false));\n\n    assertThat(Pair.anyMatch(list1, list2, (i, j) -> i == 0), is(false));\n    assertThat(Pair.allMatch(list1, list2, (i, j) -> i == 0), is(false));\n    assertThat(Pair.noneMatch(list1, list2, (i, j) -> i == 0), is(true));\n\n    assertThat(Pair.anyMatch(list1, list2, (i, j) -> i > 0), is(true));\n    assertThat(Pair.allMatch(list1, list2, (i, j) -> i > 0), is(true));\n    assertThat(Pair.noneMatch(list1, list2, (i, j) -> i > 0), is(false));\n\n    assertThat(Pair.anyMatch(list0, list0, (i, j) -> true), is(false));\n    assertThat(Pair.allMatch(list0, list0, (i, j) -> true), is(true));\n    assertThat(Pair.noneMatch(list0, list0, (i, j) -> true), is(true));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]testRangeExtent()", "name": "testRangeExtent", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@SuppressWarnings(\"UnstableApiUsage\")\n  @Test void testRangeExtent()", "original_string": "  @SuppressWarnings(\"UnstableApiUsage\")\n  @Test void testRangeExtent() {\n    final TypeSystem typeSystem = new TypeSystem();\n    BuiltIn.dataTypes(typeSystem, new ArrayList<>());\n\n    // Integer range [(4, 7]]\n    final Range<BigDecimal> range =\n        Range.openClosed(BigDecimal.valueOf(4), BigDecimal.valueOf(7));\n    final RangeExtent rangeExtent =\n        new RangeExtent(typeSystem, PrimitiveType.INT,\n            ImmutableMap.of(\"/\", ImmutableRangeSet.of(range)));\n    assertThat(rangeExtent.iterable, notNullValue());\n    assertThat(Lists.newArrayList(rangeExtent.iterable),\n        is(Arrays.asList(5, 6, 7)));\n\n    // Integer range set [(4, 7], [10, 12]]\n    final Range<BigDecimal> range2 =\n        Range.closed(BigDecimal.valueOf(10), BigDecimal.valueOf(12));\n    final RangeExtent rangeExtent2 =\n        new RangeExtent(\n            typeSystem, PrimitiveType.INT,\n            ImmutableMap.of(\"/\",\n                ImmutableRangeSet.unionOf(ImmutableList.of(range, range2))));\n    assertThat(rangeExtent2.iterable, notNullValue());\n    assertThat(Lists.newArrayList(rangeExtent2.iterable),\n        is(Arrays.asList(5, 6, 7, 10, 11, 12)));\n\n    // Boolean range set\n    final Range<Boolean> range3 = Range.closed(false, true);\n    final RangeExtent rangeExtent3 =\n        new RangeExtent(typeSystem, PrimitiveType.BOOL,\n            ImmutableMap.of(\"/\", ImmutableRangeSet.of(range3)));\n    assertThat(rangeExtent3.iterable, notNullValue());\n    assertThat(Lists.newArrayList(rangeExtent3.iterable),\n        is(Arrays.asList(false, true)));\n\n    // Range set of (Boolean, Boolean) tuples\n    final Range<Comparable> range4 =\n        Range.closed((Comparable) FlatLists.of(false, true),\n            (Comparable) FlatLists.of(true, true));\n    final RangeExtent rangeExtent4 =\n        new RangeExtent(typeSystem,\n            typeSystem.tupleType(PrimitiveType.BOOL, PrimitiveType.BOOL),\n            ImmutableMap.of(\"/\", ImmutableRangeSet.of(range4)));\n    assertThat(rangeExtent4.iterable, notNullValue());\n    assertThat(Lists.newArrayList(rangeExtent4.iterable),\n        is(\n            Arrays.asList(FlatLists.of(false, true),\n                FlatLists.of(true, false), FlatLists.of(true, true))));\n\n    // Range set of (boolean option, int) tuples\n    final RangeExtent rangeExtent5 =\n        new RangeExtent(typeSystem,\n            typeSystem.tupleType(\n                typeSystem.option(PrimitiveType.BOOL),\n                PrimitiveType.INT),\n            ImmutableMap.of(\"/1/SOME/\",\n                ImmutableRangeSet.of(Range.singleton(true)),\n                \"/2/\",\n                ImmutableRangeSet.of(\n                    Range.closed(BigDecimal.valueOf(4),\n                        BigDecimal.valueOf(6)))));\n    assertThat(rangeExtent5.iterable, notNullValue());\n    assertThat(ImmutableList.copyOf(rangeExtent5.iterable),\n        hasToString(\"[[[NONE], 4], [[NONE], 5], [[NONE], 6],\"\n            + \" [[SOME, true], 4], [[SOME, true], 5], [[SOME, true], 6]]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UtilTest.java", "class_name": "UtilTest", "class_uri": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "attributes": {"modifiers": "@SuppressWarnings(\"UnstableApiUsage\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"UnstableApiUsage\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test1()", "name": "test1", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test1()", "original_string": "  @Test void test1() {\n    final Unifier.Term e1 = p(f(a()), g(b()), Y);\n    final Unifier.Term e2 = p(Z, g(d()), c());\n    assertThat(e1, hasToString(\"p(f(a), g(b), Y)\"));\n    assertThat(unifier.substitution(f(a(), Y), Z).toString(),\n        is(\"[f(a, Y)/Z]\"));\n    assertThatCannotUnify(e1, e2);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test2()", "name": "test2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test2()", "original_string": "  @Test void test2() {\n    final Unifier.Term e1 = p(f(a()), g(b()), Y);\n    final Unifier.Term e2 = p(Z, g(W), c());\n    assertThatUnify(e1, e2, is(\"[b/W, c/Y, f(a)/Z]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test3()", "name": "test3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test3()", "original_string": "  @Test void test3() {\n    // Note: Hesham Alassaf's test says that these cannot be unified; I think\n    // because X is free, and so it assumes that Xs are distinct.\n    final Unifier.Term e1 = p(f(f(b())), X);\n    final Unifier.Term e2 = p(f(Y), X);\n    if (unifier instanceof RobinsonUnifier) {\n      assertThatUnify(e1, e2, is(\"[X/X, f(b)/Y]\"));\n    } else {\n      assertThatUnify(e1, e2, is(\"[f(b)/Y]\"));\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test4()", "name": "test4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test4()", "original_string": "  @Test void test4() {\n    final Unifier.Term e1 = p(f(f(b())), c());\n    final Unifier.Term e2 = p(f(Y), X);\n    assertThatUnify(e1, e2, is(\"[c/X, f(b)/Y]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test5()", "name": "test5", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test5()", "original_string": "  @Test void test5() {\n    final Unifier.Term e1 = p(a(), X);\n    final Unifier.Term e2 = p(b(), Y);\n    assertThatCannotUnify(e1, e2);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test6()", "name": "test6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test6()", "original_string": "  @Test void test6() {\n    final Unifier.Term e1 = p(X, a());\n    final Unifier.Term e2 = p(b(), Y);\n    assertThatUnify(e1, e2, is(\"[b/X, a/Y]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test7()", "name": "test7", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test7()", "original_string": "  @Test void test7() {\n    final Unifier.Term e1 = f(a(), X);\n    final Unifier.Term e2 = f(a(), b());\n    assertThatUnify(e1, e2, is(\"[b/X]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test8()", "name": "test8", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test8()", "original_string": "  @Test void test8() {\n    final Unifier.Term e1 = f(X);\n    final Unifier.Term e2 = f(Y);\n    assertThatUnify(e1, e2, is(\"[Y/X]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test9()", "name": "test9", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test9()", "original_string": "  @Test void test9() {\n    final Unifier.Term e1 = f(g(X), X);\n    final Unifier.Term e2 = f(Y);\n    assertThatCannotUnify(e1, e2);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test10()", "name": "test10", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test10()", "original_string": "  @Test void test10() {\n    final Unifier.Term e1 = f(g(X));\n    final Unifier.Term e2 = f(Y);\n    assertThatUnify(e1, e2, is(\"[g(X)/Y]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test11()", "name": "test11", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test11()", "original_string": "  @Test void test11() {\n    final Unifier.Term e1 = f(g(X), X);\n    final Unifier.Term e2 = f(Y, a());\n    assertThatUnify(e1, e2, is(\"[a/X, g(a)/Y]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test12()", "name": "test12", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test12()", "original_string": "  @Test void test12() {\n    final Unifier.Term e1 = father(X, Y);\n    final Unifier.Term e2 = father(bob(), tom());\n    assertThatUnify(e1, e2, is(\"[bob/X, tom/Y]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test13()", "name": "test13", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test13()", "original_string": "  @Test void test13() {\n    final Unifier.Term e1 = parents(X, father(X), mother(bill()));\n    final Unifier.Term e2 = parents(bill(), father(bill()), Y);\n    assertThatUnify(e1, e2, is(\"[bill/X, mother(bill)/Y]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test14()", "name": "test14", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test14()", "original_string": "  @Test void test14() {\n    final Unifier.Term e1 = grandParent(X, parent(parent(X)));\n    final Unifier.Term e2 = grandParent(john(), parent(Y));\n    assertThatUnify(e1, e2, is(\"[john/X, parent(john)/Y]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test15()", "name": "test15", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test15()", "original_string": "  @Test void test15() {\n    final Unifier.Term e1 = p(f(a(), g(X)));\n    final Unifier.Term e2 = p(Y, Y);\n    assertThatCannotUnify(e1, e2);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test16()", "name": "test16", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test16()", "original_string": "  @Test void test16() {\n    final Unifier.Term e1 = p(a(), X, h(g(Z)));\n    final Unifier.Term e2 = p(Z, h(Y), h(Y));\n    assertThatUnify(e1, e2, is(\"[h(g(a))/X, g(a)/Y, a/Z]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test17()", "name": "test17", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test17()", "original_string": "  @Test void test17() {\n    final Unifier.Term e1 = p(X, X);\n    final Unifier.Term e2 = p(Y, f(Y));\n    if (unifier.occurs()) {\n      assertThatCannotUnify(e1, e2);\n    } else if (unifier instanceof RobinsonUnifier) {\n      assertThatUnify(e1, e2, is(\"[Y/X, f(Y)/Y]\"));\n    } else {\n      assertThatCannotUnify(e1, e2);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test18()", "name": "test18", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test18()", "original_string": "  @Test void test18() {\n    final Unifier.Term e1 = part(W, X);\n    final Unifier.Term e2 = connected(f(W, X), W);\n    assertThatCannotUnify(e1, e2);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest.[void]test19()", "name": "test19", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void test19()", "original_string": "  @Test void test19() {\n    final Unifier.Term e1 = p(f(X), a(), Y);\n    final Unifier.Term e2 = p(f(bill()), Z, g(b()));\n    assertThatUnify(e1, e2, is(\"[bill/X, g(b)/Y, a/Z]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/UnifierTest.java", "class_name": "UnifierTest", "class_uri": "src/test/java/net/hydromatic/morel/UnifierTest.java.UnifierTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[void]test(String)", "name": "test", "arg_nums": 1, "params": [{"name": "path", "type": "String"}], "return_type": "void", "signature": "@ParameterizedTest @MethodSource(\"data\") void test(String path)", "original_string": "  @ParameterizedTest @MethodSource(\"data\") void test(String path)\n      throws Exception {\n    Method method = findMethod(path);\n    if (method != null) {\n      try {\n        method.invoke(this);\n      } catch (InvocationTargetException e) {\n        Throwable cause = e.getCause();\n        if (cause instanceof Exception) {\n          throw (Exception) cause;\n        }\n        if (cause instanceof Error) {\n          throw (Error) cause;\n        }\n        throw e;\n      }\n    } else {\n      checkRun(path);\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ScriptTest.java", "class_name": "ScriptTest", "class_uri": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest", "attributes": {"modifiers": "@ParameterizedTest @MethodSource(\"data\")", "marker_annotations": ["@ParameterizedTest"], "non_marker_annotations": ["@MethodSource(\"data\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[void]testScript()", "name": "testScript", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testScript()", "original_string": "  @Test void testScript() throws Exception {\n    checkRun(\"script.sml\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ScriptTest.java", "class_name": "ScriptTest", "class_uri": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testScott()", "name": "testScott", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testScott()", "original_string": "  @Test void testScott() {\n    final String ml = \"let\\n\"\n        + \"  val emps = #emp scott\\n\"\n        + \"in\\n\"\n        + \"  from e in emps yield #deptno e\\n\"\n        + \"end\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"int list\")\n        .assertEvalIter(\n            equalsOrdered(20, 30, 30, 20, 30, 30, 10, 20, 10, 30, 20, 30, 20,\n                10));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a program that uses an external collection from the \"scott\" JDBC\ndatabase."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testScott2()", "name": "testScott2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testScott2()", "original_string": "  @Test void testScott2() {\n    final String ml = \"from e in scott.emp yield e.deptno\";\n    final String plan = \"LogicalProject(deptno=[$7])\\n\"\n        + \"  JdbcTableScan(table=[[scott, EMP]])\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"int list\")\n        .assertCalcite(is(plan))\n        .assertEvalIter(\n            equalsOrdered(20, 30, 30, 20, 30, 30, 10, 20, 10, 30, 20, 30, 20,\n                10));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As previous, but with more concise syntax."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testScottOrder()", "name": "testScottOrder", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testScottOrder()", "original_string": "  @Test void testScottOrder() {\n    final String ml = \"from e in scott.emp\\n\"\n        + \" yield {e.empno, e.deptno}\\n\"\n        + \" order empno desc\\n\"\n        + \" skip 2 take 4\";\n    // When fixed,\n    //   [CALCITE-6128] RelBuilder.sortLimit should compose offset and fetch\n    // will yield a plan with one fewer LogicalSort\n    final String plan = \"LogicalSort(fetch=[4])\\n\"\n        + \"  LogicalSort(sort0=[$1], dir0=[DESC], offset=[2])\\n\"\n        + \"    LogicalProject(deptno=[$7], empno=[$0])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{deptno:int, empno:int} list\")\n        .assertCalcite(is(plan))\n        .assertEvalIter(\n            equalsOrdered(list(30, 7900), list(20, 7876), list(30, 7844),\n                list(10, 7839)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testScottJoin()", "name": "testScottJoin", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testScottJoin()", "original_string": "  @Test void testScottJoin() {\n    final String ml = \"let\\n\"\n        + \"  val emps = #emp scott\\n\"\n        + \"  and depts = #dept scott\\n\"\n        + \"in\\n\"\n        + \"  from e in emps, d in depts\\n\"\n        + \"    where #deptno e = #deptno d\\n\"\n        + \"    andalso #empno e >= 7900\\n\"\n        + \"    yield {empno = #empno e, dname = #dname d}\\n\"\n        + \"end\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dname:string, empno:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(\"SALES\", 7900), list(\"RESEARCH\", 7902),\n                list(\"ACCOUNTING\", 7934)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testScottJoin2()", "name": "testScottJoin2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testScottJoin2()", "original_string": "  @Test void testScottJoin2() {\n    final String ml = \"from e in #emp scott, d in #dept scott\\n\"\n        + \"  where #deptno e = #deptno d\\n\"\n        + \"  andalso #empno e >= 7900\\n\"\n        + \"  yield {empno = #empno e, dname = #dname d}\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dname:string, empno:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(\"SALES\", 7900), list(\"RESEARCH\", 7902),\n                list(\"ACCOUNTING\", 7934)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testScottJoin()} but without intermediate variables."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testScottJoin2Dot()", "name": "testScottJoin2Dot", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testScottJoin2Dot()", "original_string": "  @Test void testScottJoin2Dot() {\n    final String ml = \"from e in scott.emp, d in scott.dept\\n\"\n        + \"  where e.deptno = d.deptno\\n\"\n        + \"  andalso e.empno >= 7900\\n\"\n        + \"  yield {empno = e.empno, dname = d.dname}\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dname:string, empno:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(\"SALES\", 7900), list(\"RESEARCH\", 7902),\n                list(\"ACCOUNTING\", 7934)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testScottJoin2()} but using dot notation ('e.field' rather\nthan '#field e')."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testQueryList()", "name": "testQueryList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testQueryList()", "original_string": "  @Test void testQueryList() {\n    final String[] queries = {\n        \"from\",\n        \"from e in scott.emp\",\n        \"from e in scott.emp yield e.deptno\",\n        \"from e in scott.emp yield {e.deptno, e.ename}\",\n        \"from e in scott.emp yield {e.ename, e.deptno}\",\n        \"from e in scott.emp\\n\"\n            + \"  yield {e.ename, x = e.deptno + e.empno, b = true, \"\n            // + \"c = #\\\"c\\\", \"\n            + \"i = 3, r = 3.14, \"\n            // + \"u = (), \"\n            + \"s = \\\"hello\\\"}\",\n        \"from e in scott.emp yield ()\",\n        \"from e in scott.emp yield e\",\n        \"from e in scott.emp where e.job = \\\"CLERK\\\" yield e\",\n        \"from n in [1,2,3] yield n\",\n        \"from n in [1,2,3] where n mod 2 = 1 andalso n < 3 yield n\",\n        \"from n in [1,2,3] where false yield n\",\n        \"from n in [1,2,3] where n < 2 orelse n > 2 yield n * 3\",\n        \"from r in [{a=1,b=2},{a=1,b=0},{a=2,b=1}]\\n\"\n            + \"  order r.a desc, r.b\\n\"\n            + \"  yield {r.a, b10 = r.b * 10}\",\n        \"from r in [{a=2,b=3},{a=2,b=1},{a=1,b=1}]\\n\"\n            + \"  group r.a\",\n        \"from r in [{a=2,b=3},{a=2,b=1},{a=1,b=1}]\\n\"\n            + \"  group compute sb = sum of r.b\",\n        \"from r in [{a=2,b=3},{a=2,b=1},{a=1,b=1}]\\n\"\n            + \"  group r.a\\n\"\n            + \"  yield a\",\n        \"from r in [{a=2,b=3}]\\n\"\n            + \"group r.b compute sb = sum of r.b,\\n\"\n            + \"    mb = min of r.b, a = count\",\n        \"from r in [{a=2,b=3}]\\n\"\n            + \"group r.b compute sb = sum of r.b,\\n\"\n            + \"    mb = min of r.b, a = count\\n\"\n            + \"yield {a, a2 = a + b, sb}\",\n        \"from e in scott.emp\\n\"\n            + \"yield {e.ename, x = e.deptno * 2}\",\n        \"from e in scott.emp\\n\"\n            + \"order e.ename\",\n        \"from e in scott.emp\\n\"\n            + \"order e.ename desc\\n\"\n            + \"take 3\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\\n\"\n            + \"yield {e.ename, d.dname}\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\\n\"\n            + \"yield e\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\\n\"\n            + \"andalso e.job = \\\"CLERK\\\"\\n\"\n            + \"yield d\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\\n\"\n            + \"andalso e.job = \\\"CLERK\\\"\\n\"\n            + \"group e.mgr\",\n        \"from e in scott.emp,\\n\"\n            + \"  g in scott.salgrade\\n\"\n            + \"where e.sal >= g.losal\\n\"\n            + \"  andalso e.sal < g.hisal\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept,\"\n            + \"  g in scott.salgrade\\n\"\n            + \"where e.sal >= g.losal\\n\"\n            + \"  andalso e.sal < g.hisal\\n\"\n            + \"  andalso d.deptno = e.deptno\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept,\"\n            + \"  g in scott.salgrade\\n\"\n            + \"where e.sal >= g.losal\\n\"\n            + \"  andalso e.sal < g.hisal\\n\"\n            + \"  andalso d.deptno = e.deptno\\n\"\n            + \"group g.grade compute c = count\",\n        \"from x in (from e in scott.emp yield {e.deptno, z = 1})\\n\"\n            + \"  union (from d in scott.dept yield {d.deptno, z = 2})\",\n        \"from x in (from e in scott.emp yield e.deptno)\\n\"\n            + \"  union (from d in scott.dept yield d.deptno)\\n\"\n            + \"group x compute c = count\",\n        \"[1, 2, 3] union [2, 3, 4]\",\n        \"[10, 15, 20] union (from d in scott.dept yield d.deptno)\",\n        \"[10, 15, 20] except (from d in scott.dept yield d.deptno)\",\n        \"[10, 15, 20] intersect (from d in scott.dept yield d.deptno)\",\n\n        // the following 4 are equivalent\n        \"from e in scott.emp where e.deptno = 30 yield e.empno\",\n        \"let\\n\"\n            + \"  val emps = #emp scott\\n\"\n            + \"in\\n\"\n            + \"  from e in emps\\n\"\n            + \"  where e.deptno = 30\\n\"\n            + \"  yield e.empno\\n\"\n            + \"end\",\n        \"let\\n\"\n            + \"  val emps = #emp scott\\n\"\n            + \"  val thirty = 30\\n\"\n            + \"in\\n\"\n            + \"  from e in emps\\n\"\n            + \"  where e.deptno = thirty\\n\"\n            + \"  yield e.empno\\n\"\n            + \"end\",\n        \"map (fn e => (#empno e))\\n\"\n            + \"  (List.filter (fn e => (#deptno e) = 30) (#emp scott))\",\n    };\n    Stream.of(queries).filter(q -> !q.startsWith(\"#\")).forEach(query -> {\n      try {\n        ml(query).withBinding(\"scott\", BuiltInDataSet.SCOTT).assertEvalSame();\n      } catch (AssertionError | RuntimeException e) {\n        throw new RuntimeException(\"during query [\" + query + \"]\", e);\n      }\n    });\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that Morel gives the same answer with and without Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testNative()", "name": "testNative", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNative()", "original_string": "  @Test void testNative() {\n    String query = \"\"\n        + \"from r in\\n\"\n        + \"  List.tabulate (6, fn i =>\\n\"\n        + \"    {i, j = i + 3, s = String.substring (\\\"morel\\\", 0, i)})\\n\"\n        + \"yield {r.j, r.s}\";\n    ml(query).withBinding(\"scott\", BuiltInDataSet.SCOTT).assertEvalSame();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Translates a hybrid expression. The leaf cannot be translated to Calcite\nand therefore becomes a Morel table function; the root can."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testHybridCalciteToMorel()", "name": "testHybridCalciteToMorel", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testHybridCalciteToMorel()", "original_string": "  @Test void testHybridCalciteToMorel() {\n    final String ml = \"List.filter\\n\"\n        + \"  (fn x => x.empno < 7500)\\n\"\n        + \"  (from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLERK\\\"\\n\"\n        + \"  yield {e.empno, e.deptno, d5 = e.deptno + 5})\";\n    String plan = \"\"\n        + \"apply(\"\n        + \"fnCode apply(fnValue List.filter, \"\n        + \"argCode match(x, apply2(fnValue <, \"\n        + \"apply(fnValue nth:2, argCode get(name x)),\"\n        + \" constant(7500)))), \"\n        + \"argCode calcite(\"\n        + \"plan LogicalProject(d5=[+($1, 5)], deptno=[$1], empno=[$2])\\n\"\n        + \"  LogicalFilter(condition=[=($5, 'CLERK')])\\n\"\n        + \"    LogicalProject(comm=[$6], deptno=[$7], empno=[$0], ename=[$1], \"\n        + \"hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \"))\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"{d5:int, deptno:int, empno:int} list\")\n        .assertEvalIter(equalsOrdered(list(25, 20, 7369)))\n        .assertPlan(isCode(plan));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a query that can mostly be executed in Calcite, but is followed by\nList.filter, which must be implemented in Morel. Therefore Morel calls\ninto the internal \"calcite\" function, passing the Calcite plan to be\nexecuted."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testFullCalcite()", "name": "testFullCalcite", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFullCalcite()", "original_string": "  @Test void testFullCalcite() {\n    final String ml = \"from e in scott.emp\\n\"\n        + \"  where e.empno < 7500\\n\"\n        + \"  yield {e.empno, e.deptno, d5 = e.deptno + 5}\";\n    checkFullCalcite(ml);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a query that can be fully executed in Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testFullCalcite2()", "name": "testFullCalcite2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFullCalcite2()", "original_string": "  @Test void testFullCalcite2() {\n    final String ml = \"let\\n\"\n        + \"  val emp = scott.emp\\n\"\n        + \"in\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.empno < 7500\\n\"\n        + \"  yield {e.empno, e.deptno, d5 = e.deptno + 5}\\n\"\n        + \"end\";\n    checkFullCalcite(ml);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFullCalcite()} but table is via a {@code let}."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testFullCalcite3()", "name": "testFullCalcite3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFullCalcite3()", "original_string": "  @Test void testFullCalcite3() {\n    final String ml = \"let\\n\"\n        + \"  fun query emp =\\n\"\n        + \"    from e in emp\\n\"\n        + \"    where e.empno < 7500\\n\"\n        + \"    yield {e.empno, e.deptno, d5 = e.deptno + 5}\\n\"\n        + \"in\\n\"\n        + \"  query scott.emp\\n\"\n        + \"end\";\n    checkFullCalcite(ml);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFullCalcite()} but query is a function, and table is\npassed via an argument."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testCalciteFrom()", "name": "testCalciteFrom", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCalciteFrom()", "original_string": "  @Test void testCalciteFrom() {\n    final String ml = \"from\";\n    String plan = \"calcite(plan LogicalValues(tuples=[[{  }]])\\n)\";\n    ml(ml)\n        .with(Prop.HYBRID, true)\n        .assertType(\"unit list\")\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(list()));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a query that is \"from\" over no variables. The result has one row\nand zero columns."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testCalciteWithVariable()", "name": "testCalciteWithVariable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCalciteWithVariable()", "original_string": "  @Test void testCalciteWithVariable() {\n    final String plan = \"let(matchCode0 match(five, \"\n        + \"apply2(fnValue +, constant(2), constant(3))), \"\n        + \"resultCode calcite(plan \"\n        + \"LogicalProject(d5=[+($1, morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n\"\n        + \"}'))], deptno=[$1], empno=[$2])\\n\"\n        + \"  LogicalFilter(condition=[<($2, +(7500, +(morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n\"\n        + \"}'), morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n\"\n        + \"}'))))])\\n\"\n        + \"    LogicalProject(comm=[$6], deptno=[$7], empno=[$0], ename=[$1], \"\n        + \"hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \"))\";\n    final int inlinePassCount = 1; // limit inlining\n    checkCalciteWithVariable(inlinePassCount, plan);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a query that is executed in Calcite except for a variable, 'five',\nwhose value happens to always be '2 + 3'."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testCalciteWithVariableNoInlining()", "name": "testCalciteWithVariableNoInlining", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCalciteWithVariableNoInlining()", "original_string": "  @Test void testCalciteWithVariableNoInlining() {\n    final String plan = \"let(matchCode0 match(five, \"\n        + \"apply2(fnValue +, constant(2), constant(3))), \"\n        + \"resultCode let(matchCode0 match(ten, \"\n        + \"apply2(fnValue +, get(name five), get(name five))), \"\n        + \"resultCode calcite(plan \"\n        + \"LogicalProject(d5=[+($1, morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n}'))], deptno=[$1], empno=[$2])\\n\"\n        + \"  LogicalFilter(condition=[<($2, +(7500, morelScalar('ten', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n}')))])\\n\"\n        + \"    LogicalProject(comm=[$6], deptno=[$7], empno=[$0], ename=[$1], \"\n        + \"hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")))\";\n    final int inlinePassCount = 0;\n    checkCalciteWithVariable(inlinePassCount, plan);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testCalciteWithFunction()", "name": "testCalciteWithFunction", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCalciteWithFunction()", "original_string": "  @Test void testCalciteWithFunction() {\n    final String ml = \"let\\n\"\n        + \"  fun twice x = x + x\\n\"\n        + \"in\\n\"\n        + \"  from d in scott.dept\\n\"\n        + \"  yield twice d.deptno\\n\"\n        + \"end\";\n    String plan = \"let(matchCode0 match(twice, match(x, \"\n        + \"apply2(fnValue +, get(name x), get(name x)))), \"\n        + \"resultCode calcite(plan \"\n        + \"LogicalProject($f0=[morelScalar('int', \"\n        + \"morelScalar('twice', '{\\n\"\n        + \"  \\\"type\\\": \\\"ANY\\\",\\n\"\n        + \"  \\\"nullable\\\": false,\\n\"\n        + \"  \\\"precision\\\": -1,\\n\"\n        + \"  \\\"scale\\\": -1\\n\"\n        + \"}'), $0)])\\n\"\n        + \"  JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \"))\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .with(Prop.INLINE_PASS_COUNT, 0)\n        .assertType(\"int list\")\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(20, 40, 60, 80));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a query that is executed in Calcite except for a function,\n'twice'."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testCalciteWithHybridFunction()", "name": "testCalciteWithHybridFunction", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCalciteWithHybridFunction()", "original_string": "  @Test void testCalciteWithHybridFunction() {\n    final String ml = \"let\\n\"\n        + \"  fun plus (x, y) = x + y\\n\"\n        + \"  val five = 5\\n\"\n        + \"in\\n\"\n        + \"  from d in scott.dept\\n\"\n        + \"  yield plus (d.deptno, five)\\n\"\n        + \"end\";\n    String plan = \"let(matchCode0 match(plus, match(v0, \"\n        + \"apply(fnCode match((x, y), apply2(fnValue +, \"\n        + \"get(name x), get(name y))), \"\n        + \"argCode get(name v0)))), \"\n        + \"resultCode let(matchCode0 match(five, constant(5)), \"\n        + \"resultCode calcite(plan \"\n        + \"LogicalProject($f0=[morelScalar('int * int', \"\n        + \"morelScalar('plus', '{\\n\"\n        + \"  \\\"type\\\": \\\"ANY\\\",\\n\"\n        + \"  \\\"nullable\\\": false,\\n\"\n        + \"  \\\"precision\\\": -1,\\n\"\n        + \"  \\\"scale\\\": -1\\n\"\n        + \"}'), ROW($0, morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n\"\n        + \"}')))])\\n\"\n        + \"  JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \")))\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .with(Prop.INLINE_PASS_COUNT, 0)\n        .assertType(\"int list\")\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(15, 25, 35, 45));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a query that is executed in Calcite except for a function,\n'plus'; one of its arguments comes from a relational record, and another\nfrom the Morel environment."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testUnion()", "name": "testUnion", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testUnion()", "original_string": "  @Test void testUnion() {\n    final String ml = \"from x in (\\n\"\n        + \"(from e in scott.emp where e.job = \\\"CLERK\\\" yield e.deptno)\\n\"\n        + \"union\\n\"\n        + \"(from d in scott.dept yield d.deptno))\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"int list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(equalsUnordered(20, 20, 20, 40, 10, 10, 30, 30));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that we can send {@code union} to Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testExcept()", "name": "testExcept", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testExcept()", "original_string": "  @Test void testExcept() {\n    final String ml = \"from x in (\\n\"\n        + \"(from d in scott.dept yield d.deptno)\"\n        + \"except\\n\"\n        + \"(from e in scott.emp where e.job = \\\"CLERK\\\" yield e.deptno))\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"int list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(equalsUnordered(40));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that we can send {@code except} to Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testIntersect()", "name": "testIntersect", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testIntersect()", "original_string": "  @Test void testIntersect() {\n    final String ml = \"from x in (\\n\"\n        + \"(from e in scott.emp where e.job = \\\"CLERK\\\" yield e.deptno)\\n\"\n        + \"intersect\\n\"\n        + \"(from d in scott.dept yield d.deptno))\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"int list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(equalsUnordered(10, 20, 30));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that we can send {@code intersect} to Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testElem()", "name": "testElem", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testElem()", "original_string": "  @Test void testElem() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"where d.deptno elem (from e in scott.emp\\n\"\n        + \"    where e.job elem [\\\"ANALYST\\\", \\\"PRESIDENT\\\"]\\n\"\n        + \"    yield e.deptno)\\n\"\n        + \"yield d.dname\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"string list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(equalsUnordered(\"ACCOUNTING\", \"RESEARCH\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that we can send (what in SQL would be) an uncorrelated {@code IN}\nsub-query to Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testNotElem()", "name": "testNotElem", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNotElem()", "original_string": "  @Test void testNotElem() {\n    final UnaryOperator<Ml> fn = ml ->\n        ml.withBinding(\"scott\", BuiltInDataSet.SCOTT)\n            .with(Prop.HYBRID, true)\n            .assertType(\"string list\")\n            .assertPlan(isFullyCalcite())\n            .assertEvalIter(equalsUnordered(\"SALES\", \"OPERATIONS\"));\n\n    final String ml0 = \"from d in scott.dept\\n\"\n        + \"where not (d.deptno elem\\n\"\n        + \"    (from e in scott.emp\\n\"\n        + \"        where e.job elem [\\\"ANALYST\\\", \\\"PRESIDENT\\\"]\\n\"\n        + \"        yield e.deptno))\\n\"\n        + \"yield d.dname\";\n    final String ml1 = \"from d in scott.dept\\n\"\n        + \"where d.deptno notelem (from e in scott.emp\\n\"\n        + \"    where e.job elem [\\\"ANALYST\\\", \\\"PRESIDENT\\\"]\\n\"\n        + \"    yield e.deptno)\\n\"\n        + \"yield d.dname\";\n    fn.apply(ml(ml0));\n    fn.apply(ml(ml1));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that we can send (what in SQL would be) an uncorrelated {@code IN}\nsub-query to Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testExists()", "name": "testExists", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testExists()", "original_string": "  @Test void testExists() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"where exists (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLERK\\\")\\n\"\n        + \"yield d.deptno\";\n    String plan = \"calcite(plan \"\n        + \"LogicalProject(deptno=[$0])\\n\"\n        + \"  LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"    LogicalJoin(condition=[true], joinType=[inner])\\n\"\n        + \"      LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"        JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \"      LogicalAggregate(group=[{0}])\\n\"\n        + \"        LogicalProject(i=[true])\\n\"\n        + \"          LogicalFilter(condition=[=($5, 'CLERK')])\\n\"\n        + \"            LogicalProject(comm=[$6], deptno=[$7], empno=[$0], \"\n        + \"ename=[$1], hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"              JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"int list\")\n        .assertPlan(isFullyCalcite())\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(10, 20, 30, 40));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that {@code exists} is pushed down to Calcite.\n(There are no correlating variables.)"}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testNotExists()", "name": "testNotExists", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNotExists()", "original_string": "  @Test void testNotExists() {\n    final UnaryOperator<Ml> fn = ml ->\n        ml.withBinding(\"scott\", BuiltInDataSet.SCOTT)\n            .with(Prop.HYBRID, true)\n            .assertType(\"int list\")\n            .assertPlan(isFullyCalcite())\n            .assertEvalIter(equalsOrdered(10, 20, 30, 40));\n    final String ml0 = \"from d in scott.dept\\n\"\n        + \"where not (exists (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLARK KENT\\\"))\\n\"\n        + \"yield d.deptno\";\n    final String plan0 = \"calcite(plan \"\n        + \"LogicalProject(deptno=[$0])\\n\"\n        + \"  LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"    LogicalFilter(condition=[IS NULL($3)])\\n\"\n        + \"      LogicalJoin(condition=[true], joinType=[left])\\n\"\n        + \"        LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"          JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \"        LogicalAggregate(group=[{0}])\\n\"\n        + \"          LogicalProject(i=[true])\\n\"\n        + \"            LogicalFilter(condition=[=($5, 'CLARK KENT')])\\n\"\n        + \"              LogicalProject(comm=[$6], deptno=[$7], empno=[$0], \"\n        + \"ename=[$1], hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"                JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")\";\n    final String ml1 = \"from d in scott.dept\\n\"\n        + \"where notExists (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLARK KENT\\\")\\n\"\n        + \"yield d.deptno\";\n    final String ml2 = \"from d in scott.dept\\n\"\n        + \"where List.null (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLARK KENT\\\")\\n\"\n        + \"yield d.deptno\";\n    fn.apply(ml(ml0))\n        .assertPlan(isCode(plan0));\n    fn.apply(ml(ml1));\n    fn.apply(ml(ml2));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that {@code not exists} (uncorrelated), also {@code notExists} and\n{@code List.null}, is pushed down to Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testExistsCorrelated()", "name": "testExistsCorrelated", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testExistsCorrelated()", "original_string": "  @Test void testExistsCorrelated() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"where exists (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.deptno = d.deptno\\n\"\n        + \"  andalso e.job = \\\"CLERK\\\")\";\n    String plan = \"calcite(plan \"\n        + \"LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"  LogicalJoin(condition=[=($0, $3)], joinType=[inner])\\n\"\n        + \"    LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"      JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \"    LogicalProject(deptno=[$0], $f1=[true])\\n\"\n        + \"      LogicalAggregate(group=[{0}])\\n\"\n        + \"        LogicalProject(deptno=[$1])\\n\"\n        + \"          LogicalFilter(condition=[AND(=($5, 'CLERK'), \"\n        + \"IS NOT NULL($1))])\\n\"\n        + \"            LogicalProject(comm=[$6], deptno=[$7], empno=[$0], \"\n        + \"ename=[$1], hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"              JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"{deptno:int, dname:string, loc:string} list\")\n        .assertPlan(isFullyCalcite())\n        .assertPlan(isCode(plan))\n        .assertEvalIter(\n            equalsOrdered(list(10, \"ACCOUNTING\", \"NEW YORK\"),\n                list(20, \"RESEARCH\", \"DALLAS\"),\n                list(30, \"SALES\", \"CHICAGO\")));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that correlated {@code exists} is pushed down to Calcite."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testCorrelatedListSubQuery()", "name": "testCorrelatedListSubQuery", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCorrelatedListSubQuery()", "original_string": "  @Test void testCorrelatedListSubQuery() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"yield {d.dname, empCount = (from e in scott.emp\\n\"\n        + \"                            group e.deptno compute c = count\\n\"\n        + \"                            where deptno = d.deptno\\n\"\n        + \"                            yield c)}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        // TODO: enable in hybrid; will require new method RexSubQuery.array\n        // .with(Prop.HYBRID, true)\n        .assertType(\"{dname:string, empCount:int list} list\")\n        .assertEvalIter(\n            equalsOrdered(list(\"ACCOUNTING\", list(3)),\n                list(\"RESEARCH\", list(5)),\n                list(\"SALES\", list(6)),\n                list(\"OPERATIONS\", list())));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testCorrelatedScalar()", "name": "testCorrelatedScalar", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCorrelatedScalar()", "original_string": "  @Test void testCorrelatedScalar() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"yield {d.dname, empCount =\\n\"\n        + \"    only (from e in scott.emp\\n\"\n        + \"          where e.deptno = d.deptno\\n\"\n        + \"          group compute count)}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"{dname:string, empCount:int} list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(\n            equalsOrdered(list(\"ACCOUNTING\", 3),\n                list(\"RESEARCH\", 5),\n                list(\"SALES\", 6),\n                list(\"OPERATIONS\", 0)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testRecursive()", "name": "testRecursive", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRecursive()", "original_string": "  @Test void testRecursive() {\n    final String ml = \"let\\n\"\n        + \"  fun descendants2 descendants newDescendants =\\n\"\n        + \"    if List.null newDescendants then\\n\"\n        + \"      descendants\\n\"\n        + \"    else\\n\"\n        + \"      descendants2 (descendants union newDescendants)\\n\"\n        + \"          (from d in newDescendants,\\n\"\n        + \"              e in scott.emp\\n\"\n        + \"            where e.mgr = d.e.empno\\n\"\n        + \"            yield {e, level = d.level + 1})\\n\"\n        + \"in\\n\"\n        + \"  from d in descendants2 []\\n\"\n        + \"      (from e in scott.emp\\n\"\n        + \"        where e.mgr = 0\\n\"\n        + \"        yield {e, level = 0})\\n\"\n        + \"    yield {d.e.empno, d.e.mgr, d.e.ename, d.level}\\n\"\n        + \"end\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{empno:int, ename:string, level:int, mgr:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(7839, \"KING\", 0, 0),\n                list(7566, \"JONES\", 1, 7839), list(7698, \"BLAKE\", 1, 7839),\n                list(7782, \"CLARK\", 1, 7839), list(7788, \"SCOTT\", 2, 7566),\n                list(7902, \"FORD\", 2, 7566), list(7499, \"ALLEN\", 2, 7698),\n                list(7521, \"WARD\", 2, 7698), list(7654, \"MARTIN\", 2, 7698),\n                list(7844, \"TURNER\", 2, 7698), list(7900, \"JAMES\", 2, 7698),\n                list(7934, \"MILLER\", 2, 7782), list(7876, \"ADAMS\", 3, 7788),\n                list(7369, \"SMITH\", 3, 7902)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a recursive query that computes a transitive closure by successive\nunion operations. We cannot execute hybrid yet."}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]testRecursive2()", "name": "testRecursive2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRecursive2()", "original_string": "  @Test void testRecursive2() {\n    final String ml = \"from i in iterate\\n\"\n        + \"    (from e in scott.emp\\n\"\n        + \"      where e.mgr = 0\\n\"\n        + \"      yield {e, level = 0})\\n\"\n        + \"    fn (oldList, newList) =>\\n\"\n        + \"      (from d in newList,\\n\"\n        + \"          e in scott.emp\\n\"\n        + \"        where e.mgr = d.e.empno\\n\"\n        + \"        yield {e, level = d.level + 1})\\n\"\n        + \"  yield {i.e.empno, i.e.ename, i.level, i.e.mgr}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{empno:int, ename:string, level:int, mgr:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(7839, \"KING\", 0, 0),\n                list(7566, \"JONES\", 1, 7839), list(7698, \"BLAKE\", 1, 7839),\n                list(7782, \"CLARK\", 1, 7839), list(7788, \"SCOTT\", 2, 7566),\n                list(7902, \"FORD\", 2, 7566), list(7499, \"ALLEN\", 2, 7698),\n                list(7521, \"WARD\", 2, 7698), list(7654, \"MARTIN\", 2, 7698),\n                list(7844, \"TURNER\", 2, 7698), list(7900, \"JAMES\", 2, 7698),\n                list(7934, \"MILLER\", 2, 7782), list(7876, \"ADAMS\", 3, 7788),\n                list(7369, \"SMITH\", 3, 7902)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "class_name": "AlgebraTest", "class_uri": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Similar to {@link #testRecursive()} but uses the\n{@link net.hydromatic.morel.compile.BuiltIn#RELATIONAL_ITERATE Relatonal.iterate}\nfunction."}, {"uris": "src/test/java/net/hydromatic/morel/CalciteTest.java.CalciteTest.[void]testNestedSchema()", "name": "testNestedSchema", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNestedSchema()", "original_string": "  @Test void testNestedSchema() {\n    final Schema userSchema = new ReflectiveSchema(new UserSchema());\n    final Schema taskSchema = new ReflectiveSchema(new TaskSchema());\n\n    final Map<String, ForeignValue> foreignValueMap = Calcite.withDataSets(\n        ImmutableMap.of(\"user\", (Calcite calcite) -> {\n          SchemaPlus newSchema =\n              calcite.rootSchema.add(\"users\", userSchema);\n          newSchema.add(\"task\", taskSchema);\n          newSchema.add(\"task2\", taskSchema);\n          return new CalciteForeignValue(calcite, newSchema, true);\n        })).foreignValues();\n\n    final String sql = \"user;\\n\"\n        + \"user.task;\\n\"\n        + \"user.task2;\\n\"\n        + \"from t in user.users yield t;\\n\"\n        + \"from t in user.task2.tasks yield t;\\n\";\n    final InputStream in = new ByteArrayInputStream(sql.getBytes());\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    final Main main =\n        new Main(ImmutableList.of(), in, new PrintStream(out), foreignValueMap,\n            ImmutableMap.of(), false);\n\n    main.run();\n    if (debug) {\n      System.out.println(out);\n    }\n\n    String expected = \"val it = {task={tasks=<relation>},\"\n        + \"task2={tasks=<relation>},\"\n        + \"users=<relation>}\\n\"\n        + \"  : {task:{tasks:{completed:bool, name:string} list},\\n\"\n        + \"     task2:{tasks:{completed:bool, name:string} list},\\n\"\n        + \"     users:{age:int, name:string} list}\\n\"\n        + \"val it = {tasks=<relation>} : {tasks:{completed:bool, name:string} list}\\n\"\n        + \"val it = {tasks=<relation>} : {tasks:{completed:bool, name:string} list}\\n\"\n        + \"val it = [{age=20,name=\\\"John\\\"},{age=21,name=\\\"Jane\\\"},{age=22,name=\\\"Jack\\\"}]\\n\"\n        + \"  : {age:int, name:string} list\\n\"\n        + \"val it =\\n\"\n        + \"  [{completed=false,name=\\\"Buy milk\\\"},{completed=false,name=\\\"Buy eggs\\\"},\\n\"\n        + \"   {completed=false,name=\\\"Buy bread\\\"}] : {completed:bool, name:string} list\\n\";\n    assertThat(toLinux(out.toString()), is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/CalciteTest.java", "class_name": "CalciteTest", "class_uri": "src/test/java/net/hydromatic/morel/CalciteTest.java.CalciteTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that you if you create a\n{@link net.hydromatic.morel.foreign.CalciteForeignValue}\nwhose schema has nested schemas, those schemas appear as fields."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testEmptyRepl()", "name": "testEmptyRepl", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEmptyRepl()", "original_string": "  @Test void testEmptyRepl() {\n    final List<String> argList = ImmutableList.of();\n    final Map<String, ForeignValue> valueMap = ImmutableMap.of();\n    final Map<Prop, Object> propMap = ImmutableMap.of();\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    try (PrintStream ps = new PrintStream(out)) {\n      final InputStream in = new ByteArrayInputStream(new byte[0]);\n      final Main main = new Main(argList, in, ps, valueMap, propMap, false);\n      main.run();\n    }\n    assertThat(out.size(), is(0));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testRepl()", "name": "testRepl", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRepl()", "original_string": "  @Test void testRepl() {\n    final List<String> argList = ImmutableList.of();\n    final String ml = \"val x = 5;\\n\"\n        + \"x;\\n\"\n        + \"it + 1;\\n\"\n        + \"val f = fn x => x + 1;\\n\"\n        + \"f;\\n\"\n        + \"it x;\\n\";\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    try (PrintStream ps = new PrintStream(out)) {\n      final InputStream in = new ByteArrayInputStream(ml.getBytes());\n      final Map<String, ForeignValue> valueMap = ImmutableMap.of();\n      final Map<Prop, Object> propMap = ImmutableMap.of();\n      final Main main = new Main(argList, in, ps, valueMap, propMap, false);\n      main.run();\n    }\n    final String expected = \"val x = 5 : int\\n\"\n        + \"val it = 5 : int\\n\"\n        + \"val it = 6 : int\\n\"\n        + \"val f = fn : int -> int\\n\"\n        + \"val it = fn : int -> int\\n\"\n        + \"val it = 6 : int\\n\";\n    assertThat(out, hasToString(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testParse()", "name": "testParse", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testParse()", "original_string": "  @Test void testParse() {\n    ml(\"1\").assertParseLiteral(isLiteral(BigDecimal.ONE, \"1\"));\n    ml(\"~3.5\").assertParseLiteral(isLiteral(new BigDecimal(\"-3.5\"), \"~3.5\"));\n    ml(\"\\\"a string\\\"\")\n        .assertParseLiteral(isLiteral(\"a string\", \"\\\"a string\\\"\"));\n    ml(\"\\\"\\\"\").assertParseLiteral(isLiteral(\"\", \"\\\"\\\"\"));\n    ml(\"\\\"a\\\\\\\\b\\\\\\\"c\\\"\")\n        .assertParseLiteral(isLiteral(\"a\\\\b\\\"c\", \"\\\"a\\\\\\\\b\\\\\\\"c\\\"\"));\n    ml(\"#\\\"a\\\"\").assertParseLiteral(isLiteral('a', \"#\\\"a\\\"\"));\n    ml(\"#\\\"\\\\\\\"\\\"\").assertParseLiteral(isLiteral('\"', \"#\\\"\\\\\\\"\\\"\"));\n    ml(\"#\\\"\\\\\\\\\\\"\").assertParseLiteral(isLiteral('\\\\', \"#\\\"\\\\\\\\\\\"\"));\n\n    // true and false are variables, not actually literals\n    ml(\"true\").assertParseStmt(Ast.Id.class, \"true\");\n    ml(\"false\").assertParseStmt(Ast.Id.class, \"false\");\n\n    ml(\"val x = 5\").assertParseDecl(Ast.ValDecl.class, \"val x = 5\");\n    ml(\"val `x` = 5\").assertParseDecl(Ast.ValDecl.class, \"val x = 5\");\n    ml(\"val x : int = 5\")\n        .assertParseDecl(Ast.ValDecl.class, \"val x : int = 5\");\n\n    // other valid identifiers\n    ml(\"val x' = 5\").assertParseDecl(Ast.ValDecl.class, \"val x' = 5\");\n    ml(\"val x'' = 5\").assertParseDecl(Ast.ValDecl.class, \"val x'' = 5\");\n    ml(\"val x'y = 5\").assertParseDecl(Ast.ValDecl.class, \"val x'y = 5\");\n    ml(\"val ABC123 = 5\").assertParseDecl(Ast.ValDecl.class, \"val ABC123 = 5\");\n    ml(\"val Abc_123 = 6\").assertParseDecl(Ast.ValDecl.class, \"val Abc_123 = 6\");\n    ml(\"val Abc_ = 7\").assertParseDecl(Ast.ValDecl.class, \"val Abc_ = 7\");\n\n    ml(\"val succ = fn x => x + 1\")\n        .assertParseDecl(Ast.ValDecl.class, \"val succ = fn x => x + 1\");\n\n    ml(\"val plus = fn x => fn y => x + y\")\n        .assertParseDecl(Ast.ValDecl.class, \"val plus = fn x => fn y => x + y\");\n\n    ml(\"fun plus x y = x + y\")\n        .assertParseDecl(Ast.FunDecl.class, \"fun plus x y = x + y\");\n\n    ml(\"datatype 'a option = NONE | SOME of 'a\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype 'a option = NONE | SOME of 'a\");\n\n    ml(\"datatype color = RED | GREEN | BLUE\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype color = RED | GREEN | BLUE\");\n    ml(\"datatype 'a tree = Empty | Node of 'a * 'a forest\\n\"\n        + \"and      'a forest = Nil | Cons of 'a tree * 'a forest\")\n        .assertParseDecl(Ast.DatatypeDecl.class, \"datatype 'a tree = Empty\"\n            + \" | Node of 'a * 'a forest \"\n            + \"and 'a forest = Nil\"\n            + \" | Cons of 'a tree * 'a forest\");\n\n    final String ml = \"datatype ('a, 'b) choice =\"\n        + \" NEITHER\"\n        + \" | LEFT of 'a\"\n        + \" | RIGHT of 'b\"\n        + \" | BOTH of {a: 'a, b: 'b}\";\n    ml(ml).assertParseSame();\n\n    // -> is right-associative\n    ml(\"datatype x = X of int -> int -> int\").assertParseSame();\n    ml(\"datatype x = X of (int -> int) -> int\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of (int -> int) -> int\");\n    ml(\"datatype x = X of int -> (int -> int)\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of int -> int -> int\");\n\n    ml(\"datatype x = X of int * int list\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of int * int list\");\n    ml(\"datatype x = X of int * (int list)\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of int * int list\");\n    ml(\"datatype x = X of (int * int) list\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of (int * int) list\");\n    ml(\"datatype x = X of (int, int) pair\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of (int, int) pair\");\n\n    // \"*\" is non-associative; parentheses cannot be removed\n    ml(\"datatype ('a, 'b, 'c) foo = Triple of 'a * 'b * 'c\").assertParseSame();\n    ml(\"datatype ('a, 'b, 'c) foo = Triple of 'a * ('b * 'c)\")\n        .assertParseSame();\n    ml(\"datatype ('a, 'b, 'c) foo = Triple of ('a * 'b) * 'c\")\n        .assertParseSame();\n\n    // parentheses creating left precedence, which is the natural precedence for\n    // '+', can be removed\n    ml(\"((1 + 2) + 3) + 4\")\n        .assertParse(\"1 + 2 + 3 + 4\");\n\n    // parentheses creating right precedence can not be removed\n    ml(\"1 + (2 + (3 + (4)))\")\n        .assertParse(\"1 + (2 + (3 + 4))\");\n\n    ml(\"1 + (2 + (3 + 4)) = 5 + 5\")\n        .assertParse(\"1 + (2 + (3 + 4)) = 5 + 5\");\n\n    // :: is right-associative\n    ml(\"1 :: 2 :: 3 :: []\")\n        .assertParse(\"1 :: 2 :: 3 :: []\");\n    ml(\"((1 :: 2) :: 3) :: []\")\n        .assertParse(\"((1 :: 2) :: 3) :: []\");\n    ml(\"1 :: (2 :: (3 :: []))\")\n        .assertParse(\"1 :: 2 :: 3 :: []\");\n    ml(\"1 + 2 :: 3 + 4 * 5 :: 6\").assertParseSame();\n\n    // o is left-associative;\n    // lower precedence than \"=\" (4), higher than \"andalso\" (2)\n    ml(\"f o g\").assertParseSame();\n    ml(\"f o g o h\").assertParseSame();\n    ml(\"f o (g o h)\").assertParseSame();\n    ml(\"(f o g) o h\").assertParse(\"f o g o h\");\n\n    ml(\"a = f o g andalso c = d\").assertParseSame();\n    ml(\"a = (f o g) andalso (c = d)\").assertParse(\"a = (f o g) andalso c = d\");\n    ml(\"(a = f) o g andalso (c = d)\").assertParse(\"a = f o g andalso c = d\");\n\n    // @ is right-associative;\n    // lower precedence than \"+\" (6), higher than \"=\" (4)\n    ml(\"f @ g\").assertParseSame();\n    ml(\"f @ g @ h\").assertParseSame();\n    ml(\"f @ (g @ h)\").assertParse(\"f @ g @ h\");\n    ml(\"(f @ g) @ h\").assertParseSame();\n\n    // ^ is left-associative;\n    // lower precedence than \"*\" (7), higher than \"@\" (5)\n    ml(\"a * f ^ g @ b\").assertParseSame();\n    ml(\"(a * f) ^ (g @ b)\").assertParse(\"a * f ^ (g @ b)\");\n\n    ml(\"(1 + 2, 3, true, (5, 6), 7 = 8)\").assertParseSame();\n\n    ml(\"let val x = 2 in x + (3 + x) + x end\").assertParseSame();\n\n    ml(\"let val x = 2 and y = 3 in x + y end\").assertParseSame();\n    ml(\"let val rec x = 2 and y = 3 in x + y end\").assertParseSame();\n    ml(\"let val x = 2 and rec y = 3 in x + y end\")\n        .assertParseThrowsParseException(\n            containsString(\n                \"Encountered \\\" \\\"rec\\\" \\\"rec \\\"\\\" at line 1, column 19.\"));\n\n    // : is right-associative and low precedence\n    ml(\"1 : int : int\").assertParseSame();\n    ml(\"(2 : int) + 1 : int\").assertParseSame();\n    ml(\"(2 : int) + (1 : int) : int\").assertParseSame();\n    ml(\"((2 : int) + (1 : int)) : int\")\n        .assertParse(\"(2 : int) + (1 : int) : int\");\n\n    // pattern\n    ml(\"let val (x, y) = (1, 2) in x + y end\").assertParseSame();\n    ml(\"let val w as (x, y) = (1, 2) in #1 w + #2 w + x + y end\")\n        .assertParseSame();\n\n    // record\n    ml(\"{a = 1}\").assertParseSame();\n    ml(\"{a = 1, b = 2}\").assertParseSame();\n    ml(\"{a = 1, b = {c = 2, d = true}, e = true}\").assertParseSame();\n\n    // if\n    ml(\"if true then 1 else 2\").assertParseSame();\n\n    // if ... else if\n    ml(\"if true then 1 else if false then 2 else 3\").assertParseSame();\n\n    // case\n    ml(\"case 1 of 0 => \\\"zero\\\" | _ => \\\"nonzero\\\"\").assertParseSame();\n    ml(\"case {a = 1, b = 2} of {a = 1, ...} => 1\").assertParseSame();\n    ml(\"case {a = 1, b = 2} of {...} => 1\").assertParseSame();\n    ml(\"case {a = 1, b = 2} of {a = 3, ...} => 1\")\n        .assertParse(\"case {a = 1, b = 2} of {a = 3, ...} => 1\");\n\n    // fn\n    ml(\"fn x => x + 1\").assertParseSame();\n    ml(\"fn x => x + (1 + 2)\").assertParseSame();\n    ml(\"fn (x, y) => x + y\").assertParseSame();\n    ml(\"fn _ => 42\").assertParseSame();\n    ml(\"fn x => case x of 0 => 1 | _ => 2\").assertParseSame();\n    ml(\"fn () => 42\").assertParseSame();\n\n    // apply\n    ml(\"(fn x => x + 1) 3\").assertParseSame();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testParseComment()", "name": "testParseComment", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testParseComment()", "original_string": "  @Test void testParseComment() {\n    ml(\"1 + (* 2 + *) 3\")\n        .assertParse(\"1 + 3\");\n    ml(\"1 +\\n\"\n        + \"(* 2 +\\n\"\n        + \" *) 3\").assertParse(\"1 + 3\");\n    ml(\"(* 1 +\\n\"\n        + \"2 +\\n\"\n        + \"3 *) 5 + 6\").assertParse(\"5 + 6\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testParseCase()", "name": "testParseCase", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testParseCase()", "original_string": "  @Test void testParseCase() {\n    // SML/NJ allows 'e' and 'E'\n    ml(\"1e2\").assertParse(\"1E+2\");\n    ml(\"1E2\").assertParse(\"1E+2\");\n\n    // keywords such as 'val' and 'in' are case sensitive\n    ml(\"let val x = 1 in x + 1 end\").assertParseSame();\n    ml(\"let VAL x = 1 in x + 1 end\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" <IDENTIFIER> \\\"VAL \\\"\"));\n    ml(\"let val x = 1 IN x + 1 end\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"end\\\" \\\"end \\\"\"));\n\n    // 'notelem' is an infix operator;\n    // 'notElem' and 'NOTELEM' are ordinary identifiers\n    ml(\"1 + f notelem g * 2\")\n        .assertParse(true, \"((((1) + (f))) notelem (((g) * (2))))\");\n    ml(\"1 + f notElem g * 2\")\n        .assertParse(true, \"((1) + (((((((f) (notElem))) (g))) * (2))))\");\n    ml(\"1 + f NOTELEM g * 2\")\n        .assertParse(true, \"((1) + (((((((f) (NOTELEM))) (g))) * (2))))\");\n\n    // 'o' is an infix operator;\n    // 'O' is presumed to be just another value.\n    ml(\"1 + f o g + 2\")\n        .assertParse(true, \"((((1) + (f))) o (((g) + (2))))\");\n    ml(\"1 + F o G + 2\")\n        .assertParse(true, \"((((1) + (F))) o (((G) + (2))))\");\n    ml(\"1 + f O g + 2\")\n        .assertParse(true, \"((((1) + (((((f) (O))) (g))))) + (2))\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testParseDot()", "name": "testParseDot", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testParseDot()", "original_string": "  @Test void testParseDot() {\n    ml(\"a . b\")\n        .assertParse(\"#b a\");\n    ml(\"a . b . c\")\n        .assertParse(\"#c (#b a)\");\n    ml(\"a . b + c . d\")\n        .assertParse(\"#b a + #d c\");\n    ml(\"a.b+c.d\")\n        .assertParse(\"#b a + #d c\");\n    ml(\"(a.b+c.d*e.f.g).h\")\n        .assertParse(\"#h (#b a + #d c * #g (#f e))\");\n    ml(\"a b\")\n        .assertParse(\"a b\");\n    ml(\"a b.c\")\n        .assertParse(\"a (#c b)\");\n    ml(\"a.b c.d e.f\")\n        .assertParse(\"#b a (#d c) (#f e)\");\n    ml(\"(a.b) (c.d) (e.f)\")\n        .assertParse(\"#b a (#d c) (#f e)\");\n    ml(\"(a.(b (c.d) (e.f))\")\n        .assertParseThrowsParseException(\n            containsString(\"Encountered \\\" \\\"(\\\" \\\"( \\\"\\\" at line 1, column 4.\"));\n    ml(\"(a.b c.(d (e.f)))\")\n        .assertParseThrowsParseException(\n            containsString(\"Encountered \\\" \\\"(\\\" \\\"( \\\"\\\" at line 1, column 8.\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that the syntactic sugar \"exp.field\" is de-sugared to\n\"#field exp\"."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testParseAbbreviatedRecord()", "name": "testParseAbbreviatedRecord", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testParseAbbreviatedRecord()", "original_string": "  @Test void testParseAbbreviatedRecord() {\n    ml(\"{a, e.b, #c e, #d (e + 1), e = f + g}\")\n        .assertParse(\"{a = a, b = #b e, c = #c e, d = #d (e + 1), e = f + g}\");\n    ml(\"{v = a, w = e.b, x = #c e, y = #d (e + 1), z = (#f 2)}\")\n        .assertParse(\"{v = a, w = #b e, x = #c e, y = #d (e + 1), z = #f 2}\");\n    ml(\"{w = a = b + c, a = b + c}\")\n        .assertParse(\"{a = b + c, w = a = b + c}\");\n    ml(\"{1}\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression 1\"));\n    ml(\"{a, b + c}\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression b + c\"));\n\n    ml(\"case x of {a = a, b} => a + b\")\n        .assertParse(\"case x of {a = a, b = b} => a + b\");\n    ml(\"case x of {a, b = 2, ...} => a + b\")\n        .assertParse(\"case x of {a = a, b = 2, ...} => a + b\");\n    ml(\"fn {a, b = 2, ...} => a + b\")\n        .assertParse(\"fn {a = a, b = 2, ...} => a + b\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that the abbreviated record syntax \"{a, e.b, #c e, d = e}\"\nis expanded to \"{a = a, b = e.b, c = #c e, d = e}\"."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testParseErrorPosition()", "name": "testParseErrorPosition", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testParseErrorPosition()", "original_string": "  @Test void testParseErrorPosition() {\n    ml(\"let val x = 1 and y = $x$ + 2 in x + y end\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"unbound variable or constructor: x\", pos));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testRuntimeErrorPosition()", "name": "testRuntimeErrorPosition", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRuntimeErrorPosition()", "original_string": "  @Test void testRuntimeErrorPosition() {\n    ml(\"\\\"x\\\" ^\\n\"\n        + \"  $String.substring(\\\"hello\\\",\\n\"\n        + \"    1, 15)$ ^\\n\"\n        + \"  \\\"y\\\"\\n\", '$')\n        .assertEvalError(pos ->\n            throwsA(Codes.BuiltInExn.SUBSCRIPT.mlName, pos));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testTypeVarName()", "name": "testTypeVarName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTypeVarName()", "original_string": "  @Test void testTypeVarName() {\n    assertError(() -> new TypeVar(-1).key(),\n        throwsA(IllegalArgumentException.class, nullValue()));\n    assertThat(new TypeVar(0), hasToString(\"'a\"));\n    assertThat(new TypeVar(1), hasToString(\"'b\"));\n    assertThat(new TypeVar(2), hasToString(\"'c\"));\n    assertThat(new TypeVar(25), hasToString(\"'z\"));\n    assertThat(new TypeVar(26), hasToString(\"'ba\"));\n    assertThat(new TypeVar(27), hasToString(\"'bb\"));\n    assertThat(new TypeVar(51), hasToString(\"'bz\"));\n    assertThat(new TypeVar(52), hasToString(\"'ca\"));\n    assertThat(new TypeVar(53), hasToString(\"'cb\"));\n    assertThat(new TypeVar(26 * 26 - 1), hasToString(\"'zz\"));\n    assertThat(new TypeVar(26 * 26), hasToString(\"'baa\"));\n    assertThat(new TypeVar(27 * 26 - 1), hasToString(\"'baz\"));\n    assertThat(new TypeVar(26 * 26 * 26 - 1), hasToString(\"'zzz\"));\n    assertThat(new TypeVar(26 * 26 * 26), hasToString(\"'baaa\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests the name of {@link TypeVar}."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testType()", "name": "testType", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testType()", "original_string": "  @Test void testType() {\n    ml(\"1\").assertType(\"int\");\n    ml(\"0e0\").assertType(\"real\");\n    ml(\"1 + 2\").assertType(\"int\");\n    ml(\"1 - 2\").assertType(\"int\");\n    ml(\"1 * 2\").assertType(\"int\");\n    ml(\"1 / 2\").assertType(\"int\");\n    ml(\"1 / ~2\").assertType(\"int\");\n    ml(\"1.0 + ~2.0\").assertType(\"real\");\n    ml(\"\\\"\\\"\").assertType(\"string\");\n    ml(\"true andalso false\").assertType(\"bool\");\n    ml(\"if true then 1.0 else 2.0\").assertType(\"real\");\n    ml(\"(1, true)\").assertType(\"int * bool\");\n    ml(\"(1, true, false andalso false)\").assertType(\"int * bool * bool\");\n    ml(\"(1)\").assertType(\"int\");\n    ml(\"()\").assertType(\"unit\");\n    ml(\"{a = 1, b = true}\").assertType(\"{a:int, b:bool}\");\n    ml(\"(fn x => x + 1, fn y => y + 1)\")\n        .assertType(\"(int -> int) * (int -> int)\");\n    ml(\"let val x = 1.0 in x + 2.0 end\").assertType(\"real\");\n\n    final String ml = \"let val x = 1 in\\n\"\n        + \"  let val y = 2 in\\n\"\n        + \"    x + y\\n\"\n        + \"  end\\n\"\n        + \"end\";\n    ml(ml).assertType(\"int\");\n\n    ml(\"1 + \\\"a\\\"\")\n        .assertTypeException(\"Cannot deduce type: conflict: int vs string\");\n\n    ml(\"NONE\").assertType(\"'a option\");\n    ml(\"SOME 4\").assertType(\"int option\");\n    ml(\"SOME (SOME true)\").assertType(\"bool option option\");\n    ml(\"SOME (SOME [1, 2])\")\n        .assertType(\"int list option option\");\n    ml(\"SOME (SOME {a=1, b=true})\")\n        .assertType(\"{a:int, b:bool} option option\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testTypeFn()", "name": "testTypeFn", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTypeFn()", "original_string": "  @Test void testTypeFn() {\n    ml(\"fn x => x + 1\").assertType(\"int -> int\");\n    ml(\"fn x => fn y => x + y\").assertType(\"int -> int -> int\");\n    ml(\"fn x => case x of 0 => 1 | _ => 2\").assertType(\"int -> int\");\n    ml(\"fn x => case x of 0 => \\\"zero\\\" | _ => \\\"nonzero\\\"\")\n        .assertType(\"int -> string\");\n    ml(\"fn x: int => true\").assertType(\"int -> bool\");\n    ml(\"fn x: int * int => true\").assertType(\"int * int -> bool\");\n    ml(\"fn x: int * string => (false, #2 x)\")\n        .assertType(\"int * string -> bool * string\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testTypeFnTuple()", "name": "testTypeFnTuple", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTypeFnTuple()", "original_string": "  @Test void testTypeFnTuple() {\n    ml(\"fn (x, y) => (x + 1, y + 1)\")\n        .assertType(\"int * int -> int * int\");\n    ml(\"(fn x => x + 1, fn y => y + 1)\")\n        .assertType(\"(int -> int) * (int -> int)\");\n    ml(\"fn x => fn (y, z) => x + y + z\")\n        .assertType(\"int -> int * int -> int\");\n    ml(\"fn (x, y) => (x + 1, fn z => (x + z, y + z), y)\")\n        .assertType(\"int * int -> int * (int -> int * int) * int\");\n    ml(\"fn {a = x, b = y, c} => x + y\")\n        .assertType(\"{a:int, b:int, c:'a} -> int\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testTypeLetRecFn()", "name": "testTypeLetRecFn", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTypeLetRecFn()", "original_string": "  @Test void testTypeLetRecFn() {\n    final String ml = \"let\\n\"\n        + \"  val rec f = fn n => if n = 0 then 1 else n * (f (n - 1))\\n\"\n        + \"in\\n\"\n        + \"  f 5\\n\"\n        + \"end\";\n    ml(ml).assertType(\"int\");\n\n    final String ml2 = ml.replace(\" rec\", \"\");\n    assertThat(ml2, not(is(ml)));\n    ml(ml2).assertError(is(\"f not found\"));\n\n    ml(\"let val rec x = 1 and y = 2 in x + y end\")\n        .assertError(\"Error: fn expression required on rhs of val rec\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testRecordType()", "name": "testRecordType", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRecordType()", "original_string": "  @Test void testRecordType() {\n    final String ml = \"map #empno [{empno = 10, name = \\\"Shaggy\\\"}]\";\n    ml(ml).assertType(\"int list\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testIncompleteRecordType()", "name": "testIncompleteRecordType", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testIncompleteRecordType()", "original_string": "  @Test void testIncompleteRecordType() {\n    final String ml = \"fn (e, job) => e.job = job\";\n    String message =\n        \"unresolved flex record (can't tell what fields there are besides #job)\";\n    ml(ml).withTypeExceptionMatcher(throwsA(message))\n        .assertEval();\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testApply()", "name": "testApply", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testApply()", "original_string": "  @Test void testApply() {\n    ml(\"hd [\\\"abc\\\"]\")\n        .assertType(\"string\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testApply2()", "name": "testApply2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testApply2()", "original_string": "  @Test void testApply2() {\n    ml(\"map (fn x => String.size x) [\\\"abc\\\", \\\"de\\\"]\")\n        .assertType(\"int list\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testApplyIsMonomorphic()", "name": "testApplyIsMonomorphic", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testApplyIsMonomorphic()", "original_string": "  @Test void testApplyIsMonomorphic() {\n    // cannot be typed, since the parameter f is in a monomorphic position\n    ml(\"fn f => (f true, f 0)\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Cannot deduce type: conflict: int vs bool\")));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLetIsPolymorphic()", "name": "testLetIsPolymorphic", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test void testLetIsPolymorphic()", "original_string": "  @Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test void testLetIsPolymorphic() {\n    // f has been introduced in a let-expression and is therefore treated as\n    // polymorphic.\n    ml(\"let val f = fn x => x in (f true, f 0) end\")\n        .assertType(\"bool * int\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"disable failing test - enable when we have polymorphic types\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testHdIsPolymorphic()", "name": "testHdIsPolymorphic", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test void testHdIsPolymorphic()", "original_string": "  @Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test void testHdIsPolymorphic() {\n    ml(\"(hd [1, 2], hd [false, true])\")\n        .assertType(\"int * bool\");\n    ml(\"let\\n\"\n        + \"  val h = hd\\n\"\n        + \"in\\n\"\n        + \"   (h [1, 2], h [false, true])\\n\"\n        + \"end\")\n        .assertType(\"int * bool\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"disable failing test - enable when we have polymorphic types\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testTypeVariable()", "name": "testTypeVariable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTypeVariable()", "original_string": "  @Test void testTypeVariable() {\n    // constant\n    ml(\"fn _ => 42\").assertType(\"'a -> int\");\n    ml(\"(fn _ => 42) 2\").assertEval(is(42));\n    ml(\"fn _ => fn _ => 42\").assertType(\"'a -> 'b -> int\");\n\n    // identity\n    ml(\"fn x => x\").assertType(\"'a -> 'a\");\n    ml(\"(fn x => x) 2\").assertEval(is(2));\n    ml(\"(fn x => x) \\\"foo\\\"\").assertEval(is(\"foo\"));\n    ml(\"(fn x => x) true\").assertEval(is(true));\n    ml(\"let fun id x = x in id end\").assertType(\"'a -> 'a\");\n    ml(\"fun id x = x\").assertType(\"'a -> 'a\");\n\n    // first/second\n    ml(\"fn x => fn y => x\").assertType(\"'a -> 'b -> 'a\");\n    ml(\"let fun first x y = x in first end\")\n        .assertType(\"'a -> 'b -> 'a\");\n    ml(\"fun first x y = x\")\n        .assertType(\"'a -> 'b -> 'a\");\n    ml(\"fun second x y = y\")\n        .assertType(\"'a -> 'b -> 'b\");\n    ml(\"fun choose b x y = if b then x else y\")\n        .assertType(\"bool -> 'a -> 'a -> 'a\");\n    ml(\"fun choose b (x, y) = if b then x else y\")\n        .assertType(\"bool -> 'a * 'a -> 'a\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testExponentialType0()", "name": "testExponentialType0", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test void testExponentialType0()", "original_string": "  @Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test void testExponentialType0() {\n    final String ml = \"let\\n\"\n        + \"  fun f x = (x, x)\\n\"\n        + \"in\\n\"\n        + \"  f (f 0)\\n\"\n        + \"end\";\n    ml(ml).assertType(\"xx\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"disable failing test - enable when we have polymorphic types\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testExponentialType()", "name": "testExponentialType", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"until type-inference bug is fixed\")\n  @Test void testExponentialType()", "original_string": "  @Disabled(\"until type-inference bug is fixed\")\n  @Test void testExponentialType() {\n    final String ml = \"let\\n\"\n        + \"  fun f x = (x, x, x)\\n\"\n        + \"in\\n\"\n        + \"   f (f (f (f (f 0))))\\n\"\n        + \"end\";\n    ml(ml).assertType(\"xx\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"until type-inference bug is fixed\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"until type-inference bug is fixed\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testExponentialType2()", "name": "testExponentialType2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"until type-inference bug is fixed\")\n  @Test void testExponentialType2()", "original_string": "  @Disabled(\"until type-inference bug is fixed\")\n  @Test void testExponentialType2() {\n    final String ml = \"fun f x y z = (x, y, z)\\n\"\n        + \"val p1 = (f, f, f)\\n\"\n        + \"val p2 = (p1, p1, p1)\\n\"\n        + \"val p3 = (p2, p2, p2)\\n\";\n    ml(ml).assertType(\"xx\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"until type-inference bug is fixed\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"until type-inference bug is fixed\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testDummy()", "name": "testDummy", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@SuppressWarnings(\"ConstantConditions\")\n  @Test void testDummy()", "original_string": "  @SuppressWarnings(\"ConstantConditions\")\n  @Test void testDummy() {\n    ml(\"from d in [{a=1,b=true}] yield d.a into sum\")\n        .assertType(\"int\")\n        .assertEval(is(1));\n    switch (0) {\n    case 0:\n      ml(\"1\").assertEval(is(1));\n      // fall through\n    case 1:\n      ml(\"1 + 2\").assertEval(is(3));\n      // fall through\n    case 2:\n      ml(\"1 + 2 + 3\").assertEval(is(6));\n      // fall through\n    case 3:\n      ml(\"1 * 2 + 3 * 4\").assertEval(is(14));\n      // fall through\n    case 4:\n      ml(\"let val x = 1 in x + 2 end\")\n          .with(Prop.INLINE_PASS_COUNT, 0)\n          .assertEval(is(3));\n      // fall through\n    case 5:\n      ml(\"let val x = 1 and y = 2 in 7 end\")\n          .with(Prop.INLINE_PASS_COUNT, 0)\n          .assertEval(is(7));\n      // fall through\n    case 6:\n      ml(\"let val x = 1 and y = 2 in x + y + 4 end\")\n          .with(Prop.INLINE_PASS_COUNT, 0)\n          .assertEval(is(7));\n      // fall through\n    case 7:\n      ml(\"(not (true andalso false))\").assertEval(is(true));\n      // fall through\n    case 8:\n      ml(\"let val x = 1 and y = 2 and z = true and a = \\\"foo\\\" in\\n\"\n          + \"  if z then x else y\\n\"\n          + \"end\").assertEval(is(1));\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@SuppressWarnings(\"ConstantConditions\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"ConstantConditions\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testEval()", "name": "testEval", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEval()", "original_string": "  @Test void testEval() {\n    // literals\n    ml(\"1\").assertEval(is(1));\n    ml(\"~2\").assertEval(is(-2));\n    ml(\"\\\"a string\\\"\").assertEval(is(\"a string\"));\n    ml(\"true\").assertEval(is(true));\n    ml(\"~10.25\").assertEval(is(-10.25f));\n    ml(\"~10.25e3\").assertEval(is(-10_250f));\n    ml(\"~1.25e~3\").assertEval(is(-0.001_25f));\n    ml(\"~1.25E~3\").assertEval(is(-0.001_25f));\n    ml(\"0e0\").assertEval(is(0f));\n\n    // boolean operators\n    ml(\"true andalso false\").assertEval(is(false));\n    ml(\"true orelse false\").assertEval(is(true));\n    ml(\"false andalso false orelse true\").assertEval(is(true));\n    ml(\"false andalso true orelse true\").assertEval(is(true));\n    ml(\"(not (true andalso false))\").assertEval(is(true));\n    ml(\"not true\").assertEval(is(false));\n    ml(\"not not true\")\n        .assertError(\"operator and operand don't agree [tycon mismatch]\\n\"\n            + \"  operator domain: bool\\n\"\n            + \"  operand:         bool -> bool\");\n    ml(\"not (not true)\").assertEval(is(true));\n\n    // comparisons\n    ml(\"1 = 1\").assertEval(is(true));\n    ml(\"1 = 2\").assertEval(is(false));\n    ml(\"\\\"a\\\" = \\\"a\\\"\").assertEval(is(true));\n    ml(\"\\\"a\\\" = \\\"ab\\\"\").assertEval(is(false));\n    ml(\"1 < 1\").assertEval(is(false));\n    ml(\"1 < 2\").assertEval(is(true));\n    ml(\"\\\"a\\\" < \\\"a\\\"\").assertEval(is(false));\n    ml(\"\\\"a\\\" < \\\"ab\\\"\").assertEval(is(true));\n    ml(\"1 > 1\").assertEval(is(false));\n    ml(\"1 > 2\").assertEval(is(false));\n    ml(\"1 > ~2\").assertEval(is(true));\n    ml(\"\\\"a\\\" > \\\"a\\\"\").assertEval(is(false));\n    ml(\"\\\"a\\\" > \\\"ab\\\"\").assertEval(is(false));\n    ml(\"\\\"ac\\\" > \\\"ab\\\"\").assertEval(is(true));\n    ml(\"1 <= 1\").assertEval(is(true));\n    ml(\"1 <= 2\").assertEval(is(true));\n    ml(\"\\\"a\\\" <= \\\"a\\\"\").assertEval(is(true));\n    ml(\"\\\"a\\\" <= \\\"ab\\\"\").assertEval(is(true));\n    ml(\"1 >= 1\").assertEval(is(true));\n    ml(\"1 >= 2\").assertEval(is(false));\n    ml(\"1 >= ~2\").assertEval(is(true));\n    ml(\"\\\"a\\\" >= \\\"a\\\"\").assertEval(is(true));\n    ml(\"\\\"a\\\" >= \\\"ab\\\"\").assertEval(is(false));\n    ml(\"\\\"ac\\\" >= \\\"ab\\\"\").assertEval(is(true));\n    ml(\"1 + 4 = 2 + 3\").assertEval(is(true));\n    ml(\"1 + 2 * 2 = 2 + 3\").assertEval(is(true));\n    ml(\"1 + 2 * 2 < 2 + 3\").assertEval(is(false));\n    ml(\"1 + 2 * 2 > 2 + 3\").assertEval(is(false));\n\n    // arithmetic operators\n    ml(\"2 + 3\").assertEval(is(5));\n    ml(\"2 + 3 * 4\").assertEval(is(14));\n    ml(\"2 * 3 + 4 * 5\").assertEval(is(26));\n    ml(\"2 - 3\").assertEval(is(-1));\n    ml(\"2 * 3\").assertEval(is(6));\n    ml(\"20 / 3\").assertEval(is(6));\n    ml(\"20 / ~3\").assertEval(is(-6));\n\n    ml(\"10 mod 3\").assertEval(is(1));\n    ml(\"~10 mod 3\").assertEval(is(2));\n    ml(\"~10 mod ~3\").assertEval(is(-1));\n    ml(\"10 mod ~3\").assertEval(is(-2));\n    ml(\"0 mod 3\").assertEval(is(-0));\n    ml(\"0 mod ~3\").assertEval(is(0));\n    ml(\"19 div 3\").assertEval(is(6));\n    ml(\"20 div 3\").assertEval(is(6));\n    ml(\"~19 div 3\").assertEval(is(-7));\n    ml(\"~18 div 3\").assertEval(is(-6));\n    ml(\"19 div ~3\").assertEval(is(-7));\n    ml(\"~21 div 3\").assertEval(is(-7));\n    ml(\"~21 div ~3\").assertEval(is(7));\n    ml(\"0 div 3\").assertEval(is(0));\n\n    // string operators\n    ml(\"\\\"\\\" ^ \\\"\\\"\").assertEval(is(\"\"));\n    ml(\"\\\"1\\\" ^ \\\"2\\\"\").assertEval(is(\"12\"));\n    ml(\"1 ^ 2\")\n        .assertError(\"operator and operand don't agree [overload conflict]\\n\"\n            + \"  operator domain: string * string\\n\"\n            + \"  operand:         [int ty] * [int ty]\\n\");\n\n    // if\n    ml(\"if true then 1 else 2\").assertEval(is(1));\n    ml(\"if false then 1 else if true then 2 else 3\").assertEval(is(2));\n    ml(\"if false\\n\"\n        + \"then\\n\"\n        + \"  if true then 2 else 3\\n\"\n        + \"else 4\").assertEval(is(4));\n    ml(\"if false\\n\"\n        + \"then\\n\"\n        + \"  if true then 2 else 3\\n\"\n        + \"else\\n\"\n        + \"  if false then 4 else 5\").assertEval(is(5));\n\n    // case\n    ml(\"case 1 of 0 => \\\"zero\\\" | _ => \\\"nonzero\\\"\")\n        .assertType(\"string\")\n        .assertEval(is(\"nonzero\"));\n    ml(\"case 1 of x => x | y => y\")\n        .assertError(\"Error: match redundant\\n\"\n            + \"          x => ...\\n\"\n            + \"    -->   y => ...\\n\");\n    ml(\"case 1 of 1 => 2\")\n        .assertError(\"Warning: match nonexhaustive\\n\"\n            + \"          1 => ...\\n\");\n    ml(\"let val f = fn x => case x of x => x + 1 in f 2 end\").assertEval(is(3));\n\n    // let\n    ml(\"let val x = 1 in x + 2 end\").assertEval(is(3));\n    ml(\"let val x = 1 in ~x end\").assertEval(is(-1));\n    ml(\"let val x = 1 in ~(abs(~x)) end\").assertEval(is(-1));\n\n    // let with a tuple pattern\n    ml(\"let val (x, y) = (1, 2) in x + y end\").assertEval(is(3));\n    ml(\"let val w as (x, y) = (1, 2) in #1 w + #2 w + x + y end\")\n        .assertEval(is(6));\n\n    // composite val\n    ml(\"val x = 1 and y = 2\").assertEval(is(map(\"x\", 1, \"y\", 2)));\n    ml(\"val (x, y) = (1, true)\").assertEval(is(map(\"x\", 1, \"y\", true)));\n    ml(\"val w as (x, y) = (2, false)\")\n        .assertEval(is(map(\"x\", 2, \"y\", false, \"w\", list(2, false))));\n\n    // let with multiple variables\n    ml(\"let val x = 1 and y = 2 in x + y end\").assertEval(is(3));\n    // let with multiple variables\n    ml(\"let val x = 1 and y = 2 and z = false in\\n\"\n        + \"  if z then x else y\\n\"\n        + \"end\").assertEval(is(2));\n    ml(\"let val x = 1 and y = 2 and z = true in\\n\"\n        + \"  if z then x else y\\n\"\n        + \"end\").assertEval(is(1));\n    ml(\"let val x = 1 and y = 2 and z = true and a = \\\"foo\\\" in\\n\"\n        + \"  if z then x else y\\n\"\n        + \"end\").assertEval(is(1));\n\n    // let where variables shadow\n    final String letNested = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"in\\n\"\n        + \"  let\\n\"\n        + \"    val x = 2\\n\"\n        + \"  in\\n\"\n        + \"    x * 3\\n\"\n        + \"  end + x\\n\"\n        + \"end\";\n    ml(letNested).assertEval(is(2 * 3 + 1));\n\n    // let with match\n    ml(\"(fn z => let val (x, y) = (z + 1, z + 2) in x + y end) 3\")\n        .assertEval(is(9));\n\n    // tuple\n    ml(\"(1, 2)\").assertEval(is(list(1, 2)));\n    ml(\"(1, (2, true))\").assertEval(is(list(1, list(2, true))));\n    ml(\"()\").assertEval(is(Collections.emptyList()));\n    ml(\"(1, 2, 1, 4)\").assertEval(is(list(1, 2, 1, 4)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLetSequentialDeclarations()", "name": "testLetSequentialDeclarations", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLetSequentialDeclarations()", "original_string": "  @Test void testLetSequentialDeclarations() {\n    // let with sequential declarations\n    ml(\"let val x = 1; val y = x + 1 in x + y end\").assertEval(is(3));\n\n    // semicolon is optional\n    ml(\"let val x = 1; val y = x + 1; in x + y end\").assertEval(is(3));\n    ml(\"let val x = 1 val y = x + 1 in x + y end\").assertEval(is(3));\n\n    // 'and' is executed in parallel, therefore 'x + 1' evaluates to 2, not 4\n    ml(\"let val x = 1; val x = 3 and y = x + 1 in x + y end\").assertEval(is(5));\n\n    ml(\"let val x = 1 and y = $x$ + 2 in x + y end\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"unbound variable or constructor: x\"));\n\n    // let with val and fun\n    ml(\"let fun f x = 1 + x; val x = 2 in f x end\").assertEval(is(3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLet2()", "name": "testLet2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLet2()", "original_string": "  @Test void testLet2() {\n    final String ml = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"  val y = x + 2\\n\"\n        + \"in\\n\"\n        + \"  y + x + 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(7));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that in a {@code let} clause, we can see previously defined\nvariables."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLet3()", "name": "testLet3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLet3()", "original_string": "  @Test void testLet3() {\n    final String ml = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"  and y = 2\\n\"\n        + \"in\\n\"\n        + \"  y + x + 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(6));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testLet2()}, but using 'and'."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLet3b()", "name": "testLet3b", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLet3b()", "original_string": "  @Test void testLet3b() {\n    // The intermediate form will have nested tuples, something like this:\n    //   val v = (1, (2, 4)) in case v of (x, (y, z)) => y + 3 + x\n    final String ml = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"  and (y, z) = (2, 4)\\n\"\n        + \"in\\n\"\n        + \"  y + x + 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(6));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testLet3()}, but a tuple is being assigned."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLet3c()", "name": "testLet3c", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLet3c()", "original_string": "  @Test void testLet3c() {\n    // The intermediate form will have nested tuples, something like this:\n    //   val v = (1, (2, 4)) in case v of (x, (y, z)) => y + 3 + x\n    final String ml = \"let\\n\"\n        + \"  val x1 :: x2 :: xs = [1, 5, 9, 13, 17]\\n\"\n        + \"  and (y, z) = (2, 4)\\n\"\n        + \"in\\n\"\n        + \"  y + x1 + x2 + 3\\n\"\n        + \"end\";\n    ml(ml)\n        .with(Prop.MATCH_COVERAGE_ENABLED, false)\n        .assertEval(is(11));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLet4()", "name": "testLet4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLet4()", "original_string": "  @Test void testLet4() {\n    final String ml = \"let\\n\"\n        + \"  val x = 5\\n\"\n        + \"  and y = 1\\n\"\n        + \"in\\n\"\n        + \"  let\\n\"\n        + \"    val x = y (* new x = old y = 1 *)\\n\"\n        + \"    and y = x + 2 (* new y = old x + 2 = 5 + 2 = 7 *)\\n\"\n        + \"  in\\n\"\n        + \"    y + x + 3 (* new y + new x + 3 = 7 + 1 + 3 = 11 *)\\n\"\n        + \"  end\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(11));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that 'and' assignments occur simultaneously."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLet5()", "name": "testLet5", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLet5()", "original_string": "  @Test void testLet5() {\n    final String ml = \"let\\n\"\n        + \"  val plus = fn x => fn y => x + y\\n\"\n        + \"  val plusTwo = plus 2\\n\"\n        + \"in\\n\"\n        + \"  plusTwo 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(5));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a closure in a let."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLet6()", "name": "testLet6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLet6()", "original_string": "  @Test void testLet6() {\n    final String ml = \"let\\n\"\n        + \"  fun isZero x = x = 0\\n\"\n        + \"in\\n\"\n        + \"  fn i => i = 10 andalso isZero i\\n\"\n        + \"end\";\n    // With inlining, we want the plan to simplify to \"fn i => false\"\n    final String plan = \"match(i, andalso(apply2(\"\n        + \"fnValue =, get(name i), constant(10)), \"\n        + \"apply2(fnValue =, get(name i), constant(0))))\";\n    ml(ml)\n        .assertEval(whenAppliedTo(0, is(false)))\n        .assertEval(whenAppliedTo(10, is(false)))\n        .assertEval(whenAppliedTo(15, is(false)))\n        .assertPlan(isCode(plan));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a predicate in a let."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testLet7()", "name": "testLet7", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLet7()", "original_string": "  @Test void testLet7() {\n    final String ml = \"fun g (a, b, c) =\\n\"\n        + \"  let\\n\"\n        + \"    fun f x = x * 3\\n\"\n        + \"  in\\n\"\n        + \"    f (a + b) - c\\n\"\n        + \"  end\";\n    // With inlining, we want the plan to simplify to\n    // \"fn (a, b, c) => (a + b) * 3 - c\"\n    final String plan = \"match(v0, apply(fnCode match((a, b, c), \"\n        + \"apply2(fnValue -, apply2(fnValue *, \"\n        + \"apply2(fnValue +, get(name a), get(name b)), \"\n        + \"constant(3)), get(name c))), argCode get(name v0)))\";\n    ml(ml)\n        // g (4, 3, 2) = (4 + 3) * 3 - 2 = 19\n        .assertEval(whenAppliedTo(list(4, 3, 2), is(19)))\n        .assertPlan(isCode(plan));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a function in a let. (From <a\nhref=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf\">Secrets\nof the Glasgow Haskell Compiler inliner</a> (GHC inlining), section 2.3."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testEvalApply2()", "name": "testEvalApply2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEvalApply2()", "original_string": "  @Test void testEvalApply2() {\n    final String ml = \"Math.pow (2.0, 3.0)\";\n    final String plan =\n        \"apply2(fnValue Math.pow, constant(2.0), constant(3.0))\";\n    ml(ml)\n        .assertEval(is(8f))\n        .assertPlan(isCode(plan));\n\n    // When the argument tuple is returned from a function call, we evaluate\n    // the long way ('apply').\n    final String ml2 = \"Math.pow (hd [(2.0, 3.0)])\";\n    final String plan2 = \"apply(fnValue Math.pow,\"\n        + \" argCode apply(fnValue List.hd, \"\n        + \"argCode tuple(tuple(constant(2.0), constant(3.0)))))\";\n    ml(ml2)\n        .assertEval(is(8f))\n        .assertPlan(isCode(plan2));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that a simple eager function ({@code Math.pow}) uses\ndirect application ({@code apply2}) when its arguments are a tuple."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testNameCapture()", "name": "testNameCapture", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testNameCapture()", "original_string": "  @Test void testNameCapture() {\n    final String ml = \"fn (a, b) =>\\n\"\n        + \"  let val x = a + b in\\n\"\n        + \"    let val a = 7 in\\n\"\n        + \"      x + a\\n\"\n        + \"    end\\n\"\n        + \"  end\";\n    ml(ml)\n        // result should be x + a = (1 + 2) + 7 = 10\n        // if 'a' were wrongly captured, result would be (7 + 2) + 7 = 16\n        .assertEval(whenAppliedTo(list(1, 2), is(10)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that name capture does not occur during inlining.\n(Example is from GHC inlining, section 3.)"}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMutualRecursion()", "name": "testMutualRecursion", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMutualRecursion()", "original_string": "  @Test void testMutualRecursion() {\n    final String ml = \"let\\n\"\n        + \"  fun f i = g (i * 2)\\n\"\n        + \"  and g i = if i > 10 then i else f (i + 3)\\n\"\n        + \"in\\n\"\n        + \"  f\\n\"\n        + \"end\";\n    ml(ml)\n        // answers checked on SMLJ\n        .assertEval(whenAppliedTo(1, is(26)))\n        .assertEval(whenAppliedTo(2, is(14)))\n        .assertEval(whenAppliedTo(3, is(18)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMutualRecursion3()", "name": "testMutualRecursion3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMutualRecursion3()", "original_string": "  @Test void testMutualRecursion3() {\n    final String ml = \"let\\n\"\n        + \"  fun isZeroMod3 0 = true | isZeroMod3 n = isTwoMod3 (n - 1)\\n\"\n        + \"  and isOneMod3 0 = false | isOneMod3 n = isZeroMod3 (n - 1)\\n\"\n        + \"  and isTwoMod3 0 = false | isTwoMod3 n = isOneMod3 (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fn n => (isZeroMod3 n, isOneMod3 n, isTwoMod3 n)\\n\"\n        + \"end\";\n    ml(ml)\n        .assertEval(whenAppliedTo(17, is(list(false, false, true))))\n        .assertEval(whenAppliedTo(18, is(list(true, false, false))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testCompositeRecursiveLet()", "name": "testCompositeRecursiveLet", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"until mutual recursion bug is fixed\")\n  @Test void testCompositeRecursiveLet()", "original_string": "  @Disabled(\"until mutual recursion bug is fixed\")\n  @Test void testCompositeRecursiveLet() {\n    final String ml = \"let\\n\"\n        + \"  val rec (x, y) = (1, 2)\\n\"\n        + \"  and f = fn n => if n = 1 then 1 else n * f (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  x + f 5 + y\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(123));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"until mutual recursion bug is fixed\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"until mutual recursion bug is fixed\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a recursive {@code let} that includes a pattern. I'm not sure\nwhether this is valid Standard ML; SML-NJ doesn't like it."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMutualRecursionComplex()", "name": "testMutualRecursionComplex", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"until mutual recursion bug is fixed\")\n  @Test void testMutualRecursionComplex()", "original_string": "  @Disabled(\"until mutual recursion bug is fixed\")\n  @Test void testMutualRecursionComplex() {\n    final String ml0 = \"let\\n\"\n        + \"  fun f i = g (i + 1)\\n\"\n        + \"  and g i = h (i + 2) + p (i + 4)\\n\"\n        + \"  and h i = if i > 100 then i + 8 else f (i + 16)\\n\"\n        + \"  and p i = q (i + 32)\\n\"\n        + \"  and q i = if i > 200 then i + 64 else g (i + 128)\\n\"\n        + \"in\\n\"\n        + \"  g 7\\n\"\n        + \"end\";\n    final String ml = \"let\\n\"\n        + \"  val rec f = fn i => g (i + 1)\\n\"\n        + \"  and g = fn i => h (i + 2) + p (i + 4)\\n\"\n        + \"  and h = fn i => if i > 100 then i + 8 else f (i + 16)\\n\"\n        + \"  and p = fn i => q (i + 32)\\n\"\n        + \"  and q = fn i => if i > 200 then i + 64 else g (i + 128)\\n\"\n        + \"in\\n\"\n        + \"  g 7\\n\"\n        + \"end\";\n    ml(ml)\n        // answers checked on SMLJ\n        .assertEval(whenAppliedTo(1, is(4003)))\n        .assertEval(whenAppliedTo(6, is(3381)))\n        .assertEval(whenAppliedTo(7, is(3394)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"until mutual recursion bug is fixed\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"until mutual recursion bug is fixed\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that inlining of mutually recursive functions does not prevent\ncompilation from terminating.\n\n<p>Per GHC inlining, (f, g, h), (g, p, q) are strongly connected components\nof the dependency graph. In each group, the inliner should choose one\nfunction as 'loop-breaker' that will not be inlined; say f and q."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testSameVariableName()", "name": "testSameVariableName", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testSameVariableName()", "original_string": "  @Test void testSameVariableName() {\n    final String ml = \"List.filter\\n\"\n        + \" (fn e => e.x + 2 * e.y > 16)\\n\"\n        + \" (map\\n\"\n        + \"   (fn e => {x = e - 1, y = 10 - e})\\n\"\n        + \"   [1, 2, 3, 4, 5])\";\n    ml(ml).assertEval(isUnordered(list(list(0, 9), list(1, 8))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that you can use the same variable name in different parts of the\nprogram without the types getting confused."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testSameVariableName2()", "name": "testSameVariableName2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testSameVariableName2()", "original_string": "  @Test void testSameVariableName2() {\n    final String ml = \"List.filter\\n\"\n        + \" (fn e => e.x + 2 * e.y > 16)\\n\"\n        + \" (map\\n\"\n        + \"   (fn e => {x = e.a - 1, y = 10 - e.a})\\n\"\n        + \"   [{a=1}, {a=2}, {a=3}, {a=4}, {a=5}])\";\n    ml(ml).assertEval(isUnordered(list(list(0, 9), list(1, 8))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testSameVariableName()} but both variables are records."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testClosure()", "name": "testClosure", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testClosure()", "original_string": "  @Test void testClosure() {\n    final String ml = \"let\\n\"\n        + \"  val x = \\\"abc\\\";\\n\"\n        + \"  fun g y = size x + y;\\n\"\n        + \"  val x = 10\\n\"\n        + \"in\\n\"\n        + \"  g x\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(13));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a closure that uses one variable \"x\", called in an environment\nwith a different value of \"x\" (of a different type, to flush out bugs)."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testEvalFn()", "name": "testEvalFn", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEvalFn()", "original_string": "  @Test void testEvalFn() {\n    ml(\"(fn x => x + 1) 2\").assertEval(is(3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testEvalFnCurried()", "name": "testEvalFnCurried", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEvalFnCurried()", "original_string": "  @Test void testEvalFnCurried() {\n    ml(\"(fn x => fn y => x + y) 2 3\").assertEval(is(5));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testEvalFnTuple()", "name": "testEvalFnTuple", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEvalFnTuple()", "original_string": "  @Test void testEvalFnTuple() {\n    ml(\"(fn (x, y) => x + y) (2, 3)\").assertEval(is(5));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testEvalFnRec()", "name": "testEvalFnRec", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEvalFnRec()", "original_string": "  @Test void testEvalFnRec() {\n    final String ml = \"let\\n\"\n        + \"  val rec f = fn n => if n = 0 then 1 else n * f (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  f 5\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(120));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testEvalFnTupleGeneric()", "name": "testEvalFnTupleGeneric", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEvalFnTupleGeneric()", "original_string": "  @Test void testEvalFnTupleGeneric() {\n    ml(\"(fn (x, y) => x) (2, 3)\").assertEval(is(2));\n    ml(\"(fn (x, y) => y) (2, 3)\").assertEval(is(3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testRecord()", "name": "testRecord", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRecord()", "original_string": "  @Test void testRecord() {\n    ml(\"{a = 1, b = {c = true, d = false}}\").assertParseSame();\n    ml(\"{a = 1, 1 = 2}\").assertParseStmt(Ast.Record.class, \"{1 = 2, a = 1}\");\n    ml(\"#b {a = 1, b = {c = true, d = false}}\").assertParseSame();\n    ml(\"{0=1}\").assertError(is(\"label must be positive\"));\n    ml(\"{a = 1, b = true}\").assertType(\"{a:int, b:bool}\");\n    ml(\"{b = true, a = 1}\").assertType(\"{a:int, b:bool}\");\n    ml(\"{a = 1, b = 2}\").assertEval(is(list(1, 2)));\n    ml(\"{a = true, b = ~2}\").assertEval(is(list(true, -2)));\n    ml(\"{a = true, b = ~2, c = \\\"c\\\"}\").assertEval(is(list(true, -2, \"c\")));\n    ml(\"let val ab = {a = true, b = ~2} in #a ab end\").assertEval(is(true));\n    ml(\"{a = true, b = {c = 1, d = 2}}\")\n        .assertEval(is(list(true, list(1, 2))));\n    ml(\"#a {a = 1, b = true}\")\n        .assertType(\"int\")\n        .assertEval(is(1));\n    ml(\"#b {a = 1, b = true}\")\n        .assertType(\"bool\")\n        .assertEval(is(true));\n    ml(\"#b {a = 1, b = 2}\").assertEval(is(2));\n    ml(\"#b {a = 1, b = {x = 3, y = 4}, z = true}\").assertEval(is(list(3, 4)));\n    ml(\"#x (#b {a = 1, b = {x = 3, y = 4}, z = true})\").assertEval(is(3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEquals()", "original_string": "  @Test void testEquals() {\n    ml(\"{b = true, a = 1} = {a = 1, b = true}\").assertEval(is(true));\n    ml(\"{b = true, a = 0} = {a = 1, b = true}\").assertEval(is(false));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testRecord2()", "name": "testRecord2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"deduce type of #label\")\n  @Test void testRecord2()", "original_string": "  @Disabled(\"deduce type of #label\")\n  @Test void testRecord2() {\n    ml(\"#x #b {a = 1, b = {x = 3, y = 4}, z = true}\")\n        .assertError(\"Error: operator and operand don't agree [type mismatch]\\n\"\n            + \"  operator domain: {x:'Y; 'Z}\\n\"\n            + \"  operand:         {b:'W; 'X} -> 'W\\n\"\n            + \"  in expression:\\n\"\n            + \"    (fn {x=x,...} => x) (fn {b=b,...} => b)\\n\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"deduce type of #label\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"deduce type of #label\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testRecordFn()", "name": "testRecordFn", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRecordFn()", "original_string": "  @Test void testRecordFn() {\n    ml(\"(fn {a=a1,b=b1} => a1) {a = 1, b = true}\")\n        .assertType(\"int\")\n        .assertEval(is(1));\n    ml(\"(fn {a=a1,b=b1} => b1) {a = 1, b = true}\")\n        .assertType(\"bool\")\n        .assertEval(is(true));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testRecordMatch()", "name": "testRecordMatch", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRecordMatch()", "original_string": "  @Test void testRecordMatch() {\n    final String ml = \"case {a=1, b=2, c=3}\\n\"\n        + \"  of {a=2, b=2, c=3} => 0\\n\"\n        + \"   | {a=1, c=x, ...} => x\\n\"\n        + \"   | _ => ~1\";\n    ml(ml).assertEval(is(3));\n    ml(\"fn {} => 0\").assertParseSame();\n    ml(\"fn {a=1, ..., c=2}\")\n        .assertParseThrowsParseException(\n            containsString(\"Encountered \\\" \\\",\\\" \\\", \\\"\\\" at line 1, \"\n                + \"column 13.\"));\n    ml(\"fn {...} => 0\").assertParseSame();\n    ml(\"fn {a = a, ...} => 0\").assertParseSame();\n    ml(\"fn {a, b = {c, d}, ...} => 0\")\n        .assertParse(\"fn {a = a, b = {c = c, d = d}, ...} => 0\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testRecordCase()", "name": "testRecordCase", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRecordCase()", "original_string": "  @Test void testRecordCase() {\n    ml(\"case {a=2,b=3} of {a=x,b=y} => x * y\").assertEval(is(6));\n    ml(\"case {a=2,b=3,c=4} of {a=x,b=y,c=z} => x * y\").assertEval(is(6));\n    ml(\"case {a=2,b=3,c=4} of {a=x,b=y,...} => x * y\").assertEval(is(6));\n    // resolution of flex records is more lenient in case than in fun\n    ml(\"case {a=2,b=3,c=4} of {a=3,...} => 1 | {b=2,...} => 2 | _ => 3\")\n        .assertEval(is(3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testRecordTuple()", "name": "testRecordTuple", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testRecordTuple()", "original_string": "  @Test void testRecordTuple() {\n    ml(\"{ 1 = true, 2 = 0}\").assertType(\"bool * int\");\n    ml(\"{2=0,1=true}\").assertType(\"bool * int\");\n    ml(\"{3=0,1=true,11=false}\").assertType(\"{1:bool, 3:int, 11:bool}\");\n    ml(\"#1 {1=true,2=0}\").assertType(\"bool\");\n    ml(\"#1 (true, 0)\").assertType(\"bool\");\n    ml(\"#2 (true, 0)\")\n        .assertType(\"int\")\n        .assertEval(is(0));\n\n    // empty record = () = unit\n    ml(\"()\").assertType(\"unit\");\n    ml(\"{}\")\n        .assertType(\"unit\")\n        .assertEval(is(ImmutableList.of()));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testList()", "name": "testList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testList()", "original_string": "  @Test void testList() {\n    ml(\"[1]\").assertType(\"int list\");\n    ml(\"[[1]]\").assertType(\"int list list\");\n    ml(\"[(1, true), (2, false)]\").assertType(\"(int * bool) list\");\n    ml(\"1 :: [2]\").assertType(\"int list\");\n    ml(\"1 :: [2, 3]\").assertType(\"int list\");\n    ml(\"[1] :: [[2], [3]]\").assertType(\"int list list\");\n    ml(\"1 :: []\").assertType(\"int list\");\n    ml(\"1 :: 2 :: []\")\n        .assertType(\"int list\")\n        .assertEval(is(list(1, 2)));\n    ml(\"fn [] => 0\").assertType(\"'a list -> int\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testList2()", "name": "testList2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"need type annotations\")\n  @Test void testList2()", "original_string": "  @Disabled(\"need type annotations\")\n  @Test void testList2() {\n    ml(\"fn x: 'b list => 0\").assertType(\"'a list -> int\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"need type annotations\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"need type annotations\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testListLength()", "name": "testListLength", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testListLength()", "original_string": "  @Test void testListLength() {\n    final String ml = \"let\\n\"\n        + \"  val rec len = fn x =>\\n\"\n        + \"    case x of [] => 0\\n\"\n        + \"            | head :: tail => 1 + len tail\\n\"\n        + \"in\\n\"\n        + \"  len [1, 2, 3]\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " List length function exercises list pattern-matching and recursion."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testListLength2()", "name": "testListLength2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testListLength2()", "original_string": "  @Test void testListLength2() {\n    final String ml = \"let\\n\"\n        + \"  val rec len = fn x =>\\n\"\n        + \"    case x of head :: tail => 1 + len tail\\n\"\n        + \"            | [] => 0\\n\"\n        + \"in\\n\"\n        + \"  len [1, 2, 3]\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testListLength()} but match reversed, which requires\ncautious matching of :: pattern."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testListLength3()", "name": "testListLength3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testListLength3()", "original_string": "  @Test void testListLength3() {\n    final String ml = \"let\\n\"\n        + \"  fun len [] = 0\\n\"\n        + \"     | len (head :: tail) = 1 + len tail\\n\"\n        + \"in\\n\"\n        + \"  len [1, 2, 3]\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {link {@link #testListLength()} but using {@code fun}."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFunUnit()", "name": "testFunUnit", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFunUnit()", "original_string": "  @Test void testFunUnit() {\n    final String ml = \"let\\n\"\n        + \"  fun one () = 1\\n\"\n        + \"in\\n\"\n        + \"  one () + 2\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchTuple()", "name": "testMatchTuple", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchTuple()", "original_string": "  @Test void testMatchTuple() {\n    final String ml = \"let\\n\"\n        + \"  val rec sumIf = fn v =>\\n\"\n        + \"    case v of (true, n) :: tail => n + sumIf tail\\n\"\n        + \"            | (false, _) :: tail => sumIf tail\\n\"\n        + \"            | _ => 0\\n\"\n        + \"in\\n\"\n        + \"  sumIf [(true, 2), (false, 3), (true, 5)]\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(7));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchRedundant()", "name": "testMatchRedundant", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchRedundant()", "original_string": "  @Test void testMatchRedundant() {\n    final String ml = \"fun f x = case x > 0 of\\n\"\n        + \"   true => \\\"positive\\\"\\n\"\n        + \" | false => \\\"non-positive\\\"\\n\"\n        + \" | $true => \\\"oops\\\"$\";\n    ml(ml, '$')\n        .assertMatchCoverage(REDUNDANT)\n        .assertEvalThrows(pos -> throwsA(\"match redundant\", pos));\n\n    // similar, but 'fun' rather than 'case'\n    final String ml2 = \"\"\n        + \"fun f true = \\\"positive\\\"\\n\"\n        + \"  | f false = \\\"non-positive\\\"\\n\"\n        + \"  | $f true = \\\"oops\\\"$\";\n    ml(ml2, '$')\n        .assertMatchCoverage(REDUNDANT)\n        .assertEvalThrows(pos -> throwsA(\"match redundant\", pos));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " The algorithm is described in\n<a href=\"https://stackoverflow.com/questions/7883023/algorithm-for-type-checking-ml-like-pattern-matching\">\nStack overflow</a> and in Lennart Augustsson's 1985 paper \"Compiling\nPattern Matching\"."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage1()", "name": "testMatchCoverage1", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage1()", "original_string": "  @Test void testMatchCoverage1() {\n    final String ml = \"fun f (x, y) = x + y + 1\";\n    ml(ml).assertMatchCoverage(OK);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage2()", "name": "testMatchCoverage2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage2()", "original_string": "  @Test void testMatchCoverage2() {\n    final String ml = \"\"\n        + \"fun f (1, y) = y\\n\"\n        + \"  | f (x, 2) = x\\n\"\n        + \"  | f (x, y) = x + y + 1\";\n    ml(ml).assertMatchCoverage(OK);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage3()", "name": "testMatchCoverage3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage3()", "original_string": "  @Test void testMatchCoverage3() {\n    final String ml = \"fun f 1 = 2 | f x = x + 3\";\n    ml(ml).assertMatchCoverage(OK);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage4()", "name": "testMatchCoverage4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage4()", "original_string": "  @Test void testMatchCoverage4() {\n    final String ml = \"\"\n        + \"fun f 1 = 2\\n\"\n        + \"  | f _ = 1\";\n    ml(ml).assertMatchCoverage(OK);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage5()", "name": "testMatchCoverage5", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage5()", "original_string": "  @Test void testMatchCoverage5() {\n    final String ml = \"\"\n        + \"fun f [] = 0\\n\"\n        + \"  | f (h :: t) = 1 + (f t)\";\n    ml(ml).assertMatchCoverage(OK);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage6()", "name": "testMatchCoverage6", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage6()", "original_string": "  @Test void testMatchCoverage6() {\n    final String ml = \"\"\n        + \"fun f (0, y) = y\\n\"\n        + \"  | f (x, y) = x + y + 1\";\n    ml(ml).assertMatchCoverage(OK);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage7()", "name": "testMatchCoverage7", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage7()", "original_string": "  @Test void testMatchCoverage7() {\n    final String ml = \"\"\n        + \"fun f (x, y, 0) = y\\n\"\n        + \"  | f (x, y, z) = x + z\";\n    ml(ml).assertMatchCoverage(OK);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage8()", "name": "testMatchCoverage8", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage8()", "original_string": "  @Test void testMatchCoverage8() {\n    // The last case is redundant because we know that bool has two values.\n    final String ml = \"\"\n        + \"fun f (true, y, z) = y\\n\"\n        + \"  | f (false, y, z) = z\\n\"\n        + \"  | $f _ = 0$\";\n    ml(ml, '$')\n        .assertMatchCoverage(REDUNDANT)\n        .assertEvalError(pos -> throwsA(\"match redundant\", pos));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage9()", "name": "testMatchCoverage9", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage9()", "original_string": "  @Test void testMatchCoverage9() {\n    // The last case is redundant because we know that unit has only one value.\n    final String ml = \"\"\n        + \"fun f () = 1\\n\"\n        + \"  | $f _ = 0$\";\n    ml(ml, '$').assertMatchCoverage(REDUNDANT);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage10()", "name": "testMatchCoverage10", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage10()", "original_string": "  @Test void testMatchCoverage10() {\n    final String ml = \"fun maskToString m =\\n\"\n        + \"  let\\n\"\n        + \"    fun maskToString2 (m, s, 0) = s\\n\"\n        + \"      | maskToString2 (m, s, k) =\\n\"\n        + \"        maskToString2 (m div 3,\\n\"\n        + \"          ($case (m mod 3) of\\n\"\n        + \"              0 => \\\"b\\\"\\n\"\n        + \"            | 1 => \\\"y\\\"\\n\"\n        + \"            | 2 => \\\"g\\\"$) ^ s,\\n\"\n        + \"          k - 1)\\n\"\n        + \"  in\\n\"\n        + \"    maskToString2 (m, \\\"\\\", 5)\\n\"\n        + \"  end\";\n    ml(ml, '$')\n        .assertMatchCoverage(NON_EXHAUSTIVE);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage12()", "name": "testMatchCoverage12", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage12()", "original_string": "  @Test void testMatchCoverage12() {\n    // two \"match nonexhaustive\" warnings\n    final String ml = \"fun f x =\\n\"\n        + \"  let\\n\"\n        + \"    fun g 1 = 1\\n\"\n        + \"    and h 2 = 2\\n\"\n        + \"  in\\n\"\n        + \"    (g x) + (h 2)\\n\"\n        + \"  end\";\n    ml(ml)\n        .assertMatchCoverage(NON_EXHAUSTIVE)\n        .assertEvalWarnings(\n            new CustomTypeSafeMatcher<List<Throwable>>(\n                \"two warnings\") {\n              @Override protected boolean matchesSafely(List<Throwable> list) {\n                return list.size() == 2\n                    && list.get(0) instanceof CompileException\n                    && list.get(0).getMessage().equals(\"match nonexhaustive\")\n                    && list.get(1) instanceof CompileException\n                    && list.get(1).getMessage().equals(\"match nonexhaustive\");\n              }\n            });\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMatchCoverage13()", "name": "testMatchCoverage13", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMatchCoverage13()", "original_string": "  @Test void testMatchCoverage13() {\n    // Even though \"SOME i\" is seen at depth 1 in the first line,\n    // the \"SOME\" at depth 0 in the second line is not the same pattern,\n    // therefore the pattern is not redundant.\n    final String ml = \"fun f (SOME (SOME i)) = i + 1\\n\"\n        + \"  | f (SOME NONE) = 0\\n\"\n        + \"  | f NONE = ~1\\n\";\n    ml(ml).assertMatchCoverage(OK);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Test case for \"[MOREL-205] Pattern that uses nested type-constructors\nshould not be considered redundant\"."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFun()", "name": "testFun", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFun()", "original_string": "  @Test void testFun() {\n    final String ml = \"let\\n\"\n        + \"  fun fact n = if n = 0 then 1 else n * fact (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fact 5\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(120));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Function declaration."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFunValue()", "name": "testFunValue", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFunValue()", "original_string": "  @Test void testFunValue() {\n    final String ml = \"let\\n\"\n        + \"  fun fact n = if n = 0 then 1 else n * fact (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fact\\n\"\n        + \"end\";\n    ml(ml).assertEval(whenAppliedTo(5, is(120)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFun()} but not applied to a value."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFunValueSansLet()", "name": "testFunValueSansLet", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFunValueSansLet()", "original_string": "  @Test void testFunValueSansLet() {\n    final String ml = \"fun fact n = if n = 0 then 1 else n * fact (n - 1)\";\n    ml(ml).assertEval(whenAppliedTo(5, is(120)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFunValue()} but without \"let\".\n\n<p>This is mainly a test for the test framework. We want to handle bindings\n({@code fun}) as well as values ({@code let} and {@code fn}). So people can\nwrite tests more concisely."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFun2()", "name": "testFun2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFun2()", "original_string": "  @Test void testFun2() {\n    final String ml = \"let\\n\"\n        + \"  fun fact n = case n of 0 => 1 | _ => n * fact (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fact 5\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(120));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFun} but uses case."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFun3()", "name": "testFun3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFun3()", "original_string": "  @Test void testFun3() {\n    final String ml = \"let\\n\"\n        + \"  fun fact 1 = 1 | fact n = n * fact (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fact 5\\n\"\n        + \"end\";\n    final String expected = \"let\"\n        + \" fun fact 1 = 1 \"\n        + \"| fact n = n * fact (n - 1) \"\n        + \"in fact 5 end\";\n    ml(ml).assertParse(expected)\n        .assertEval(is(120));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFun} but uses a multi-clause function."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFun4()", "name": "testFun4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFun4()", "original_string": "  @Test void testFun4() {\n    final String ml = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"in\\n\"\n        + \"  let\\n\"\n        + \"    val x = 17\\n\"\n        + \"    and inc1 = fn n => n + x\\n\"\n        + \"    and inc2 = fn n => n + x + x\\n\"\n        + \"  in\\n\"\n        + \"    inc2 (inc1 x)\\n\"\n        + \"  end\\n\"\n        + \"end\";\n    ml(ml).assertType(\"int\")\n        .assertEval(is(20));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Simultaneous functions."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testMutuallyRecursiveFunctions()", "name": "testMutuallyRecursiveFunctions", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Disabled(\"not working yet\")\n  @Test void testMutuallyRecursiveFunctions()", "original_string": "  @Disabled(\"not working yet\")\n  @Test void testMutuallyRecursiveFunctions() {\n    final String ml = \"let\\n\"\n        + \"  fun even 0 = true\\n\"\n        + \"    | even n = odd (n - 1)\\n\"\n        + \"  and odd 0 = false\\n\"\n        + \"    | odd n = even (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  odd 7\\n\"\n        + \"end\";\n    ml(ml).assertType(\"boolean\")\n        .assertEval(is(true));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Disabled(\"not working yet\")\n  @Test", "marker_annotations": ["@Test"], "non_marker_annotations": ["@Disabled(\"not working yet\")"], "comments": [], "return_type": "void", "classes": []}, "docstring": " Mutually recursive functions: the definition of 'even' references 'odd'\nand the definition of 'odd' references 'even'."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFunTwoArgs()", "name": "testFunTwoArgs", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFunTwoArgs()", "original_string": "  @Test void testFunTwoArgs() {\n    final String ml = \"let\\n\"\n        + \"  fun sum x y = x + y\\n\"\n        + \"in\\n\"\n        + \"  sum 5 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(8));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " A function with two arguments."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFunRecord()", "name": "testFunRecord", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFunRecord()", "original_string": "  @Test void testFunRecord() {\n    final String ml = \"\"\n        + \"fun f {a=x,b=1,...} = x\\n\"\n        + \"  | f {b=y,c=2,...} = y\\n\"\n        + \"  | f {a=x,b=y,c=z} = x+y+z\";\n    ml(ml).assertType(\"{a:int, b:int, c:int} -> int\")\n        .assertEval(whenAppliedTo(list(1, 2, 3), is(6)));\n\n    final String ml2 = \"let\\n\"\n        + \"  fun f {a=x,b=1,...} = x\\n\"\n        + \"    | f {b=y,c=2,...} = y\\n\"\n        + \"    | f {a=x,b=y,c=z} = x+y+z\\n\"\n        + \"in\\n\"\n        + \"  f {a=1,b=2,c=3}\\n\"\n        + \"end\";\n    ml(ml2).assertEval(is(6));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testDatatype()", "name": "testDatatype", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testDatatype()", "original_string": "  @Test void testDatatype() {\n    final String ml = \"let\\n\"\n        + \"  datatype 'a tree = NODE of 'a tree * 'a tree | LEAF of 'a\\n\"\n        + \"in\\n\"\n        + \"  NODE (LEAF 1, NODE (LEAF 2, LEAF 3))\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(hasMoniker(\"'a tree\"))\n        .assertType(\n            instanceOfAnd(DataType.class,\n                hasTypeConstructors(\"{LEAF='a, NODE='a tree * 'a tree}\")))\n        .assertEval(is(node(leaf(1), node(leaf(2), leaf(3)))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testDatatype2()", "name": "testDatatype2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testDatatype2()", "original_string": "  @Test void testDatatype2() {\n    final String ml = \"let\\n\"\n        + \"  datatype number = ZERO | INTEGER of int | RATIONAL of int * int\\n\"\n        + \"in\\n\"\n        + \"  RATIONAL (2, 3)\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"number\")\n        .assertEval(is(ImmutableList.of(\"RATIONAL\", ImmutableList.of(2, 3))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testDatatype3()", "name": "testDatatype3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testDatatype3()", "original_string": "  @Test void testDatatype3() {\n    final String ml = \"let\\n\"\n        + \"  datatype intoption = NONE | SOME of int;\\n\"\n        + \"  val score = fn z => case z of NONE => 0 | SOME x => x\\n\"\n        + \"in\\n\"\n        + \"  score (SOME 5)\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(5));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testDatatype3b()", "name": "testDatatype3b", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testDatatype3b()", "original_string": "  @Test void testDatatype3b() {\n    final String ml = \"let\\n\"\n        + \"  datatype intoption = NONE | SOME of int;\\n\"\n        + \"  fun score NONE = 0\\n\"\n        + \"    | score (SOME x) = x\\n\"\n        + \"in\\n\"\n        + \"  score (SOME 5)\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(5));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testDatatype3()} but with {@code fun} rather than {@code fn}\n ... {@code case}."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testDatatype3c()", "name": "testDatatype3c", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testDatatype3c()", "original_string": "  @Test void testDatatype3c() {\n    final String ml = \"let\\n\"\n        + \"  datatype intoption = NONE | SOME of int;\\n\"\n        + \"  fun score NONE = 0\\n\"\n        + \"    | score (SOME x) = x\\n\"\n        + \"in\\n\"\n        + \"  score NONE\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(0));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testDatatype3b()} but use a nilary type constructor (NONE)."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testDatatype4()", "name": "testDatatype4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testDatatype4()", "original_string": "  @Test void testDatatype4() {\n    final String ml = \"let\\n\"\n        + \" datatype intlist = NIL | CONS of int * intlist;\\n\"\n        + \" fun depth NIL = 0\\n\"\n        + \"   | depth CONS (x, y) = 1 + depth y\\n\"\n        + \"in\\n\"\n        + \" depth NIL\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(0));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testDatatype4a()", "name": "testDatatype4a", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testDatatype4a()", "original_string": "  @Test void testDatatype4a() {\n    final String ml = \"let\\n\"\n        + \" datatype intlist = NIL | CONS of int * intlist;\\n\"\n        + \" fun depth NIL = 0\\n\"\n        + \"   | depth CONS (x, y) = 1 + depth y\\n\"\n        + \"in\\n\"\n        + \" depth (CONS (5, CONS (2, NIL)))\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(2));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testDatatype4()} but with deeper expression."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testSetOp()", "name": "testSetOp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testSetOp()", "original_string": "  @Test void testSetOp() {\n    ml(\"a union b\").assertParseSame();\n    ml(\"a union b union c\").assertParseSame();\n    ml(\"(a union b) union c\").assertParse(\"a union b union c\");\n    ml(\"a union (b union c)\").assertParseSame();\n    final String ueui = \"a union b except c union d intersect e\";\n    ml(ueui).assertParseSame();\n    ml(\"((a union b) except c) union (d intersect e)\")\n        .assertParse(ueui);\n    ml(\"from x in emps union depts where deptno = 10\")\n        .assertParseSame();\n    final String fuf =\n        \"(from x in emps) union (from x in depts where #deptno x = 10)\";\n    ml(fuf).assertParseSame();\n    ml(\"(from x in emps) union from x in depts where #deptno x = 10\")\n        .assertParse(fuf);\n\n    ml(\"[1, 2, 3] union [2, 3, 4]\")\n        .assertEvalIter(equalsUnordered(1, 2, 3, 2, 3, 4));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests set operators (union, except, intersect).\nThese are Morel extensions to Standard ML,\nintended to help relational expressions,\nbut not part of the {@code from} expression."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFrom()", "name": "testFrom", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFrom()", "original_string": "  @Test void testFrom() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"    {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps yield #deptno e\\n\"\n        + \"end\";\n    ml(ml).assertEvalIter(equalsOrdered(10, 20, 30, 30));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testParseFrom()", "name": "testParseFrom", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testParseFrom()", "original_string": "  @Test void testParseFrom() {\n    ml(\"from\").assertParseSame();\n    ml(\"from e in emps\").assertParseSame();\n    ml(\"from e in emps where c\").assertParseSame();\n    ml(\"from e in emps, d in depts\").assertParseSame();\n    ml(\"from e in emps, d where hasEmp e\").assertParseSame();\n    ml(\"from e, d where hasEmp e\").assertParseSame();\n    ml(\"from e in emps, job, d where hasEmp (e, d, job)\")\n        .assertParseSame();\n    ml(\"from a, b in emps where a > b join c join d in depts where c > d\")\n        .assertParse(\"from a, b in emps where a > b \"\n            + \"join c, d in depts where c > d\");\n    ml(\"from a, b in emps where a > b join c, d in depts where c > d\")\n        .assertParseSame();\n    ml(\"from e in emps, d in depts on e.deptno = d.deptno\")\n        .assertParse(\"from e in emps, d in depts on #deptno e = #deptno d\");\n    ml(\"from e in emps on true, d in depts on e.deptno = d.deptno\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"on\\\" \\\"on \\\"\\\" \"\n                + \"at line 1, column 16.\"));\n    ml(\"from e, d in depts on e.deptno = d.deptno\")\n        .assertParse(\"from e, d in depts on #deptno e = #deptno d\");\n    ml(\"from , d in depts\").assertError(\"Xx\");\n    ml(\"from join d in depts on c\").assertError(\"Xx\");\n    ml(\"from left join d in depts on c\").assertError(\"Xx\");\n    ml(\"from right join d in depts on c\").assertError(\"Xx\");\n    ml(\"from full join d in depts on c\").assertError(\"Xx\");\n    ml(\"from e in emps join d in depts\").assertError(\"Xx\");\n    ml(\"from e in emps join d in depts where c\").assertError(\"Xx\");\n    ml(\"from e in emps join d in depts on c\")\n        .assertParse(\"from e in emps, d in depts on c\");\n    if (\"TODO\".isEmpty()) {\n      ml(\"from e in emps left join d in depts on c\").assertParseSame();\n      ml(\"from e in emps right join d in depts on c\").assertParseSame();\n      ml(\"from e in emps full join d in depts on c\").assertParseSame();\n    }\n    ml(\"from e in (from z in emps), d in (from y in depts) on c\")\n        .assertParseSame();\n    ml(\"from e in emps\\n\"\n        + \" group e.deptno\\n\"\n        + \" join d in depts on deptno = d.deptno\\n\"\n        + \" group d.location\\n\")\n        .assertParse(\"from e in emps\"\n            + \" group deptno = #deptno e\"\n            + \" join d in depts on deptno = #deptno d\"\n            + \" group location = #location d\");\n    // As previous, but use 'group e = {...}' so that we can write 'e.deptno'\n    // later in the query.\n    ml(\"from e in emps\\n\"\n        + \" group e = {e.deptno}\\n\"\n        + \" join d in depts on e.deptno = d.deptno\\n\"\n        + \" group d.location\")\n        .assertParse(\"from e in emps\"\n            + \" group e = {deptno = #deptno e}\"\n            + \" join d in depts on #deptno e = #deptno d\"\n            + \" group location = #location d\");\n    ml(\"(from e in emps where e.id = 101, d in depts)\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"in\\\" \\\"in \\\"\\\" at line 1, column 37.\"));\n    ml(\"from e in emps where e.id = 101 join d in depts\")\n        .assertParse(\"from e in emps where #id e = 101 join d in depts\");\n    // after 'group', you have to use 'join' not ','\n    ml(\"(from e in emps\\n\"\n        + \" group e.id compute count,\\n\"\n        + \" d in depts\\n\"\n        + \" where false)\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"in\\\" \\\"in \\\"\\\" at line 3, column 4.\"));\n    ml(\"(from e in emps\\n\"\n        + \" group e.id compute count\\n\"\n        + \" join d in depts\\n\"\n        + \" where false)\")\n        .assertParse(\"from e in emps\"\n            + \" group id = #id e compute count = count\"\n            + \" join d in depts where false\");\n    ml(\"from e in emps skip 1 take 2\").assertParseSame();\n    ml(\"from e in emps order e.empno take 2\")\n        .assertParse(\"from e in emps order #empno e take 2\");\n    ml(\"from e in emps order e.empno take 2 skip 3 skip 1+1 take 2\")\n        .assertParse(\"from e in emps order #empno e take 2 skip 3 skip 1 + 1 \"\n            + \"take 2\");\n    ml(\"fn f => from i in [1, 2, 3] where f i\")\n        .assertParseSame()\n        .assertType(\"(int -> bool) -> int list\");\n    ml(\"fn f => from i in [1, 2, 3] join j in [3, 4] on f (i, j) yield i + j\")\n        .assertParse(\"fn f => from i in [1, 2, 3],\"\n            + \" j in [3, 4] on f (i, j) yield i + j\")\n        .assertType(\"(int * int -> bool) -> int list\");\n\n    // In \"from p in exp\" and \"from p = exp\", p can be any pattern\n    // but in \"from v\" v can only be an identifier.\n    ml(\"from x, y in [1, 2], z\").assertParseSame();\n    ml(\"from {x, y} in [{x=1, y=2}], z\")\n        .assertParse(\"from {x = x, y = y} in [{x = 1, y = 2}], z\");\n    ml(\"from {x, y}, z\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\",\\\" \\\", \\\"\\\" \"\n                + \"at line 1, column 12.\"));\n    ml(\"from {x, y} group\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"group\\\" \\\"group \\\"\\\" \"\n                + \"at line 1, column 13.\"));\n    ml(\"from {x, y} where true\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"where\\\" \\\"where \\\"\\\" \"\n                + \"at line 1, column 13.\"));\n    ml(\"from (x, y) where true\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"where\\\" \\\"where \\\"\\\" \"\n                + \"at line 1, column 13.\"));\n    ml(\"from w as (x, y) order x\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"order\\\" \\\"order \\\"\\\" \"\n                + \"at line 1, column 18.\"));\n    ml(\"from (x, y)\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\"<EOF>\\\" at line 1, column 11.\"));\n    ml(\"from e in emps\\n\"\n        + \"through e in empsInDept 20\\n\"\n        + \"yield e.sal\")\n        .assertParse(\"from e in emps through e in empsInDept 20 yield #sal e\");\n    ml(\"from e in emps\\n\"\n        + \"yield e.empno\\n\"\n        + \"into sum\")\n        .assertParse(\"from e in emps yield #empno e into sum\");\n    ml(\"from e in emps\\n\"\n        + \"yield e.empno\\n\"\n        + \"compute sum, count\")\n        .assertParse(\"from e in emps \"\n            + \"yield #empno e \"\n            + \"compute sum = sum, count = count\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromYield()", "name": "testFromYield", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromYield()", "original_string": "  @Test void testFromYield() {\n    ml(\"from a in [1], b in [true]\")\n        .assertType(\"{a:int, b:bool} list\");\n    ml(\"from a in [1], b in [true] yield a\")\n        .assertType(\"int list\");\n    ml(\"from a in [1], b in [true] yield {a,b}\")\n        .assertType(\"{a:int, b:bool} list\");\n    ml(\"from a in [1], b in [true] yield {y=a,b}\")\n        .assertType(\"{b:bool, y:int} list\");\n    ml(\"from a in [1], b in [true] yield {y=a,x=b,z=a}\")\n        .assertType(\"{x:bool, y:int, z:int} list\");\n    ml(\"from a in [1], b in [true] yield {y=a,x=b,z=a} yield {z,x}\")\n        .assertType(\"{x:bool, z:int} list\");\n    ml(\"from a in [1], b in [true] yield {y=a,x=b,z=a} yield {z}\")\n        .assertType(\"{z:int} list\");\n    ml(\"from a in [1], b in [true] yield (b,a)\")\n        .assertType(\"(bool * int) list\");\n    ml(\"from a in [1], b in [true] yield (b)\")\n        .assertType(\"bool list\");\n    ml(\"from a in [1], b in [true] yield {b,a} yield a\")\n        .assertType(\"int list\");\n    String value = \"'yield' step that is not last in 'from' must be a record \"\n        + \"expression\";\n    ml(\"from a in [1], b in [true] yield (b,a) where b\")\n        .assertType(\"{a:int, b:bool} list\");\n    ml(\"from a in [1], b in [true] yield (b,a) where $c$\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"unbound variable or constructor: c\", pos));\n    ml(\"from a in [1], b in [true] yield {b,a} where b\")\n        .assertType(\"{a:int, b:bool} list\")\n        .assertEval(is(list(list(1, true))));\n    ml(\"from d in [{a=1,b=true}], i in [2] yield i\")\n        .assertType(\"int list\");\n    // Note that 'd' has record type but is not a record expression\n    ml(\"from d in [{a=1,b=true}], i in [2] yield d yield $a$\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"unbound variable or constructor: a\", pos));\n    ml(\"from d in [{a=1,b=true}], i in [2] yield {d.a,d.b} yield a\")\n        .assertType(\"int list\");\n    ml(\"from d in [{a=1,b=true}], i in [2] yield d where true\")\n        .assertType(\"{d:{a:int, b:bool}, i:int} list\");\n    ml(\"from d in [{a=1,b=true}], i in [2] yield i yield 3\")\n        .assertType(\"int list\");\n    ml(\"from d in [{a=1,b=true}], i in [2] yield d\")\n        .assertType(\"{a:int, b:bool} list\");\n    ml(\"from d in [{a=1,b=true}], i in [2] yield d yield 3\")\n        .assertType(\"int list\");\n    ml(\"from d in [{a=1,b=true}] yield $d.x$\", '$')\n        .assertTypeThrows(\n            pos -> throwsA(TypeResolver.TypeException.class,\n                is(\"no field 'x' in type '{a:int, b:bool}'\")));\n    ml(\"from d in [{a=1,b=true}] yield d.a into List.length\")\n        .assertType(\"int\");\n    ml(\"from d in [{a=1,b=true}] yield d.a into sum\")\n        .assertType(\"int\")\n        .assertEval(is(1));\n    ml(\"from d in [{a=1,b=true}] yield d.a $into sum$ yield \\\"a\\\"\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"'into' step must be last in 'from'\", pos));\n    // \"map String.size\" has type \"string list -> int list\",\n    // and therefore the type of \"j\" is \"int\"\n    ml(\"from s in [\\\"ab\\\",\\\"c\\\"]\\n\"\n        + \" through j in (map String.size)\")\n        .assertType(\"int list\");\n    ml(\"from s in [\\\"ab\\\",\\\"c\\\"]\\n\"\n        + \" through j in (map String.size)\\n\"\n        + \" yield j + 2\")\n        .assertType(\"int list\");\n    ml(\"from d in [{a=1,b=true},{a=2,b=false}]\\n\"\n        + \" yield d.a\\n\"\n        + \" through s in (fn ints =>\\n\"\n        + \"   from i in ints yield substring (\\\"abc\\\", 0, i))\")\n        .assertType(\"string list\")\n        .assertEval(is(list(\"a\", \"ab\")));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromYieldExpression()", "name": "testFromYieldExpression", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromYieldExpression()", "original_string": "  @Test void testFromYieldExpression() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"    {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps yield (#id e + #deptno e)\\n\"\n        + \"end\";\n    ml(ml).assertEvalIter(equalsOrdered(110, 121, 132, 133));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromWhere()", "name": "testFromWhere", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromWhere()", "original_string": "  @Test void testFromWhere() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"    {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps where #deptno e = 30 yield #id e\\n\"\n        + \"end\";\n    ml(ml).assertEvalIter(equalsOrdered(102, 103));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat()", "name": "testFromSuchThat", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat()", "original_string": "  @Test void testFromSuchThat() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"    {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"  fun hasEmpNameInDept (n, d) =\\n\"\n        + \"    (n, d) elem (from e in emps yield (e.name, e.deptno))\\n\"\n        + \"in\\n\"\n        + \"  from n, d\\n\"\n        + \"    where hasEmpNameInDept (n, d)\\n\"\n        + \"    where d = 30\\n\"\n        + \"    yield {d, n}\\n\"\n        + \"end\";\n    final String code = \"from(sink\\n\"\n        + \"  join(pat v0,\\n\"\n        + \"  exp from(\\n\"\n        + \"    sink join(pat e, exp tuple(\\n\"\n        + \"  tuple(constant(10), constant(100), constant(Fred)),\\n\"\n        + \"  tuple(constant(20), constant(101), constant(Velma)),\\n\"\n        + \"  tuple(constant(30), constant(102), constant(Shaggy)),\\n\"\n        + \"  tuple(constant(30), constant(103), constant(Scooby))),\\n\"\n        + \" sink collect(tuple(apply(fnValue nth:2, argCode get(name e)), \"\n        + \"apply(fnValue nth:0, argCode get(name e)))))), \"\n        + \"sink join(pat n_1, exp tuple(\\n\"\n        + \" apply(fnValue nth:0, argCode get(name v0))), \"\n        + \"sink join(pat d_1, exp tuple(constant(30)), \"\n        + \"sink where(condition apply2(fnValue elem,\\n\"\n        + \"                            tuple(get(name n), get(name d)), \"\n        + \"from(sink join(pat e, exp tuple(\\n\"\n        + \"  tuple(constant(10), constant(100), constant(Fred)),\\n\"\n        + \"  tuple(constant(20), constant(101), constant(Velma)),\\n\"\n        + \"  tuple(constant(30), constant(102), constant(Shaggy)),\\n\"\n        + \"  tuple(constant(30), constant(103), constant(Scooby))),\\n\"\n        + \" sink collect(tuple(apply(fnValue nth:2, argCode get(name e)), \"\n        + \"apply(fnValue nth:0, argCode get(name e))))))),\\n\"\n        + \"        sink where(condition apply2(fnValue =, get(name d), constant(30)),\\n\"\n        + \"          sink collect(tuple(get(name d), get(name n)))))))))\";\n    final List<Object> expected =\n        list(list(30, \"Shaggy\"), list(30, \"Scooby\"));\n    ml(ml).assertType(\"{d:int, n:string} list\")\n        .assertPlan(isCode2(code))\n        .assertEval(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Applies {@code suchthat} to a function that tests membership of a set,\nand therefore the effect is to iterate over that set."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat2()", "name": "testFromSuchThat2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat2()", "original_string": "  @Test void testFromSuchThat2() {\n    final String ml = \"let\\n\"\n        + \"  fun hasJob (d, job) =\\n\"\n        + \"    (d div 2, job)\\n\"\n        + \"      elem (from e in scott.emp yield (e.deptno, e.job))\\n\"\n        + \"in\\n\"\n        + \"  from d in scott.dept, j\"\n        + \"    where hasJob (d.deptno, j)\\n\"\n        + \"    yield j\\n\"\n        + \"end\";\n    final String core = \"val it = \"\n        + \"from d_1 in #dept scott \"\n        + \"join j : string \"\n        + \"where case (#deptno d_1, j) of\"\n        + \" (d, job) => op elem ((op div (d, 2), job),\"\n        + \" from e in #emp scott\"\n        + \" yield (#deptno e, #job e)) yield j\";\n    final String code = \"from(sink join(pat d_1,\\n\"\n        + \"    exp apply(fnValue nth:1, argCode get(name scott)),\\n\"\n        + \"  sink join(pat j,\\n\"\n        + \"      exp apply(\\n\"\n        + \"        fnCode apply(fnValue List.filter,\\n\"\n        + \"          argCode match(j,\\n\"\n        + \"            apply(fnCode match((d, job),\\n\"\n        + \"              apply2(fnValue elem,\\n\"\n        + \"                tuple(apply2(fnValue div, get(name d), constant(2)),\\n\"\n        + \"                get(name job)),\\n\"\n        + \"              from(\\n\"\n        + \"              sink join(pat e,\\n\"\n        + \"                exp apply(fnValue nth:2, argCode get(name scott)),\\n\"\n        + \"                sink collect(\\n\"\n        + \"                  tuple(apply(fnValue nth:1, argCode get(name e)),\\n\"\n        + \"                    apply(fnValue nth:5, argCode get(name e)))))))),\\n\"\n        + \"              argCode tuple(\\n\"\n        + \"                apply(fnValue nth:0, argCode get(name d)),\\n\"\n        + \"                get(name j))))),\\n\"\n        + \"        argCode apply(fnValue $.extent, argCode constant(()))),\\n\"\n        + \"    sink collect(get(name j)))))\";\n    final List<Object> expected = list(); // TODO\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"string list\");\n//        .assertCore(-1, is(core))\n//        .assertPlan(isCode2(code))\n//        .assertEval(is(expected));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat2b()", "name": "testFromSuchThat2b", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat2b()", "original_string": "  @Test void testFromSuchThat2b() {\n    final String ml = \"from d where d elem scott.dept\";\n    final String core0 = \"val it = \"\n        + \"from d : {deptno:int, dname:string, loc:string} \"\n        + \"where d elem #dept scott\";\n    final String core1 = \"val it = from d in #dept scott\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{deptno:int, dname:string, loc:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Translates a simple {@code suchthat} expression, \"d elem list\"."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat2c()", "name": "testFromSuchThat2c", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat2c()", "original_string": "  @Test void testFromSuchThat2c() {\n    final String ml = \"from loc, deptno, name \"\n        + \"where {deptno, loc, dname = name} elem scott.dept\";\n    final String core = \"val it = \"\n        + \"from v0 in #dept scott \"\n        + \"join loc in [#loc v0] \"\n        + \"join deptno in [#deptno v0] \"\n        + \"join name in [#dname v0] \"\n        + \"where op elem ({deptno = deptno, dname = name, loc = loc},\"\n        + \" #dept scott) \"\n        + \"yield {deptno = deptno, loc = loc, name = name}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{deptno:int, loc:string, name:string} list\")\n        .assertCore(-1, hasToString(core))\n        .assertEval(\n            is(\n                list(list(10, \"NEW YORK\", \"ACCOUNTING\"),\n                    list(20, \"DALLAS\", \"RESEARCH\"),\n                    list(30, \"CHICAGO\", \"SALES\"),\n                    list(40, \"BOSTON\", \"OPERATIONS\"))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Translates a simple {@code suchthat} expression, \"{x, y} elem list\".\nFields are renamed, to disrupt alphabetical ordering."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat2d()", "name": "testFromSuchThat2d", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat2d()", "original_string": "  @Test void testFromSuchThat2d() {\n    final String ml = \"from dno, name\\n\"\n        + \"  where {deptno = dno, dname = name, loc = \\\"CHICAGO\\\"}\\n\"\n        + \"      elem scott.dept\\n\"\n        + \"    andalso dno > 20\";\n    final String core0 = \"val it = \"\n        + \"from dno : int \"\n        + \"join name : string \"\n        + \"where {deptno = dno, dname = name, loc = \\\"CHICAGO\\\"} \"\n        + \"elem #dept scott \"\n        + \"andalso dno > 20\";\n    final String core1 = \"val it = \"\n        + \"from v0 in #dept scott \"\n        + \"join dno in [#deptno v0] \"\n        + \"join name in [#dname v0] \"\n        + \"where op elem ({deptno = dno, dname = name, loc = \\\"CHICAGO\\\"},\"\n        + \" #dept scott) \"\n        + \"andalso dno > 20 \"\n        + \"yield {dno = dno, name = name}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dno:int, name:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFromSuchThat2c()} but with a literal."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat2d2()", "name": "testFromSuchThat2d2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat2d2()", "original_string": "  @Test void testFromSuchThat2d2() {\n    final String ml = \"from dno, name\\n\"\n        + \"  where {deptno = dno, dname = name, loc = \\\"CHICAGO\\\"}\\n\"\n        + \"      elem scott.dept\\n\"\n        + \"    andalso dno > 20\";\n    final String core0 = \"val it = \"\n        + \"from dno : int \"\n        + \"join name : string \"\n        + \"where {deptno = dno, dname = name, loc = \\\"CHICAGO\\\"} \"\n        + \"elem #dept scott \"\n        + \"andalso dno > 20\";\n    final String core1 = \"val it = \"\n        + \"from v0 in #dept scott \"\n        + \"join dno in [#deptno v0] \"\n        + \"join name in [#dname v0] \"\n        + \"where op elem ({deptno = dno, dname = name, loc = \\\"CHICAGO\\\"},\"\n        + \" #dept scott) \"\n        + \"andalso dno > 20 \"\n        + \"yield {dno = dno, name = name}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dno:int, name:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFromSuchThat2c()} but with a literal."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat2d3()", "name": "testFromSuchThat2d3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat2d3()", "original_string": "  @Test void testFromSuchThat2d3() {\n    final String ml = \"from dno, name, v\\n\"\n        + \"where v elem scott.dept\\n\"\n        + \"where v.deptno = dno\\n\"\n        + \"where name = v.dname\\n\"\n        + \"where v.loc = \\\"CHICAGO\\\"\\n\"\n        + \"where dno = 30\\n\"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    final String core0 = \"val it = \"\n        + \"from dno : int \"\n        + \"join name : string \"\n        + \"join v : {deptno:int, dname:string, loc:string} \"\n        + \"where v elem #dept scott \"\n        + \"where #deptno v = dno \"\n        + \"where name = #dname v \"\n        + \"where #loc v = \\\"CHICAGO\\\" \"\n        + \"where dno = 30 \"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    final String core1 = \"val it = \"\n        + \"from dno in [30] \"\n        + \"join v in #dept scott \"\n        + \"join name in [#dname v] \"\n        + \"where #deptno v = dno \"\n        + \"where name = #dname v \"\n        + \"where #loc v = \\\"CHICAGO\\\" \"\n        + \"where dno = 30 \"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dno:int, name:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1))\n        .assertEval(is(list(list(30, \"SALES\"))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat2d4()", "name": "testFromSuchThat2d4", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat2d4()", "original_string": "  @Test void testFromSuchThat2d4() {\n    final String ml = \"from dno, name, v\\n\"\n        + \"where v elem scott.dept\\n\"\n        + \"where v.deptno = dno\\n\"\n        + \"where name = v.dname\\n\"\n        + \"where v.loc = \\\"CHICAGO\\\"\\n\"\n        + \"where dno > 25\\n\"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    final String core0 = \"val it = \"\n        + \"from dno : int \"\n        + \"join name : string \"\n        + \"join v : {deptno:int, dname:string, loc:string} \"\n        + \"where v elem #dept scott \"\n        + \"where #deptno v = dno \"\n        + \"where name = #dname v \"\n        + \"where #loc v = \\\"CHICAGO\\\" \"\n        + \"where dno > 25 \"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    final String core1 = \"val it = \"\n        + \"from v in #dept scott \"\n        + \"join dno in [#deptno v] \"\n        + \"join name in [#dname v] \"\n        + \"where #deptno v = dno \"\n        + \"where name = #dname v \"\n        + \"where #loc v = \\\"CHICAGO\\\" \"\n        + \"where dno > 25 \"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dno:int, name:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1))\n        .assertEval(is(list(list(30, \"SALES\"))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat2e()", "name": "testFromSuchThat2e", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat2e()", "original_string": "  @Test void testFromSuchThat2e() {\n    final String ml = \"let\\n\"\n        + \"  fun isDept d =\\n\"\n        + \"    d elem scott.dept\\n\"\n        + \"in\\n\"\n        + \"  from d\\n\"\n        + \"    where isDept d andalso d.deptno = 20\\n\"\n        + \"    yield d.dname\\n\"\n        + \"end\";\n    final String core0 = \"val it = \"\n        + \"let\"\n        + \" val isDept = fn d => d elem #dept scott \"\n        + \"in\"\n        + \" from d_1 : {deptno:int, dname:string, loc:string}\"\n        + \" where isDept d_1 andalso #deptno d_1 = 20\"\n        + \" yield #dname d_1 \"\n        + \"end\";\n    final String core1 = \"val it = \"\n        + \"from d_1 in #dept scott \"\n        + \"where #deptno d_1 = 20 \"\n        + \"yield #dname d_1\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"string list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFromSuchThat2d()} but using a function.\n(Simple enough that the function can be handled by inlining.)"}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat2f()", "name": "testFromSuchThat2f", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat2f()", "original_string": "  @Test void testFromSuchThat2f() {\n    final String ml = \"let\\n\"\n        + \"  fun isDept d =\\n\"\n        + \"    d elem scott.dept\\n\"\n        + \"  fun isEmp e =\\n\"\n        + \"    e elem scott.emp\\n\"\n        + \"in\\n\"\n        + \"  from d, e\\n\"\n        + \"    where isDept d\\n\"\n        + \"    andalso isEmp e\\n\"\n        + \"    andalso d.deptno = e.deptno\\n\"\n        + \"    andalso d.deptno = 20\\n\"\n        + \"    yield d.dname\\n\"\n        + \"end\";\n    final String core0 = \"val it = \"\n        + \"let\"\n        + \" val isDept = fn d => d elem #dept scott \"\n        + \"in\"\n        + \" let\"\n        + \" val isEmp = fn e => e elem #emp scott \"\n        + \"in\"\n        + \" from d_1 : {deptno:int, dname:string, loc:string}\"\n        + \" join e_1 : {comm:real, deptno:int, empno:int, ename:string, \"\n        + \"hiredate:string, job:string, mgr:int, sal:real}\"\n        + \" where isDept d_1 \"\n        + \"andalso isEmp e_1 \"\n        + \"andalso #deptno d_1 = #deptno e_1 \"\n        + \"andalso #deptno d_1 = 20\"\n        + \" yield #dname d_1\"\n        + \" end \"\n        + \"end\";\n    final String core1 = \"val it = \"\n        + \"from d_1 in #dept scott \"\n        + \"join e_1 in #emp scott \"\n        + \"where #deptno d_1 = #deptno e_1 \"\n        + \"andalso #deptno d_1 = 20 \"\n        + \"yield #dname d_1\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"string list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a join expressed via {@code suchthat}."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromSuchThat3()", "name": "testFromSuchThat3", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromSuchThat3()", "original_string": "  @Test void testFromSuchThat3() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"  fun hasEmpNameInDept (n, d) =\\n\"\n        + \"    (n, d) elem (from e in emps yield (e.name, e.deptno))\\n\"\n        + \"in\\n\"\n        + \"  from n, d\\n\"\n        + \"    where hasEmpNameInDept (n, d)\\n\"\n        + \"    where d = 30\\n\"\n        + \"    yield {d, n}\\n\"\n        + \"end\";\n    final String core = \"val it = \"\n        + \"from n_1, d_1 \"\n        + \"where (case (n_1, d_1) of (n, d) => op elem ((n, d), \"\n        + \"from e in [\"\n        + \"{deptno = 30, id = 102, name = \\\"Shaggy\\\"}, \"\n        + \"{deptno = 30, id = 103, name = \\\"Scooby\\\"}]\"\n        + \" yield (#name e, #deptno e)))\"\n        + \" where d_1 = 30\"\n        + \" yield {d = d_1, n = n_1}\";\n    final String code = \"from(sink\\n\"\n        + \"  join(pat (n_1, d_1),\\n\"\n        + \"  exp apply(\\n\"\n        + \"    fnCode apply(fnValue List.filter,\\n\"\n        + \"      argCode match(v0,\\n\"\n        + \"        apply(fnCode match((n_1, d_1),\\n\"\n        + \"            apply(fnCode match((n, d),\\n\"\n        + \"                apply2(fnValue elem,\\n\"\n        + \"                  tuple(get(name n), get(name d)),\\n\"\n        + \"                  from(sink\\n\"\n        + \"                    join(pat e, exp tuple(\\n\"\n        + \"  tuple(constant(30), constant(102), constant(Shaggy)),\\n\"\n        + \"  tuple(constant(30), constant(103), constant(Scooby))),\\n\"\n        + \"      sink collect(tuple(apply(fnValue nth:2, argCode get(name e)),\\n\"\n        + \"        apply(fnValue nth:0, argCode get(name e)))))))),\\n\"\n        + \"               argCode tuple(get(name n), get(name d)))),\\n\"\n        + \"            argCode get(name v0)))),\\n\"\n        + \"          argCode apply(fnValue $.extent, argCode constant(()))),\\n\"\n        + \"        sink where(condition apply2(fnValue =, get(name d), constant(30)),\\n\"\n        + \"          sink collect(tuple(get(name d), get(name n))))))\";\n    ml(ml).assertType(\"{d:int, n:string} list\");\n//        .assertCore(-1, is(core))\n//        .assertPlan(isCode2(code))\n//        .assertEval(is(list()));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " A {@code suchthat} expression."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testBooleanExtent()", "name": "testBooleanExtent", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testBooleanExtent()", "original_string": "  @Test void testBooleanExtent() {\n    final String ml = \"from i\\n\"\n        + \"where Option.getOpt (i, false)\";\n    final String core = \"val it = \"\n        + \"from i in extent \\\"bool option\\\" \"\n        + \"where #getOpt Option (i, false)\";\n    ml(ml).assertType(\"bool option list\")\n        .assertCore(-1, hasToString(core))\n        .assertEval(is(list(list(\"SOME\", true))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " A query with an unconstrained scan that is deduced to be of type\n{@code bool option} and therefore iterates over\n{@code [SOME true, SOME false, NONE]}."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromNoYield()", "name": "testFromNoYield", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromNoYield()", "original_string": "  @Test void testFromNoYield() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps where #deptno e = 30\\n\"\n        + \"end\";\n    ml(ml).assertType(\"{deptno:int, id:int, name:string} list\")\n        .assertEvalIter(equalsOrdered(list(30, 103, \"Scooby\")));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromJoinNoYield()", "name": "testFromJoinNoYield", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromJoinNoYield()", "original_string": "  @Test void testFromJoinNoYield() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20}]\\n\"\n        + \"  val depts =\\n\"\n        + \"    [{deptno = 10, name = \\\"Sales\\\"}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps, d in depts where #deptno e = #deptno d\\n\"\n        + \"end\";\n    ml(ml)\n        .assertType(\"{d:{deptno:int, name:string},\"\n            + \" e:{deptno:int, id:int, name:string}} list\")\n        .assertEvalIter(\n            equalsOrdered(list(list(10, \"Sales\"), list(10, 100, \"Fred\"))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testYieldYield()", "name": "testYieldYield", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testYieldYield()", "original_string": "  @Test void testYieldYield() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps\\n\"\n        + \"  yield {x = e.id + e.deptno, y = e.id - e.deptno}\\n\"\n        + \"  yield x + y\\n\"\n        + \"end\";\n    ml(ml)\n        .assertType(\"int list\")\n        .assertEvalIter(equalsOrdered(200, 202));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testYieldSingletonRecord()", "name": "testYieldSingletonRecord", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testYieldSingletonRecord()", "original_string": "  @Test void testYieldSingletonRecord() {\n    final String ml = \"from e in [{x=1,y=2},{x=3,y=4},{x=5,y=6}]\\n\"\n        + \"  yield {z=e.x}\\n\"\n        + \"  where z > 2\\n\"\n        + \"  order z desc\\n\"\n        + \"  yield {z=z}\";\n    ml(ml)\n        .assertType(\"{z:int} list\")\n        .assertEvalIter(equalsOrdered(list(5), list(3)));\n\n    final String ml2 = \"from e in [{x=1,y=2},{x=3,y=4},{x=5,y=6}]\\n\"\n        + \"  yield {z=e.x}\\n\"\n        + \"  where z > 2\\n\"\n        + \"  order z desc\";\n    ml(ml2)\n        .assertType(\"int list\")\n        .assertEvalIter(equalsOrdered(5, 3));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testCrossApply()", "name": "testCrossApply", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCrossApply()", "original_string": "  @Test void testCrossApply() {\n    final String ml = \"from s in [\\\"abc\\\", \\\"\\\", \\\"d\\\"],\\n\"\n        + \"    c in explode s\\n\"\n        + \"  yield s ^ \\\":\\\" ^ str c\";\n    ml(ml).assertEvalIter(equalsOrdered(\"abc:a\", \"abc:b\", \"abc:c\", \"d:d\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Analogous to SQL \"CROSS APPLY\" which calls a table-valued function\nfor each row in an outer loop."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testCrossApplyGroup()", "name": "testCrossApplyGroup", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCrossApplyGroup()", "original_string": "  @Test void testCrossApplyGroup() {\n    final String ml = \"from s in [\\\"abc\\\", \\\"\\\", \\\"d\\\"],\\n\"\n        + \"    c in explode s\\n\"\n        + \"  group s compute count = sum of 1\";\n    ml(ml).assertEvalIter(equalsUnordered(list(3, \"abc\"), list(1, \"d\")));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testJoinLateral()", "name": "testJoinLateral", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testJoinLateral()", "original_string": "  @Test void testJoinLateral() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [{name = \\\"Shaggy\\\",\\n\"\n        + \"               pets = [{name = \\\"Scooby\\\", species = \\\"Dog\\\"},\\n\"\n        + \"                       {name = \\\"Scrappy\\\", species = \\\"Dog\\\"}]},\\n\"\n        + \"              {name = \\\"Charlie\\\",\\n\"\n        + \"               pets = [{name = \\\"Snoopy\\\", species = \\\"Dog\\\"}]},\\n\"\n        + \"              {name = \\\"Danny\\\", pets = []}]\"\n        + \"in\\n\"\n        + \"  from e in emps,\\n\"\n        + \"      p in e.pets\\n\"\n        + \"    yield p.name\\n\"\n        + \"end\";\n    ml(ml).assertEvalIter(equalsOrdered(\"Scooby\", \"Scrappy\", \"Snoopy\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromGroupWithoutCompute()", "name": "testFromGroupWithoutCompute", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromGroupWithoutCompute()", "original_string": "  @Test void testFromGroupWithoutCompute() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"     {id = 102, name = \\\"Shaggy\\\", deptno = 10}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps group #deptno e\\n\"\n        + \"end\";\n    final String expected = \"let val emps = \"\n        + \"[{deptno = 10, id = 100, name = \\\"Fred\\\"},\"\n        + \" {deptno = 20, id = 101, name = \\\"Velma\\\"},\"\n        + \" {deptno = 10, id = 102, name = \\\"Shaggy\\\"}] \"\n        + \"in\"\n        + \" from e in emps\"\n        + \" group deptno = #deptno e \"\n        + \"end\";\n    ml(\"val x = \" + ml)\n        .assertParseDecl(Ast.ValDecl.class, \"val x = \" + expected);\n    // The implicit yield expression is \"deptno\". It is not a record,\n    // \"{deptno = deptno}\", because there is only one variable defined (the\n    // \"group\" clause defines \"deptno\" and hides the \"e\" from the \"from\"\n    // clause).\n    ml(ml).assertType(\"int list\")\n        .assertEvalIter(equalsUnordered(10, 20));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromGroupWithoutCompute2()", "name": "testFromGroupWithoutCompute2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromGroupWithoutCompute2()", "original_string": "  @Test void testFromGroupWithoutCompute2() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"     {id = 102, name = \\\"Shaggy\\\", deptno = 10}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps group #deptno e, parity = e.id mod 2\\n\"\n        + \"end\";\n    ml(ml).assertType(\"{deptno:int, parity:int} list\")\n        .assertEvalIter(equalsUnordered(list(10, 0), list(20, 1)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " As {@link #testFromGroupWithoutCompute()} but composite key, therefore\nresult is a list of records."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromGroup()", "name": "testFromGroup", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromGroup()", "original_string": "  @Test void testFromGroup() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"     {id = 102, name = \\\"Shaggy\\\", deptno = 10}]\\n\"\n        + \"  fun sum [] = 0 | sum (h::t) = h + (sum t)\\n\"\n        + \"in\\n\"\n        + \"  from e in emps\\n\"\n        + \"    group #deptno e\\n\"\n        + \"    compute sumId = sum of #id e\\n\"\n        + \"end\";\n    final String expected = \"let val emps = \"\n        + \"[{deptno = 10, id = 100, name = \\\"Fred\\\"},\"\n        + \" {deptno = 20, id = 101, name = \\\"Velma\\\"},\"\n        + \" {deptno = 10, id = 102, name = \\\"Shaggy\\\"}]; \"\n        + \"fun sum ([]) = 0 | sum (h :: t) = h + sum t \"\n        + \"in\"\n        + \" from e in emps\"\n        + \" group deptno = #deptno e\"\n        + \" compute sumId = sum of #id e \"\n        + \"end\";\n    ml(\"val x = \" + ml)\n        .assertParseDecl(Ast.ValDecl.class, \"val x = \" + expected);\n    ml(ml).assertType(\"{deptno:int, sumId:int} list\")\n        .assertEvalIter(equalsUnordered(list(10, 202), list(20, 101)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testGroupAs()", "name": "testGroupAs", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testGroupAs()", "original_string": "  @Test void testGroupAs() {\n    final String ml0 = \"from e in emp\\n\"\n        + \"group deptno = e.deptno\";\n    final String ml1 = \"from e in emp\\n\"\n        + \"group e.deptno\";\n    final String ml2 = \"from e in emp\\n\"\n        + \"group #deptno e\";\n    final String expected = \"from e in emp group deptno = #deptno e\";\n    ml(ml0).assertParse(expected);\n    ml(ml1).assertParse(expected);\n    ml(ml2).assertParse(expected);\n\n    final String ml3 = \"from e in emp\\n\"\n        + \"group e, h = f + e.g\";\n    final String expected3 = \"from e in emp group e = e, h = f + #g e\";\n    ml(ml3).assertParse(expected3);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testGroupAs2()", "name": "testGroupAs2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testGroupAs2()", "original_string": "  @Test void testGroupAs2() {\n    ml(\"from e in emp group e.deptno, e.deptno + e.empid\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression #deptno e + #empid e\"));\n    ml(\"from e in emp group 1\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression 1\"));\n    ml(\"from e in emp group e.deptno compute (fn x => x) of e.job\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression fn x => x\"));\n    // Require that we can derive a name for the expression even though there\n    // is only one, and therefore we would not use the name.\n    // (We could revisit this requirement.)\n    ml(\"from e in emp group compute (fn x => x) of e.job\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression fn x => x\"));\n    ml(\"from e in [{x = 1, y = 5}]\\n\"\n        + \"  group compute sum of e.x\")\n        .assertType(hasMoniker(\"int list\"));\n    ml(\"from e in [1, 2, 3]\\n\"\n        + \"  group compute sum of e\")\n        .assertType(hasMoniker(\"int list\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testGroupSansOf()", "name": "testGroupSansOf", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testGroupSansOf()", "original_string": "  @Test void testGroupSansOf() {\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"  group compute c = count\")\n        .assertType(hasMoniker(\"int list\"))\n        .assertEvalIter(equalsUnordered(3));\n\n    ml(\"from e in [{a = 1, b = 5}, {a = 0, b = 1}, {a = 1, b = 1}]\\n\"\n        + \"  group e.a compute rows = (fn x => x)\")\n        .assertType(hasMoniker(\"{a:int, rows:{a:int, b:int} list} list\"))\n        .assertEvalIter(\n            equalsUnordered(\n                list(1, list(list(1, 5), list(1, 1))),\n                list(0, list(list(0, 1)))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testGroupDuplicates()", "name": "testGroupDuplicates", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testGroupDuplicates()", "original_string": "  @Test void testGroupDuplicates() {\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\")\n        .assertEvalIter(equalsUnordered(0, 1));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x, b = e.x\")\n        .assertEvalIter(equalsUnordered(list(0, 0), list(1, 1)));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x, a = e.y\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'a' in group\")));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group e.x, x = e.y\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'x' in group\")));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\\n\"\n        + \"compute b = sum of e.y\")\n        .assertEvalIter(equalsUnordered(list(0, 1), list(1, 6)));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\\n\"\n        + \"compute a = sum of e.y\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'a' in group\")));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group sum = e.x\\n\"\n        + \"compute sum of e.y\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'sum' in group\")));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\\n\"\n        + \"compute b = sum of e.y, c = sum of e.x\")\n        .assertEvalIter(equalsUnordered(list(0, 1, 0), list(1, 6, 2)));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\\n\"\n        + \"compute c = sum of e.y, c = sum of e.x\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'c' in group\")));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that Morel throws if there are duplicate names in 'group' or\n'compute' clauses."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testCompute()", "name": "testCompute", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testCompute()", "original_string": "  @Test void testCompute() {\n    ml(\"from i in [1, 2, 3] compute sum of i\")\n        .assertParse(\"from i in [1, 2, 3] compute sum = sum of i\")\n        .assertType(\"int\")\n        .assertEval(is(6));\n    ml(\"from i in [1, 2, 3] compute sum of i, count\")\n        .assertParse(\"from i in [1, 2, 3] \"\n            + \"compute sum = sum of i, count = count\")\n        .assertType(\"{count:int, sum:int}\");\n    // there must be at least one aggregate function\n    ml(\"from i in [1, 2, 3] compute\")\n        .assertParseThrows(\n            throwsA(ParseException.class,\n                startsWith(\"Encountered \\\"<EOF>\\\" at \")));\n\n    // Theoretically a \"group\" without a \"compute\" can be followed by a\n    // \"compute\" step. So, the following is ambiguous. We treat it as a single\n    // \"group ... compute\" step. Under the two-step interpretation, the type\n    // would have been \"int\".\n    ml(\"from (i, j) in [(1, 1), (2, 3), (3, 4)]\\n\"\n        + \"  group j = i mod 2\\n\"\n        + \"  compute sum of j\")\n        .assertType(\"{j:int, sum:int} list\")\n        .assertEvalIter(equalsUnordered(list(1, 5), list(0, 3)));\n\n    // \"compute\" must not be followed by other steps\n    ml(\"from i in [1, 2, 3] compute s = sum of i yield s + 2\")\n        .assertTypeThrows(\n            throwsA(IllegalArgumentException.class,\n                is(\"'compute' step must be last in 'from'\")));\n    // similar, but valid\n    ml(\"(from i in [1, 2, 3] compute s = sum of i) + 2\")\n        .assertType(hasMoniker(\"int\"))\n        .assertEval(is(8));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests query with 'compute' without 'group'. Such a query does not return\na collection, but returns the value of the aggregate function. Technically,\nit is a monoid comprehension, and an aggregate function is a monoid."}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testGroupYield()", "name": "testGroupYield", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testGroupYield()", "original_string": "  @Test void testGroupYield() {\n    final String ml = \"from r in [{a=2,b=3}]\\n\"\n        + \"group r.a compute sb = sum of r.b\\n\"\n        + \"yield {a, a2 = a + a, sb}\";\n    final String expected = \"from r in [{a = 2, b = 3}]\"\n        + \" group a = #a r compute sb = sum of #b r\"\n        + \" yield {a = a, a2 = a + a, sb = sb}\";\n    final String plan = \"from(\"\n        + \"sink join(pat r, exp tuple(tuple(constant(2), constant(3))), \"\n        + \"sink group(key tuple(apply(fnValue nth:0, argCode get(name r))), \"\n        + \"agg aggregate, \"\n        + \"sink collect(tuple(get(name a), \"\n        + \"apply2(fnValue +, get(name a), get(name a)), \"\n        + \"get(name sb))))))\";\n    ml(ml).assertParse(expected)\n        .assertEvalIter(equalsOrdered(list(2, 4, 3)))\n        .assertPlan(isCode(plan));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testJoinGroup()", "name": "testJoinGroup", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testJoinGroup()", "original_string": "  @Test void testJoinGroup() {\n    final String ml = \"from e in [{empno=100,deptno=10}],\\n\"\n        + \"  d in [{deptno=10,altitude=3500}]\\n\"\n        + \"group e.deptno compute s = sum of e.empno + d.altitude\";\n    final String expected = \"from e in [{deptno = 10, empno = 100}],\"\n        + \" d in [{altitude = 3500, deptno = 10}]\"\n        + \" group deptno = #deptno e\"\n        + \" compute s = sum of #empno e + #altitude d\";\n    ml(ml).assertParse(expected)\n        .assertType(\"{deptno:int, s:int} list\")\n        .assertEvalIter(equalsOrdered(list(10, 3600)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testGroupGroup()", "name": "testGroupGroup", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testGroupGroup()", "original_string": "  @Test void testGroupGroup() {\n    final String ml = \"from r in [{a=2,b=3}]\\n\"\n        + \"group a1 = r.a, b1 = r.b\\n\"\n        + \"group c2 = a1 + b1 compute s2 = sum of a1\";\n    final String expected = \"from r in [{a = 2, b = 3}]\"\n        + \" group a1 = #a r, b1 = #b r\"\n        + \" group c2 = a1 + b1 compute s2 = sum of a1\";\n    ml(ml).assertParse(expected)\n        .assertType(hasMoniker(\"{c2:int, s2:int} list\"))\n        .assertEvalIter(equalsOrdered(list(5, 2)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromOrderYield()", "name": "testFromOrderYield", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromOrderYield()", "original_string": "  @Test void testFromOrderYield() {\n    final String ml = \"from r in [{a=1,b=2},{a=1,b=0},{a=2,b=1}]\\n\"\n        + \"  order r.a desc, r.b\\n\"\n        + \"  skip 0\\n\"\n        + \"  take 4 + 6\\n\"\n        + \"  yield {r.a, b10 = r.b * 10}\";\n    final String expected = \"from r in\"\n        + \" [{a = 1, b = 2}, {a = 1, b = 0}, {a = 2, b = 1}]\"\n        + \" order #a r desc, #b r\"\n        + \" skip 0\"\n        + \" take 4 + 6\"\n        + \" yield {a = #a r, b10 = #b r * 10}\";\n    ml(ml).assertParse(expected)\n        .assertType(hasMoniker(\"{a:int, b10:int} list\"))\n        .assertEvalIter(equalsOrdered(list(2, 10), list(1, 0), list(1, 20)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromEmpty()", "name": "testFromEmpty", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromEmpty()", "original_string": "  @Test void testFromEmpty() {\n    final String ml = \"from\";\n    final String expected = \"from\";\n    ml(ml).assertParse(expected)\n        .assertType(hasMoniker(\"unit list\"))\n        .assertEvalIter(equalsOrdered(list()));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromPattern()", "name": "testFromPattern", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromPattern()", "original_string": "  @Test void testFromPattern() {\n    ml(\"from (x, y) in [(1,2),(3,4),(3,0)] group sum = x + y\")\n        .assertParse(\"from (x, y) in [(1, 2), (3, 4), (3, 0)] \"\n            + \"group sum = x + y\")\n        .assertType(hasMoniker(\"int list\"))\n        .assertEvalIter(equalsUnordered(3, 7));\n    ml(\"from {c, a, ...} in [{a=1.0,b=true,c=3},{a=1.5,b=true,c=4}]\")\n        .assertParse(\"from {a = a, c = c, ...}\"\n            + \" in [{a = 1.0, b = true, c = 3}, {a = 1.5, b = true, c = 4}]\")\n        .assertType(\"{a:real, c:int} list\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFromEquals()", "name": "testFromEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromEquals()", "original_string": "  @Test void testFromEquals() {\n    final String ml = \"from x in [\\\"a\\\", \\\"b\\\"], y = \\\"c\\\", z in [\\\"d\\\"]\\n\"\n        + \"  yield x ^ y ^ z\";\n    final String expected = \"from x in [\\\"a\\\", \\\"b\\\"], y = \\\"c\\\", z in [\\\"d\\\"]\"\n        + \" yield x ^ y ^ z\";\n    ml(ml).assertParse(expected)\n        .assertType(hasMoniker(\"string list\"))\n        .assertEvalIter(equalsUnordered(\"acd\", \"bcd\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testFunFrom()", "name": "testFunFrom", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFunFrom()", "original_string": "  @Test void testFunFrom() {\n    final String ml = \"let\\n\"\n        + \"  fun query emp =\\n\"\n        + \"    from e in emp\\n\"\n        + \"    yield {e.deptno,e.empno,e.ename}\\n\"\n        + \"in\\n\"\n        + \"  query scott.emp\\n\"\n        + \"end\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{deptno:int, empno:int, ename:string} list\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testToCoreAndBack()", "name": "testToCoreAndBack", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testToCoreAndBack()", "original_string": "  @Test void testToCoreAndBack() {\n    final String[] expressions = {\n        \"()\", null,\n        \"true andalso not false\", null,\n        \"true orelse false\", null,\n        \"1\", null,\n        \"[1, 2]\", null,\n        \"1 :: 2 :: []\", null,\n        \"1 + ~2\", null,\n        \"(\\\"hello\\\", 2, 3)\", null,\n        \"String.substring (\\\"hello\\\", 2, 3)\",\n        \"#substring String (\\\"hello\\\", 2, 3)\",\n        \"substring (\\\"hello\\\", 4, 1)\",\n        \"#substring String (\\\"hello\\\", 4, 1)\",\n        \"{a = 1, b = true, c = \\\"d\\\"}\", null,\n        \"fn x => 1 + x + 3\", null,\n        \"List.tabulate (6, fn i =>\"\n            + \" {i, j = i + 3, s = substring (\\\"morel\\\", 0, i)})\",\n        \"#tabulate List (6, fn i =>\"\n            + \" {i = i, j = i + 3, s = #substring String (\\\"morel\\\", 0, i)})\",\n    };\n    for (int i = 0; i < expressions.length / 2; i++) {\n      String ml = expressions[i * 2];\n      String expected = \"val it = \" + Util.first(expressions[i  * 2 + 1], ml);\n      ml(ml).assertCore(-1, hasToString(expected));\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[void]testError()", "name": "testError", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testError()", "original_string": "  @Test void testError() {\n    ml(\"fn x y => x + y\")\n        .assertError(\n            \"Error: non-constructor applied to argument in pattern: x\");\n    ml(\"- case {a=1,b=2,c=3} of {a=x,b=y} => x + y\")\n        .assertError(\"Error: case object and rules do not agree [tycon \"\n            + \"mismatch]\\n\"\n            + \"  rule domain: {a:[+ ty], b:[+ ty]}\\n\"\n            + \"  object: {a:[int ty], b:[int ty], c:[int ty]}\\n\"\n            + \"  in expression:\\n\"\n            + \"    (case {a=1,b=2,c=3}\\n\"\n            + \"      of {a=x,b=y} => x + y)\\n\");\n    ml(\"fun f {a=x,b=y,...} = x+y\")\n        .assertError(\"Error: unresolved flex record (need to know the names of \"\n            + \"ALL the fields\\n\"\n            + \" in this context)\\n\"\n            + \"  type: {a:[+ ty], b:[+ ty]; 'Z}\\n\");\n    ml(\"fun f {a=x,...} = x | {b=y,...} = y;\")\n        .assertError(\"stdIn:1.24-1.33 Error: can't find function arguments in \"\n            + \"clause\\n\"\n            + \"stdIn:1.24-1.33 Error: illegal function symbol in clause\\n\"\n            + \"stdIn:1.6-1.37 Error: clauses do not all have same function \"\n            + \"name\\n\"\n            + \"stdIn:1.36 Error: unbound variable or constructor: y\\n\"\n            + \"stdIn:1.2-1.37 Error: unresolved flex record\\n\"\n            + \"   (can't tell what fields there are besides #a)\\n\");\n    ml(\"fun f {a=x,...} = x | f {b=y,...} = y\")\n        .assertError(\"Error: unresolved flex record (need to know the names of \"\n            + \"ALL the fields\\n\"\n            + \" in this context)\\n\"\n            + \"  type: {a:'Y, b:'Y; 'Z}\\n\");\n    ml(\"fun f {a=x,...} = x\\n\"\n        + \"  | f {b=y,...} = y\\n\"\n        + \"  | f {a=x,b=y,c=z} = x+y+z\")\n        .assertError(\"stdIn:1.6-3.20 Error: match redundant\\n\"\n            + \"          {a=x,b=_,c=_} => ...\\n\"\n            + \"    -->   {a=_,b=y,c=_} => ...\\n\"\n            + \"    -->   {a=x,b=y,c=z} => ...\\n\");\n    ml(\"fun f 1 = 1 | f n = n * f (n - 1) | g 2 = 2\")\n        .assertError(\"stdIn:3.5-3.46 Error: clauses don't all have same \"\n            + \"function name\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/MainTest.java", "class_name": "MainTest", "class_uri": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testAnalyze()", "name": "testAnalyze", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testAnalyze()", "original_string": "  @Test void testAnalyze() {\n    final String ml = \"let\\n\"\n        + \"  val aUnused = 0\\n\"\n        + \"  val bOnce = 1 + 1\\n\"\n        + \"  val cOnce = 2 + 2\\n\"\n        + \"  val dOnce = 3 + 3\\n\"\n        + \"  val eTwice = bOnce + cOnce\\n\"\n        + \"  val fMultiSafe = dOnce + 4\\n\"\n        + \"  val gAtomic = 5\\n\"\n        + \"  val x = [1, 2]\\n\"\n        + \"  val z = case x of\\n\"\n        + \"     []            => fMultiSafe + gAtomic\\n\"\n        + \"   | 1 :: x2 :: x3 => 2\\n\"\n        + \"   | x0 :: xs      => fMultiSafe + x0 + gAtomic\\n\"\n        + \"in\\n\"\n        + \"  eTwice + eTwice\\n\"\n        + \"end\";\n    final String map = \"{aUnused=DEAD, bOnce=ONCE_SAFE, cOnce=ONCE_SAFE, \"\n        + \"dOnce=ONCE_SAFE, eTwice=MULTI_UNSAFE, fMultiSafe=MULTI_SAFE, \"\n        + \"gAtomic=ATOMIC, it=MULTI_UNSAFE, op +=MULTI_UNSAFE, \"\n        + \"x=ONCE_SAFE, x0=ONCE_SAFE, x2=DEAD, x3=DEAD, xs=DEAD, z=DEAD}\";\n    ml(ml)\n        .assertAnalyze(hasToString(map));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testInline()", "name": "testInline", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testInline()", "original_string": "  @Test void testInline() {\n    final String ml = \"fun f x = let val y = x + 1 in y + 2 end\";\n    final String plan = \"match(x, apply2(fnValue +, \"\n        + \"apply2(fnValue +, get(name x), constant(1)), \"\n        + \"constant(2)))\";\n    ml(ml).assertPlan(isCode(plan));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testInlineFn()", "name": "testInlineFn", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testInlineFn()", "original_string": "  @Test void testInlineFn() {\n    final String ml = \"fun f x =\\n\"\n        + \"  let\\n\"\n        + \"    val succ = fn y => y + 1\\n\"\n        + \"  in\\n\"\n        + \"    succ x\\n\"\n        + \"  end\";\n    final String plan =\n        \"match(x, apply2(fnValue +, get(name x), constant(1)))\";\n    ml(ml).assertPlan(isCode(plan))\n        .assertEval(whenAppliedTo(2, is(3)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testInlineFnUnit()", "name": "testInlineFnUnit", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testInlineFnUnit()", "original_string": "  @Test void testInlineFnUnit() {\n    final String ml = \"fun f () = String.size \\\"abc\\\"\";\n    final String core = \"val f = fn v0 => #size String \\\"abc\\\"\";\n    ml(ml)\n        .assertEval(whenAppliedTo(list(), is(3)))\n        .assertCore(2, hasToString(core));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testLetAtomic()", "name": "testLetAtomic", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testLetAtomic()", "original_string": "  @Test void testLetAtomic() {\n    final String ml = \"fun f x =\\n\"\n        + \"  let\\n\"\n        + \"    val y = x\\n\"\n        + \"  in\\n\"\n        + \"    y + 1 + y\\n\"\n        + \"  end\";\n    final String core = \"val f = fn x => x + 1 + x\";\n    ml(ml)\n        .assertEval(whenAppliedTo(2, is(5))).assertCore(2, hasToString(core));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " We inline a variable (y), even though it is used twice, because its\nvalue is atomic (x)."}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testInlineChained()", "name": "testInlineChained", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testInlineChained()", "original_string": "  @Test void testInlineChained() {\n    // Generate code \"fun f x0 = x0 + 1\";\n    // calling \"f 0\" yields value 1.\n    checkInlineChained(1);\n\n    // Generate code \"fun f x0 =\n    //   let val x1 = x0 + 1\n    //   in x1 + 2\n    //   end\";\n    // calling \"f 0\" yields value 1 + 2 = 3.\n    checkInlineChained(2);\n\n    // Generate code \"fun f x0 = ... in x2 + 3 ... end\";\n    // calling \"f 0\" yields value 1 + 2 + 3 = 6.\n    checkInlineChained(3);\n\n    // If inlining algorithm is exponential, this one will be super-slow.\n    checkInlineChained(200);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testFromPredicate()", "name": "testFromPredicate", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromPredicate()", "original_string": "  @Test void testFromPredicate() {\n    final String ml = \"let\\n\"\n        + \"  fun isEven n = n mod 2 = 0\\n\"\n        + \"in\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where isEven e.empno\\n\"\n        + \"  yield e.deptno\\n\"\n        + \"end\";\n    final String core0 = \"val it = \"\n        + \"let \"\n        + \"val isEven = fn n => n mod 2 = 0 \"\n        + \"in \"\n        + \"from e in #emp scott \"\n        + \"where isEven (#empno e) yield #deptno e end\";\n    final String core1 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"where let val n = #empno e in op mod (n, 2) = 0 end yield #deptno e\";\n    final String core2 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"where op mod (#empno e, 2) = 0 yield #deptno e\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core2))\n        .assertEval(is(list(20, 30, 30, 10, 20, 30, 20, 30, 20, 10)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that a predicate is inlined inside {@code where}."}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testFromView()", "name": "testFromView", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromView()", "original_string": "  @Test void testFromView() {\n    final String ml = \"let\\n\"\n        + \"  fun evenEmp x =\\n\"\n        + \"    from e in scott.emp\\n\"\n        + \"    where e.empno mod 2 = 0\\n\"\n        + \"in\\n\"\n        + \"  from e in (evenEmp 1)\\n\"\n        + \"  where e.deptno = 10\\n\"\n        + \"  yield e.ename\\n\"\n        + \"end\";\n    final String core0 = \"val it = \"\n        + \"let\"\n        + \" val evenEmp = fn x =>\"\n        + \" from e in #emp scott\"\n        + \" where #empno e mod 2 = 0 \"\n        + \"in\"\n        + \" from e_1 in evenEmp 1\"\n        + \" where #deptno e_1 = 10\"\n        + \" yield #ename e_1 \"\n        + \"end\";\n    final String core1 = \"val it = \"\n        + \"from e_1 in \"\n        + \"(let val x = 1\"\n        + \" in from e in #emp scott\"\n        + \" where op mod (#empno e, 2) = 0 \"\n        + \"end)\"\n        + \" where #deptno e_1 = 10\"\n        + \" yield #ename e_1\";\n    final String core2 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"where op mod (#empno e, 2) = 0 \"\n        + \"yield {e = e} \"\n        + \"where #deptno e_1 = 10 \"\n        + \"yield #ename e_1\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core2))\n        .assertEval(isUnordered(list(\"CLARK\", \"MILLER\")));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that a predicate is inlined inside {@code where}."}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testMapFilterToFrom()", "name": "testMapFilterToFrom", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testMapFilterToFrom()", "original_string": "  @Test void testMapFilterToFrom() {\n    final String ml = \"map (fn e => (#empno e))\\n\"\n        + \"  (List.filter (fn e => (#deptno e) = 30) (#emp scott))\";\n    final String core0 = \"val it = \"\n        + \"map (fn e_1 => #empno e_1) \"\n        + \"(#filter List (fn e => #deptno e = 30) \"\n        + \"(#emp scott))\";\n    final String core1 = \"val it = \"\n        + \"from v0 in \"\n        + \"#filter List (fn e => #deptno e = 30) (#emp scott) \"\n        + \"yield (fn e_1 => #empno e_1) v0\";\n    final String core2 = \"val it = \"\n        + \"from v2 in #emp scott \"\n        + \"where #deptno v2 = 30 \"\n        + \"yield {v0 = v2} \"\n        + \"yield #empno v0\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core2))\n        .assertEval(isUnordered(list(7499, 7521, 7654, 7698, 7844, 7900)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that an expression involving 'map' and 'filter'\nis converted to a 'from' expression."}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testFilterMapFilterMapToFrom()", "name": "testFilterMapFilterMapToFrom", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFilterMapFilterMapToFrom()", "original_string": "  @Test void testFilterMapFilterMapToFrom() {\n    final String ml = \"\"\n        + \"map (fn r => r + 100)\\n\"\n        + \"  (map (fn r => #x r + #z r)\\n\"\n        + \"    (List.filter (fn r => #y r > #z r)\\n\"\n        + \"      (map (fn e => {x = #empno e, y = #deptno e, z = 15})\\n\"\n        + \"        (List.filter (fn e => #deptno e = 30)\\n\"\n        + \"          (#emp scott)))))\";\n    final String core0 = \"val it = \"\n        + \"map (fn r_2 => r_2 + 100)\"\n        + \" (map (fn r_1 => #x r_1 + #z r_1)\"\n        + \" (#filter List (fn r => #y r > #z r)\"\n        + \" (map (fn e_1 => {x = #empno e_1, y = #deptno e_1, z = 15})\"\n        + \" (#filter List (fn e => #deptno e = 30) (#emp scott)))))\";\n    final String core1 = \"val it = \"\n        + \"from v0 in #map List (fn r_1 => #x r_1 + #z r_1)\"\n        + \" (#filter List (fn r => #y r > #z r)\"\n        + \" (#map List (fn e_1 => {x = #empno e_1, y = #deptno e_1, z = 15})\"\n        + \" (#filter List (fn e => #deptno e = 30) (#emp scott)))) \"\n        + \"yield (fn r_2 => r_2 + 100) v0\";\n    final String core2 = \"val it = \"\n        + \"from v6 in #emp scott \"\n        + \"where #deptno v6 = 30 \"\n        + \"yield {v5 = v6} \"\n        + \"yield {v4 = {x = #empno v5, y = #deptno v5, z = 15}} \"\n        + \"where #y v4 > #z v4 \"\n        + \"yield {v2 = v4} \"\n        + \"yield {v0 = #x v2 + #z v2} \"\n        + \"yield v0 + 100\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core2))\n        .assertEval(isUnordered(list(7614, 7636, 7769, 7813, 7959, 8015)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that an expression involving 'filter' then 'map' then 'filter' then\n'map' is converted to a 'from' expression."}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testFromFrom()", "name": "testFromFrom", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromFrom()", "original_string": "  @Test void testFromFrom() {\n    final String ml = \"from i in (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  yield e.deptno)\\n\"\n        + \"where i > 10\\n\"\n        + \"yield i / 10\";\n    final String core0 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"yield {i = #deptno e} \"\n        + \"where i > 10 \"\n        + \"yield i / 10\";\n    final String core1 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"yield {i = #deptno e} \"\n        + \"where i > 10 \"\n        + \"yield /:int (i, 10)\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core1))\n        .assertEval(isUnordered(list(2, 3, 3, 2, 3, 3, 2, 3, 2, 3, 2)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testFromEmptyFrom()", "name": "testFromEmptyFrom", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFromEmptyFrom()", "original_string": "  @Test void testFromEmptyFrom() {\n    final String ml = \"from u in (from)\\n\"\n        + \"where 3 < 4\\n\"\n        + \"yield {u, v = 10}\";\n    final String core0 = \"val it = \"\n        + \"from u in (from) \"\n        + \"where 3 < 4 \"\n        + \"yield {u = u, v = 10}\";\n    final String core1 = \"val it = \"\n        + \"from \"\n        + \"yield {u = ()} \"\n        + \"where 3 < 4 \"\n        + \"yield {u = u, v = 10}\";\n    ml(ml)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core1))\n        .assertEval(isUnordered(list(list(Unit.INSTANCE, 10))));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testInlineCase()", "name": "testInlineCase", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testInlineCase()", "original_string": "  @Test void testInlineCase() {\n    final String ml = \"let\\n\"\n        + \"  val f = fn x => case x of y => y + 2\\n\"\n        + \"in\\n\"\n        + \"  f 3\\n\"\n        + \"end\";\n    ml(ml)\n        .assertCore(0,\n            hasToString(\"val it = \"\n                + \"let val f = fn x => case x of y => y + 2 in f 3 end\"))\n        .assertCore(2, hasToString(\"val it = let val x = 3 in x + 2 end\"))\n        .assertEval(is(5));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that a singleton {@code case} is inlined."}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]testInlineCase2()", "name": "testInlineCase2", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testInlineCase2()", "original_string": "  @Test void testInlineCase2() {\n    final String ml = \"let\\n\"\n        + \"  val f = fn (x, y) => case (x, y) of (x1, y1) => x1 - y1\\n\"\n        + \"in\\n\"\n        + \"  f (13, 5)\\n\"\n        + \"end\";\n    ml(ml)\n        .assertCore(0,\n            hasToString(\"val it = \"\n                + \"let\"\n                + \" val f = fn v0 => \"\n                + \"case v0 of (x, y) => \"\n                + \"case (x, y) of (x1, y1) => x1 - y1 \"\n                + \"in\"\n                + \" f (13, 5) \"\n                + \"end\"))\n        .assertCore(2,\n            hasToString(\"val it = \"\n                + \"let val v0 = (13, 5) \"\n                + \"in case v0 of (x, y) => -:int (x, y) \"\n                + \"end\"))\n        .assertEval(is(8));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/InlineTest.java", "class_name": "InlineTest", "class_uri": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that a singleton {@code case} is inlined."}, {"uris": "src/test/java/net/hydromatic/morel/SatTest.java.SatTest.[void]testBuild()", "name": "testBuild", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testBuild()", "original_string": "  @Test void testBuild() {\n    final Sat sat = new Sat();\n    final Variable x = sat.variable(\"x\");\n    final Variable y = sat.variable(\"y\");\n\n    // (x \u2228 x \u2228 y) \u2227 (\u00acx \u2228 \u00acy \u2228 \u00acy) \u2227 (\u00acx \u2228 y \u2228 y)\n    final Term clause0 = sat.or(x, x, y);\n    final Term clause1 = sat.or(sat.not(x), sat.not(y), sat.not(y));\n    final Term clause2 = sat.or(sat.not(x), y, y);\n    final Term formula = sat.and(clause0, clause1, clause2);\n    assertThat(formula.toString(),\n        is(\"(x \u2228 x \u2228 y) \u2227 (\u00acx \u2228 \u00acy \u2228 \u00acy) \u2227 (\u00acx \u2228 y \u2228 y)\"));\n\n    final Map<Variable, Boolean> solution = sat.solve(formula);\n    assertThat(solution, notNullValue());\n    assertThat(solution,\n        is(ImmutableMap.of(x, false, y, true)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/SatTest.java", "class_name": "SatTest", "class_uri": "src/test/java/net/hydromatic/morel/SatTest.java.SatTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a formula with three clauses, three terms each.\nIt is in \"3SAT\" form, and has a solution (i.e. is satisfiable)."}, {"uris": "src/test/java/net/hydromatic/morel/SatTest.java.SatTest.[void]testTrue()", "name": "testTrue", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTrue()", "original_string": "  @Test void testTrue() {\n    final Sat sat = new Sat();\n    final Term trueTerm = sat.and();\n    assertThat(trueTerm, hasToString(\"true\"));\n\n    final Map<Variable, Boolean> solve = sat.solve(trueTerm);\n    assertThat(\"satisfiable\", solve, notNullValue());\n    assertThat(solve.isEmpty(), is(true));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/SatTest.java", "class_name": "SatTest", "class_uri": "src/test/java/net/hydromatic/morel/SatTest.java.SatTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests true (\"and\" with zero arguments)."}, {"uris": "src/test/java/net/hydromatic/morel/SatTest.java.SatTest.[void]testFalse()", "name": "testFalse", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFalse()", "original_string": "  @Test void testFalse() {\n    final Sat sat = new Sat();\n    final Term falseTerm = sat.or();\n    assertThat(falseTerm, hasToString(\"false\"));\n\n    final Map<Variable, Boolean> solve = sat.solve(falseTerm);\n    assertThat(\"not satisfiable\", solve, nullValue());\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/SatTest.java", "class_name": "SatTest", "class_uri": "src/test/java/net/hydromatic/morel/SatTest.java.SatTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests false (\"or\" with zero arguments)."}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[void]testPairList()", "name": "testPairList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testPairList()", "original_string": "  @Test void testPairList() {\n    final PairList<Integer, String> pairList = PairList.of();\n    final List<Map.Entry<Integer, String>> list = new ArrayList<>();\n\n    validate(pairList, list);\n\n    // add(T, U)\n    pairList.add(1, \"a\");\n    list.add(Pair.of(1, \"a\"));\n    validate(pairList, list);\n\n    // add(Pair<T, U>)\n    pairList.add(Pair.of(2, \"b\"));\n    list.add(Pair.of(2, \"b\"));\n    validate(pairList, list);\n\n    // add(T, U)\n    pairList.add(2, \"bb\");\n    list.add(Pair.of(2, \"bb\"));\n    validate(pairList, list);\n\n    // add(int, Pair<T, U>)\n    pairList.add(0, Pair.of(3, \"c\"));\n    list.add(0, Pair.of(3, \"c\"));\n    validate(pairList, list);\n\n    // add(int, T, U)\n    pairList.add(0, 4, \"d\");\n    list.add(0, Pair.of(4, \"d\"));\n    validate(pairList, list);\n\n    // remove(int)\n    Map.Entry<Integer, String> x = pairList.remove(1);\n    Map.Entry<Integer, String> y = list.remove(1);\n    assertThat(x, is(y));\n    validate(pairList, list);\n\n    // clear()\n    pairList.clear();\n    list.clear();\n    validate(pairList, list);\n\n    // clear() again\n    pairList.clear();\n    list.clear();\n    validate(pairList, list);\n\n    // add(T, U) having called clear\n    pairList.add(-1, \"c\");\n    list.add(Pair.of(-1, \"c\"));\n    validate(pairList, list);\n\n    // addAll(PairList)\n    final PairList<Integer, String> pairList8 = PairList.copyOf(8, \"x\", 7, \"y\");\n    pairList.addAll(pairList8);\n    list.addAll(pairList8);\n    validate(pairList, list);\n\n    // addAll(int, PairList)\n    pairList.addAll(3, pairList8);\n    list.addAll(3, pairList8);\n    validate(pairList, list);\n\n    PairList<Integer, String> immutablePairList = pairList.immutable();\n    assertThrows(UnsupportedOperationException.class, () ->\n        immutablePairList.add(0, \"\"));\n    validate(immutablePairList, list);\n\n    // set(int, Pair<T, U>)\n    pairList.set(2, 0, \"p\");\n    list.set(2, Pair.of(0, \"p\"));\n    validate(pairList, list);\n\n    // set(int, T, U)\n    pairList.set(1, Pair.of(88, \"q\"));\n    list.set(1, Pair.of(88, \"q\"));\n    validate(pairList, list);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Basic test for {@link PairList}."}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[void]testAddAll()", "name": "testAddAll", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testAddAll()", "original_string": "  @Test void testAddAll() {\n    PairList<String, Integer> pairList = PairList.of();\n\n    // MutablePairList (0 entries)\n    pairList.addAll(PairList.of());\n    assertThat(pairList, hasSize(0));\n\n    // MutablePairList (1 entry)\n    pairList.addAll(PairList.of(\"a\", 1));\n    assertThat(pairList, hasSize(1));\n\n    // MutablePairList (2 entries)\n    pairList.addAll(PairList.of(ImmutableMap.of(\"b\", 2, \"c\", 3)));\n    assertThat(pairList, hasSize(3));\n\n    // EmptyImmutablePairList\n    pairList.addAll(ImmutablePairList.of());\n    assertThat(pairList, hasSize(3));\n\n    // ImmutableList (0 entries)\n    pairList.addAll(ImmutableList.of());\n    assertThat(pairList, hasSize(3));\n\n    // SingletonImmutablePairList\n    pairList.addAll(ImmutablePairList.of(\"d\", 4));\n    assertThat(pairList, hasSize(4));\n\n    // ImmutableList (1 entry)\n    pairList.addAll(ImmutableList.of(new MapEntry<>(\"e\", 5)));\n    assertThat(pairList, hasSize(5));\n\n    // MutablePairList (2 entries)\n    pairList.addAll(PairList.copyOf(\"f\", 6, \"g\", 7));\n    assertThat(pairList, hasSize(7));\n\n    // ArrayImmutablePairList (2 entries, created from MutablePairList)\n    pairList.addAll(PairList.copyOf(\"h\", 8, \"i\", 9).immutable());\n    assertThat(pairList, hasSize(9));\n\n    // ArrayImmutablePairList (3 entries, created using copyOf)\n    pairList.addAll(ImmutablePairList.copyOf(\"j\", 10, \"k\", 11, \"l\", 12));\n    assertThat(pairList, hasSize(12));\n\n    // ArrayImmutablePairList (2 entries, created using copyOf)\n    pairList.addAll(ImmutablePairList.copyOf(\"m\", 13, \"n\", 14));\n    assertThat(pairList, hasSize(14));\n\n    // ArrayImmutablePairList (1 entry, created using copyOf)\n    pairList.addAll(ImmutablePairList.copyOf(\"o\", 15));\n    assertThat(pairList, hasSize(15));\n\n    assertThat(pairList,\n        hasToString(\"[<a, 1>, <b, 2>, <c, 3>, <d, 4>, <e, 5>, <f, 6>, \"\n            + \"<g, 7>, <h, 8>, <i, 9>, <j, 10>, <k, 11>, <l, 12>, \"\n            + \"<m, 13>, <n, 14>, <o, 15>]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[void]testPairListOfMap()", "name": "testPairListOfMap", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testPairListOfMap()", "original_string": "  @Test void testPairListOfMap() {\n    final ImmutableMap<String, Integer> map = ImmutableMap.of(\"a\", 1, \"b\", 2);\n    final PairList<String, Integer> pairList = PairList.of(map);\n    assertThat(pairList, hasSize(2));\n    assertThat(pairList, hasToString(\"[<a, 1>, <b, 2>]\"));\n\n    final List<Map.Entry<String, Integer>> list = new ArrayList<>(map.entrySet());\n    validate(pairList, list);\n\n    final ImmutableMap<String, Integer> map2 = pairList.toImmutableMap();\n    assertThat(map2, is(map));\n\n    // After calling toImmutableMap, you can modify the list and call\n    // toImmutableMap again.\n    pairList.add(\"c\", 3);\n    list.add(Pair.of(\"c\", 3));\n    validate(pairList, list);\n    assertThat(pairList, hasToString(\"[<a, 1>, <b, 2>, <c, 3>]\"));\n    final ImmutableMap<String, Integer> map3 = pairList.toImmutableMap();\n    assertThat(map3, hasToString(\"{a=1, b=2, c=3}\"));\n\n    final Map<String, Integer> emptyMap = ImmutableMap.of();\n    final PairList<String, Integer> emptyPairList = PairList.of(emptyMap);\n    assertThat(emptyPairList.isEmpty(), is(true));\n    validate(emptyPairList, Collections.emptyList());\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link PairList#of(Map)} and {@link PairList#toImmutableMap()}."}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[void]testPairListWithCapacity()", "name": "testPairListWithCapacity", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testPairListWithCapacity()", "original_string": "  @Test void testPairListWithCapacity() {\n    final PairList<String, Integer> list = PairList.withCapacity(100);\n    assertThat(list, hasSize(0));\n    assertThat(list, empty());\n    assertThat(list, hasToString(\"[]\"));\n\n    list.add(\"a\", 1);\n    list.add(\"b\", 2);\n    assertThat(list, hasSize(2));\n    assertThat(list, hasToString(\"[<a, 1>, <b, 2>]\"));\n\n    final Map.Entry<String, Integer> entry = list.remove(0);\n    assertThat(entry.getKey(), is(\"a\"));\n    assertThat(entry.getValue(), is(1));\n    assertThat(list, hasToString(\"[<b, 2>]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests {@link PairList#withCapacity(int)}."}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[void]testPairListOf()", "name": "testPairListOf", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testPairListOf()", "original_string": "  @Test void testPairListOf() {\n    final PairList<String, Integer> list0 = PairList.of();\n    assertThat(list0, hasSize(0));\n    assertThat(list0, empty());\n    assertThat(list0, hasToString(\"[]\"));\n\n    final PairList<String, Integer> list1 = PairList.of(\"a\", 1);\n    assertThat(list1, hasSize(1));\n    assertThat(list1, hasToString(\"[<a, 1>]\"));\n\n    final PairList<String, Integer> list3 =\n        PairList.copyOf(\"a\", 1, \"b\", null, \"c\", 3);\n    assertThat(list3, hasSize(3));\n    assertThat(list3, hasToString(\"[<a, 1>, <b, null>, <c, 3>]\"));\n\n    assertThrows(IllegalArgumentException.class,\n        () -> PairList.copyOf(\"a\", 1, \"b\", 2, \"c\"),\n        \"odd number of arguments\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[void]testTransform()", "name": "testTransform", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testTransform()", "original_string": "  @Test void testTransform() {\n    final PairList<String, Integer> mutableList3 =\n        PairList.copyOf(\"a\", 1, null, 5, \"c\", 3);\n    final PairList<String, Integer> immutableList3 =\n        PairList.copyOf(\"a\", 1, \"null\", 5, \"c\", 3);\n\n    final PairList<String, Integer> mutableList0 = PairList.of();\n\n    final PairList<String, Integer> mutableList1 = PairList.of(\"a\", 1);\n    final PairList<String, Integer> doubleList1 =\n        ImmutablePairList.copyOf(\"a\", 1, \"a\", 1);\n\n    for (boolean mutable : new boolean[] {false, true}) {\n      PairList<String, Integer> list0 =\n          mutable ? mutableList0 : mutableList0.immutable();\n      PairList<String, Integer> list1 =\n          mutable ? mutableList1 : mutableList1.immutable();\n      PairList<String, Integer> list3 =\n          mutable ? mutableList3 : immutableList3;\n\n      assertThat(list0.transform((s, i) -> s + i), empty());\n\n      assertThat(list1.transform((s, i) -> s + i), is(ImmutableList.of(\"a1\")));\n\n      assertThat(list3.transform((s, i) -> s + i),\n          is(Arrays.asList(\"a1\", \"null5\", \"c3\")));\n      assertThat(list3.transform2((s, i) -> s + i),\n          is(Arrays.asList(\"a1\", \"null5\", \"c3\")));\n\n      final BiPredicate<String, Integer> gt2 = (s, i) -> i > 2;\n      assertThat(list3.anyMatch(gt2), is(true));\n      assertThat(list3.allMatch(gt2), is(false));\n      assertThat(list3.noMatch(gt2), is(false));\n      assertThat(list3.firstMatch(gt2), is(1));\n\n      final BiPredicate<String, Integer> negative = (s, i) -> i < 0;\n      assertThat(list3.anyMatch(negative), is(false));\n      assertThat(list3.allMatch(negative), is(false));\n      assertThat(list3.noMatch(negative), is(true));\n      assertThat(list3.firstMatch(negative), is(-1));\n\n      final BiPredicate<String, Integer> positive = (s, i) -> i > 0;\n      assertThat(list3.anyMatch(positive), is(true));\n      assertThat(list3.allMatch(positive), is(true));\n      assertThat(list3.noMatch(positive), is(false));\n      assertThat(list3.firstMatch(positive), is(0));\n\n      final BiPredicate<String, Integer> isNull = (s, i) -> s == null;\n      if (mutable) {\n        assertThat(list3.anyMatch(isNull), is(true));\n        assertThat(list3.allMatch(isNull), is(false));\n        assertThat(list3.noMatch(isNull), is(false));\n        assertThat(list3.firstMatch(isNull), is(1));\n      } else {\n        // In the immutable version, null has been replaced with \"null\"\n        assertThat(list3.anyMatch(isNull), is(false));\n        assertThat(list3.allMatch(isNull), is(false));\n        assertThat(list3.noMatch(isNull), is(true));\n        assertThat(list3.firstMatch(isNull), is(-1));\n      }\n\n      // All predicates behave the same on the empty list\n      Arrays.asList(gt2, negative, positive, isNull).forEach(p -> {\n        assertThat(list0.anyMatch(p), is(false));\n        assertThat(list0.allMatch(p), is(true)); // trivially\n        assertThat(list0.noMatch(p), is(true));\n        assertThat(list0.firstMatch(p), is(-1));\n      });\n\n      // All predicates on the 1-element list have the same answer as the same\n      // predicate on the 2-element list that is the 1-element list doubled.\n      Arrays.asList(gt2, negative, positive, isNull).forEach(p -> {\n        assertThat(list1.anyMatch(p), is(doubleList1.anyMatch(p)));\n        assertThat(list1.allMatch(p), is(doubleList1.anyMatch(p)));\n        assertThat(list1.noMatch(p), is(doubleList1.noMatch(p)));\n        assertThat(list1.firstMatch(p), is(doubleList1.firstMatch(p)));\n      });\n    }\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[void]testBuilder()", "name": "testBuilder", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testBuilder()", "original_string": "  @Test void testBuilder() {\n    final PairList.Builder<String, Integer> b = PairList.builder();\n    final List<Pair<String, Integer>> list = new ArrayList<>();\n\n    final PairList<String, Integer> list0 = b.build();\n    validate(list0, list);\n\n    b.add(\"a\", 1);\n    list.add(Pair.of(\"a\", 1));\n    final PairList<String, Integer> list1 = b.build();\n    validate(list1, list);\n\n    b.add(\"b\", 2);\n    b.add(\"c\", null);\n    list.add(Pair.of(\"b\", 2));\n    list.add(Pair.of(\"c\", null));\n    final PairList<String, Integer> list3 = b.build();\n    validate(list3, list);\n\n    // Singleton list with null key\n    final PairList.Builder<String, Integer> b2 = PairList.builder();\n    list.clear();\n    b2.add(null, 5);\n    list.add(Pair.of(null, 5));\n    validate(b2.build(), list);\n\n    // Singleton list with null value\n    final PairList.Builder<String, Integer> b3 = PairList.builder();\n    list.clear();\n    b3.add(\"x\", null);\n    list.add(Pair.of(\"x\", null));\n    validate(b3.build(), list);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/PairListTest.java", "class_name": "PairListTest", "class_uri": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ast/Pos_splitTest.java.Pos_splitTest.[void]testSplit_ValidInput()", "name": "testSplit_ValidInput", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSplit_ValidInput()", "original_string": "    @Test\n    public void testSplit_ValidInput() {\n        String input = \"a,b,c\";\n        char delimiter = ',';\n        String file = \"testFile\";\n\n        Pair<String, Pos> result = Pos.split(input, delimiter, file);\n\n        assertEquals(\"abc\", result.left);\n        assertEquals(file, result.right.file);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ast/Pos_splitTest.java", "class_name": "Pos_splitTest", "class_uri": "src/test/java/net/hydromatic/morel/ast/Pos_splitTest.java.Pos_splitTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ast/Pos_splitTest.java.Pos_splitTest.[void]testSplit_InvalidInput()", "name": "testSplit_InvalidInput", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testSplit_InvalidInput()", "original_string": "    @Test\n    public void testSplit_InvalidInput() {\n        String input = \"a,b,c,d\";\n        char delimiter = ',';\n        String file = \"testFile\";\n\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            Pos.split(input, delimiter, file);\n        });\n\n        assertEquals(\"expected exactly two occurrences of delimiter, ','\", exception.getMessage());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ast/Pos_splitTest.java", "class_name": "Pos_splitTest", "class_uri": "src/test/java/net/hydromatic/morel/ast/Pos_splitTest.java.Pos_splitTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ast/Pos_equalsTest.java.Pos_equalsTest.[void]testEquals()", "name": "testEquals", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testEquals()", "original_string": "    @Test\n    void testEquals() {\n        Pos pos1 = new Pos(\"file1\", 1, 2, 3, 4);\n        Pos pos2 = new Pos(\"file1\", 1, 2, 3, 4);\n        Pos pos3 = new Pos(\"file2\", 5, 6, 7, 8);\n\n        // Test same object\n        assertTrue(pos1.equals(pos1));\n\n        // Test equal objects\n        assertTrue(pos1.equals(pos2));\n        assertTrue(pos2.equals(pos1));\n\n        // Test different objects\n        assertFalse(pos1.equals(pos3));\n        assertFalse(pos3.equals(pos1));\n\n        // Test null\n        assertFalse(pos1.equals(null));\n\n        // Test different class\n        assertFalse(pos1.equals(\"not a Pos object\"));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ast/Pos_equalsTest.java", "class_name": "Pos_equalsTest", "class_uri": "src/test/java/net/hydromatic/morel/ast/Pos_equalsTest.java.Pos_equalsTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/ast/Pos_plusTest.java.Pos_plusTest.[void]testPlus()", "name": "testPlus", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testPlus()", "original_string": "    @Test\n    void testPlus() {\n        Pos pos1 = new Pos(\"file1\", 1, 2, 3, 4);\n        Pos pos2 = new Pos(\"file1\", 0, 1, 5, 6);\n\n        Pos result = pos1.plus(pos2);\n\n        assertEquals(\"file1\", result.file);\n        assertEquals(0, result.startLine);\n        assertEquals(1, result.startColumn);\n        assertEquals(5, result.endLine);\n        assertEquals(6, result.endColumn);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/ast/Pos_plusTest.java", "class_name": "Pos_plusTest", "class_uri": "src/test/java/net/hydromatic/morel/ast/Pos_plusTest.java.Pos_plusTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java.Extents_unionTest.[void]testUnionWithEmptyList()", "name": "testUnionWithEmptyList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testUnionWithEmptyList()", "original_string": "    @Test\n    public void testUnionWithEmptyList() {\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList();\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.union(rangeSetMaps);\n        assertEquals(ImmutableMap.of(\"/\", ImmutableRangeSet.of()), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java", "class_name": "Extents_unionTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java.Extents_unionTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java.Extents_unionTest.[void]testUnionWithSingleMap()", "name": "testUnionWithSingleMap", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testUnionWithSingleMap()", "original_string": "    @Test\n    public void testUnionWithSingleMap() {\n        ImmutableRangeSet<Integer> rangeSet = ImmutableRangeSet.of();\n        Map<String, ImmutableRangeSet<Integer>> singleMap = ImmutableMap.of(\"/\", rangeSet);\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList(singleMap);\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.union(rangeSetMaps);\n        assertEquals(singleMap, result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java", "class_name": "Extents_unionTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java.Extents_unionTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java.Extents_unionTest.[void]testUnionWithMultipleMaps()", "name": "testUnionWithMultipleMaps", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testUnionWithMultipleMaps()", "original_string": "    @Test\n    public void testUnionWithMultipleMaps() {\n        ImmutableRangeSet<Integer> rangeSet1 = ImmutableRangeSet.of();\n        ImmutableRangeSet<Integer> rangeSet2 = ImmutableRangeSet.of();\n        Map<String, ImmutableRangeSet<Integer>> map1 = ImmutableMap.of(\"/\", rangeSet1);\n        Map<String, ImmutableRangeSet<Integer>> map2 = ImmutableMap.of(\"/\", rangeSet2);\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList(map1, map2);\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.union(rangeSetMaps);\n        assertEquals(ImmutableMap.of(\"/\", rangeSet1.union(rangeSet2)), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java", "class_name": "Extents_unionTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java.Extents_unionTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java.EnvironmentTest.[void]testOptimizeSubEnvironment()", "name": "testOptimizeSubEnvironment", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testOptimizeSubEnvironment()", "original_string": "  @Test void testOptimizeSubEnvironment() {\n    final Environment e0 = Environments.empty()\n        .bind(core.idPat(PrimitiveType.INT, \"a\", 0), 0)\n        .bind(core.idPat(PrimitiveType.INT, \"b\", 0), 1)\n        .bind(core.idPat(PrimitiveType.INT, \"c\", 0), 2);\n    assertThat(e0, instanceOf(Environments.SubEnvironment.class));\n    checkOptimizeSubEnvironment(e0);\n\n    final Environment e0a = e0.bindAll(e0.getValueMap().values());\n    assertThat(e0a, instanceOf(Environments.MapEnvironment.class));\n    checkOptimizeSubEnvironment(e0a);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java", "class_name": "EnvironmentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java.EnvironmentTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests that if you call {@link Environment#bind} twice with the same name,\nthe binding chain does not get longer."}, {"uris": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java.Extents_intersectTest.[void]testIntersect_EmptyList()", "name": "testIntersect_EmptyList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testIntersect_EmptyList()", "original_string": "    @Test\n    void testIntersect_EmptyList() {\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList();\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.intersect(rangeSetMaps);\n        assertEquals(ImmutableMap.of(), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java", "class_name": "Extents_intersectTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java.Extents_intersectTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java.Extents_intersectTest.[void]testIntersect_SingleMap()", "name": "testIntersect_SingleMap", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testIntersect_SingleMap()", "original_string": "    @Test\n    void testIntersect_SingleMap() {\n        ImmutableRangeSet<Integer> rangeSet = ImmutableRangeSet.of();\n        Map<String, ImmutableRangeSet<Integer>> singleMap = ImmutableMap.of(\"key\", rangeSet);\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList(singleMap);\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.intersect(rangeSetMaps);\n        assertEquals(singleMap, result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java", "class_name": "Extents_intersectTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java.Extents_intersectTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java.Extents_intersectTest.[void]testIntersect_MultipleMaps()", "name": "testIntersect_MultipleMaps", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testIntersect_MultipleMaps()", "original_string": "    @Test\n    void testIntersect_MultipleMaps() {\n        ImmutableRangeSet<Integer> rangeSet1 = ImmutableRangeSet.of();\n        ImmutableRangeSet<Integer> rangeSet2 = ImmutableRangeSet.of();\n        Map<String, ImmutableRangeSet<Integer>> map1 = ImmutableMap.of(\"key1\", rangeSet1);\n        Map<String, ImmutableRangeSet<Integer>> map2 = ImmutableMap.of(\"key2\", rangeSet2);\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList(map1, map2);\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.intersect(rangeSetMaps);\n        assertEquals(2, result.size());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java", "class_name": "Extents_intersectTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java.Extents_intersectTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest.[void]testConstant()", "name": "testConstant", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testConstant()", "original_string": "  @Test void testConstant() {\n    final Fixture f = new Fixture();\n    assertThat(\"1 is literal\",\n        core.intLiteral(BigDecimal.ONE).isConstant(), is(true));\n    assertThat(\"false is literal\",\n        core.boolLiteral(false).isConstant(), is(true));\n    assertThat(\"a is literal\",\n        core.charLiteral('a').isConstant(), is(true));\n    assertThat(\"3.14 is literal\",\n        core.realLiteral(3.14f).isConstant(), is(true));\n    assertThat(\"string is literal\",\n        core.stringLiteral(\"pi\").isConstant(), is(true));\n    assertThat(\"identifier is not literal\",\n        f.aId.isConstant(), is(false));\n    assertThat(\"list of constants is constant\",\n        f.list12.isConstant(), is(true));\n\n    assertThat(\"unit is constant\",\n        core.tuple(f.typeSystem, null, ImmutableList.of()).isConstant(),\n        is(true));\n\n    final PairList<String, Core.Exp> map =\n        PairList.copyOf(\"a\", f.intLiteral(1), \"b\",\n            core.boolLiteral(true));\n    assertThat(\"record of constants is constant\",\n        core.record(f.typeSystem, map).isConstant(), is(true));\n    final List<Core.Exp> list = map.rightList();\n    assertThat(\"tuple of constants is constant\",\n        core.tuple(f.typeSystem, null, list).isConstant(), is(true));\n\n    final PairList<String, Core.Exp> map2 =\n        PairList.copyOf(\"a\", f.intLiteral(1), \"b\", f.aId);\n    assertThat(\"record that contains an id is not constant\",\n        core.record(f.typeSystem, map2).isConstant(), is(false));\n    final List<Core.Exp> list2 = map2.rightList();\n    assertThat(\"tuple that contains an id is not constant\",\n        core.tuple(f.typeSystem, null, list2).isConstant(), is(false));\n\n    // TODO: check that zero-arg constructor (e.g. NIL) is constant\n    // TODO: check that one-arg constructor (e.g. CONS (1, [])) is constant\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java", "class_name": "ExtentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests whether an expression is constant.\n\n@see Core.Exp#isConstant()"}, {"uris": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest.[void]testEq()", "name": "testEq", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testEq()", "original_string": "  @Test void testEq() {\n    final Fixture f = new Fixture();\n\n    // pat = \"x\", exp = \"x = 10\", extent = \"[10]\"\n    Core.IdPat xPat = core.idPat(PrimitiveType.INT, \"x\", 0);\n    Core.Literal ten = f.intLiteral(10);\n    Core.Exp exp = core.equal(f.typeSystem, core.id(xPat), ten);\n    Core.Exp x = f.extent(xPat, exp);\n    assertThat(x, hasToString(\"[10]\"));\n\n    // pat = \"x\", exp = \"10 = x\", extent = \"[10]\"\n    Core.Exp exp2 = core.equal(f.typeSystem, ten, core.id(xPat));\n    Core.Exp x2 = f.extent(xPat, exp2);\n    assertThat(x2, hasToString(\"[10]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java", "class_name": "ExtentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": " Tests a variable assigned a single value."}, {"uris": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest.[void]testBetween()", "name": "testBetween", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testBetween()", "original_string": "  @Test void testBetween() {\n    // pat = \"x\", exp = \"x >= 3 andalso y = 20 andalso x < 10 andalso 5 <> x\",\n    // extent of x is \"extent [[3..5), (5..10)]\";\n    // extent of y is \"extent [20, 20]\";\n    final Fixture f = new Fixture();\n    Core.IdPat xPat = core.idPat(PrimitiveType.INT, \"x\", 0);\n    Core.IdPat yPat = core.idPat(PrimitiveType.INT, \"y\", 0);\n    Core.Literal three = f.intLiteral(3);\n    Core.Literal five = f.intLiteral(5);\n    Core.Literal ten = f.intLiteral(10);\n    Core.Literal twenty = f.intLiteral(20);\n    Core.Exp exp0 = core.greaterThanOrEqualTo(f.typeSystem, core.id(xPat), three);\n    Core.Exp exp1 = core.equal(f.typeSystem, core.id(yPat), twenty);\n    Core.Exp exp2 = core.lessThan(f.typeSystem, core.id(xPat), ten);\n    Core.Exp exp3 = core.notEqual(f.typeSystem, core.id(xPat), five);\n    final Core.Exp exp =\n        core.andAlso(f.typeSystem, exp0,\n            core.andAlso(f.typeSystem, exp1,\n                core.andAlso(f.typeSystem, exp2, exp3)));\n    Core.Exp x = f.extent(xPat, exp);\n    assertThat(x, instanceOf(Core.Apply.class));\n    assertThat(((Core.Apply) x).fn, instanceOf(Core.Literal.class));\n    assertThat(((Core.Literal) ((Core.Apply) x).fn).unwrap(BuiltIn.class),\n        is(BuiltIn.Z_EXTENT));\n    assertThat(x, hasToString(\"extent \\\"int {/=[[3..5), (5..10)]}\\\"\"));\n\n    Core.Exp y = f.extent(yPat, exp);\n    assertThat(y, instanceOf(Core.Apply.class));\n    assertThat(((Core.Apply) y).fn, instanceOf(Core.Literal.class));\n    assertThat(((Core.Literal) ((Core.Apply) y).fn).unwrap(BuiltIn.class),\n        is(BuiltIn.Z_LIST));\n    assertThat(y, hasToString(\"[20]\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java", "class_name": "ExtentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest.[void]testSubTrue()", "name": "testSubTrue", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testSubTrue()", "original_string": "  @Test void testSubTrue() {\n    final Fixture f = new Fixture();\n    final Core.Exp exp1 =\n        core.andAlso(f.typeSystem, f.aId,\n            core.andAlso(f.typeSystem, f.bId,\n                core.orElse(f.typeSystem, f.cId, f.intLiteral(1))));\n    final String expected1a = \"a andalso (c orelse 1)\";\n    final String expected1b = \"a andalso (b andalso (c orelse 1))\";\n    final String expected1c = \"b andalso (c orelse 1)\";\n    f.checkSubTrue(exp1, list(f.bId), expected1a);\n    f.checkSubTrue(exp1, list(f.cId), expected1b);\n    f.checkSubTrue(exp1, list(f.cId, f.dId, f.list12), expected1b);\n    f.checkSubTrue(exp1, list(f.aId), expected1c);\n    f.checkSubTrue(exp1, list(f.dId), expected1b);\n    f.checkSubTrue(exp1, list(), expected1b);\n\n    final Core.Exp exp2 =\n        core.orElse(f.typeSystem, f.aId,\n            core.orElse(f.typeSystem, f.bId,\n                core.andAlso(f.typeSystem, f.cId, f.dId)));\n    final String expected2a = \"a orelse (b orelse c andalso d)\";\n    f.checkSubTrue(exp2, list(f.bId), expected2a); // TODO \"a\"\n    f.checkSubTrue(exp2, list(f.cId),\n        expected2a); // TODO \"a orelse (b orelse d)\"\n    f.checkSubTrue(exp2, list(f.bId, f.cId), expected2a); // TODO \"a\"\n    f.checkSubTrue(exp2, list(f.aId), expected2a); // TODO \"true\"\n    f.checkSubTrue(exp2, list(), expected2a);\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java", "class_name": "ExtentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest.[void]testFlatten()", "name": "testFlatten", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testFlatten()", "original_string": "  @Test void testFlatten() {\n    final Fixture f = new Fixture();\n    f.checkFlatten(f.aId, \"[a]\", \"[a]\");\n    f.checkFlatten(core.boolLiteral(true), \"[]\", \"[true]\");\n    f.checkFlatten(core.boolLiteral(false), \"[false]\", \"[]\");\n    f.checkFlatten(\n        core.andAlso(f.typeSystem, f.aId,\n            core.andAlso(f.typeSystem, f.bId,\n                core.orElse(f.typeSystem, f.cId, f.intLiteral(1)))),\n        \"[a, b, c orelse 1]\",\n        \"[a andalso (b andalso (c orelse 1))]\");\n    f.checkFlatten(\n        core.orElse(f.typeSystem, f.aId,\n            core.orElse(f.typeSystem, f.bId,\n                core.andAlso(f.typeSystem, f.cId, f.intLiteral(1)))),\n        \"[a orelse (b orelse c andalso 1)]\",\n        \"[a, b, c andalso 1]\");\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java", "class_name": "ExtentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest.[void]testAnalysis2c()", "name": "testAnalysis2c", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testAnalysis2c()", "original_string": "  @Test void testAnalysis2c() {\n    final Fixture f = new Fixture();\n    final Core.IdPat loc = core.idPat(PrimitiveType.STRING, \"loc\", 0);\n    final Core.IdPat deptno = core.idPat(PrimitiveType.INT, \"deptno\", 0);\n    final Core.IdPat name = core.idPat(PrimitiveType.STRING, \"name\", 0);\n    final Core.TuplePat pat =\n        core.tuplePat(f.typeSystem, list(loc, deptno, name));\n\n    final Core.Exp condition0 =\n        core.elem(f.typeSystem,\n            core.record(f.typeSystem,\n                PairList.copyOf(\"deptno\", core.id(deptno),\n                    \"dname\", core.id(name),\n                    \"loc\", core.id(loc))),\n            core.id(f.depts));\n    final Core.Exp condition1 =\n        core.greaterThan(f.typeSystem, core.id(deptno),\n            core.intLiteral(BigDecimal.valueOf(20)));\n\n    final BiConsumer<String, Consumer<FromBuilder>> fn = (v, action) -> {\n      final FromBuilder fromBuilder = core.fromBuilder(f.typeSystem);\n      fromBuilder.scan(pat);\n      // Apply one of the variants of 'where' clause\n      action.accept(fromBuilder);\n\n      final PairList<Core.IdPat, Core.Exp> idPats = PairList.of();\n      Extents.Analysis analysis =\n          Extents.create(f.typeSystem, pat, ImmutableSortedMap.of(),\n              fromBuilder.build().steps, idPats);\n      assertThat(analysis, notNullValue());\n      if (\"\".isEmpty()) {\n        assertThat(analysis.extentExp,\n            hasToString((\"from loc in [#loc v0] \"\n                + \"join deptno in [#deptno v0] \"\n                + \"join name in [#dname v0]\").replace(\"v0\", v)));\n        assertThat(analysis.satisfiedFilters, hasSize(3));\n        assertThat(analysis.satisfiedFilters.get(0),\n            hasToString(\"loc = #loc v0\".replace(\"v0\", v)));\n      } else {\n        assertThat(analysis.extentExp, hasToString(\"depts\"));\n        assertThat(analysis.satisfiedFilters, hasSize(1));\n        assertThat(analysis.satisfiedFilters.get(0), is(condition0));\n      }\n      assertThat(analysis.remainingFilters, empty());\n      assertThat(analysis.boundPats, anEmptyMap());\n      assertThat(analysis.goalPats, is(ImmutableSet.of(loc, deptno, name)));\n      assertThat(idPats, hasSize(1));\n      assertThat(idPats.leftList().get(0), hasToString(v));\n    };\n\n    // from (loc, deptno, name)\n    // where op elem ({deptno = deptno, dname = name, loc = loc}, depts)\n    fn.accept(\"v0\", fromBuilder ->\n        fromBuilder.where(condition0));\n\n    // from (loc, deptno, name)\n    // where op elem ({deptno = deptno, dname = name, loc = loc}, depts)\n    // where deptno > 20\n    fn.accept(\"v1\", fromBuilder ->\n        fromBuilder.where(condition0)\n            .where(condition1));\n\n    // from (loc, deptno, name)\n    // where op elem ({deptno = deptno, dname = name, loc = loc}, depts)\n    //    andalso deptno > 20\n    fn.accept(\"v2\", fromBuilder ->\n        fromBuilder.where(\n            core.andAlso(f.typeSystem, condition0, condition1)));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java", "class_name": "ExtentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest.[void]testAnalysis2d()", "name": "testAnalysis2d", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test void testAnalysis2d()", "original_string": "  @Test void testAnalysis2d() {\n    final Fixture f = new Fixture();\n    final Core.IdPat dno = core.idPat(PrimitiveType.INT, \"dno\", 0);\n    final Core.IdPat name = core.idPat(PrimitiveType.STRING, \"name\", 0);\n    final Core.TuplePat pat = core.tuplePat(f.typeSystem, list(dno, name));\n\n    // from (dno, name)\n    // where op elem ({deptno = dno, dname = name, loc = \"CHICAGO\"}, depts)\n    //   andalso dno > 20\n    final FromBuilder fromBuilder = core.fromBuilder(f.typeSystem);\n    fromBuilder.scan(pat);\n    final Core.Exp condition0 =\n        core.elem(f.typeSystem,\n            core.record(f.typeSystem,\n                PairList.copyOf(\"deptno\", core.id(dno),\n                    \"dname\", core.id(name),\n                    \"loc\", core.stringLiteral(\"CHICAGO\"))),\n            core.id(f.depts));\n    final Core.Exp condition1 =\n        core.greaterThan(f.typeSystem, core.id(dno),\n            core.intLiteral(BigDecimal.valueOf(20)));\n    fromBuilder.where(core.andAlso(f.typeSystem, condition0, condition1));\n\n    final PairList<Core.IdPat, Core.Exp> idPats = PairList.of();\n    Extents.Analysis analysis =\n        Extents.create(f.typeSystem, pat, ImmutableSortedMap.of(),\n            fromBuilder.build().steps, idPats);\n    assertThat(analysis, notNullValue());\n    assertThat(analysis.extentExp,\n        hasToString(\"from dno in [#deptno v0] join name in [#dname v0]\"));\n    assertThat(idPats, hasSize(1));\n    assertThat(idPats.leftList().get(0), hasToString(\"v0\"));\n  }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java", "class_name": "ExtentTest", "class_uri": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_leftTest.java.Pair_leftTest.[void]testLeft()", "name": "testLeft", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testLeft()", "original_string": "    @Test\n    public void testLeft() {\n        // Given\n        List<Map.Entry<String, Integer>> pairs = Arrays.asList(\n            new AbstractMap.SimpleEntry<>(\"a\", 1),\n            new AbstractMap.SimpleEntry<>(\"b\", 2),\n            new AbstractMap.SimpleEntry<>(\"c\", 3)\n        );\n\n        // When\n        List<String> result = Pair.left(pairs);\n\n        // Then\n        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_leftTest.java", "class_name": "Pair_leftTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_leftTest.java.Pair_leftTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_toImmutableListTest.java.Static_toImmutableListTest.[void]testToImmutableList()", "name": "testToImmutableList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testToImmutableList()", "original_string": "    @Test\n    void testToImmutableList() {\n        List<String> inputList = Arrays.asList(\"a\", \"b\", \"c\");\n        Stream<String> stream = inputList.stream();\n\n        ImmutableList<String> result = stream.collect(Static.toImmutableList());\n\n        assertEquals(inputList, result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_toImmutableListTest.java", "class_name": "Static_toImmutableListTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_toImmutableListTest.java.Static_toImmutableListTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Ord_forEachIndexedTest.java.Ord_forEachIndexedTest.[void]testForEachIndexed()", "name": "testForEachIndexed", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testForEachIndexed()", "original_string": "    @Test\n    public void testForEachIndexed() {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        StringBuilder result = new StringBuilder();\n        ObjIntConsumer<String> consumer = (e, i) -> result.append(i).append(e);\n\n        Ord.forEachIndexed(list, consumer);\n\n        assertEquals(\"0a1b2c\", result.toString());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Ord_forEachIndexedTest.java", "class_name": "Ord_forEachIndexedTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Ord_forEachIndexedTest.java.Ord_forEachIndexedTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_toMapTest.java.Pair_toMapTest.[void]testToMap()", "name": "testToMap", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testToMap()", "original_string": "    @Test\n    public void testToMap() {\n        // Given\n        List<Pair<String, Integer>> pairs = Arrays.asList(\n            new Pair<>(\"key1\", 1),\n            new Pair<>(\"key2\", 2),\n            new Pair<>(\"key3\", 3)\n        );\n\n        // When\n        Map<String, Integer> result = Pair.toMap(pairs);\n\n        // Then\n        Map<String, Integer> expected = new HashMap<>();\n        expected.put(\"key1\", 1);\n        expected.put(\"key2\", 2);\n        expected.put(\"key3\", 3);\n\n        assertEquals(expected, result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_toMapTest.java", "class_name": "Pair_toMapTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_toMapTest.java.Pair_toMapTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java.Pair_compareToTest.[void]testCompareTo_DifferentLeft()", "name": "testCompareTo_DifferentLeft", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testCompareTo_DifferentLeft()", "original_string": "    @Test\n    void testCompareTo_DifferentLeft() {\n        Pair<Integer, Integer> pair1 = Pair.of(1, 2);\n        Pair<Integer, Integer> pair2 = Pair.of(2, 2);\n        assertTrue(pair1.compareTo(pair2) < 0);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java", "class_name": "Pair_compareToTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java.Pair_compareToTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java.Pair_compareToTest.[void]testCompareTo_SameLeftDifferentRight()", "name": "testCompareTo_SameLeftDifferentRight", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testCompareTo_SameLeftDifferentRight()", "original_string": "    @Test\n    void testCompareTo_SameLeftDifferentRight() {\n        Pair<Integer, Integer> pair1 = Pair.of(1, 2);\n        Pair<Integer, Integer> pair2 = Pair.of(1, 3);\n        assertTrue(pair1.compareTo(pair2) < 0);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java", "class_name": "Pair_compareToTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java.Pair_compareToTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java.Pair_compareToTest.[void]testCompareTo_SameLeftSameRight()", "name": "testCompareTo_SameLeftSameRight", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testCompareTo_SameLeftSameRight()", "original_string": "    @Test\n    void testCompareTo_SameLeftSameRight() {\n        Pair<Integer, Integer> pair1 = Pair.of(1, 2);\n        Pair<Integer, Integer> pair2 = Pair.of(1, 2);\n        assertEquals(0, pair1.compareTo(pair2));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java", "class_name": "Pair_compareToTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java.Pair_compareToTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Ord_forEachTest.java.Ord_forEachTest.[void]testForEach()", "name": "testForEach", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testForEach()", "original_string": "    @Test\n    public void testForEach() {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        StringBuilder result = new StringBuilder();\n        ObjIntConsumer<String> consumer = (e, i) -> result.append(e).append(i);\n\n        Ord.forEach(list, consumer);\n\n        assertEquals(\"a0b1c2\", result.toString());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Ord_forEachTest.java", "class_name": "Ord_forEachTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Ord_forEachTest.java.Ord_forEachTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_intersectTest.java.Static_intersectTest.[void]testIntersect()", "name": "testIntersect", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testIntersect()", "original_string": "    @Test\n    public void testIntersect() {\n        List<Integer> list0 = Arrays.asList(1, 2, 3, 4);\n        Iterable<Integer> list1 = Arrays.asList(3, 4, 5, 6);\n\n        List<Integer> result = Static.intersect(list0, list1);\n\n        assertEquals(ImmutableList.of(3, 4), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_intersectTest.java", "class_name": "Static_intersectTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_intersectTest.java.Static_intersectTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_anyMatchTest.java.Pair_anyMatchTest.[void]testAnyMatch_True()", "name": "testAnyMatch_True", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testAnyMatch_True()", "original_string": "    @Test\n    void testAnyMatch_True() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(1, 2, 3);\n        BiPredicate<Integer, Integer> predicate = (k, v) -> k.equals(v);\n\n        assertTrue(Pair.anyMatch(ks, vs, predicate));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_anyMatchTest.java", "class_name": "Pair_anyMatchTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_anyMatchTest.java.Pair_anyMatchTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_anyMatchTest.java.Pair_anyMatchTest.[void]testAnyMatch_False()", "name": "testAnyMatch_False", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testAnyMatch_False()", "original_string": "    @Test\n    void testAnyMatch_False() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(4, 5, 6);\n        BiPredicate<Integer, Integer> predicate = (k, v) -> k.equals(v);\n\n        assertFalse(Pair.anyMatch(ks, vs, predicate));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_anyMatchTest.java", "class_name": "Pair_anyMatchTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_anyMatchTest.java.Pair_anyMatchTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_adjacentsTest.java.Pair_adjacentsTest.[void]testAdjacentsWithEmptyIterable()", "name": "testAdjacentsWithEmptyIterable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testAdjacentsWithEmptyIterable()", "original_string": "    @Test\n    void testAdjacentsWithEmptyIterable() {\n        Iterable<Integer> emptyIterable = Collections.emptyList();\n        Iterable<Pair<Integer, Integer>> result = Pair.adjacents(emptyIterable);\n        Iterator<Pair<Integer, Integer>> iterator = result.iterator();\n        assertFalse(iterator.hasNext());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_adjacentsTest.java", "class_name": "Pair_adjacentsTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_adjacentsTest.java.Pair_adjacentsTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_adjacentsTest.java.Pair_adjacentsTest.[void]testAdjacentsWithNonEmptyIterable()", "name": "testAdjacentsWithNonEmptyIterable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testAdjacentsWithNonEmptyIterable()", "original_string": "    @Test\n    void testAdjacentsWithNonEmptyIterable() {\n        List<Integer> nonEmptyIterable = Arrays.asList(1, 2, 3);\n        Iterable<Pair<Integer, Integer>> result = Pair.adjacents(nonEmptyIterable);\n        Iterator<Pair<Integer, Integer>> iterator = result.iterator();\n        assertTrue(iterator.hasNext());\n        assertEquals(Pair.of(1, 2), iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(Pair.of(2, 3), iterator.next());\n        assertFalse(iterator.hasNext());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_adjacentsTest.java", "class_name": "Pair_adjacentsTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_adjacentsTest.java.Pair_adjacentsTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_zipMutableTest.java.Pair_zipMutableTest.[void]testZipMutable()", "name": "testZipMutable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testZipMutable()", "original_string": "    @Test\n    void testZipMutable() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\", \"c\");\n\n        List<Pair<Integer, String>> result = Pair.zipMutable(ks, vs);\n\n        assertEquals(3, result.size());\n        assertEquals(Pair.of(1, \"a\"), result.get(0));\n        assertEquals(Pair.of(2, \"b\"), result.get(1));\n        assertEquals(Pair.of(3, \"c\"), result.get(2));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_zipMutableTest.java", "class_name": "Pair_zipMutableTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_zipMutableTest.java.Pair_zipMutableTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest.[void]testEquals_SameInstance()", "name": "testEquals_SameInstance", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testEquals_SameInstance()", "original_string": "    @Test\n    void testEquals_SameInstance() {\n        Pair<String, Integer> pair = Pair.of(\"key\", 42);\n        assertTrue(pair.equals(pair));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java", "class_name": "Pair_equalsTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest.[void]testEquals_DifferentInstanceSameValues()", "name": "testEquals_DifferentInstanceSameValues", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testEquals_DifferentInstanceSameValues()", "original_string": "    @Test\n    void testEquals_DifferentInstanceSameValues() {\n        Pair<String, Integer> pair1 = Pair.of(\"key\", 42);\n        Pair<String, Integer> pair2 = Pair.of(\"key\", 42);\n        assertTrue(pair1.equals(pair2));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java", "class_name": "Pair_equalsTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest.[void]testEquals_DifferentInstanceDifferentValues()", "name": "testEquals_DifferentInstanceDifferentValues", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testEquals_DifferentInstanceDifferentValues()", "original_string": "    @Test\n    void testEquals_DifferentInstanceDifferentValues() {\n        Pair<String, Integer> pair1 = Pair.of(\"key\", 42);\n        Pair<String, Integer> pair2 = Pair.of(\"key\", 43);\n        assertFalse(pair1.equals(pair2));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java", "class_name": "Pair_equalsTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest.[void]testEquals_NotInstanceOfMapEntry()", "name": "testEquals_NotInstanceOfMapEntry", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testEquals_NotInstanceOfMapEntry()", "original_string": "    @Test\n    void testEquals_NotInstanceOfMapEntry() {\n        Pair<String, Integer> pair = Pair.of(\"key\", 42);\n        assertFalse(pair.equals(\"not a pair\"));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java", "class_name": "Pair_equalsTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest.[void]testEquals_InstanceOfMapEntryDifferentValues()", "name": "testEquals_InstanceOfMapEntryDifferentValues", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testEquals_InstanceOfMapEntryDifferentValues()", "original_string": "    @Test\n    void testEquals_InstanceOfMapEntryDifferentValues() {\n        Pair<String, Integer> pair = Pair.of(\"key\", 42);\n        Map.Entry<String, Integer> entry = new AbstractMap.SimpleEntry<>(\"key\", 43);\n        assertFalse(pair.equals(entry));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java", "class_name": "Pair_equalsTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest.[void]testEquals_InstanceOfMapEntrySameValues()", "name": "testEquals_InstanceOfMapEntrySameValues", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testEquals_InstanceOfMapEntrySameValues()", "original_string": "    @Test\n    void testEquals_InstanceOfMapEntrySameValues() {\n        Pair<String, Integer> pair = Pair.of(\"key\", 42);\n        Map.Entry<String, Integer> entry = new AbstractMap.SimpleEntry<>(\"key\", 42);\n        assertTrue(pair.equals(entry));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java", "class_name": "Pair_equalsTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_firstAndTest.java.Pair_firstAndTest.[void]testFirstAndWithEmptyIterable()", "name": "testFirstAndWithEmptyIterable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testFirstAndWithEmptyIterable()", "original_string": "    @Test\n    void testFirstAndWithEmptyIterable() {\n        Iterable<Integer> emptyIterable = Collections.emptyList();\n        Iterable<Pair<Integer, Integer>> result = Pair.firstAnd(emptyIterable);\n        Iterator<Pair<Integer, Integer>> iterator = result.iterator();\n        assertFalse(iterator.hasNext());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_firstAndTest.java", "class_name": "Pair_firstAndTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_firstAndTest.java.Pair_firstAndTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_firstAndTest.java.Pair_firstAndTest.[void]testFirstAndWithNonEmptyIterable()", "name": "testFirstAndWithNonEmptyIterable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testFirstAndWithNonEmptyIterable()", "original_string": "    @Test\n    void testFirstAndWithNonEmptyIterable() {\n        List<Integer> nonEmptyIterable = Arrays.asList(1, 2, 3);\n        Iterable<Pair<Integer, Integer>> result = Pair.firstAnd(nonEmptyIterable);\n        Iterator<Pair<Integer, Integer>> iterator = result.iterator();\n        assertTrue(iterator.hasNext());\n        Pair<Integer, Integer> firstPair = iterator.next();\n        assertEquals(1, firstPair.left);\n        assertEquals(2, firstPair.right);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_firstAndTest.java", "class_name": "Pair_firstAndTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_firstAndTest.java.Pair_firstAndTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_transformEagerTest.java.Static_transformEagerTest.[void]testTransformEagerWithEmptyIterable()", "name": "testTransformEagerWithEmptyIterable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testTransformEagerWithEmptyIterable()", "original_string": "    @Test\n    public void testTransformEagerWithEmptyIterable() {\n        Iterable<String> emptyIterable = Collections.emptyList();\n        Function<String, Integer> mapper = String::length;\n\n        ImmutableList<Integer> result = Static.transformEager(emptyIterable, mapper);\n\n        assertEquals(ImmutableList.of(), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_transformEagerTest.java", "class_name": "Static_transformEagerTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_transformEagerTest.java.Static_transformEagerTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_transformEagerTest.java.Static_transformEagerTest.[void]testTransformEagerWithNonEmptyIterable()", "name": "testTransformEagerWithNonEmptyIterable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testTransformEagerWithNonEmptyIterable()", "original_string": "    @Test\n    public void testTransformEagerWithNonEmptyIterable() {\n        Iterable<String> nonEmptyIterable = Arrays.asList(\"one\", \"two\", \"three\");\n        Function<String, Integer> mapper = String::length;\n\n        ImmutableList<Integer> result = Static.transformEager(nonEmptyIterable, mapper);\n\n        assertEquals(ImmutableList.of(3, 3, 5), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_transformEagerTest.java", "class_name": "Static_transformEagerTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_transformEagerTest.java.Static_transformEagerTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_findTest.java.Static_findTest.[void]testFindRandomAccessList()", "name": "testFindRandomAccessList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testFindRandomAccessList()", "original_string": "    @Test\n    public void testFindRandomAccessList() {\n        List<Integer> list = ImmutableList.of(1, 2, 3, 4, 5);\n        Predicate<Integer> predicate = i -> i == 3;\n        int result = Static.find(list, predicate);\n        assertEquals(2, result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_findTest.java", "class_name": "Static_findTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_findTest.java.Static_findTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_findTest.java.Static_findTest.[void]testFindNonRandomAccessList()", "name": "testFindNonRandomAccessList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testFindNonRandomAccessList()", "original_string": "    @Test\n    public void testFindNonRandomAccessList() {\n        List<Integer> list = ImmutableList.of(1, 2, 3, 4, 5);\n        Predicate<Integer> predicate = i -> i == 3;\n        int result = Static.find(list, predicate);\n        assertEquals(2, result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_findTest.java", "class_name": "Static_findTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_findTest.java.Static_findTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_findTest.java.Static_findTest.[void]testFindNoMatch()", "name": "testFindNoMatch", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testFindNoMatch()", "original_string": "    @Test\n    public void testFindNoMatch() {\n        List<Integer> list = ImmutableList.of(1, 2, 3, 4, 5);\n        Predicate<Integer> predicate = i -> i == 6;\n        int result = Static.find(list, predicate);\n        assertEquals(-1, result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_findTest.java", "class_name": "Static_findTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_findTest.java.Static_findTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_rightTest.java.Pair_rightTest.[void]testRight()", "name": "testRight", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testRight()", "original_string": "    @Test\n    public void testRight() {\n        // Given\n        List<Map.Entry<String, Integer>> pairs = Arrays.asList(\n            new AbstractMap.SimpleEntry<>(\"a\", 1),\n            new AbstractMap.SimpleEntry<>(\"b\", 2),\n            new AbstractMap.SimpleEntry<>(\"c\", 3)\n        );\n\n        // When\n        List<Integer> result = Pair.right(pairs);\n\n        // Then\n        assertEquals(Arrays.asList(1, 2, 3), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_rightTest.java", "class_name": "Pair_rightTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_rightTest.java.Pair_rightTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_noneMatchTest.java.Pair_noneMatchTest.[void]testNoneMatch_NoMatch()", "name": "testNoneMatch_NoMatch", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testNoneMatch_NoMatch()", "original_string": "    @Test\n    void testNoneMatch_NoMatch() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(4, 5, 6);\n        BiPredicate<Integer, Integer> predicate = (k, v) -> k > v;\n\n        boolean result = Pair.noneMatch(ks, vs, predicate);\n\n        assertTrue(result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_noneMatchTest.java", "class_name": "Pair_noneMatchTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_noneMatchTest.java.Pair_noneMatchTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_noneMatchTest.java.Pair_noneMatchTest.[void]testNoneMatch_WithMatch()", "name": "testNoneMatch_WithMatch", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testNoneMatch_WithMatch()", "original_string": "    @Test\n    void testNoneMatch_WithMatch() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(4, 1, 6);\n        BiPredicate<Integer, Integer> predicate = (k, v) -> k > v;\n\n        boolean result = Pair.noneMatch(ks, vs, predicate);\n\n        assertFalse(result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_noneMatchTest.java", "class_name": "Pair_noneMatchTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_noneMatchTest.java.Pair_noneMatchTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_forEachTest.java.Pair_forEachTest.[void]testForEach()", "name": "testForEach", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testForEach()", "original_string": "    @Test\n    public void testForEach() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\", \"c\");\n        StringBuilder result = new StringBuilder();\n\n        BiConsumer<Integer, String> consumer = (k, v) -> result.append(k).append(v);\n\n        Pair.forEach(ks, vs, consumer);\n\n        assertEquals(\"1a2b3c\", result.toString());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_forEachTest.java", "class_name": "Pair_forEachTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_forEachTest.java.Pair_forEachTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest.[void]testClear()", "name": "testClear", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testClear()", "original_string": "    @Test\n    public void testClear() {\n        assertThat(tailList.size(), is(2));\n        assertThat(backingList.size(), is(4));\n\n        tailList.clear();\n\n        assertThat(tailList.size(), is(0));\n        assertThat(backingList.size(), is(2));\n        assertThat(backingList.get(0), is(\"a\"));\n        assertThat(backingList.get(1), is(\"b\"));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java", "class_name": "TailList_clearTest", "class_uri": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest.[void]testClearEmptyList()", "name": "testClearEmptyList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testClearEmptyList()", "original_string": "    @Test\n    public void testClearEmptyList() {\n        TailList<String> emptyTailList = new TailList<>(new ArrayList<>(), 0);\n\n        assertThat(emptyTailList.size(), is(0));\n\n        emptyTailList.clear();\n\n        assertThat(emptyTailList.size(), is(0));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java", "class_name": "TailList_clearTest", "class_uri": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest.[void]testClearWithNoElementsToRemove()", "name": "testClearWithNoElementsToRemove", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testClearWithNoElementsToRemove()", "original_string": "    @Test\n    public void testClearWithNoElementsToRemove() {\n        TailList<String> noRemoveTailList = new TailList<>(backingList, 4);\n\n        assertThat(noRemoveTailList.size(), is(0));\n\n        noRemoveTailList.clear();\n\n        assertThat(noRemoveTailList.size(), is(0));\n        assertThat(backingList.size(), is(4));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java", "class_name": "TailList_clearTest", "class_uri": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java.Static_minusTest.[void]testMinus_AllElementsRemoved()", "name": "testMinus_AllElementsRemoved", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testMinus_AllElementsRemoved()", "original_string": "    @Test\n    public void testMinus_AllElementsRemoved() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 2, 4, 2);\n        List<Integer> result = Static.minus(list, 2);\n        assertEquals(Arrays.asList(1, 3, 4), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java", "class_name": "Static_minusTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java.Static_minusTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java.Static_minusTest.[void]testMinus_NoElementsRemoved()", "name": "testMinus_NoElementsRemoved", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testMinus_NoElementsRemoved()", "original_string": "    @Test\n    public void testMinus_NoElementsRemoved() {\n        List<Integer> list = Arrays.asList(1, 3, 4);\n        List<Integer> result = Static.minus(list, 2);\n        assertEquals(Arrays.asList(1, 3, 4), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java", "class_name": "Static_minusTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java.Static_minusTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java.Static_minusTest.[void]testMinus_EmptyList()", "name": "testMinus_EmptyList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testMinus_EmptyList()", "original_string": "    @Test\n    public void testMinus_EmptyList() {\n        List<Integer> list = ImmutableList.of();\n        List<Integer> result = Static.minus(list, 2);\n        assertEquals(ImmutableList.of(), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java", "class_name": "Static_minusTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java.Static_minusTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java.Pair_zipTest.[void]testZipStrictEqualSizes()", "name": "testZipStrictEqualSizes", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testZipStrictEqualSizes()", "original_string": "    @Test\n    void testZipStrictEqualSizes() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\", \"c\");\n        List<Pair<Integer, String>> result = Pair.zip(ks, vs, true);\n        assertEquals(3, result.size());\n        assertEquals(Pair.of(1, \"a\"), result.get(0));\n        assertEquals(Pair.of(2, \"b\"), result.get(1));\n        assertEquals(Pair.of(3, \"c\"), result.get(2));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java", "class_name": "Pair_zipTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java.Pair_zipTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java.Pair_zipTest.[void]testZipStrictDifferentSizes()", "name": "testZipStrictDifferentSizes", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testZipStrictDifferentSizes()", "original_string": "    @Test\n    void testZipStrictDifferentSizes() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\");\n        assertThrows(AssertionError.class, () -> Pair.zip(ks, vs, true));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java", "class_name": "Pair_zipTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java.Pair_zipTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java.Pair_zipTest.[void]testZipNonStrict()", "name": "testZipNonStrict", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testZipNonStrict()", "original_string": "    @Test\n    void testZipNonStrict() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\");\n        List<Pair<Integer, String>> result = Pair.zip(ks, vs, false);\n        assertEquals(2, result.size());\n        assertEquals(Pair.of(1, \"a\"), result.get(0));\n        assertEquals(Pair.of(2, \"b\"), result.get(1));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java", "class_name": "Pair_zipTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java.Pair_zipTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java.Pair_allMatchTest.[void]testAllMatch_AllElementsMatch()", "name": "testAllMatch_AllElementsMatch", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testAllMatch_AllElementsMatch()", "original_string": "    @Test\n    void testAllMatch_AllElementsMatch() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(1, 2, 3);\n        BiPredicate<Integer, Integer> predicate = Integer::equals;\n\n        boolean result = Pair.allMatch(ks, vs, predicate);\n\n        assertTrue(result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java", "class_name": "Pair_allMatchTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java.Pair_allMatchTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java.Pair_allMatchTest.[void]testAllMatch_NotAllElementsMatch()", "name": "testAllMatch_NotAllElementsMatch", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testAllMatch_NotAllElementsMatch()", "original_string": "    @Test\n    void testAllMatch_NotAllElementsMatch() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(1, 2, 4);\n        BiPredicate<Integer, Integer> predicate = Integer::equals;\n\n        boolean result = Pair.allMatch(ks, vs, predicate);\n\n        assertFalse(result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java", "class_name": "Pair_allMatchTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java.Pair_allMatchTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java.Pair_allMatchTest.[void]testAllMatch_DifferentLengths()", "name": "testAllMatch_DifferentLengths", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testAllMatch_DifferentLengths()", "original_string": "    @Test\n    void testAllMatch_DifferentLengths() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(1, 2);\n        BiPredicate<Integer, Integer> predicate = Integer::equals;\n\n        boolean result = Pair.allMatch(ks, vs, predicate);\n\n        assertTrue(result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java", "class_name": "Pair_allMatchTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java.Pair_allMatchTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java.Pair_allMatchTest.[void]testAllMatch_EmptyCollections()", "name": "testAllMatch_EmptyCollections", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testAllMatch_EmptyCollections()", "original_string": "    @Test\n    void testAllMatch_EmptyCollections() {\n        List<Integer> ks = Collections.emptyList();\n        List<Integer> vs = Collections.emptyList();\n        BiPredicate<Integer, Integer> predicate = Integer::equals;\n\n        boolean result = Pair.allMatch(ks, vs, predicate);\n\n        assertTrue(result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java", "class_name": "Pair_allMatchTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java.Pair_allMatchTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest.[void]testVariableCreation()", "name": "testVariableCreation", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testVariableCreation()", "original_string": "    @Test\n    public void testVariableCreation() {\n        Sat.Variable variable = sat.variable(\"x\");\n        assertNotNull(variable);\n        assertEquals(\"x\", variable.name);\n        assertEquals(0, variable.id);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java", "class_name": "Sat_variableTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest.[void]testVariableRetrieval()", "name": "testVariableRetrieval", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testVariableRetrieval()", "original_string": "    @Test\n    public void testVariableRetrieval() {\n        Sat.Variable variable1 = sat.variable(\"x\");\n        Sat.Variable variable2 = sat.variable(\"x\");\n        assertSame(variable1, variable2);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java", "class_name": "Sat_variableTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest.[void]testVariableIdIncrement()", "name": "testVariableIdIncrement", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testVariableIdIncrement()", "original_string": "    @Test\n    public void testVariableIdIncrement() {\n        Sat.Variable variable1 = sat.variable(\"x\");\n        Sat.Variable variable2 = sat.variable(\"y\");\n        assertEquals(0, variable1.id);\n        assertEquals(1, variable2.id);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java", "class_name": "Sat_variableTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest.[void]testVariableNameUniqueness()", "name": "testVariableNameUniqueness", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testVariableNameUniqueness()", "original_string": "    @Test\n    public void testVariableNameUniqueness() {\n        Sat.Variable variable1 = sat.variable(\"x\");\n        Sat.Variable variable2 = sat.variable(\"y\");\n        assertNotEquals(variable1.name, variable2.name);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java", "class_name": "Sat_variableTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest.[void]testVariableIdUniqueness()", "name": "testVariableIdUniqueness", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testVariableIdUniqueness()", "original_string": "    @Test\n    public void testVariableIdUniqueness() {\n        Sat.Variable variable1 = sat.variable(\"x\");\n        Sat.Variable variable2 = sat.variable(\"y\");\n        assertNotEquals(variable1.id, variable2.id);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java", "class_name": "Sat_variableTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_strTest.java.Static_strTest.[void]testStr()", "name": "testStr", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    void testStr()", "original_string": "    @Test\n    void testStr() {\n        StringBuilder b = new StringBuilder(\"test\");\n        String result = Static.str(b);\n        assertEquals(\"test\", result);\n        assertEquals(0, b.length());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_strTest.java", "class_name": "Static_strTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_strTest.java.Static_strTest", "attributes": {"modifiers": "@Test", "marker_annotations": ["@Test"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java.Static_shorterThanTest.[void]testShorterThan_Collection()", "name": "testShorterThan_Collection", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testShorterThan_Collection()", "original_string": "    @Test\n    public void testShorterThan_Collection() {\n        Collection<Integer> collection = Arrays.asList(1, 2, 3);\n        assertTrue(Static.shorterThan(collection, 4));\n        assertFalse(Static.shorterThan(collection, 3));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java", "class_name": "Static_shorterThanTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java.Static_shorterThanTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java.Static_shorterThanTest.[void]testShorterThan_Iterable()", "name": "testShorterThan_Iterable", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testShorterThan_Iterable()", "original_string": "    @Test\n    public void testShorterThan_Iterable() {\n        Iterable<Integer> iterable = ImmutableList.of(1, 2, 3);\n        assertTrue(Static.shorterThan(iterable, 4));\n        assertFalse(Static.shorterThan(iterable, 3));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java", "class_name": "Static_shorterThanTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java.Static_shorterThanTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java.Static_shorterThanTest.[void]testShorterThan_NonPositiveN()", "name": "testShorterThan_NonPositiveN", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testShorterThan_NonPositiveN()", "original_string": "    @Test\n    public void testShorterThan_NonPositiveN() {\n        Iterable<Integer> iterable = ImmutableList.of(1, 2, 3);\n        assertFalse(Static.shorterThan(iterable, 0));\n        assertFalse(Static.shorterThan(iterable, -1));\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java", "class_name": "Static_shorterThanTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java.Static_shorterThanTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_plusTest.java.Static_plusTest.[void]testPlus()", "name": "testPlus", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testPlus()", "original_string": "    @Test\n    public void testPlus() {\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"a\", 1);\n        map.put(\"b\", 2);\n\n        Map<String, Integer> result = Static.plus(map, \"c\", 3);\n\n        assertEquals(ImmutableMap.of(\"a\", 1, \"b\", 2, \"c\", 3), result);\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/util/Static_plusTest.java", "class_name": "Static_plusTest", "class_uri": "src/test/java/net/hydromatic/morel/util/Static_plusTest.java.Static_plusTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/type/RangeExtent_toStringTest.java.RangeExtent_toStringTest.[void]testToStringUnbounded()", "name": "testToStringUnbounded", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testToStringUnbounded()", "original_string": "    @Test\n    public void testToStringUnbounded() {\n        Type mockType = new Type() {\n            @Override\n            public String toString() {\n                return \"MockType\";\n            }\n\n            @Override\n            public <R> R accept(TypeVisitor<R> visitor) {\n                return null; // Provide a default implementation\n            }\n\n            @Override\n            public Type copy(TypeSystem typeSystem, java.util.function.UnaryOperator<Type> operator) {\n                return this; // Provide a default implementation\n            }\n        };\n\n        RangeExtent rangeExtent = new RangeExtent(null, mockType, ImmutableMap.of());\n        assertEquals(\"MockType\", rangeExtent.toString());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/type/RangeExtent_toStringTest.java", "class_name": "RangeExtent_toStringTest", "class_uri": "src/test/java/net/hydromatic/morel/type/RangeExtent_toStringTest.java.RangeExtent_toStringTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/net/hydromatic/morel/type/RangeExtent_toStringTest.java.RangeExtent_toStringTest.[void]testToStringBounded()", "name": "testToStringBounded", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Test\n    public void testToStringBounded()", "original_string": "    @Test\n    public void testToStringBounded() {\n        Type mockType = new Type() {\n            @Override\n            public String toString() {\n                return \"MockType\";\n            }\n\n            @Override\n            public <R> R accept(TypeVisitor<R> visitor) {\n                return null; // Provide a default implementation\n            }\n\n            @Override\n            public Type copy(TypeSystem typeSystem, java.util.function.UnaryOperator<Type> operator) {\n                return this; // Provide a default implementation\n            }\n        };\n\n        ImmutableRangeSet<Integer> mockRangeSet = ImmutableRangeSet.of();\n        RangeExtent rangeExtent = new RangeExtent(null, mockType, ImmutableMap.of(\"path\", mockRangeSet));\n        assertEquals(\"MockType {path=[[]]}\", rangeExtent.toString());\n    }", "default_arguments": null, "file": "src/test/java/net/hydromatic/morel/type/RangeExtent_toStringTest.java", "class_name": "RangeExtent_toStringTest", "class_uri": "src/test/java/net/hydromatic/morel/type/RangeExtent_toStringTest.java.RangeExtent_toStringTest", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}]