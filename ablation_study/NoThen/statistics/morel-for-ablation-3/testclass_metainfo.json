[{"uris": "src/test/java/net/hydromatic/morel/FromBuilderTest.java.FromBuilderTest", "name": "FromBuilderTest", "file_path": "src/test/java/net/hydromatic/morel/FromBuilderTest.java", "superclasses": "", "methods": ["[void]testBasic()", "[void]testWhereOrder()", "[void]testTrivialYield()", "[void]testTrivialYield2()", "[void]testTrivialYield3()", "[void]testNested()", "[void]testNested3()", "[void]testNested4()", "[void]testNestedSameName()", "[void]testNested0()", "[void]testNested2()", "[void]testNestedFromTuple()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "  private static class Fixture {\n    final TypeSystem typeSystem = new TypeSystem();\n    final PrimitiveType intType = PrimitiveType.INT;\n    final PrimitiveType unitType = PrimitiveType.UNIT;\n    final Type intPairType = typeSystem.tupleType(intType, intType);\n    final Core.IdPat aPat = core.idPat(intType, \"a\", 0);\n    final Core.Id aId = core.id(aPat);\n    final Core.IdPat bPat = core.idPat(intType, \"b\", 0);\n    final Core.Id bId = core.id(bPat);\n    final Core.IdPat dPat = core.idPat(intPairType, \"d\", 0);\n    final Core.Id dId = core.id(dPat);\n    final Core.IdPat iPat = core.idPat(intType, \"i\", 0);\n    final Core.Id iId = core.id(iPat);\n    final Core.IdPat jPat = core.idPat(intType, \"j\", 0);\n    final Core.Id jId = core.id(jPat);\n    final Core.IdPat uPat = core.idPat(unitType, \"u\", 0);\n    final Core.Exp list12 = core.list(typeSystem, intLiteral(1), intLiteral(2));\n    final Core.Exp list34 = core.list(typeSystem, intLiteral(3), intLiteral(4));\n    final Core.Exp tuple12 =\n        core.tuple(typeSystem, intLiteral(1), intLiteral(2));\n    final Core.Exp tuple34 =\n        core.tuple(typeSystem, intLiteral(3), intLiteral(4));\n\n    Core.Literal intLiteral(int i) {\n      return core.literal(intType, i);\n    }\n\n    Core.Exp record(Core.Id... ids) {\n      final PairList<String, Core.Exp> nameExps = PairList.of();\n      Arrays.asList(ids).forEach(id -> nameExps.add(id.idPat.name, id));\n      return core.record(typeSystem, nameExps);\n    }\n\n    FromBuilder fromBuilder() {\n      return core.fromBuilder(typeSystem, Environments.empty());\n    }\n  }", "definition": "  private static class Fixture", "class_docstring": "", "name": "Fixture", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final TypeSystem typeSystem = new TypeSystem();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TypeSystem", "name": "typeSystem = new TypeSystem()", "syntax_pass": true}, {"attribute_expression": "final PrimitiveType intType = PrimitiveType.INT;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "PrimitiveType", "name": "intType = PrimitiveType.INT", "syntax_pass": true}, {"attribute_expression": "final PrimitiveType unitType = PrimitiveType.UNIT;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "PrimitiveType", "name": "unitType = PrimitiveType.UNIT", "syntax_pass": true}, {"attribute_expression": "final Type intPairType = typeSystem.tupleType(intType, intType);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Type", "name": "intPairType = typeSystem.tupleType(intType, intType)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat aPat = core.idPat(intType, \"a\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "aPat = core.idPat(intType, \"a\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Id aId = core.id(aPat);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Id", "name": "aId = core.id(aPat)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat bPat = core.idPat(intType, \"b\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "bPat = core.idPat(intType, \"b\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Id bId = core.id(bPat);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Id", "name": "bId = core.id(bPat)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat dPat = core.idPat(intPairType, \"d\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "dPat = core.idPat(intPairType, \"d\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Id dId = core.id(dPat);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Id", "name": "dId = core.id(dPat)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat iPat = core.idPat(intType, \"i\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "iPat = core.idPat(intType, \"i\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Id iId = core.id(iPat);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Id", "name": "iId = core.id(iPat)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat jPat = core.idPat(intType, \"j\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "jPat = core.idPat(intType, \"j\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Id jId = core.id(jPat);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Id", "name": "jId = core.id(jPat)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat uPat = core.idPat(unitType, \"u\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "uPat = core.idPat(unitType, \"u\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Exp list12 = core.list(typeSystem, intLiteral(1), intLiteral(2));", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Exp", "name": "list12 = core.list(typeSystem, intLiteral(1), intLiteral(2))", "syntax_pass": true}, {"attribute_expression": "final Core.Exp list34 = core.list(typeSystem, intLiteral(3), intLiteral(4));", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Exp", "name": "list34 = core.list(typeSystem, intLiteral(3), intLiteral(4))", "syntax_pass": true}, {"attribute_expression": "final Core.Exp tuple12 =\n        core.tuple(typeSystem, intLiteral(1), intLiteral(2));", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Exp", "name": "tuple12 =\n        core.tuple(typeSystem, intLiteral(1), intLiteral(2))", "syntax_pass": true}, {"attribute_expression": "final Core.Exp tuple34 =\n        core.tuple(typeSystem, intLiteral(3), intLiteral(4));", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Exp", "name": "tuple34 =\n        core.tuple(typeSystem, intLiteral(3), intLiteral(4))", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Core.Literal intLiteral(int i) {\n      return core.literal(intType, i);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Core.Literal", "classes": []}, "name": "intLiteral", "params": [{"name": "i", "type": "int"}], "body": "                                   {\n      return core.literal(intType, i);\n    }", "signature": "Core.Literal intLiteral(int i)"}, {"syntax_pass": true, "original_string": "    Core.Exp record(Core.Id... ids) {\n      final PairList<String, Core.Exp> nameExps = PairList.of();\n      Arrays.asList(ids).forEach(id -> nameExps.add(id.idPat.name, id));\n      return core.record(typeSystem, nameExps);\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Core.Exp", "classes": []}, "name": "record", "params": [], "body": "                                    {\n      final PairList<String, Core.Exp> nameExps = PairList.of();\n      Arrays.asList(ids).forEach(id -> nameExps.add(id.idPat.name, id));\n      return core.record(typeSystem, nameExps);\n    }", "signature": "Core.Exp record(Core.Id... ids)"}, {"syntax_pass": true, "original_string": "    FromBuilder fromBuilder() {\n      return core.fromBuilder(typeSystem, Environments.empty());\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "FromBuilder", "classes": []}, "name": "fromBuilder", "params": [], "body": "                              {\n      return core.fromBuilder(typeSystem, Environments.empty());\n    }", "signature": "FromBuilder fromBuilder()"}]}], "class_docstring": "\nTest {@link net.hydromatic.morel.ast.FromBuilder}.\n", "original_string": "public class FromBuilderTest {\n  private static class Fixture {\n    final TypeSystem typeSystem = new TypeSystem();\n    final PrimitiveType intType = PrimitiveType.INT;\n    final PrimitiveType unitType = PrimitiveType.UNIT;\n    final Type intPairType = typeSystem.tupleType(intType, intType);\n    final Core.IdPat aPat = core.idPat(intType, \"a\", 0);\n    final Core.Id aId = core.id(aPat);\n    final Core.IdPat bPat = core.idPat(intType, \"b\", 0);\n    final Core.Id bId = core.id(bPat);\n    final Core.IdPat dPat = core.idPat(intPairType, \"d\", 0);\n    final Core.Id dId = core.id(dPat);\n    final Core.IdPat iPat = core.idPat(intType, \"i\", 0);\n    final Core.Id iId = core.id(iPat);\n    final Core.IdPat jPat = core.idPat(intType, \"j\", 0);\n    final Core.Id jId = core.id(jPat);\n    final Core.IdPat uPat = core.idPat(unitType, \"u\", 0);\n    final Core.Exp list12 = core.list(typeSystem, intLiteral(1), intLiteral(2));\n    final Core.Exp list34 = core.list(typeSystem, intLiteral(3), intLiteral(4));\n    final Core.Exp tuple12 =\n        core.tuple(typeSystem, intLiteral(1), intLiteral(2));\n    final Core.Exp tuple34 =\n        core.tuple(typeSystem, intLiteral(3), intLiteral(4));\n\n    Core.Literal intLiteral(int i) {\n      return core.literal(intType, i);\n    }\n\n    Core.Exp record(Core.Id... ids) {\n      final PairList<String, Core.Exp> nameExps = PairList.of();\n      Arrays.asList(ids).forEach(id -> nameExps.add(id.idPat.name, id));\n      return core.record(typeSystem, nameExps);\n    }\n\n    FromBuilder fromBuilder() {\n      return core.fromBuilder(typeSystem, Environments.empty());\n    }\n  }\n\n  @Test void testBasic() {\n    // from i in [1, 2]\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, f.list12);\n\n    final Core.From from = fromBuilder.build();\n    assertThat(from, hasToString(\"from i in [1, 2]\"));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, hasToString(\"[1, 2]\"));\n\n    // \"from i in [1, 2] yield i\" --> \"[1, 2]\"\n    fromBuilder.yield_(f.iId);\n    final Core.From from2 = fromBuilder.build();\n    assertThat(from2, is(from));\n    final Core.Exp e2 = fromBuilder.buildSimplify();\n    assertThat(e2, is(e));\n  }\n\n  @Test void testWhereOrder() {\n    // from i in [1, 2] where i < 2 order i desc\n    //  ==>\n    // from i in [1, 2]\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, f.list12)\n        .where(core.lessThan(f.typeSystem, f.iId, f.intLiteral(2)))\n        .order(ImmutableList.of(core.orderItem(f.iId, Ast.Direction.DESC)));\n\n    final Core.From from = fromBuilder.build();\n    assertThat(from.toString(),\n        is(\"from i in [1, 2] where i < 2 order i desc\"));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n\n    // \"where true\" and \"order {}\" are ignored\n    fromBuilder.where(core.boolLiteral(true))\n        .order(ImmutableList.of())\n        .where(core.greaterThan(f.typeSystem, f.iId, f.intLiteral(1)));\n    final Core.From from2 = fromBuilder.build();\n    assertThat(from2.toString(),\n        is(\"from i in [1, 2] where i < 2 order i desc where i > 1\"));\n    final Core.Exp e2 = fromBuilder.buildSimplify();\n    assertThat(e2, is(from2));\n  }\n\n  @Test void testTrivialYield() {\n    // from i in [1, 2] where i < 2 yield i\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, f.list12)\n        .where(core.lessThan(f.typeSystem, f.iId, f.intLiteral(2)))\n        .yield_(f.iId);\n\n    final Core.From from = fromBuilder.build();\n    assertThat(from, hasToString(\"from i in [1, 2] where i < 2\"));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }\n\n  @Test void testTrivialYield2() {\n    // from j in [1, 2], i in [3, 4] where i < 2 yield {i, j}\n    //   ==>\n    // from j in [1, 2], i in [3, 4] where i < 2\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.jPat, f.list12)\n        .scan(f.iPat, f.list34)\n        .where(core.lessThan(f.typeSystem, f.iId, f.intLiteral(2)))\n        .yield_(f.record(f.iId, f.jId));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from j in [1, 2] \"\n        + \"join i in [3, 4] \"\n        + \"where i < 2\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }\n\n  @Test void testTrivialYield3() {\n    // from j in [1, 2] yield {j} join i in [3, 4]\n    //   ==>\n    // from j in [1, 2] join i in [3, 4]\n    final Fixture f = new Fixture();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.jPat, f.list12)\n        .yield_(f.record(f.jId))\n        .scan(f.iPat, f.list34);\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from j in [1, 2] \"\n        + \"join i in [3, 4]\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }\n\n  @Test void testNested() {\n    // from i in (from j in [1, 2] where j < 2) where i > 1\n    //   ==>\n    // from j in [1, 2] where j < 2 yield {i = j} where i > 1\n    final Fixture f = new Fixture();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(f.jPat, f.list12)\n            .where(core.lessThan(f.typeSystem, f.jId, f.intLiteral(2)))\n            .build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, innerFrom)\n        .where(core.greaterThan(f.typeSystem, f.iId, f.intLiteral(1)));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from j in [1, 2] \"\n        + \"where j < 2 \"\n        + \"yield {i = j} \"\n        + \"where i > 1\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }\n\n  @Test void testNested3() {\n    // from i in (from j in [1, 2]) where i > 1\n    //   ==>\n    // from j in [1, 2] yield {i = j} where i > 1\n    final Fixture f = new Fixture();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(f.jPat, f.list12)\n            .build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, innerFrom)\n        .where(core.greaterThan(f.typeSystem, f.iId, f.intLiteral(1)));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from j in [1, 2] yield {i = j} where i > 1\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n\n    // from j in (from j in [1, 2]) where j > 1\n    //   ==>\n    // from j in [1, 2] where j > 1\n    final FromBuilder fromBuilder2 = f.fromBuilder();\n    fromBuilder2.scan(f.jPat, innerFrom)\n        .where(core.greaterThan(f.typeSystem, f.jId, f.intLiteral(1)));\n\n    final Core.From from2 = fromBuilder2.build();\n    final String expected2 = \"from j in [1, 2] where j > 1\";\n    assertThat(from2, hasToString(expected2));\n    final Core.Exp e2 = fromBuilder2.buildSimplify();\n    assertThat(e2, is(from2));\n\n    // from i in (from j in [1, 2])\n    //   ==>\n    // from j in [1, 2]\n    //   ==> simplification\n    // [1, 2]\n    final FromBuilder fromBuilder3 = f.fromBuilder();\n    fromBuilder3.scan(f.iPat, innerFrom);\n\n    final Core.From from3 = fromBuilder3.build();\n    final String expected3 = \"from j in [1, 2]\";\n    assertThat(from3, hasToString(expected3));\n    final Core.Exp e3 = fromBuilder3.buildSimplify();\n    assertThat(e3, is(f.list12));\n  }\n\n  @Test void testNested4() {\n    // from d in [(1, 2), (3, 4)]\n    // join i in (from i in [#1 d])\n    //   ==>\n    // from d in [(1, 2), (3, 4)]\n    // join i in [#1 d]\n    final Fixture f = new Fixture();\n    final Function<List<Binding>, Core.From> innerFrom = bindings ->\n        core.fromBuilder(f.typeSystem,\n                Environments.empty().bindAll(bindings))\n            .scan(f.iPat,\n                core.list(f.typeSystem,\n                    core.field(f.typeSystem, f.dId, 0)))\n            .build();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder\n        .scan(f.dPat,\n            core.list(f.typeSystem, f.tuple12, f.tuple34))\n        .scan(f.iPat, innerFrom.apply(fromBuilder.bindings()));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from d in [(1, 2), (3, 4)] \"\n        + \"join i in [#1 d]\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n\n    // from d in [(1, 2), (3, 4)]\n    // join j in (from i in [#1 d])\n    // where j > #1 d\n    //   ==>\n    // from d in [(1, 2), (3, 4)]\n    // join i in [#1 d]\n    // yield {d, j = i}\n    // where j > #1 d\n    final FromBuilder fromBuilder2 = f.fromBuilder();\n    fromBuilder2\n        .scan(f.dPat,\n            core.list(f.typeSystem, f.tuple12, f.tuple34))\n        .scan(f.jPat, innerFrom.apply(fromBuilder.bindings()))\n        .where(\n            core.greaterThan(f.typeSystem, f.jId,\n                core.field(f.typeSystem, f.dId, 0)));\n\n    final Core.From from2 = fromBuilder2.build();\n    final String expected2 = \"from d in [(1, 2), (3, 4)] \"\n        + \"join i in [#1 d] \"\n        + \"yield {d = d, j = i} \"\n        + \"where j > #1 d\";\n    assertThat(from2, hasToString(expected2));\n    final Core.Exp e2 = fromBuilder2.buildSimplify();\n    assertThat(e2, is(from2));\n  }\n\n  /** As {@link #testNested()} but inner and outer variables have the same\n   * name, and therefore no yield is required. */\n  @Test void testNestedSameName() {\n    // from i in (from i in [1, 2] where i < 2) where i > 1\n    //   ==>\n    // from i in [1, 2] where i < 2 where i > 1\n    final Fixture f = new Fixture();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(f.iPat, f.list12)\n            .where(core.lessThan(f.typeSystem, f.iId, f.intLiteral(2)))\n            .build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.iPat, innerFrom)\n        .where(core.greaterThan(f.typeSystem, f.iId, f.intLiteral(1)));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from i in [1, 2] \"\n        + \"where i < 2 \"\n        + \"where i > 1\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }\n\n  @Test void testNested0() {\n    // from u in (from)\n    //   ==>\n    // from\n    final Fixture f = new Fixture();\n    final Core.From innerFrom = f.fromBuilder().build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(f.uPat, innerFrom);\n\n    final Core.From from = fromBuilder.build();\n    assertThat(from, hasToString(\"from u in (from)\"));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, hasToString(\"from\"));\n  }\n\n  @Test void testNested2() {\n    // from {i = a, j = b} in (from a in [1, 2], b in [3, 4] where a < 2)\n    //   where i < j\n    //   ==>\n    // from a in [1, 2], b in [3, 4] where a < 2 yield {i = a, j = b}\n    //   where i < j\n    final Fixture f = new Fixture();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(f.aPat, f.list12)\n            .scan(f.bPat, f.list34)\n            .where(core.lessThan(f.typeSystem, f.aId, f.intLiteral(2)))\n            .build();\n\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder.scan(\n        core.recordPat(f.typeSystem, ImmutableSet.of(\"i\", \"j\"),\n            ImmutableList.of(f.aPat, f.bPat)),\n            innerFrom)\n        .where(core.lessThan(f.typeSystem, f.iId, f.jId));\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from a in [1, 2] \"\n        + \"join b in [3, 4] \"\n        + \"where a < 2 \"\n        + \"yield {i = a, j = b} \"\n        + \"where i < j\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n  }\n\n  @Test void testNestedFromTuple() {\n    // from (a, b) in\n    //   (from (a, b) in\n    //     (from a in [1, 2] join b in [3, 4]))\n    // where a > b andalso b = 10\n    // yield b\n    //   ==>\n    // from a in [1, 2]\n    // join b in [3, 4]\n    // where a > b andalso a = 10\n    // yield b\n    final Fixture f = new Fixture();\n    final Core.Pat abPat =\n        core.tuplePat(f.typeSystem, Arrays.asList(f.aPat, f.bPat));\n\n    final Core.From innermostFrom =\n        f.fromBuilder()\n            .scan(f.aPat, f.list12)\n            .scan(f.bPat, f.list34)\n            .build();\n    final Core.From innerFrom =\n        f.fromBuilder()\n            .scan(abPat, innermostFrom)\n            .build();\n    final FromBuilder fromBuilder = f.fromBuilder();\n    fromBuilder\n        .scan(abPat, innerFrom)\n        .where(\n            core.andAlso(f.typeSystem,\n                core.greaterThan(f.typeSystem, f.aId, f.bId),\n                core.equal(f.typeSystem, f.aId,\n                    core.intLiteral(BigDecimal.TEN))))\n        .yield_(f.bId);\n\n    final Core.From from = fromBuilder.build();\n    final String expected = \"from a in [1, 2] \"\n        + \"join b in [3, 4] \"\n        + \"where a > b andalso a = 10 \"\n        + \"yield b\";\n    assertThat(from, hasToString(expected));\n    final Core.Exp e = fromBuilder.buildSimplify();\n    assertThat(e, is(from));\n\n    // Tuple where variables are not in alphabetical order. Requires\n    // a 'yield' step to re-order variables.\n    //\n    // from (b, a) in\n    //   (from a in [1, 2] join b in [3, 4])\n    // where a > b andalso b = 10\n    // yield b\n    //   ==>\n    // from a in [1, 2]\n    // join b in [3, 4]\n    // yield {a = b, b = a}\n    // where a > b andalso a = 10\n    // yield b\n    final Core.Pat baPat =\n        core.tuplePat(f.typeSystem, Arrays.asList(f.bPat, f.aPat));\n    final FromBuilder fromBuilder2 = f.fromBuilder();\n    fromBuilder2\n        .scan(baPat, innermostFrom)\n        .where(\n            core.andAlso(f.typeSystem,\n                core.greaterThan(f.typeSystem, f.aId, f.bId),\n                core.equal(f.typeSystem, f.aId,\n                    core.intLiteral(BigDecimal.TEN))))\n        .yield_(f.bId);\n\n    final Core.From from2 = fromBuilder2.build();\n    final String expected2 = \"from a in [1, 2] \"\n        + \"join b in [3, 4] \"\n        + \"yield {a = b, b = a} \"\n        + \"where a > b andalso a = 10 \"\n        + \"yield b\";\n    assertThat(from2, hasToString(expected2));\n    final Core.Exp e2 = fromBuilder2.buildSimplify();\n    assertThat(e2, is(from2));\n\n    // from (i, j) in\n    //   (from a in [1, 2] join b in [3, 4])\n    // where i > j andalso j = 10\n    // yield i\n    //   ==>\n    // from a in [1, 2]\n    // join b in [3, 4]\n    // yield {i = a, j = b}\n    // where i > j andalso j = 10\n    // yield i\n    final Core.Pat ijPat =\n        core.tuplePat(f.typeSystem, Arrays.asList(f.iPat, f.jPat));\n    final FromBuilder fromBuilder3 = f.fromBuilder();\n    fromBuilder3\n        .scan(ijPat, innermostFrom)\n        .where(\n            core.andAlso(f.typeSystem,\n                core.greaterThan(f.typeSystem, f.iId, f.jId),\n                core.equal(f.typeSystem, f.jId,\n                    core.intLiteral(BigDecimal.TEN))))\n        .yield_(f.jId);\n\n    final Core.From from3 = fromBuilder3.build();\n    final String expected3 = \"from a in [1, 2] \"\n        + \"join b in [3, 4] \"\n        + \"yield {i = a, j = b} \"\n        + \"where i > j andalso j = 10 \"\n        + \"yield j\";\n    assertThat(from3, hasToString(expected3));\n    final Core.Exp e3 = fromBuilder3.buildSimplify();\n    assertThat(e3, is(from3));\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest", "name": "ShellTest", "file_path": "src/test/java/net/hydromatic/morel/ShellTest.java", "superclasses": "", "methods": ["[void]testShell()", "[void]testShellNoBanner()", "[void]testOneLine()", "[void]testTwoLines()", "[void]testReal()", "[void]testEmptyLines()", "[void]testSingleLineComment()", "[void]testSingleLineCommentWithQuote()", "[void]testMultiLineLet()", "[void]testUse()", "[void]testMatchWarning()", "[void]testUseEmpty()", "[void]testUseMissing()", "[void]testUseSelfReferential()", "[void]testRaw()", "[void]testStringDepth()", "[void]testPrintDepth()", "[void]testPrintLength()", "[void]testLineWidth()"], "method_uris": ["src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[Fixture]fixture()", "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]pauseForTenMilliseconds()", "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[void]assumeNotInCi()", "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[File]getUseDirectory()", "src/test/java/net/hydromatic/morel/ShellTest.java.ShellTest.[Matcher<String>]is2(String)"], "overrides": null, "attributes": [{"original_string": "  private static class FixtureImpl implements Fixture {\n    final ImmutableList<String> argList;\n    final String inputString;\n    final boolean raw;\n    final File file;\n\n    FixtureImpl(ImmutableList<String> argList, String inputString,\n        boolean raw, File file) {\n      this.argList = requireNonNull(argList, \"argList\");\n      this.inputString = requireNonNull(inputString, \"inputString\");\n      this.raw = raw;\n      this.file = requireNonNull(file, \"file\");\n    }\n\n    @Override public List<String> argList() {\n      return argList;\n    }\n\n    @Override public Fixture withArgList(List<String> argList) {\n      if (this.argList.equals(argList)) {\n        return this;\n      }\n      ImmutableList<String> argList1 = ImmutableList.copyOf(argList);\n      return new FixtureImpl(argList1, inputString, raw, file);\n    }\n\n    @Override public File getFile() {\n      return file;\n    }\n\n    @Override public Fixture withFile(File file) {\n      if (file.equals(this.file)) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }\n\n    @Override public String inputString() {\n      return inputString;\n    }\n\n    @Override public Fixture withInputString(String inputString) {\n      if (this.inputString.equals(inputString)) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }\n\n    @Override public boolean isRaw() {\n      return raw;\n    }\n\n    @Override public Fixture withRaw(boolean raw) {\n      if (raw == this.raw) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }\n  }", "definition": "  private static class FixtureImpl implements Fixture", "class_docstring": " Implementation of Fixture.", "name": "FixtureImpl", "super_interfaces": ["Fixture"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final ImmutableList<String> argList;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ImmutableList<String>", "name": "argList", "syntax_pass": true}, {"attribute_expression": "final String inputString;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "inputString", "syntax_pass": true}, {"attribute_expression": "final boolean raw;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "boolean", "name": "raw", "syntax_pass": true}, {"attribute_expression": "final File file;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "File", "name": "file", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FixtureImpl(ImmutableList<String> argList, String inputString,\n        boolean raw, File file) {\n      this.argList = requireNonNull(argList, \"argList\");\n      this.inputString = requireNonNull(inputString, \"inputString\");\n      this.raw = raw;\n      this.file = requireNonNull(file, \"file\");\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FixtureImpl", "params": [{"name": "argList", "type": "ImmutableList<String>"}, {"name": "inputString", "type": "String"}, {"name": "raw", "type": "boolean"}, {"name": "file", "type": "File"}], "body": "                                {\n      this.argList = requireNonNull(argList, \"argList\");\n      this.inputString = requireNonNull(inputString, \"inputString\");\n      this.raw = raw;\n      this.file = requireNonNull(file, \"file\");\n    }", "signature": "FixtureImpl(ImmutableList<String> argList, String inputString,\n        boolean raw, File file)"}, {"syntax_pass": true, "original_string": "    @Override public List<String> argList() {\n      return argList;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "argList", "params": [], "body": "                                            {\n      return argList;\n    }", "signature": "@Override public List<String> argList()"}, {"syntax_pass": true, "original_string": "    @Override public Fixture withArgList(List<String> argList) {\n      if (this.argList.equals(argList)) {\n        return this;\n      }\n      ImmutableList<String> argList1 = ImmutableList.copyOf(argList);\n      return new FixtureImpl(argList1, inputString, raw, file);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Fixture", "classes": []}, "name": "withArgList", "params": [{"name": "argList", "type": "List<String>"}], "body": "                                                               {\n      if (this.argList.equals(argList)) {\n        return this;\n      }\n      ImmutableList<String> argList1 = ImmutableList.copyOf(argList);\n      return new FixtureImpl(argList1, inputString, raw, file);\n    }", "signature": "@Override public Fixture withArgList(List<String> argList)"}, {"syntax_pass": true, "original_string": "    @Override public File getFile() {\n      return file;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "File", "classes": []}, "name": "getFile", "params": [], "body": "                                    {\n      return file;\n    }", "signature": "@Override public File getFile()"}, {"syntax_pass": true, "original_string": "    @Override public Fixture withFile(File file) {\n      if (file.equals(this.file)) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Fixture", "classes": []}, "name": "withFile", "params": [{"name": "file", "type": "File"}], "body": "                                                 {\n      if (file.equals(this.file)) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }", "signature": "@Override public Fixture withFile(File file)"}, {"syntax_pass": true, "original_string": "    @Override public String inputString() {\n      return inputString;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "inputString", "params": [], "body": "                                          {\n      return inputString;\n    }", "signature": "@Override public String inputString()"}, {"syntax_pass": true, "original_string": "    @Override public Fixture withInputString(String inputString) {\n      if (this.inputString.equals(inputString)) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Fixture", "classes": []}, "name": "withInputString", "params": [{"name": "inputString", "type": "String"}], "body": "                                                                 {\n      if (this.inputString.equals(inputString)) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }", "signature": "@Override public Fixture withInputString(String inputString)"}, {"syntax_pass": true, "original_string": "    @Override public boolean isRaw() {\n      return raw;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRaw", "params": [], "body": "                                     {\n      return raw;\n    }", "signature": "@Override public boolean isRaw()"}, {"syntax_pass": true, "original_string": "    @Override public Fixture withRaw(boolean raw) {\n      if (raw == this.raw) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Fixture", "classes": []}, "name": "withRaw", "params": [{"name": "raw", "type": "boolean"}], "body": "                                                  {\n      if (raw == this.raw) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }", "signature": "@Override public Fixture withRaw(boolean raw)"}]}], "class_docstring": " Tests the Shell.", "original_string": "public class ShellTest {\n\n  /** Creates a Fixture. */\n  static Fixture fixture() {\n    return new FixtureImpl(Fixture.DEFAULT_ARG_LIST, \"?\", false, new File(\"\"));\n  }\n\n  static void pauseForTenMilliseconds() {\n    try {\n      Thread.sleep(10);\n    } catch (InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  /** Throws \"assumption failed\" if the environment variable 'morel.ci'\n   * is set and is not 0 or false. Allows us to skip tests that are\n   * non-deterministic when run in GitHub actions or Travis CI. */\n  static void assumeNotInCi() {\n    final String ci = System.getProperty(\"morel.ci\");\n    assumeTrue(ci == null\n            || ci.equalsIgnoreCase(\"false\")\n            || ci.equals(\"0\"),\n        \"test skipped during CI (morel.ci is \" + ci + \")\");\n  }\n\n  static File getUseDirectory() {\n    final File rootDirectory = findDirectory();\n    return new File(rootDirectory, \"use\");\n  }\n\n  /** Tests {@link Shell} with empty input. */\n  @Test void testShell() {\n    final List<String> argList = Collections.singletonList(\"--system=false\");\n    fixture().withArgList(argList)\n        .withInputString(\"\")\n        .assertOutput(containsString(\"morel version\"));\n  }\n\n  /** Tests {@link Shell} with empty input and banner disabled. */\n  @Test void testShellNoBanner() {\n    fixture()\n        .withInputString(\"\")\n        .assertOutput(containsString(\"- \\r\\r\\n\"));\n  }\n\n  /** Tests {@link Shell} with one line. */\n  @Test void testOneLine() {\n    assumeNotInCi();\n    final String in = \"1 + 2;\\n\";\n    final String expected = \"1 + 2;\\r\\n\"\n        + \"- 1 + 2;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 3 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }\n\n  /** Tests {@link Shell} with a continued line. */\n  @Test void testTwoLines() {\n    assumeNotInCi();\n    final String in = \"1 +\\n\"\n        + \"2;\\n\";\n    final String expected = \"1 +\\r\\n\"\n        + \"2;\\r\\n\"\n        + \"- 1 +\\r\\r\\n\"\n        + \"\\u001B[?2004l= 2;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 3 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }\n\n  /** Tests {@link Shell} printing some tricky real values. */\n  @Test void testReal() {\n    final String in = \"val nan = Real.posInf / Real.negInf;\\n\"\n        + \"(nan, Real.posInf, Real.negInf, 0.0, ~0.0);\\n\";\n    final String expected = \"val nan = nan : real\\n\"\n        + \"val it = (nan,inf,~inf,0.0,~0.0) : real * real * real * real * real\\n\";\n    fixture().withRaw(true).withInputString(in).assertOutput(is(expected));\n  }\n\n  /** Tests {@link Shell} with a line that is a comment, another that is empty,\n   *  and another that has only a semicolon; all are treated as empty. */\n  @Test void testEmptyLines() {\n    assumeNotInCi();\n    final String in = \"(* a comment followed by empty *)\\n\"\n        + \"\\n\"\n        + \";\\n\";\n    final String expected = \"(* a comment followed by empty *)\\r\\n\"\n        + \"\\r\\n\"\n        + \";\\r\\n\"\n        + \"- (* a comment followed by empty *)\\r\\r\\n\"\n        + \"\\u001B[?2004l- \\r\\r\\n\"\n        + \"\\u001B[?2004l- ;\\r\\r\\n\"\n        + \"\\u001B[?2004l- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }\n\n  private Matcher<String> is2(String expected) {\n    return anyOf(is(expected),\n        is(expected.replace(\"\\u001B[?2004l\", \"\")));\n  }\n\n  /** Tests {@link Shell} with a single-line comment. */\n  @Test void testSingleLineComment() {\n    assumeNotInCi();\n    final String in = \"(*) line comment\\n\"\n        + \"1 + 2;\\n\";\n    final String expected = \"(*) line comment\\r\\n\"\n        + \"1 + 2;\\r\\n\"\n        + \"- (*) line comment\\r\\r\\n\"\n        + \"\\u001B[?2004l- 1 + 2;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 3 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }\n\n  /** Tests {@link Shell} with a single-line comment that contains a quote. */\n  @Test void testSingleLineCommentWithQuote() {\n    assumeNotInCi();\n    final String in = \"(*) it's a single-line comment with a quote\\n\"\n        + \"2 + 3;\\n\";\n    final String expected = \"(*) it's a single-line comment with a quote\\r\\n\"\n        + \"2 + 3;\\r\\n\"\n        + \"- (*) it's a single-line comment with a quote\\r\\r\\n\"\n        + \"\\u001B[?2004l- 2 + 3;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 5 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }\n\n  /** Tests {@link Shell} with {@code let} statement spread over multiple\n   * lines. */\n  @Test void testMultiLineLet() {\n    assumeNotInCi();\n    final String in = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"in\\n\"\n        + \"  x + 2\\n\"\n        + \"end;\\n\";\n    final String expected = \"let\\r\\n\"\n        + \"  val x = 1\\r\\n\"\n        + \"in\\r\\n\"\n        + \"  x + 2\\r\\n\"\n        + \"end;\\r\\n\"\n        + \"- let\\r\\r\\n\"\n        + \"\\u001B[?2004l=   val x = 1\\r\\r\\n\"\n        + \"\\u001B[?2004l= in\\r\\r\\n\"\n        + \"\\u001B[?2004l=   x + 2\\r\\r\\n\"\n        + \"\\u001B[?2004l= end;\\r\\r\\n\"\n        + \"\\u001B[?2004lval it = 3 : int\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture().withInputString(in).assertOutput(is2(expected));\n  }\n\n  /** Tests the {@code use} function. */\n  @Test void testUse() {\n    assumeNotInCi();\n    // In SML-NJ, given x.sml as follows:\n    //   val x = 2;\n    //   val y = x + 3;\n    //   x + y;\n    //   use \"z.sml\";\n    //   x + y + z;\n    // and z.sml as follows:\n    //   val z = 7;\n    //   val x = 1;\n    //   x + z;\n    // running\n    //   use \"x.sml\";\n    //   x;\n    // gives\n    //   - use \"x.sml\";\n    //   [opening x.sml]\n    //   val x = 2 : int\n    //   val y = 5 : int\n    //   val it = 7 : int\n    //   [opening z.sml]\n    //   val z = 7 : int\n    //   val x = 1 : int\n    //   val it = 8 : int\n    //   val it = () : unit\n    //   val it = 13 : int\n    //   val it = () : unit\n    //   val it = 1;\n    // Note that x = 1 after /tmp/x.sml has finished;\n    // and that z has been assigned after /tmp/z.sml has finished.\n    final String in = \"use \\\"x.sml\\\";\\n\";\n    final String expected = \"use \\\"x.sml\\\";\\r\\n\"\n        + \"- use \\\"x.sml\\\";\\r\\r\\n\"\n        + \"\\u001B[?2004l[opening x.sml]\\r\\n\"\n        + \"val x = 2 : int\\r\\n\"\n        + \"val y = 5 : int\\r\\n\"\n        + \"val it = 7 : int\\r\\n\"\n        + \"[opening z.sml]\\r\\n\"\n        + \"val z = 7 : int\\r\\n\"\n        + \"val x = 1 : int\\r\\n\"\n        + \"val it = 8 : int\\r\\n\"\n        + \"val it = () : unit\\r\\n\"\n        + \"val it = 13 : int\\r\\n\"\n        + \"val it = () : unit\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture()\n        .withArgListPlusDirectory()\n        .withInputString(in)\n        .assertOutput(is2(expected));\n\n    final String expectedRaw = \"[opening x.sml]\\n\"\n        + \"val x = 2 : int\\n\"\n        + \"val y = 5 : int\\n\"\n        + \"val it = 7 : int\\n\"\n        + \"[opening z.sml]\\n\"\n        + \"val z = 7 : int\\n\"\n        + \"val x = 1 : int\\n\"\n        + \"val it = 8 : int\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = 13 : int\\n\"\n        + \"val it = () : unit\\n\";\n    fixture()\n        .withRaw(true)\n        .withArgListPlusDirectory()\n        .withInputString(in)\n        .assertOutput(is(expectedRaw));\n  }\n\n  /** Tests a warning. */\n  @Test void testMatchWarning() {\n    final String in = \"fun f 1 = 1;\\n\"\n        + \"f 1;\\n\";\n    final String expected = \"stdIn:1.5-1.12 Warning: match nonexhaustive\\n\"\n        + \"  raised at: stdIn:1.5-1.12\\n\"\n        + \"val f = fn : int -> int\\n\"\n        + \"val it = 1 : int\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(in)\n        .assertOutput(is(expected));\n  }\n\n  /** Tests the {@code use} function on an empty file. */\n  @Test void testUseEmpty() {\n    assumeNotInCi();\n    final String in = \"use \\\"empty.sml\\\";\\n\";\n    final String expected = \"use \\\"empty.sml\\\";\\r\\n\"\n        + \"- use \\\"empty.sml\\\";\\r\\r\\n\"\n        + \"\\u001B[?2004l[opening empty.sml]\\r\\n\"\n        + \"val it = () : unit\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture()\n        .withArgListPlusDirectory()\n        .withInputString(in)\n        .assertOutput(is2(expected));\n  }\n\n  /** Tests the {@code use} function on a missing file. */\n  @Test void testUseMissing() {\n    assumeNotInCi();\n    // SML-NJ gives:\n    //   [opening missing.sml]\n    //   [use failed: Io: openIn failed on \"missing.sml\", No such file or\n    //   directory]\n    //   uncaught exception Error\n    //     raised at: ../compiler/TopLevel/interact/interact.sml:24.14-24.28\n\n    final String in = \"use \\\"missing.sml\\\";\\n\";\n    final String expected = \"use \\\"missing.sml\\\";\\r\\n\"\n        + \"- use \\\"missing.sml\\\";\\r\\r\\n\"\n        + \"\\u001B[?2004l[opening missing.sml]\\r\\n\"\n        + \"[use failed: Io: openIn failed on missing.sml,\"\n        + \" No such file or directory]\\r\\n\"\n        + \"uncaught exception Error\\r\\n\"\n        + \"  raised at: stdIn:1.1-1.18\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture()\n        .withArgListPlusDirectory()\n        .withInputString(in)\n        .assertOutput(is2(expected));\n  }\n\n  /** Tests the {@code use} function on a file that uses itself. */\n  @Test void testUseSelfReferential() {\n    assumeNotInCi();\n    // SML-NJ gives:\n    //   [opening self-referential.sml]\n    //   [use failed: Io: openIn failed on \"self-referential.sml\", Too many\n    //   open files]\n    //   uncaught exception Error\n    //     raised at: ../compiler/TopLevel/interact/interact.sml:24.14-24.28\n\n    final String in = \"use \\\"self-referential.sml\\\";\\n\";\n    final String expected = \"use \\\"self-referential.sml\\\";\\r\\n\"\n        + \"- use \\\"self-referential.sml\\\";\\r\\r\\n\"\n        + \"\\u001B[?2004l[opening self-referential.sml]\\r\\n\"\n        + \"[opening self-referential.sml]\\r\\n\"\n        + \"[opening self-referential.sml]\\r\\n\"\n        + \"[opening self-referential.sml]\\r\\n\"\n        + \"[use failed: Io: openIn failed on self-referential.sml,\"\n        + \" Too many open files]\\r\\n\"\n        + \"uncaught exception Error\\r\\n\"\n        + \"  raised at: stdIn:1.1-1.27\\r\\n\"\n        + \"val it = () : unit\\r\\n\"\n        + \"- \\r\\r\\n\"\n        + \"\\u001B[?2004l\";\n    fixture()\n        .withArgListPlusDirectory()\n        .withArgList(list -> plus(list, \"--maxUseDepth=3\"))\n        .withInputString(in)\n        .assertOutput(is2(expected));\n  }\n\n  /** Tests a script running in raw mode.\n   * It uses {@link Main} rather than {@link Shell}. */\n  @Test void testRaw() {\n    String inputString = \"val x = 2;\\n\"\n        + \"x + 3;\\n\";\n    String expected = \"val x = 2 : int\\n\"\n        + \"val it = 5 : int\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }\n\n  @Test void testStringDepth() {\n    String inputString = \"val s = \\\"a string that is 35 characters long\\\";\\n\"\n        + \"val c = #\\\"a\\\";\\n\"\n        + \"Sys.set (\\\"stringDepth\\\", 20);\\n\"\n        + \"s;\\n\"\n        + \"c;\\n\"\n        + \"\\\"abc\\\";\\n\"\n        + \"Sys.set (\\\"stringDepth\\\", 1);\\n\"\n        + \"s;\\n\"\n        + \"c;\\n\"\n        + \"Sys.set (\\\"stringDepth\\\", 0);\\n\"\n        + \"s;\\n\"\n        + \"c;\\n\"\n        + \"Sys.set (\\\"stringDepth\\\", 5);\\n\"\n        + \"\\\"a\\\\\\\\b\\\\\\\"cdef\\\";\";\n    String expected = \"val s = \\\"a string that is 35 characters long\\\" : string\\n\"\n        + \"val c = #\\\"a\\\" : char\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = \\\"a string that is 35 #\\\" : string\\n\"\n        + \"val it = #\\\"a\\\" : char\\n\"\n        + \"val it = \\\"abc\\\" : string\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = \\\"a#\\\" : string\\n\"\n        + \"val it = #\\\"a\\\" : char\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = \\\"#\\\" : string\\n\"\n        + \"val it = #\\\"a\\\" : char\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = \\\"a\\\\\\\\b\\\\\\\"c#\\\" : string\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }\n\n  @Test void testPrintDepth() {\n    String inputString = \"Sys.set (\\\"lineWidth\\\", 70);\\n\"\n        + \"val x = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=7,h=[8],i={j=[9]}}]}]};\\n\"\n        + \"Sys.set (\\\"printDepth\\\", 6);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 5);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 4);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 3);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 2);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 1);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", 0);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printDepth\\\", ~1);\\n\"\n        + \"x;\";\n    // TODO: wrap types linke this:\n    // val it = ...\n    //  : {a:int, b:int list,\n    //     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\n    String expected = \"val it = () : unit\\n\"\n        + \"val x = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=#,h=#,i=#}]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=7,h=[#],i={j=#}}]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=#,h=#,i=#}]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=4,e=[#,#],f=[#]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=#,e=#,f=#}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[#,#],c=[#]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=#,b=#,c=#}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = # : unit\\n\"\n        + \"val it = #\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = {a=1,b=[2,3],c=[{d=4,e=[5,6],f=[{g=7,h=[8],i={j=[9]}}]}]}\\n\"\n        + \"  : {a:int, b:int list,\\n\"\n        + \"     c:{d:int, e:int list, f:{g:int, h:int list, i:{j:int list}} list} list}\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }\n\n  @Test void testPrintLength() {\n    String inputString = \"Sys.set (\\\"printLength\\\", 10);\\n\"\n        + \"val x = [[1,2,3], [4,5], [6], []];\\n\"\n        + \"Sys.set (\\\"printLength\\\", 4);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", 3);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", 2);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", 1);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", 0);\\n\"\n        + \"x;\"\n        + \"Sys.set (\\\"printLength\\\", ~1);\\n\"\n        + \"x;\\n\";\n    String expected = \"val it = () : unit\\n\"\n        + \"val x = [[1,2,3],[4,5],[6],[]] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,2,3],[4,5],[6],[]] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,2,3],[4,5],[6],...] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,2,...],[4,5],...] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,...],...] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [...] : int list list\\n\"\n        + \"val it = () : unit\\n\"\n        + \"val it = [[1,2,3],[4,5],[6],[]] : int list list\\n\";\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }\n\n  @Test void testLineWidth() {\n    String inputString = \"Sys.set (\\\"lineWidth\\\", 100);\\n\"\n        + \"100;\"\n        + \"val x = [[1,2,3], [4,5], [6], []];\\n\"\n        + \"val y = ([1,2,3], [4,5], [6], []);\\n\"\n        + \"val z = {a=[1,2,3], b=[4,5], c=[6], d=()};\\n\"\n        + \"val r = {x=x,y=y,z=z};\\n\"\n        + \"val f = fn s => String.size s;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", 40);\\n\"\n        + \"40;\\n\"\n        + \"x;\\n\"\n        + \"y;\\n\"\n        + \"z;\\n\"\n        + \"r;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", 20);\\n\"\n        + \"20;\\n\"\n        + \"x;\\n\"\n        + \"y;\\n\"\n        + \"z;\\n\"\n        + \"f;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", 1);\\n\"\n        + \"1;\\n\"\n        + \"x;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", 0);\\n\"\n        + \"0;\\n\"\n        + \"x;\\n\"\n        + \"Sys.set (\\\"lineWidth\\\", ~1);\\n\"\n        + \"~1;\\n\"\n        + \"x;\\n\";\n    String[] lines = {\n        // width 100\n        \"val it = () : unit\",\n        \"val it = 100 : int\",\n        \"val x = [[1,2,3],[4,5],[6],[]] : int list list\",\n        \"val y = ([1,2,3],[4,5],[6],[])\"\n            + \" : int list * int list * int list * 'a list\",\n        \"val z = {a=[1,2,3],b=[4,5],c=[6],d=()}\"\n            + \" : {a:int list, b:int list, c:int list, d:unit}\",\n        \"val r = {x=[[1,2,3],[4,5],[6],[]],y=([1,2,3],[4,5],[6],[]),\"\n            + \"z={a=[1,2,3],b=[4,5],c=[6],d=()}}\",\n        \"  : {x:int list list, y:int list * int list * int list * 'a list,\",\n        \"     z:{a:int list, b:int list, c:int list, d:unit}}\",\n        \"val f = fn : string -> int\",\n        // width 40\n        \"val it = () : unit\",\n        \"val it = 40 : int\",\n        \"val it = [[1,2,3],[4,5],[6],[]]\",\n        \"  : int list list\",\n        \"val it = ([1,2,3],[4,5],[6],[])\",\n        \"  : int list * int list * int list *\",\n        \"    'a list\",\n        \"val it = {a=[1,2,3],b=[4,5],c=[6],d=()}\",\n        \"  : {a:int list, b:int list, c:int list,\",\n        \"     d:unit}\",\n        \"val it =\",\n        \"  {x=[[1,2,3],[4,5],[6],[]],\",\n        \"   y=([1,2,3],[4,5],[6],[]),\",\n        \"   z={a=[1,2,3],b=[4,5],c=[6],d=()}}\",\n        \"  : {x:int list list,\",\n        \"     y:int list * int list * int list *\",\n        \"       'a list,\",\n        \"     z:{a:int list, b:int list,\",\n        \"        c:int list, d:unit}}\",\n        // width 20\n        \"val it = () : unit\",\n        \"val it = 20 : int\",\n        \"val it =\",\n        \"  [[1,2,3],[4,5],[6],\",\n        \"   []]\",\n        \"  : int list list\",\n        \"val it =\",\n        \"  ([1,2,3],[4,5],[6],\",\n        \"   [])\",\n        \"  : int list *\",\n        \"    int list *\",\n        \"    int list *\",\n        \"    'a list\",\n        \"val it =\",\n        \"  {a=[1,2,3],b=[4,5],\",\n        \"   c=[6],d=()}\",\n        \"  : {a:int list,\",\n        \"     b:int list,\",\n        \"     c:int list,\",\n        \"     d:unit}\",\n        \"val it = fn\",\n        \"  : string -> int\",\n        // width 1\n        \"val it =\",\n        \"  ()\",\n        \"  :\",\n        \"    unit\",\n        \"val it =\",\n        \"  1\",\n        \"  :\",\n        \"    int\",\n        \"val it =\",\n        \"  [\",\n        \"   [\",\n        \"    1,\",\n        \"    2,\",\n        \"    3],\",\n        \"   [\",\n        \"    4,\",\n        \"    5],\",\n        \"   [\",\n        \"    6],\",\n        \"   []]\",\n        \"  :\",\n        \"    int list list\",\n        // width 0\n        \"val it =\",\n        \"  ()\",\n        \"  :\",\n        \"    unit\",\n        \"val it =\",\n        \"  0\",\n        \"  :\",\n        \"    int\",\n        \"val it =\",\n        \"  [\",\n        \"   [\",\n        \"    1,\",\n        \"    2,\",\n        \"    3],\",\n        \"   [\",\n        \"    4,\",\n        \"    5],\",\n        \"   [\",\n        \"    6],\",\n        \"   []]\",\n        \"  :\",\n        \"    int list list\",\n        // width ~1\n        \"val it = () : unit\",\n        \"val it = ~1 : int\",\n        \"val it = [[1,2,3],[4,5],[6],[]] : int list list\",\n        \"\",\n    };\n    String expected = String.join(\"\\n\", lines);\n    fixture()\n        .withRaw(true)\n        .withInputString(inputString)\n        .assertOutput(is(expected));\n  }\n\n  /** Fixture for testing the shell.\n   *\n   * @see #fixture */\n  interface Fixture {\n    ImmutableList<String> DEFAULT_ARG_LIST =\n        ImmutableList.of(\"--prompt=false\", \"--system=false\", \"--banner=false\",\n            \"--terminal=dumb\");\n\n    List<String> argList();\n\n    Fixture withArgList(List<String> argList);\n\n    default Fixture withArgList(UnaryOperator<List<String>> transform) {\n      return withArgList(transform.apply(argList()));\n    }\n\n    default Fixture withArgListPlusDirectory() {\n      File useDirectory = getUseDirectory();\n      return withArgList(list -> plus(list, \"--directory=\" + useDirectory))\n          .withFile(useDirectory);\n    }\n\n    Fixture withFile(File file);\n\n    File getFile();\n\n    String inputString();\n\n    Fixture withInputString(String inputString);\n\n    Fixture withRaw(boolean raw);\n\n    boolean isRaw();\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    default Fixture assertOutput(Matcher<String> matcher) {\n      try {\n        if (isRaw()) {\n          try (Reader reader = new StringReader(inputString());\n               StringWriter writer = new StringWriter()) {\n            final List<String> argList = ImmutableList.of();\n            final Map<String, ForeignValue> valueMap = ImmutableMap.of();\n            final Map<Prop, Object> propMap = new LinkedHashMap<>();\n            Prop.DIRECTORY.set(propMap, getFile());\n            Prop.SCRIPT_DIRECTORY.set(propMap, getFile());\n            final Main main =\n                new Main(argList, reader, writer, valueMap, propMap, false);\n            main.run();\n            assertThat(writer.toString(), matcher);\n            return this;\n          }\n        }\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ByteArrayInputStream bais =\n            new ByteArrayInputStream(inputString().getBytes(UTF_8));\n        final Shell.Config config = Shell.parse(Shell.Config.DEFAULT, argList())\n            .withPauseFn(ShellTest::pauseForTenMilliseconds);\n        final Shell shell = Shell.create(config, bais, baos);\n        shell.run();\n        final String outString = baos.toString(UTF_8.name());\n        assertThat(outString, matcher);\n        return this;\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  /** Implementation of Fixture. */\n  private static class FixtureImpl implements Fixture {\n    final ImmutableList<String> argList;\n    final String inputString;\n    final boolean raw;\n    final File file;\n\n    FixtureImpl(ImmutableList<String> argList, String inputString,\n        boolean raw, File file) {\n      this.argList = requireNonNull(argList, \"argList\");\n      this.inputString = requireNonNull(inputString, \"inputString\");\n      this.raw = raw;\n      this.file = requireNonNull(file, \"file\");\n    }\n\n    @Override public List<String> argList() {\n      return argList;\n    }\n\n    @Override public Fixture withArgList(List<String> argList) {\n      if (this.argList.equals(argList)) {\n        return this;\n      }\n      ImmutableList<String> argList1 = ImmutableList.copyOf(argList);\n      return new FixtureImpl(argList1, inputString, raw, file);\n    }\n\n    @Override public File getFile() {\n      return file;\n    }\n\n    @Override public Fixture withFile(File file) {\n      if (file.equals(this.file)) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }\n\n    @Override public String inputString() {\n      return inputString;\n    }\n\n    @Override public Fixture withInputString(String inputString) {\n      if (this.inputString.equals(inputString)) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }\n\n    @Override public boolean isRaw() {\n      return raw;\n    }\n\n    @Override public Fixture withRaw(boolean raw) {\n      if (raw == this.raw) {\n        return this;\n      }\n      return new FixtureImpl(argList, inputString, raw, file);\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/LintTest.java.LintTest", "name": "LintTest", "file_path": "src/test/java/net/hydromatic/morel/LintTest.java", "superclasses": "", "methods": ["[void]testLint()"], "method_uris": ["src/test/java/net/hydromatic/morel/LintTest.java.LintTest.[Puffin.Program<GlobalState>]makeProgram()"], "overrides": null, "attributes": [{"original_string": "  private static class Message {\n    final Source source;\n    final int line;\n    final String message;\n\n    Message(Source source, int line, String message) {\n      this.source = source;\n      this.line = line;\n      this.message = message;\n    }\n\n    @Override public String toString() {\n      return source + \":\" + line + \":\" + message;\n    }\n  }", "definition": "  private static class Message", "class_docstring": " Warning that code is not as it should be.", "name": "Message", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Source source;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Source", "name": "source", "syntax_pass": true}, {"attribute_expression": "final int line;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "line", "syntax_pass": true}, {"attribute_expression": "final String message;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "message", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Message(Source source, int line, String message) {\n      this.source = source;\n      this.line = line;\n      this.message = message;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Message", "params": [{"name": "source", "type": "Source"}, {"name": "line", "type": "int"}, {"name": "message", "type": "String"}], "body": "                                                     {\n      this.source = source;\n      this.line = line;\n      this.message = message;\n    }", "signature": "Message(Source source, int line, String message)"}, {"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return source + \":\" + line + \":\" + message;\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return source + \":\" + line + \":\" + message;\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  private static class GlobalState {\n    int fileCount = 0;\n    final List<Message> messages = new ArrayList<>();\n  }", "definition": "  private static class GlobalState", "class_docstring": " Internal state of the lint rules.", "name": "GlobalState", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "int fileCount = 0;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "fileCount = 0", "syntax_pass": true}, {"attribute_expression": "final List<Message> messages = new ArrayList<>();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Message>", "name": "messages = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "  private static class FileState {\n    final GlobalState global;\n    int starLine;\n    int atLine;\n    int javadocStartLine;\n    int javadocEndLine;\n    int blockquoteCount;\n    int ulCount;\n\n    FileState(GlobalState global) {\n      this.global = global;\n    }\n\n    void message(String message, Puffin.Line<GlobalState, FileState> line) {\n      global.messages.add(new Message(line.source(), line.fnr(), message));\n    }\n\n    public boolean inJavadoc() {\n      return javadocEndLine < javadocStartLine;\n    }\n  }", "definition": "  private static class FileState", "class_docstring": " Internal state of the lint rules, per file.", "name": "FileState", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final GlobalState global;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "GlobalState", "name": "global", "syntax_pass": true}, {"attribute_expression": "int starLine;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "starLine", "syntax_pass": true}, {"attribute_expression": "int atLine;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "atLine", "syntax_pass": true}, {"attribute_expression": "int javadocStartLine;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "javadocStartLine", "syntax_pass": true}, {"attribute_expression": "int javadocEndLine;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "javadocEndLine", "syntax_pass": true}, {"attribute_expression": "int blockquoteCount;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "blockquoteCount", "syntax_pass": true}, {"attribute_expression": "int ulCount;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "ulCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    FileState(GlobalState global) {\n      this.global = global;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FileState", "params": [{"name": "global", "type": "GlobalState"}], "body": "                                  {\n      this.global = global;\n    }", "signature": "FileState(GlobalState global)"}, {"syntax_pass": true, "original_string": "    void message(String message, Puffin.Line<GlobalState, FileState> line) {\n      global.messages.add(new Message(line.source(), line.fnr(), message));\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "message", "params": [{"name": "message", "type": "String"}, {"name": "line", "type": "Puffin.Line<GlobalState, FileState>"}], "body": "                                                                           {\n      global.messages.add(new Message(line.source(), line.fnr(), message));\n    }", "signature": "void message(String message, Puffin.Line<GlobalState, FileState> line)"}, {"syntax_pass": true, "original_string": "    public boolean inJavadoc() {\n      return javadocEndLine < javadocStartLine;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inJavadoc", "params": [], "body": "                               {\n      return javadocEndLine < javadocStartLine;\n    }", "signature": "public boolean inJavadoc()"}]}], "class_docstring": " Runs Lint-like checks on the source code.\nAlso tests those checks.", "original_string": "public class LintTest {\n  @SuppressWarnings(\"Convert2MethodRef\") // JDK 8 requires lambdas\n  private Puffin.Program<GlobalState> makeProgram() {\n    return Puffin.builder(GlobalState::new, global -> new FileState(global))\n        .add(line -> line.isLast(),\n            line -> {\n              String f = line.filename();\n              final int slash = f.lastIndexOf('/');\n              final String endMarker =\n                  \"// End \" + (slash < 0 ? f : f.substring(slash + 1));\n              if (!line.line().equals(endMarker)\n                  && line.filename().endsWith(\".java\")) {\n                line.state().message(\"File must end with '\" + endMarker + \"'\",\n                    line);\n              }\n            })\n        .add(line -> line.fnr() == 1,\n            line -> line.globalState().fileCount++)\n\n        // Trailing space\n        .add(line -> line.endsWith(\" \"),\n            line -> line.state().message(\"Trailing space\", line))\n\n        // Tab\n        .add(line -> line.contains(\"\\t\"),\n            line -> line.state().message(\"Tab\", line))\n\n        // Nullable\n        .add(line -> line.startsWith(\"import javax.annotation.Nullable;\"),\n            line -> line.state().message(\n                \"use org.checkerframework.checker.nullness.qual.Nullable\",\n                line))\n\n        // Nonnull\n        .add(line -> line.startsWith(\"import javax.annotation.Nonnull;\"),\n            line -> line.state().message(\n                \"use org.checkerframework.checker.nullness.qual.NonNull\",\n                line))\n\n        // Use of 'Static.' other than in an import.\n        .add(line -> (line.contains(\"Assertions.\")\n                || line.contains(\"CoreMatchers.\")\n                || line.contains(\"MatcherAssert.assertThat\")\n                || line.contains(\"Objects.requireNonNull\")\n                || line.contains(\"Ord.forEachIndexed\")\n                || line.contains(\"Pair.forEach\")\n                || line.contains(\"Preconditions.\")\n                || line.contains(\"Static.\"))\n                && line.filename().endsWith(\".java\")\n                && !line.startsWith(\"import static\")\n                && !line.matches(\"^ *// .*$\")\n                && !line.endsWith(\"// lint:skip\")\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"LintTest.java\")).isPresent()\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"UtilTest.java\")).isPresent(),\n            line -> line.state().message(\"should be static import\", line))\n\n        // In a test,\n        //   assertThat(x.toString(), is(y));\n        // should be\n        //   assertThat(x, hasToString(y)));\n        .add(line -> line.contains(\".toString(), is(\")\n                && line.filename().endsWith(\".java\")\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"LintTest.java\")).isPresent(),\n            line -> line.state().message(\"use 'Matchers.hasToString'\", line))\n\n        // Comment without space\n        .add(line -> line.matches(\".* //[^ ].*\")\n                && !line.source().fileOpt()\n                .filter(f -> f.getName().equals(\"LintTest.java\")).isPresent()\n                && !line.contains(\"//--\")\n                && !line.contains(\"//~\")\n                && !line.contains(\"//noinspection\")\n                && !line.contains(\"//CHECKSTYLE\"),\n            line -> line.state().message(\"'//' must be followed by ' '\", line))\n\n        // Javadoc does not require '</p>', so we do not allow '</p>'\n        .add(line -> line.state().inJavadoc()\n                && line.contains(\"</p>\"),\n            line -> line.state().message(\"no '</p>'\", line))\n\n        // No \"**/\"\n        .add(line -> line.contains(\" **/\")\n                && line.state().inJavadoc(),\n            line ->\n                line.state().message(\"no '**/'; use '*/'\",\n                    line))\n\n        // A Javadoc paragraph '<p>' must not be on its own line.\n        .add(line -> line.matches(\"^ *\\\\* <p>\"),\n            line ->\n                line.state().message(\"<p> must not be on its own line\",\n                    line))\n\n        // A Javadoc paragraph '<p>' must be preceded by a blank Javadoc\n        // line.\n        .add(line -> line.matches(\"^ *\\\\*\"),\n            line -> {\n              final FileState f = line.state();\n              if (f.starLine == line.fnr() - 1) {\n                f.message(\"duplicate empty line in javadoc\", line);\n              }\n              f.starLine = line.fnr();\n            })\n        .add(line -> line.matches(\"^ *\\\\* <p>.*\")\n                && line.fnr() - 1 != line.state().starLine,\n            line ->\n                line.state().message(\"<p> must be preceded by blank line\",\n                    line))\n\n        // A non-blank line following a blank line must have a '<p>'\n        .add(line -> line.state().inJavadoc()\n                && line.state().ulCount == 0\n                && line.state().blockquoteCount == 0\n                && line.contains(\"* \")\n                && line.fnr() - 1 == line.state().starLine\n                && line.matches(\"^ *\\\\* [^<@].*\"),\n            line -> line.state().message(\"missing '<p>'\", line))\n\n        // The first \"@param\" of a javadoc block must be preceded by a blank\n        // line.\n        .add(line -> line.matches(\"^ */\\\\*\\\\*.*\"),\n            line -> {\n              final FileState f = line.state();\n              f.javadocStartLine = line.fnr();\n              f.blockquoteCount = 0;\n              f.ulCount = 0;\n            })\n        .add(line -> line.matches(\".*\\\\*/\"),\n            line -> line.state().javadocEndLine = line.fnr())\n        .add(line -> line.matches(\"^ *\\\\* @.*\"),\n            line -> {\n              if (line.state().inJavadoc()\n                  && line.state().atLine < line.state().javadocStartLine\n                  && line.fnr() - 1 != line.state().starLine) {\n                line.state().message(\n                    \"First @tag must be preceded by blank line\",\n                    line);\n              }\n              line.state().atLine = line.fnr();\n            })\n        .add(line -> line.contains(\"<blockquote>\"),\n            line -> line.state().blockquoteCount++)\n        .add(line -> line.contains(\"</blockquote>\"),\n            line -> line.state().blockquoteCount--)\n        .add(line -> line.contains(\"<ul>\"),\n            line -> line.state().ulCount++)\n        .add(line -> line.contains(\"</ul>\"),\n            line -> line.state().ulCount--)\n        .build();\n  }\n\n  /** Tests that source code has no flaws. */\n  @Test void testLint() {\n    assumeTrue(TestUnsafe.haveGit(), \"Invalid git environment\");\n\n    final Puffin.Program<GlobalState> program = makeProgram();\n    final List<File> javaFiles = TestUnsafe.getTextFiles();\n\n    final GlobalState g;\n    StringWriter b = new StringWriter();\n    try (PrintWriter pw = new PrintWriter(b)) {\n      g = program.execute(javaFiles.parallelStream().map(Sources::of), pw);\n    }\n\n    assertThat(\"Lint violations:\\n\" + b, g.messages, empty());\n  }\n\n  /** Warning that code is not as it should be. */\n  private static class Message {\n    final Source source;\n    final int line;\n    final String message;\n\n    Message(Source source, int line, String message) {\n      this.source = source;\n      this.line = line;\n      this.message = message;\n    }\n\n    @Override public String toString() {\n      return source + \":\" + line + \":\" + message;\n    }\n  }\n\n  /** Internal state of the lint rules. */\n  private static class GlobalState {\n    int fileCount = 0;\n    final List<Message> messages = new ArrayList<>();\n  }\n\n  /** Internal state of the lint rules, per file. */\n  private static class FileState {\n    final GlobalState global;\n    int starLine;\n    int atLine;\n    int javadocStartLine;\n    int javadocEndLine;\n    int blockquoteCount;\n    int ulCount;\n\n    FileState(GlobalState global) {\n      this.global = global;\n    }\n\n    void message(String message, Puffin.Line<GlobalState, FileState> line) {\n      global.messages.add(new Message(line.source(), line.fnr(), message));\n    }\n\n    public boolean inJavadoc() {\n      return javadocEndLine < javadocStartLine;\n    }\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest", "name": "UtilTest", "file_path": "src/test/java/net/hydromatic/morel/UtilTest.java", "superclasses": "", "methods": ["[void]testTailList()", "[void]testOrd()", "[void]testMapList()", "[void]testFolder()", "[void]testShorterThan()", "[void]testFind()", "[void]testPos()", "[void]testPower()", "[void]testTransform()", "[void]testToString()", "[void]testFloatBit()", "[void]testPairAllMatch()", "[void]testRangeExtent()"], "method_uris": ["src/test/java/net/hydromatic/morel/UtilTest.java.UtilTest.[void]checkShorterThan(Iterable<E>,int)"], "overrides": null, "attributes": [], "class_docstring": " Tests for various utility classes.", "original_string": "public class UtilTest {\n  /** Tests {@link TailList}. */\n  @Test void testTailList() {\n    final List<String> list = new ArrayList<>();\n    list.add(\"a\");\n    list.add(\"b\");\n\n    final List<String> tailList = new TailList<>(list);\n    assertThat(tailList.size(), is(0));\n    list.add(\"c\");\n    assertThat(tailList.size(), is(1));\n    assertThat(tailList.get(0), is(\"c\"));\n    assertThat(tailList, hasToString(\"[c]\"));\n\n    tailList.set(0, \"d\");\n    assertThat(tailList, hasToString(\"[d]\"));\n\n    tailList.add(0, \"e\");\n    assertThat(tailList, hasToString(\"[e, d]\"));\n\n    final StringBuilder s = new StringBuilder();\n    for (String item : tailList) {\n      s.append(item);\n    }\n    assertThat(s, hasToString(\"ed\"));\n\n    tailList.add(\"f\");\n    assertThat(tailList, hasToString(\"[e, d, f]\"));\n    assertThat(list.size(), is(5));\n\n    tailList.addAll(Arrays.asList(\"x\", \"y\", \"z\"));\n    assertThat(tailList, hasToString(\"[e, d, f, x, y, z]\"));\n\n    tailList.clear();\n    assertThat(tailList.size(), is(0));\n    assertThat(tailList.isEmpty(), is(true));\n    assertThat(list.size(), is(2));\n    assertThat(list.isEmpty(), is(false));\n  }\n\n  @Test void testOrd() {\n    final List<String> abc = Arrays.asList(\"a\", \"b\", \"c\");\n    final StringBuilder buf = new StringBuilder();\n    forEachIndexed(abc, (e, i) ->\n        buf.append(i).append(\"#\").append(e).append(\";\"));\n    assertThat(buf, hasToString(\"0#a;1#b;2#c;\"));\n  }\n\n  @Test void testMapList() {\n    final List<String> abc =\n        MapList.of(3, i -> \"\" + (char) ('a' + i));\n    assertThat(abc.size(), is(3));\n    assertThat(abc.get(0), is(\"a\"));\n    assertThat(abc.get(2), is(\"c\"));\n    assertThat(String.join(\",\", abc), is(\"a,b,c\"));\n  }\n\n  @Test void testFolder() {\n    final List<Folder<Ast.Exp>> list = new ArrayList<>();\n    Folder.start(list, ast.stringLiteral(Pos.ZERO, \"a\"));\n    Folder.at(list, ast.stringLiteral(Pos.ZERO, \"b\"));\n    Folder.at(list, ast.stringLiteral(Pos.ZERO, \"c\"));\n    assertThat(Folder.combineAll(list), hasToString(\"\\\"a\\\" @ \\\"b\\\" @ \\\"c\\\"\"));\n\n    list.clear();\n    Folder.start(list, ast.stringLiteral(Pos.ZERO, \"a\"));\n    Folder.cons(list, ast.stringLiteral(Pos.ZERO, \"b\"));\n    assertThat(Folder.combineAll(list), hasToString(\"\\\"a\\\" :: \\\"b\\\"\"));\n  }\n\n  /** Tests {@link Static#shorterThan(Iterable, int)}. */\n  @Test void testShorterThan() {\n    // A list of length n is shorter than n + 1, but not shorter than n\n    final List<Integer> list2 = Arrays.asList(0, 1);\n    assertThat(Static.shorterThan(list2, 1), is(false));\n    assertThat(Static.shorterThan(list2, 2), is(false));\n    assertThat(Static.shorterThan(list2, 3), is(true));\n\n    // Collections of length 3\n    final List<Integer> list3 = ImmutableIntList.identity(3);\n    final HashSet<Integer> set3 = new HashSet<>(list3);\n    final Iterable<Integer> iterable3 = list3::iterator;\n    assertThat(iterable3, not(instanceOf(Collection.class)));\n    checkShorterThan(list3, 3);\n    checkShorterThan(set3, 3);\n    checkShorterThan(iterable3, 3);\n\n    // Collections of length 1\n    final Set<String> set1 = Collections.singleton(\"x\");\n    final List<String> list1 = new ArrayList<>(set1);\n    final Iterable<String> iterable1 = list1::iterator;\n    assertThat(iterable1, not(instanceOf(Collection.class)));\n    checkShorterThan(list1, 1);\n    checkShorterThan(set1, 1);\n    checkShorterThan(iterable1, 1);\n\n    // Empty collections\n    final Set<String> set0 = Collections.emptySet();\n    final List<String> list0 = Collections.emptyList();\n    final Iterable<String> iterable0 = set0::iterator;\n    assertThat(iterable0, not(instanceOf(Collection.class)));\n    checkShorterThan(list0, 0);\n    checkShorterThan(set0, 0);\n    checkShorterThan(iterable0, 0);\n\n    // Very large collections (too large to materialize)\n    final int bigSize = Integer.MAX_VALUE - 10;\n    final List<Integer> listBig = Util.range(bigSize);\n    final Iterable<Integer> iterableBig = listBig::iterator;\n    assertThat(iterableBig, not(instanceOf(Collection.class)));\n    checkShorterThan(listBig, bigSize);\n  }\n\n  private <E> void checkShorterThan(Iterable<E> iterable, int size) {\n    assertThat(Static.shorterThan(iterable, -1), is(size < -1));\n    assertThat(Static.shorterThan(iterable, 0), is(size < 0));\n    assertThat(Static.shorterThan(iterable, 1), is(size < 1));\n    assertThat(Static.shorterThan(iterable, 2), is(size < 2));\n    assertThat(Static.shorterThan(iterable, 3), is(size < 3));\n    assertThat(Static.shorterThan(iterable, 4), is(size < 4));\n    assertThat(Static.shorterThan(iterable, 1_000_000), is(size < 1_000_000));\n  }\n\n  /** Tests {@link Static#find(List, Predicate)}. */\n  @Test void testFind() {\n    final List<Integer> list = Arrays.asList(1, 7, 3);\n    final List<Integer> emptyList = Collections.emptyList();\n    assertThat(Static.find(list, i -> i > 0), is(0));\n    assertThat(Static.find(list, i -> i > 1), is(1));\n    assertThat(Static.find(list, i -> i > 10), is(-1));\n    assertThat(Static.find(emptyList, i -> i > 0), is(-1));\n  }\n\n  /** Unit tests for {@link Pos}. */\n  @Test void testPos() {\n    final BiConsumer<String, String> check = (s, posString) -> {\n      final Pair<String, Pos> pos = Pos.split(s, '$', \"stdIn\");\n      assertThat(pos.left, is(\"abcdefgh\"));\n      assertThat(pos.right, notNullValue());\n      assertThat(pos.right, hasToString(posString));\n    };\n    // starts and ends in middle\n    check.accept(\"abc$def$gh\", \"stdIn:1.4-1.7\");\n    // ends at end\n    check.accept(\"abc$defgh$\", \"stdIn:1.4-1.9\");\n    // starts at start\n    check.accept(\"$abc$defgh\", \"stdIn:1.1-1.4\");\n    // one character long\n    check.accept(\"abc$d$efgh\", \"stdIn:1.4\");\n\n    final BiConsumer<String, String> check2 = (s, posString) -> {\n      final Pair<String, Pos> pos = Pos.split(s, '$', \"stdIn\");\n      assertThat(pos.left,\n          is(\"abc\\n\"\n              + \"de\\n\"\n              + \"\\n\"\n              + \"fgh\"));\n      assertThat(pos.right, notNullValue());\n      assertThat(pos.right, hasToString(posString));\n    };\n    // start of line\n    check2.accept(\"abc\\n\"\n        + \"$de$\\n\"\n        + \"\\n\"\n        + \"fgh\", \"stdIn:2.1-2.3\");\n    // spans multiple lines\n    check2.accept(\"abc\\n\"\n        + \"d$e\\n\"\n        + \"\\n\"\n        + \"fg$h\", \"stdIn:2.2-4.3\");\n\n    // too many, too few\n    Consumer<String> checkTooFew = s -> {\n      try {\n        final Pair<String, Pos> pos4 = Pos.split(s, '$', \"stdIn\");\n        fail(\"expected error, got \" + pos4);\n      } catch (IllegalArgumentException e) {\n        assertThat(e.getMessage(),\n            is(\"expected exactly two occurrences of delimiter, '$'\"));\n      }\n    };\n    checkTooFew.accept(\"$abc$de$f\");\n    checkTooFew.accept(\"abc$def\");\n    checkTooFew.accept(\"abcdef\");\n  }\n\n  /** Tests {@link Static#nextPowerOfTwo(int)}. */\n  @Test void testPower() {\n    assertThat(nextPowerOfTwo(0), is(1));\n    assertThat(nextPowerOfTwo(-1), is(1)); // 2^16\n    assertThat(nextPowerOfTwo(-2), is(1)); // 2^16\n    assertThat(nextPowerOfTwo(-3), is(1)); // 2^16\n    assertThat(nextPowerOfTwo(-4), is(1)); // 2^16\n    assertThat(nextPowerOfTwo(-65_536), is(1)); // 2^16\n\n    assertThat(nextPowerOfTwo(1), is(2));\n    assertThat(nextPowerOfTwo(2), is(4));\n    assertThat(nextPowerOfTwo(3), is(4));\n    assertThat(nextPowerOfTwo(4), is(8));\n    assertThat(nextPowerOfTwo(5), is(8));\n\n    assertThat(nextPowerOfTwo(16_383), is(16_384)); // 2^14\n    assertThat(nextPowerOfTwo(16_384), is(32_768)); // 2^15\n    assertThat(nextPowerOfTwo(16_384), is(32_768));\n    assertThat(nextPowerOfTwo(32_768), is(65_536)); // 2^16\n\n    assertThat(nextPowerOfTwo(1_073_741_823), is(1_073_741_824)); // 2^31\n    assertThat(nextPowerOfTwo(1_073_741_824), is(-2_147_483_648)); // 2^32\n    assertThat(nextPowerOfTwo(2_147_483_647), is(-2_147_483_648)); // 2^32\n    assertThat(nextPowerOfTwo(-2_147_483_648), is(1)); // 2^0\n  }\n\n  @Test void testTransform() {\n    final List<String> list = Arrays.asList(\"john\", \"paul\", \"george\", \"ringo\");\n    assertThat(transform(list, String::length), is(Arrays.asList(4, 4, 6, 5)));\n    assertThat(transform(Collections.emptyList(), String::length),\n        is(Collections.emptyList()));\n  }\n\n  /** Tests that {@code Real.toString} returns values consistent with JDK 19 and\n   * later, incorporating the fix to\n   * <a href=\"https://bugs.openjdk.org/browse/JDK-4511638\">[JDK-4511638]\n   * Double.toString(double) sometimes produces incorrect results</a>. */\n  @Test void testToString() {\n    Function<String, String> fn = s -> {\n      float f = Float.parseFloat(s);\n      return Codes.floatToString(f);\n    };\n    assertThat(fn.apply(\"1.17549435E-38\"), is(\"1.1754944E~38\"));\n    assertThat(fn.apply(\"1.1754944E-38\"), is(\"1.1754944E~38\"));\n\n    assertThat(fn.apply(\"1.23456795E12\"), is(\"1.234568E12\"));\n    assertThat(fn.apply(\"1.234568E12\"), is(\"1.234568E12\"));\n\n    assertThat(fn.apply(\"1.23456791E11\"), is(\"1.2345679E11\"));\n    assertThat(fn.apply(\"1.2345679E11\"), is(\"1.2345679E11\"));\n\n    assertThat(fn.apply(\"1.23456788E10\"), is(\"1.2345679E10\"));\n    assertThat(fn.apply(\"1.2345679E10\"), is(\"1.2345679E10\"));\n\n    assertThat(fn.apply(\"1.23456792E8\"), is(\"1.2345679E8\"));\n    assertThat(fn.apply(\"1.2345679E8\"), is(\"1.2345679E8\"));\n\n    assertThat(fn.apply(\"1.0\"), is(\"1.0\"));\n    assertThat(fn.apply(\"-1.234\"), is(\"~1.234\"));\n    assertThat(fn.apply(\"-1.234e-10\"), is(\"~1.234E~10\"));\n  }\n\n  /** Tests the {@link Codes#isNegative(float)} function,\n   * which is used to implement {@code Real.signBit}. */\n  @SuppressWarnings(\"ConstantValue\")\n  @Test void testFloatBit() {\n    assertThat(isNegative(0f), is(false));\n    assertThat(isNegative(3.5f), is(false));\n    assertThat(isNegative(Float.POSITIVE_INFINITY), is(false));\n    assertThat(isNegative(-0f), is(true));\n    assertThat(isNegative(-10.25f), is(true));\n    assertThat(isNegative(Float.NEGATIVE_INFINITY), is(true));\n\n    // The standard basis library is unclear, but in SMLNJ and Mlton\n    // nan is negative, and we do the same.\n    assertThat(isNegative(Float.NaN), is(true));\n    // In SMLNJ and Mlton ~nan is positive, and we do the same.\n    assertThat(isNegative(Codes.NEGATIVE_NAN), is(false));\n    assertThat(Float.isNaN(Float.NaN), is(true));\n    assertThat(Float.isNaN(Codes.NEGATIVE_NAN), is(true));\n  }\n\n  @Test void testPairAllMatch() {\n    final List<Integer> list1 = Arrays.asList(1, 3, 5);\n    final List<Integer> list2 = Arrays.asList(2, 3, 4);\n    final List<Integer> list0 = Collections.emptyList();\n    assertThat(Pair.anyMatch(list1, list2, Objects::equals), is(true));\n    assertThat(Pair.allMatch(list1, list2, Objects::equals), is(false));\n    assertThat(Pair.noneMatch(list1, list2, Objects::equals), is(false));\n\n    assertThat(Pair.anyMatch(list1, list2, (i, j) -> i == 0), is(false));\n    assertThat(Pair.allMatch(list1, list2, (i, j) -> i == 0), is(false));\n    assertThat(Pair.noneMatch(list1, list2, (i, j) -> i == 0), is(true));\n\n    assertThat(Pair.anyMatch(list1, list2, (i, j) -> i > 0), is(true));\n    assertThat(Pair.allMatch(list1, list2, (i, j) -> i > 0), is(true));\n    assertThat(Pair.noneMatch(list1, list2, (i, j) -> i > 0), is(false));\n\n    assertThat(Pair.anyMatch(list0, list0, (i, j) -> true), is(false));\n    assertThat(Pair.allMatch(list0, list0, (i, j) -> true), is(true));\n    assertThat(Pair.noneMatch(list0, list0, (i, j) -> true), is(true));\n  }\n\n  @SuppressWarnings(\"UnstableApiUsage\")\n  @Test void testRangeExtent() {\n    final TypeSystem typeSystem = new TypeSystem();\n    BuiltIn.dataTypes(typeSystem, new ArrayList<>());\n\n    // Integer range [(4, 7]]\n    final Range<BigDecimal> range =\n        Range.openClosed(BigDecimal.valueOf(4), BigDecimal.valueOf(7));\n    final RangeExtent rangeExtent =\n        new RangeExtent(typeSystem, PrimitiveType.INT,\n            ImmutableMap.of(\"/\", ImmutableRangeSet.of(range)));\n    assertThat(rangeExtent.iterable, notNullValue());\n    assertThat(Lists.newArrayList(rangeExtent.iterable),\n        is(Arrays.asList(5, 6, 7)));\n\n    // Integer range set [(4, 7], [10, 12]]\n    final Range<BigDecimal> range2 =\n        Range.closed(BigDecimal.valueOf(10), BigDecimal.valueOf(12));\n    final RangeExtent rangeExtent2 =\n        new RangeExtent(\n            typeSystem, PrimitiveType.INT,\n            ImmutableMap.of(\"/\",\n                ImmutableRangeSet.unionOf(ImmutableList.of(range, range2))));\n    assertThat(rangeExtent2.iterable, notNullValue());\n    assertThat(Lists.newArrayList(rangeExtent2.iterable),\n        is(Arrays.asList(5, 6, 7, 10, 11, 12)));\n\n    // Boolean range set\n    final Range<Boolean> range3 = Range.closed(false, true);\n    final RangeExtent rangeExtent3 =\n        new RangeExtent(typeSystem, PrimitiveType.BOOL,\n            ImmutableMap.of(\"/\", ImmutableRangeSet.of(range3)));\n    assertThat(rangeExtent3.iterable, notNullValue());\n    assertThat(Lists.newArrayList(rangeExtent3.iterable),\n        is(Arrays.asList(false, true)));\n\n    // Range set of (Boolean, Boolean) tuples\n    final Range<Comparable> range4 =\n        Range.closed((Comparable) FlatLists.of(false, true),\n            (Comparable) FlatLists.of(true, true));\n    final RangeExtent rangeExtent4 =\n        new RangeExtent(typeSystem,\n            typeSystem.tupleType(PrimitiveType.BOOL, PrimitiveType.BOOL),\n            ImmutableMap.of(\"/\", ImmutableRangeSet.of(range4)));\n    assertThat(rangeExtent4.iterable, notNullValue());\n    assertThat(Lists.newArrayList(rangeExtent4.iterable),\n        is(\n            Arrays.asList(FlatLists.of(false, true),\n                FlatLists.of(true, false), FlatLists.of(true, true))));\n\n    // Range set of (boolean option, int) tuples\n    final RangeExtent rangeExtent5 =\n        new RangeExtent(typeSystem,\n            typeSystem.tupleType(\n                typeSystem.option(PrimitiveType.BOOL),\n                PrimitiveType.INT),\n            ImmutableMap.of(\"/1/SOME/\",\n                ImmutableRangeSet.of(Range.singleton(true)),\n                \"/2/\",\n                ImmutableRangeSet.of(\n                    Range.closed(BigDecimal.valueOf(4),\n                        BigDecimal.valueOf(6)))));\n    assertThat(rangeExtent5.iterable, notNullValue());\n    assertThat(ImmutableList.copyOf(rangeExtent5.iterable),\n        hasToString(\"[[[NONE], 4], [[NONE], 5], [[NONE], 6],\"\n            + \" [[SOME, true], 4], [[SOME, true], 5], [[SOME, true], 6]]\"));\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest", "name": "ScriptTest", "file_path": "src/test/java/net/hydromatic/morel/ScriptTest.java", "superclasses": "", "methods": ["[void]test(String)", "[void]testScript()"], "method_uris": ["src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[]ScriptTest()", "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[void]main(String[])", "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[Stream<Arguments>]data()", "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[Method]findMethod(String)", "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[void]checkRun(String)", "src/test/java/net/hydromatic/morel/ScriptTest.java.ScriptTest.[Stream<Arguments>]data_(String)"], "overrides": null, "attributes": [], "class_docstring": "\nTest that runs files and checks the results.\n", "original_string": "public class ScriptTest {\n  public ScriptTest() {\n  }\n\n  /** Runs a test from the command line.\n   *\n   * <p>For example:\n   *\n   * <blockquote>\n   *   <code>java ScriptTest script/table.sml</code>\n   * </blockquote> */\n  public static void main(String[] args) throws Exception {\n    for (String arg : args) {\n      new ScriptTest().test(arg);\n    }\n  }\n\n  /** For {@link ParameterizedTest} runner. */\n  @SuppressWarnings(\"unused\")\n  static Stream<Arguments> data() {\n    // Start with a test file we know exists, then find the directory and list\n    // its files.\n    final String first = \"script/simple.smli\";\n    return data_(first);\n  }\n\n  @ParameterizedTest @MethodSource(\"data\") void test(String path)\n      throws Exception {\n    Method method = findMethod(path);\n    if (method != null) {\n      try {\n        method.invoke(this);\n      } catch (InvocationTargetException e) {\n        Throwable cause = e.getCause();\n        if (cause instanceof Exception) {\n          throw (Exception) cause;\n        }\n        if (cause instanceof Error) {\n          throw (Error) cause;\n        }\n        throw e;\n      }\n    } else {\n      checkRun(path);\n    }\n  }\n\n  private Method findMethod(String path) {\n    // E.g. path \"script/simple.sml\" gives method \"testScriptSimple\"\n    String methodName = toCamelCase(\"test_\"\n        + path.replace(File.separatorChar, '_').replaceAll(\"\\\\.sml$\", \"\"));\n    Method m;\n    try {\n      m = getClass().getMethod(methodName);\n    } catch (NoSuchMethodException e) {\n      m = null;\n    }\n    return m;\n  }\n\n  protected void checkRun(String path) throws Exception {\n    final File inFile;\n    final File outFile;\n    final File f = new File(path);\n    final boolean idempotent = path.endsWith(\".smli\");\n    if (f.isAbsolute()) {\n      // e.g. path = \"/tmp/foo.sml\"\n      inFile = f;\n      outFile = new File(path + \".out\");\n    } else {\n      // e.g. path = \"sql/outer.sml\"\n      // inUrl = \"file:/home/fred/morel/target/test-classes/script/outer.sml\"\n      final URL inUrl = MainTest.class.getResource(\"/\" + n2u(path));\n      assertThat(inUrl, notNullValue());\n      inFile = urlToFile(inUrl);\n      assertThat(inFile, notNullValue());\n      String outPath = idempotent ? path : path + \".out\";\n      outFile =\n          new File(inFile.getAbsoluteFile().getParent(),\n              u2n(\"surefire/\") + outPath);\n    }\n    TestUtils.discard(outFile.getParentFile().mkdirs());\n    final List<String> argList = ImmutableList.of(\"--echo\");\n    final File scriptDirectory = inFile.getParentFile();\n    final boolean loadDictionary =\n        inFile.getPath()\n            .matches(\".*/(blog|dummy|foreign|hybrid|suchThat)\\\\.(sml|smli)\");\n    final Map<String, ForeignValue> dictionary =\n        loadDictionary\n            ? Calcite.withDataSets(BuiltInDataSet.DICTIONARY).foreignValues()\n            : ImmutableMap.of();\n\n    final Map<Prop, Object> propMap = new LinkedHashMap<>();\n    File directory = scriptDirectory;\n    for (File d = scriptDirectory; d != null; d = d.getParentFile()) {\n      if (d.getName().equals(\"script\")) {\n        directory = d.getParentFile();\n        break;\n      }\n    }\n    // For the \"file.smli\" test, move to a subdirectory; it's more predictable\n    if (inFile.getPath().matches(\".*/(file)\\\\.(sml|smli)\")) {\n      directory = new File(directory, \"data\");\n    }\n    Prop.DIRECTORY.set(propMap, directory);\n    Prop.SCRIPT_DIRECTORY.set(propMap, scriptDirectory);\n\n    try (Reader reader = TestUtils.reader(inFile);\n         Writer writer = TestUtils.printWriter(outFile)) {\n      Main main =\n          new Main(argList, reader, writer, dictionary, propMap, idempotent);\n      main.run();\n    }\n    final String inName =\n        idempotent ? inFile.getName() : inFile.getName() + \".out\";\n    final File refFile = new File(inFile.getParentFile(), inName);\n    if (!refFile.exists()) {\n      System.out.println(\"Reference file not found: \" + refFile);\n    }\n    final String diff = TestUtils.diff(refFile, outFile);\n    if (!diff.isEmpty()) {\n      fail(\"Files differ: \" + refFile + \" \" + outFile + \"\\n\"\n          + diff);\n    }\n  }\n\n  @SuppressWarnings(\"SameParameterValue\")\n  protected static Stream<Arguments> data_(String first) {\n    // inUrl = \"file:/home/fred/morel/target/test-classes/script/agg.sml\"\n    final URL inUrl = MainTest.class.getResource(\"/\" + n2u(first));\n    assertThat(inUrl, notNullValue());\n    final File firstFile = urlToFile(inUrl);\n    assertThat(firstFile, notNullValue());\n    final int commonPrefixLength =\n        firstFile.getAbsolutePath().length() - first.length();\n    final File dir = firstFile.getParentFile();\n    @SuppressWarnings(\"UnstableApiUsage\") final FilenameFilter filter =\n        new PatternFilenameFilter(\".*\\\\.(sml|smli)$\");\n    File[] files = dir.listFiles(filter);\n    return Stream.of(first(files, new File[0]))\n        .map(f ->\n            Arguments.of(f.getAbsolutePath().substring(commonPrefixLength)));\n  }\n\n  @Test void testScript() throws Exception {\n    checkRun(\"script.sml\");\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest", "name": "AlgebraTest", "file_path": "src/test/java/net/hydromatic/morel/AlgebraTest.java", "superclasses": "", "methods": ["[void]testScott()", "[void]testScott2()", "[void]testScottOrder()", "[void]testScottJoin()", "[void]testScottJoin2()", "[void]testScottJoin2Dot()", "[void]testQueryList()", "[void]testNative()", "[void]testHybridCalciteToMorel()", "[void]testFullCalcite()", "[void]testFullCalcite2()", "[void]testFullCalcite3()", "[void]testCalciteFrom()", "[void]testCalciteWithVariable()", "[void]testCalciteWithVariableNoInlining()", "[void]testCalciteWithFunction()", "[void]testCalciteWithHybridFunction()", "[void]testUnion()", "[void]testExcept()", "[void]testIntersect()", "[void]testElem()", "[void]testNotElem()", "[void]testExists()", "[void]testNotExists()", "[void]testExistsCorrelated()", "[void]testCorrelatedListSubQuery()", "[void]testCorrelatedScalar()", "[void]testRecursive()", "[void]testRecursive2()"], "method_uris": ["src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]checkFullCalcite(String)", "src/test/java/net/hydromatic/morel/AlgebraTest.java.AlgebraTest.[void]checkCalciteWithVariable(int,String)"], "overrides": null, "attributes": [], "class_docstring": "\nTests translation of Morel programs to Apache Calcite relational algebra.\n", "original_string": "public class AlgebraTest {\n  /** Tests a program that uses an external collection from the \"scott\" JDBC\n   * database. */\n  @Test void testScott() {\n    final String ml = \"let\\n\"\n        + \"  val emps = #emp scott\\n\"\n        + \"in\\n\"\n        + \"  from e in emps yield #deptno e\\n\"\n        + \"end\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"int list\")\n        .assertEvalIter(\n            equalsOrdered(20, 30, 30, 20, 30, 30, 10, 20, 10, 30, 20, 30, 20,\n                10));\n  }\n\n  /** As previous, but with more concise syntax. */\n  @Test void testScott2() {\n    final String ml = \"from e in scott.emp yield e.deptno\";\n    final String plan = \"LogicalProject(deptno=[$7])\\n\"\n        + \"  JdbcTableScan(table=[[scott, EMP]])\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"int list\")\n        .assertCalcite(is(plan))\n        .assertEvalIter(\n            equalsOrdered(20, 30, 30, 20, 30, 30, 10, 20, 10, 30, 20, 30, 20,\n                10));\n  }\n\n  @Test void testScottOrder() {\n    final String ml = \"from e in scott.emp\\n\"\n        + \" yield {e.empno, e.deptno}\\n\"\n        + \" order empno desc\\n\"\n        + \" skip 2 take 4\";\n    // When fixed,\n    //   [CALCITE-6128] RelBuilder.sortLimit should compose offset and fetch\n    // will yield a plan with one fewer LogicalSort\n    final String plan = \"LogicalSort(fetch=[4])\\n\"\n        + \"  LogicalSort(sort0=[$1], dir0=[DESC], offset=[2])\\n\"\n        + \"    LogicalProject(deptno=[$7], empno=[$0])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{deptno:int, empno:int} list\")\n        .assertCalcite(is(plan))\n        .assertEvalIter(\n            equalsOrdered(list(30, 7900), list(20, 7876), list(30, 7844),\n                list(10, 7839)));\n  }\n\n  @Test void testScottJoin() {\n    final String ml = \"let\\n\"\n        + \"  val emps = #emp scott\\n\"\n        + \"  and depts = #dept scott\\n\"\n        + \"in\\n\"\n        + \"  from e in emps, d in depts\\n\"\n        + \"    where #deptno e = #deptno d\\n\"\n        + \"    andalso #empno e >= 7900\\n\"\n        + \"    yield {empno = #empno e, dname = #dname d}\\n\"\n        + \"end\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dname:string, empno:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(\"SALES\", 7900), list(\"RESEARCH\", 7902),\n                list(\"ACCOUNTING\", 7934)));\n  }\n\n  /** As {@link #testScottJoin()} but without intermediate variables. */\n  @Test void testScottJoin2() {\n    final String ml = \"from e in #emp scott, d in #dept scott\\n\"\n        + \"  where #deptno e = #deptno d\\n\"\n        + \"  andalso #empno e >= 7900\\n\"\n        + \"  yield {empno = #empno e, dname = #dname d}\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dname:string, empno:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(\"SALES\", 7900), list(\"RESEARCH\", 7902),\n                list(\"ACCOUNTING\", 7934)));\n  }\n\n  /** As {@link #testScottJoin2()} but using dot notation ('e.field' rather\n   * than '#field e'). */\n  @Test void testScottJoin2Dot() {\n    final String ml = \"from e in scott.emp, d in scott.dept\\n\"\n        + \"  where e.deptno = d.deptno\\n\"\n        + \"  andalso e.empno >= 7900\\n\"\n        + \"  yield {empno = e.empno, dname = d.dname}\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dname:string, empno:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(\"SALES\", 7900), list(\"RESEARCH\", 7902),\n                list(\"ACCOUNTING\", 7934)));\n  }\n\n  /** Tests that Morel gives the same answer with and without Calcite. */\n  @Test void testQueryList() {\n    final String[] queries = {\n        \"from\",\n        \"from e in scott.emp\",\n        \"from e in scott.emp yield e.deptno\",\n        \"from e in scott.emp yield {e.deptno, e.ename}\",\n        \"from e in scott.emp yield {e.ename, e.deptno}\",\n        \"from e in scott.emp\\n\"\n            + \"  yield {e.ename, x = e.deptno + e.empno, b = true, \"\n            // + \"c = #\\\"c\\\", \"\n            + \"i = 3, r = 3.14, \"\n            // + \"u = (), \"\n            + \"s = \\\"hello\\\"}\",\n        \"from e in scott.emp yield ()\",\n        \"from e in scott.emp yield e\",\n        \"from e in scott.emp where e.job = \\\"CLERK\\\" yield e\",\n        \"from n in [1,2,3] yield n\",\n        \"from n in [1,2,3] where n mod 2 = 1 andalso n < 3 yield n\",\n        \"from n in [1,2,3] where false yield n\",\n        \"from n in [1,2,3] where n < 2 orelse n > 2 yield n * 3\",\n        \"from r in [{a=1,b=2},{a=1,b=0},{a=2,b=1}]\\n\"\n            + \"  order r.a desc, r.b\\n\"\n            + \"  yield {r.a, b10 = r.b * 10}\",\n        \"from r in [{a=2,b=3},{a=2,b=1},{a=1,b=1}]\\n\"\n            + \"  group r.a\",\n        \"from r in [{a=2,b=3},{a=2,b=1},{a=1,b=1}]\\n\"\n            + \"  group compute sb = sum of r.b\",\n        \"from r in [{a=2,b=3},{a=2,b=1},{a=1,b=1}]\\n\"\n            + \"  group r.a\\n\"\n            + \"  yield a\",\n        \"from r in [{a=2,b=3}]\\n\"\n            + \"group r.b compute sb = sum of r.b,\\n\"\n            + \"    mb = min of r.b, a = count\",\n        \"from r in [{a=2,b=3}]\\n\"\n            + \"group r.b compute sb = sum of r.b,\\n\"\n            + \"    mb = min of r.b, a = count\\n\"\n            + \"yield {a, a2 = a + b, sb}\",\n        \"from e in scott.emp\\n\"\n            + \"yield {e.ename, x = e.deptno * 2}\",\n        \"from e in scott.emp\\n\"\n            + \"order e.ename\",\n        \"from e in scott.emp\\n\"\n            + \"order e.ename desc\\n\"\n            + \"take 3\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\\n\"\n            + \"yield {e.ename, d.dname}\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\\n\"\n            + \"yield e\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\\n\"\n            + \"andalso e.job = \\\"CLERK\\\"\\n\"\n            + \"yield d\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept\\n\"\n            + \"where e.deptno = d.deptno\\n\"\n            + \"andalso e.job = \\\"CLERK\\\"\\n\"\n            + \"group e.mgr\",\n        \"from e in scott.emp,\\n\"\n            + \"  g in scott.salgrade\\n\"\n            + \"where e.sal >= g.losal\\n\"\n            + \"  andalso e.sal < g.hisal\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept,\"\n            + \"  g in scott.salgrade\\n\"\n            + \"where e.sal >= g.losal\\n\"\n            + \"  andalso e.sal < g.hisal\\n\"\n            + \"  andalso d.deptno = e.deptno\",\n        \"from e in scott.emp,\\n\"\n            + \"  d in scott.dept,\"\n            + \"  g in scott.salgrade\\n\"\n            + \"where e.sal >= g.losal\\n\"\n            + \"  andalso e.sal < g.hisal\\n\"\n            + \"  andalso d.deptno = e.deptno\\n\"\n            + \"group g.grade compute c = count\",\n        \"from x in (from e in scott.emp yield {e.deptno, z = 1})\\n\"\n            + \"  union (from d in scott.dept yield {d.deptno, z = 2})\",\n        \"from x in (from e in scott.emp yield e.deptno)\\n\"\n            + \"  union (from d in scott.dept yield d.deptno)\\n\"\n            + \"group x compute c = count\",\n        \"[1, 2, 3] union [2, 3, 4]\",\n        \"[10, 15, 20] union (from d in scott.dept yield d.deptno)\",\n        \"[10, 15, 20] except (from d in scott.dept yield d.deptno)\",\n        \"[10, 15, 20] intersect (from d in scott.dept yield d.deptno)\",\n\n        // the following 4 are equivalent\n        \"from e in scott.emp where e.deptno = 30 yield e.empno\",\n        \"let\\n\"\n            + \"  val emps = #emp scott\\n\"\n            + \"in\\n\"\n            + \"  from e in emps\\n\"\n            + \"  where e.deptno = 30\\n\"\n            + \"  yield e.empno\\n\"\n            + \"end\",\n        \"let\\n\"\n            + \"  val emps = #emp scott\\n\"\n            + \"  val thirty = 30\\n\"\n            + \"in\\n\"\n            + \"  from e in emps\\n\"\n            + \"  where e.deptno = thirty\\n\"\n            + \"  yield e.empno\\n\"\n            + \"end\",\n        \"map (fn e => (#empno e))\\n\"\n            + \"  (List.filter (fn e => (#deptno e) = 30) (#emp scott))\",\n    };\n    Stream.of(queries).filter(q -> !q.startsWith(\"#\")).forEach(query -> {\n      try {\n        ml(query).withBinding(\"scott\", BuiltInDataSet.SCOTT).assertEvalSame();\n      } catch (AssertionError | RuntimeException e) {\n        throw new RuntimeException(\"during query [\" + query + \"]\", e);\n      }\n    });\n  }\n\n  /** Translates a hybrid expression. The leaf cannot be translated to Calcite\n   * and therefore becomes a Morel table function; the root can. */\n  @Test void testNative() {\n    String query = \"\"\n        + \"from r in\\n\"\n        + \"  List.tabulate (6, fn i =>\\n\"\n        + \"    {i, j = i + 3, s = String.substring (\\\"morel\\\", 0, i)})\\n\"\n        + \"yield {r.j, r.s}\";\n    ml(query).withBinding(\"scott\", BuiltInDataSet.SCOTT).assertEvalSame();\n  }\n\n  /** Tests a query that can mostly be executed in Calcite, but is followed by\n   * List.filter, which must be implemented in Morel. Therefore Morel calls\n   * into the internal \"calcite\" function, passing the Calcite plan to be\n   * executed. */\n  @Test void testHybridCalciteToMorel() {\n    final String ml = \"List.filter\\n\"\n        + \"  (fn x => x.empno < 7500)\\n\"\n        + \"  (from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLERK\\\"\\n\"\n        + \"  yield {e.empno, e.deptno, d5 = e.deptno + 5})\";\n    String plan = \"\"\n        + \"apply(\"\n        + \"fnCode apply(fnValue List.filter, \"\n        + \"argCode match(x, apply2(fnValue <, \"\n        + \"apply(fnValue nth:2, argCode get(name x)),\"\n        + \" constant(7500)))), \"\n        + \"argCode calcite(\"\n        + \"plan LogicalProject(d5=[+($1, 5)], deptno=[$1], empno=[$2])\\n\"\n        + \"  LogicalFilter(condition=[=($5, 'CLERK')])\\n\"\n        + \"    LogicalProject(comm=[$6], deptno=[$7], empno=[$0], ename=[$1], \"\n        + \"hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \"))\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"{d5:int, deptno:int, empno:int} list\")\n        .assertEvalIter(equalsOrdered(list(25, 20, 7369)))\n        .assertPlan(isCode(plan));\n  }\n\n  /** Tests a query that can be fully executed in Calcite. */\n  @Test void testFullCalcite() {\n    final String ml = \"from e in scott.emp\\n\"\n        + \"  where e.empno < 7500\\n\"\n        + \"  yield {e.empno, e.deptno, d5 = e.deptno + 5}\";\n    checkFullCalcite(ml);\n  }\n\n  /** As {@link #testFullCalcite()} but table is via a {@code let}. */\n  @Test void testFullCalcite2() {\n    final String ml = \"let\\n\"\n        + \"  val emp = scott.emp\\n\"\n        + \"in\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.empno < 7500\\n\"\n        + \"  yield {e.empno, e.deptno, d5 = e.deptno + 5}\\n\"\n        + \"end\";\n    checkFullCalcite(ml);\n  }\n\n  /** As {@link #testFullCalcite()} but query is a function, and table is\n   * passed via an argument. */\n  @Test void testFullCalcite3() {\n    final String ml = \"let\\n\"\n        + \"  fun query emp =\\n\"\n        + \"    from e in emp\\n\"\n        + \"    where e.empno < 7500\\n\"\n        + \"    yield {e.empno, e.deptno, d5 = e.deptno + 5}\\n\"\n        + \"in\\n\"\n        + \"  query scott.emp\\n\"\n        + \"end\";\n    checkFullCalcite(ml);\n  }\n\n  private void checkFullCalcite(String ml) {\n    String plan = \"calcite(plan \"\n        + \"LogicalProject(d5=[+($1, 5)], deptno=[$1], empno=[$2])\\n\"\n        + \"  LogicalFilter(condition=[<($2, 7500)])\\n\"\n        + \"    LogicalProject(comm=[$6], deptno=[$7], empno=[$0], ename=[$1], \"\n        + \"hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"{d5:int, deptno:int, empno:int} list\")\n        .assertEvalIter(equalsOrdered(list(25, 20, 7369), list(35, 30, 7499)))\n        .assertPlan(isCode(plan));\n  }\n\n  /** Tests a query that is \"from\" over no variables. The result has one row\n   * and zero columns. */\n  @Test void testCalciteFrom() {\n    final String ml = \"from\";\n    String plan = \"calcite(plan LogicalValues(tuples=[[{  }]])\\n)\";\n    ml(ml)\n        .with(Prop.HYBRID, true)\n        .assertType(\"unit list\")\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(list()));\n  }\n\n  /** Tests a query that is executed in Calcite except for a variable, 'five',\n   * whose value happens to always be '2 + 3'. */\n  @Test void testCalciteWithVariable() {\n    final String plan = \"let(matchCode0 match(five, \"\n        + \"apply2(fnValue +, constant(2), constant(3))), \"\n        + \"resultCode calcite(plan \"\n        + \"LogicalProject(d5=[+($1, morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n\"\n        + \"}'))], deptno=[$1], empno=[$2])\\n\"\n        + \"  LogicalFilter(condition=[<($2, +(7500, +(morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n\"\n        + \"}'), morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n\"\n        + \"}'))))])\\n\"\n        + \"    LogicalProject(comm=[$6], deptno=[$7], empno=[$0], ename=[$1], \"\n        + \"hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \"))\";\n    final int inlinePassCount = 1; // limit inlining\n    checkCalciteWithVariable(inlinePassCount, plan);\n  }\n\n  @Test void testCalciteWithVariableNoInlining() {\n    final String plan = \"let(matchCode0 match(five, \"\n        + \"apply2(fnValue +, constant(2), constant(3))), \"\n        + \"resultCode let(matchCode0 match(ten, \"\n        + \"apply2(fnValue +, get(name five), get(name five))), \"\n        + \"resultCode calcite(plan \"\n        + \"LogicalProject(d5=[+($1, morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n}'))], deptno=[$1], empno=[$2])\\n\"\n        + \"  LogicalFilter(condition=[<($2, +(7500, morelScalar('ten', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n}')))])\\n\"\n        + \"    LogicalProject(comm=[$6], deptno=[$7], empno=[$0], ename=[$1], \"\n        + \"hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"      JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")))\";\n    final int inlinePassCount = 0;\n    checkCalciteWithVariable(inlinePassCount, plan);\n  }\n\n  private void checkCalciteWithVariable(int inlinePassCount, String plan) {\n    final String ml = \"let\\n\"\n        + \"  val five = 2 + 3\\n\"\n        + \"  val ten = five + five\\n\"\n        + \"in\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.empno < 7500 + ten\\n\"\n        + \"  yield {e.empno, e.deptno, d5 = e.deptno + five}\\n\"\n        + \"end\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .with(Prop.INLINE_PASS_COUNT, inlinePassCount)\n        .assertType(\"{d5:int, deptno:int, empno:int} list\")\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(list(25, 20, 7369), list(35, 30, 7499)));\n  }\n\n  /** Tests a query that is executed in Calcite except for a function,\n   * 'twice'. */\n  @Test void testCalciteWithFunction() {\n    final String ml = \"let\\n\"\n        + \"  fun twice x = x + x\\n\"\n        + \"in\\n\"\n        + \"  from d in scott.dept\\n\"\n        + \"  yield twice d.deptno\\n\"\n        + \"end\";\n    String plan = \"let(matchCode0 match(twice, match(x, \"\n        + \"apply2(fnValue +, get(name x), get(name x)))), \"\n        + \"resultCode calcite(plan \"\n        + \"LogicalProject($f0=[morelScalar('int', \"\n        + \"morelScalar('twice', '{\\n\"\n        + \"  \\\"type\\\": \\\"ANY\\\",\\n\"\n        + \"  \\\"nullable\\\": false,\\n\"\n        + \"  \\\"precision\\\": -1,\\n\"\n        + \"  \\\"scale\\\": -1\\n\"\n        + \"}'), $0)])\\n\"\n        + \"  JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \"))\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .with(Prop.INLINE_PASS_COUNT, 0)\n        .assertType(\"int list\")\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(20, 40, 60, 80));\n  }\n\n  /** Tests a query that is executed in Calcite except for a function,\n   * 'plus'; one of its arguments comes from a relational record, and another\n   * from the Morel environment. */\n  @Test void testCalciteWithHybridFunction() {\n    final String ml = \"let\\n\"\n        + \"  fun plus (x, y) = x + y\\n\"\n        + \"  val five = 5\\n\"\n        + \"in\\n\"\n        + \"  from d in scott.dept\\n\"\n        + \"  yield plus (d.deptno, five)\\n\"\n        + \"end\";\n    String plan = \"let(matchCode0 match(plus, match(v0, \"\n        + \"apply(fnCode match((x, y), apply2(fnValue +, \"\n        + \"get(name x), get(name y))), \"\n        + \"argCode get(name v0)))), \"\n        + \"resultCode let(matchCode0 match(five, constant(5)), \"\n        + \"resultCode calcite(plan \"\n        + \"LogicalProject($f0=[morelScalar('int * int', \"\n        + \"morelScalar('plus', '{\\n\"\n        + \"  \\\"type\\\": \\\"ANY\\\",\\n\"\n        + \"  \\\"nullable\\\": false,\\n\"\n        + \"  \\\"precision\\\": -1,\\n\"\n        + \"  \\\"scale\\\": -1\\n\"\n        + \"}'), ROW($0, morelScalar('five', '{\\n\"\n        + \"  \\\"type\\\": \\\"INTEGER\\\",\\n\"\n        + \"  \\\"nullable\\\": false\\n\"\n        + \"}')))])\\n\"\n        + \"  JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \")))\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .with(Prop.INLINE_PASS_COUNT, 0)\n        .assertType(\"int list\")\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(15, 25, 35, 45));\n  }\n\n  /** Tests that we can send {@code union} to Calcite. */\n  @Test void testUnion() {\n    final String ml = \"from x in (\\n\"\n        + \"(from e in scott.emp where e.job = \\\"CLERK\\\" yield e.deptno)\\n\"\n        + \"union\\n\"\n        + \"(from d in scott.dept yield d.deptno))\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"int list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(equalsUnordered(20, 20, 20, 40, 10, 10, 30, 30));\n  }\n\n  /** Tests that we can send {@code except} to Calcite. */\n  @Test void testExcept() {\n    final String ml = \"from x in (\\n\"\n        + \"(from d in scott.dept yield d.deptno)\"\n        + \"except\\n\"\n        + \"(from e in scott.emp where e.job = \\\"CLERK\\\" yield e.deptno))\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"int list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(equalsUnordered(40));\n  }\n\n  /** Tests that we can send {@code intersect} to Calcite. */\n  @Test void testIntersect() {\n    final String ml = \"from x in (\\n\"\n        + \"(from e in scott.emp where e.job = \\\"CLERK\\\" yield e.deptno)\\n\"\n        + \"intersect\\n\"\n        + \"(from d in scott.dept yield d.deptno))\\n\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"int list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(equalsUnordered(10, 20, 30));\n  }\n\n  /** Tests that we can send (what in SQL would be) an uncorrelated {@code IN}\n   * sub-query to Calcite. */\n  @Test void testElem() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"where d.deptno elem (from e in scott.emp\\n\"\n        + \"    where e.job elem [\\\"ANALYST\\\", \\\"PRESIDENT\\\"]\\n\"\n        + \"    yield e.deptno)\\n\"\n        + \"yield d.dname\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"string list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(equalsUnordered(\"ACCOUNTING\", \"RESEARCH\"));\n  }\n\n  /** Tests that we can send (what in SQL would be) an uncorrelated {@code IN}\n   * sub-query to Calcite. */\n  @Test void testNotElem() {\n    final UnaryOperator<Ml> fn = ml ->\n        ml.withBinding(\"scott\", BuiltInDataSet.SCOTT)\n            .with(Prop.HYBRID, true)\n            .assertType(\"string list\")\n            .assertPlan(isFullyCalcite())\n            .assertEvalIter(equalsUnordered(\"SALES\", \"OPERATIONS\"));\n\n    final String ml0 = \"from d in scott.dept\\n\"\n        + \"where not (d.deptno elem\\n\"\n        + \"    (from e in scott.emp\\n\"\n        + \"        where e.job elem [\\\"ANALYST\\\", \\\"PRESIDENT\\\"]\\n\"\n        + \"        yield e.deptno))\\n\"\n        + \"yield d.dname\";\n    final String ml1 = \"from d in scott.dept\\n\"\n        + \"where d.deptno notelem (from e in scott.emp\\n\"\n        + \"    where e.job elem [\\\"ANALYST\\\", \\\"PRESIDENT\\\"]\\n\"\n        + \"    yield e.deptno)\\n\"\n        + \"yield d.dname\";\n    fn.apply(ml(ml0));\n    fn.apply(ml(ml1));\n  }\n\n  /** Tests that {@code exists} is pushed down to Calcite.\n   * (There are no correlating variables.) */\n  @Test void testExists() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"where exists (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLERK\\\")\\n\"\n        + \"yield d.deptno\";\n    String plan = \"calcite(plan \"\n        + \"LogicalProject(deptno=[$0])\\n\"\n        + \"  LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"    LogicalJoin(condition=[true], joinType=[inner])\\n\"\n        + \"      LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"        JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \"      LogicalAggregate(group=[{0}])\\n\"\n        + \"        LogicalProject(i=[true])\\n\"\n        + \"          LogicalFilter(condition=[=($5, 'CLERK')])\\n\"\n        + \"            LogicalProject(comm=[$6], deptno=[$7], empno=[$0], \"\n        + \"ename=[$1], hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"              JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"int list\")\n        .assertPlan(isFullyCalcite())\n        .assertPlan(isCode(plan))\n        .assertEvalIter(equalsOrdered(10, 20, 30, 40));\n  }\n\n  /** Tests that {@code not exists} (uncorrelated), also {@code notExists} and\n   * {@code List.null}, is pushed down to Calcite. */\n  @Test void testNotExists() {\n    final UnaryOperator<Ml> fn = ml ->\n        ml.withBinding(\"scott\", BuiltInDataSet.SCOTT)\n            .with(Prop.HYBRID, true)\n            .assertType(\"int list\")\n            .assertPlan(isFullyCalcite())\n            .assertEvalIter(equalsOrdered(10, 20, 30, 40));\n    final String ml0 = \"from d in scott.dept\\n\"\n        + \"where not (exists (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLARK KENT\\\"))\\n\"\n        + \"yield d.deptno\";\n    final String plan0 = \"calcite(plan \"\n        + \"LogicalProject(deptno=[$0])\\n\"\n        + \"  LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"    LogicalFilter(condition=[IS NULL($3)])\\n\"\n        + \"      LogicalJoin(condition=[true], joinType=[left])\\n\"\n        + \"        LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"          JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \"        LogicalAggregate(group=[{0}])\\n\"\n        + \"          LogicalProject(i=[true])\\n\"\n        + \"            LogicalFilter(condition=[=($5, 'CLARK KENT')])\\n\"\n        + \"              LogicalProject(comm=[$6], deptno=[$7], empno=[$0], \"\n        + \"ename=[$1], hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"                JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")\";\n    final String ml1 = \"from d in scott.dept\\n\"\n        + \"where notExists (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLARK KENT\\\")\\n\"\n        + \"yield d.deptno\";\n    final String ml2 = \"from d in scott.dept\\n\"\n        + \"where List.null (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.job = \\\"CLARK KENT\\\")\\n\"\n        + \"yield d.deptno\";\n    fn.apply(ml(ml0))\n        .assertPlan(isCode(plan0));\n    fn.apply(ml(ml1));\n    fn.apply(ml(ml2));\n  }\n\n  /** Tests that correlated {@code exists} is pushed down to Calcite. */\n  @Test void testExistsCorrelated() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"where exists (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where e.deptno = d.deptno\\n\"\n        + \"  andalso e.job = \\\"CLERK\\\")\";\n    String plan = \"calcite(plan \"\n        + \"LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"  LogicalJoin(condition=[=($0, $3)], joinType=[inner])\\n\"\n        + \"    LogicalProject(deptno=[$0], dname=[$1], loc=[$2])\\n\"\n        + \"      JdbcTableScan(table=[[scott, DEPT]])\\n\"\n        + \"    LogicalProject(deptno=[$0], $f1=[true])\\n\"\n        + \"      LogicalAggregate(group=[{0}])\\n\"\n        + \"        LogicalProject(deptno=[$1])\\n\"\n        + \"          LogicalFilter(condition=[AND(=($5, 'CLERK'), \"\n        + \"IS NOT NULL($1))])\\n\"\n        + \"            LogicalProject(comm=[$6], deptno=[$7], empno=[$0], \"\n        + \"ename=[$1], hiredate=[$4], job=[$2], mgr=[$3], sal=[$5])\\n\"\n        + \"              JdbcTableScan(table=[[scott, EMP]])\\n\"\n        + \")\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"{deptno:int, dname:string, loc:string} list\")\n        .assertPlan(isFullyCalcite())\n        .assertPlan(isCode(plan))\n        .assertEvalIter(\n            equalsOrdered(list(10, \"ACCOUNTING\", \"NEW YORK\"),\n                list(20, \"RESEARCH\", \"DALLAS\"),\n                list(30, \"SALES\", \"CHICAGO\")));\n  }\n\n  @Test void testCorrelatedListSubQuery() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"yield {d.dname, empCount = (from e in scott.emp\\n\"\n        + \"                            group e.deptno compute c = count\\n\"\n        + \"                            where deptno = d.deptno\\n\"\n        + \"                            yield c)}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        // TODO: enable in hybrid; will require new method RexSubQuery.array\n        // .with(Prop.HYBRID, true)\n        .assertType(\"{dname:string, empCount:int list} list\")\n        .assertEvalIter(\n            equalsOrdered(list(\"ACCOUNTING\", list(3)),\n                list(\"RESEARCH\", list(5)),\n                list(\"SALES\", list(6)),\n                list(\"OPERATIONS\", list())));\n  }\n\n  @Test void testCorrelatedScalar() {\n    final String ml = \"from d in scott.dept\\n\"\n        + \"yield {d.dname, empCount =\\n\"\n        + \"    only (from e in scott.emp\\n\"\n        + \"          where e.deptno = d.deptno\\n\"\n        + \"          group compute count)}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .with(Prop.HYBRID, true)\n        .assertType(\"{dname:string, empCount:int} list\")\n        .assertPlan(isFullyCalcite())\n        .assertEvalIter(\n            equalsOrdered(list(\"ACCOUNTING\", 3),\n                list(\"RESEARCH\", 5),\n                list(\"SALES\", 6),\n                list(\"OPERATIONS\", 0)));\n  }\n\n  /** Tests a recursive query that computes a transitive closure by successive\n   * union operations. We cannot execute hybrid yet. */\n  @Test void testRecursive() {\n    final String ml = \"let\\n\"\n        + \"  fun descendants2 descendants newDescendants =\\n\"\n        + \"    if List.null newDescendants then\\n\"\n        + \"      descendants\\n\"\n        + \"    else\\n\"\n        + \"      descendants2 (descendants union newDescendants)\\n\"\n        + \"          (from d in newDescendants,\\n\"\n        + \"              e in scott.emp\\n\"\n        + \"            where e.mgr = d.e.empno\\n\"\n        + \"            yield {e, level = d.level + 1})\\n\"\n        + \"in\\n\"\n        + \"  from d in descendants2 []\\n\"\n        + \"      (from e in scott.emp\\n\"\n        + \"        where e.mgr = 0\\n\"\n        + \"        yield {e, level = 0})\\n\"\n        + \"    yield {d.e.empno, d.e.mgr, d.e.ename, d.level}\\n\"\n        + \"end\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{empno:int, ename:string, level:int, mgr:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(7839, \"KING\", 0, 0),\n                list(7566, \"JONES\", 1, 7839), list(7698, \"BLAKE\", 1, 7839),\n                list(7782, \"CLARK\", 1, 7839), list(7788, \"SCOTT\", 2, 7566),\n                list(7902, \"FORD\", 2, 7566), list(7499, \"ALLEN\", 2, 7698),\n                list(7521, \"WARD\", 2, 7698), list(7654, \"MARTIN\", 2, 7698),\n                list(7844, \"TURNER\", 2, 7698), list(7900, \"JAMES\", 2, 7698),\n                list(7934, \"MILLER\", 2, 7782), list(7876, \"ADAMS\", 3, 7788),\n                list(7369, \"SMITH\", 3, 7902)));\n  }\n\n  /** Similar to {@link #testRecursive()} but uses the\n   * {@link net.hydromatic.morel.compile.BuiltIn#RELATIONAL_ITERATE Relatonal.iterate}\n   * function. */\n  @Test void testRecursive2() {\n    final String ml = \"from i in iterate\\n\"\n        + \"    (from e in scott.emp\\n\"\n        + \"      where e.mgr = 0\\n\"\n        + \"      yield {e, level = 0})\\n\"\n        + \"    fn (oldList, newList) =>\\n\"\n        + \"      (from d in newList,\\n\"\n        + \"          e in scott.emp\\n\"\n        + \"        where e.mgr = d.e.empno\\n\"\n        + \"        yield {e, level = d.level + 1})\\n\"\n        + \"  yield {i.e.empno, i.e.ename, i.level, i.e.mgr}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{empno:int, ename:string, level:int, mgr:int} list\")\n        .assertEvalIter(\n            equalsOrdered(list(7839, \"KING\", 0, 0),\n                list(7566, \"JONES\", 1, 7839), list(7698, \"BLAKE\", 1, 7839),\n                list(7782, \"CLARK\", 1, 7839), list(7788, \"SCOTT\", 2, 7566),\n                list(7902, \"FORD\", 2, 7566), list(7499, \"ALLEN\", 2, 7698),\n                list(7521, \"WARD\", 2, 7698), list(7654, \"MARTIN\", 2, 7698),\n                list(7844, \"TURNER\", 2, 7698), list(7900, \"JAMES\", 2, 7698),\n                list(7934, \"MILLER\", 2, 7782), list(7876, \"ADAMS\", 3, 7788),\n                list(7369, \"SMITH\", 3, 7902)));\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/CalciteTest.java.CalciteTest", "name": "CalciteTest", "file_path": "src/test/java/net/hydromatic/morel/CalciteTest.java", "superclasses": "", "methods": ["[void]testNestedSchema()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "  public static class UserSchema {\n    @Override public String toString() {\n      return \"UserSchema\";\n    }\n\n    /** Array that will, via reflection, become the \"users\" table in the\n     * \"user\" schema. */\n    @SuppressWarnings(\"unused\") // used via reflection\n    public final User[] users = {\n        new User(\"John\", 20),\n        new User(\"Jane\", 21),\n        new User(\"Jack\", 22)\n    };\n  }", "definition": "  public static class UserSchema", "class_docstring": " Java object that will, via reflection, become create the \"user\" schema.", "name": "UserSchema", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"unused\") // used via reflection\n    public final User[] users = {\n        new User(\"John\", 20),\n        new User(\"Jane\", 21),\n        new User(\"Jack\", 22)\n    };", "docstring": " Array that will, via reflection, become the \"users\" table in the\n\"user\" schema.", "modifiers": "@SuppressWarnings(\"unused\") // used via reflection\n    public final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": ["// used via reflection"], "type": "User[]", "name": "users = {\n        new User(\"John\", 20),\n        new User(\"Jane\", 21),\n        new User(\"Jack\", 22)\n    }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return \"UserSchema\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return \"UserSchema\";\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  public static class User {\n    public final String name;\n    public final int age;\n\n    User(String name, int age) {\n      this.name = name;\n      this.age = age;\n    }\n  }", "definition": "  public static class User", "class_docstring": " Row in the \"users\" table.", "name": "User", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "public final int age;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "int", "name": "age", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    User(String name, int age) {\n      this.name = name;\n      this.age = age;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "User", "params": [{"name": "name", "type": "String"}, {"name": "age", "type": "int"}], "body": "                               {\n      this.name = name;\n      this.age = age;\n    }", "signature": "User(String name, int age)"}]}, {"original_string": "  public static class TaskSchema {\n    @Override public String toString() {\n      return \"TaskSchema\";\n    }\n\n    /** Array that will, via reflection, become the \"tasks\" table in the\n     * \"task\" schema. */\n    @SuppressWarnings(\"unused\") // used via reflection\n    public final Task[] tasks = {\n        new Task(\"Buy milk\", false),\n        new Task(\"Buy eggs\", false),\n        new Task(\"Buy bread\", false)\n    };\n  }", "definition": "  public static class TaskSchema", "class_docstring": " Java object that will, via reflection, become create the \"task\" schema.", "name": "TaskSchema", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"unused\") // used via reflection\n    public final Task[] tasks = {\n        new Task(\"Buy milk\", false),\n        new Task(\"Buy eggs\", false),\n        new Task(\"Buy bread\", false)\n    };", "docstring": " Array that will, via reflection, become the \"tasks\" table in the\n\"task\" schema.", "modifiers": "@SuppressWarnings(\"unused\") // used via reflection\n    public final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "public", "final"], "comments": ["// used via reflection"], "type": "Task[]", "name": "tasks = {\n        new Task(\"Buy milk\", false),\n        new Task(\"Buy eggs\", false),\n        new Task(\"Buy bread\", false)\n    }", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override public String toString() {\n      return \"TaskSchema\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                       {\n      return \"TaskSchema\";\n    }", "signature": "@Override public String toString()"}]}, {"original_string": "  public static class Task {\n    public final String name;\n    public final boolean completed;\n\n    Task(String name, boolean completed) {\n      this.name = name;\n      this.completed = completed;\n    }\n  }", "definition": "  public static class Task", "class_docstring": " Row in the \"tasks\" table.", "name": "Task", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "public final boolean completed;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "boolean", "name": "completed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Task(String name, boolean completed) {\n      this.name = name;\n      this.completed = completed;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Task", "params": [{"name": "name", "type": "String"}, {"name": "completed", "type": "boolean"}], "body": "                                         {\n      this.name = name;\n      this.completed = completed;\n    }", "signature": "Task(String name, boolean completed)"}]}], "class_docstring": " Tests Morel's integration with Calcite.\n\n<p>Algebra is covered in {@link AlgebraTest} but this test covers\nwhat's left, such as {@link CalciteForeignValue} and schemas.\n", "original_string": "class CalciteTest {\n  final boolean debug = hashCode() < hashCode(); // always false\n\n  /** Tests that you if you create a\n   * {@link net.hydromatic.morel.foreign.CalciteForeignValue}\n   * whose schema has nested schemas, those schemas appear as fields. */\n  @Test void testNestedSchema() {\n    final Schema userSchema = new ReflectiveSchema(new UserSchema());\n    final Schema taskSchema = new ReflectiveSchema(new TaskSchema());\n\n    final Map<String, ForeignValue> foreignValueMap = Calcite.withDataSets(\n        ImmutableMap.of(\"user\", (Calcite calcite) -> {\n          SchemaPlus newSchema =\n              calcite.rootSchema.add(\"users\", userSchema);\n          newSchema.add(\"task\", taskSchema);\n          newSchema.add(\"task2\", taskSchema);\n          return new CalciteForeignValue(calcite, newSchema, true);\n        })).foreignValues();\n\n    final String sql = \"user;\\n\"\n        + \"user.task;\\n\"\n        + \"user.task2;\\n\"\n        + \"from t in user.users yield t;\\n\"\n        + \"from t in user.task2.tasks yield t;\\n\";\n    final InputStream in = new ByteArrayInputStream(sql.getBytes());\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    final Main main =\n        new Main(ImmutableList.of(), in, new PrintStream(out), foreignValueMap,\n            ImmutableMap.of(), false);\n\n    main.run();\n    if (debug) {\n      System.out.println(out);\n    }\n\n    String expected = \"val it = {task={tasks=<relation>},\"\n        + \"task2={tasks=<relation>},\"\n        + \"users=<relation>}\\n\"\n        + \"  : {task:{tasks:{completed:bool, name:string} list},\\n\"\n        + \"     task2:{tasks:{completed:bool, name:string} list},\\n\"\n        + \"     users:{age:int, name:string} list}\\n\"\n        + \"val it = {tasks=<relation>} : {tasks:{completed:bool, name:string} list}\\n\"\n        + \"val it = {tasks=<relation>} : {tasks:{completed:bool, name:string} list}\\n\"\n        + \"val it = [{age=20,name=\\\"John\\\"},{age=21,name=\\\"Jane\\\"},{age=22,name=\\\"Jack\\\"}]\\n\"\n        + \"  : {age:int, name:string} list\\n\"\n        + \"val it =\\n\"\n        + \"  [{completed=false,name=\\\"Buy milk\\\"},{completed=false,name=\\\"Buy eggs\\\"},\\n\"\n        + \"   {completed=false,name=\\\"Buy bread\\\"}] : {completed:bool, name:string} list\\n\";\n    assertThat(toLinux(out.toString()), is(expected));\n  }\n\n  /** Java object that will, via reflection, become create the \"user\" schema. */\n  public static class UserSchema {\n    @Override public String toString() {\n      return \"UserSchema\";\n    }\n\n    /** Array that will, via reflection, become the \"users\" table in the\n     * \"user\" schema. */\n    @SuppressWarnings(\"unused\") // used via reflection\n    public final User[] users = {\n        new User(\"John\", 20),\n        new User(\"Jane\", 21),\n        new User(\"Jack\", 22)\n    };\n  }\n\n  /** Row in the \"users\" table. */\n  public static class User {\n    public final String name;\n    public final int age;\n\n    User(String name, int age) {\n      this.name = name;\n      this.age = age;\n    }\n  }\n\n  /** Java object that will, via reflection, become create the \"task\" schema. */\n  public static class TaskSchema {\n    @Override public String toString() {\n      return \"TaskSchema\";\n    }\n\n    /** Array that will, via reflection, become the \"tasks\" table in the\n     * \"task\" schema. */\n    @SuppressWarnings(\"unused\") // used via reflection\n    public final Task[] tasks = {\n        new Task(\"Buy milk\", false),\n        new Task(\"Buy eggs\", false),\n        new Task(\"Buy bread\", false)\n    };\n  }\n\n\n  /** Row in the \"tasks\" table. */\n  public static class Task {\n    public final String name;\n    public final boolean completed;\n\n    Task(String name, boolean completed) {\n      this.name = name;\n      this.completed = completed;\n    }\n  }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "final boolean debug = hashCode() < hashCode();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "boolean", "name": "debug = hashCode() < hashCode()", "syntax_pass": true}]}, {"uris": "src/test/java/net/hydromatic/morel/MainTest.java.MainTest", "name": "MainTest", "file_path": "src/test/java/net/hydromatic/morel/MainTest.java", "superclasses": "", "methods": ["[void]testEmptyRepl()", "[void]testRepl()", "[void]testParse()", "[void]testParseComment()", "[void]testParseCase()", "[void]testParseDot()", "[void]testParseAbbreviatedRecord()", "[void]testParseErrorPosition()", "[void]testRuntimeErrorPosition()", "[void]testTypeVarName()", "[void]testType()", "[void]testTypeFn()", "[void]testTypeFnTuple()", "[void]testTypeLetRecFn()", "[void]testRecordType()", "[void]testIncompleteRecordType()", "[void]testApply()", "[void]testApply2()", "[void]testApplyIsMonomorphic()", "[void]testLetIsPolymorphic()", "[void]testHdIsPolymorphic()", "[void]testTypeVariable()", "[void]testExponentialType0()", "[void]testExponentialType()", "[void]testExponentialType2()", "[void]testDummy()", "[void]testEval()", "[void]testLetSequentialDeclarations()", "[void]testLet2()", "[void]testLet3()", "[void]testLet3b()", "[void]testLet3c()", "[void]testLet4()", "[void]testLet5()", "[void]testLet6()", "[void]testLet7()", "[void]testEvalApply2()", "[void]testNameCapture()", "[void]testMutualRecursion()", "[void]testMutualRecursion3()", "[void]testCompositeRecursiveLet()", "[void]testMutualRecursionComplex()", "[void]testSameVariableName()", "[void]testSameVariableName2()", "[void]testClosure()", "[void]testEvalFn()", "[void]testEvalFnCurried()", "[void]testEvalFnTuple()", "[void]testEvalFnRec()", "[void]testEvalFnTupleGeneric()", "[void]testRecord()", "[void]testEquals()", "[void]testRecord2()", "[void]testRecordFn()", "[void]testRecordMatch()", "[void]testRecordCase()", "[void]testRecordTuple()", "[void]testList()", "[void]testList2()", "[void]testListLength()", "[void]testListLength2()", "[void]testListLength3()", "[void]testFunUnit()", "[void]testMatchTuple()", "[void]testMatchRedundant()", "[void]testMatchCoverage1()", "[void]testMatchCoverage2()", "[void]testMatchCoverage3()", "[void]testMatchCoverage4()", "[void]testMatchCoverage5()", "[void]testMatchCoverage6()", "[void]testMatchCoverage7()", "[void]testMatchCoverage8()", "[void]testMatchCoverage9()", "[void]testMatchCoverage10()", "[void]testMatchCoverage12()", "[void]testMatchCoverage13()", "[void]testFun()", "[void]testFunValue()", "[void]testFunValueSansLet()", "[void]testFun2()", "[void]testFun3()", "[void]testFun4()", "[void]testMutuallyRecursiveFunctions()", "[void]testFunTwoArgs()", "[void]testFunRecord()", "[void]testDatatype()", "[void]testDatatype2()", "[void]testDatatype3()", "[void]testDatatype3b()", "[void]testDatatype3c()", "[void]testDatatype4()", "[void]testDatatype4a()", "[void]testSetOp()", "[void]testFrom()", "[void]testParseFrom()", "[void]testFromYield()", "[void]testFromYieldExpression()", "[void]testFromWhere()", "[void]testFromSuchThat()", "[void]testFromSuchThat2()", "[void]testFromSuchThat2b()", "[void]testFromSuchThat2c()", "[void]testFromSuchThat2d()", "[void]testFromSuchThat2d2()", "[void]testFromSuchThat2d3()", "[void]testFromSuchThat2d4()", "[void]testFromSuchThat2e()", "[void]testFromSuchThat2f()", "[void]testFromSuchThat3()", "[void]testBooleanExtent()", "[void]testFromNoYield()", "[void]testFromJoinNoYield()", "[void]testYieldYield()", "[void]testYieldSingletonRecord()", "[void]testCrossApply()", "[void]testCrossApplyGroup()", "[void]testJoinLateral()", "[void]testFromGroupWithoutCompute()", "[void]testFromGroupWithoutCompute2()", "[void]testFromGroup()", "[void]testGroupAs()", "[void]testGroupAs2()", "[void]testGroupSansOf()", "[void]testGroupDuplicates()", "[void]testCompute()", "[void]testGroupYield()", "[void]testJoinGroup()", "[void]testGroupGroup()", "[void]testFromOrderYield()", "[void]testFromEmpty()", "[void]testFromPattern()", "[void]testFromEquals()", "[void]testFunFrom()", "[void]testToCoreAndBack()", "[void]testError()"], "method_uris": ["src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[List<Object>]leaf(Object)", "src/test/java/net/hydromatic/morel/MainTest.java.MainTest.[List<Object>]node()"], "overrides": null, "attributes": [], "class_docstring": "\nKick the tires.\n", "original_string": "public class MainTest {\n\n  @Test void testEmptyRepl() {\n    final List<String> argList = ImmutableList.of();\n    final Map<String, ForeignValue> valueMap = ImmutableMap.of();\n    final Map<Prop, Object> propMap = ImmutableMap.of();\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    try (PrintStream ps = new PrintStream(out)) {\n      final InputStream in = new ByteArrayInputStream(new byte[0]);\n      final Main main = new Main(argList, in, ps, valueMap, propMap, false);\n      main.run();\n    }\n    assertThat(out.size(), is(0));\n  }\n\n  @Test void testRepl() {\n    final List<String> argList = ImmutableList.of();\n    final String ml = \"val x = 5;\\n\"\n        + \"x;\\n\"\n        + \"it + 1;\\n\"\n        + \"val f = fn x => x + 1;\\n\"\n        + \"f;\\n\"\n        + \"it x;\\n\";\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    try (PrintStream ps = new PrintStream(out)) {\n      final InputStream in = new ByteArrayInputStream(ml.getBytes());\n      final Map<String, ForeignValue> valueMap = ImmutableMap.of();\n      final Map<Prop, Object> propMap = ImmutableMap.of();\n      final Main main = new Main(argList, in, ps, valueMap, propMap, false);\n      main.run();\n    }\n    final String expected = \"val x = 5 : int\\n\"\n        + \"val it = 5 : int\\n\"\n        + \"val it = 6 : int\\n\"\n        + \"val f = fn : int -> int\\n\"\n        + \"val it = fn : int -> int\\n\"\n        + \"val it = 6 : int\\n\";\n    assertThat(out, hasToString(expected));\n  }\n\n  @Test void testParse() {\n    ml(\"1\").assertParseLiteral(isLiteral(BigDecimal.ONE, \"1\"));\n    ml(\"~3.5\").assertParseLiteral(isLiteral(new BigDecimal(\"-3.5\"), \"~3.5\"));\n    ml(\"\\\"a string\\\"\")\n        .assertParseLiteral(isLiteral(\"a string\", \"\\\"a string\\\"\"));\n    ml(\"\\\"\\\"\").assertParseLiteral(isLiteral(\"\", \"\\\"\\\"\"));\n    ml(\"\\\"a\\\\\\\\b\\\\\\\"c\\\"\")\n        .assertParseLiteral(isLiteral(\"a\\\\b\\\"c\", \"\\\"a\\\\\\\\b\\\\\\\"c\\\"\"));\n    ml(\"#\\\"a\\\"\").assertParseLiteral(isLiteral('a', \"#\\\"a\\\"\"));\n    ml(\"#\\\"\\\\\\\"\\\"\").assertParseLiteral(isLiteral('\"', \"#\\\"\\\\\\\"\\\"\"));\n    ml(\"#\\\"\\\\\\\\\\\"\").assertParseLiteral(isLiteral('\\\\', \"#\\\"\\\\\\\\\\\"\"));\n\n    // true and false are variables, not actually literals\n    ml(\"true\").assertParseStmt(Ast.Id.class, \"true\");\n    ml(\"false\").assertParseStmt(Ast.Id.class, \"false\");\n\n    ml(\"val x = 5\").assertParseDecl(Ast.ValDecl.class, \"val x = 5\");\n    ml(\"val `x` = 5\").assertParseDecl(Ast.ValDecl.class, \"val x = 5\");\n    ml(\"val x : int = 5\")\n        .assertParseDecl(Ast.ValDecl.class, \"val x : int = 5\");\n\n    // other valid identifiers\n    ml(\"val x' = 5\").assertParseDecl(Ast.ValDecl.class, \"val x' = 5\");\n    ml(\"val x'' = 5\").assertParseDecl(Ast.ValDecl.class, \"val x'' = 5\");\n    ml(\"val x'y = 5\").assertParseDecl(Ast.ValDecl.class, \"val x'y = 5\");\n    ml(\"val ABC123 = 5\").assertParseDecl(Ast.ValDecl.class, \"val ABC123 = 5\");\n    ml(\"val Abc_123 = 6\").assertParseDecl(Ast.ValDecl.class, \"val Abc_123 = 6\");\n    ml(\"val Abc_ = 7\").assertParseDecl(Ast.ValDecl.class, \"val Abc_ = 7\");\n\n    ml(\"val succ = fn x => x + 1\")\n        .assertParseDecl(Ast.ValDecl.class, \"val succ = fn x => x + 1\");\n\n    ml(\"val plus = fn x => fn y => x + y\")\n        .assertParseDecl(Ast.ValDecl.class, \"val plus = fn x => fn y => x + y\");\n\n    ml(\"fun plus x y = x + y\")\n        .assertParseDecl(Ast.FunDecl.class, \"fun plus x y = x + y\");\n\n    ml(\"datatype 'a option = NONE | SOME of 'a\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype 'a option = NONE | SOME of 'a\");\n\n    ml(\"datatype color = RED | GREEN | BLUE\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype color = RED | GREEN | BLUE\");\n    ml(\"datatype 'a tree = Empty | Node of 'a * 'a forest\\n\"\n        + \"and      'a forest = Nil | Cons of 'a tree * 'a forest\")\n        .assertParseDecl(Ast.DatatypeDecl.class, \"datatype 'a tree = Empty\"\n            + \" | Node of 'a * 'a forest \"\n            + \"and 'a forest = Nil\"\n            + \" | Cons of 'a tree * 'a forest\");\n\n    final String ml = \"datatype ('a, 'b) choice =\"\n        + \" NEITHER\"\n        + \" | LEFT of 'a\"\n        + \" | RIGHT of 'b\"\n        + \" | BOTH of {a: 'a, b: 'b}\";\n    ml(ml).assertParseSame();\n\n    // -> is right-associative\n    ml(\"datatype x = X of int -> int -> int\").assertParseSame();\n    ml(\"datatype x = X of (int -> int) -> int\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of (int -> int) -> int\");\n    ml(\"datatype x = X of int -> (int -> int)\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of int -> int -> int\");\n\n    ml(\"datatype x = X of int * int list\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of int * int list\");\n    ml(\"datatype x = X of int * (int list)\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of int * int list\");\n    ml(\"datatype x = X of (int * int) list\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of (int * int) list\");\n    ml(\"datatype x = X of (int, int) pair\")\n        .assertParseDecl(Ast.DatatypeDecl.class,\n            \"datatype x = X of (int, int) pair\");\n\n    // \"*\" is non-associative; parentheses cannot be removed\n    ml(\"datatype ('a, 'b, 'c) foo = Triple of 'a * 'b * 'c\").assertParseSame();\n    ml(\"datatype ('a, 'b, 'c) foo = Triple of 'a * ('b * 'c)\")\n        .assertParseSame();\n    ml(\"datatype ('a, 'b, 'c) foo = Triple of ('a * 'b) * 'c\")\n        .assertParseSame();\n\n    // parentheses creating left precedence, which is the natural precedence for\n    // '+', can be removed\n    ml(\"((1 + 2) + 3) + 4\")\n        .assertParse(\"1 + 2 + 3 + 4\");\n\n    // parentheses creating right precedence can not be removed\n    ml(\"1 + (2 + (3 + (4)))\")\n        .assertParse(\"1 + (2 + (3 + 4))\");\n\n    ml(\"1 + (2 + (3 + 4)) = 5 + 5\")\n        .assertParse(\"1 + (2 + (3 + 4)) = 5 + 5\");\n\n    // :: is right-associative\n    ml(\"1 :: 2 :: 3 :: []\")\n        .assertParse(\"1 :: 2 :: 3 :: []\");\n    ml(\"((1 :: 2) :: 3) :: []\")\n        .assertParse(\"((1 :: 2) :: 3) :: []\");\n    ml(\"1 :: (2 :: (3 :: []))\")\n        .assertParse(\"1 :: 2 :: 3 :: []\");\n    ml(\"1 + 2 :: 3 + 4 * 5 :: 6\").assertParseSame();\n\n    // o is left-associative;\n    // lower precedence than \"=\" (4), higher than \"andalso\" (2)\n    ml(\"f o g\").assertParseSame();\n    ml(\"f o g o h\").assertParseSame();\n    ml(\"f o (g o h)\").assertParseSame();\n    ml(\"(f o g) o h\").assertParse(\"f o g o h\");\n\n    ml(\"a = f o g andalso c = d\").assertParseSame();\n    ml(\"a = (f o g) andalso (c = d)\").assertParse(\"a = (f o g) andalso c = d\");\n    ml(\"(a = f) o g andalso (c = d)\").assertParse(\"a = f o g andalso c = d\");\n\n    // @ is right-associative;\n    // lower precedence than \"+\" (6), higher than \"=\" (4)\n    ml(\"f @ g\").assertParseSame();\n    ml(\"f @ g @ h\").assertParseSame();\n    ml(\"f @ (g @ h)\").assertParse(\"f @ g @ h\");\n    ml(\"(f @ g) @ h\").assertParseSame();\n\n    // ^ is left-associative;\n    // lower precedence than \"*\" (7), higher than \"@\" (5)\n    ml(\"a * f ^ g @ b\").assertParseSame();\n    ml(\"(a * f) ^ (g @ b)\").assertParse(\"a * f ^ (g @ b)\");\n\n    ml(\"(1 + 2, 3, true, (5, 6), 7 = 8)\").assertParseSame();\n\n    ml(\"let val x = 2 in x + (3 + x) + x end\").assertParseSame();\n\n    ml(\"let val x = 2 and y = 3 in x + y end\").assertParseSame();\n    ml(\"let val rec x = 2 and y = 3 in x + y end\").assertParseSame();\n    ml(\"let val x = 2 and rec y = 3 in x + y end\")\n        .assertParseThrowsParseException(\n            containsString(\n                \"Encountered \\\" \\\"rec\\\" \\\"rec \\\"\\\" at line 1, column 19.\"));\n\n    // : is right-associative and low precedence\n    ml(\"1 : int : int\").assertParseSame();\n    ml(\"(2 : int) + 1 : int\").assertParseSame();\n    ml(\"(2 : int) + (1 : int) : int\").assertParseSame();\n    ml(\"((2 : int) + (1 : int)) : int\")\n        .assertParse(\"(2 : int) + (1 : int) : int\");\n\n    // pattern\n    ml(\"let val (x, y) = (1, 2) in x + y end\").assertParseSame();\n    ml(\"let val w as (x, y) = (1, 2) in #1 w + #2 w + x + y end\")\n        .assertParseSame();\n\n    // record\n    ml(\"{a = 1}\").assertParseSame();\n    ml(\"{a = 1, b = 2}\").assertParseSame();\n    ml(\"{a = 1, b = {c = 2, d = true}, e = true}\").assertParseSame();\n\n    // if\n    ml(\"if true then 1 else 2\").assertParseSame();\n\n    // if ... else if\n    ml(\"if true then 1 else if false then 2 else 3\").assertParseSame();\n\n    // case\n    ml(\"case 1 of 0 => \\\"zero\\\" | _ => \\\"nonzero\\\"\").assertParseSame();\n    ml(\"case {a = 1, b = 2} of {a = 1, ...} => 1\").assertParseSame();\n    ml(\"case {a = 1, b = 2} of {...} => 1\").assertParseSame();\n    ml(\"case {a = 1, b = 2} of {a = 3, ...} => 1\")\n        .assertParse(\"case {a = 1, b = 2} of {a = 3, ...} => 1\");\n\n    // fn\n    ml(\"fn x => x + 1\").assertParseSame();\n    ml(\"fn x => x + (1 + 2)\").assertParseSame();\n    ml(\"fn (x, y) => x + y\").assertParseSame();\n    ml(\"fn _ => 42\").assertParseSame();\n    ml(\"fn x => case x of 0 => 1 | _ => 2\").assertParseSame();\n    ml(\"fn () => 42\").assertParseSame();\n\n    // apply\n    ml(\"(fn x => x + 1) 3\").assertParseSame();\n  }\n\n  @Test void testParseComment() {\n    ml(\"1 + (* 2 + *) 3\")\n        .assertParse(\"1 + 3\");\n    ml(\"1 +\\n\"\n        + \"(* 2 +\\n\"\n        + \" *) 3\").assertParse(\"1 + 3\");\n    ml(\"(* 1 +\\n\"\n        + \"2 +\\n\"\n        + \"3 *) 5 + 6\").assertParse(\"5 + 6\");\n  }\n\n  @Test void testParseCase() {\n    // SML/NJ allows 'e' and 'E'\n    ml(\"1e2\").assertParse(\"1E+2\");\n    ml(\"1E2\").assertParse(\"1E+2\");\n\n    // keywords such as 'val' and 'in' are case sensitive\n    ml(\"let val x = 1 in x + 1 end\").assertParseSame();\n    ml(\"let VAL x = 1 in x + 1 end\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" <IDENTIFIER> \\\"VAL \\\"\"));\n    ml(\"let val x = 1 IN x + 1 end\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"end\\\" \\\"end \\\"\"));\n\n    // 'notelem' is an infix operator;\n    // 'notElem' and 'NOTELEM' are ordinary identifiers\n    ml(\"1 + f notelem g * 2\")\n        .assertParse(true, \"((((1) + (f))) notelem (((g) * (2))))\");\n    ml(\"1 + f notElem g * 2\")\n        .assertParse(true, \"((1) + (((((((f) (notElem))) (g))) * (2))))\");\n    ml(\"1 + f NOTELEM g * 2\")\n        .assertParse(true, \"((1) + (((((((f) (NOTELEM))) (g))) * (2))))\");\n\n    // 'o' is an infix operator;\n    // 'O' is presumed to be just another value.\n    ml(\"1 + f o g + 2\")\n        .assertParse(true, \"((((1) + (f))) o (((g) + (2))))\");\n    ml(\"1 + F o G + 2\")\n        .assertParse(true, \"((((1) + (F))) o (((G) + (2))))\");\n    ml(\"1 + f O g + 2\")\n        .assertParse(true, \"((((1) + (((((f) (O))) (g))))) + (2))\");\n  }\n\n  /** Tests that the syntactic sugar \"exp.field\" is de-sugared to\n   * \"#field exp\". */\n  @Test void testParseDot() {\n    ml(\"a . b\")\n        .assertParse(\"#b a\");\n    ml(\"a . b . c\")\n        .assertParse(\"#c (#b a)\");\n    ml(\"a . b + c . d\")\n        .assertParse(\"#b a + #d c\");\n    ml(\"a.b+c.d\")\n        .assertParse(\"#b a + #d c\");\n    ml(\"(a.b+c.d*e.f.g).h\")\n        .assertParse(\"#h (#b a + #d c * #g (#f e))\");\n    ml(\"a b\")\n        .assertParse(\"a b\");\n    ml(\"a b.c\")\n        .assertParse(\"a (#c b)\");\n    ml(\"a.b c.d e.f\")\n        .assertParse(\"#b a (#d c) (#f e)\");\n    ml(\"(a.b) (c.d) (e.f)\")\n        .assertParse(\"#b a (#d c) (#f e)\");\n    ml(\"(a.(b (c.d) (e.f))\")\n        .assertParseThrowsParseException(\n            containsString(\"Encountered \\\" \\\"(\\\" \\\"( \\\"\\\" at line 1, column 4.\"));\n    ml(\"(a.b c.(d (e.f)))\")\n        .assertParseThrowsParseException(\n            containsString(\"Encountered \\\" \\\"(\\\" \\\"( \\\"\\\" at line 1, column 8.\"));\n  }\n\n  /** Tests that the abbreviated record syntax \"{a, e.b, #c e, d = e}\"\n   * is expanded to \"{a = a, b = e.b, c = #c e, d = e}\". */\n  @Test void testParseAbbreviatedRecord() {\n    ml(\"{a, e.b, #c e, #d (e + 1), e = f + g}\")\n        .assertParse(\"{a = a, b = #b e, c = #c e, d = #d (e + 1), e = f + g}\");\n    ml(\"{v = a, w = e.b, x = #c e, y = #d (e + 1), z = (#f 2)}\")\n        .assertParse(\"{v = a, w = #b e, x = #c e, y = #d (e + 1), z = #f 2}\");\n    ml(\"{w = a = b + c, a = b + c}\")\n        .assertParse(\"{a = b + c, w = a = b + c}\");\n    ml(\"{1}\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression 1\"));\n    ml(\"{a, b + c}\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression b + c\"));\n\n    ml(\"case x of {a = a, b} => a + b\")\n        .assertParse(\"case x of {a = a, b = b} => a + b\");\n    ml(\"case x of {a, b = 2, ...} => a + b\")\n        .assertParse(\"case x of {a = a, b = 2, ...} => a + b\");\n    ml(\"fn {a, b = 2, ...} => a + b\")\n        .assertParse(\"fn {a = a, b = 2, ...} => a + b\");\n  }\n\n  @Test void testParseErrorPosition() {\n    ml(\"let val x = 1 and y = $x$ + 2 in x + y end\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"unbound variable or constructor: x\", pos));\n  }\n\n  @Test void testRuntimeErrorPosition() {\n    ml(\"\\\"x\\\" ^\\n\"\n        + \"  $String.substring(\\\"hello\\\",\\n\"\n        + \"    1, 15)$ ^\\n\"\n        + \"  \\\"y\\\"\\n\", '$')\n        .assertEvalError(pos ->\n            throwsA(Codes.BuiltInExn.SUBSCRIPT.mlName, pos));\n  }\n\n  /** Tests the name of {@link TypeVar}. */\n  @Test void testTypeVarName() {\n    assertError(() -> new TypeVar(-1).key(),\n        throwsA(IllegalArgumentException.class, nullValue()));\n    assertThat(new TypeVar(0), hasToString(\"'a\"));\n    assertThat(new TypeVar(1), hasToString(\"'b\"));\n    assertThat(new TypeVar(2), hasToString(\"'c\"));\n    assertThat(new TypeVar(25), hasToString(\"'z\"));\n    assertThat(new TypeVar(26), hasToString(\"'ba\"));\n    assertThat(new TypeVar(27), hasToString(\"'bb\"));\n    assertThat(new TypeVar(51), hasToString(\"'bz\"));\n    assertThat(new TypeVar(52), hasToString(\"'ca\"));\n    assertThat(new TypeVar(53), hasToString(\"'cb\"));\n    assertThat(new TypeVar(26 * 26 - 1), hasToString(\"'zz\"));\n    assertThat(new TypeVar(26 * 26), hasToString(\"'baa\"));\n    assertThat(new TypeVar(27 * 26 - 1), hasToString(\"'baz\"));\n    assertThat(new TypeVar(26 * 26 * 26 - 1), hasToString(\"'zzz\"));\n    assertThat(new TypeVar(26 * 26 * 26), hasToString(\"'baaa\"));\n  }\n\n  @Test void testType() {\n    ml(\"1\").assertType(\"int\");\n    ml(\"0e0\").assertType(\"real\");\n    ml(\"1 + 2\").assertType(\"int\");\n    ml(\"1 - 2\").assertType(\"int\");\n    ml(\"1 * 2\").assertType(\"int\");\n    ml(\"1 / 2\").assertType(\"int\");\n    ml(\"1 / ~2\").assertType(\"int\");\n    ml(\"1.0 + ~2.0\").assertType(\"real\");\n    ml(\"\\\"\\\"\").assertType(\"string\");\n    ml(\"true andalso false\").assertType(\"bool\");\n    ml(\"if true then 1.0 else 2.0\").assertType(\"real\");\n    ml(\"(1, true)\").assertType(\"int * bool\");\n    ml(\"(1, true, false andalso false)\").assertType(\"int * bool * bool\");\n    ml(\"(1)\").assertType(\"int\");\n    ml(\"()\").assertType(\"unit\");\n    ml(\"{a = 1, b = true}\").assertType(\"{a:int, b:bool}\");\n    ml(\"(fn x => x + 1, fn y => y + 1)\")\n        .assertType(\"(int -> int) * (int -> int)\");\n    ml(\"let val x = 1.0 in x + 2.0 end\").assertType(\"real\");\n\n    final String ml = \"let val x = 1 in\\n\"\n        + \"  let val y = 2 in\\n\"\n        + \"    x + y\\n\"\n        + \"  end\\n\"\n        + \"end\";\n    ml(ml).assertType(\"int\");\n\n    ml(\"1 + \\\"a\\\"\")\n        .assertTypeException(\"Cannot deduce type: conflict: int vs string\");\n\n    ml(\"NONE\").assertType(\"'a option\");\n    ml(\"SOME 4\").assertType(\"int option\");\n    ml(\"SOME (SOME true)\").assertType(\"bool option option\");\n    ml(\"SOME (SOME [1, 2])\")\n        .assertType(\"int list option option\");\n    ml(\"SOME (SOME {a=1, b=true})\")\n        .assertType(\"{a:int, b:bool} option option\");\n  }\n\n  @Test void testTypeFn() {\n    ml(\"fn x => x + 1\").assertType(\"int -> int\");\n    ml(\"fn x => fn y => x + y\").assertType(\"int -> int -> int\");\n    ml(\"fn x => case x of 0 => 1 | _ => 2\").assertType(\"int -> int\");\n    ml(\"fn x => case x of 0 => \\\"zero\\\" | _ => \\\"nonzero\\\"\")\n        .assertType(\"int -> string\");\n    ml(\"fn x: int => true\").assertType(\"int -> bool\");\n    ml(\"fn x: int * int => true\").assertType(\"int * int -> bool\");\n    ml(\"fn x: int * string => (false, #2 x)\")\n        .assertType(\"int * string -> bool * string\");\n  }\n\n  @Test void testTypeFnTuple() {\n    ml(\"fn (x, y) => (x + 1, y + 1)\")\n        .assertType(\"int * int -> int * int\");\n    ml(\"(fn x => x + 1, fn y => y + 1)\")\n        .assertType(\"(int -> int) * (int -> int)\");\n    ml(\"fn x => fn (y, z) => x + y + z\")\n        .assertType(\"int -> int * int -> int\");\n    ml(\"fn (x, y) => (x + 1, fn z => (x + z, y + z), y)\")\n        .assertType(\"int * int -> int * (int -> int * int) * int\");\n    ml(\"fn {a = x, b = y, c} => x + y\")\n        .assertType(\"{a:int, b:int, c:'a} -> int\");\n  }\n\n  @Test void testTypeLetRecFn() {\n    final String ml = \"let\\n\"\n        + \"  val rec f = fn n => if n = 0 then 1 else n * (f (n - 1))\\n\"\n        + \"in\\n\"\n        + \"  f 5\\n\"\n        + \"end\";\n    ml(ml).assertType(\"int\");\n\n    final String ml2 = ml.replace(\" rec\", \"\");\n    assertThat(ml2, not(is(ml)));\n    ml(ml2).assertError(is(\"f not found\"));\n\n    ml(\"let val rec x = 1 and y = 2 in x + y end\")\n        .assertError(\"Error: fn expression required on rhs of val rec\");\n  }\n\n  @Test void testRecordType() {\n    final String ml = \"map #empno [{empno = 10, name = \\\"Shaggy\\\"}]\";\n    ml(ml).assertType(\"int list\");\n  }\n\n  @Test void testIncompleteRecordType() {\n    final String ml = \"fn (e, job) => e.job = job\";\n    String message =\n        \"unresolved flex record (can't tell what fields there are besides #job)\";\n    ml(ml).withTypeExceptionMatcher(throwsA(message))\n        .assertEval();\n  }\n\n  @Test void testApply() {\n    ml(\"hd [\\\"abc\\\"]\")\n        .assertType(\"string\");\n  }\n\n  @Test void testApply2() {\n    ml(\"map (fn x => String.size x) [\\\"abc\\\", \\\"de\\\"]\")\n        .assertType(\"int list\");\n  }\n\n  @Test void testApplyIsMonomorphic() {\n    // cannot be typed, since the parameter f is in a monomorphic position\n    ml(\"fn f => (f true, f 0)\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Cannot deduce type: conflict: int vs bool\")));\n  }\n\n  @Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test void testLetIsPolymorphic() {\n    // f has been introduced in a let-expression and is therefore treated as\n    // polymorphic.\n    ml(\"let val f = fn x => x in (f true, f 0) end\")\n        .assertType(\"bool * int\");\n  }\n\n  @Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test void testHdIsPolymorphic() {\n    ml(\"(hd [1, 2], hd [false, true])\")\n        .assertType(\"int * bool\");\n    ml(\"let\\n\"\n        + \"  val h = hd\\n\"\n        + \"in\\n\"\n        + \"   (h [1, 2], h [false, true])\\n\"\n        + \"end\")\n        .assertType(\"int * bool\");\n  }\n\n  @Test void testTypeVariable() {\n    // constant\n    ml(\"fn _ => 42\").assertType(\"'a -> int\");\n    ml(\"(fn _ => 42) 2\").assertEval(is(42));\n    ml(\"fn _ => fn _ => 42\").assertType(\"'a -> 'b -> int\");\n\n    // identity\n    ml(\"fn x => x\").assertType(\"'a -> 'a\");\n    ml(\"(fn x => x) 2\").assertEval(is(2));\n    ml(\"(fn x => x) \\\"foo\\\"\").assertEval(is(\"foo\"));\n    ml(\"(fn x => x) true\").assertEval(is(true));\n    ml(\"let fun id x = x in id end\").assertType(\"'a -> 'a\");\n    ml(\"fun id x = x\").assertType(\"'a -> 'a\");\n\n    // first/second\n    ml(\"fn x => fn y => x\").assertType(\"'a -> 'b -> 'a\");\n    ml(\"let fun first x y = x in first end\")\n        .assertType(\"'a -> 'b -> 'a\");\n    ml(\"fun first x y = x\")\n        .assertType(\"'a -> 'b -> 'a\");\n    ml(\"fun second x y = y\")\n        .assertType(\"'a -> 'b -> 'b\");\n    ml(\"fun choose b x y = if b then x else y\")\n        .assertType(\"bool -> 'a -> 'a -> 'a\");\n    ml(\"fun choose b (x, y) = if b then x else y\")\n        .assertType(\"bool -> 'a * 'a -> 'a\");\n  }\n\n  @Disabled(\"disable failing test - enable when we have polymorphic types\")\n  @Test void testExponentialType0() {\n    final String ml = \"let\\n\"\n        + \"  fun f x = (x, x)\\n\"\n        + \"in\\n\"\n        + \"  f (f 0)\\n\"\n        + \"end\";\n    ml(ml).assertType(\"xx\");\n  }\n\n  @Disabled(\"until type-inference bug is fixed\")\n  @Test void testExponentialType() {\n    final String ml = \"let\\n\"\n        + \"  fun f x = (x, x, x)\\n\"\n        + \"in\\n\"\n        + \"   f (f (f (f (f 0))))\\n\"\n        + \"end\";\n    ml(ml).assertType(\"xx\");\n  }\n\n  @Disabled(\"until type-inference bug is fixed\")\n  @Test void testExponentialType2() {\n    final String ml = \"fun f x y z = (x, y, z)\\n\"\n        + \"val p1 = (f, f, f)\\n\"\n        + \"val p2 = (p1, p1, p1)\\n\"\n        + \"val p3 = (p2, p2, p2)\\n\";\n    ml(ml).assertType(\"xx\");\n  }\n\n  @SuppressWarnings(\"ConstantConditions\")\n  @Test void testDummy() {\n    ml(\"from d in [{a=1,b=true}] yield d.a into sum\")\n        .assertType(\"int\")\n        .assertEval(is(1));\n    switch (0) {\n    case 0:\n      ml(\"1\").assertEval(is(1));\n      // fall through\n    case 1:\n      ml(\"1 + 2\").assertEval(is(3));\n      // fall through\n    case 2:\n      ml(\"1 + 2 + 3\").assertEval(is(6));\n      // fall through\n    case 3:\n      ml(\"1 * 2 + 3 * 4\").assertEval(is(14));\n      // fall through\n    case 4:\n      ml(\"let val x = 1 in x + 2 end\")\n          .with(Prop.INLINE_PASS_COUNT, 0)\n          .assertEval(is(3));\n      // fall through\n    case 5:\n      ml(\"let val x = 1 and y = 2 in 7 end\")\n          .with(Prop.INLINE_PASS_COUNT, 0)\n          .assertEval(is(7));\n      // fall through\n    case 6:\n      ml(\"let val x = 1 and y = 2 in x + y + 4 end\")\n          .with(Prop.INLINE_PASS_COUNT, 0)\n          .assertEval(is(7));\n      // fall through\n    case 7:\n      ml(\"(not (true andalso false))\").assertEval(is(true));\n      // fall through\n    case 8:\n      ml(\"let val x = 1 and y = 2 and z = true and a = \\\"foo\\\" in\\n\"\n          + \"  if z then x else y\\n\"\n          + \"end\").assertEval(is(1));\n    }\n  }\n\n  @Test void testEval() {\n    // literals\n    ml(\"1\").assertEval(is(1));\n    ml(\"~2\").assertEval(is(-2));\n    ml(\"\\\"a string\\\"\").assertEval(is(\"a string\"));\n    ml(\"true\").assertEval(is(true));\n    ml(\"~10.25\").assertEval(is(-10.25f));\n    ml(\"~10.25e3\").assertEval(is(-10_250f));\n    ml(\"~1.25e~3\").assertEval(is(-0.001_25f));\n    ml(\"~1.25E~3\").assertEval(is(-0.001_25f));\n    ml(\"0e0\").assertEval(is(0f));\n\n    // boolean operators\n    ml(\"true andalso false\").assertEval(is(false));\n    ml(\"true orelse false\").assertEval(is(true));\n    ml(\"false andalso false orelse true\").assertEval(is(true));\n    ml(\"false andalso true orelse true\").assertEval(is(true));\n    ml(\"(not (true andalso false))\").assertEval(is(true));\n    ml(\"not true\").assertEval(is(false));\n    ml(\"not not true\")\n        .assertError(\"operator and operand don't agree [tycon mismatch]\\n\"\n            + \"  operator domain: bool\\n\"\n            + \"  operand:         bool -> bool\");\n    ml(\"not (not true)\").assertEval(is(true));\n\n    // comparisons\n    ml(\"1 = 1\").assertEval(is(true));\n    ml(\"1 = 2\").assertEval(is(false));\n    ml(\"\\\"a\\\" = \\\"a\\\"\").assertEval(is(true));\n    ml(\"\\\"a\\\" = \\\"ab\\\"\").assertEval(is(false));\n    ml(\"1 < 1\").assertEval(is(false));\n    ml(\"1 < 2\").assertEval(is(true));\n    ml(\"\\\"a\\\" < \\\"a\\\"\").assertEval(is(false));\n    ml(\"\\\"a\\\" < \\\"ab\\\"\").assertEval(is(true));\n    ml(\"1 > 1\").assertEval(is(false));\n    ml(\"1 > 2\").assertEval(is(false));\n    ml(\"1 > ~2\").assertEval(is(true));\n    ml(\"\\\"a\\\" > \\\"a\\\"\").assertEval(is(false));\n    ml(\"\\\"a\\\" > \\\"ab\\\"\").assertEval(is(false));\n    ml(\"\\\"ac\\\" > \\\"ab\\\"\").assertEval(is(true));\n    ml(\"1 <= 1\").assertEval(is(true));\n    ml(\"1 <= 2\").assertEval(is(true));\n    ml(\"\\\"a\\\" <= \\\"a\\\"\").assertEval(is(true));\n    ml(\"\\\"a\\\" <= \\\"ab\\\"\").assertEval(is(true));\n    ml(\"1 >= 1\").assertEval(is(true));\n    ml(\"1 >= 2\").assertEval(is(false));\n    ml(\"1 >= ~2\").assertEval(is(true));\n    ml(\"\\\"a\\\" >= \\\"a\\\"\").assertEval(is(true));\n    ml(\"\\\"a\\\" >= \\\"ab\\\"\").assertEval(is(false));\n    ml(\"\\\"ac\\\" >= \\\"ab\\\"\").assertEval(is(true));\n    ml(\"1 + 4 = 2 + 3\").assertEval(is(true));\n    ml(\"1 + 2 * 2 = 2 + 3\").assertEval(is(true));\n    ml(\"1 + 2 * 2 < 2 + 3\").assertEval(is(false));\n    ml(\"1 + 2 * 2 > 2 + 3\").assertEval(is(false));\n\n    // arithmetic operators\n    ml(\"2 + 3\").assertEval(is(5));\n    ml(\"2 + 3 * 4\").assertEval(is(14));\n    ml(\"2 * 3 + 4 * 5\").assertEval(is(26));\n    ml(\"2 - 3\").assertEval(is(-1));\n    ml(\"2 * 3\").assertEval(is(6));\n    ml(\"20 / 3\").assertEval(is(6));\n    ml(\"20 / ~3\").assertEval(is(-6));\n\n    ml(\"10 mod 3\").assertEval(is(1));\n    ml(\"~10 mod 3\").assertEval(is(2));\n    ml(\"~10 mod ~3\").assertEval(is(-1));\n    ml(\"10 mod ~3\").assertEval(is(-2));\n    ml(\"0 mod 3\").assertEval(is(-0));\n    ml(\"0 mod ~3\").assertEval(is(0));\n    ml(\"19 div 3\").assertEval(is(6));\n    ml(\"20 div 3\").assertEval(is(6));\n    ml(\"~19 div 3\").assertEval(is(-7));\n    ml(\"~18 div 3\").assertEval(is(-6));\n    ml(\"19 div ~3\").assertEval(is(-7));\n    ml(\"~21 div 3\").assertEval(is(-7));\n    ml(\"~21 div ~3\").assertEval(is(7));\n    ml(\"0 div 3\").assertEval(is(0));\n\n    // string operators\n    ml(\"\\\"\\\" ^ \\\"\\\"\").assertEval(is(\"\"));\n    ml(\"\\\"1\\\" ^ \\\"2\\\"\").assertEval(is(\"12\"));\n    ml(\"1 ^ 2\")\n        .assertError(\"operator and operand don't agree [overload conflict]\\n\"\n            + \"  operator domain: string * string\\n\"\n            + \"  operand:         [int ty] * [int ty]\\n\");\n\n    // if\n    ml(\"if true then 1 else 2\").assertEval(is(1));\n    ml(\"if false then 1 else if true then 2 else 3\").assertEval(is(2));\n    ml(\"if false\\n\"\n        + \"then\\n\"\n        + \"  if true then 2 else 3\\n\"\n        + \"else 4\").assertEval(is(4));\n    ml(\"if false\\n\"\n        + \"then\\n\"\n        + \"  if true then 2 else 3\\n\"\n        + \"else\\n\"\n        + \"  if false then 4 else 5\").assertEval(is(5));\n\n    // case\n    ml(\"case 1 of 0 => \\\"zero\\\" | _ => \\\"nonzero\\\"\")\n        .assertType(\"string\")\n        .assertEval(is(\"nonzero\"));\n    ml(\"case 1 of x => x | y => y\")\n        .assertError(\"Error: match redundant\\n\"\n            + \"          x => ...\\n\"\n            + \"    -->   y => ...\\n\");\n    ml(\"case 1 of 1 => 2\")\n        .assertError(\"Warning: match nonexhaustive\\n\"\n            + \"          1 => ...\\n\");\n    ml(\"let val f = fn x => case x of x => x + 1 in f 2 end\").assertEval(is(3));\n\n    // let\n    ml(\"let val x = 1 in x + 2 end\").assertEval(is(3));\n    ml(\"let val x = 1 in ~x end\").assertEval(is(-1));\n    ml(\"let val x = 1 in ~(abs(~x)) end\").assertEval(is(-1));\n\n    // let with a tuple pattern\n    ml(\"let val (x, y) = (1, 2) in x + y end\").assertEval(is(3));\n    ml(\"let val w as (x, y) = (1, 2) in #1 w + #2 w + x + y end\")\n        .assertEval(is(6));\n\n    // composite val\n    ml(\"val x = 1 and y = 2\").assertEval(is(map(\"x\", 1, \"y\", 2)));\n    ml(\"val (x, y) = (1, true)\").assertEval(is(map(\"x\", 1, \"y\", true)));\n    ml(\"val w as (x, y) = (2, false)\")\n        .assertEval(is(map(\"x\", 2, \"y\", false, \"w\", list(2, false))));\n\n    // let with multiple variables\n    ml(\"let val x = 1 and y = 2 in x + y end\").assertEval(is(3));\n    // let with multiple variables\n    ml(\"let val x = 1 and y = 2 and z = false in\\n\"\n        + \"  if z then x else y\\n\"\n        + \"end\").assertEval(is(2));\n    ml(\"let val x = 1 and y = 2 and z = true in\\n\"\n        + \"  if z then x else y\\n\"\n        + \"end\").assertEval(is(1));\n    ml(\"let val x = 1 and y = 2 and z = true and a = \\\"foo\\\" in\\n\"\n        + \"  if z then x else y\\n\"\n        + \"end\").assertEval(is(1));\n\n    // let where variables shadow\n    final String letNested = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"in\\n\"\n        + \"  let\\n\"\n        + \"    val x = 2\\n\"\n        + \"  in\\n\"\n        + \"    x * 3\\n\"\n        + \"  end + x\\n\"\n        + \"end\";\n    ml(letNested).assertEval(is(2 * 3 + 1));\n\n    // let with match\n    ml(\"(fn z => let val (x, y) = (z + 1, z + 2) in x + y end) 3\")\n        .assertEval(is(9));\n\n    // tuple\n    ml(\"(1, 2)\").assertEval(is(list(1, 2)));\n    ml(\"(1, (2, true))\").assertEval(is(list(1, list(2, true))));\n    ml(\"()\").assertEval(is(Collections.emptyList()));\n    ml(\"(1, 2, 1, 4)\").assertEval(is(list(1, 2, 1, 4)));\n  }\n\n  @Test void testLetSequentialDeclarations() {\n    // let with sequential declarations\n    ml(\"let val x = 1; val y = x + 1 in x + y end\").assertEval(is(3));\n\n    // semicolon is optional\n    ml(\"let val x = 1; val y = x + 1; in x + y end\").assertEval(is(3));\n    ml(\"let val x = 1 val y = x + 1 in x + y end\").assertEval(is(3));\n\n    // 'and' is executed in parallel, therefore 'x + 1' evaluates to 2, not 4\n    ml(\"let val x = 1; val x = 3 and y = x + 1 in x + y end\").assertEval(is(5));\n\n    ml(\"let val x = 1 and y = $x$ + 2 in x + y end\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"unbound variable or constructor: x\"));\n\n    // let with val and fun\n    ml(\"let fun f x = 1 + x; val x = 2 in f x end\").assertEval(is(3));\n  }\n\n  /** Tests that in a {@code let} clause, we can see previously defined\n   * variables. */\n  @Test void testLet2() {\n    final String ml = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"  val y = x + 2\\n\"\n        + \"in\\n\"\n        + \"  y + x + 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(7));\n  }\n\n  /** As {@link #testLet2()}, but using 'and'. */\n  @Test void testLet3() {\n    final String ml = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"  and y = 2\\n\"\n        + \"in\\n\"\n        + \"  y + x + 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(6));\n  }\n\n  /** As {@link #testLet3()}, but a tuple is being assigned. */\n  @Test void testLet3b() {\n    // The intermediate form will have nested tuples, something like this:\n    //   val v = (1, (2, 4)) in case v of (x, (y, z)) => y + 3 + x\n    final String ml = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"  and (y, z) = (2, 4)\\n\"\n        + \"in\\n\"\n        + \"  y + x + 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(6));\n  }\n\n  @Test void testLet3c() {\n    // The intermediate form will have nested tuples, something like this:\n    //   val v = (1, (2, 4)) in case v of (x, (y, z)) => y + 3 + x\n    final String ml = \"let\\n\"\n        + \"  val x1 :: x2 :: xs = [1, 5, 9, 13, 17]\\n\"\n        + \"  and (y, z) = (2, 4)\\n\"\n        + \"in\\n\"\n        + \"  y + x1 + x2 + 3\\n\"\n        + \"end\";\n    ml(ml)\n        .with(Prop.MATCH_COVERAGE_ENABLED, false)\n        .assertEval(is(11));\n  }\n\n  /** Tests that 'and' assignments occur simultaneously. */\n  @Test void testLet4() {\n    final String ml = \"let\\n\"\n        + \"  val x = 5\\n\"\n        + \"  and y = 1\\n\"\n        + \"in\\n\"\n        + \"  let\\n\"\n        + \"    val x = y (* new x = old y = 1 *)\\n\"\n        + \"    and y = x + 2 (* new y = old x + 2 = 5 + 2 = 7 *)\\n\"\n        + \"  in\\n\"\n        + \"    y + x + 3 (* new y + new x + 3 = 7 + 1 + 3 = 11 *)\\n\"\n        + \"  end\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(11));\n  }\n\n  /** Tests a closure in a let. */\n  @Test void testLet5() {\n    final String ml = \"let\\n\"\n        + \"  val plus = fn x => fn y => x + y\\n\"\n        + \"  val plusTwo = plus 2\\n\"\n        + \"in\\n\"\n        + \"  plusTwo 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(5));\n  }\n\n  /** Tests a predicate in a let. */\n  @Test void testLet6() {\n    final String ml = \"let\\n\"\n        + \"  fun isZero x = x = 0\\n\"\n        + \"in\\n\"\n        + \"  fn i => i = 10 andalso isZero i\\n\"\n        + \"end\";\n    // With inlining, we want the plan to simplify to \"fn i => false\"\n    final String plan = \"match(i, andalso(apply2(\"\n        + \"fnValue =, get(name i), constant(10)), \"\n        + \"apply2(fnValue =, get(name i), constant(0))))\";\n    ml(ml)\n        .assertEval(whenAppliedTo(0, is(false)))\n        .assertEval(whenAppliedTo(10, is(false)))\n        .assertEval(whenAppliedTo(15, is(false)))\n        .assertPlan(isCode(plan));\n  }\n\n  /** Tests a function in a let. (From <a\n   * href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf\">Secrets\n   * of the Glasgow Haskell Compiler inliner</a> (GHC inlining), section 2.3. */\n  @Test void testLet7() {\n    final String ml = \"fun g (a, b, c) =\\n\"\n        + \"  let\\n\"\n        + \"    fun f x = x * 3\\n\"\n        + \"  in\\n\"\n        + \"    f (a + b) - c\\n\"\n        + \"  end\";\n    // With inlining, we want the plan to simplify to\n    // \"fn (a, b, c) => (a + b) * 3 - c\"\n    final String plan = \"match(v0, apply(fnCode match((a, b, c), \"\n        + \"apply2(fnValue -, apply2(fnValue *, \"\n        + \"apply2(fnValue +, get(name a), get(name b)), \"\n        + \"constant(3)), get(name c))), argCode get(name v0)))\";\n    ml(ml)\n        // g (4, 3, 2) = (4 + 3) * 3 - 2 = 19\n        .assertEval(whenAppliedTo(list(4, 3, 2), is(19)))\n        .assertPlan(isCode(plan));\n  }\n\n  /** Tests that a simple eager function ({@code Math.pow}) uses\n   * direct application ({@code apply2}) when its arguments are a tuple. */\n  @Test void testEvalApply2() {\n    final String ml = \"Math.pow (2.0, 3.0)\";\n    final String plan =\n        \"apply2(fnValue Math.pow, constant(2.0), constant(3.0))\";\n    ml(ml)\n        .assertEval(is(8f))\n        .assertPlan(isCode(plan));\n\n    // When the argument tuple is returned from a function call, we evaluate\n    // the long way ('apply').\n    final String ml2 = \"Math.pow (hd [(2.0, 3.0)])\";\n    final String plan2 = \"apply(fnValue Math.pow,\"\n        + \" argCode apply(fnValue List.hd, \"\n        + \"argCode tuple(tuple(constant(2.0), constant(3.0)))))\";\n    ml(ml2)\n        .assertEval(is(8f))\n        .assertPlan(isCode(plan2));\n  }\n\n  /** Tests that name capture does not occur during inlining.\n   * (Example is from GHC inlining, section 3.) */\n  @Test void testNameCapture() {\n    final String ml = \"fn (a, b) =>\\n\"\n        + \"  let val x = a + b in\\n\"\n        + \"    let val a = 7 in\\n\"\n        + \"      x + a\\n\"\n        + \"    end\\n\"\n        + \"  end\";\n    ml(ml)\n        // result should be x + a = (1 + 2) + 7 = 10\n        // if 'a' were wrongly captured, result would be (7 + 2) + 7 = 16\n        .assertEval(whenAppliedTo(list(1, 2), is(10)));\n  }\n\n  @Test void testMutualRecursion() {\n    final String ml = \"let\\n\"\n        + \"  fun f i = g (i * 2)\\n\"\n        + \"  and g i = if i > 10 then i else f (i + 3)\\n\"\n        + \"in\\n\"\n        + \"  f\\n\"\n        + \"end\";\n    ml(ml)\n        // answers checked on SMLJ\n        .assertEval(whenAppliedTo(1, is(26)))\n        .assertEval(whenAppliedTo(2, is(14)))\n        .assertEval(whenAppliedTo(3, is(18)));\n  }\n\n  @Test void testMutualRecursion3() {\n    final String ml = \"let\\n\"\n        + \"  fun isZeroMod3 0 = true | isZeroMod3 n = isTwoMod3 (n - 1)\\n\"\n        + \"  and isOneMod3 0 = false | isOneMod3 n = isZeroMod3 (n - 1)\\n\"\n        + \"  and isTwoMod3 0 = false | isTwoMod3 n = isOneMod3 (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fn n => (isZeroMod3 n, isOneMod3 n, isTwoMod3 n)\\n\"\n        + \"end\";\n    ml(ml)\n        .assertEval(whenAppliedTo(17, is(list(false, false, true))))\n        .assertEval(whenAppliedTo(18, is(list(true, false, false))));\n  }\n\n  /** Tests a recursive {@code let} that includes a pattern. I'm not sure\n   * whether this is valid Standard ML; SML-NJ doesn't like it. */\n  @Disabled(\"until mutual recursion bug is fixed\")\n  @Test void testCompositeRecursiveLet() {\n    final String ml = \"let\\n\"\n        + \"  val rec (x, y) = (1, 2)\\n\"\n        + \"  and f = fn n => if n = 1 then 1 else n * f (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  x + f 5 + y\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(123));\n  }\n\n  /** Tests that inlining of mutually recursive functions does not prevent\n   * compilation from terminating.\n   *\n   * <p>Per GHC inlining, (f, g, h), (g, p, q) are strongly connected components\n   * of the dependency graph. In each group, the inliner should choose one\n   * function as 'loop-breaker' that will not be inlined; say f and q. */\n  @Disabled(\"until mutual recursion bug is fixed\")\n  @Test void testMutualRecursionComplex() {\n    final String ml0 = \"let\\n\"\n        + \"  fun f i = g (i + 1)\\n\"\n        + \"  and g i = h (i + 2) + p (i + 4)\\n\"\n        + \"  and h i = if i > 100 then i + 8 else f (i + 16)\\n\"\n        + \"  and p i = q (i + 32)\\n\"\n        + \"  and q i = if i > 200 then i + 64 else g (i + 128)\\n\"\n        + \"in\\n\"\n        + \"  g 7\\n\"\n        + \"end\";\n    final String ml = \"let\\n\"\n        + \"  val rec f = fn i => g (i + 1)\\n\"\n        + \"  and g = fn i => h (i + 2) + p (i + 4)\\n\"\n        + \"  and h = fn i => if i > 100 then i + 8 else f (i + 16)\\n\"\n        + \"  and p = fn i => q (i + 32)\\n\"\n        + \"  and q = fn i => if i > 200 then i + 64 else g (i + 128)\\n\"\n        + \"in\\n\"\n        + \"  g 7\\n\"\n        + \"end\";\n    ml(ml)\n        // answers checked on SMLJ\n        .assertEval(whenAppliedTo(1, is(4003)))\n        .assertEval(whenAppliedTo(6, is(3381)))\n        .assertEval(whenAppliedTo(7, is(3394)));\n  }\n\n  /** Tests that you can use the same variable name in different parts of the\n   * program without the types getting confused. */\n  @Test void testSameVariableName() {\n    final String ml = \"List.filter\\n\"\n        + \" (fn e => e.x + 2 * e.y > 16)\\n\"\n        + \" (map\\n\"\n        + \"   (fn e => {x = e - 1, y = 10 - e})\\n\"\n        + \"   [1, 2, 3, 4, 5])\";\n    ml(ml).assertEval(isUnordered(list(list(0, 9), list(1, 8))));\n  }\n\n  /** As {@link #testSameVariableName()} but both variables are records. */\n  @Test void testSameVariableName2() {\n    final String ml = \"List.filter\\n\"\n        + \" (fn e => e.x + 2 * e.y > 16)\\n\"\n        + \" (map\\n\"\n        + \"   (fn e => {x = e.a - 1, y = 10 - e.a})\\n\"\n        + \"   [{a=1}, {a=2}, {a=3}, {a=4}, {a=5}])\";\n    ml(ml).assertEval(isUnordered(list(list(0, 9), list(1, 8))));\n  }\n\n  /** Tests a closure that uses one variable \"x\", called in an environment\n   * with a different value of \"x\" (of a different type, to flush out bugs). */\n  @Test void testClosure() {\n    final String ml = \"let\\n\"\n        + \"  val x = \\\"abc\\\";\\n\"\n        + \"  fun g y = size x + y;\\n\"\n        + \"  val x = 10\\n\"\n        + \"in\\n\"\n        + \"  g x\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(13));\n  }\n\n  @Test void testEvalFn() {\n    ml(\"(fn x => x + 1) 2\").assertEval(is(3));\n  }\n\n  @Test void testEvalFnCurried() {\n    ml(\"(fn x => fn y => x + y) 2 3\").assertEval(is(5));\n  }\n\n  @Test void testEvalFnTuple() {\n    ml(\"(fn (x, y) => x + y) (2, 3)\").assertEval(is(5));\n  }\n\n  @Test void testEvalFnRec() {\n    final String ml = \"let\\n\"\n        + \"  val rec f = fn n => if n = 0 then 1 else n * f (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  f 5\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(120));\n  }\n\n  @Test void testEvalFnTupleGeneric() {\n    ml(\"(fn (x, y) => x) (2, 3)\").assertEval(is(2));\n    ml(\"(fn (x, y) => y) (2, 3)\").assertEval(is(3));\n  }\n\n  @Test void testRecord() {\n    ml(\"{a = 1, b = {c = true, d = false}}\").assertParseSame();\n    ml(\"{a = 1, 1 = 2}\").assertParseStmt(Ast.Record.class, \"{1 = 2, a = 1}\");\n    ml(\"#b {a = 1, b = {c = true, d = false}}\").assertParseSame();\n    ml(\"{0=1}\").assertError(is(\"label must be positive\"));\n    ml(\"{a = 1, b = true}\").assertType(\"{a:int, b:bool}\");\n    ml(\"{b = true, a = 1}\").assertType(\"{a:int, b:bool}\");\n    ml(\"{a = 1, b = 2}\").assertEval(is(list(1, 2)));\n    ml(\"{a = true, b = ~2}\").assertEval(is(list(true, -2)));\n    ml(\"{a = true, b = ~2, c = \\\"c\\\"}\").assertEval(is(list(true, -2, \"c\")));\n    ml(\"let val ab = {a = true, b = ~2} in #a ab end\").assertEval(is(true));\n    ml(\"{a = true, b = {c = 1, d = 2}}\")\n        .assertEval(is(list(true, list(1, 2))));\n    ml(\"#a {a = 1, b = true}\")\n        .assertType(\"int\")\n        .assertEval(is(1));\n    ml(\"#b {a = 1, b = true}\")\n        .assertType(\"bool\")\n        .assertEval(is(true));\n    ml(\"#b {a = 1, b = 2}\").assertEval(is(2));\n    ml(\"#b {a = 1, b = {x = 3, y = 4}, z = true}\").assertEval(is(list(3, 4)));\n    ml(\"#x (#b {a = 1, b = {x = 3, y = 4}, z = true})\").assertEval(is(3));\n  }\n\n  @Test void testEquals() {\n    ml(\"{b = true, a = 1} = {a = 1, b = true}\").assertEval(is(true));\n    ml(\"{b = true, a = 0} = {a = 1, b = true}\").assertEval(is(false));\n  }\n\n  @Disabled(\"deduce type of #label\")\n  @Test void testRecord2() {\n    ml(\"#x #b {a = 1, b = {x = 3, y = 4}, z = true}\")\n        .assertError(\"Error: operator and operand don't agree [type mismatch]\\n\"\n            + \"  operator domain: {x:'Y; 'Z}\\n\"\n            + \"  operand:         {b:'W; 'X} -> 'W\\n\"\n            + \"  in expression:\\n\"\n            + \"    (fn {x=x,...} => x) (fn {b=b,...} => b)\\n\");\n  }\n\n  @Test void testRecordFn() {\n    ml(\"(fn {a=a1,b=b1} => a1) {a = 1, b = true}\")\n        .assertType(\"int\")\n        .assertEval(is(1));\n    ml(\"(fn {a=a1,b=b1} => b1) {a = 1, b = true}\")\n        .assertType(\"bool\")\n        .assertEval(is(true));\n  }\n\n  @Test void testRecordMatch() {\n    final String ml = \"case {a=1, b=2, c=3}\\n\"\n        + \"  of {a=2, b=2, c=3} => 0\\n\"\n        + \"   | {a=1, c=x, ...} => x\\n\"\n        + \"   | _ => ~1\";\n    ml(ml).assertEval(is(3));\n    ml(\"fn {} => 0\").assertParseSame();\n    ml(\"fn {a=1, ..., c=2}\")\n        .assertParseThrowsParseException(\n            containsString(\"Encountered \\\" \\\",\\\" \\\", \\\"\\\" at line 1, \"\n                + \"column 13.\"));\n    ml(\"fn {...} => 0\").assertParseSame();\n    ml(\"fn {a = a, ...} => 0\").assertParseSame();\n    ml(\"fn {a, b = {c, d}, ...} => 0\")\n        .assertParse(\"fn {a = a, b = {c = c, d = d}, ...} => 0\");\n  }\n\n  @Test void testRecordCase() {\n    ml(\"case {a=2,b=3} of {a=x,b=y} => x * y\").assertEval(is(6));\n    ml(\"case {a=2,b=3,c=4} of {a=x,b=y,c=z} => x * y\").assertEval(is(6));\n    ml(\"case {a=2,b=3,c=4} of {a=x,b=y,...} => x * y\").assertEval(is(6));\n    // resolution of flex records is more lenient in case than in fun\n    ml(\"case {a=2,b=3,c=4} of {a=3,...} => 1 | {b=2,...} => 2 | _ => 3\")\n        .assertEval(is(3));\n  }\n\n  @Test void testRecordTuple() {\n    ml(\"{ 1 = true, 2 = 0}\").assertType(\"bool * int\");\n    ml(\"{2=0,1=true}\").assertType(\"bool * int\");\n    ml(\"{3=0,1=true,11=false}\").assertType(\"{1:bool, 3:int, 11:bool}\");\n    ml(\"#1 {1=true,2=0}\").assertType(\"bool\");\n    ml(\"#1 (true, 0)\").assertType(\"bool\");\n    ml(\"#2 (true, 0)\")\n        .assertType(\"int\")\n        .assertEval(is(0));\n\n    // empty record = () = unit\n    ml(\"()\").assertType(\"unit\");\n    ml(\"{}\")\n        .assertType(\"unit\")\n        .assertEval(is(ImmutableList.of()));\n  }\n\n  @Test void testList() {\n    ml(\"[1]\").assertType(\"int list\");\n    ml(\"[[1]]\").assertType(\"int list list\");\n    ml(\"[(1, true), (2, false)]\").assertType(\"(int * bool) list\");\n    ml(\"1 :: [2]\").assertType(\"int list\");\n    ml(\"1 :: [2, 3]\").assertType(\"int list\");\n    ml(\"[1] :: [[2], [3]]\").assertType(\"int list list\");\n    ml(\"1 :: []\").assertType(\"int list\");\n    ml(\"1 :: 2 :: []\")\n        .assertType(\"int list\")\n        .assertEval(is(list(1, 2)));\n    ml(\"fn [] => 0\").assertType(\"'a list -> int\");\n  }\n\n  @Disabled(\"need type annotations\")\n  @Test void testList2() {\n    ml(\"fn x: 'b list => 0\").assertType(\"'a list -> int\");\n  }\n\n  /** List length function exercises list pattern-matching and recursion. */\n  @Test void testListLength() {\n    final String ml = \"let\\n\"\n        + \"  val rec len = fn x =>\\n\"\n        + \"    case x of [] => 0\\n\"\n        + \"            | head :: tail => 1 + len tail\\n\"\n        + \"in\\n\"\n        + \"  len [1, 2, 3]\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(3));\n  }\n\n  /** As {@link #testListLength()} but match reversed, which requires\n   * cautious matching of :: pattern. */\n  @Test void testListLength2() {\n    final String ml = \"let\\n\"\n        + \"  val rec len = fn x =>\\n\"\n        + \"    case x of head :: tail => 1 + len tail\\n\"\n        + \"            | [] => 0\\n\"\n        + \"in\\n\"\n        + \"  len [1, 2, 3]\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(3));\n  }\n\n  /** As {link {@link #testListLength()} but using {@code fun}. */\n  @Test void testListLength3() {\n    final String ml = \"let\\n\"\n        + \"  fun len [] = 0\\n\"\n        + \"     | len (head :: tail) = 1 + len tail\\n\"\n        + \"in\\n\"\n        + \"  len [1, 2, 3]\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(3));\n  }\n\n  @Test void testFunUnit() {\n    final String ml = \"let\\n\"\n        + \"  fun one () = 1\\n\"\n        + \"in\\n\"\n        + \"  one () + 2\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(3));\n  }\n\n  @Test void testMatchTuple() {\n    final String ml = \"let\\n\"\n        + \"  val rec sumIf = fn v =>\\n\"\n        + \"    case v of (true, n) :: tail => n + sumIf tail\\n\"\n        + \"            | (false, _) :: tail => sumIf tail\\n\"\n        + \"            | _ => 0\\n\"\n        + \"in\\n\"\n        + \"  sumIf [(true, 2), (false, 3), (true, 5)]\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(7));\n  }\n\n  /** The algorithm is described in\n   * <a href=\"https://stackoverflow.com/questions/7883023/algorithm-for-type-checking-ml-like-pattern-matching\">\n   * Stack overflow</a> and in Lennart Augustsson's 1985 paper \"Compiling\n   * Pattern Matching\". */\n  @Test void testMatchRedundant() {\n    final String ml = \"fun f x = case x > 0 of\\n\"\n        + \"   true => \\\"positive\\\"\\n\"\n        + \" | false => \\\"non-positive\\\"\\n\"\n        + \" | $true => \\\"oops\\\"$\";\n    ml(ml, '$')\n        .assertMatchCoverage(REDUNDANT)\n        .assertEvalThrows(pos -> throwsA(\"match redundant\", pos));\n\n    // similar, but 'fun' rather than 'case'\n    final String ml2 = \"\"\n        + \"fun f true = \\\"positive\\\"\\n\"\n        + \"  | f false = \\\"non-positive\\\"\\n\"\n        + \"  | $f true = \\\"oops\\\"$\";\n    ml(ml2, '$')\n        .assertMatchCoverage(REDUNDANT)\n        .assertEvalThrows(pos -> throwsA(\"match redundant\", pos));\n  }\n\n  @Test void testMatchCoverage1() {\n    final String ml = \"fun f (x, y) = x + y + 1\";\n    ml(ml).assertMatchCoverage(OK);\n  }\n\n  @Test void testMatchCoverage2() {\n    final String ml = \"\"\n        + \"fun f (1, y) = y\\n\"\n        + \"  | f (x, 2) = x\\n\"\n        + \"  | f (x, y) = x + y + 1\";\n    ml(ml).assertMatchCoverage(OK);\n  }\n\n  @Test void testMatchCoverage3() {\n    final String ml = \"fun f 1 = 2 | f x = x + 3\";\n    ml(ml).assertMatchCoverage(OK);\n  }\n\n  @Test void testMatchCoverage4() {\n    final String ml = \"\"\n        + \"fun f 1 = 2\\n\"\n        + \"  | f _ = 1\";\n    ml(ml).assertMatchCoverage(OK);\n  }\n\n  @Test void testMatchCoverage5() {\n    final String ml = \"\"\n        + \"fun f [] = 0\\n\"\n        + \"  | f (h :: t) = 1 + (f t)\";\n    ml(ml).assertMatchCoverage(OK);\n  }\n\n  @Test void testMatchCoverage6() {\n    final String ml = \"\"\n        + \"fun f (0, y) = y\\n\"\n        + \"  | f (x, y) = x + y + 1\";\n    ml(ml).assertMatchCoverage(OK);\n  }\n\n  @Test void testMatchCoverage7() {\n    final String ml = \"\"\n        + \"fun f (x, y, 0) = y\\n\"\n        + \"  | f (x, y, z) = x + z\";\n    ml(ml).assertMatchCoverage(OK);\n  }\n\n  @Test void testMatchCoverage8() {\n    // The last case is redundant because we know that bool has two values.\n    final String ml = \"\"\n        + \"fun f (true, y, z) = y\\n\"\n        + \"  | f (false, y, z) = z\\n\"\n        + \"  | $f _ = 0$\";\n    ml(ml, '$')\n        .assertMatchCoverage(REDUNDANT)\n        .assertEvalError(pos -> throwsA(\"match redundant\", pos));\n  }\n\n  @Test void testMatchCoverage9() {\n    // The last case is redundant because we know that unit has only one value.\n    final String ml = \"\"\n        + \"fun f () = 1\\n\"\n        + \"  | $f _ = 0$\";\n    ml(ml, '$').assertMatchCoverage(REDUNDANT);\n  }\n\n  @Test void testMatchCoverage10() {\n    final String ml = \"fun maskToString m =\\n\"\n        + \"  let\\n\"\n        + \"    fun maskToString2 (m, s, 0) = s\\n\"\n        + \"      | maskToString2 (m, s, k) =\\n\"\n        + \"        maskToString2 (m div 3,\\n\"\n        + \"          ($case (m mod 3) of\\n\"\n        + \"              0 => \\\"b\\\"\\n\"\n        + \"            | 1 => \\\"y\\\"\\n\"\n        + \"            | 2 => \\\"g\\\"$) ^ s,\\n\"\n        + \"          k - 1)\\n\"\n        + \"  in\\n\"\n        + \"    maskToString2 (m, \\\"\\\", 5)\\n\"\n        + \"  end\";\n    ml(ml, '$')\n        .assertMatchCoverage(NON_EXHAUSTIVE);\n  }\n\n  @Test void testMatchCoverage12() {\n    // two \"match nonexhaustive\" warnings\n    final String ml = \"fun f x =\\n\"\n        + \"  let\\n\"\n        + \"    fun g 1 = 1\\n\"\n        + \"    and h 2 = 2\\n\"\n        + \"  in\\n\"\n        + \"    (g x) + (h 2)\\n\"\n        + \"  end\";\n    ml(ml)\n        .assertMatchCoverage(NON_EXHAUSTIVE)\n        .assertEvalWarnings(\n            new CustomTypeSafeMatcher<List<Throwable>>(\n                \"two warnings\") {\n              @Override protected boolean matchesSafely(List<Throwable> list) {\n                return list.size() == 2\n                    && list.get(0) instanceof CompileException\n                    && list.get(0).getMessage().equals(\"match nonexhaustive\")\n                    && list.get(1) instanceof CompileException\n                    && list.get(1).getMessage().equals(\"match nonexhaustive\");\n              }\n            });\n  }\n\n  /** Test case for \"[MOREL-205] Pattern that uses nested type-constructors\n   * should not be considered redundant\". */\n  @Test void testMatchCoverage13() {\n    // Even though \"SOME i\" is seen at depth 1 in the first line,\n    // the \"SOME\" at depth 0 in the second line is not the same pattern,\n    // therefore the pattern is not redundant.\n    final String ml = \"fun f (SOME (SOME i)) = i + 1\\n\"\n        + \"  | f (SOME NONE) = 0\\n\"\n        + \"  | f NONE = ~1\\n\";\n    ml(ml).assertMatchCoverage(OK);\n  }\n\n  /** Function declaration. */\n  @Test void testFun() {\n    final String ml = \"let\\n\"\n        + \"  fun fact n = if n = 0 then 1 else n * fact (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fact 5\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(120));\n  }\n\n  /** As {@link #testFun()} but not applied to a value. */\n  @Test void testFunValue() {\n    final String ml = \"let\\n\"\n        + \"  fun fact n = if n = 0 then 1 else n * fact (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fact\\n\"\n        + \"end\";\n    ml(ml).assertEval(whenAppliedTo(5, is(120)));\n  }\n\n  /** As {@link #testFunValue()} but without \"let\".\n   *\n   * <p>This is mainly a test for the test framework. We want to handle bindings\n   * ({@code fun}) as well as values ({@code let} and {@code fn}). So people can\n   * write tests more concisely. */\n  @Test void testFunValueSansLet() {\n    final String ml = \"fun fact n = if n = 0 then 1 else n * fact (n - 1)\";\n    ml(ml).assertEval(whenAppliedTo(5, is(120)));\n  }\n\n  /** As {@link #testFun} but uses case. */\n  @Test void testFun2() {\n    final String ml = \"let\\n\"\n        + \"  fun fact n = case n of 0 => 1 | _ => n * fact (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fact 5\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(120));\n  }\n\n  /** As {@link #testFun} but uses a multi-clause function. */\n  @Test void testFun3() {\n    final String ml = \"let\\n\"\n        + \"  fun fact 1 = 1 | fact n = n * fact (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  fact 5\\n\"\n        + \"end\";\n    final String expected = \"let\"\n        + \" fun fact 1 = 1 \"\n        + \"| fact n = n * fact (n - 1) \"\n        + \"in fact 5 end\";\n    ml(ml).assertParse(expected)\n        .assertEval(is(120));\n  }\n\n  /** Simultaneous functions. */\n  @Test void testFun4() {\n    final String ml = \"let\\n\"\n        + \"  val x = 1\\n\"\n        + \"in\\n\"\n        + \"  let\\n\"\n        + \"    val x = 17\\n\"\n        + \"    and inc1 = fn n => n + x\\n\"\n        + \"    and inc2 = fn n => n + x + x\\n\"\n        + \"  in\\n\"\n        + \"    inc2 (inc1 x)\\n\"\n        + \"  end\\n\"\n        + \"end\";\n    ml(ml).assertType(\"int\")\n        .assertEval(is(20));\n  }\n\n  /** Mutually recursive functions: the definition of 'even' references 'odd'\n   * and the definition of 'odd' references 'even'. */\n  @Disabled(\"not working yet\")\n  @Test void testMutuallyRecursiveFunctions() {\n    final String ml = \"let\\n\"\n        + \"  fun even 0 = true\\n\"\n        + \"    | even n = odd (n - 1)\\n\"\n        + \"  and odd 0 = false\\n\"\n        + \"    | odd n = even (n - 1)\\n\"\n        + \"in\\n\"\n        + \"  odd 7\\n\"\n        + \"end\";\n    ml(ml).assertType(\"boolean\")\n        .assertEval(is(true));\n  }\n\n  /** A function with two arguments. */\n  @Test void testFunTwoArgs() {\n    final String ml = \"let\\n\"\n        + \"  fun sum x y = x + y\\n\"\n        + \"in\\n\"\n        + \"  sum 5 3\\n\"\n        + \"end\";\n    ml(ml).assertEval(is(8));\n  }\n\n  @Test void testFunRecord() {\n    final String ml = \"\"\n        + \"fun f {a=x,b=1,...} = x\\n\"\n        + \"  | f {b=y,c=2,...} = y\\n\"\n        + \"  | f {a=x,b=y,c=z} = x+y+z\";\n    ml(ml).assertType(\"{a:int, b:int, c:int} -> int\")\n        .assertEval(whenAppliedTo(list(1, 2, 3), is(6)));\n\n    final String ml2 = \"let\\n\"\n        + \"  fun f {a=x,b=1,...} = x\\n\"\n        + \"    | f {b=y,c=2,...} = y\\n\"\n        + \"    | f {a=x,b=y,c=z} = x+y+z\\n\"\n        + \"in\\n\"\n        + \"  f {a=1,b=2,c=3}\\n\"\n        + \"end\";\n    ml(ml2).assertEval(is(6));\n  }\n\n  @Test void testDatatype() {\n    final String ml = \"let\\n\"\n        + \"  datatype 'a tree = NODE of 'a tree * 'a tree | LEAF of 'a\\n\"\n        + \"in\\n\"\n        + \"  NODE (LEAF 1, NODE (LEAF 2, LEAF 3))\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(hasMoniker(\"'a tree\"))\n        .assertType(\n            instanceOfAnd(DataType.class,\n                hasTypeConstructors(\"{LEAF='a, NODE='a tree * 'a tree}\")))\n        .assertEval(is(node(leaf(1), node(leaf(2), leaf(3)))));\n  }\n\n  private static List<Object> leaf(Object arg) {\n    return list(\"LEAF\", arg);\n  }\n\n  private static List<Object> node(Object... args) {\n    return list(\"NODE\", list(args));\n  }\n\n  @Test void testDatatype2() {\n    final String ml = \"let\\n\"\n        + \"  datatype number = ZERO | INTEGER of int | RATIONAL of int * int\\n\"\n        + \"in\\n\"\n        + \"  RATIONAL (2, 3)\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"number\")\n        .assertEval(is(ImmutableList.of(\"RATIONAL\", ImmutableList.of(2, 3))));\n  }\n\n  @Test void testDatatype3() {\n    final String ml = \"let\\n\"\n        + \"  datatype intoption = NONE | SOME of int;\\n\"\n        + \"  val score = fn z => case z of NONE => 0 | SOME x => x\\n\"\n        + \"in\\n\"\n        + \"  score (SOME 5)\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(5));\n  }\n\n  /** As {@link #testDatatype3()} but with {@code fun} rather than {@code fn}\n   *  ... {@code case}. */\n  @Test void testDatatype3b() {\n    final String ml = \"let\\n\"\n        + \"  datatype intoption = NONE | SOME of int;\\n\"\n        + \"  fun score NONE = 0\\n\"\n        + \"    | score (SOME x) = x\\n\"\n        + \"in\\n\"\n        + \"  score (SOME 5)\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(5));\n  }\n\n  /** As {@link #testDatatype3b()} but use a nilary type constructor (NONE). */\n  @Test void testDatatype3c() {\n    final String ml = \"let\\n\"\n        + \"  datatype intoption = NONE | SOME of int;\\n\"\n        + \"  fun score NONE = 0\\n\"\n        + \"    | score (SOME x) = x\\n\"\n        + \"in\\n\"\n        + \"  score NONE\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(0));\n  }\n\n  @Test void testDatatype4() {\n    final String ml = \"let\\n\"\n        + \" datatype intlist = NIL | CONS of int * intlist;\\n\"\n        + \" fun depth NIL = 0\\n\"\n        + \"   | depth CONS (x, y) = 1 + depth y\\n\"\n        + \"in\\n\"\n        + \" depth NIL\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(0));\n  }\n\n  /** As {@link #testDatatype4()} but with deeper expression. */\n  @Test void testDatatype4a() {\n    final String ml = \"let\\n\"\n        + \" datatype intlist = NIL | CONS of int * intlist;\\n\"\n        + \" fun depth NIL = 0\\n\"\n        + \"   | depth CONS (x, y) = 1 + depth y\\n\"\n        + \"in\\n\"\n        + \" depth (CONS (5, CONS (2, NIL)))\\n\"\n        + \"end\";\n    ml(ml).assertParseSame()\n        .assertType(\"int\")\n        .assertEval(is(2));\n  }\n\n  /** Tests set operators (union, except, intersect).\n   * These are Morel extensions to Standard ML,\n   * intended to help relational expressions,\n   * but not part of the {@code from} expression. */\n  @Test void testSetOp() {\n    ml(\"a union b\").assertParseSame();\n    ml(\"a union b union c\").assertParseSame();\n    ml(\"(a union b) union c\").assertParse(\"a union b union c\");\n    ml(\"a union (b union c)\").assertParseSame();\n    final String ueui = \"a union b except c union d intersect e\";\n    ml(ueui).assertParseSame();\n    ml(\"((a union b) except c) union (d intersect e)\")\n        .assertParse(ueui);\n    ml(\"from x in emps union depts where deptno = 10\")\n        .assertParseSame();\n    final String fuf =\n        \"(from x in emps) union (from x in depts where #deptno x = 10)\";\n    ml(fuf).assertParseSame();\n    ml(\"(from x in emps) union from x in depts where #deptno x = 10\")\n        .assertParse(fuf);\n\n    ml(\"[1, 2, 3] union [2, 3, 4]\")\n        .assertEvalIter(equalsUnordered(1, 2, 3, 2, 3, 4));\n  }\n\n  @Test void testFrom() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"    {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps yield #deptno e\\n\"\n        + \"end\";\n    ml(ml).assertEvalIter(equalsOrdered(10, 20, 30, 30));\n  }\n\n  @Test void testParseFrom() {\n    ml(\"from\").assertParseSame();\n    ml(\"from e in emps\").assertParseSame();\n    ml(\"from e in emps where c\").assertParseSame();\n    ml(\"from e in emps, d in depts\").assertParseSame();\n    ml(\"from e in emps, d where hasEmp e\").assertParseSame();\n    ml(\"from e, d where hasEmp e\").assertParseSame();\n    ml(\"from e in emps, job, d where hasEmp (e, d, job)\")\n        .assertParseSame();\n    ml(\"from a, b in emps where a > b join c join d in depts where c > d\")\n        .assertParse(\"from a, b in emps where a > b \"\n            + \"join c, d in depts where c > d\");\n    ml(\"from a, b in emps where a > b join c, d in depts where c > d\")\n        .assertParseSame();\n    ml(\"from e in emps, d in depts on e.deptno = d.deptno\")\n        .assertParse(\"from e in emps, d in depts on #deptno e = #deptno d\");\n    ml(\"from e in emps on true, d in depts on e.deptno = d.deptno\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"on\\\" \\\"on \\\"\\\" \"\n                + \"at line 1, column 16.\"));\n    ml(\"from e, d in depts on e.deptno = d.deptno\")\n        .assertParse(\"from e, d in depts on #deptno e = #deptno d\");\n    ml(\"from , d in depts\").assertError(\"Xx\");\n    ml(\"from join d in depts on c\").assertError(\"Xx\");\n    ml(\"from left join d in depts on c\").assertError(\"Xx\");\n    ml(\"from right join d in depts on c\").assertError(\"Xx\");\n    ml(\"from full join d in depts on c\").assertError(\"Xx\");\n    ml(\"from e in emps join d in depts\").assertError(\"Xx\");\n    ml(\"from e in emps join d in depts where c\").assertError(\"Xx\");\n    ml(\"from e in emps join d in depts on c\")\n        .assertParse(\"from e in emps, d in depts on c\");\n    if (\"TODO\".isEmpty()) {\n      ml(\"from e in emps left join d in depts on c\").assertParseSame();\n      ml(\"from e in emps right join d in depts on c\").assertParseSame();\n      ml(\"from e in emps full join d in depts on c\").assertParseSame();\n    }\n    ml(\"from e in (from z in emps), d in (from y in depts) on c\")\n        .assertParseSame();\n    ml(\"from e in emps\\n\"\n        + \" group e.deptno\\n\"\n        + \" join d in depts on deptno = d.deptno\\n\"\n        + \" group d.location\\n\")\n        .assertParse(\"from e in emps\"\n            + \" group deptno = #deptno e\"\n            + \" join d in depts on deptno = #deptno d\"\n            + \" group location = #location d\");\n    // As previous, but use 'group e = {...}' so that we can write 'e.deptno'\n    // later in the query.\n    ml(\"from e in emps\\n\"\n        + \" group e = {e.deptno}\\n\"\n        + \" join d in depts on e.deptno = d.deptno\\n\"\n        + \" group d.location\")\n        .assertParse(\"from e in emps\"\n            + \" group e = {deptno = #deptno e}\"\n            + \" join d in depts on #deptno e = #deptno d\"\n            + \" group location = #location d\");\n    ml(\"(from e in emps where e.id = 101, d in depts)\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"in\\\" \\\"in \\\"\\\" at line 1, column 37.\"));\n    ml(\"from e in emps where e.id = 101 join d in depts\")\n        .assertParse(\"from e in emps where #id e = 101 join d in depts\");\n    // after 'group', you have to use 'join' not ','\n    ml(\"(from e in emps\\n\"\n        + \" group e.id compute count,\\n\"\n        + \" d in depts\\n\"\n        + \" where false)\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"in\\\" \\\"in \\\"\\\" at line 3, column 4.\"));\n    ml(\"(from e in emps\\n\"\n        + \" group e.id compute count\\n\"\n        + \" join d in depts\\n\"\n        + \" where false)\")\n        .assertParse(\"from e in emps\"\n            + \" group id = #id e compute count = count\"\n            + \" join d in depts where false\");\n    ml(\"from e in emps skip 1 take 2\").assertParseSame();\n    ml(\"from e in emps order e.empno take 2\")\n        .assertParse(\"from e in emps order #empno e take 2\");\n    ml(\"from e in emps order e.empno take 2 skip 3 skip 1+1 take 2\")\n        .assertParse(\"from e in emps order #empno e take 2 skip 3 skip 1 + 1 \"\n            + \"take 2\");\n    ml(\"fn f => from i in [1, 2, 3] where f i\")\n        .assertParseSame()\n        .assertType(\"(int -> bool) -> int list\");\n    ml(\"fn f => from i in [1, 2, 3] join j in [3, 4] on f (i, j) yield i + j\")\n        .assertParse(\"fn f => from i in [1, 2, 3],\"\n            + \" j in [3, 4] on f (i, j) yield i + j\")\n        .assertType(\"(int * int -> bool) -> int list\");\n\n    // In \"from p in exp\" and \"from p = exp\", p can be any pattern\n    // but in \"from v\" v can only be an identifier.\n    ml(\"from x, y in [1, 2], z\").assertParseSame();\n    ml(\"from {x, y} in [{x=1, y=2}], z\")\n        .assertParse(\"from {x = x, y = y} in [{x = 1, y = 2}], z\");\n    ml(\"from {x, y}, z\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\",\\\" \\\", \\\"\\\" \"\n                + \"at line 1, column 12.\"));\n    ml(\"from {x, y} group\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"group\\\" \\\"group \\\"\\\" \"\n                + \"at line 1, column 13.\"));\n    ml(\"from {x, y} where true\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"where\\\" \\\"where \\\"\\\" \"\n                + \"at line 1, column 13.\"));\n    ml(\"from (x, y) where true\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"where\\\" \\\"where \\\"\\\" \"\n                + \"at line 1, column 13.\"));\n    ml(\"from w as (x, y) order x\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\" \\\"order\\\" \\\"order \\\"\\\" \"\n                + \"at line 1, column 18.\"));\n    ml(\"from (x, y)\")\n        .assertParseThrowsParseException(\n            startsWith(\"Encountered \\\"<EOF>\\\" at line 1, column 11.\"));\n    ml(\"from e in emps\\n\"\n        + \"through e in empsInDept 20\\n\"\n        + \"yield e.sal\")\n        .assertParse(\"from e in emps through e in empsInDept 20 yield #sal e\");\n    ml(\"from e in emps\\n\"\n        + \"yield e.empno\\n\"\n        + \"into sum\")\n        .assertParse(\"from e in emps yield #empno e into sum\");\n    ml(\"from e in emps\\n\"\n        + \"yield e.empno\\n\"\n        + \"compute sum, count\")\n        .assertParse(\"from e in emps \"\n            + \"yield #empno e \"\n            + \"compute sum = sum, count = count\");\n  }\n\n  @Test void testFromYield() {\n    ml(\"from a in [1], b in [true]\")\n        .assertType(\"{a:int, b:bool} list\");\n    ml(\"from a in [1], b in [true] yield a\")\n        .assertType(\"int list\");\n    ml(\"from a in [1], b in [true] yield {a,b}\")\n        .assertType(\"{a:int, b:bool} list\");\n    ml(\"from a in [1], b in [true] yield {y=a,b}\")\n        .assertType(\"{b:bool, y:int} list\");\n    ml(\"from a in [1], b in [true] yield {y=a,x=b,z=a}\")\n        .assertType(\"{x:bool, y:int, z:int} list\");\n    ml(\"from a in [1], b in [true] yield {y=a,x=b,z=a} yield {z,x}\")\n        .assertType(\"{x:bool, z:int} list\");\n    ml(\"from a in [1], b in [true] yield {y=a,x=b,z=a} yield {z}\")\n        .assertType(\"{z:int} list\");\n    ml(\"from a in [1], b in [true] yield (b,a)\")\n        .assertType(\"(bool * int) list\");\n    ml(\"from a in [1], b in [true] yield (b)\")\n        .assertType(\"bool list\");\n    ml(\"from a in [1], b in [true] yield {b,a} yield a\")\n        .assertType(\"int list\");\n    String value = \"'yield' step that is not last in 'from' must be a record \"\n        + \"expression\";\n    ml(\"from a in [1], b in [true] yield (b,a) where b\")\n        .assertType(\"{a:int, b:bool} list\");\n    ml(\"from a in [1], b in [true] yield (b,a) where $c$\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"unbound variable or constructor: c\", pos));\n    ml(\"from a in [1], b in [true] yield {b,a} where b\")\n        .assertType(\"{a:int, b:bool} list\")\n        .assertEval(is(list(list(1, true))));\n    ml(\"from d in [{a=1,b=true}], i in [2] yield i\")\n        .assertType(\"int list\");\n    // Note that 'd' has record type but is not a record expression\n    ml(\"from d in [{a=1,b=true}], i in [2] yield d yield $a$\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"unbound variable or constructor: a\", pos));\n    ml(\"from d in [{a=1,b=true}], i in [2] yield {d.a,d.b} yield a\")\n        .assertType(\"int list\");\n    ml(\"from d in [{a=1,b=true}], i in [2] yield d where true\")\n        .assertType(\"{d:{a:int, b:bool}, i:int} list\");\n    ml(\"from d in [{a=1,b=true}], i in [2] yield i yield 3\")\n        .assertType(\"int list\");\n    ml(\"from d in [{a=1,b=true}], i in [2] yield d\")\n        .assertType(\"{a:int, b:bool} list\");\n    ml(\"from d in [{a=1,b=true}], i in [2] yield d yield 3\")\n        .assertType(\"int list\");\n    ml(\"from d in [{a=1,b=true}] yield $d.x$\", '$')\n        .assertTypeThrows(\n            pos -> throwsA(TypeResolver.TypeException.class,\n                is(\"no field 'x' in type '{a:int, b:bool}'\")));\n    ml(\"from d in [{a=1,b=true}] yield d.a into List.length\")\n        .assertType(\"int\");\n    ml(\"from d in [{a=1,b=true}] yield d.a into sum\")\n        .assertType(\"int\")\n        .assertEval(is(1));\n    ml(\"from d in [{a=1,b=true}] yield d.a $into sum$ yield \\\"a\\\"\", '$')\n        .assertCompileException(pos ->\n            throwsA(CompileException.class,\n                \"'into' step must be last in 'from'\", pos));\n    // \"map String.size\" has type \"string list -> int list\",\n    // and therefore the type of \"j\" is \"int\"\n    ml(\"from s in [\\\"ab\\\",\\\"c\\\"]\\n\"\n        + \" through j in (map String.size)\")\n        .assertType(\"int list\");\n    ml(\"from s in [\\\"ab\\\",\\\"c\\\"]\\n\"\n        + \" through j in (map String.size)\\n\"\n        + \" yield j + 2\")\n        .assertType(\"int list\");\n    ml(\"from d in [{a=1,b=true},{a=2,b=false}]\\n\"\n        + \" yield d.a\\n\"\n        + \" through s in (fn ints =>\\n\"\n        + \"   from i in ints yield substring (\\\"abc\\\", 0, i))\")\n        .assertType(\"string list\")\n        .assertEval(is(list(\"a\", \"ab\")));\n  }\n\n  @Test void testFromYieldExpression() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"    {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps yield (#id e + #deptno e)\\n\"\n        + \"end\";\n    ml(ml).assertEvalIter(equalsOrdered(110, 121, 132, 133));\n  }\n\n  @Test void testFromWhere() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"    {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps where #deptno e = 30 yield #id e\\n\"\n        + \"end\";\n    ml(ml).assertEvalIter(equalsOrdered(102, 103));\n  }\n\n  /** Applies {@code suchthat} to a function that tests membership of a set,\n   * and therefore the effect is to iterate over that set. */\n  @Test void testFromSuchThat() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"    {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"  fun hasEmpNameInDept (n, d) =\\n\"\n        + \"    (n, d) elem (from e in emps yield (e.name, e.deptno))\\n\"\n        + \"in\\n\"\n        + \"  from n, d\\n\"\n        + \"    where hasEmpNameInDept (n, d)\\n\"\n        + \"    where d = 30\\n\"\n        + \"    yield {d, n}\\n\"\n        + \"end\";\n    final String code = \"from(sink\\n\"\n        + \"  join(pat v0,\\n\"\n        + \"  exp from(\\n\"\n        + \"    sink join(pat e, exp tuple(\\n\"\n        + \"  tuple(constant(10), constant(100), constant(Fred)),\\n\"\n        + \"  tuple(constant(20), constant(101), constant(Velma)),\\n\"\n        + \"  tuple(constant(30), constant(102), constant(Shaggy)),\\n\"\n        + \"  tuple(constant(30), constant(103), constant(Scooby))),\\n\"\n        + \" sink collect(tuple(apply(fnValue nth:2, argCode get(name e)), \"\n        + \"apply(fnValue nth:0, argCode get(name e)))))), \"\n        + \"sink join(pat n_1, exp tuple(\\n\"\n        + \" apply(fnValue nth:0, argCode get(name v0))), \"\n        + \"sink join(pat d_1, exp tuple(constant(30)), \"\n        + \"sink where(condition apply2(fnValue elem,\\n\"\n        + \"                            tuple(get(name n), get(name d)), \"\n        + \"from(sink join(pat e, exp tuple(\\n\"\n        + \"  tuple(constant(10), constant(100), constant(Fred)),\\n\"\n        + \"  tuple(constant(20), constant(101), constant(Velma)),\\n\"\n        + \"  tuple(constant(30), constant(102), constant(Shaggy)),\\n\"\n        + \"  tuple(constant(30), constant(103), constant(Scooby))),\\n\"\n        + \" sink collect(tuple(apply(fnValue nth:2, argCode get(name e)), \"\n        + \"apply(fnValue nth:0, argCode get(name e))))))),\\n\"\n        + \"        sink where(condition apply2(fnValue =, get(name d), constant(30)),\\n\"\n        + \"          sink collect(tuple(get(name d), get(name n)))))))))\";\n    final List<Object> expected =\n        list(list(30, \"Shaggy\"), list(30, \"Scooby\"));\n    ml(ml).assertType(\"{d:int, n:string} list\")\n        .assertPlan(isCode2(code))\n        .assertEval(is(expected));\n  }\n\n  @Test void testFromSuchThat2() {\n    final String ml = \"let\\n\"\n        + \"  fun hasJob (d, job) =\\n\"\n        + \"    (d div 2, job)\\n\"\n        + \"      elem (from e in scott.emp yield (e.deptno, e.job))\\n\"\n        + \"in\\n\"\n        + \"  from d in scott.dept, j\"\n        + \"    where hasJob (d.deptno, j)\\n\"\n        + \"    yield j\\n\"\n        + \"end\";\n    final String core = \"val it = \"\n        + \"from d_1 in #dept scott \"\n        + \"join j : string \"\n        + \"where case (#deptno d_1, j) of\"\n        + \" (d, job) => op elem ((op div (d, 2), job),\"\n        + \" from e in #emp scott\"\n        + \" yield (#deptno e, #job e)) yield j\";\n    final String code = \"from(sink join(pat d_1,\\n\"\n        + \"    exp apply(fnValue nth:1, argCode get(name scott)),\\n\"\n        + \"  sink join(pat j,\\n\"\n        + \"      exp apply(\\n\"\n        + \"        fnCode apply(fnValue List.filter,\\n\"\n        + \"          argCode match(j,\\n\"\n        + \"            apply(fnCode match((d, job),\\n\"\n        + \"              apply2(fnValue elem,\\n\"\n        + \"                tuple(apply2(fnValue div, get(name d), constant(2)),\\n\"\n        + \"                get(name job)),\\n\"\n        + \"              from(\\n\"\n        + \"              sink join(pat e,\\n\"\n        + \"                exp apply(fnValue nth:2, argCode get(name scott)),\\n\"\n        + \"                sink collect(\\n\"\n        + \"                  tuple(apply(fnValue nth:1, argCode get(name e)),\\n\"\n        + \"                    apply(fnValue nth:5, argCode get(name e)))))))),\\n\"\n        + \"              argCode tuple(\\n\"\n        + \"                apply(fnValue nth:0, argCode get(name d)),\\n\"\n        + \"                get(name j))))),\\n\"\n        + \"        argCode apply(fnValue $.extent, argCode constant(()))),\\n\"\n        + \"    sink collect(get(name j)))))\";\n    final List<Object> expected = list(); // TODO\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"string list\");\n//        .assertCore(-1, is(core))\n//        .assertPlan(isCode2(code))\n//        .assertEval(is(expected));\n  }\n\n  /** Translates a simple {@code suchthat} expression, \"d elem list\". */\n  @Test void testFromSuchThat2b() {\n    final String ml = \"from d where d elem scott.dept\";\n    final String core0 = \"val it = \"\n        + \"from d : {deptno:int, dname:string, loc:string} \"\n        + \"where d elem #dept scott\";\n    final String core1 = \"val it = from d in #dept scott\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{deptno:int, dname:string, loc:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }\n\n  /** Translates a simple {@code suchthat} expression, \"{x, y} elem list\".\n   * Fields are renamed, to disrupt alphabetical ordering. */\n  @Test void testFromSuchThat2c() {\n    final String ml = \"from loc, deptno, name \"\n        + \"where {deptno, loc, dname = name} elem scott.dept\";\n    final String core = \"val it = \"\n        + \"from v0 in #dept scott \"\n        + \"join loc in [#loc v0] \"\n        + \"join deptno in [#deptno v0] \"\n        + \"join name in [#dname v0] \"\n        + \"where op elem ({deptno = deptno, dname = name, loc = loc},\"\n        + \" #dept scott) \"\n        + \"yield {deptno = deptno, loc = loc, name = name}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{deptno:int, loc:string, name:string} list\")\n        .assertCore(-1, hasToString(core))\n        .assertEval(\n            is(\n                list(list(10, \"NEW YORK\", \"ACCOUNTING\"),\n                    list(20, \"DALLAS\", \"RESEARCH\"),\n                    list(30, \"CHICAGO\", \"SALES\"),\n                    list(40, \"BOSTON\", \"OPERATIONS\"))));\n  }\n\n  /** As {@link #testFromSuchThat2c()} but with a literal. */\n  @Test void testFromSuchThat2d() {\n    final String ml = \"from dno, name\\n\"\n        + \"  where {deptno = dno, dname = name, loc = \\\"CHICAGO\\\"}\\n\"\n        + \"      elem scott.dept\\n\"\n        + \"    andalso dno > 20\";\n    final String core0 = \"val it = \"\n        + \"from dno : int \"\n        + \"join name : string \"\n        + \"where {deptno = dno, dname = name, loc = \\\"CHICAGO\\\"} \"\n        + \"elem #dept scott \"\n        + \"andalso dno > 20\";\n    final String core1 = \"val it = \"\n        + \"from v0 in #dept scott \"\n        + \"join dno in [#deptno v0] \"\n        + \"join name in [#dname v0] \"\n        + \"where op elem ({deptno = dno, dname = name, loc = \\\"CHICAGO\\\"},\"\n        + \" #dept scott) \"\n        + \"andalso dno > 20 \"\n        + \"yield {dno = dno, name = name}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dno:int, name:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }\n\n  /** As {@link #testFromSuchThat2c()} but with a literal. */\n  @Test void testFromSuchThat2d2() {\n    final String ml = \"from dno, name\\n\"\n        + \"  where {deptno = dno, dname = name, loc = \\\"CHICAGO\\\"}\\n\"\n        + \"      elem scott.dept\\n\"\n        + \"    andalso dno > 20\";\n    final String core0 = \"val it = \"\n        + \"from dno : int \"\n        + \"join name : string \"\n        + \"where {deptno = dno, dname = name, loc = \\\"CHICAGO\\\"} \"\n        + \"elem #dept scott \"\n        + \"andalso dno > 20\";\n    final String core1 = \"val it = \"\n        + \"from v0 in #dept scott \"\n        + \"join dno in [#deptno v0] \"\n        + \"join name in [#dname v0] \"\n        + \"where op elem ({deptno = dno, dname = name, loc = \\\"CHICAGO\\\"},\"\n        + \" #dept scott) \"\n        + \"andalso dno > 20 \"\n        + \"yield {dno = dno, name = name}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dno:int, name:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }\n\n  @Test void testFromSuchThat2d3() {\n    final String ml = \"from dno, name, v\\n\"\n        + \"where v elem scott.dept\\n\"\n        + \"where v.deptno = dno\\n\"\n        + \"where name = v.dname\\n\"\n        + \"where v.loc = \\\"CHICAGO\\\"\\n\"\n        + \"where dno = 30\\n\"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    final String core0 = \"val it = \"\n        + \"from dno : int \"\n        + \"join name : string \"\n        + \"join v : {deptno:int, dname:string, loc:string} \"\n        + \"where v elem #dept scott \"\n        + \"where #deptno v = dno \"\n        + \"where name = #dname v \"\n        + \"where #loc v = \\\"CHICAGO\\\" \"\n        + \"where dno = 30 \"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    final String core1 = \"val it = \"\n        + \"from dno in [30] \"\n        + \"join v in #dept scott \"\n        + \"join name in [#dname v] \"\n        + \"where #deptno v = dno \"\n        + \"where name = #dname v \"\n        + \"where #loc v = \\\"CHICAGO\\\" \"\n        + \"where dno = 30 \"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dno:int, name:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1))\n        .assertEval(is(list(list(30, \"SALES\"))));\n  }\n\n  @Test void testFromSuchThat2d4() {\n    final String ml = \"from dno, name, v\\n\"\n        + \"where v elem scott.dept\\n\"\n        + \"where v.deptno = dno\\n\"\n        + \"where name = v.dname\\n\"\n        + \"where v.loc = \\\"CHICAGO\\\"\\n\"\n        + \"where dno > 25\\n\"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    final String core0 = \"val it = \"\n        + \"from dno : int \"\n        + \"join name : string \"\n        + \"join v : {deptno:int, dname:string, loc:string} \"\n        + \"where v elem #dept scott \"\n        + \"where #deptno v = dno \"\n        + \"where name = #dname v \"\n        + \"where #loc v = \\\"CHICAGO\\\" \"\n        + \"where dno > 25 \"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    final String core1 = \"val it = \"\n        + \"from v in #dept scott \"\n        + \"join dno in [#deptno v] \"\n        + \"join name in [#dname v] \"\n        + \"where #deptno v = dno \"\n        + \"where name = #dname v \"\n        + \"where #loc v = \\\"CHICAGO\\\" \"\n        + \"where dno > 25 \"\n        + \"yield {dno = #deptno v, name = #dname v}\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{dno:int, name:string} list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1))\n        .assertEval(is(list(list(30, \"SALES\"))));\n  }\n\n  /** As {@link #testFromSuchThat2d()} but using a function.\n   * (Simple enough that the function can be handled by inlining.) */\n  @Test void testFromSuchThat2e() {\n    final String ml = \"let\\n\"\n        + \"  fun isDept d =\\n\"\n        + \"    d elem scott.dept\\n\"\n        + \"in\\n\"\n        + \"  from d\\n\"\n        + \"    where isDept d andalso d.deptno = 20\\n\"\n        + \"    yield d.dname\\n\"\n        + \"end\";\n    final String core0 = \"val it = \"\n        + \"let\"\n        + \" val isDept = fn d => d elem #dept scott \"\n        + \"in\"\n        + \" from d_1 : {deptno:int, dname:string, loc:string}\"\n        + \" where isDept d_1 andalso #deptno d_1 = 20\"\n        + \" yield #dname d_1 \"\n        + \"end\";\n    final String core1 = \"val it = \"\n        + \"from d_1 in #dept scott \"\n        + \"where #deptno d_1 = 20 \"\n        + \"yield #dname d_1\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"string list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }\n\n  /** Tests a join expressed via {@code suchthat}. */\n  @Test void testFromSuchThat2f() {\n    final String ml = \"let\\n\"\n        + \"  fun isDept d =\\n\"\n        + \"    d elem scott.dept\\n\"\n        + \"  fun isEmp e =\\n\"\n        + \"    e elem scott.emp\\n\"\n        + \"in\\n\"\n        + \"  from d, e\\n\"\n        + \"    where isDept d\\n\"\n        + \"    andalso isEmp e\\n\"\n        + \"    andalso d.deptno = e.deptno\\n\"\n        + \"    andalso d.deptno = 20\\n\"\n        + \"    yield d.dname\\n\"\n        + \"end\";\n    final String core0 = \"val it = \"\n        + \"let\"\n        + \" val isDept = fn d => d elem #dept scott \"\n        + \"in\"\n        + \" let\"\n        + \" val isEmp = fn e => e elem #emp scott \"\n        + \"in\"\n        + \" from d_1 : {deptno:int, dname:string, loc:string}\"\n        + \" join e_1 : {comm:real, deptno:int, empno:int, ename:string, \"\n        + \"hiredate:string, job:string, mgr:int, sal:real}\"\n        + \" where isDept d_1 \"\n        + \"andalso isEmp e_1 \"\n        + \"andalso #deptno d_1 = #deptno e_1 \"\n        + \"andalso #deptno d_1 = 20\"\n        + \" yield #dname d_1\"\n        + \" end \"\n        + \"end\";\n    final String core1 = \"val it = \"\n        + \"from d_1 in #dept scott \"\n        + \"join e_1 in #emp scott \"\n        + \"where #deptno d_1 = #deptno e_1 \"\n        + \"andalso #deptno d_1 = 20 \"\n        + \"yield #dname d_1\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"string list\")\n        .assertCore(0, hasToString(core0))\n        .assertCore(-1, hasToString(core1));\n  }\n\n  /** A {@code suchthat} expression. */\n  @Test void testFromSuchThat3() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [\\n\"\n        + \"    {id = 102, name = \\\"Shaggy\\\", deptno = 30},\\n\"\n        + \"    {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"  fun hasEmpNameInDept (n, d) =\\n\"\n        + \"    (n, d) elem (from e in emps yield (e.name, e.deptno))\\n\"\n        + \"in\\n\"\n        + \"  from n, d\\n\"\n        + \"    where hasEmpNameInDept (n, d)\\n\"\n        + \"    where d = 30\\n\"\n        + \"    yield {d, n}\\n\"\n        + \"end\";\n    final String core = \"val it = \"\n        + \"from n_1, d_1 \"\n        + \"where (case (n_1, d_1) of (n, d) => op elem ((n, d), \"\n        + \"from e in [\"\n        + \"{deptno = 30, id = 102, name = \\\"Shaggy\\\"}, \"\n        + \"{deptno = 30, id = 103, name = \\\"Scooby\\\"}]\"\n        + \" yield (#name e, #deptno e)))\"\n        + \" where d_1 = 30\"\n        + \" yield {d = d_1, n = n_1}\";\n    final String code = \"from(sink\\n\"\n        + \"  join(pat (n_1, d_1),\\n\"\n        + \"  exp apply(\\n\"\n        + \"    fnCode apply(fnValue List.filter,\\n\"\n        + \"      argCode match(v0,\\n\"\n        + \"        apply(fnCode match((n_1, d_1),\\n\"\n        + \"            apply(fnCode match((n, d),\\n\"\n        + \"                apply2(fnValue elem,\\n\"\n        + \"                  tuple(get(name n), get(name d)),\\n\"\n        + \"                  from(sink\\n\"\n        + \"                    join(pat e, exp tuple(\\n\"\n        + \"  tuple(constant(30), constant(102), constant(Shaggy)),\\n\"\n        + \"  tuple(constant(30), constant(103), constant(Scooby))),\\n\"\n        + \"      sink collect(tuple(apply(fnValue nth:2, argCode get(name e)),\\n\"\n        + \"        apply(fnValue nth:0, argCode get(name e)))))))),\\n\"\n        + \"               argCode tuple(get(name n), get(name d)))),\\n\"\n        + \"            argCode get(name v0)))),\\n\"\n        + \"          argCode apply(fnValue $.extent, argCode constant(()))),\\n\"\n        + \"        sink where(condition apply2(fnValue =, get(name d), constant(30)),\\n\"\n        + \"          sink collect(tuple(get(name d), get(name n))))))\";\n    ml(ml).assertType(\"{d:int, n:string} list\");\n//        .assertCore(-1, is(core))\n//        .assertPlan(isCode2(code))\n//        .assertEval(is(list()));\n  }\n\n  /** A query with an unconstrained scan that is deduced to be of type\n   * {@code bool option} and therefore iterates over\n   * {@code [SOME true, SOME false, NONE]}. */\n  @Test void testBooleanExtent() {\n    final String ml = \"from i\\n\"\n        + \"where Option.getOpt (i, false)\";\n    final String core = \"val it = \"\n        + \"from i in extent \\\"bool option\\\" \"\n        + \"where #getOpt Option (i, false)\";\n    ml(ml).assertType(\"bool option list\")\n        .assertCore(-1, hasToString(core))\n        .assertEval(is(list(list(\"SOME\", true))));\n  }\n\n  @Test void testFromNoYield() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 103, name = \\\"Scooby\\\", deptno = 30}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps where #deptno e = 30\\n\"\n        + \"end\";\n    ml(ml).assertType(\"{deptno:int, id:int, name:string} list\")\n        .assertEvalIter(equalsOrdered(list(30, 103, \"Scooby\")));\n  }\n\n  @Test void testFromJoinNoYield() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20}]\\n\"\n        + \"  val depts =\\n\"\n        + \"    [{deptno = 10, name = \\\"Sales\\\"}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps, d in depts where #deptno e = #deptno d\\n\"\n        + \"end\";\n    ml(ml)\n        .assertType(\"{d:{deptno:int, name:string},\"\n            + \" e:{deptno:int, id:int, name:string}} list\")\n        .assertEvalIter(\n            equalsOrdered(list(list(10, \"Sales\"), list(10, 100, \"Fred\"))));\n  }\n\n  @Test void testYieldYield() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps\\n\"\n        + \"  yield {x = e.id + e.deptno, y = e.id - e.deptno}\\n\"\n        + \"  yield x + y\\n\"\n        + \"end\";\n    ml(ml)\n        .assertType(\"int list\")\n        .assertEvalIter(equalsOrdered(200, 202));\n  }\n\n  @Test void testYieldSingletonRecord() {\n    final String ml = \"from e in [{x=1,y=2},{x=3,y=4},{x=5,y=6}]\\n\"\n        + \"  yield {z=e.x}\\n\"\n        + \"  where z > 2\\n\"\n        + \"  order z desc\\n\"\n        + \"  yield {z=z}\";\n    ml(ml)\n        .assertType(\"{z:int} list\")\n        .assertEvalIter(equalsOrdered(list(5), list(3)));\n\n    final String ml2 = \"from e in [{x=1,y=2},{x=3,y=4},{x=5,y=6}]\\n\"\n        + \"  yield {z=e.x}\\n\"\n        + \"  where z > 2\\n\"\n        + \"  order z desc\";\n    ml(ml2)\n        .assertType(\"int list\")\n        .assertEvalIter(equalsOrdered(5, 3));\n  }\n\n  /** Analogous to SQL \"CROSS APPLY\" which calls a table-valued function\n   * for each row in an outer loop. */\n  @Test void testCrossApply() {\n    final String ml = \"from s in [\\\"abc\\\", \\\"\\\", \\\"d\\\"],\\n\"\n        + \"    c in explode s\\n\"\n        + \"  yield s ^ \\\":\\\" ^ str c\";\n    ml(ml).assertEvalIter(equalsOrdered(\"abc:a\", \"abc:b\", \"abc:c\", \"d:d\"));\n  }\n\n  @Test void testCrossApplyGroup() {\n    final String ml = \"from s in [\\\"abc\\\", \\\"\\\", \\\"d\\\"],\\n\"\n        + \"    c in explode s\\n\"\n        + \"  group s compute count = sum of 1\";\n    ml(ml).assertEvalIter(equalsUnordered(list(3, \"abc\"), list(1, \"d\")));\n  }\n\n  @Test void testJoinLateral() {\n    final String ml = \"let\\n\"\n        + \"  val emps = [{name = \\\"Shaggy\\\",\\n\"\n        + \"               pets = [{name = \\\"Scooby\\\", species = \\\"Dog\\\"},\\n\"\n        + \"                       {name = \\\"Scrappy\\\", species = \\\"Dog\\\"}]},\\n\"\n        + \"              {name = \\\"Charlie\\\",\\n\"\n        + \"               pets = [{name = \\\"Snoopy\\\", species = \\\"Dog\\\"}]},\\n\"\n        + \"              {name = \\\"Danny\\\", pets = []}]\"\n        + \"in\\n\"\n        + \"  from e in emps,\\n\"\n        + \"      p in e.pets\\n\"\n        + \"    yield p.name\\n\"\n        + \"end\";\n    ml(ml).assertEvalIter(equalsOrdered(\"Scooby\", \"Scrappy\", \"Snoopy\"));\n  }\n\n  @Test void testFromGroupWithoutCompute() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"     {id = 102, name = \\\"Shaggy\\\", deptno = 10}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps group #deptno e\\n\"\n        + \"end\";\n    final String expected = \"let val emps = \"\n        + \"[{deptno = 10, id = 100, name = \\\"Fred\\\"},\"\n        + \" {deptno = 20, id = 101, name = \\\"Velma\\\"},\"\n        + \" {deptno = 10, id = 102, name = \\\"Shaggy\\\"}] \"\n        + \"in\"\n        + \" from e in emps\"\n        + \" group deptno = #deptno e \"\n        + \"end\";\n    ml(\"val x = \" + ml)\n        .assertParseDecl(Ast.ValDecl.class, \"val x = \" + expected);\n    // The implicit yield expression is \"deptno\". It is not a record,\n    // \"{deptno = deptno}\", because there is only one variable defined (the\n    // \"group\" clause defines \"deptno\" and hides the \"e\" from the \"from\"\n    // clause).\n    ml(ml).assertType(\"int list\")\n        .assertEvalIter(equalsUnordered(10, 20));\n  }\n\n  /** As {@link #testFromGroupWithoutCompute()} but composite key, therefore\n   * result is a list of records. */\n  @Test void testFromGroupWithoutCompute2() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"     {id = 102, name = \\\"Shaggy\\\", deptno = 10}]\\n\"\n        + \"in\\n\"\n        + \"  from e in emps group #deptno e, parity = e.id mod 2\\n\"\n        + \"end\";\n    ml(ml).assertType(\"{deptno:int, parity:int} list\")\n        .assertEvalIter(equalsUnordered(list(10, 0), list(20, 1)));\n  }\n\n  @Test void testFromGroup() {\n    final String ml = \"let\\n\"\n        + \"  val emps =\\n\"\n        + \"    [{id = 100, name = \\\"Fred\\\", deptno = 10},\\n\"\n        + \"     {id = 101, name = \\\"Velma\\\", deptno = 20},\\n\"\n        + \"     {id = 102, name = \\\"Shaggy\\\", deptno = 10}]\\n\"\n        + \"  fun sum [] = 0 | sum (h::t) = h + (sum t)\\n\"\n        + \"in\\n\"\n        + \"  from e in emps\\n\"\n        + \"    group #deptno e\\n\"\n        + \"    compute sumId = sum of #id e\\n\"\n        + \"end\";\n    final String expected = \"let val emps = \"\n        + \"[{deptno = 10, id = 100, name = \\\"Fred\\\"},\"\n        + \" {deptno = 20, id = 101, name = \\\"Velma\\\"},\"\n        + \" {deptno = 10, id = 102, name = \\\"Shaggy\\\"}]; \"\n        + \"fun sum ([]) = 0 | sum (h :: t) = h + sum t \"\n        + \"in\"\n        + \" from e in emps\"\n        + \" group deptno = #deptno e\"\n        + \" compute sumId = sum of #id e \"\n        + \"end\";\n    ml(\"val x = \" + ml)\n        .assertParseDecl(Ast.ValDecl.class, \"val x = \" + expected);\n    ml(ml).assertType(\"{deptno:int, sumId:int} list\")\n        .assertEvalIter(equalsUnordered(list(10, 202), list(20, 101)));\n  }\n\n  @Test void testGroupAs() {\n    final String ml0 = \"from e in emp\\n\"\n        + \"group deptno = e.deptno\";\n    final String ml1 = \"from e in emp\\n\"\n        + \"group e.deptno\";\n    final String ml2 = \"from e in emp\\n\"\n        + \"group #deptno e\";\n    final String expected = \"from e in emp group deptno = #deptno e\";\n    ml(ml0).assertParse(expected);\n    ml(ml1).assertParse(expected);\n    ml(ml2).assertParse(expected);\n\n    final String ml3 = \"from e in emp\\n\"\n        + \"group e, h = f + e.g\";\n    final String expected3 = \"from e in emp group e = e, h = f + #g e\";\n    ml(ml3).assertParse(expected3);\n  }\n\n  @Test void testGroupAs2() {\n    ml(\"from e in emp group e.deptno, e.deptno + e.empid\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression #deptno e + #empid e\"));\n    ml(\"from e in emp group 1\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression 1\"));\n    ml(\"from e in emp group e.deptno compute (fn x => x) of e.job\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression fn x => x\"));\n    // Require that we can derive a name for the expression even though there\n    // is only one, and therefore we would not use the name.\n    // (We could revisit this requirement.)\n    ml(\"from e in emp group compute (fn x => x) of e.job\")\n        .assertParseThrowsIllegalArgumentException(\n            is(\"cannot derive label for expression fn x => x\"));\n    ml(\"from e in [{x = 1, y = 5}]\\n\"\n        + \"  group compute sum of e.x\")\n        .assertType(hasMoniker(\"int list\"));\n    ml(\"from e in [1, 2, 3]\\n\"\n        + \"  group compute sum of e\")\n        .assertType(hasMoniker(\"int list\"));\n  }\n\n  @Test void testGroupSansOf() {\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"  group compute c = count\")\n        .assertType(hasMoniker(\"int list\"))\n        .assertEvalIter(equalsUnordered(3));\n\n    ml(\"from e in [{a = 1, b = 5}, {a = 0, b = 1}, {a = 1, b = 1}]\\n\"\n        + \"  group e.a compute rows = (fn x => x)\")\n        .assertType(hasMoniker(\"{a:int, rows:{a:int, b:int} list} list\"))\n        .assertEvalIter(\n            equalsUnordered(\n                list(1, list(list(1, 5), list(1, 1))),\n                list(0, list(list(0, 1)))));\n  }\n\n  /** Tests that Morel throws if there are duplicate names in 'group' or\n   * 'compute' clauses. */\n  @Test void testGroupDuplicates() {\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\")\n        .assertEvalIter(equalsUnordered(0, 1));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x, b = e.x\")\n        .assertEvalIter(equalsUnordered(list(0, 0), list(1, 1)));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x, a = e.y\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'a' in group\")));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group e.x, x = e.y\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'x' in group\")));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\\n\"\n        + \"compute b = sum of e.y\")\n        .assertEvalIter(equalsUnordered(list(0, 1), list(1, 6)));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\\n\"\n        + \"compute a = sum of e.y\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'a' in group\")));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group sum = e.x\\n\"\n        + \"compute sum of e.y\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'sum' in group\")));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\\n\"\n        + \"compute b = sum of e.y, c = sum of e.x\")\n        .assertEvalIter(equalsUnordered(list(0, 1, 0), list(1, 6, 2)));\n    ml(\"from e in [{x = 1, y = 5}, {x = 0, y = 1}, {x = 1, y = 1}]\\n\"\n        + \"group a = e.x\\n\"\n        + \"compute c = sum of e.y, c = sum of e.x\")\n        .assertTypeThrows(\n            throwsA(RuntimeException.class,\n                is(\"Duplicate field name 'c' in group\")));\n  }\n\n  /** Tests query with 'compute' without 'group'. Such a query does not return\n   * a collection, but returns the value of the aggregate function. Technically,\n   * it is a monoid comprehension, and an aggregate function is a monoid. */\n  @Test void testCompute() {\n    ml(\"from i in [1, 2, 3] compute sum of i\")\n        .assertParse(\"from i in [1, 2, 3] compute sum = sum of i\")\n        .assertType(\"int\")\n        .assertEval(is(6));\n    ml(\"from i in [1, 2, 3] compute sum of i, count\")\n        .assertParse(\"from i in [1, 2, 3] \"\n            + \"compute sum = sum of i, count = count\")\n        .assertType(\"{count:int, sum:int}\");\n    // there must be at least one aggregate function\n    ml(\"from i in [1, 2, 3] compute\")\n        .assertParseThrows(\n            throwsA(ParseException.class,\n                startsWith(\"Encountered \\\"<EOF>\\\" at \")));\n\n    // Theoretically a \"group\" without a \"compute\" can be followed by a\n    // \"compute\" step. So, the following is ambiguous. We treat it as a single\n    // \"group ... compute\" step. Under the two-step interpretation, the type\n    // would have been \"int\".\n    ml(\"from (i, j) in [(1, 1), (2, 3), (3, 4)]\\n\"\n        + \"  group j = i mod 2\\n\"\n        + \"  compute sum of j\")\n        .assertType(\"{j:int, sum:int} list\")\n        .assertEvalIter(equalsUnordered(list(1, 5), list(0, 3)));\n\n    // \"compute\" must not be followed by other steps\n    ml(\"from i in [1, 2, 3] compute s = sum of i yield s + 2\")\n        .assertTypeThrows(\n            throwsA(IllegalArgumentException.class,\n                is(\"'compute' step must be last in 'from'\")));\n    // similar, but valid\n    ml(\"(from i in [1, 2, 3] compute s = sum of i) + 2\")\n        .assertType(hasMoniker(\"int\"))\n        .assertEval(is(8));\n  }\n\n  @Test void testGroupYield() {\n    final String ml = \"from r in [{a=2,b=3}]\\n\"\n        + \"group r.a compute sb = sum of r.b\\n\"\n        + \"yield {a, a2 = a + a, sb}\";\n    final String expected = \"from r in [{a = 2, b = 3}]\"\n        + \" group a = #a r compute sb = sum of #b r\"\n        + \" yield {a = a, a2 = a + a, sb = sb}\";\n    final String plan = \"from(\"\n        + \"sink join(pat r, exp tuple(tuple(constant(2), constant(3))), \"\n        + \"sink group(key tuple(apply(fnValue nth:0, argCode get(name r))), \"\n        + \"agg aggregate, \"\n        + \"sink collect(tuple(get(name a), \"\n        + \"apply2(fnValue +, get(name a), get(name a)), \"\n        + \"get(name sb))))))\";\n    ml(ml).assertParse(expected)\n        .assertEvalIter(equalsOrdered(list(2, 4, 3)))\n        .assertPlan(isCode(plan));\n  }\n\n  @Test void testJoinGroup() {\n    final String ml = \"from e in [{empno=100,deptno=10}],\\n\"\n        + \"  d in [{deptno=10,altitude=3500}]\\n\"\n        + \"group e.deptno compute s = sum of e.empno + d.altitude\";\n    final String expected = \"from e in [{deptno = 10, empno = 100}],\"\n        + \" d in [{altitude = 3500, deptno = 10}]\"\n        + \" group deptno = #deptno e\"\n        + \" compute s = sum of #empno e + #altitude d\";\n    ml(ml).assertParse(expected)\n        .assertType(\"{deptno:int, s:int} list\")\n        .assertEvalIter(equalsOrdered(list(10, 3600)));\n  }\n\n  @Test void testGroupGroup() {\n    final String ml = \"from r in [{a=2,b=3}]\\n\"\n        + \"group a1 = r.a, b1 = r.b\\n\"\n        + \"group c2 = a1 + b1 compute s2 = sum of a1\";\n    final String expected = \"from r in [{a = 2, b = 3}]\"\n        + \" group a1 = #a r, b1 = #b r\"\n        + \" group c2 = a1 + b1 compute s2 = sum of a1\";\n    ml(ml).assertParse(expected)\n        .assertType(hasMoniker(\"{c2:int, s2:int} list\"))\n        .assertEvalIter(equalsOrdered(list(5, 2)));\n  }\n\n  @Test void testFromOrderYield() {\n    final String ml = \"from r in [{a=1,b=2},{a=1,b=0},{a=2,b=1}]\\n\"\n        + \"  order r.a desc, r.b\\n\"\n        + \"  skip 0\\n\"\n        + \"  take 4 + 6\\n\"\n        + \"  yield {r.a, b10 = r.b * 10}\";\n    final String expected = \"from r in\"\n        + \" [{a = 1, b = 2}, {a = 1, b = 0}, {a = 2, b = 1}]\"\n        + \" order #a r desc, #b r\"\n        + \" skip 0\"\n        + \" take 4 + 6\"\n        + \" yield {a = #a r, b10 = #b r * 10}\";\n    ml(ml).assertParse(expected)\n        .assertType(hasMoniker(\"{a:int, b10:int} list\"))\n        .assertEvalIter(equalsOrdered(list(2, 10), list(1, 0), list(1, 20)));\n  }\n\n  @Test void testFromEmpty() {\n    final String ml = \"from\";\n    final String expected = \"from\";\n    ml(ml).assertParse(expected)\n        .assertType(hasMoniker(\"unit list\"))\n        .assertEvalIter(equalsOrdered(list()));\n  }\n\n  @Test void testFromPattern() {\n    ml(\"from (x, y) in [(1,2),(3,4),(3,0)] group sum = x + y\")\n        .assertParse(\"from (x, y) in [(1, 2), (3, 4), (3, 0)] \"\n            + \"group sum = x + y\")\n        .assertType(hasMoniker(\"int list\"))\n        .assertEvalIter(equalsUnordered(3, 7));\n    ml(\"from {c, a, ...} in [{a=1.0,b=true,c=3},{a=1.5,b=true,c=4}]\")\n        .assertParse(\"from {a = a, c = c, ...}\"\n            + \" in [{a = 1.0, b = true, c = 3}, {a = 1.5, b = true, c = 4}]\")\n        .assertType(\"{a:real, c:int} list\");\n  }\n\n  @Test void testFromEquals() {\n    final String ml = \"from x in [\\\"a\\\", \\\"b\\\"], y = \\\"c\\\", z in [\\\"d\\\"]\\n\"\n        + \"  yield x ^ y ^ z\";\n    final String expected = \"from x in [\\\"a\\\", \\\"b\\\"], y = \\\"c\\\", z in [\\\"d\\\"]\"\n        + \" yield x ^ y ^ z\";\n    ml(ml).assertParse(expected)\n        .assertType(hasMoniker(\"string list\"))\n        .assertEvalIter(equalsUnordered(\"acd\", \"bcd\"));\n  }\n\n  @Test void testFunFrom() {\n    final String ml = \"let\\n\"\n        + \"  fun query emp =\\n\"\n        + \"    from e in emp\\n\"\n        + \"    yield {e.deptno,e.empno,e.ename}\\n\"\n        + \"in\\n\"\n        + \"  query scott.emp\\n\"\n        + \"end\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertType(\"{deptno:int, empno:int, ename:string} list\");\n  }\n\n  @Test void testToCoreAndBack() {\n    final String[] expressions = {\n        \"()\", null,\n        \"true andalso not false\", null,\n        \"true orelse false\", null,\n        \"1\", null,\n        \"[1, 2]\", null,\n        \"1 :: 2 :: []\", null,\n        \"1 + ~2\", null,\n        \"(\\\"hello\\\", 2, 3)\", null,\n        \"String.substring (\\\"hello\\\", 2, 3)\",\n        \"#substring String (\\\"hello\\\", 2, 3)\",\n        \"substring (\\\"hello\\\", 4, 1)\",\n        \"#substring String (\\\"hello\\\", 4, 1)\",\n        \"{a = 1, b = true, c = \\\"d\\\"}\", null,\n        \"fn x => 1 + x + 3\", null,\n        \"List.tabulate (6, fn i =>\"\n            + \" {i, j = i + 3, s = substring (\\\"morel\\\", 0, i)})\",\n        \"#tabulate List (6, fn i =>\"\n            + \" {i = i, j = i + 3, s = #substring String (\\\"morel\\\", 0, i)})\",\n    };\n    for (int i = 0; i < expressions.length / 2; i++) {\n      String ml = expressions[i * 2];\n      String expected = \"val it = \" + Util.first(expressions[i  * 2 + 1], ml);\n      ml(ml).assertCore(-1, hasToString(expected));\n    }\n  }\n\n  @Test void testError() {\n    ml(\"fn x y => x + y\")\n        .assertError(\n            \"Error: non-constructor applied to argument in pattern: x\");\n    ml(\"- case {a=1,b=2,c=3} of {a=x,b=y} => x + y\")\n        .assertError(\"Error: case object and rules do not agree [tycon \"\n            + \"mismatch]\\n\"\n            + \"  rule domain: {a:[+ ty], b:[+ ty]}\\n\"\n            + \"  object: {a:[int ty], b:[int ty], c:[int ty]}\\n\"\n            + \"  in expression:\\n\"\n            + \"    (case {a=1,b=2,c=3}\\n\"\n            + \"      of {a=x,b=y} => x + y)\\n\");\n    ml(\"fun f {a=x,b=y,...} = x+y\")\n        .assertError(\"Error: unresolved flex record (need to know the names of \"\n            + \"ALL the fields\\n\"\n            + \" in this context)\\n\"\n            + \"  type: {a:[+ ty], b:[+ ty]; 'Z}\\n\");\n    ml(\"fun f {a=x,...} = x | {b=y,...} = y;\")\n        .assertError(\"stdIn:1.24-1.33 Error: can't find function arguments in \"\n            + \"clause\\n\"\n            + \"stdIn:1.24-1.33 Error: illegal function symbol in clause\\n\"\n            + \"stdIn:1.6-1.37 Error: clauses do not all have same function \"\n            + \"name\\n\"\n            + \"stdIn:1.36 Error: unbound variable or constructor: y\\n\"\n            + \"stdIn:1.2-1.37 Error: unresolved flex record\\n\"\n            + \"   (can't tell what fields there are besides #a)\\n\");\n    ml(\"fun f {a=x,...} = x | f {b=y,...} = y\")\n        .assertError(\"Error: unresolved flex record (need to know the names of \"\n            + \"ALL the fields\\n\"\n            + \" in this context)\\n\"\n            + \"  type: {a:'Y, b:'Y; 'Z}\\n\");\n    ml(\"fun f {a=x,...} = x\\n\"\n        + \"  | f {b=y,...} = y\\n\"\n        + \"  | f {a=x,b=y,c=z} = x+y+z\")\n        .assertError(\"stdIn:1.6-3.20 Error: match redundant\\n\"\n            + \"          {a=x,b=_,c=_} => ...\\n\"\n            + \"    -->   {a=_,b=y,c=_} => ...\\n\"\n            + \"    -->   {a=x,b=y,c=z} => ...\\n\");\n    ml(\"fun f 1 = 1 | f n = n * f (n - 1) | g 2 = 2\")\n        .assertError(\"stdIn:3.5-3.46 Error: clauses don't all have same \"\n            + \"function name\");\n  }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest", "name": "InlineTest", "file_path": "src/test/java/net/hydromatic/morel/InlineTest.java", "superclasses": "", "methods": ["[void]testAnalyze()", "[void]testInline()", "[void]testInlineFn()", "[void]testInlineFnUnit()", "[void]testLetAtomic()", "[void]testInlineChained()", "[void]testFromPredicate()", "[void]testFromView()", "[void]testMapFilterToFrom()", "[void]testFilterMapFilterMapToFrom()", "[void]testFromFrom()", "[void]testFromEmptyFrom()", "[void]testInlineCase()", "[void]testInlineCase2()"], "method_uris": ["src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[void]checkInlineChained(int)", "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[String]gen(int,int)", "src/test/java/net/hydromatic/morel/InlineTest.java.InlineTest.[String]v(int)"], "overrides": null, "attributes": [], "class_docstring": "\nTest inlining and other optimizations.\n", "original_string": "public class InlineTest {\n  @Test void testAnalyze() {\n    final String ml = \"let\\n\"\n        + \"  val aUnused = 0\\n\"\n        + \"  val bOnce = 1 + 1\\n\"\n        + \"  val cOnce = 2 + 2\\n\"\n        + \"  val dOnce = 3 + 3\\n\"\n        + \"  val eTwice = bOnce + cOnce\\n\"\n        + \"  val fMultiSafe = dOnce + 4\\n\"\n        + \"  val gAtomic = 5\\n\"\n        + \"  val x = [1, 2]\\n\"\n        + \"  val z = case x of\\n\"\n        + \"     []            => fMultiSafe + gAtomic\\n\"\n        + \"   | 1 :: x2 :: x3 => 2\\n\"\n        + \"   | x0 :: xs      => fMultiSafe + x0 + gAtomic\\n\"\n        + \"in\\n\"\n        + \"  eTwice + eTwice\\n\"\n        + \"end\";\n    final String map = \"{aUnused=DEAD, bOnce=ONCE_SAFE, cOnce=ONCE_SAFE, \"\n        + \"dOnce=ONCE_SAFE, eTwice=MULTI_UNSAFE, fMultiSafe=MULTI_SAFE, \"\n        + \"gAtomic=ATOMIC, it=MULTI_UNSAFE, op +=MULTI_UNSAFE, \"\n        + \"x=ONCE_SAFE, x0=ONCE_SAFE, x2=DEAD, x3=DEAD, xs=DEAD, z=DEAD}\";\n    ml(ml)\n        .assertAnalyze(hasToString(map));\n  }\n\n  @Test void testInline() {\n    final String ml = \"fun f x = let val y = x + 1 in y + 2 end\";\n    final String plan = \"match(x, apply2(fnValue +, \"\n        + \"apply2(fnValue +, get(name x), constant(1)), \"\n        + \"constant(2)))\";\n    ml(ml).assertPlan(isCode(plan));\n  }\n\n  @Test void testInlineFn() {\n    final String ml = \"fun f x =\\n\"\n        + \"  let\\n\"\n        + \"    val succ = fn y => y + 1\\n\"\n        + \"  in\\n\"\n        + \"    succ x\\n\"\n        + \"  end\";\n    final String plan =\n        \"match(x, apply2(fnValue +, get(name x), constant(1)))\";\n    ml(ml).assertPlan(isCode(plan))\n        .assertEval(whenAppliedTo(2, is(3)));\n  }\n\n  @Test void testInlineFnUnit() {\n    final String ml = \"fun f () = String.size \\\"abc\\\"\";\n    final String core = \"val f = fn v0 => #size String \\\"abc\\\"\";\n    ml(ml)\n        .assertEval(whenAppliedTo(list(), is(3)))\n        .assertCore(2, hasToString(core));\n  }\n\n  /** We inline a variable (y), even though it is used twice, because its\n   * value is atomic (x). */\n  @Test void testLetAtomic() {\n    final String ml = \"fun f x =\\n\"\n        + \"  let\\n\"\n        + \"    val y = x\\n\"\n        + \"  in\\n\"\n        + \"    y + 1 + y\\n\"\n        + \"  end\";\n    final String core = \"val f = fn x => x + 1 + x\";\n    ml(ml)\n        .assertEval(whenAppliedTo(2, is(5))).assertCore(2, hasToString(core));\n  }\n\n  @Test void testInlineChained() {\n    // Generate code \"fun f x0 = x0 + 1\";\n    // calling \"f 0\" yields value 1.\n    checkInlineChained(1);\n\n    // Generate code \"fun f x0 =\n    //   let val x1 = x0 + 1\n    //   in x1 + 2\n    //   end\";\n    // calling \"f 0\" yields value 1 + 2 = 3.\n    checkInlineChained(2);\n\n    // Generate code \"fun f x0 = ... in x2 + 3 ... end\";\n    // calling \"f 0\" yields value 1 + 2 + 3 = 6.\n    checkInlineChained(3);\n\n    // If inlining algorithm is exponential, this one will be super-slow.\n    checkInlineChained(200);\n  }\n\n  /** Checks that a nested expression of depth {@code n} gives the right\n   * answer and completes in a reasonable time. */\n  private void checkInlineChained(int n) {\n    final String ml = \"fun f x0 =\\n\"\n        + gen(1, n);\n    final int expected = n * (n + 1) / 2;\n    ml(ml).assertEval(Matchers.whenAppliedTo(0, is(expected)));\n  }\n\n  /** Generates a deeply nested expression,\n   * such as\n   *\n   * <pre>{@code\n   * fun f x0 =\n   *   let val x1 = x0 + 1 in\n   *      let val x2 = x1 + 2 in\n   *        ...\n   *           xN + (N + 1)\n   *        ...\n   *      end\n   *    end\n   * }</pre>\n   *\n   * <p>Such an expression is a challenge for the inliner, because x0 is\n   * inlined into x1, x1 is inlined into x2, and so forth. If done wrong, the\n   * algorithm is exponential.\n   */\n  private String gen(int i, int n) {\n    if (i == n) {\n      return v(i - 1) + \" + \" + i;\n    } else {\n      return \" let val \" + v(i) + \" = \" + v(i - 1) + \" + \" + i + \" in\\n\"\n          + gen(i + 1, n) + \"\\n\"\n          + \"end\\n\";\n    }\n  }\n\n  /** Returns a variable name such as \"x1\". */\n  private String v(int i) {\n    return \"x\" + i;\n  }\n\n  /** Tests that a predicate is inlined inside {@code where}. */\n  @Test void testFromPredicate() {\n    final String ml = \"let\\n\"\n        + \"  fun isEven n = n mod 2 = 0\\n\"\n        + \"in\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  where isEven e.empno\\n\"\n        + \"  yield e.deptno\\n\"\n        + \"end\";\n    final String core0 = \"val it = \"\n        + \"let \"\n        + \"val isEven = fn n => n mod 2 = 0 \"\n        + \"in \"\n        + \"from e in #emp scott \"\n        + \"where isEven (#empno e) yield #deptno e end\";\n    final String core1 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"where let val n = #empno e in op mod (n, 2) = 0 end yield #deptno e\";\n    final String core2 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"where op mod (#empno e, 2) = 0 yield #deptno e\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core2))\n        .assertEval(is(list(20, 30, 30, 10, 20, 30, 20, 30, 20, 10)));\n  }\n\n  /** Tests that a predicate is inlined inside {@code where}. */\n  @Test void testFromView() {\n    final String ml = \"let\\n\"\n        + \"  fun evenEmp x =\\n\"\n        + \"    from e in scott.emp\\n\"\n        + \"    where e.empno mod 2 = 0\\n\"\n        + \"in\\n\"\n        + \"  from e in (evenEmp 1)\\n\"\n        + \"  where e.deptno = 10\\n\"\n        + \"  yield e.ename\\n\"\n        + \"end\";\n    final String core0 = \"val it = \"\n        + \"let\"\n        + \" val evenEmp = fn x =>\"\n        + \" from e in #emp scott\"\n        + \" where #empno e mod 2 = 0 \"\n        + \"in\"\n        + \" from e_1 in evenEmp 1\"\n        + \" where #deptno e_1 = 10\"\n        + \" yield #ename e_1 \"\n        + \"end\";\n    final String core1 = \"val it = \"\n        + \"from e_1 in \"\n        + \"(let val x = 1\"\n        + \" in from e in #emp scott\"\n        + \" where op mod (#empno e, 2) = 0 \"\n        + \"end)\"\n        + \" where #deptno e_1 = 10\"\n        + \" yield #ename e_1\";\n    final String core2 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"where op mod (#empno e, 2) = 0 \"\n        + \"yield {e = e} \"\n        + \"where #deptno e_1 = 10 \"\n        + \"yield #ename e_1\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core2))\n        .assertEval(isUnordered(list(\"CLARK\", \"MILLER\")));\n  }\n\n  /** Tests that an expression involving 'map' and 'filter'\n   * is converted to a 'from' expression. */\n  @Test void testMapFilterToFrom() {\n    final String ml = \"map (fn e => (#empno e))\\n\"\n        + \"  (List.filter (fn e => (#deptno e) = 30) (#emp scott))\";\n    final String core0 = \"val it = \"\n        + \"map (fn e_1 => #empno e_1) \"\n        + \"(#filter List (fn e => #deptno e = 30) \"\n        + \"(#emp scott))\";\n    final String core1 = \"val it = \"\n        + \"from v0 in \"\n        + \"#filter List (fn e => #deptno e = 30) (#emp scott) \"\n        + \"yield (fn e_1 => #empno e_1) v0\";\n    final String core2 = \"val it = \"\n        + \"from v2 in #emp scott \"\n        + \"where #deptno v2 = 30 \"\n        + \"yield {v0 = v2} \"\n        + \"yield #empno v0\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core2))\n        .assertEval(isUnordered(list(7499, 7521, 7654, 7698, 7844, 7900)));\n  }\n\n  /** Tests that an expression involving 'filter' then 'map' then 'filter' then\n   * 'map' is converted to a 'from' expression. */\n  @Test void testFilterMapFilterMapToFrom() {\n    final String ml = \"\"\n        + \"map (fn r => r + 100)\\n\"\n        + \"  (map (fn r => #x r + #z r)\\n\"\n        + \"    (List.filter (fn r => #y r > #z r)\\n\"\n        + \"      (map (fn e => {x = #empno e, y = #deptno e, z = 15})\\n\"\n        + \"        (List.filter (fn e => #deptno e = 30)\\n\"\n        + \"          (#emp scott)))))\";\n    final String core0 = \"val it = \"\n        + \"map (fn r_2 => r_2 + 100)\"\n        + \" (map (fn r_1 => #x r_1 + #z r_1)\"\n        + \" (#filter List (fn r => #y r > #z r)\"\n        + \" (map (fn e_1 => {x = #empno e_1, y = #deptno e_1, z = 15})\"\n        + \" (#filter List (fn e => #deptno e = 30) (#emp scott)))))\";\n    final String core1 = \"val it = \"\n        + \"from v0 in #map List (fn r_1 => #x r_1 + #z r_1)\"\n        + \" (#filter List (fn r => #y r > #z r)\"\n        + \" (#map List (fn e_1 => {x = #empno e_1, y = #deptno e_1, z = 15})\"\n        + \" (#filter List (fn e => #deptno e = 30) (#emp scott)))) \"\n        + \"yield (fn r_2 => r_2 + 100) v0\";\n    final String core2 = \"val it = \"\n        + \"from v6 in #emp scott \"\n        + \"where #deptno v6 = 30 \"\n        + \"yield {v5 = v6} \"\n        + \"yield {v4 = {x = #empno v5, y = #deptno v5, z = 15}} \"\n        + \"where #y v4 > #z v4 \"\n        + \"yield {v2 = v4} \"\n        + \"yield {v0 = #x v2 + #z v2} \"\n        + \"yield v0 + 100\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core2))\n        .assertEval(isUnordered(list(7614, 7636, 7769, 7813, 7959, 8015)));\n  }\n\n  @Test void testFromFrom() {\n    final String ml = \"from i in (\\n\"\n        + \"  from e in scott.emp\\n\"\n        + \"  yield e.deptno)\\n\"\n        + \"where i > 10\\n\"\n        + \"yield i / 10\";\n    final String core0 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"yield {i = #deptno e} \"\n        + \"where i > 10 \"\n        + \"yield i / 10\";\n    final String core1 = \"val it = \"\n        + \"from e in #emp scott \"\n        + \"yield {i = #deptno e} \"\n        + \"where i > 10 \"\n        + \"yield /:int (i, 10)\";\n    ml(ml)\n        .withBinding(\"scott\", BuiltInDataSet.SCOTT)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core1))\n        .assertEval(isUnordered(list(2, 3, 3, 2, 3, 3, 2, 3, 2, 3, 2)));\n  }\n\n  @Test void testFromEmptyFrom() {\n    final String ml = \"from u in (from)\\n\"\n        + \"where 3 < 4\\n\"\n        + \"yield {u, v = 10}\";\n    final String core0 = \"val it = \"\n        + \"from u in (from) \"\n        + \"where 3 < 4 \"\n        + \"yield {u = u, v = 10}\";\n    final String core1 = \"val it = \"\n        + \"from \"\n        + \"yield {u = ()} \"\n        + \"where 3 < 4 \"\n        + \"yield {u = u, v = 10}\";\n    ml(ml)\n        .assertCoreString(hasToString(core0), hasToString(core1),\n            hasToString(core1))\n        .assertEval(isUnordered(list(list(Unit.INSTANCE, 10))));\n  }\n\n  /** Tests that a singleton {@code case} is inlined. */\n  @Test void testInlineCase() {\n    final String ml = \"let\\n\"\n        + \"  val f = fn x => case x of y => y + 2\\n\"\n        + \"in\\n\"\n        + \"  f 3\\n\"\n        + \"end\";\n    ml(ml)\n        .assertCore(0,\n            hasToString(\"val it = \"\n                + \"let val f = fn x => case x of y => y + 2 in f 3 end\"))\n        .assertCore(2, hasToString(\"val it = let val x = 3 in x + 2 end\"))\n        .assertEval(is(5));\n  }\n\n  /** Tests that a singleton {@code case} is inlined. */\n  @Test void testInlineCase2() {\n    final String ml = \"let\\n\"\n        + \"  val f = fn (x, y) => case (x, y) of (x1, y1) => x1 - y1\\n\"\n        + \"in\\n\"\n        + \"  f (13, 5)\\n\"\n        + \"end\";\n    ml(ml)\n        .assertCore(0,\n            hasToString(\"val it = \"\n                + \"let\"\n                + \" val f = fn v0 => \"\n                + \"case v0 of (x, y) => \"\n                + \"case (x, y) of (x1, y1) => x1 - y1 \"\n                + \"in\"\n                + \" f (13, 5) \"\n                + \"end\"))\n        .assertCore(2,\n            hasToString(\"val it = \"\n                + \"let val v0 = (13, 5) \"\n                + \"in case v0 of (x, y) => -:int (x, y) \"\n                + \"end\"))\n        .assertEval(is(8));\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/SatTest.java.SatTest", "name": "SatTest", "file_path": "src/test/java/net/hydromatic/morel/SatTest.java", "superclasses": "", "methods": ["[void]testBuild()", "[void]testTrue()", "[void]testFalse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": " Tests satisfiability.", "original_string": "public class SatTest {\n  /** Tests a formula with three clauses, three terms each.\n   * It is in \"3SAT\" form, and has a solution (i.e. is satisfiable). */\n  @Test void testBuild() {\n    final Sat sat = new Sat();\n    final Variable x = sat.variable(\"x\");\n    final Variable y = sat.variable(\"y\");\n\n    // (x \u2228 x \u2228 y) \u2227 (\u00acx \u2228 \u00acy \u2228 \u00acy) \u2227 (\u00acx \u2228 y \u2228 y)\n    final Term clause0 = sat.or(x, x, y);\n    final Term clause1 = sat.or(sat.not(x), sat.not(y), sat.not(y));\n    final Term clause2 = sat.or(sat.not(x), y, y);\n    final Term formula = sat.and(clause0, clause1, clause2);\n    assertThat(formula.toString(),\n        is(\"(x \u2228 x \u2228 y) \u2227 (\u00acx \u2228 \u00acy \u2228 \u00acy) \u2227 (\u00acx \u2228 y \u2228 y)\"));\n\n    final Map<Variable, Boolean> solution = sat.solve(formula);\n    assertThat(solution, notNullValue());\n    assertThat(solution,\n        is(ImmutableMap.of(x, false, y, true)));\n  }\n\n  /** Tests true (\"and\" with zero arguments). */\n  @Test void testTrue() {\n    final Sat sat = new Sat();\n    final Term trueTerm = sat.and();\n    assertThat(trueTerm, hasToString(\"true\"));\n\n    final Map<Variable, Boolean> solve = sat.solve(trueTerm);\n    assertThat(\"satisfiable\", solve, notNullValue());\n    assertThat(solve.isEmpty(), is(true));\n  }\n\n  /** Tests false (\"or\" with zero arguments). */\n  @Test void testFalse() {\n    final Sat sat = new Sat();\n    final Term falseTerm = sat.or();\n    assertThat(falseTerm, hasToString(\"false\"));\n\n    final Map<Variable, Boolean> solve = sat.solve(falseTerm);\n    assertThat(\"not satisfiable\", solve, nullValue());\n  }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest", "name": "PairListTest", "file_path": "src/test/java/net/hydromatic/morel/PairListTest.java", "superclasses": "", "methods": ["[void]testPairList()", "[void]testAddAll()", "[void]testPairListOfMap()", "[void]testPairListWithCapacity()", "[void]testPairListOf()", "[void]testTransform()", "[void]testBuilder()"], "method_uris": ["src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[List<T>]left(List<? extends Map.Entry<? extends T, ? extends U>>)", "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[List<U>]right(List<? extends Map.Entry<? extends T, ? extends U>>)", "src/test/java/net/hydromatic/morel/PairListTest.java.PairListTest.[void]validate(PairList<T, U>,List<? extends Map.Entry<T, U>>)"], "overrides": null, "attributes": [], "class_docstring": " Unit test for {@code PairList}.", "original_string": "class PairListTest {\n  /** Equivalent to {@link Pair#left} but without calling\n   * {@link PairList#leftList()}. */\n  private static <T, U> List<T> left(\n      final List<? extends Map.Entry<? extends T, ? extends U>> pairs) {\n    return new AbstractList<T>() {\n      @Override public T get(int index) {\n        return pairs.get(index).getKey();\n      }\n\n      @Override public int size() {\n        return pairs.size();\n      }\n    };\n  }\n\n  /** Equivalent to {@link Pair#right} but without calling\n   * {@link PairList#rightList()}. */\n  private static <T, U> List<U> right(\n      final List<? extends Map.Entry<? extends T, ? extends U>> pairs) {\n    return new AbstractList<U>() {\n      @Override public U get(int index) {\n        return pairs.get(index).getValue();\n      }\n\n      @Override public int size() {\n        return pairs.size();\n      }\n    };\n  }\n\n  /** Compares a {@link PairList} with a {@link List} that should have\n   * equivalent contents. */\n  private <T, U> void validate(PairList<T, U> pairList,\n      List<? extends Map.Entry<T, U>> list) {\n    assertThat(pairList.isEmpty(), is(list.isEmpty()));\n    assertThat(pairList, hasSize(list.size()));\n    assertThat(pairList.leftList(), hasSize(list.size()));\n    assertThat(pairList.rightList(), hasSize(list.size()));\n    assertThat(pairList.leftList(), is(left(list)));\n    assertThat(pairList.leftList(), instanceOf(RandomAccess.class));\n    assertThat(pairList.rightList(), is(right(list)));\n    assertThat(pairList.rightList(), instanceOf(RandomAccess.class));\n\n    // Check PairList.left(int) and PairList.right(int)\n    for (int i = 0; i < list.size(); i++) {\n      Map.Entry<T, U> entry = list.get(i);\n      assertThat(pairList.left(i), is(entry.getKey()));\n      assertThat(pairList.right(i), is(entry.getValue()));\n    }\n\n    final List<Map.Entry<T, U>> list2 = new ArrayList<>(pairList);\n    assertThat(list2, is(list));\n\n    // Check PairList.forEach(Consumer)\n    list2.clear();\n    //noinspection UseBulkOperation\n    pairList.forEach(p -> list2.add(p));\n    assertThat(list2, is(list));\n\n    // Check PairList.forEach(BiConsumer)\n    list2.clear();\n    pairList.forEach((t, u) -> list2.add(Pair.of(t, u)));\n    assertThat(list2, is(list));\n\n    // Check PairList.forEachIndexed\n    list2.clear();\n    pairList.forEachIndexed((i, t, u) -> {\n      assertThat(i, is(list2.size()));\n      list2.add(Pair.of(t, u));\n    });\n    assertThat(list2, is(list));\n\n    // Check PairList.immutable()\n    // Skip if there are no null keys or values\n    if (list.stream().anyMatch(e -> e.getKey() == null)) {\n      // PairList.immutable should throw if there are null keys\n      try {\n        Object o = pairList.immutable();\n        fail(\"expected error, got \" + o);\n      } catch (NullPointerException e) {\n        assertThat(e.getMessage(), startsWith(\"key at index\"));\n      }\n    } else if (list.stream().anyMatch(e -> e.getValue() == null)) {\n      // PairList.immutable should throw if there are null values\n      try {\n        Object o = pairList.immutable();\n        fail(\"expected error, got \" + o);\n      } catch (NullPointerException e) {\n        assertThat(e.getMessage(), startsWith(\"value at index\"));\n      }\n    } else {\n      final PairList<T, U> immutablePairList = pairList.immutable();\n      assertThat(immutablePairList, hasSize(list.size()));\n      assertThat(immutablePairList, is(list));\n\n      list2.clear();\n      immutablePairList.forEach((k, v) -> list2.add(Pair.of(k, v)));\n      assertThat(list2, is(list));\n    }\n  }\n\n  /** Basic test for {@link PairList}. */\n  @Test void testPairList() {\n    final PairList<Integer, String> pairList = PairList.of();\n    final List<Map.Entry<Integer, String>> list = new ArrayList<>();\n\n    validate(pairList, list);\n\n    // add(T, U)\n    pairList.add(1, \"a\");\n    list.add(Pair.of(1, \"a\"));\n    validate(pairList, list);\n\n    // add(Pair<T, U>)\n    pairList.add(Pair.of(2, \"b\"));\n    list.add(Pair.of(2, \"b\"));\n    validate(pairList, list);\n\n    // add(T, U)\n    pairList.add(2, \"bb\");\n    list.add(Pair.of(2, \"bb\"));\n    validate(pairList, list);\n\n    // add(int, Pair<T, U>)\n    pairList.add(0, Pair.of(3, \"c\"));\n    list.add(0, Pair.of(3, \"c\"));\n    validate(pairList, list);\n\n    // add(int, T, U)\n    pairList.add(0, 4, \"d\");\n    list.add(0, Pair.of(4, \"d\"));\n    validate(pairList, list);\n\n    // remove(int)\n    Map.Entry<Integer, String> x = pairList.remove(1);\n    Map.Entry<Integer, String> y = list.remove(1);\n    assertThat(x, is(y));\n    validate(pairList, list);\n\n    // clear()\n    pairList.clear();\n    list.clear();\n    validate(pairList, list);\n\n    // clear() again\n    pairList.clear();\n    list.clear();\n    validate(pairList, list);\n\n    // add(T, U) having called clear\n    pairList.add(-1, \"c\");\n    list.add(Pair.of(-1, \"c\"));\n    validate(pairList, list);\n\n    // addAll(PairList)\n    final PairList<Integer, String> pairList8 = PairList.copyOf(8, \"x\", 7, \"y\");\n    pairList.addAll(pairList8);\n    list.addAll(pairList8);\n    validate(pairList, list);\n\n    // addAll(int, PairList)\n    pairList.addAll(3, pairList8);\n    list.addAll(3, pairList8);\n    validate(pairList, list);\n\n    PairList<Integer, String> immutablePairList = pairList.immutable();\n    assertThrows(UnsupportedOperationException.class, () ->\n        immutablePairList.add(0, \"\"));\n    validate(immutablePairList, list);\n\n    // set(int, Pair<T, U>)\n    pairList.set(2, 0, \"p\");\n    list.set(2, Pair.of(0, \"p\"));\n    validate(pairList, list);\n\n    // set(int, T, U)\n    pairList.set(1, Pair.of(88, \"q\"));\n    list.set(1, Pair.of(88, \"q\"));\n    validate(pairList, list);\n  }\n\n  @Test void testAddAll() {\n    PairList<String, Integer> pairList = PairList.of();\n\n    // MutablePairList (0 entries)\n    pairList.addAll(PairList.of());\n    assertThat(pairList, hasSize(0));\n\n    // MutablePairList (1 entry)\n    pairList.addAll(PairList.of(\"a\", 1));\n    assertThat(pairList, hasSize(1));\n\n    // MutablePairList (2 entries)\n    pairList.addAll(PairList.of(ImmutableMap.of(\"b\", 2, \"c\", 3)));\n    assertThat(pairList, hasSize(3));\n\n    // EmptyImmutablePairList\n    pairList.addAll(ImmutablePairList.of());\n    assertThat(pairList, hasSize(3));\n\n    // ImmutableList (0 entries)\n    pairList.addAll(ImmutableList.of());\n    assertThat(pairList, hasSize(3));\n\n    // SingletonImmutablePairList\n    pairList.addAll(ImmutablePairList.of(\"d\", 4));\n    assertThat(pairList, hasSize(4));\n\n    // ImmutableList (1 entry)\n    pairList.addAll(ImmutableList.of(new MapEntry<>(\"e\", 5)));\n    assertThat(pairList, hasSize(5));\n\n    // MutablePairList (2 entries)\n    pairList.addAll(PairList.copyOf(\"f\", 6, \"g\", 7));\n    assertThat(pairList, hasSize(7));\n\n    // ArrayImmutablePairList (2 entries, created from MutablePairList)\n    pairList.addAll(PairList.copyOf(\"h\", 8, \"i\", 9).immutable());\n    assertThat(pairList, hasSize(9));\n\n    // ArrayImmutablePairList (3 entries, created using copyOf)\n    pairList.addAll(ImmutablePairList.copyOf(\"j\", 10, \"k\", 11, \"l\", 12));\n    assertThat(pairList, hasSize(12));\n\n    // ArrayImmutablePairList (2 entries, created using copyOf)\n    pairList.addAll(ImmutablePairList.copyOf(\"m\", 13, \"n\", 14));\n    assertThat(pairList, hasSize(14));\n\n    // ArrayImmutablePairList (1 entry, created using copyOf)\n    pairList.addAll(ImmutablePairList.copyOf(\"o\", 15));\n    assertThat(pairList, hasSize(15));\n\n    assertThat(pairList,\n        hasToString(\"[<a, 1>, <b, 2>, <c, 3>, <d, 4>, <e, 5>, <f, 6>, \"\n            + \"<g, 7>, <h, 8>, <i, 9>, <j, 10>, <k, 11>, <l, 12>, \"\n            + \"<m, 13>, <n, 14>, <o, 15>]\"));\n  }\n\n  /** Tests {@link PairList#of(Map)} and {@link PairList#toImmutableMap()}. */\n  @Test void testPairListOfMap() {\n    final ImmutableMap<String, Integer> map = ImmutableMap.of(\"a\", 1, \"b\", 2);\n    final PairList<String, Integer> pairList = PairList.of(map);\n    assertThat(pairList, hasSize(2));\n    assertThat(pairList, hasToString(\"[<a, 1>, <b, 2>]\"));\n\n    final List<Map.Entry<String, Integer>> list = new ArrayList<>(map.entrySet());\n    validate(pairList, list);\n\n    final ImmutableMap<String, Integer> map2 = pairList.toImmutableMap();\n    assertThat(map2, is(map));\n\n    // After calling toImmutableMap, you can modify the list and call\n    // toImmutableMap again.\n    pairList.add(\"c\", 3);\n    list.add(Pair.of(\"c\", 3));\n    validate(pairList, list);\n    assertThat(pairList, hasToString(\"[<a, 1>, <b, 2>, <c, 3>]\"));\n    final ImmutableMap<String, Integer> map3 = pairList.toImmutableMap();\n    assertThat(map3, hasToString(\"{a=1, b=2, c=3}\"));\n\n    final Map<String, Integer> emptyMap = ImmutableMap.of();\n    final PairList<String, Integer> emptyPairList = PairList.of(emptyMap);\n    assertThat(emptyPairList.isEmpty(), is(true));\n    validate(emptyPairList, Collections.emptyList());\n  }\n\n  /** Tests {@link PairList#withCapacity(int)}. */\n  @Test void testPairListWithCapacity() {\n    final PairList<String, Integer> list = PairList.withCapacity(100);\n    assertThat(list, hasSize(0));\n    assertThat(list, empty());\n    assertThat(list, hasToString(\"[]\"));\n\n    list.add(\"a\", 1);\n    list.add(\"b\", 2);\n    assertThat(list, hasSize(2));\n    assertThat(list, hasToString(\"[<a, 1>, <b, 2>]\"));\n\n    final Map.Entry<String, Integer> entry = list.remove(0);\n    assertThat(entry.getKey(), is(\"a\"));\n    assertThat(entry.getValue(), is(1));\n    assertThat(list, hasToString(\"[<b, 2>]\"));\n  }\n\n  @Test void testPairListOf() {\n    final PairList<String, Integer> list0 = PairList.of();\n    assertThat(list0, hasSize(0));\n    assertThat(list0, empty());\n    assertThat(list0, hasToString(\"[]\"));\n\n    final PairList<String, Integer> list1 = PairList.of(\"a\", 1);\n    assertThat(list1, hasSize(1));\n    assertThat(list1, hasToString(\"[<a, 1>]\"));\n\n    final PairList<String, Integer> list3 =\n        PairList.copyOf(\"a\", 1, \"b\", null, \"c\", 3);\n    assertThat(list3, hasSize(3));\n    assertThat(list3, hasToString(\"[<a, 1>, <b, null>, <c, 3>]\"));\n\n    assertThrows(IllegalArgumentException.class,\n        () -> PairList.copyOf(\"a\", 1, \"b\", 2, \"c\"),\n        \"odd number of arguments\");\n  }\n\n  @Test void testTransform() {\n    final PairList<String, Integer> mutableList3 =\n        PairList.copyOf(\"a\", 1, null, 5, \"c\", 3);\n    final PairList<String, Integer> immutableList3 =\n        PairList.copyOf(\"a\", 1, \"null\", 5, \"c\", 3);\n\n    final PairList<String, Integer> mutableList0 = PairList.of();\n\n    final PairList<String, Integer> mutableList1 = PairList.of(\"a\", 1);\n    final PairList<String, Integer> doubleList1 =\n        ImmutablePairList.copyOf(\"a\", 1, \"a\", 1);\n\n    for (boolean mutable : new boolean[] {false, true}) {\n      PairList<String, Integer> list0 =\n          mutable ? mutableList0 : mutableList0.immutable();\n      PairList<String, Integer> list1 =\n          mutable ? mutableList1 : mutableList1.immutable();\n      PairList<String, Integer> list3 =\n          mutable ? mutableList3 : immutableList3;\n\n      assertThat(list0.transform((s, i) -> s + i), empty());\n\n      assertThat(list1.transform((s, i) -> s + i), is(ImmutableList.of(\"a1\")));\n\n      assertThat(list3.transform((s, i) -> s + i),\n          is(Arrays.asList(\"a1\", \"null5\", \"c3\")));\n      assertThat(list3.transform2((s, i) -> s + i),\n          is(Arrays.asList(\"a1\", \"null5\", \"c3\")));\n\n      final BiPredicate<String, Integer> gt2 = (s, i) -> i > 2;\n      assertThat(list3.anyMatch(gt2), is(true));\n      assertThat(list3.allMatch(gt2), is(false));\n      assertThat(list3.noMatch(gt2), is(false));\n      assertThat(list3.firstMatch(gt2), is(1));\n\n      final BiPredicate<String, Integer> negative = (s, i) -> i < 0;\n      assertThat(list3.anyMatch(negative), is(false));\n      assertThat(list3.allMatch(negative), is(false));\n      assertThat(list3.noMatch(negative), is(true));\n      assertThat(list3.firstMatch(negative), is(-1));\n\n      final BiPredicate<String, Integer> positive = (s, i) -> i > 0;\n      assertThat(list3.anyMatch(positive), is(true));\n      assertThat(list3.allMatch(positive), is(true));\n      assertThat(list3.noMatch(positive), is(false));\n      assertThat(list3.firstMatch(positive), is(0));\n\n      final BiPredicate<String, Integer> isNull = (s, i) -> s == null;\n      if (mutable) {\n        assertThat(list3.anyMatch(isNull), is(true));\n        assertThat(list3.allMatch(isNull), is(false));\n        assertThat(list3.noMatch(isNull), is(false));\n        assertThat(list3.firstMatch(isNull), is(1));\n      } else {\n        // In the immutable version, null has been replaced with \"null\"\n        assertThat(list3.anyMatch(isNull), is(false));\n        assertThat(list3.allMatch(isNull), is(false));\n        assertThat(list3.noMatch(isNull), is(true));\n        assertThat(list3.firstMatch(isNull), is(-1));\n      }\n\n      // All predicates behave the same on the empty list\n      Arrays.asList(gt2, negative, positive, isNull).forEach(p -> {\n        assertThat(list0.anyMatch(p), is(false));\n        assertThat(list0.allMatch(p), is(true)); // trivially\n        assertThat(list0.noMatch(p), is(true));\n        assertThat(list0.firstMatch(p), is(-1));\n      });\n\n      // All predicates on the 1-element list have the same answer as the same\n      // predicate on the 2-element list that is the 1-element list doubled.\n      Arrays.asList(gt2, negative, positive, isNull).forEach(p -> {\n        assertThat(list1.anyMatch(p), is(doubleList1.anyMatch(p)));\n        assertThat(list1.allMatch(p), is(doubleList1.anyMatch(p)));\n        assertThat(list1.noMatch(p), is(doubleList1.noMatch(p)));\n        assertThat(list1.firstMatch(p), is(doubleList1.firstMatch(p)));\n      });\n    }\n  }\n\n  @Test void testBuilder() {\n    final PairList.Builder<String, Integer> b = PairList.builder();\n    final List<Pair<String, Integer>> list = new ArrayList<>();\n\n    final PairList<String, Integer> list0 = b.build();\n    validate(list0, list);\n\n    b.add(\"a\", 1);\n    list.add(Pair.of(\"a\", 1));\n    final PairList<String, Integer> list1 = b.build();\n    validate(list1, list);\n\n    b.add(\"b\", 2);\n    b.add(\"c\", null);\n    list.add(Pair.of(\"b\", 2));\n    list.add(Pair.of(\"c\", null));\n    final PairList<String, Integer> list3 = b.build();\n    validate(list3, list);\n\n    // Singleton list with null key\n    final PairList.Builder<String, Integer> b2 = PairList.builder();\n    list.clear();\n    b2.add(null, 5);\n    list.add(Pair.of(null, 5));\n    validate(b2.build(), list);\n\n    // Singleton list with null value\n    final PairList.Builder<String, Integer> b3 = PairList.builder();\n    list.clear();\n    b3.add(\"x\", null);\n    list.add(Pair.of(\"x\", null));\n    validate(b3.build(), list);\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/ast/Pos_splitTest.java.Pos_splitTest", "name": "Pos_splitTest", "file_path": "src/test/java/net/hydromatic/morel/ast/Pos_splitTest.java", "superclasses": "", "methods": ["[void]testSplit_ValidInput()", "[void]testSplit_InvalidInput()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Pos_splitTest {\n\n    @Test\n    public void testSplit_ValidInput() {\n        String input = \"a,b,c\";\n        char delimiter = ',';\n        String file = \"testFile\";\n\n        Pair<String, Pos> result = Pos.split(input, delimiter, file);\n\n        assertEquals(\"abc\", result.left);\n        assertEquals(file, result.right.file);\n    }\n\n    @Test\n    public void testSplit_InvalidInput() {\n        String input = \"a,b,c,d\";\n        char delimiter = ',';\n        String file = \"testFile\";\n\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            Pos.split(input, delimiter, file);\n        });\n\n        assertEquals(\"expected exactly two occurrences of delimiter, ','\", exception.getMessage());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/ast/Pos_equalsTest.java.Pos_equalsTest", "name": "Pos_equalsTest", "file_path": "src/test/java/net/hydromatic/morel/ast/Pos_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pos_equalsTest {\n\n    @Test\n    void testEquals() {\n        Pos pos1 = new Pos(\"file1\", 1, 2, 3, 4);\n        Pos pos2 = new Pos(\"file1\", 1, 2, 3, 4);\n        Pos pos3 = new Pos(\"file2\", 5, 6, 7, 8);\n\n        // Test same object\n        assertTrue(pos1.equals(pos1));\n\n        // Test equal objects\n        assertTrue(pos1.equals(pos2));\n        assertTrue(pos2.equals(pos1));\n\n        // Test different objects\n        assertFalse(pos1.equals(pos3));\n        assertFalse(pos3.equals(pos1));\n\n        // Test null\n        assertFalse(pos1.equals(null));\n\n        // Test different class\n        assertFalse(pos1.equals(\"not a Pos object\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/ast/Pos_plusTest.java.Pos_plusTest", "name": "Pos_plusTest", "file_path": "src/test/java/net/hydromatic/morel/ast/Pos_plusTest.java", "superclasses": "", "methods": ["[void]testPlus()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pos_plusTest {\n\n    @Test\n    void testPlus() {\n        Pos pos1 = new Pos(\"file1\", 1, 2, 3, 4);\n        Pos pos2 = new Pos(\"file1\", 0, 1, 5, 6);\n\n        Pos result = pos1.plus(pos2);\n\n        assertEquals(\"file1\", result.file);\n        assertEquals(0, result.startLine);\n        assertEquals(1, result.startColumn);\n        assertEquals(5, result.endLine);\n        assertEquals(6, result.endColumn);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java.Extents_unionTest", "name": "Extents_unionTest", "file_path": "src/test/java/net/hydromatic/morel/compile/Extents_unionTest.java", "superclasses": "", "methods": ["[void]testUnionWithEmptyList()", "[void]testUnionWithSingleMap()", "[void]testUnionWithMultipleMaps()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Extents_unionTest {\n\n    @Test\n    public void testUnionWithEmptyList() {\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList();\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.union(rangeSetMaps);\n        assertEquals(ImmutableMap.of(\"/\", ImmutableRangeSet.of()), result);\n    }\n\n    @Test\n    public void testUnionWithSingleMap() {\n        ImmutableRangeSet<Integer> rangeSet = ImmutableRangeSet.of();\n        Map<String, ImmutableRangeSet<Integer>> singleMap = ImmutableMap.of(\"/\", rangeSet);\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList(singleMap);\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.union(rangeSetMaps);\n        assertEquals(singleMap, result);\n    }\n\n    @Test\n    public void testUnionWithMultipleMaps() {\n        ImmutableRangeSet<Integer> rangeSet1 = ImmutableRangeSet.of();\n        ImmutableRangeSet<Integer> rangeSet2 = ImmutableRangeSet.of();\n        Map<String, ImmutableRangeSet<Integer>> map1 = ImmutableMap.of(\"/\", rangeSet1);\n        Map<String, ImmutableRangeSet<Integer>> map2 = ImmutableMap.of(\"/\", rangeSet2);\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList(map1, map2);\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.union(rangeSetMaps);\n        assertEquals(ImmutableMap.of(\"/\", rangeSet1.union(rangeSet2)), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java.EnvironmentTest", "name": "EnvironmentTest", "file_path": "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java", "superclasses": "", "methods": ["[void]testOptimizeSubEnvironment()"], "method_uris": ["src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java.EnvironmentTest.[void]checkOptimizeSubEnvironment(Environment)", "src/test/java/net/hydromatic/morel/compile/EnvironmentTest.java.EnvironmentTest.[Matcher<Environment>]hasEnvLength(int)"], "overrides": null, "attributes": [], "class_docstring": "\nTests for {@link net.hydromatic.morel.compile.Environment}.\n", "original_string": "public class EnvironmentTest {\n  /** Tests that if you call {@link Environment#bind} twice with the same name,\n   * the binding chain does not get longer. */\n  @Test void testOptimizeSubEnvironment() {\n    final Environment e0 = Environments.empty()\n        .bind(core.idPat(PrimitiveType.INT, \"a\", 0), 0)\n        .bind(core.idPat(PrimitiveType.INT, \"b\", 0), 1)\n        .bind(core.idPat(PrimitiveType.INT, \"c\", 0), 2);\n    assertThat(e0, instanceOf(Environments.SubEnvironment.class));\n    checkOptimizeSubEnvironment(e0);\n\n    final Environment e0a = e0.bindAll(e0.getValueMap().values());\n    assertThat(e0a, instanceOf(Environments.MapEnvironment.class));\n    checkOptimizeSubEnvironment(e0a);\n  }\n\n  private void checkOptimizeSubEnvironment(Environment e0) {\n    final Set<String> nameSet = ImmutableSet.of(\"false\", \"true\", \"a\", \"b\", \"c\");\n    final Set<String> namePlusFooSet =\n        ImmutableSet.<String>builder().addAll(nameSet).add(\"foo\").build();\n\n    assertThat(e0.getValueMap().keySet(), is(nameSet));\n    assertThat(e0, hasEnvLength(5));\n\n    // Overwrite \"true\"; there are still 5 values, but 6 bindings.\n    final Environment e1 =\n        e0.bind(core.idPat(PrimitiveType.STRING, \"true\", 0), \"yes\");\n    assertThat(e1.getValueMap().keySet(), is(nameSet));\n    assertThat(e1, hasEnvLength(6));\n\n    // Overwrite \"true\" again; still 5 values, and still 6 bindings.\n    final Environment e2 =\n        e1.bind(core.idPat(PrimitiveType.STRING, \"true\", 0), \"no\");\n    assertThat(e2.getValueMap().keySet(), is(nameSet));\n    assertThat(e2, hasEnvLength(6));\n\n    // Add \"foo\". Value count and binding count increase.\n    final Environment e3 =\n        e2.bind(core.idPat(PrimitiveType.STRING, \"foo\", 0), \"baz\");\n    assertThat(e3.getValueMap().keySet(), is(namePlusFooSet));\n    assertThat(e3, hasEnvLength(7));\n\n    // Add \"true\". Value count stays at 7, binding count increases.\n    // (We do not look beyond the \"foo\" for the \"true\"; such optimization would\n    // be nice, but is expensive, so we do not do it.)\n    final Environment e4 =\n        e3.bind(core.idPat(PrimitiveType.STRING, \"true\", 0), \"yes\");\n    assertThat(e4.getValueMap().keySet(), is(namePlusFooSet));\n    assertThat(e4, hasEnvLength(8));\n  }\n\n  private Matcher<Environment> hasEnvLength(int i) {\n    return new CustomTypeSafeMatcher<Environment>(\"environment depth \" + i) {\n      @Override protected boolean matchesSafely(Environment env) {\n        return depth(env) == i;\n      }\n\n      private int depth(Environment env) {\n        final AtomicInteger c = new AtomicInteger();\n        env.visit(b -> c.incrementAndGet());\n        return c.get();\n      }\n    };\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java.Extents_intersectTest", "name": "Extents_intersectTest", "file_path": "src/test/java/net/hydromatic/morel/compile/Extents_intersectTest.java", "superclasses": "", "methods": ["[void]testIntersect_EmptyList()", "[void]testIntersect_SingleMap()", "[void]testIntersect_MultipleMaps()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Extents_intersectTest {\n\n    @Test\n    void testIntersect_EmptyList() {\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList();\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.intersect(rangeSetMaps);\n        assertEquals(ImmutableMap.of(), result);\n    }\n\n    @Test\n    void testIntersect_SingleMap() {\n        ImmutableRangeSet<Integer> rangeSet = ImmutableRangeSet.of();\n        Map<String, ImmutableRangeSet<Integer>> singleMap = ImmutableMap.of(\"key\", rangeSet);\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList(singleMap);\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.intersect(rangeSetMaps);\n        assertEquals(singleMap, result);\n    }\n\n    @Test\n    void testIntersect_MultipleMaps() {\n        ImmutableRangeSet<Integer> rangeSet1 = ImmutableRangeSet.of();\n        ImmutableRangeSet<Integer> rangeSet2 = ImmutableRangeSet.of();\n        Map<String, ImmutableRangeSet<Integer>> map1 = ImmutableMap.of(\"key1\", rangeSet1);\n        Map<String, ImmutableRangeSet<Integer>> map2 = ImmutableMap.of(\"key2\", rangeSet2);\n        List<Map<String, ImmutableRangeSet<Integer>>> rangeSetMaps = Arrays.asList(map1, map2);\n        Map<String, ImmutableRangeSet<Integer>> result = Extents.intersect(rangeSetMaps);\n        assertEquals(2, result.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java.ExtentTest", "name": "ExtentTest", "file_path": "src/test/java/net/hydromatic/morel/compile/ExtentTest.java", "superclasses": "", "methods": ["[void]testConstant()", "[void]testEq()", "[void]testBetween()", "[void]testSubTrue()", "[void]testFlatten()", "[void]testAnalysis2c()", "[void]testAnalysis2d()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "  private static class Fixture {\n    final TypeSystem typeSystem = new TypeSystem();\n    final PrimitiveType intType = PrimitiveType.INT;\n    final Core.IdPat aPat = core.idPat(intType, \"a\", 0);\n    final Core.Id aId = core.id(aPat);\n    final Core.IdPat bPat = core.idPat(intType, \"b\", 0);\n    final Core.Id bId = core.id(bPat);\n    final Core.IdPat cPat = core.idPat(intType, \"c\", 0);\n    final Core.Id cId = core.id(cPat);\n    final Core.IdPat dPat = core.idPat(intType, \"d\", 0);\n    final Core.Id dId = core.id(dPat);\n    final Core.Exp list12 = core.list(typeSystem, intLiteral(1), intLiteral(2));\n    final RecordLikeType deptType =\n        typeSystem.recordType(\n            RecordType.map(\"deptno\", PrimitiveType.INT,\n                \"dname\", PrimitiveType.STRING,\n                \"loc\", PrimitiveType.STRING));\n    final ListType deptListType = typeSystem.listType(deptType);\n    final Core.IdPat depts = core.idPat(deptListType, \"depts\", 0);\n\n    Core.Literal intLiteral(int i) {\n      return core.intLiteral(BigDecimal.valueOf(i));\n    }\n\n    void checkFlatten(Core.Exp exp, String s, String s2) {\n      final List<Core.Exp> andExps = core.decomposeAnd(exp);\n      assertThat(andExps, hasToString(s));\n      assertThat(core.andAlso(typeSystem, andExps),\n          hasToString(exp.toString()));\n\n      final List<Core.Exp> orExps = core.decomposeOr(exp);\n      assertThat(orExps, hasToString(s2));\n      assertThat(core.orElse(typeSystem, orExps),\n          hasToString(exp.toString()));\n    }\n\n    void checkSubTrue(Core.Exp exp, List<Core.Exp> exps, String s) {\n      final Core.Exp exp2 = core.subTrue(typeSystem, exp, exps);\n      assertThat(exp2, hasToString(s));\n    }\n\n    Core.Exp extent(Core.Pat pat, Core.Exp filterExp) {\n      final Extents.Analysis analysis =\n          Extents.create(typeSystem, pat, ImmutableSortedMap.of(),\n              ImmutableList.of(core.where(ImmutableList.of(), filterExp)),\n              ImmutablePairList.of());\n      return analysis.extentExp;\n    }\n  }", "definition": "  private static class Fixture", "class_docstring": "", "name": "Fixture", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final TypeSystem typeSystem = new TypeSystem();", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "TypeSystem", "name": "typeSystem = new TypeSystem()", "syntax_pass": true}, {"attribute_expression": "final PrimitiveType intType = PrimitiveType.INT;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "PrimitiveType", "name": "intType = PrimitiveType.INT", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat aPat = core.idPat(intType, \"a\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "aPat = core.idPat(intType, \"a\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Id aId = core.id(aPat);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Id", "name": "aId = core.id(aPat)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat bPat = core.idPat(intType, \"b\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "bPat = core.idPat(intType, \"b\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Id bId = core.id(bPat);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Id", "name": "bId = core.id(bPat)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat cPat = core.idPat(intType, \"c\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "cPat = core.idPat(intType, \"c\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Id cId = core.id(cPat);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Id", "name": "cId = core.id(cPat)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat dPat = core.idPat(intType, \"d\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "dPat = core.idPat(intType, \"d\", 0)", "syntax_pass": true}, {"attribute_expression": "final Core.Id dId = core.id(dPat);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Id", "name": "dId = core.id(dPat)", "syntax_pass": true}, {"attribute_expression": "final Core.Exp list12 = core.list(typeSystem, intLiteral(1), intLiteral(2));", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.Exp", "name": "list12 = core.list(typeSystem, intLiteral(1), intLiteral(2))", "syntax_pass": true}, {"attribute_expression": "final RecordLikeType deptType =\n        typeSystem.recordType(\n            RecordType.map(\"deptno\", PrimitiveType.INT,\n                \"dname\", PrimitiveType.STRING,\n                \"loc\", PrimitiveType.STRING));", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "RecordLikeType", "name": "deptType =\n        typeSystem.recordType(\n            RecordType.map(\"deptno\", PrimitiveType.INT,\n                \"dname\", PrimitiveType.STRING,\n                \"loc\", PrimitiveType.STRING))", "syntax_pass": true}, {"attribute_expression": "final ListType deptListType = typeSystem.listType(deptType);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "ListType", "name": "deptListType = typeSystem.listType(deptType)", "syntax_pass": true}, {"attribute_expression": "final Core.IdPat depts = core.idPat(deptListType, \"depts\", 0);", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Core.IdPat", "name": "depts = core.idPat(deptListType, \"depts\", 0)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Core.Literal intLiteral(int i) {\n      return core.intLiteral(BigDecimal.valueOf(i));\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Core.Literal", "classes": []}, "name": "intLiteral", "params": [{"name": "i", "type": "int"}], "body": "                                   {\n      return core.intLiteral(BigDecimal.valueOf(i));\n    }", "signature": "Core.Literal intLiteral(int i)"}, {"syntax_pass": true, "original_string": "    void checkFlatten(Core.Exp exp, String s, String s2) {\n      final List<Core.Exp> andExps = core.decomposeAnd(exp);\n      assertThat(andExps, hasToString(s));\n      assertThat(core.andAlso(typeSystem, andExps),\n          hasToString(exp.toString()));\n\n      final List<Core.Exp> orExps = core.decomposeOr(exp);\n      assertThat(orExps, hasToString(s2));\n      assertThat(core.orElse(typeSystem, orExps),\n          hasToString(exp.toString()));\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "checkFlatten", "params": [{"name": "exp", "type": "Core.Exp"}, {"name": "s", "type": "String"}, {"name": "s2", "type": "String"}], "body": "                                                         {\n      final List<Core.Exp> andExps = core.decomposeAnd(exp);\n      assertThat(andExps, hasToString(s));\n      assertThat(core.andAlso(typeSystem, andExps),\n          hasToString(exp.toString()));\n\n      final List<Core.Exp> orExps = core.decomposeOr(exp);\n      assertThat(orExps, hasToString(s2));\n      assertThat(core.orElse(typeSystem, orExps),\n          hasToString(exp.toString()));\n    }", "signature": "void checkFlatten(Core.Exp exp, String s, String s2)"}, {"syntax_pass": true, "original_string": "    void checkSubTrue(Core.Exp exp, List<Core.Exp> exps, String s) {\n      final Core.Exp exp2 = core.subTrue(typeSystem, exp, exps);\n      assertThat(exp2, hasToString(s));\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "checkSubTrue", "params": [{"name": "exp", "type": "Core.Exp"}, {"name": "exps", "type": "List<Core.Exp>"}, {"name": "s", "type": "String"}], "body": "                                                                   {\n      final Core.Exp exp2 = core.subTrue(typeSystem, exp, exps);\n      assertThat(exp2, hasToString(s));\n    }", "signature": "void checkSubTrue(Core.Exp exp, List<Core.Exp> exps, String s)"}, {"syntax_pass": true, "original_string": "    Core.Exp extent(Core.Pat pat, Core.Exp filterExp) {\n      final Extents.Analysis analysis =\n          Extents.create(typeSystem, pat, ImmutableSortedMap.of(),\n              ImmutableList.of(core.where(ImmutableList.of(), filterExp)),\n              ImmutablePairList.of());\n      return analysis.extentExp;\n    }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Core.Exp", "classes": []}, "name": "extent", "params": [{"name": "pat", "type": "Core.Pat"}, {"name": "filterExp", "type": "Core.Exp"}], "body": "                                                      {\n      final Extents.Analysis analysis =\n          Extents.create(typeSystem, pat, ImmutableSortedMap.of(),\n              ImmutableList.of(core.where(ImmutableList.of(), filterExp)),\n              ImmutablePairList.of());\n      return analysis.extentExp;\n    }", "signature": "Core.Exp extent(Core.Pat pat, Core.Exp filterExp)"}]}], "class_docstring": "\nTests for {@link Extents}.\n", "original_string": "public class ExtentTest {\n  private static class Fixture {\n    final TypeSystem typeSystem = new TypeSystem();\n    final PrimitiveType intType = PrimitiveType.INT;\n    final Core.IdPat aPat = core.idPat(intType, \"a\", 0);\n    final Core.Id aId = core.id(aPat);\n    final Core.IdPat bPat = core.idPat(intType, \"b\", 0);\n    final Core.Id bId = core.id(bPat);\n    final Core.IdPat cPat = core.idPat(intType, \"c\", 0);\n    final Core.Id cId = core.id(cPat);\n    final Core.IdPat dPat = core.idPat(intType, \"d\", 0);\n    final Core.Id dId = core.id(dPat);\n    final Core.Exp list12 = core.list(typeSystem, intLiteral(1), intLiteral(2));\n    final RecordLikeType deptType =\n        typeSystem.recordType(\n            RecordType.map(\"deptno\", PrimitiveType.INT,\n                \"dname\", PrimitiveType.STRING,\n                \"loc\", PrimitiveType.STRING));\n    final ListType deptListType = typeSystem.listType(deptType);\n    final Core.IdPat depts = core.idPat(deptListType, \"depts\", 0);\n\n    Core.Literal intLiteral(int i) {\n      return core.intLiteral(BigDecimal.valueOf(i));\n    }\n\n    void checkFlatten(Core.Exp exp, String s, String s2) {\n      final List<Core.Exp> andExps = core.decomposeAnd(exp);\n      assertThat(andExps, hasToString(s));\n      assertThat(core.andAlso(typeSystem, andExps),\n          hasToString(exp.toString()));\n\n      final List<Core.Exp> orExps = core.decomposeOr(exp);\n      assertThat(orExps, hasToString(s2));\n      assertThat(core.orElse(typeSystem, orExps),\n          hasToString(exp.toString()));\n    }\n\n    void checkSubTrue(Core.Exp exp, List<Core.Exp> exps, String s) {\n      final Core.Exp exp2 = core.subTrue(typeSystem, exp, exps);\n      assertThat(exp2, hasToString(s));\n    }\n\n    Core.Exp extent(Core.Pat pat, Core.Exp filterExp) {\n      final Extents.Analysis analysis =\n          Extents.create(typeSystem, pat, ImmutableSortedMap.of(),\n              ImmutableList.of(core.where(ImmutableList.of(), filterExp)),\n              ImmutablePairList.of());\n      return analysis.extentExp;\n    }\n  }\n\n  /** Tests whether an expression is constant.\n   *\n   * @see Core.Exp#isConstant() */\n  @Test void testConstant() {\n    final Fixture f = new Fixture();\n    assertThat(\"1 is literal\",\n        core.intLiteral(BigDecimal.ONE).isConstant(), is(true));\n    assertThat(\"false is literal\",\n        core.boolLiteral(false).isConstant(), is(true));\n    assertThat(\"a is literal\",\n        core.charLiteral('a').isConstant(), is(true));\n    assertThat(\"3.14 is literal\",\n        core.realLiteral(3.14f).isConstant(), is(true));\n    assertThat(\"string is literal\",\n        core.stringLiteral(\"pi\").isConstant(), is(true));\n    assertThat(\"identifier is not literal\",\n        f.aId.isConstant(), is(false));\n    assertThat(\"list of constants is constant\",\n        f.list12.isConstant(), is(true));\n\n    assertThat(\"unit is constant\",\n        core.tuple(f.typeSystem, null, ImmutableList.of()).isConstant(),\n        is(true));\n\n    final PairList<String, Core.Exp> map =\n        PairList.copyOf(\"a\", f.intLiteral(1), \"b\",\n            core.boolLiteral(true));\n    assertThat(\"record of constants is constant\",\n        core.record(f.typeSystem, map).isConstant(), is(true));\n    final List<Core.Exp> list = map.rightList();\n    assertThat(\"tuple of constants is constant\",\n        core.tuple(f.typeSystem, null, list).isConstant(), is(true));\n\n    final PairList<String, Core.Exp> map2 =\n        PairList.copyOf(\"a\", f.intLiteral(1), \"b\", f.aId);\n    assertThat(\"record that contains an id is not constant\",\n        core.record(f.typeSystem, map2).isConstant(), is(false));\n    final List<Core.Exp> list2 = map2.rightList();\n    assertThat(\"tuple that contains an id is not constant\",\n        core.tuple(f.typeSystem, null, list2).isConstant(), is(false));\n\n    // TODO: check that zero-arg constructor (e.g. NIL) is constant\n    // TODO: check that one-arg constructor (e.g. CONS (1, [])) is constant\n  }\n\n  /** Tests a variable assigned a single value. */\n  @Test void testEq() {\n    final Fixture f = new Fixture();\n\n    // pat = \"x\", exp = \"x = 10\", extent = \"[10]\"\n    Core.IdPat xPat = core.idPat(PrimitiveType.INT, \"x\", 0);\n    Core.Literal ten = f.intLiteral(10);\n    Core.Exp exp = core.equal(f.typeSystem, core.id(xPat), ten);\n    Core.Exp x = f.extent(xPat, exp);\n    assertThat(x, hasToString(\"[10]\"));\n\n    // pat = \"x\", exp = \"10 = x\", extent = \"[10]\"\n    Core.Exp exp2 = core.equal(f.typeSystem, ten, core.id(xPat));\n    Core.Exp x2 = f.extent(xPat, exp2);\n    assertThat(x2, hasToString(\"[10]\"));\n  }\n\n  @Test void testBetween() {\n    // pat = \"x\", exp = \"x >= 3 andalso y = 20 andalso x < 10 andalso 5 <> x\",\n    // extent of x is \"extent [[3..5), (5..10)]\";\n    // extent of y is \"extent [20, 20]\";\n    final Fixture f = new Fixture();\n    Core.IdPat xPat = core.idPat(PrimitiveType.INT, \"x\", 0);\n    Core.IdPat yPat = core.idPat(PrimitiveType.INT, \"y\", 0);\n    Core.Literal three = f.intLiteral(3);\n    Core.Literal five = f.intLiteral(5);\n    Core.Literal ten = f.intLiteral(10);\n    Core.Literal twenty = f.intLiteral(20);\n    Core.Exp exp0 = core.greaterThanOrEqualTo(f.typeSystem, core.id(xPat), three);\n    Core.Exp exp1 = core.equal(f.typeSystem, core.id(yPat), twenty);\n    Core.Exp exp2 = core.lessThan(f.typeSystem, core.id(xPat), ten);\n    Core.Exp exp3 = core.notEqual(f.typeSystem, core.id(xPat), five);\n    final Core.Exp exp =\n        core.andAlso(f.typeSystem, exp0,\n            core.andAlso(f.typeSystem, exp1,\n                core.andAlso(f.typeSystem, exp2, exp3)));\n    Core.Exp x = f.extent(xPat, exp);\n    assertThat(x, instanceOf(Core.Apply.class));\n    assertThat(((Core.Apply) x).fn, instanceOf(Core.Literal.class));\n    assertThat(((Core.Literal) ((Core.Apply) x).fn).unwrap(BuiltIn.class),\n        is(BuiltIn.Z_EXTENT));\n    assertThat(x, hasToString(\"extent \\\"int {/=[[3..5), (5..10)]}\\\"\"));\n\n    Core.Exp y = f.extent(yPat, exp);\n    assertThat(y, instanceOf(Core.Apply.class));\n    assertThat(((Core.Apply) y).fn, instanceOf(Core.Literal.class));\n    assertThat(((Core.Literal) ((Core.Apply) y).fn).unwrap(BuiltIn.class),\n        is(BuiltIn.Z_LIST));\n    assertThat(y, hasToString(\"[20]\"));\n  }\n\n  @Test void testSubTrue() {\n    final Fixture f = new Fixture();\n    final Core.Exp exp1 =\n        core.andAlso(f.typeSystem, f.aId,\n            core.andAlso(f.typeSystem, f.bId,\n                core.orElse(f.typeSystem, f.cId, f.intLiteral(1))));\n    final String expected1a = \"a andalso (c orelse 1)\";\n    final String expected1b = \"a andalso (b andalso (c orelse 1))\";\n    final String expected1c = \"b andalso (c orelse 1)\";\n    f.checkSubTrue(exp1, list(f.bId), expected1a);\n    f.checkSubTrue(exp1, list(f.cId), expected1b);\n    f.checkSubTrue(exp1, list(f.cId, f.dId, f.list12), expected1b);\n    f.checkSubTrue(exp1, list(f.aId), expected1c);\n    f.checkSubTrue(exp1, list(f.dId), expected1b);\n    f.checkSubTrue(exp1, list(), expected1b);\n\n    final Core.Exp exp2 =\n        core.orElse(f.typeSystem, f.aId,\n            core.orElse(f.typeSystem, f.bId,\n                core.andAlso(f.typeSystem, f.cId, f.dId)));\n    final String expected2a = \"a orelse (b orelse c andalso d)\";\n    f.checkSubTrue(exp2, list(f.bId), expected2a); // TODO \"a\"\n    f.checkSubTrue(exp2, list(f.cId),\n        expected2a); // TODO \"a orelse (b orelse d)\"\n    f.checkSubTrue(exp2, list(f.bId, f.cId), expected2a); // TODO \"a\"\n    f.checkSubTrue(exp2, list(f.aId), expected2a); // TODO \"true\"\n    f.checkSubTrue(exp2, list(), expected2a);\n  }\n\n  @Test void testFlatten() {\n    final Fixture f = new Fixture();\n    f.checkFlatten(f.aId, \"[a]\", \"[a]\");\n    f.checkFlatten(core.boolLiteral(true), \"[]\", \"[true]\");\n    f.checkFlatten(core.boolLiteral(false), \"[false]\", \"[]\");\n    f.checkFlatten(\n        core.andAlso(f.typeSystem, f.aId,\n            core.andAlso(f.typeSystem, f.bId,\n                core.orElse(f.typeSystem, f.cId, f.intLiteral(1)))),\n        \"[a, b, c orelse 1]\",\n        \"[a andalso (b andalso (c orelse 1))]\");\n    f.checkFlatten(\n        core.orElse(f.typeSystem, f.aId,\n            core.orElse(f.typeSystem, f.bId,\n                core.andAlso(f.typeSystem, f.cId, f.intLiteral(1)))),\n        \"[a orelse (b orelse c andalso 1)]\",\n        \"[a, b, c andalso 1]\");\n  }\n\n  @Test void testAnalysis2c() {\n    final Fixture f = new Fixture();\n    final Core.IdPat loc = core.idPat(PrimitiveType.STRING, \"loc\", 0);\n    final Core.IdPat deptno = core.idPat(PrimitiveType.INT, \"deptno\", 0);\n    final Core.IdPat name = core.idPat(PrimitiveType.STRING, \"name\", 0);\n    final Core.TuplePat pat =\n        core.tuplePat(f.typeSystem, list(loc, deptno, name));\n\n    final Core.Exp condition0 =\n        core.elem(f.typeSystem,\n            core.record(f.typeSystem,\n                PairList.copyOf(\"deptno\", core.id(deptno),\n                    \"dname\", core.id(name),\n                    \"loc\", core.id(loc))),\n            core.id(f.depts));\n    final Core.Exp condition1 =\n        core.greaterThan(f.typeSystem, core.id(deptno),\n            core.intLiteral(BigDecimal.valueOf(20)));\n\n    final BiConsumer<String, Consumer<FromBuilder>> fn = (v, action) -> {\n      final FromBuilder fromBuilder = core.fromBuilder(f.typeSystem);\n      fromBuilder.scan(pat);\n      // Apply one of the variants of 'where' clause\n      action.accept(fromBuilder);\n\n      final PairList<Core.IdPat, Core.Exp> idPats = PairList.of();\n      Extents.Analysis analysis =\n          Extents.create(f.typeSystem, pat, ImmutableSortedMap.of(),\n              fromBuilder.build().steps, idPats);\n      assertThat(analysis, notNullValue());\n      if (\"\".isEmpty()) {\n        assertThat(analysis.extentExp,\n            hasToString((\"from loc in [#loc v0] \"\n                + \"join deptno in [#deptno v0] \"\n                + \"join name in [#dname v0]\").replace(\"v0\", v)));\n        assertThat(analysis.satisfiedFilters, hasSize(3));\n        assertThat(analysis.satisfiedFilters.get(0),\n            hasToString(\"loc = #loc v0\".replace(\"v0\", v)));\n      } else {\n        assertThat(analysis.extentExp, hasToString(\"depts\"));\n        assertThat(analysis.satisfiedFilters, hasSize(1));\n        assertThat(analysis.satisfiedFilters.get(0), is(condition0));\n      }\n      assertThat(analysis.remainingFilters, empty());\n      assertThat(analysis.boundPats, anEmptyMap());\n      assertThat(analysis.goalPats, is(ImmutableSet.of(loc, deptno, name)));\n      assertThat(idPats, hasSize(1));\n      assertThat(idPats.leftList().get(0), hasToString(v));\n    };\n\n    // from (loc, deptno, name)\n    // where op elem ({deptno = deptno, dname = name, loc = loc}, depts)\n    fn.accept(\"v0\", fromBuilder ->\n        fromBuilder.where(condition0));\n\n    // from (loc, deptno, name)\n    // where op elem ({deptno = deptno, dname = name, loc = loc}, depts)\n    // where deptno > 20\n    fn.accept(\"v1\", fromBuilder ->\n        fromBuilder.where(condition0)\n            .where(condition1));\n\n    // from (loc, deptno, name)\n    // where op elem ({deptno = deptno, dname = name, loc = loc}, depts)\n    //    andalso deptno > 20\n    fn.accept(\"v2\", fromBuilder ->\n        fromBuilder.where(\n            core.andAlso(f.typeSystem, condition0, condition1)));\n  }\n\n  @Test void testAnalysis2d() {\n    final Fixture f = new Fixture();\n    final Core.IdPat dno = core.idPat(PrimitiveType.INT, \"dno\", 0);\n    final Core.IdPat name = core.idPat(PrimitiveType.STRING, \"name\", 0);\n    final Core.TuplePat pat = core.tuplePat(f.typeSystem, list(dno, name));\n\n    // from (dno, name)\n    // where op elem ({deptno = dno, dname = name, loc = \"CHICAGO\"}, depts)\n    //   andalso dno > 20\n    final FromBuilder fromBuilder = core.fromBuilder(f.typeSystem);\n    fromBuilder.scan(pat);\n    final Core.Exp condition0 =\n        core.elem(f.typeSystem,\n            core.record(f.typeSystem,\n                PairList.copyOf(\"deptno\", core.id(dno),\n                    \"dname\", core.id(name),\n                    \"loc\", core.stringLiteral(\"CHICAGO\"))),\n            core.id(f.depts));\n    final Core.Exp condition1 =\n        core.greaterThan(f.typeSystem, core.id(dno),\n            core.intLiteral(BigDecimal.valueOf(20)));\n    fromBuilder.where(core.andAlso(f.typeSystem, condition0, condition1));\n\n    final PairList<Core.IdPat, Core.Exp> idPats = PairList.of();\n    Extents.Analysis analysis =\n        Extents.create(f.typeSystem, pat, ImmutableSortedMap.of(),\n            fromBuilder.build().steps, idPats);\n    assertThat(analysis, notNullValue());\n    assertThat(analysis.extentExp,\n        hasToString(\"from dno in [#deptno v0] join name in [#dname v0]\"));\n    assertThat(idPats, hasSize(1));\n    assertThat(idPats.leftList().get(0), hasToString(\"v0\"));\n  }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_leftTest.java.Pair_leftTest", "name": "Pair_leftTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_leftTest.java", "superclasses": "", "methods": ["[void]testLeft()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Pair_leftTest {\n\n    @Test\n    public void testLeft() {\n        // Given\n        List<Map.Entry<String, Integer>> pairs = Arrays.asList(\n            new AbstractMap.SimpleEntry<>(\"a\", 1),\n            new AbstractMap.SimpleEntry<>(\"b\", 2),\n            new AbstractMap.SimpleEntry<>(\"c\", 3)\n        );\n\n        // When\n        List<String> result = Pair.left(pairs);\n\n        // Then\n        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_toImmutableListTest.java.Static_toImmutableListTest", "name": "Static_toImmutableListTest", "file_path": "src/test/java/net/hydromatic/morel/util/Static_toImmutableListTest.java", "superclasses": "", "methods": ["[void]testToImmutableList()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Static_toImmutableListTest {\n\n    @Test\n    void testToImmutableList() {\n        List<String> inputList = Arrays.asList(\"a\", \"b\", \"c\");\n        Stream<String> stream = inputList.stream();\n\n        ImmutableList<String> result = stream.collect(Static.toImmutableList());\n\n        assertEquals(inputList, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Ord_forEachIndexedTest.java.Ord_forEachIndexedTest", "name": "Ord_forEachIndexedTest", "file_path": "src/test/java/net/hydromatic/morel/util/Ord_forEachIndexedTest.java", "superclasses": "", "methods": ["[void]testForEachIndexed()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Ord_forEachIndexedTest {\n\n    @Test\n    public void testForEachIndexed() {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        StringBuilder result = new StringBuilder();\n        ObjIntConsumer<String> consumer = (e, i) -> result.append(i).append(e);\n\n        Ord.forEachIndexed(list, consumer);\n\n        assertEquals(\"0a1b2c\", result.toString());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_toMapTest.java.Pair_toMapTest", "name": "Pair_toMapTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_toMapTest.java", "superclasses": "", "methods": ["[void]testToMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Pair_toMapTest {\n\n    @Test\n    public void testToMap() {\n        // Given\n        List<Pair<String, Integer>> pairs = Arrays.asList(\n            new Pair<>(\"key1\", 1),\n            new Pair<>(\"key2\", 2),\n            new Pair<>(\"key3\", 3)\n        );\n\n        // When\n        Map<String, Integer> result = Pair.toMap(pairs);\n\n        // Then\n        Map<String, Integer> expected = new HashMap<>();\n        expected.put(\"key1\", 1);\n        expected.put(\"key2\", 2);\n        expected.put(\"key3\", 3);\n\n        assertEquals(expected, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java.Pair_compareToTest", "name": "Pair_compareToTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_compareToTest.java", "superclasses": "", "methods": ["[void]testCompareTo_DifferentLeft()", "[void]testCompareTo_SameLeftDifferentRight()", "[void]testCompareTo_SameLeftSameRight()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pair_compareToTest {\n\n    @Test\n    void testCompareTo_DifferentLeft() {\n        Pair<Integer, Integer> pair1 = Pair.of(1, 2);\n        Pair<Integer, Integer> pair2 = Pair.of(2, 2);\n        assertTrue(pair1.compareTo(pair2) < 0);\n    }\n\n    @Test\n    void testCompareTo_SameLeftDifferentRight() {\n        Pair<Integer, Integer> pair1 = Pair.of(1, 2);\n        Pair<Integer, Integer> pair2 = Pair.of(1, 3);\n        assertTrue(pair1.compareTo(pair2) < 0);\n    }\n\n    @Test\n    void testCompareTo_SameLeftSameRight() {\n        Pair<Integer, Integer> pair1 = Pair.of(1, 2);\n        Pair<Integer, Integer> pair2 = Pair.of(1, 2);\n        assertEquals(0, pair1.compareTo(pair2));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Ord_forEachTest.java.Ord_forEachTest", "name": "Ord_forEachTest", "file_path": "src/test/java/net/hydromatic/morel/util/Ord_forEachTest.java", "superclasses": "", "methods": ["[void]testForEach()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Ord_forEachTest {\n\n    @Test\n    public void testForEach() {\n        List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n        StringBuilder result = new StringBuilder();\n        ObjIntConsumer<String> consumer = (e, i) -> result.append(e).append(i);\n\n        Ord.forEach(list, consumer);\n\n        assertEquals(\"a0b1c2\", result.toString());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_intersectTest.java.Static_intersectTest", "name": "Static_intersectTest", "file_path": "src/test/java/net/hydromatic/morel/util/Static_intersectTest.java", "superclasses": "", "methods": ["[void]testIntersect()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Static_intersectTest {\n\n    @Test\n    public void testIntersect() {\n        List<Integer> list0 = Arrays.asList(1, 2, 3, 4);\n        Iterable<Integer> list1 = Arrays.asList(3, 4, 5, 6);\n\n        List<Integer> result = Static.intersect(list0, list1);\n\n        assertEquals(ImmutableList.of(3, 4), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_anyMatchTest.java.Pair_anyMatchTest", "name": "Pair_anyMatchTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_anyMatchTest.java", "superclasses": "", "methods": ["[void]testAnyMatch_True()", "[void]testAnyMatch_False()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pair_anyMatchTest {\n\n    @Test\n    void testAnyMatch_True() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(1, 2, 3);\n        BiPredicate<Integer, Integer> predicate = (k, v) -> k.equals(v);\n\n        assertTrue(Pair.anyMatch(ks, vs, predicate));\n    }\n\n    @Test\n    void testAnyMatch_False() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(4, 5, 6);\n        BiPredicate<Integer, Integer> predicate = (k, v) -> k.equals(v);\n\n        assertFalse(Pair.anyMatch(ks, vs, predicate));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_adjacentsTest.java.Pair_adjacentsTest", "name": "Pair_adjacentsTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_adjacentsTest.java", "superclasses": "", "methods": ["[void]testAdjacentsWithEmptyIterable()", "[void]testAdjacentsWithNonEmptyIterable()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pair_adjacentsTest {\n\n    @Test\n    void testAdjacentsWithEmptyIterable() {\n        Iterable<Integer> emptyIterable = Collections.emptyList();\n        Iterable<Pair<Integer, Integer>> result = Pair.adjacents(emptyIterable);\n        Iterator<Pair<Integer, Integer>> iterator = result.iterator();\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    void testAdjacentsWithNonEmptyIterable() {\n        List<Integer> nonEmptyIterable = Arrays.asList(1, 2, 3);\n        Iterable<Pair<Integer, Integer>> result = Pair.adjacents(nonEmptyIterable);\n        Iterator<Pair<Integer, Integer>> iterator = result.iterator();\n        assertTrue(iterator.hasNext());\n        assertEquals(Pair.of(1, 2), iterator.next());\n        assertTrue(iterator.hasNext());\n        assertEquals(Pair.of(2, 3), iterator.next());\n        assertFalse(iterator.hasNext());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_zipMutableTest.java.Pair_zipMutableTest", "name": "Pair_zipMutableTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_zipMutableTest.java", "superclasses": "", "methods": ["[void]testZipMutable()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pair_zipMutableTest {\n\n    @Test\n    void testZipMutable() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\", \"c\");\n\n        List<Pair<Integer, String>> result = Pair.zipMutable(ks, vs);\n\n        assertEquals(3, result.size());\n        assertEquals(Pair.of(1, \"a\"), result.get(0));\n        assertEquals(Pair.of(2, \"b\"), result.get(1));\n        assertEquals(Pair.of(3, \"c\"), result.get(2));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java.Pair_equalsTest", "name": "Pair_equalsTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameInstance()", "[void]testEquals_DifferentInstanceSameValues()", "[void]testEquals_DifferentInstanceDifferentValues()", "[void]testEquals_NotInstanceOfMapEntry()", "[void]testEquals_InstanceOfMapEntryDifferentValues()", "[void]testEquals_InstanceOfMapEntrySameValues()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pair_equalsTest {\n\n    @Test\n    void testEquals_SameInstance() {\n        Pair<String, Integer> pair = Pair.of(\"key\", 42);\n        assertTrue(pair.equals(pair));\n    }\n\n    @Test\n    void testEquals_DifferentInstanceSameValues() {\n        Pair<String, Integer> pair1 = Pair.of(\"key\", 42);\n        Pair<String, Integer> pair2 = Pair.of(\"key\", 42);\n        assertTrue(pair1.equals(pair2));\n    }\n\n    @Test\n    void testEquals_DifferentInstanceDifferentValues() {\n        Pair<String, Integer> pair1 = Pair.of(\"key\", 42);\n        Pair<String, Integer> pair2 = Pair.of(\"key\", 43);\n        assertFalse(pair1.equals(pair2));\n    }\n\n    @Test\n    void testEquals_NotInstanceOfMapEntry() {\n        Pair<String, Integer> pair = Pair.of(\"key\", 42);\n        assertFalse(pair.equals(\"not a pair\"));\n    }\n\n    @Test\n    void testEquals_InstanceOfMapEntryDifferentValues() {\n        Pair<String, Integer> pair = Pair.of(\"key\", 42);\n        Map.Entry<String, Integer> entry = new AbstractMap.SimpleEntry<>(\"key\", 43);\n        assertFalse(pair.equals(entry));\n    }\n\n    @Test\n    void testEquals_InstanceOfMapEntrySameValues() {\n        Pair<String, Integer> pair = Pair.of(\"key\", 42);\n        Map.Entry<String, Integer> entry = new AbstractMap.SimpleEntry<>(\"key\", 42);\n        assertTrue(pair.equals(entry));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_firstAndTest.java.Pair_firstAndTest", "name": "Pair_firstAndTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_firstAndTest.java", "superclasses": "", "methods": ["[void]testFirstAndWithEmptyIterable()", "[void]testFirstAndWithNonEmptyIterable()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pair_firstAndTest {\n\n    @Test\n    void testFirstAndWithEmptyIterable() {\n        Iterable<Integer> emptyIterable = Collections.emptyList();\n        Iterable<Pair<Integer, Integer>> result = Pair.firstAnd(emptyIterable);\n        Iterator<Pair<Integer, Integer>> iterator = result.iterator();\n        assertFalse(iterator.hasNext());\n    }\n\n    @Test\n    void testFirstAndWithNonEmptyIterable() {\n        List<Integer> nonEmptyIterable = Arrays.asList(1, 2, 3);\n        Iterable<Pair<Integer, Integer>> result = Pair.firstAnd(nonEmptyIterable);\n        Iterator<Pair<Integer, Integer>> iterator = result.iterator();\n        assertTrue(iterator.hasNext());\n        Pair<Integer, Integer> firstPair = iterator.next();\n        assertEquals(1, firstPair.left);\n        assertEquals(2, firstPair.right);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_transformEagerTest.java.Static_transformEagerTest", "name": "Static_transformEagerTest", "file_path": "src/test/java/net/hydromatic/morel/util/Static_transformEagerTest.java", "superclasses": "", "methods": ["[void]testTransformEagerWithEmptyIterable()", "[void]testTransformEagerWithNonEmptyIterable()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Static_transformEagerTest {\n\n    @Test\n    public void testTransformEagerWithEmptyIterable() {\n        Iterable<String> emptyIterable = Collections.emptyList();\n        Function<String, Integer> mapper = String::length;\n\n        ImmutableList<Integer> result = Static.transformEager(emptyIterable, mapper);\n\n        assertEquals(ImmutableList.of(), result);\n    }\n\n    @Test\n    public void testTransformEagerWithNonEmptyIterable() {\n        Iterable<String> nonEmptyIterable = Arrays.asList(\"one\", \"two\", \"three\");\n        Function<String, Integer> mapper = String::length;\n\n        ImmutableList<Integer> result = Static.transformEager(nonEmptyIterable, mapper);\n\n        assertEquals(ImmutableList.of(3, 3, 5), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_findTest.java.Static_findTest", "name": "Static_findTest", "file_path": "src/test/java/net/hydromatic/morel/util/Static_findTest.java", "superclasses": "", "methods": ["[void]testFindRandomAccessList()", "[void]testFindNonRandomAccessList()", "[void]testFindNoMatch()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Static_findTest {\n\n    @Test\n    public void testFindRandomAccessList() {\n        List<Integer> list = ImmutableList.of(1, 2, 3, 4, 5);\n        Predicate<Integer> predicate = i -> i == 3;\n        int result = Static.find(list, predicate);\n        assertEquals(2, result);\n    }\n\n    @Test\n    public void testFindNonRandomAccessList() {\n        List<Integer> list = ImmutableList.of(1, 2, 3, 4, 5);\n        Predicate<Integer> predicate = i -> i == 3;\n        int result = Static.find(list, predicate);\n        assertEquals(2, result);\n    }\n\n    @Test\n    public void testFindNoMatch() {\n        List<Integer> list = ImmutableList.of(1, 2, 3, 4, 5);\n        Predicate<Integer> predicate = i -> i == 6;\n        int result = Static.find(list, predicate);\n        assertEquals(-1, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_rightTest.java.Pair_rightTest", "name": "Pair_rightTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_rightTest.java", "superclasses": "", "methods": ["[void]testRight()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Pair_rightTest {\n\n    @Test\n    public void testRight() {\n        // Given\n        List<Map.Entry<String, Integer>> pairs = Arrays.asList(\n            new AbstractMap.SimpleEntry<>(\"a\", 1),\n            new AbstractMap.SimpleEntry<>(\"b\", 2),\n            new AbstractMap.SimpleEntry<>(\"c\", 3)\n        );\n\n        // When\n        List<Integer> result = Pair.right(pairs);\n\n        // Then\n        assertEquals(Arrays.asList(1, 2, 3), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_noneMatchTest.java.Pair_noneMatchTest", "name": "Pair_noneMatchTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_noneMatchTest.java", "superclasses": "", "methods": ["[void]testNoneMatch_NoMatch()", "[void]testNoneMatch_WithMatch()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pair_noneMatchTest {\n\n    @Test\n    void testNoneMatch_NoMatch() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(4, 5, 6);\n        BiPredicate<Integer, Integer> predicate = (k, v) -> k > v;\n\n        boolean result = Pair.noneMatch(ks, vs, predicate);\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testNoneMatch_WithMatch() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(4, 1, 6);\n        BiPredicate<Integer, Integer> predicate = (k, v) -> k > v;\n\n        boolean result = Pair.noneMatch(ks, vs, predicate);\n\n        assertFalse(result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_forEachTest.java.Pair_forEachTest", "name": "Pair_forEachTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_forEachTest.java", "superclasses": "", "methods": ["[void]testForEach()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Pair_forEachTest {\n\n    @Test\n    public void testForEach() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\", \"c\");\n        StringBuilder result = new StringBuilder();\n\n        BiConsumer<Integer, String> consumer = (k, v) -> result.append(k).append(v);\n\n        Pair.forEach(ks, vs, consumer);\n\n        assertEquals(\"1a2b3c\", result.toString());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest", "name": "TailList_clearTest", "file_path": "src/test/java/net/hydromatic/morel/util/TailList_clearTest.java", "superclasses": "", "methods": ["[void]testClear()", "[void]testClearEmptyList()", "[void]testClearWithNoElementsToRemove()"], "method_uris": ["src/test/java/net/hydromatic/morel/util/TailList_clearTest.java.TailList_clearTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TailList_clearTest {\n    private List<String> backingList;\n    private TailList<String> tailList;\n\n    @BeforeEach\n    public void setUp() {\n        backingList = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\", \"d\"));\n        tailList = new TailList<>(backingList, 2);\n    }\n\n    @Test\n    public void testClear() {\n        assertThat(tailList.size(), is(2));\n        assertThat(backingList.size(), is(4));\n\n        tailList.clear();\n\n        assertThat(tailList.size(), is(0));\n        assertThat(backingList.size(), is(2));\n        assertThat(backingList.get(0), is(\"a\"));\n        assertThat(backingList.get(1), is(\"b\"));\n    }\n\n    @Test\n    public void testClearEmptyList() {\n        TailList<String> emptyTailList = new TailList<>(new ArrayList<>(), 0);\n\n        assertThat(emptyTailList.size(), is(0));\n\n        emptyTailList.clear();\n\n        assertThat(emptyTailList.size(), is(0));\n    }\n\n    @Test\n    public void testClearWithNoElementsToRemove() {\n        TailList<String> noRemoveTailList = new TailList<>(backingList, 4);\n\n        assertThat(noRemoveTailList.size(), is(0));\n\n        noRemoveTailList.clear();\n\n        assertThat(noRemoveTailList.size(), is(0));\n        assertThat(backingList.size(), is(4));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<String> backingList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "backingList", "syntax_pass": true}, {"attribute_expression": "private TailList<String> tailList;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TailList<String>", "name": "tailList", "syntax_pass": true}]}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java.Static_minusTest", "name": "Static_minusTest", "file_path": "src/test/java/net/hydromatic/morel/util/Static_minusTest.java", "superclasses": "", "methods": ["[void]testMinus_AllElementsRemoved()", "[void]testMinus_NoElementsRemoved()", "[void]testMinus_EmptyList()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Static_minusTest {\n\n    @Test\n    public void testMinus_AllElementsRemoved() {\n        List<Integer> list = Arrays.asList(1, 2, 3, 2, 4, 2);\n        List<Integer> result = Static.minus(list, 2);\n        assertEquals(Arrays.asList(1, 3, 4), result);\n    }\n\n    @Test\n    public void testMinus_NoElementsRemoved() {\n        List<Integer> list = Arrays.asList(1, 3, 4);\n        List<Integer> result = Static.minus(list, 2);\n        assertEquals(Arrays.asList(1, 3, 4), result);\n    }\n\n    @Test\n    public void testMinus_EmptyList() {\n        List<Integer> list = ImmutableList.of();\n        List<Integer> result = Static.minus(list, 2);\n        assertEquals(ImmutableList.of(), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java.Pair_zipTest", "name": "Pair_zipTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_zipTest.java", "superclasses": "", "methods": ["[void]testZipStrictEqualSizes()", "[void]testZipStrictDifferentSizes()", "[void]testZipNonStrict()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pair_zipTest {\n\n    @Test\n    void testZipStrictEqualSizes() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\", \"c\");\n        List<Pair<Integer, String>> result = Pair.zip(ks, vs, true);\n        assertEquals(3, result.size());\n        assertEquals(Pair.of(1, \"a\"), result.get(0));\n        assertEquals(Pair.of(2, \"b\"), result.get(1));\n        assertEquals(Pair.of(3, \"c\"), result.get(2));\n    }\n\n    @Test\n    void testZipStrictDifferentSizes() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\");\n        assertThrows(AssertionError.class, () -> Pair.zip(ks, vs, true));\n    }\n\n    @Test\n    void testZipNonStrict() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<String> vs = Arrays.asList(\"a\", \"b\");\n        List<Pair<Integer, String>> result = Pair.zip(ks, vs, false);\n        assertEquals(2, result.size());\n        assertEquals(Pair.of(1, \"a\"), result.get(0));\n        assertEquals(Pair.of(2, \"b\"), result.get(1));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java.Pair_allMatchTest", "name": "Pair_allMatchTest", "file_path": "src/test/java/net/hydromatic/morel/util/Pair_allMatchTest.java", "superclasses": "", "methods": ["[void]testAllMatch_AllElementsMatch()", "[void]testAllMatch_NotAllElementsMatch()", "[void]testAllMatch_DifferentLengths()", "[void]testAllMatch_EmptyCollections()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Pair_allMatchTest {\n\n    @Test\n    void testAllMatch_AllElementsMatch() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(1, 2, 3);\n        BiPredicate<Integer, Integer> predicate = Integer::equals;\n\n        boolean result = Pair.allMatch(ks, vs, predicate);\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testAllMatch_NotAllElementsMatch() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(1, 2, 4);\n        BiPredicate<Integer, Integer> predicate = Integer::equals;\n\n        boolean result = Pair.allMatch(ks, vs, predicate);\n\n        assertFalse(result);\n    }\n\n    @Test\n    void testAllMatch_DifferentLengths() {\n        List<Integer> ks = Arrays.asList(1, 2, 3);\n        List<Integer> vs = Arrays.asList(1, 2);\n        BiPredicate<Integer, Integer> predicate = Integer::equals;\n\n        boolean result = Pair.allMatch(ks, vs, predicate);\n\n        assertTrue(result);\n    }\n\n    @Test\n    void testAllMatch_EmptyCollections() {\n        List<Integer> ks = Collections.emptyList();\n        List<Integer> vs = Collections.emptyList();\n        BiPredicate<Integer, Integer> predicate = Integer::equals;\n\n        boolean result = Pair.allMatch(ks, vs, predicate);\n\n        assertTrue(result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest", "name": "Sat_variableTest", "file_path": "src/test/java/net/hydromatic/morel/util/Sat_variableTest.java", "superclasses": "", "methods": ["[void]testVariableCreation()", "[void]testVariableRetrieval()", "[void]testVariableIdIncrement()", "[void]testVariableNameUniqueness()", "[void]testVariableIdUniqueness()"], "method_uris": ["src/test/java/net/hydromatic/morel/util/Sat_variableTest.java.Sat_variableTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Sat_variableTest {\n    private Sat sat;\n\n    @BeforeEach\n    public void setUp() {\n        sat = new Sat();\n    }\n\n    @Test\n    public void testVariableCreation() {\n        Sat.Variable variable = sat.variable(\"x\");\n        assertNotNull(variable);\n        assertEquals(\"x\", variable.name);\n        assertEquals(0, variable.id);\n    }\n\n    @Test\n    public void testVariableRetrieval() {\n        Sat.Variable variable1 = sat.variable(\"x\");\n        Sat.Variable variable2 = sat.variable(\"x\");\n        assertSame(variable1, variable2);\n    }\n\n    @Test\n    public void testVariableIdIncrement() {\n        Sat.Variable variable1 = sat.variable(\"x\");\n        Sat.Variable variable2 = sat.variable(\"y\");\n        assertEquals(0, variable1.id);\n        assertEquals(1, variable2.id);\n    }\n\n    @Test\n    public void testVariableNameUniqueness() {\n        Sat.Variable variable1 = sat.variable(\"x\");\n        Sat.Variable variable2 = sat.variable(\"y\");\n        assertNotEquals(variable1.name, variable2.name);\n    }\n\n    @Test\n    public void testVariableIdUniqueness() {\n        Sat.Variable variable1 = sat.variable(\"x\");\n        Sat.Variable variable2 = sat.variable(\"y\");\n        assertNotEquals(variable1.id, variable2.id);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Sat sat;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Sat", "name": "sat", "syntax_pass": true}]}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_strTest.java.Static_strTest", "name": "Static_strTest", "file_path": "src/test/java/net/hydromatic/morel/util/Static_strTest.java", "superclasses": "", "methods": ["[void]testStr()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Static_strTest {\n\n    @Test\n    void testStr() {\n        StringBuilder b = new StringBuilder(\"test\");\n        String result = Static.str(b);\n        assertEquals(\"test\", result);\n        assertEquals(0, b.length());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java.Static_shorterThanTest", "name": "Static_shorterThanTest", "file_path": "src/test/java/net/hydromatic/morel/util/Static_shorterThanTest.java", "superclasses": "", "methods": ["[void]testShorterThan_Collection()", "[void]testShorterThan_Iterable()", "[void]testShorterThan_NonPositiveN()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Static_shorterThanTest {\n\n    @Test\n    public void testShorterThan_Collection() {\n        Collection<Integer> collection = Arrays.asList(1, 2, 3);\n        assertTrue(Static.shorterThan(collection, 4));\n        assertFalse(Static.shorterThan(collection, 3));\n    }\n\n    @Test\n    public void testShorterThan_Iterable() {\n        Iterable<Integer> iterable = ImmutableList.of(1, 2, 3);\n        assertTrue(Static.shorterThan(iterable, 4));\n        assertFalse(Static.shorterThan(iterable, 3));\n    }\n\n    @Test\n    public void testShorterThan_NonPositiveN() {\n        Iterable<Integer> iterable = ImmutableList.of(1, 2, 3);\n        assertFalse(Static.shorterThan(iterable, 0));\n        assertFalse(Static.shorterThan(iterable, -1));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/util/Static_plusTest.java.Static_plusTest", "name": "Static_plusTest", "file_path": "src/test/java/net/hydromatic/morel/util/Static_plusTest.java", "superclasses": "", "methods": ["[void]testPlus()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Static_plusTest {\n\n    @Test\n    public void testPlus() {\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"a\", 1);\n        map.put(\"b\", 2);\n\n        Map<String, Integer> result = Static.plus(map, \"c\", 3);\n\n        assertEquals(ImmutableMap.of(\"a\", 1, \"b\", 2, \"c\", 3), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/hydromatic/morel/type/RangeExtent_toStringTest.java.RangeExtent_toStringTest", "name": "RangeExtent_toStringTest", "file_path": "src/test/java/net/hydromatic/morel/type/RangeExtent_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringUnbounded()", "[void]testToStringBounded()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RangeExtent_toStringTest {\n\n    @Test\n    public void testToStringUnbounded() {\n        Type mockType = new Type() {\n            @Override\n            public String toString() {\n                return \"MockType\";\n            }\n\n            @Override\n            public <R> R accept(TypeVisitor<R> visitor) {\n                return null; // Provide a default implementation\n            }\n\n            @Override\n            public Type copy(TypeSystem typeSystem, java.util.function.UnaryOperator<Type> operator) {\n                return this; // Provide a default implementation\n            }\n        };\n\n        RangeExtent rangeExtent = new RangeExtent(null, mockType, ImmutableMap.of());\n        assertEquals(\"MockType\", rangeExtent.toString());\n    }\n\n    @Test\n    public void testToStringBounded() {\n        Type mockType = new Type() {\n            @Override\n            public String toString() {\n                return \"MockType\";\n            }\n\n            @Override\n            public <R> R accept(TypeVisitor<R> visitor) {\n                return null; // Provide a default implementation\n            }\n\n            @Override\n            public Type copy(TypeSystem typeSystem, java.util.function.UnaryOperator<Type> operator) {\n                return this; // Provide a default implementation\n            }\n        };\n\n        ImmutableRangeSet<Integer> mockRangeSet = ImmutableRangeSet.of();\n        RangeExtent rangeExtent = new RangeExtent(null, mockType, ImmutableMap.of(\"path\", mockRangeSet));\n        assertEquals(\"MockType {path=[[]]}\", rangeExtent.toString());\n    }\n}", "super_interfaces": [], "fields": []}]