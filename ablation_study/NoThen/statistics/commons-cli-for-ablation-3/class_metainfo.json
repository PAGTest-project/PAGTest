[{"uris": "src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java.UnrecognizedOptionException", "name": "UnrecognizedOptionException", "file_path": "src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java", "superclasses": "ParseException", "methods": ["[]UnrecognizedOptionException(String)", "[]UnrecognizedOptionException(String,String)", "[String]getOption()"], "method_uris": ["src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java.UnrecognizedOptionException.[]UnrecognizedOptionException(String)", "src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java.UnrecognizedOptionException.[]UnrecognizedOptionException(String,String)", "src/main/java/org/apache/commons/cli/UnrecognizedOptionException.java.UnrecognizedOptionException.[String]getOption()"], "overrides": null, "attributes": [], "class_docstring": "\nThrown during parsing signaling an unrecognized option.\n", "original_string": "public class UnrecognizedOptionException extends ParseException {\n\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = -252504690284625623L;\n\n    /** The unrecognized option. */\n    private final String option;\n\n    /**\n     * Constructs a new {@code UnrecognizedArgumentException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public UnrecognizedOptionException(final String message) {\n        this(message, null);\n    }\n\n    /**\n     * Constructs a new {@code UnrecognizedArgumentException} with the specified option and detail message.\n     *\n     * @param message the detail message\n     * @param option the unrecognized option\n     * @since 1.2\n     */\n    public UnrecognizedOptionException(final String message, final String option) {\n        super(message);\n        this.option = option;\n    }\n\n    /**\n     * Gets the unrecognized option.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public String getOption() {\n        return option;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -252504690284625623L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -252504690284625623L", "syntax_pass": true}, {"attribute_expression": "private final String option;", "docstring": " The unrecognized option.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "option", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/Option.java.Option", "name": "Option", "file_path": "src/main/java/org/apache/commons/cli/Option.java", "superclasses": "", "methods": ["[Builder]builder()", "[Builder]builder(String)", "[]Option(Builder)", "[]Option(String,boolean,String)", "[]Option(String,String)", "[]Option(String,String,boolean,String)", "[boolean]acceptsArg()", "[void]add(String)", "[boolean]addValue(String)", "[void]clearValues()", "[Object]clone()", "[boolean]equals(Object)", "[String]getArgName()", "[int]getArgs()", "[Converter<?, ?>]getConverter()", "[DeprecatedAttributes]getDeprecated()", "[String]getDescription()", "[int]getId()", "[String]getKey()", "[String]getLongOpt()", "[String]getOpt()", "[String]getSince()", "[Object]getType()", "[String]getValue()", "[String]getValue(int)", "[String]getValue(String)", "[String[]]getValues()", "[char]getValueSeparator()", "[List<String>]getValuesList()", "[boolean]hasArg()", "[boolean]hasArgName()", "[boolean]hasArgs()", "[int]hashCode()", "[boolean]hasLongOpt()", "[boolean]hasNoValues()", "[boolean]hasOptionalArg()", "[boolean]hasValueSeparator()", "[boolean]isDeprecated()", "[boolean]isRequired()", "[void]processValue(String)", "[boolean]requiresArg()", "[void]setArgName(String)", "[void]setArgs(int)", "[void]setConverter(Converter<?, ?>)", "[void]setDescription(String)", "[void]setLongOpt(String)", "[void]setOptionalArg(boolean)", "[void]setRequired(boolean)", "[void]setType(Class<?>)", "[void]setType(Object)", "[void]setValueSeparator(char)", "[String]toDeprecatedString()", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/cli/Option.java.Option.[Builder]builder()", "src/main/java/org/apache/commons/cli/Option.java.Option.[Builder]builder(String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[]Option(Builder)", "src/main/java/org/apache/commons/cli/Option.java.Option.[]Option(String,boolean,String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[]Option(String,String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[]Option(String,String,boolean,String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]acceptsArg()", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]add(String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]addValue(String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]clearValues()", "src/main/java/org/apache/commons/cli/Option.java.Option.[Object]clone()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]equals(Object)", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]getArgName()", "src/main/java/org/apache/commons/cli/Option.java.Option.[int]getArgs()", "src/main/java/org/apache/commons/cli/Option.java.Option.[Converter<?, ?>]getConverter()", "src/main/java/org/apache/commons/cli/Option.java.Option.[DeprecatedAttributes]getDeprecated()", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]getDescription()", "src/main/java/org/apache/commons/cli/Option.java.Option.[int]getId()", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]getKey()", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]getLongOpt()", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]getOpt()", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]getSince()", "src/main/java/org/apache/commons/cli/Option.java.Option.[Object]getType()", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]getValue()", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]getValue(int)", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]getValue(String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[String[]]getValues()", "src/main/java/org/apache/commons/cli/Option.java.Option.[char]getValueSeparator()", "src/main/java/org/apache/commons/cli/Option.java.Option.[List<String>]getValuesList()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]hasArg()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]hasArgName()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]hasArgs()", "src/main/java/org/apache/commons/cli/Option.java.Option.[int]hashCode()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]hasLongOpt()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]hasNoValues()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]hasOptionalArg()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]hasValueSeparator()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]isDeprecated()", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]isRequired()", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]processValue(String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[boolean]requiresArg()", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setArgName(String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setArgs(int)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setConverter(Converter<?, ?>)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setDescription(String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setLongOpt(String)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setOptionalArg(boolean)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setRequired(boolean)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setType(Class<?>)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setType(Object)", "src/main/java/org/apache/commons/cli/Option.java.Option.[void]setValueSeparator(char)", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]toDeprecatedString()", "src/main/java/org/apache/commons/cli/Option.java.Option.[String]toString()"], "overrides": null, "attributes": [{"original_string": "    public static final class Builder {\n\n        /** The default type. */\n        private static final Class<String> DEFAULT_TYPE = String.class;\n\n        /**\n         * Returns the input Class or the default type (String) if null.\n         *\n         * @param type the candidate Class.\n         * @return the input Class or the default type (String) if null.\n         */\n        private static Class<?> toType(final Class<?> type) {\n            return type != null ? type : DEFAULT_TYPE;\n        }\n\n        /** The number of argument values this option can have. */\n        private int argCount = UNINITIALIZED;\n\n        /** The name of the argument for this option. */\n        private String argName;\n\n        /** The converter to convert to type. **/\n        private Converter<?, ?> converter;\n\n        /** Specifies whether this option is deprecated. */\n        private DeprecatedAttributes deprecated;\n\n        /** Description of the option. */\n        private String description;\n\n        /** The long representation of the option. */\n        private String longOption;\n\n        /** The name of the option. */\n        private String option;\n\n        /** Specifies whether the argument value of this Option is optional. */\n        private boolean optionalArg;\n\n        /** Specifies whether this option is required to be present. */\n        private boolean required;\n\n        /** Specifies the version when this option was added.  May be null */\n        private String since;\n\n        /** The type of this Option. */\n        private Class<?> type = DEFAULT_TYPE;\n\n        /** The character that is the value separator. */\n        private char valueSeparator;\n\n        /**\n         * Constructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n         *\n         * @param option short representation of the option.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         */\n        private Builder(final String option) throws IllegalArgumentException {\n            option(option);\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}.\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set.\n         */\n        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n\n        /**\n         * Sets the converter for the option.\n         * <p>\n         * Note: See {@link TypeHandler} for serialization discussion.\n         * </p>\n         *\n         * @param converter the Converter to use.\n         * @return this builder, to allow method chaining.\n         * @since 1.7.0\n         */\n        public Builder converter(final Converter<?, ?> converter) {\n            this.converter = converter;\n            return this;\n        }\n\n        /**\n         * Marks this Option as deprecated.\n         *\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated() {\n            return deprecated(DeprecatedAttributes.DEFAULT);\n        }\n\n        /**\n         * Sets whether the Option is deprecated.\n         *\n         * @param deprecated specifies whether the Option is deprecated.\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated(final DeprecatedAttributes deprecated) {\n            this.deprecated = deprecated;\n            return this;\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg() {\n            return hasArg(true);\n        }\n\n        /**\n         * Tests whether the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option can have unlimited argument values.\n         *\n         * @return this builder.\n         */\n        public Builder hasArgs() {\n            argCount = UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOption the long name of the Option\n         * @return this builder.\n         */\n        public Builder longOpt(final String longOption) {\n            this.longOption = longOption;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param argCount the number of argument values\n         * @return this builder.\n         */\n        public Builder numberOfArgs(final int argCount) {\n            this.argCount = argCount;\n            return this;\n        }\n\n        /**\n         * Sets the name of the Option.\n         *\n         * @param option the name of the Option.\n         * @return this builder.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         * @since 1.5.0\n         */\n        public Builder option(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param optionalArg specifies whether the Option can have an optional argument.\n         * @return this builder.\n         */\n        public Builder optionalArg(final boolean optionalArg) {\n            if (optionalArg && argCount == UNINITIALIZED) {\n                argCount = 1;\n            }\n            this.optionalArg = optionalArg;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder.\n         */\n        public Builder required() {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is required.\n         *\n         * @param required specifies whether the Option is required.\n         * @return this builder.\n         */\n        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }\n\n        /** Sets the version number when this option was first defined.\"\n         *\n         * @param since the version number when this option was first defined.\n         * @return this builder.\n         */\n        public Builder since(final String since) {\n            this.since = since;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option.\n         * @return this builder.\n         */\n        public Builder type(final Class<?> type) {\n            this.type = toType(type);\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder.\n         */\n        public Builder valueSeparator() {\n            return valueSeparator(Char.EQUAL);\n        }\n\n        /**\n         * The Option will use {@code sep} as a means to separate argument values.\n         * <p>\n         * <b>Example:</b>\n         * </p>\n         *\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = { \"-Dkey=value\" };\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param valueSeparator The value separator.\n         * @return this builder.\n         */\n        public Builder valueSeparator(final char valueSeparator) {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }\n\n    }", "definition": "    public static final class Builder", "class_docstring": "\nBuilds {@code Option} instances using descriptive methods.\n<p>\nExample usage:\n</p>\n\n<pre>\nOption option = Option.builder(\"a\").required(true).longOpt(\"arg-name\").build();\n</pre>\n\n@since 1.3\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final Class<String> DEFAULT_TYPE = String.class;", "docstring": " The default type.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Class<String>", "name": "DEFAULT_TYPE = String.class", "syntax_pass": true}, {"attribute_expression": "private int argCount = UNINITIALIZED;", "docstring": " The number of argument values this option can have.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "argCount = UNINITIALIZED", "syntax_pass": true}, {"attribute_expression": "private String argName;", "docstring": " The name of the argument for this option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "argName", "syntax_pass": true}, {"attribute_expression": "private Converter<?, ?> converter;", "docstring": " The converter to convert to type. *", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Converter<?, ?>", "name": "converter", "syntax_pass": true}, {"attribute_expression": "private DeprecatedAttributes deprecated;", "docstring": " Specifies whether this option is deprecated.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DeprecatedAttributes", "name": "deprecated", "syntax_pass": true}, {"attribute_expression": "private String description;", "docstring": " Description of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private String longOption;", "docstring": " The long representation of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "longOption", "syntax_pass": true}, {"attribute_expression": "private String option;", "docstring": " The name of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "option", "syntax_pass": true}, {"attribute_expression": "private boolean optionalArg;", "docstring": " Specifies whether the argument value of this Option is optional.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "optionalArg", "syntax_pass": true}, {"attribute_expression": "private boolean required;", "docstring": " Specifies whether this option is required to be present.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "required", "syntax_pass": true}, {"attribute_expression": "private String since;", "docstring": " Specifies the version when this option was added.  May be null", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "since", "syntax_pass": true}, {"attribute_expression": "private Class<?> type = DEFAULT_TYPE;", "docstring": " The type of this Option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Class<?>", "name": "type = DEFAULT_TYPE", "syntax_pass": true}, {"attribute_expression": "private char valueSeparator;", "docstring": " The character that is the value separator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "char", "name": "valueSeparator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private static Class<?> toType(final Class<?> type) {\n            return type != null ? type : DEFAULT_TYPE;\n        }", "docstring": "\nReturns the input Class or the default type (String) if null.\n\n@param type the candidate Class.\n@return the input Class or the default type (String) if null.\n", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Class<?>", "classes": []}, "name": "toType", "params": [{"name": "type", "type": "Class<?>"}], "body": "                                                            {\n            return type != null ? type : DEFAULT_TYPE;\n        }", "signature": "private static Class<?> toType(final Class<?> type)"}, {"syntax_pass": true, "original_string": "        private Builder(final String option) throws IllegalArgumentException {\n            option(option);\n        }", "docstring": "\nConstructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n\n@param option short representation of the option.\n@throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Builder", "params": [{"name": "option", "type": "String"}], "body": "                                                                             {\n            option(option);\n        }", "signature": "private Builder(final String option)"}, {"syntax_pass": true, "original_string": "        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }", "docstring": "\nSets the display name for the argument value.\n\n@param argName the display name for the argument value.\n@return this builder, to allow method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "argName", "params": [{"name": "argName", "type": "String"}], "body": "                                                     {\n            this.argName = argName;\n            return this;\n        }", "signature": "public Builder argName(final String argName)"}, {"syntax_pass": true, "original_string": "        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }", "docstring": "\nConstructs an Option with the values declared by this {@link Builder}.\n\n@return the new {@link Option}.\n@throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Option", "classes": []}, "name": "build", "params": [], "body": "                              {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }", "signature": "public Option build()"}, {"syntax_pass": true, "original_string": "        public Builder converter(final Converter<?, ?> converter) {\n            this.converter = converter;\n            return this;\n        }", "docstring": "\nSets the converter for the option.\n<p>\nNote: See {@link TypeHandler} for serialization discussion.\n</p>\n\n@param converter the Converter to use.\n@return this builder, to allow method chaining.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "converter", "params": [{"name": "converter", "type": "Converter<?, ?>"}], "body": "                                                                  {\n            this.converter = converter;\n            return this;\n        }", "signature": "public Builder converter(final Converter<?, ?> converter)"}, {"syntax_pass": true, "original_string": "        public Builder deprecated() {\n            return deprecated(DeprecatedAttributes.DEFAULT);\n        }", "docstring": "\nMarks this Option as deprecated.\n\n@return this builder.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "deprecated", "params": [], "body": "                                    {\n            return deprecated(DeprecatedAttributes.DEFAULT);\n        }", "signature": "public Builder deprecated()"}, {"syntax_pass": true, "original_string": "        public Builder deprecated(final DeprecatedAttributes deprecated) {\n            this.deprecated = deprecated;\n            return this;\n        }", "docstring": "\nSets whether the Option is deprecated.\n\n@param deprecated specifies whether the Option is deprecated.\n@return this builder.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "deprecated", "params": [{"name": "deprecated", "type": "DeprecatedAttributes"}], "body": "                                                                         {\n            this.deprecated = deprecated;\n            return this;\n        }", "signature": "public Builder deprecated(final DeprecatedAttributes deprecated)"}, {"syntax_pass": true, "original_string": "        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }", "docstring": "\nSets the description for this option.\n\n@param description the description of the option.\n@return this builder, to allow method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "desc", "params": [{"name": "description", "type": "String"}], "body": "                                                      {\n            this.description = description;\n            return this;\n        }", "signature": "public Builder desc(final String description)"}, {"syntax_pass": true, "original_string": "        public Builder hasArg() {\n            return hasArg(true);\n        }", "docstring": "\nTests whether the Option will require an argument.\n\n@return this builder, to allow method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "hasArg", "params": [], "body": "                                {\n            return hasArg(true);\n        }", "signature": "public Builder hasArg()"}, {"syntax_pass": true, "original_string": "        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : UNINITIALIZED;\n            return this;\n        }", "docstring": "\nTests whether the Option has an argument or not.\n\n@param hasArg specifies whether the Option takes an argument or not.\n@return this builder, to allow method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "hasArg", "params": [{"name": "hasArg", "type": "boolean"}], "body": "                                                    {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : UNINITIALIZED;\n            return this;\n        }", "signature": "public Builder hasArg(final boolean hasArg)"}, {"syntax_pass": true, "original_string": "        public Builder hasArgs() {\n            argCount = UNLIMITED_VALUES;\n            return this;\n        }", "docstring": "\nTests whether the Option can have unlimited argument values.\n\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "hasArgs", "params": [], "body": "                                 {\n            argCount = UNLIMITED_VALUES;\n            return this;\n        }", "signature": "public Builder hasArgs()"}, {"syntax_pass": true, "original_string": "        public Builder longOpt(final String longOption) {\n            this.longOption = longOption;\n            return this;\n        }", "docstring": "\nSets the long name of the Option.\n\n@param longOption the long name of the Option\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "longOpt", "params": [{"name": "longOption", "type": "String"}], "body": "                                                        {\n            this.longOption = longOption;\n            return this;\n        }", "signature": "public Builder longOpt(final String longOption)"}, {"syntax_pass": true, "original_string": "        public Builder numberOfArgs(final int argCount) {\n            this.argCount = argCount;\n            return this;\n        }", "docstring": "\nSets the number of argument values the Option can take.\n\n@param argCount the number of argument values\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "numberOfArgs", "params": [{"name": "argCount", "type": "int"}], "body": "                                                        {\n            this.argCount = argCount;\n            return this;\n        }", "signature": "public Builder numberOfArgs(final int argCount)"}, {"syntax_pass": true, "original_string": "        public Builder option(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }", "docstring": "\nSets the name of the Option.\n\n@param option the name of the Option.\n@return this builder.\n@throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "option", "params": [{"name": "option", "type": "String"}], "body": "                                                                                   {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }", "signature": "public Builder option(final String option)"}, {"syntax_pass": true, "original_string": "        public Builder optionalArg(final boolean optionalArg) {\n            if (optionalArg && argCount == UNINITIALIZED) {\n                argCount = 1;\n            }\n            this.optionalArg = optionalArg;\n            return this;\n        }", "docstring": "\nSets whether the Option can have an optional argument.\n\n@param optionalArg specifies whether the Option can have an optional argument.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "optionalArg", "params": [{"name": "optionalArg", "type": "boolean"}], "body": "                                                              {\n            if (optionalArg && argCount == UNINITIALIZED) {\n                argCount = 1;\n            }\n            this.optionalArg = optionalArg;\n            return this;\n        }", "signature": "public Builder optionalArg(final boolean optionalArg)"}, {"syntax_pass": true, "original_string": "        public Builder required() {\n            return required(true);\n        }", "docstring": "\nMarks this Option as required.\n\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "required", "params": [], "body": "                                  {\n            return required(true);\n        }", "signature": "public Builder required()"}, {"syntax_pass": true, "original_string": "        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }", "docstring": "\nSets whether the Option is required.\n\n@param required specifies whether the Option is required.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "required", "params": [{"name": "required", "type": "boolean"}], "body": "                                                        {\n            this.required = required;\n            return this;\n        }", "signature": "public Builder required(final boolean required)"}, {"syntax_pass": true, "original_string": "        public Builder since(final String since) {\n            this.since = since;\n            return this;\n        }", "docstring": " Sets the version number when this option was first defined.\"\n\n@param since the version number when this option was first defined.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "since", "params": [{"name": "since", "type": "String"}], "body": "                                                 {\n            this.since = since;\n            return this;\n        }", "signature": "public Builder since(final String since)"}, {"syntax_pass": true, "original_string": "        public Builder type(final Class<?> type) {\n            this.type = toType(type);\n            return this;\n        }", "docstring": "\nSets the type of the Option.\n\n@param type the type of the Option.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "type", "params": [{"name": "type", "type": "Class<?>"}], "body": "                                                 {\n            this.type = toType(type);\n            return this;\n        }", "signature": "public Builder type(final Class<?> type)"}, {"syntax_pass": true, "original_string": "        public Builder valueSeparator() {\n            return valueSeparator(Char.EQUAL);\n        }", "docstring": "\nThe Option will use '=' as a means to separate argument value.\n\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "valueSeparator", "params": [], "body": "                                        {\n            return valueSeparator(Char.EQUAL);\n        }", "signature": "public Builder valueSeparator()"}, {"syntax_pass": true, "original_string": "        public Builder valueSeparator(final char valueSeparator) {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }", "docstring": "\nThe Option will use {@code sep} as a means to separate argument values.\n<p>\n<b>Example:</b>\n</p>\n\n<pre>\nOption opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\nOptions options = new Options();\noptions.addOption(opt);\nString[] args = { \"-Dkey=value\" };\nCommandLineParser parser = new DefaultParser();\nCommandLine line = parser.parse(options, args);\nString propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\nString propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n</pre>\n\n@param valueSeparator The value separator.\n@return this builder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "valueSeparator", "params": [{"name": "valueSeparator", "type": "char"}], "body": "                                                                 {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }", "signature": "public Builder valueSeparator(final char valueSeparator)"}]}], "class_docstring": "\nDescribes a single command-line option. It maintains information regarding the short-name of the option, the long-name, if any exists, a flag indicating if\nan argument is required for this option, and a self-documenting description of the option.\n<p>\nAn Option is not created independently, but is created through an instance of {@link Options}. An Option is required to have at least a short or a long-name.\n</p>\n<p>\n<b>Note:</b> once an {@link Option} has been added to an instance of {@link Options}, its required flag cannot be changed.\n</p>\n\n@see org.apache.commons.cli.Options\n@see org.apache.commons.cli.CommandLine\n", "original_string": "public class Option implements Cloneable, Serializable {\n\n    /**\n     * Builds {@code Option} instances using descriptive methods.\n     * <p>\n     * Example usage:\n     * </p>\n     *\n     * <pre>\n     * Option option = Option.builder(\"a\").required(true).longOpt(\"arg-name\").build();\n     * </pre>\n     *\n     * @since 1.3\n     */\n    public static final class Builder {\n\n        /** The default type. */\n        private static final Class<String> DEFAULT_TYPE = String.class;\n\n        /**\n         * Returns the input Class or the default type (String) if null.\n         *\n         * @param type the candidate Class.\n         * @return the input Class or the default type (String) if null.\n         */\n        private static Class<?> toType(final Class<?> type) {\n            return type != null ? type : DEFAULT_TYPE;\n        }\n\n        /** The number of argument values this option can have. */\n        private int argCount = UNINITIALIZED;\n\n        /** The name of the argument for this option. */\n        private String argName;\n\n        /** The converter to convert to type. **/\n        private Converter<?, ?> converter;\n\n        /** Specifies whether this option is deprecated. */\n        private DeprecatedAttributes deprecated;\n\n        /** Description of the option. */\n        private String description;\n\n        /** The long representation of the option. */\n        private String longOption;\n\n        /** The name of the option. */\n        private String option;\n\n        /** Specifies whether the argument value of this Option is optional. */\n        private boolean optionalArg;\n\n        /** Specifies whether this option is required to be present. */\n        private boolean required;\n\n        /** Specifies the version when this option was added.  May be null */\n        private String since;\n\n        /** The type of this Option. */\n        private Class<?> type = DEFAULT_TYPE;\n\n        /** The character that is the value separator. */\n        private char valueSeparator;\n\n        /**\n         * Constructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.\n         *\n         * @param option short representation of the option.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         */\n        private Builder(final String option) throws IllegalArgumentException {\n            option(option);\n        }\n\n        /**\n         * Sets the display name for the argument value.\n         *\n         * @param argName the display name for the argument value.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder argName(final String argName) {\n            this.argName = argName;\n            return this;\n        }\n\n        /**\n         * Constructs an Option with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link Option}.\n         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set.\n         */\n        public Option build() {\n            if (option == null && longOption == null) {\n                throw new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n            }\n            return new Option(this);\n        }\n\n        /**\n         * Sets the converter for the option.\n         * <p>\n         * Note: See {@link TypeHandler} for serialization discussion.\n         * </p>\n         *\n         * @param converter the Converter to use.\n         * @return this builder, to allow method chaining.\n         * @since 1.7.0\n         */\n        public Builder converter(final Converter<?, ?> converter) {\n            this.converter = converter;\n            return this;\n        }\n\n        /**\n         * Marks this Option as deprecated.\n         *\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated() {\n            return deprecated(DeprecatedAttributes.DEFAULT);\n        }\n\n        /**\n         * Sets whether the Option is deprecated.\n         *\n         * @param deprecated specifies whether the Option is deprecated.\n         * @return this builder.\n         * @since 1.7.0\n         */\n        public Builder deprecated(final DeprecatedAttributes deprecated) {\n            this.deprecated = deprecated;\n            return this;\n        }\n\n        /**\n         * Sets the description for this option.\n         *\n         * @param description the description of the option.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder desc(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option will require an argument.\n         *\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg() {\n            return hasArg(true);\n        }\n\n        /**\n         * Tests whether the Option has an argument or not.\n         *\n         * @param hasArg specifies whether the Option takes an argument or not.\n         * @return this builder, to allow method chaining.\n         */\n        public Builder hasArg(final boolean hasArg) {\n            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\n            argCount = hasArg ? 1 : UNINITIALIZED;\n            return this;\n        }\n\n        /**\n         * Tests whether the Option can have unlimited argument values.\n         *\n         * @return this builder.\n         */\n        public Builder hasArgs() {\n            argCount = UNLIMITED_VALUES;\n            return this;\n        }\n\n        /**\n         * Sets the long name of the Option.\n         *\n         * @param longOption the long name of the Option\n         * @return this builder.\n         */\n        public Builder longOpt(final String longOption) {\n            this.longOption = longOption;\n            return this;\n        }\n\n        /**\n         * Sets the number of argument values the Option can take.\n         *\n         * @param argCount the number of argument values\n         * @return this builder.\n         */\n        public Builder numberOfArgs(final int argCount) {\n            this.argCount = argCount;\n            return this;\n        }\n\n        /**\n         * Sets the name of the Option.\n         *\n         * @param option the name of the Option.\n         * @return this builder.\n         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n         * @since 1.5.0\n         */\n        public Builder option(final String option) throws IllegalArgumentException {\n            this.option = OptionValidator.validate(option);\n            return this;\n        }\n\n        /**\n         * Sets whether the Option can have an optional argument.\n         *\n         * @param optionalArg specifies whether the Option can have an optional argument.\n         * @return this builder.\n         */\n        public Builder optionalArg(final boolean optionalArg) {\n            if (optionalArg && argCount == UNINITIALIZED) {\n                argCount = 1;\n            }\n            this.optionalArg = optionalArg;\n            return this;\n        }\n\n        /**\n         * Marks this Option as required.\n         *\n         * @return this builder.\n         */\n        public Builder required() {\n            return required(true);\n        }\n\n        /**\n         * Sets whether the Option is required.\n         *\n         * @param required specifies whether the Option is required.\n         * @return this builder.\n         */\n        public Builder required(final boolean required) {\n            this.required = required;\n            return this;\n        }\n\n        /** Sets the version number when this option was first defined.\"\n         *\n         * @param since the version number when this option was first defined.\n         * @return this builder.\n         */\n        public Builder since(final String since) {\n            this.since = since;\n            return this;\n        }\n\n        /**\n         * Sets the type of the Option.\n         *\n         * @param type the type of the Option.\n         * @return this builder.\n         */\n        public Builder type(final Class<?> type) {\n            this.type = toType(type);\n            return this;\n        }\n\n        /**\n         * The Option will use '=' as a means to separate argument value.\n         *\n         * @return this builder.\n         */\n        public Builder valueSeparator() {\n            return valueSeparator(Char.EQUAL);\n        }\n\n        /**\n         * The Option will use {@code sep} as a means to separate argument values.\n         * <p>\n         * <b>Example:</b>\n         * </p>\n         *\n         * <pre>\n         * Option opt = Option.builder(\"D\").hasArgs().valueSeparator('=').build();\n         * Options options = new Options();\n         * options.addOption(opt);\n         * String[] args = { \"-Dkey=value\" };\n         * CommandLineParser parser = new DefaultParser();\n         * CommandLine line = parser.parse(options, args);\n         * String propertyName = line.getOptionValues(\"D\")[0]; // will be \"key\"\n         * String propertyValue = line.getOptionValues(\"D\")[1]; // will be \"value\"\n         * </pre>\n         *\n         * @param valueSeparator The value separator.\n         * @return this builder.\n         */\n        public Builder valueSeparator(final char valueSeparator) {\n            this.valueSeparator = valueSeparator;\n            return this;\n        }\n\n    }\n\n    /** Empty array. */\n    static final Option[] EMPTY_ARRAY = {};\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** Specifies the number of argument values has not been specified. */\n    public static final int UNINITIALIZED = -1;\n\n    /** Specifies the number of argument values is infinite. */\n    public static final int UNLIMITED_VALUES = -2;\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @return a new {@link Builder} instance.\n     * @since 1.3\n     */\n    public static Builder builder() {\n        return builder(null);\n    }\n\n    /**\n     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.\n     *\n     * @param option short representation of the option.\n     * @return a new {@link Builder} instance.\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     * @since 1.3\n     */\n    public static Builder builder(final String option) {\n        return new Builder(option);\n    }\n\n    /** The number of argument values this option can have. */\n    private int argCount = UNINITIALIZED;\n\n    /** The name of the argument for this option. */\n    private String argName;\n\n    /** The explicit converter for this option. May be null. */\n    private transient Converter<?, ?> converter;\n\n    /**\n     * Specifies whether this option is deprecated, may be null.\n     * <p>\n     * If you want to serialize this field, use a serialization proxy.\n     * </p>\n     */\n    private final transient DeprecatedAttributes deprecated;\n\n    /** Description of the option. */\n    private String description;\n\n    /** The long representation of the option. */\n    private String longOption;\n\n    /** The name of the option. */\n    private final String option;\n\n    /** Specifies whether the argument value of this Option is optional. */\n    private boolean optionalArg;\n\n    /** Specifies whether this option is required to be present. */\n    private boolean required;\n\n    /** Specifies the version when this option was added.  May be null */\n    private String since;\n\n    /** The type of this Option. */\n    private Class<?> type = String.class;\n\n    /** The list of argument values. **/\n    private List<String> values = new ArrayList<>();\n\n    /** The character that is the value separator. */\n    private char valueSeparator;\n\n    /**\n     * Private constructor used by the nested Builder class.\n     *\n     * @param builder builder used to create this option.\n     */\n    private Option(final Builder builder) {\n        this.argName = builder.argName;\n        this.description = builder.description;\n        this.longOption = builder.longOption;\n        this.argCount = builder.argCount;\n        this.option = builder.option;\n        this.optionalArg = builder.optionalArg;\n        this.deprecated = builder.deprecated;\n        this.required = builder.required;\n        this.since = builder.since;\n        this.type = builder.type;\n        this.valueSeparator = builder.valueSeparator;\n        this.converter = builder.converter;\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option      short representation of the option.\n     * @param hasArg      specifies whether the Option takes an argument or not.\n     * @param description describes the function of the option.\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final boolean hasArg, final String description) throws IllegalArgumentException {\n        this(option, null, hasArg, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters. The option does not take an argument.\n     *\n     * @param option      short representation of the option.\n     * @param description describes the function of the option.\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String description) throws IllegalArgumentException {\n        this(option, null, false, description);\n    }\n\n    /**\n     * Creates an Option using the specified parameters.\n     *\n     * @param option      short representation of the option.\n     * @param longOption  the long representation of the option.\n     * @param hasArg      specifies whether the Option takes an argument or not.\n     * @param description describes the function of the option.\n     *\n     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.\n     */\n    public Option(final String option, final String longOption, final boolean hasArg, final String description) throws IllegalArgumentException {\n        // ensure that the option is valid\n        this.deprecated = null;\n        this.option = OptionValidator.validate(option);\n        this.longOption = longOption;\n        // if hasArg is set then the number of arguments is 1\n        if (hasArg) {\n            this.argCount = 1;\n        }\n        this.description = description;\n    }\n\n    /**\n     * Tests whether the option can accept more arguments.\n     *\n     * @return false if the maximum number of arguments is reached.\n     * @since 1.3\n     */\n    boolean acceptsArg() {\n        return (hasArg() || hasArgs() || hasOptionalArg()) && (argCount <= 0 || values.size() < argCount);\n    }\n\n    /**\n     * Adds the value to this Option. If the number of arguments is greater than zero and there is enough space in the list then add the value. Otherwise, throw\n     * a runtime exception.\n     *\n     * @param value The value to be added to this Option.\n     */\n    private void add(final String value) {\n        if (!acceptsArg()) {\n            throw new IllegalArgumentException(\"Cannot add value, list full.\");\n        }\n        // store value\n        values.add(value);\n    }\n\n    /**\n     * This method is not intended to be used. It was a piece of internal API that was made public in 1.0. It currently throws an UnsupportedOperationException.\n     *\n     * @param value the value to add.\n     * @return always throws an {@link UnsupportedOperationException}.\n     * @throws UnsupportedOperationException always.\n     * @deprecated Unused.\n     */\n    @Deprecated\n    public boolean addValue(final String value) {\n        throw new UnsupportedOperationException(\n                \"The addValue method is not intended for client use. Subclasses should use the processValue method instead.\");\n    }\n\n    /**\n     * Clears the Option values. After a parse is complete, these are left with data in them and they need clearing if another parse is done.\n     *\n     * See: <a href=\"https://issues.apache.org/jira/browse/CLI-71\">CLI-71</a>\n     */\n    void clearValues() {\n        values.clear();\n    }\n\n    /**\n     * A rather odd clone method - due to incorrect code in 1.0 it is public and in 1.1 rather than throwing a CloneNotSupportedException it throws a\n     * RuntimeException so as to maintain backwards compatible at the API level.\n     *\n     * After calling this method, it is very likely you will want to call clearValues().\n     *\n     * @return a clone of this Option instance.\n     * @throws RuntimeException if a {@link CloneNotSupportedException} has been thrown by {@code super.clone()}.\n     */\n    @Override\n    public Object clone() {\n        try {\n            final Option option = (Option) super.clone();\n            option.values = new ArrayList<>(values);\n            return option;\n        } catch (final CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Option)) {\n            return false;\n        }\n        final Option other = (Option) obj;\n        return Objects.equals(longOption, other.longOption) && Objects.equals(option, other.option);\n    }\n\n    /**\n     * Gets the display name for the argument value.\n     *\n     * @return the display name for the argument value.\n     */\n    public String getArgName() {\n        return argName;\n    }\n\n    /**\n     * Gets the number of argument values this Option can take.\n     *\n     * <p>\n     * A value equal to the constant {@link #UNINITIALIZED} (= -1) indicates the number of arguments has not been specified. A value equal to the constant\n     * {@link #UNLIMITED_VALUES} (= -2) indicates that this options takes an unlimited amount of values.\n     * </p>\n     *\n     * @return num the number of argument values.\n     * @see #UNINITIALIZED\n     * @see #UNLIMITED_VALUES\n     */\n    public int getArgs() {\n        return argCount;\n    }\n\n    /**\n     * Gets the value to type converter.\n     *\n     * @return the value to type converter.\n     * @since 1.7.0\n     */\n    public Converter<?, ?> getConverter() {\n        return converter == null ? TypeHandler.getDefault().getConverter(type) : converter;\n    }\n\n    /**\n     * Gets deprecated attributes if any.\n     *\n     * @return boolean deprecated attributes or null.\n     * @since 1.7.0\n     */\n    public DeprecatedAttributes getDeprecated() {\n        return deprecated;\n    }\n\n    /**\n     * Gets the self-documenting description of this Option.\n     *\n     * @return The string description of this option.\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets the id of this Option. This is only set when the Option shortOpt is a single character. This is used for switch statements.\n     *\n     * @return the id of this Option.\n     */\n    public int getId() {\n        return getKey().charAt(0);\n    }\n\n    /**\n     * Gets the 'unique' Option identifier. This is the option value if set or the long value if the options value is not set.\n     *\n     * @return the 'unique' Option identifier.\n     * @since 1.7.0\n     */\n    public String getKey() {\n        // if 'opt' is null, then it is a 'long' option\n        return option == null ? longOption : option;\n    }\n\n    /**\n     * Gets the long name of this Option.\n     *\n     * @return Long name of this option, or null, if there is no long name.\n     */\n    public String getLongOpt() {\n        return longOption;\n    }\n\n    /**\n     * Gets the name of this Option.\n     *\n     * It is this String which can be used with {@link CommandLine#hasOption(String opt)} and {@link CommandLine#getOptionValue(String opt)} to check for\n     * existence and argument.\n     *\n     * @return The name of this option.\n     */\n    public String getOpt() {\n        return option;\n    }\n\n    /**\n     * Gets the version when this option was added.\n     * @return the version when this option was added, or {@code null} if not set.\n     */\n    public String getSince() {\n        return since;\n    }\n\n\n    /**\n     * Gets the type of this Option.\n     *\n     * @return The type of this option.\n     */\n    public Object getType() {\n        return type;\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @return the value/first value of this Option or {@code null} if there is no value.\n     */\n    public String getValue() {\n        return hasNoValues() ? null : values.get(0);\n    }\n\n    /**\n     * Gets the specified value of this Option or {@code null} if there is no value.\n     *\n     * @param index The index of the value to be returned.\n     *\n     * @return the specified value of this Option or {@code null} if there is no value.\n     *\n     * @throws IndexOutOfBoundsException if index is less than 1 or greater than the number of the values for this Option.\n     */\n    public String getValue(final int index) throws IndexOutOfBoundsException {\n        return hasNoValues() ? null : values.get(index);\n    }\n\n    /**\n     * Gets the value/first value of this Option or the {@code defaultValue} if there is no value.\n     *\n     * @param defaultValue The value to be returned if there is no value.\n     *\n     * @return the value/first value of this Option or the {@code defaultValue} if there are no values.\n     */\n    public String getValue(final String defaultValue) {\n        final String value = getValue();\n        return value != null ? value : defaultValue;\n    }\n\n    /**\n     * Gets the values of this Option as a String array or null if there are no values.\n     *\n     * @return the values of this Option as a String array or null if there are no values.\n     */\n    public String[] getValues() {\n        return hasNoValues() ? null : values.toArray(EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the value separator character.\n     *\n     * @return the value separator character.\n     */\n    public char getValueSeparator() {\n        return valueSeparator;\n    }\n\n    /**\n     * Gets the values of this Option as a List or null if there are no values.\n     *\n     * @return the values of this Option as a List or null if there are no values.\n     */\n    public List<String> getValuesList() {\n        return values;\n    }\n\n    /**\n     * Tests whether this Option requires an argument.\n     *\n     * @return boolean flag indicating if an argument is required.\n     */\n    public boolean hasArg() {\n        return argCount > 0 || argCount == UNLIMITED_VALUES;\n    }\n\n    /**\n     * Tests whether the display name for the argument value has been set.\n     *\n     * @return if the display name for the argument value has been set.\n     */\n    public boolean hasArgName() {\n        return argName != null && !argName.isEmpty();\n    }\n\n    /**\n     * Tests whether this Option can take many values.\n     *\n     * @return boolean flag indicating if multiple values are allowed.\n     */\n    public boolean hasArgs() {\n        return argCount > 1 || argCount == UNLIMITED_VALUES;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(longOption, option);\n    }\n\n    /**\n     * Tests whether this Option has a long name.\n     *\n     * @return boolean flag indicating existence of a long name.\n     */\n    public boolean hasLongOpt() {\n        return longOption != null;\n    }\n\n    /**\n     * Tests whether this Option has any values.\n     *\n     * @return whether this Option has any values.\n     */\n    private boolean hasNoValues() {\n        return values.isEmpty();\n    }\n\n    /**\n     * Tests whether this Option can have an optional argument.\n     *\n     * @return whether this Option can have an optional argument.\n     */\n    public boolean hasOptionalArg() {\n        return optionalArg;\n    }\n\n    /**\n     * Tests whether this Option has specified a value separator.\n     *\n     * @return whether this Option has specified a value separator.\n     * @since 1.1\n     */\n    public boolean hasValueSeparator() {\n        return valueSeparator > 0;\n    }\n\n    /**\n     * Tests whether this Option is deprecated.\n     *\n     * @return boolean flag indicating whether this Option is deprecated.\n     * @since 1.7.0\n     */\n    public boolean isDeprecated() {\n        return deprecated != null;\n    }\n\n    /**\n     * Tests whether this Option is required.\n     *\n     * @return boolean flag indicating whether this Option is required.\n     */\n    public boolean isRequired() {\n        return required;\n    }\n\n    /**\n     * Processes the value. If this Option has a value separator the value will have to be parsed into individual tokens. When n-1 tokens have been processed\n     * and there are more value separators in the value, parsing is ceased and the remaining characters are added as a single token.\n     *\n     * @param value The String to be processed.\n     */\n    void processValue(final String value) {\n        if (argCount == UNINITIALIZED) {\n            throw new IllegalArgumentException(\"NO_ARGS_ALLOWED\");\n        }\n        String add = value;\n        // this Option has a separator character\n        if (hasValueSeparator()) {\n            // get the separator character\n            final char sep = getValueSeparator();\n            // store the index for the value separator\n            int index = add.indexOf(sep);\n            // while there are more value separators\n            while (index != -1) {\n                // next value to be added\n                if (values.size() == argCount - 1) {\n                    break;\n                }\n                // store\n                add(add.substring(0, index));\n                // parse\n                add = add.substring(index + 1);\n                // get new index\n                index = add.indexOf(sep);\n            }\n        }\n        // store the actual value or the last value that has been parsed\n        add(add);\n    }\n\n    /**\n     * Tests whether the option requires more arguments to be valid.\n     *\n     * @return false if the option doesn't require more arguments.\n     */\n    boolean requiresArg() {\n        if (optionalArg) {\n            return false;\n        }\n        if (argCount == UNLIMITED_VALUES) {\n            return values.isEmpty();\n        }\n        return acceptsArg();\n    }\n\n    /**\n     * Sets the display name for the argument value.\n     *\n     * @param argName the display name for the argument value.\n     */\n    public void setArgName(final String argName) {\n        this.argName = argName;\n    }\n\n    /**\n     * Sets the number of argument values this Option can take.\n     *\n     * @param num the number of argument values.\n     */\n    public void setArgs(final int num) {\n        this.argCount = num;\n    }\n\n    /**\n     * Sets the value to type converter.\n     *\n     * @param converter The converter to convert the string value to the type.\n     * @since 1.7.0\n     */\n    public void setConverter(final Converter<?, ?> converter) {\n        this.converter = converter;\n    }\n\n    /**\n     * Sets the self-documenting description of this Option.\n     *\n     * @param description The description of this option.\n     * @since 1.1\n     */\n    public void setDescription(final String description) {\n        this.description = description;\n    }\n\n    /**\n     * Sets the long name of this Option.\n     *\n     * @param longOpt the long name of this Option.\n     */\n    public void setLongOpt(final String longOpt) {\n        this.longOption = longOpt;\n    }\n\n    /**\n     * Sets whether this Option can have an optional argument.\n     *\n     * @param optionalArg specifies whether the Option can have an optional argument.\n     */\n    public void setOptionalArg(final boolean optionalArg) {\n        this.optionalArg = optionalArg;\n    }\n\n    /**\n     * Sets whether this Option is mandatory.\n     *\n     * @param required specifies whether this Option is mandatory.\n     */\n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n\n    /**\n     * Sets the type of this Option.\n     *\n     * @param type the type of this Option.\n     * @since 1.3\n     */\n    public void setType(final Class<?> type) {\n        this.type = Builder.toType(type);\n    }\n\n    /**\n     * Sets the type of this Option.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class} object.\n     * </p>\n     *\n     * @param type the type of this Option.\n     * @deprecated since 1.3, use {@link #setType(Class)} instead.\n     */\n    @Deprecated\n    public void setType(final Object type) {\n        setType((Class<?>) type);\n    }\n\n    /**\n     * Sets the value separator. For example if the argument value was a Java property, the value separator would be '='.\n     *\n     * @param valueSeparator The value separator.\n     */\n    public void setValueSeparator(final char valueSeparator) {\n        this.valueSeparator = valueSeparator;\n    }\n\n    String toDeprecatedString() {\n        if (!isDeprecated()) {\n            return \"\";\n        }\n        // @formatter:off\n        final StringBuilder buf = new StringBuilder()\n                .append(\"Option '\")\n                .append(option)\n                .append(Char.APOS);\n        // @formatter:on\n        if (longOption != null) {\n            buf.append(Char.APOS).append(longOption).append(Char.APOS);\n        }\n        buf.append(\": \").append(deprecated);\n        return buf.toString();\n    }\n\n    /**\n     * Creates a String suitable for debugging.\n     *\n     * @return a String suitable for debugging.\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder().append(\"[ \");\n        buf.append(\"Option \");\n        buf.append(option);\n        if (longOption != null) {\n            buf.append(Char.SP).append(longOption);\n        }\n        if (isDeprecated()) {\n            buf.append(Char.SP);\n            buf.append(deprecated.toString());\n        }\n        if (hasArgs()) {\n            buf.append(\"[ARG...]\");\n        } else if (hasArg()) {\n            buf.append(\" [ARG]\");\n        }\n        // @formatter:off\n        return buf.append(\" :: \")\n            .append(description)\n            .append(\" :: \")\n            .append(type)\n            .append(\" ]\")\n            .toString();\n        // @formatter:on\n    }\n}", "super_interfaces": ["Cloneable", "Serializable"], "fields": [{"attribute_expression": "static final Option[] EMPTY_ARRAY = {};", "docstring": " Empty array.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Option[]", "name": "EMPTY_ARRAY = {}", "syntax_pass": true}, {"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "public static final int UNINITIALIZED = -1;", "docstring": " Specifies the number of argument values has not been specified.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "UNINITIALIZED = -1", "syntax_pass": true}, {"attribute_expression": "public static final int UNLIMITED_VALUES = -2;", "docstring": " Specifies the number of argument values is infinite.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "UNLIMITED_VALUES = -2", "syntax_pass": true}, {"attribute_expression": "private int argCount = UNINITIALIZED;", "docstring": " The number of argument values this option can have.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "argCount = UNINITIALIZED", "syntax_pass": true}, {"attribute_expression": "private String argName;", "docstring": " The name of the argument for this option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "argName", "syntax_pass": true}, {"attribute_expression": "private transient Converter<?, ?> converter;", "docstring": " The explicit converter for this option. May be null.", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Converter<?, ?>", "name": "converter", "syntax_pass": true}, {"attribute_expression": "private final transient DeprecatedAttributes deprecated;", "docstring": "\nSpecifies whether this option is deprecated, may be null.\n<p>\nIf you want to serialize this field, use a serialization proxy.\n</p>\n", "modifiers": "private final transient", "marker_annotations": [], "non_marker_annotations": ["private", "final", "transient"], "comments": [], "type": "DeprecatedAttributes", "name": "deprecated", "syntax_pass": true}, {"attribute_expression": "private String description;", "docstring": " Description of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private String longOption;", "docstring": " The long representation of the option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "longOption", "syntax_pass": true}, {"attribute_expression": "private final String option;", "docstring": " The name of the option.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "option", "syntax_pass": true}, {"attribute_expression": "private boolean optionalArg;", "docstring": " Specifies whether the argument value of this Option is optional.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "optionalArg", "syntax_pass": true}, {"attribute_expression": "private boolean required;", "docstring": " Specifies whether this option is required to be present.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "required", "syntax_pass": true}, {"attribute_expression": "private String since;", "docstring": " Specifies the version when this option was added.  May be null", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "since", "syntax_pass": true}, {"attribute_expression": "private Class<?> type = String.class;", "docstring": " The type of this Option.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Class<?>", "name": "type = String.class", "syntax_pass": true}, {"attribute_expression": "private List<String> values = new ArrayList<>();", "docstring": " The list of argument values. *", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "values = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private char valueSeparator;", "docstring": " The character that is the value separator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "char", "name": "valueSeparator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/MissingArgumentException.java.MissingArgumentException", "name": "MissingArgumentException", "file_path": "src/main/java/org/apache/commons/cli/MissingArgumentException.java", "superclasses": "ParseException", "methods": ["[]MissingArgumentException(Option)", "[]MissingArgumentException(String)", "[Option]getOption()"], "method_uris": ["src/main/java/org/apache/commons/cli/MissingArgumentException.java.MissingArgumentException.[]MissingArgumentException(Option)", "src/main/java/org/apache/commons/cli/MissingArgumentException.java.MissingArgumentException.[]MissingArgumentException(String)", "src/main/java/org/apache/commons/cli/MissingArgumentException.java.MissingArgumentException.[Option]getOption()"], "overrides": null, "attributes": [], "class_docstring": "\nThrown when an option requiring an argument is not provided with an argument.\n", "original_string": "public class MissingArgumentException extends ParseException {\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = -7098538588704965017L;\n\n    /** The option requiring additional arguments */\n    private Option option;\n\n    /**\n     * Constructs a new {@code MissingArgumentException} with the specified detail message.\n     *\n     * @param option the option requiring an argument\n     * @since 1.2\n     */\n    public MissingArgumentException(final Option option) {\n        this(\"Missing argument for option: \" + option.getKey());\n        this.option = option;\n    }\n\n    /**\n     * Constructs a new {@code MissingArgumentException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public MissingArgumentException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Gets the option requiring an argument that wasn't provided on the command line.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public Option getOption() {\n        return option;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7098538588704965017L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7098538588704965017L", "syntax_pass": true}, {"attribute_expression": "private Option option;", "docstring": " The option requiring additional arguments", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "option", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/Util.java.Util", "name": "Util", "file_path": "src/main/java/org/apache/commons/cli/Util.java", "superclasses": "", "methods": ["[boolean]isEmpty(Object[])", "[boolean]isEmpty(String)", "[String]stripLeadingAndTrailingQuotes(String)", "[String]stripLeadingHyphens(String)", "[]Util()"], "method_uris": ["src/main/java/org/apache/commons/cli/Util.java.Util.[boolean]isEmpty(Object[])", "src/main/java/org/apache/commons/cli/Util.java.Util.[boolean]isEmpty(String)", "src/main/java/org/apache/commons/cli/Util.java.Util.[String]stripLeadingAndTrailingQuotes(String)", "src/main/java/org/apache/commons/cli/Util.java.Util.[String]stripLeadingHyphens(String)", "src/main/java/org/apache/commons/cli/Util.java.Util.[]Util()"], "overrides": null, "attributes": [], "class_docstring": "\nContains useful helper methods for classes within this package.\n", "original_string": "final class Util {\n\n    /**\n     * An empty immutable {@code String} array.\n     */\n    static final String[] EMPTY_STRING_ARRAY = {};\n\n    /**\n     * Tests whether the given array is null or empty.\n     *\n     * @param array the array to test.\n     * @return the given array is null or empty.\n     */\n    static boolean isEmpty(final Object[] array) {\n        return array == null || array.length == 0;\n    }\n\n    /**\n     * Tests whether the given string is null or empty.\n     *\n     * @param str The string to test.\n     * @return Whether the given string is null or empty.\n     */\n    static boolean isEmpty(final String str) {\n        return str == null || str.isEmpty();\n    }\n\n    /**\n     * Removes the leading and trailing quotes from {@code str}. E.g. if str is '\"one two\"', then 'one two' is returned.\n     *\n     * @param str The string from which the leading and trailing quotes should be removed.\n     * @return The string without the leading and trailing quotes.\n     */\n    static String stripLeadingAndTrailingQuotes(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        final int length = str.length();\n        if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1) {\n            return str.substring(1, length - 1);\n        }\n        return str;\n    }\n\n    /**\n     * Removes the hyphens from the beginning of {@code str} and return the new String.\n     *\n     * @param str The string from which the hyphens should be removed.\n     * @return the new String.\n     */\n    static String stripLeadingHyphens(final String str) {\n        if (isEmpty(str)) {\n            return str;\n        }\n        if (str.startsWith(\"--\")) {\n            return str.substring(2);\n        }\n        if (str.startsWith(\"-\")) {\n            return str.substring(1);\n        }\n        return str;\n    }\n\n    private Util() {\n        // no instances\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final String[] EMPTY_STRING_ARRAY = {};", "docstring": "\nAn empty immutable {@code String} array.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "String[]", "name": "EMPTY_STRING_ARRAY = {}", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/BasicParser.java.BasicParser", "name": "BasicParser", "file_path": "src/main/java/org/apache/commons/cli/BasicParser.java", "superclasses": "Parser", "methods": ["[String[]]flatten(Options,String[],boolean)"], "method_uris": ["src/main/java/org/apache/commons/cli/BasicParser.java.BasicParser.[String[]]flatten(Options,String[],boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nThe class BasicParser provides a very simple implementation of the {@link Parser#flatten(Options,String[],boolean)\nflatten} method.\n\n@deprecated since 1.3, use the {@link DefaultParser} instead\n", "original_string": "@Deprecated\npublic class BasicParser extends Parser {\n    /**\n     * <p>\n     * A simple implementation of {@link Parser}'s abstract {@link Parser#flatten(Options, String[], boolean) flatten}\n     * method.\n     * </p>\n     *\n     * <p>\n     * <b>Note:</b> {@code options} and {@code stopAtNonOption} are not used in this {@code flatten} method.\n     * </p>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.\n     * @return The {@code arguments} String array.\n     */\n    @Override\n    protected String[] flatten(@SuppressWarnings(\"unused\") final Options options, final String[] arguments,\n        @SuppressWarnings(\"unused\") final boolean stopAtNonOption) {\n        // just echo the arguments\n        return arguments;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup", "name": "OptionGroup", "file_path": "src/main/java/org/apache/commons/cli/OptionGroup.java", "superclasses": "", "methods": ["[OptionGroup]addOption(Option)", "[Collection<String>]getNames()", "[Collection<Option>]getOptions()", "[String]getSelected()", "[boolean]isRequired()", "[boolean]isSelected()", "[void]setRequired(boolean)", "[void]setSelected(Option)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup.[OptionGroup]addOption(Option)", "src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup.[Collection<String>]getNames()", "src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup.[Collection<Option>]getOptions()", "src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup.[String]getSelected()", "src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup.[boolean]isRequired()", "src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup.[boolean]isSelected()", "src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup.[void]setRequired(boolean)", "src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup.[void]setSelected(Option)", "src/main/java/org/apache/commons/cli/OptionGroup.java.OptionGroup.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nA group of mutually exclusive options.\n", "original_string": "public class OptionGroup implements Serializable {\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** Hold the options */\n    private final Map<String, Option> optionMap = new LinkedHashMap<>();\n\n    /** The name of the selected option */\n    private String selected;\n\n    /** Specified whether this group is required */\n    private boolean required;\n\n    /**\n     * Adds the given {@code Option} to this group.\n     *\n     * @param option the option to add to this group\n     * @return this option group with the option added\n     */\n    public OptionGroup addOption(final Option option) {\n        // key - option name\n        // value - the option\n        optionMap.put(option.getKey(), option);\n        return this;\n    }\n\n    /**\n     * Gets the names of the options in this group as a {@code Collection}.\n     *\n     * @return the names of the options in this group as a {@code Collection}.\n     */\n    public Collection<String> getNames() {\n        // the key set is the collection of names\n        return optionMap.keySet();\n    }\n\n    /**\n     * Gets the options in this group as a {@code Collection}.\n     *\n     * @return the options in this group as a {@code Collection}.\n     */\n    public Collection<Option> getOptions() {\n        // the values are the collection of options\n        return optionMap.values();\n    }\n\n    /**\n     * Gets the selected option name.\n     *\n     * If the selected option is deprecated <em>no warning is logged</em>.\n     * @return the selected option name.\n     */\n    public String getSelected() {\n        return selected;\n    }\n\n    /**\n     * Tests whether this option group is required.\n     *\n     * @return whether this option group is required\n     */\n    public boolean isRequired() {\n        return required;\n    }\n\n    /**\n     * Tests whether an option is selected.\n     *\n     *  If an option is selected and is deprecated <em>no warning is logged</em>.\n     * @return whether whether an option is selected.\n     * @since 1.9.0\n     */\n    public boolean isSelected() {\n        return selected != null;\n    }\n\n    /**\n     * Sets whether this group is required.\n     *\n     * @param required whether this group is required.\n     */\n    public void setRequired(final boolean required) {\n        this.required = required;\n    }\n\n    /**\n     * Sets the selected option of this group to {@code name}.\n     *\n     * If the selected option is deprecated <em>no warning is logged</em>.\n     * @param option the option that is selected\n     * @throws AlreadySelectedException if an option from this group has already been selected.\n     */\n    public void setSelected(final Option option) throws AlreadySelectedException {\n        if (option == null) {\n            // reset the option previously selected\n            selected = null;\n            return;\n        }\n        // if no option has already been selected or the\n        // same option is being reselected then set the\n        // selected member variable\n        if (selected != null && !selected.equals(option.getKey())) {\n            throw new AlreadySelectedException(this, option);\n        }\n        selected = option.getKey();\n    }\n\n    /**\n     * Returns the stringified version of this OptionGroup.\n     *\n     * @return the stringified representation of this group\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buff = new StringBuilder();\n        final Iterator<Option> iter = getOptions().iterator();\n        buff.append(\"[\");\n        while (iter.hasNext()) {\n            final Option option = iter.next();\n            if (option.getOpt() != null) {\n                buff.append(\"-\");\n                buff.append(option.getOpt());\n            } else {\n                buff.append(\"--\");\n                buff.append(option.getLongOpt());\n            }\n\n            if (option.getDescription() != null) {\n                buff.append(Char.SP);\n                buff.append(option.getDescription());\n            }\n\n            if (iter.hasNext()) {\n                buff.append(\", \");\n            }\n        }\n        buff.append(\"]\");\n        return buff.toString();\n    }\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Option> optionMap = new LinkedHashMap<>();", "docstring": " Hold the options", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Option>", "name": "optionMap = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private String selected;", "docstring": " The name of the selected option", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "selected", "syntax_pass": true}, {"attribute_expression": "private boolean required;", "docstring": " Specified whether this group is required", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "required", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/AlreadySelectedException.java.AlreadySelectedException", "name": "AlreadySelectedException", "file_path": "src/main/java/org/apache/commons/cli/AlreadySelectedException.java", "superclasses": "ParseException", "methods": ["[]AlreadySelectedException(OptionGroup,Option)", "[]AlreadySelectedException(String)", "[]AlreadySelectedException(String,OptionGroup,Option)", "[Option]getOption()", "[OptionGroup]getOptionGroup()"], "method_uris": ["src/main/java/org/apache/commons/cli/AlreadySelectedException.java.AlreadySelectedException.[]AlreadySelectedException(OptionGroup,Option)", "src/main/java/org/apache/commons/cli/AlreadySelectedException.java.AlreadySelectedException.[]AlreadySelectedException(String)", "src/main/java/org/apache/commons/cli/AlreadySelectedException.java.AlreadySelectedException.[]AlreadySelectedException(String,OptionGroup,Option)", "src/main/java/org/apache/commons/cli/AlreadySelectedException.java.AlreadySelectedException.[Option]getOption()", "src/main/java/org/apache/commons/cli/AlreadySelectedException.java.AlreadySelectedException.[OptionGroup]getOptionGroup()"], "overrides": null, "attributes": [], "class_docstring": "\nThrown when more than one option in an option group has been provided.\n", "original_string": "public class AlreadySelectedException extends ParseException {\n\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 3674381532418544760L;\n\n    /** The option group selected. */\n    private final OptionGroup group;\n\n    /** The option that triggered the exception. */\n    private final Option option;\n\n    /**\n     * Constructs a new {@code AlreadySelectedException} for the specified option group.\n     *\n     * @param group the option group already selected\n     * @param option the option that triggered the exception\n     * @since 1.2\n     */\n    public AlreadySelectedException(final OptionGroup group, final Option option) {\n        this(String.format(\"The option '%s' was specified but an option from this group has already been selected: '%s'\", option.getKey(), group.getSelected()),\n                group, option);\n    }\n\n    /**\n     * Constructs a new {@code AlreadySelectedException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public AlreadySelectedException(final String message) {\n        this(message, null, null);\n    }\n\n    private AlreadySelectedException(final String message, final OptionGroup group, final Option option) {\n        super(message);\n        this.group = group;\n        this.option = option;\n    }\n\n    /**\n     * Gets the option that was added to the group and triggered the exception.\n     *\n     * @return the related option\n     * @since 1.2\n     */\n    public Option getOption() {\n        return option;\n    }\n\n    /**\n     * Gets the option group where another option has been selected.\n     *\n     * @return the related option group\n     * @since 1.2\n     */\n    public OptionGroup getOptionGroup() {\n        return group;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3674381532418544760L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3674381532418544760L", "syntax_pass": true}, {"attribute_expression": "private final OptionGroup group;", "docstring": " The option group selected.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OptionGroup", "name": "group", "syntax_pass": true}, {"attribute_expression": "private final Option option;", "docstring": " The option that triggered the exception.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Option", "name": "option", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser", "name": "DefaultParser", "file_path": "src/main/java/org/apache/commons/cli/DefaultParser.java", "superclasses": "", "methods": ["[Builder]builder()", "[int]indexOfEqual(String)", "[]DefaultParser()", "[]DefaultParser(boolean)", "[]DefaultParser(boolean,Boolean,Consumer<Option>)", "[void]checkRequiredArgs()", "[void]checkRequiredOptions()", "[String]getLongPrefix(String)", "[List<String>]getMatchingLongOptions(String)", "[void]handleConcatenatedOptions(String)", "[void]handleLongOption(String)", "[void]handleLongOptionWithEqual(String)", "[void]handleLongOptionWithoutEqual(String)", "[void]handleOption(Option)", "[void]handleProperties(Properties)", "[void]handleShortAndLongOption(String)", "[void]handleToken(String)", "[void]handleUnknownToken(String)", "[boolean]isArgument(String)", "[boolean]isJavaProperty(String)", "[boolean]isLongOption(String)", "[boolean]isNegativeNumber(String)", "[boolean]isOption(String)", "[boolean]isShortOption(String)", "[CommandLine]parse(Options,String[])", "[CommandLine]parse(Options,String[],boolean)", "[CommandLine]parse(Options,String[],Properties)", "[CommandLine]parse(Options,String[],Properties,boolean)", "[String]stripLeadingAndTrailingQuotesDefaultOff(String)", "[String]stripLeadingAndTrailingQuotesDefaultOn(String)", "[void]updateRequiredOptions(Option)"], "method_uris": ["src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[Builder]builder()", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[int]indexOfEqual(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[]DefaultParser()", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[]DefaultParser(boolean)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[]DefaultParser(boolean,Boolean,Consumer<Option>)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]checkRequiredArgs()", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]checkRequiredOptions()", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[String]getLongPrefix(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[List<String>]getMatchingLongOptions(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]handleConcatenatedOptions(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]handleLongOption(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]handleLongOptionWithEqual(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]handleLongOptionWithoutEqual(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]handleOption(Option)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]handleProperties(Properties)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]handleShortAndLongOption(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]handleToken(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]handleUnknownToken(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[boolean]isArgument(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[boolean]isJavaProperty(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[boolean]isLongOption(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[boolean]isNegativeNumber(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[boolean]isOption(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[boolean]isShortOption(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[CommandLine]parse(Options,String[])", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[CommandLine]parse(Options,String[],boolean)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[CommandLine]parse(Options,String[],Properties)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[CommandLine]parse(Options,String[],Properties,boolean)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[String]stripLeadingAndTrailingQuotesDefaultOff(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[String]stripLeadingAndTrailingQuotesDefaultOn(String)", "src/main/java/org/apache/commons/cli/DefaultParser.java.DefaultParser.[void]updateRequiredOptions(Option)"], "overrides": null, "attributes": [{"original_string": "    public static final class Builder {\n\n        /** Flag indicating if partial matching of long options is supported. */\n        private boolean allowPartialMatching = true;\n\n        /**\n         * The deprecated option handler.\n         * <p>\n         * If you want to serialize this field, use a serialization proxy.\n         * </p>\n         */\n        private Consumer<Option> deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n\n        /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments. */\n        private Boolean stripLeadingAndTrailingQuotes;\n\n        /**\n         * Constructs a new {@code Builder} for a {@code DefaultParser} instance.\n         *\n         * Both allowPartialMatching and stripLeadingAndTrailingQuotes are true by default,\n         * mimicking the argument-less constructor.\n         */\n        private Builder() {\n        }\n\n        /**\n         * Builds an DefaultParser with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link DefaultParser}\n         * @since 1.5.0\n         */\n        public DefaultParser build() {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes, deprecatedHandler);\n        }\n\n        /**\n         * Sets if partial matching of long options is supported.\n         *\n         * By \"partial matching\" we mean that given the following code:\n         *\n         * <pre>\n         * {\n         *     &#64;code\n         *     final Options options = new Options();\n         *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n         *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n         *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n         * }\n         * </pre>\n         *\n         * If \"partial matching\" is turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n         * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n         *\n         * @param allowPartialMatching whether to allow partial matching of long options\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setAllowPartialMatching(final boolean allowPartialMatching) {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n\n        /**\n         * Sets if balanced leading and trailing double quotes should be stripped from option arguments.\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is true,\n         * the outermost balanced double quotes of option arguments values will be removed.\n         * For example, {@code -o '\"x\"'} getValue() will return {@code x}, instead of {@code \"x\"}\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is null,\n         * then quotes will be stripped from option values separated by space from the option, but\n         * kept in other cases, which is the historic behavior.\n         *\n         * @param stripLeadingAndTrailingQuotes whether balanced leading and trailing double quotes should be stripped from option arguments.\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes) {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }\n    }", "definition": "    public static final class Builder", "class_docstring": "\nA nested builder class to create {@code DefaultParser} instances\nusing descriptive methods.\n\nExample usage:\n<pre>\nDefaultParser parser = Option.builder()\n    .setAllowPartialMatching(false)\n    .setStripLeadingAndTrailingQuotes(false)\n    .build();\n</pre>\n\n@since 1.5.0\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private boolean allowPartialMatching = true;", "docstring": " Flag indicating if partial matching of long options is supported.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "allowPartialMatching = true", "syntax_pass": true}, {"attribute_expression": "private Consumer<Option> deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;", "docstring": "\nThe deprecated option handler.\n<p>\nIf you want to serialize this field, use a serialization proxy.\n</p>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Consumer<Option>", "name": "deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER", "syntax_pass": true}, {"attribute_expression": "private Boolean stripLeadingAndTrailingQuotes;", "docstring": " Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Boolean", "name": "stripLeadingAndTrailingQuotes", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Builder() {\n        }", "docstring": "\nConstructs a new {@code Builder} for a {@code DefaultParser} instance.\n\nBoth allowPartialMatching and stripLeadingAndTrailingQuotes are true by default,\nmimicking the argument-less constructor.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Builder", "params": [], "body": "                          {\n        }", "signature": "private Builder()"}, {"syntax_pass": true, "original_string": "        public DefaultParser build() {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes, deprecatedHandler);\n        }", "docstring": "\nBuilds an DefaultParser with the values declared by this {@link Builder}.\n\n@return the new {@link DefaultParser}\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DefaultParser", "classes": []}, "name": "build", "params": [], "body": "                                     {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes, deprecatedHandler);\n        }", "signature": "public DefaultParser build()"}, {"syntax_pass": true, "original_string": "        public Builder setAllowPartialMatching(final boolean allowPartialMatching) {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }", "docstring": "\nSets if partial matching of long options is supported.\n\nBy \"partial matching\" we mean that given the following code:\n\n<pre>\n{\n    &#64;code\n    final Options options = new Options();\n    options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n    options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n    options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n}\n</pre>\n\nIf \"partial matching\" is turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n\"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n\n@param allowPartialMatching whether to allow partial matching of long options\n@return this builder, to allow method chaining\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setAllowPartialMatching", "params": [{"name": "allowPartialMatching", "type": "boolean"}], "body": "                                                                                   {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }", "signature": "public Builder setAllowPartialMatching(final boolean allowPartialMatching)"}, {"syntax_pass": true, "original_string": "        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }", "docstring": "\nSets the deprecated option handler.\n\n@param deprecatedHandler the deprecated option handler.\n@return {@code this} instance.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setDeprecatedHandler", "params": [{"name": "deprecatedHandler", "type": "Consumer<Option>"}], "body": "                                                                                      {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }", "signature": "public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler)"}, {"syntax_pass": true, "original_string": "        public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes) {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }", "docstring": "\nSets if balanced leading and trailing double quotes should be stripped from option arguments.\n\nIf \"stripping of balanced leading and trailing double quotes from option arguments\" is true,\nthe outermost balanced double quotes of option arguments values will be removed.\nFor example, {@code -o '\"x\"'} getValue() will return {@code x}, instead of {@code \"x\"}\n\nIf \"stripping of balanced leading and trailing double quotes from option arguments\" is null,\nthen quotes will be stripped from option values separated by space from the option, but\nkept in other cases, which is the historic behavior.\n\n@param stripLeadingAndTrailingQuotes whether balanced leading and trailing double quotes should be stripped from option arguments.\n@return this builder, to allow method chaining\n@since 1.5.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setStripLeadingAndTrailingQuotes", "params": [{"name": "stripLeadingAndTrailingQuotes", "type": "Boolean"}], "body": "                                                                                                     {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }", "signature": "public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes)"}]}], "class_docstring": "\nDefault parser.\n\n@since 1.3\n", "original_string": "public class DefaultParser implements CommandLineParser {\n\n    /**\n     * A nested builder class to create {@code DefaultParser} instances\n     * using descriptive methods.\n     *\n     * Example usage:\n     * <pre>\n     * DefaultParser parser = Option.builder()\n     *     .setAllowPartialMatching(false)\n     *     .setStripLeadingAndTrailingQuotes(false)\n     *     .build();\n     * </pre>\n     *\n     * @since 1.5.0\n     */\n    public static final class Builder {\n\n        /** Flag indicating if partial matching of long options is supported. */\n        private boolean allowPartialMatching = true;\n\n        /**\n         * The deprecated option handler.\n         * <p>\n         * If you want to serialize this field, use a serialization proxy.\n         * </p>\n         */\n        private Consumer<Option> deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n\n        /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments. */\n        private Boolean stripLeadingAndTrailingQuotes;\n\n        /**\n         * Constructs a new {@code Builder} for a {@code DefaultParser} instance.\n         *\n         * Both allowPartialMatching and stripLeadingAndTrailingQuotes are true by default,\n         * mimicking the argument-less constructor.\n         */\n        private Builder() {\n        }\n\n        /**\n         * Builds an DefaultParser with the values declared by this {@link Builder}.\n         *\n         * @return the new {@link DefaultParser}\n         * @since 1.5.0\n         */\n        public DefaultParser build() {\n            return new DefaultParser(allowPartialMatching, stripLeadingAndTrailingQuotes, deprecatedHandler);\n        }\n\n        /**\n         * Sets if partial matching of long options is supported.\n         *\n         * By \"partial matching\" we mean that given the following code:\n         *\n         * <pre>\n         * {\n         *     &#64;code\n         *     final Options options = new Options();\n         *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n         *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n         *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n         * }\n         * </pre>\n         *\n         * If \"partial matching\" is turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n         * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n         *\n         * @param allowPartialMatching whether to allow partial matching of long options\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setAllowPartialMatching(final boolean allowPartialMatching) {\n            this.allowPartialMatching = allowPartialMatching;\n            return this;\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n\n        /**\n         * Sets if balanced leading and trailing double quotes should be stripped from option arguments.\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is true,\n         * the outermost balanced double quotes of option arguments values will be removed.\n         * For example, {@code -o '\"x\"'} getValue() will return {@code x}, instead of {@code \"x\"}\n         *\n         * If \"stripping of balanced leading and trailing double quotes from option arguments\" is null,\n         * then quotes will be stripped from option values separated by space from the option, but\n         * kept in other cases, which is the historic behavior.\n         *\n         * @param stripLeadingAndTrailingQuotes whether balanced leading and trailing double quotes should be stripped from option arguments.\n         * @return this builder, to allow method chaining\n         * @since 1.5.0\n         */\n        public Builder setStripLeadingAndTrailingQuotes(final Boolean stripLeadingAndTrailingQuotes) {\n            this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n            return this;\n        }\n    }\n\n    /**\n     * Creates a new {@link Builder} to create an {@link DefaultParser} using descriptive\n     * methods.\n     *\n     * @return a new {@link Builder} instance\n     * @since 1.5.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    static int indexOfEqual(final String token) {\n        return token.indexOf(Char.EQUAL);\n    }\n\n    /** The command-line instance. */\n    protected CommandLine cmd;\n\n    /** The current options. */\n    protected Options options;\n\n    /**\n     * Flag indicating how unrecognized tokens are handled. {@code true} to stop the parsing and add the remaining\n     * tokens to the args list. {@code false} to throw an exception.\n     */\n    protected boolean stopAtNonOption;\n\n    /** The token currently processed. */\n    protected String currentToken;\n\n    /** The last option parsed. */\n    protected Option currentOption;\n\n    /** Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line. */\n    protected boolean skipParsing;\n\n    /** The required options and groups expected to be found when parsing the command line. */\n    protected List expectedOpts;\n\n    /** Flag indicating if partial matching of long options is supported. */\n    private final boolean allowPartialMatching;\n\n    /** Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments.\n     * null represents the historic arbitrary behavior */\n    private final Boolean stripLeadingAndTrailingQuotes;\n\n    /**\n     * The deprecated option handler.\n     * <p>\n     * If you want to serialize this field, use a serialization proxy.\n     * </p>\n     */\n    private final Consumer<Option> deprecatedHandler;\n\n    /**\n     * Creates a new DefaultParser instance with partial matching enabled.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     */\n    public DefaultParser() {\n        this.allowPartialMatching = true;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }\n\n    /**\n     * Create a new DefaultParser instance with the specified partial matching policy.\n     *\n     * By \"partial matching\" we mean that given the following code:\n     *\n     * <pre>\n     * {\n     *     &#64;code\n     *     final Options options = new Options();\n     *     options.addOption(new Option(\"d\", \"debug\", false, \"Turn on debug.\"));\n     *     options.addOption(new Option(\"e\", \"extract\", false, \"Turn on extract.\"));\n     *     options.addOption(new Option(\"o\", \"option\", true, \"Turn on option with argument.\"));\n     * }\n     * </pre>\n     *\n     * with \"partial matching\" turned on, {@code -de} only matches the {@code \"debug\"} option. However, with\n     * \"partial matching\" disabled, {@code -de} would enable both {@code debug} as well as {@code extract}\n     * options.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     */\n    public DefaultParser(final boolean allowPartialMatching) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = null;\n        this.deprecatedHandler = CommandLine.Builder.DEPRECATED_HANDLER;\n    }\n\n    /**\n     * Creates a new DefaultParser instance with the specified partial matching and quote\n     * stripping policy.\n     *\n     * @param allowPartialMatching if partial matching of long options shall be enabled\n     * @param stripLeadingAndTrailingQuotes if balanced outer double quoutes should be stripped\n     */\n    private DefaultParser(final boolean allowPartialMatching, final Boolean stripLeadingAndTrailingQuotes, final Consumer<Option> deprecatedHandler) {\n        this.allowPartialMatching = allowPartialMatching;\n        this.stripLeadingAndTrailingQuotes = stripLeadingAndTrailingQuotes;\n        this.deprecatedHandler = deprecatedHandler;\n    }\n\n    /**\n     * Throws a {@link MissingArgumentException} if the current option didn't receive the number of arguments expected.\n     */\n    private void checkRequiredArgs() throws ParseException {\n        if (currentOption != null && currentOption.requiresArg()) {\n            if (isJavaProperty(currentOption.getKey()) && currentOption.getValuesList().size() == 1) {\n                return;\n            }\n            throw new MissingArgumentException(currentOption);\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!expectedOpts.isEmpty()) {\n            throw new MissingOptionException(expectedOpts);\n        }\n    }\n\n    /**\n     * Searches for a prefix that is the long name of an option (-Xmx512m)\n     *\n     * @param token\n     */\n    private String getLongPrefix(final String token) {\n        final String t = Util.stripLeadingHyphens(token);\n        int i;\n        String opt = null;\n        for (i = t.length() - 2; i > 1; i--) {\n            final String prefix = t.substring(0, i);\n            if (options.hasLongOption(prefix)) {\n                opt = prefix;\n                break;\n            }\n        }\n        return opt;\n    }\n\n    /**\n     * Gets a list of matching option strings for the given token, depending on the selected partial matching policy.\n     *\n     * @param token the token (may contain leading dashes)\n     * @return the list of matching option strings or an empty list if no matching option could be found\n     */\n    private List<String> getMatchingLongOptions(final String token) {\n        if (allowPartialMatching) {\n            return options.getMatchingOptions(token);\n        }\n        final List<String> matches = new ArrayList<>(1);\n        if (options.hasLongOption(token)) {\n            matches.add(options.getOption(token).getLongOpt());\n        }\n        return matches;\n    }\n\n    /**\n     * Breaks {@code token} into its constituent parts using the following algorithm.\n     *\n     * <ul>\n     * <li>ignore the first character (\"<b>-</b>\")</li>\n     * <li>for each remaining character check if an {@link Option} exists with that id.</li>\n     * <li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\n     * tokens.</li>\n     * <li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\n     * remaining characters as a token to the list of processed tokens.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\n     * special token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\n     * processed tokens list.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\n     * that character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b> at the first non-Option encountered.\n     * @throws ParseException if there are any problems encountered while parsing the command line token.\n     */\n    protected void handleConcatenatedOptions(final String token) throws ParseException {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n            if (!options.hasOption(ch)) {\n                handleUnknownToken(stopAtNonOption && i > 1 ? token.substring(i) : token);\n                break;\n            }\n            handleOption(options.getOption(ch));\n            if (currentOption != null && token.length() != i + 1) {\n                // add the trail as an argument of the option\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(i + 1)));\n                break;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L --L=V --L V --l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOption(final String token) throws ParseException {\n        if (indexOfEqual(token) == -1) {\n            handleLongOptionWithoutEqual(token);\n        } else {\n            handleLongOptionWithEqual(token);\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L=V -L=V --l=V -l=V\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithEqual(final String token) throws ParseException {\n        final int pos = indexOfEqual(token);\n        final String value = token.substring(pos + 1);\n        final String opt = token.substring(0, pos);\n        final List<String> matchingOpts = getMatchingLongOptions(opt);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(opt)) {\n            throw new AmbiguousOptionException(opt, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(opt) ? opt : matchingOpts.get(0);\n            final Option option = options.getOption(key);\n            if (option.acceptsArg()) {\n                handleOption(option);\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                currentOption = null;\n            } else {\n                handleUnknownToken(currentToken);\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * --L -L --l -l\n     *\n     * @param token the command line token to handle\n     */\n    private void handleLongOptionWithoutEqual(final String token) throws ParseException {\n        final List<String> matchingOpts = getMatchingLongOptions(token);\n        if (matchingOpts.isEmpty()) {\n            handleUnknownToken(currentToken);\n        } else if (matchingOpts.size() > 1 && !options.hasLongOption(token)) {\n            throw new AmbiguousOptionException(token, matchingOpts);\n        } else {\n            final String key = options.hasLongOption(token) ? token : matchingOpts.get(0);\n            handleOption(options.getOption(key));\n        }\n    }\n\n    private void handleOption(final Option option) throws ParseException {\n        // check the previous option before handling the next one\n        checkRequiredArgs();\n        final Option copy = (Option) option.clone();\n        updateRequiredOptions(copy);\n        cmd.addOption(copy);\n        currentOption = copy.hasArg() ? copy : null;\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     */\n    private void handleProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties\n                final String value = properties.getProperty(option);\n\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        opt.processValue(stripLeadingAndTrailingQuotesDefaultOff(value));\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the option to the CommandLine\n                    continue;\n                }\n                handleOption(opt);\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Handles the following tokens:\n     *\n     * -S -SV -S V -S=V -S1S2 -S1S2 V -SV1=V2\n     *\n     * -L -LV -L V -L=V -l\n     *\n     * @param hyphenToken the command line token to handle\n     */\n    private void handleShortAndLongOption(final String hyphenToken) throws ParseException {\n        final String token = Util.stripLeadingHyphens(hyphenToken);\n        final int pos = indexOfEqual(token);\n        if (token.length() == 1) {\n            // -S\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else {\n                handleUnknownToken(hyphenToken);\n            }\n        } else if (pos == -1) {\n            // no equal sign found (-xxx)\n            if (options.hasShortOption(token)) {\n                handleOption(options.getOption(token));\n            } else if (!getMatchingLongOptions(token).isEmpty()) {\n                // -L or -l\n                handleLongOptionWithoutEqual(hyphenToken);\n            } else {\n                // look for a long prefix (-Xmx512m)\n                final String opt = getLongPrefix(token);\n\n                if (opt != null && options.getOption(opt).acceptsArg()) {\n                    handleOption(options.getOption(opt));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(opt.length())));\n                    currentOption = null;\n                } else if (isJavaProperty(token)) {\n                    // -SV1 (-Dflag)\n                    handleOption(options.getOption(token.substring(0, 1)));\n                    currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOff(token.substring(1)));\n                    currentOption = null;\n                } else {\n                    // -S1S2S3 or -S1S2V\n                    handleConcatenatedOptions(hyphenToken);\n                }\n            }\n        } else {\n            // equal sign found (-xxx=yyy)\n            final String opt = token.substring(0, pos);\n            final String value = token.substring(pos + 1);\n\n            if (opt.length() == 1) {\n                // -S=V\n                final Option option = options.getOption(opt);\n                if (option != null && option.acceptsArg()) {\n                    handleOption(option);\n                    currentOption.processValue(value);\n                    currentOption = null;\n                } else {\n                    handleUnknownToken(hyphenToken);\n                }\n            } else if (isJavaProperty(opt)) {\n                // -SV1=V2 (-Dkey=value)\n                handleOption(options.getOption(opt.substring(0, 1)));\n                currentOption.processValue(opt.substring(1));\n                currentOption.processValue(value);\n                currentOption = null;\n            } else {\n                // -L=V or -l=V\n                handleLongOptionWithEqual(hyphenToken);\n            }\n        }\n    }\n\n    /**\n     * Handles any command line token.\n     *\n     * @param token the command line token to handle\n     * @throws ParseException\n     */\n    private void handleToken(final String token) throws ParseException {\n        if (token != null) {\n            currentToken = token;\n            if (skipParsing) {\n                cmd.addArg(token);\n            } else if (\"--\".equals(token)) {\n                skipParsing = true;\n            } else if (currentOption != null && currentOption.acceptsArg() && isArgument(token)) {\n                currentOption.processValue(stripLeadingAndTrailingQuotesDefaultOn(token));\n            } else if (token.startsWith(\"--\")) {\n                handleLongOption(token);\n            } else if (token.startsWith(\"-\") && !\"-\".equals(token)) {\n                handleShortAndLongOption(token);\n            } else {\n                handleUnknownToken(token);\n            }\n            if (currentOption != null && !currentOption.acceptsArg()) {\n                currentOption = null;\n            }\n        }\n    }\n\n    /**\n     * Handles an unknown token. If the token starts with a dash an UnrecognizedOptionException is thrown. Otherwise the\n     * token is added to the arguments of the command line. If the stopAtNonOption flag is set, this stops the parsing and\n     * the remaining tokens are added as-is in the arguments of the command line.\n     *\n     * @param token the command line token to handle\n     */\n    private void handleUnknownToken(final String token) throws ParseException {\n        if (token.startsWith(\"-\") && token.length() > 1 && !stopAtNonOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + token, token);\n        }\n        cmd.addArg(token);\n        if (stopAtNonOption) {\n            skipParsing = true;\n        }\n    }\n\n    /**\n     * Tests if the token is a valid argument.\n     *\n     * @param token\n     */\n    private boolean isArgument(final String token) {\n        return !isOption(token) || isNegativeNumber(token);\n    }\n\n    /**\n     * Tests if the specified token is a Java-like property (-Dkey=value).\n     */\n    private boolean isJavaProperty(final String token) {\n        final String opt = token.isEmpty() ? null : token.substring(0, 1);\n        final Option option = options.getOption(opt);\n        return option != null && (option.getArgs() >= 2 || option.getArgs() == Option.UNLIMITED_VALUES);\n    }\n\n    /**\n     * Tests if the token looks like a long option.\n     *\n     * @param token\n     */\n    private boolean isLongOption(final String token) {\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        final int pos = indexOfEqual(token);\n        final String t = pos == -1 ? token : token.substring(0, pos);\n        if (!getMatchingLongOptions(t).isEmpty()) {\n            // long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\n            return true;\n        }\n        if (getLongPrefix(token) != null && !token.startsWith(\"--\")) {\n            // -LV\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Tests if the token is a negative number.\n     *\n     * @param token\n     */\n    private boolean isNegativeNumber(final String token) {\n        try {\n            Double.parseDouble(token);\n            return true;\n        } catch (final NumberFormatException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests if the token looks like an option.\n     *\n     * @param token\n     */\n    private boolean isOption(final String token) {\n        return isLongOption(token) || isShortOption(token);\n    }\n\n    /**\n     * Tests if the token looks like a short option.\n     *\n     * @param token\n     */\n    private boolean isShortOption(final String token) {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (token == null || !token.startsWith(\"-\") || token.length() == 1) {\n            return false;\n        }\n        // remove leading \"-\" and \"=value\"\n        final int pos = indexOfEqual(token);\n        final String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        if (options.hasShortOption(optName)) {\n            return true;\n        }\n        // check for several concatenated short options\n        return !optName.isEmpty() && options.hasShortOption(String.valueOf(optName.charAt(0)));\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null);\n    }\n\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     *\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parses the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     *\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n        throws ParseException {\n        this.options = options;\n        this.stopAtNonOption = stopAtNonOption;\n        skipParsing = false;\n        currentOption = null;\n        expectedOpts = new ArrayList<>(options.getRequiredOptions());\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        cmd = CommandLine.builder().setDeprecatedHandler(deprecatedHandler).build();\n        if (arguments != null) {\n            for (final String argument : arguments) {\n                handleToken(argument);\n            }\n        }\n        // check the arguments of the last option\n        checkRequiredArgs();\n        // add the default options\n        handleProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }\n\n    /**\n     * Strips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n     * If stripLeadingAndTrailingQuotes is null, then do not strip\n     *\n     * @param token a string\n     * @return token with the quotes stripped (if set)\n     */\n    private String stripLeadingAndTrailingQuotesDefaultOff(final String token) {\n        if (stripLeadingAndTrailingQuotes != null && stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }\n\n    /**\n     * Strips balanced leading and trailing quotes if the stripLeadingAndTrailingQuotes is set\n     * If stripLeadingAndTrailingQuotes is null, then do not strip\n     *\n     * @param token a string\n     * @return token with the quotes stripped (if set)\n     */\n    private String stripLeadingAndTrailingQuotesDefaultOn(final String token) {\n        if (stripLeadingAndTrailingQuotes == null || stripLeadingAndTrailingQuotes) {\n            return Util.stripLeadingAndTrailingQuotes(token);\n        }\n        return token;\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param option\n     */\n    private void updateRequiredOptions(final Option option) throws AlreadySelectedException {\n        if (option.isRequired()) {\n            expectedOpts.remove(option.getKey());\n        }\n\n        // if the option is in an OptionGroup make that option the selected option of the group\n        if (options.getOptionGroup(option) != null) {\n            final OptionGroup group = options.getOptionGroup(option);\n\n            if (group.isRequired()) {\n                expectedOpts.remove(group);\n            }\n\n            group.setSelected(option);\n        }\n    }\n}", "super_interfaces": ["CommandLineParser"], "fields": [{"attribute_expression": "protected CommandLine cmd;", "docstring": " The command-line instance.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "CommandLine", "name": "cmd", "syntax_pass": true}, {"attribute_expression": "protected Options options;", "docstring": " The current options.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "protected boolean stopAtNonOption;", "docstring": "\nFlag indicating how unrecognized tokens are handled. {@code true} to stop the parsing and add the remaining\ntokens to the args list. {@code false} to throw an exception.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "stopAtNonOption", "syntax_pass": true}, {"attribute_expression": "protected String currentToken;", "docstring": " The token currently processed.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "currentToken", "syntax_pass": true}, {"attribute_expression": "protected Option currentOption;", "docstring": " The last option parsed.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Option", "name": "currentOption", "syntax_pass": true}, {"attribute_expression": "protected boolean skipParsing;", "docstring": " Flag indicating if tokens should no longer be analyzed and simply added as arguments of the command line.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "skipParsing", "syntax_pass": true}, {"attribute_expression": "protected List expectedOpts;", "docstring": " The required options and groups expected to be found when parsing the command line.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List", "name": "expectedOpts", "syntax_pass": true}, {"attribute_expression": "private final boolean allowPartialMatching;", "docstring": " Flag indicating if partial matching of long options is supported.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "allowPartialMatching", "syntax_pass": true}, {"attribute_expression": "private final Boolean stripLeadingAndTrailingQuotes;", "docstring": " Flag indicating if balanced leading and trailing double quotes should be stripped from option arguments.\nnull represents the historic arbitrary behavior", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Boolean", "name": "stripLeadingAndTrailingQuotes", "syntax_pass": true}, {"attribute_expression": "private final Consumer<Option> deprecatedHandler;", "docstring": "\nThe deprecated option handler.\n<p>\nIf you want to serialize this field, use a serialization proxy.\n</p>\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Consumer<Option>", "name": "deprecatedHandler", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/ParseException.java.ParseException", "name": "ParseException", "file_path": "src/main/java/org/apache/commons/cli/ParseException.java", "superclasses": "Exception", "methods": ["[ParseException]wrap(Throwable)", "[]ParseException(String)", "[]ParseException(Throwable)"], "method_uris": ["src/main/java/org/apache/commons/cli/ParseException.java.ParseException.[ParseException]wrap(Throwable)", "src/main/java/org/apache/commons/cli/ParseException.java.ParseException.[]ParseException(String)", "src/main/java/org/apache/commons/cli/ParseException.java.ParseException.[]ParseException(Throwable)"], "overrides": null, "attributes": [], "class_docstring": "\nBase for Exceptions thrown during parsing of a command-line.\n", "original_string": "public class ParseException extends Exception {\n\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 9112808380089253192L;\n\n    /**\n     * Converts any exception except {@code UnsupportedOperationException} to a {@code ParseException}.\n     * if {@code e} is an instance of {@code ParseException} it is returned, otherwise a {@code ParseException} is\n     * created that wraps it.\n     * <p>\n     * Note: {@code UnsupportedOperationException} are not wrapped.  This is to solve a legacy expected exception problem and will be\n     * removed in the future.</p>\n     * @param e the exception to convert.\n     * @return the ParseException.\n     * @throws UnsupportedOperationException due to legacy expectations.  Will be removed in the future.\n     * @since 1.7.0\n     */\n    public static ParseException wrap(final Throwable e) throws UnsupportedOperationException {\n        if (e instanceof UnsupportedOperationException) {\n            throw (UnsupportedOperationException) e;\n        }\n\n        if (e instanceof ParseException) {\n            return (ParseException) e;\n        }\n        return new ParseException(e);\n    }\n\n    /**\n     * Constructs a new {@code ParseException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public ParseException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Constructs a new {@code ParseException} wrapping the specified exception.\n     *\n     * @param e the Exception to wrap.\n     */\n    public ParseException(final Throwable e) {\n        super(e);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 9112808380089253192L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 9112808380089253192L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/OptionValidator.java.OptionValidator", "name": "OptionValidator", "file_path": "src/main/java/org/apache/commons/cli/OptionValidator.java", "superclasses": "", "methods": ["[boolean]isValidChar(char)", "[boolean]isValidOpt(char)", "[boolean]search(char[],char)", "[String]validate(String)"], "method_uris": ["src/main/java/org/apache/commons/cli/OptionValidator.java.OptionValidator.[boolean]isValidChar(char)", "src/main/java/org/apache/commons/cli/OptionValidator.java.OptionValidator.[boolean]isValidOpt(char)", "src/main/java/org/apache/commons/cli/OptionValidator.java.OptionValidator.[boolean]search(char[],char)", "src/main/java/org/apache/commons/cli/OptionValidator.java.OptionValidator.[String]validate(String)"], "overrides": null, "attributes": [], "class_docstring": "\nValidates an Option string.\n", "original_string": "final class OptionValidator {\n    /* package private for testing access */\n    /** The array of additional characters allowed as the first character in the option but not in the rest of the option */\n    static final char[] ADDITIONAL_OPTION_CHARS = {'?', '@'};\n    /** The array of additional characters allowed in the rest of the option but not in the first position */\n    static final char[] ADDITIONAL_LONG_CHARS = {'-'};\n\n    /**\n     * Returns whether the specified character is a valid character.\n     * A character is valid if any of the following conditions are true:\n     * <ul>\n     * <li>it is a letter</li>\n     * <li>it is a currency symbol (such as '$')</li>\n     * <li>it is a connecting punctuation character (such as '_')</li>\n     * <li>it is a digit</li>\n     * <li>it is a numeric letter (such as a Roman numeral character)</li>\n     * <li>it is a combining mark</li>\n     * <li>it is a non-spacing mark</li>\n     * <li>isIdentifierIgnorable returns true for the character</li>\n     * <li>it is a hyphen/dash ('-')</li>\n     * </ul>\n     * @param c the character to validate\n     * @return true if {@code c} is a valid character letter.\n     */\n    private static boolean isValidChar(final char c) {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_LONG_CHARS, c);\n    }\n\n    /**\n     * Returns whether the specified character is a valid Option.\n     * A character is valid if any of the following conditions are true:\n     * <ul>\n     * <li>it is a letter</li>\n     * <li>it is a currency symbol (such as '$')</li>\n     * <li>it is a connecting punctuation character (such as '_')</li>\n     * <li>it is a digit</li>\n     * <li>it is a numeric letter (such as a Roman numeral character)</li>\n     * <li>it is a combining mark</li>\n     * <li>it is a non-spacing mark</li>\n     * <li>isIdentifierIgnorable returns true for the character</li>\n     * <li>it is a question mark or 'at' sign ('?' or '@')</li>\n     * </ul>\n     * @param c the option to validate\n     * @return true if {@code c} is a letter, '?' or '@', otherwise false.\n     */\n    private static boolean isValidOpt(final char c) {\n        return Character.isJavaIdentifierPart(c) || search(ADDITIONAL_OPTION_CHARS, c);\n    }\n\n    /**\n     * Checks the char array for a matching char.\n     * @param chars the char array to search\n     * @param c the char to look for.\n     * @return {@code true} if {@code c} was in {@code ary}, {@code false} otherwise.\n     */\n    private static boolean search(final char[] chars, final char c) {\n        for (final char a : chars) {\n            if (a == c) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Validates whether {@code opt} is a permissible Option shortOpt. The rules that specify if the {@code opt}\n     * is valid are:\n     *\n     * <ul>\n     * <li>a single character {@code opt} that is either Chars.SP(special case), '?', '@' or a letter</li>\n     * <li>a multi character {@code opt} that only contains valid characters</li>\n     * </ul>\n     * </p><p>\n     * A character is valid if any of the following conditions are true:\n     * <ul>\n     * <li>it is a letter</li>\n     * <li>it is a currency symbol (such as '$')</li>\n     * <li>it is a connecting punctuation character (such as '_')</li>\n     * <li>it is a digit</li>\n     * <li>it is a numeric letter (such as a Roman numeral character)</li>\n     * <li>it is a combining mark</li>\n     * <li>it is a non-spacing mark</li>\n     * <li>isIdentifierIgnorable returns true for the character</li>\n     * <li>it is a hyphen/dash ('-')</li>\n     * </ul>\n     * </p><p>\n     * In case {@code opt} is {@code null} no further validation is performed.\n     *\n     * @param option The option string to validate, may be null\n     * @throws IllegalArgumentException if the Option is not valid.\n     */\n    static String validate(final String option) throws IllegalArgumentException {\n        // if opt is null do not check further.\n        if (option == null) {\n            return null;\n        }\n        if (option.isEmpty()) {\n            throw new IllegalArgumentException(\"Empty option name.\");\n        }\n        final char[] chars = option.toCharArray();\n        final char ch0 = chars[0];\n        if (!isValidOpt(ch0)) {\n            throw new IllegalArgumentException(String.format(\"Illegal option name '%s'.\", ch0));\n        }\n        // handle the multi-character opt\n        if (option.length() > 1) {\n            for (int i = 1; i < chars.length; i++) {\n                final char ch = chars[i];\n                if (!isValidChar(ch)) {\n                    throw new IllegalArgumentException(String.format(\"The option '%s' contains an illegal \" + \"character : '%s'.\", option, ch));\n                }\n            }\n        }\n        return option;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final char[] ADDITIONAL_OPTION_CHARS = {'?', '@'};", "docstring": " The array of additional characters allowed as the first character in the option but not in the rest of the option", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char[]", "name": "ADDITIONAL_OPTION_CHARS = {'?', '@'}", "syntax_pass": true}, {"attribute_expression": "static final char[] ADDITIONAL_LONG_CHARS = {'-'};", "docstring": " The array of additional characters allowed in the rest of the option but not in the first position", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char[]", "name": "ADDITIONAL_LONG_CHARS = {'-'}", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler", "name": "TypeHandler", "file_path": "src/main/java/org/apache/commons/cli/TypeHandler.java", "superclasses": "", "methods": ["[Class<?>]createClass(String)", "[Date]createDate(String)", "[Map<Class<?>, Converter<?, ? extends Throwable>>]createDefaultMap()", "[File]createFile(String)", "[File[]]createFiles(String)", "[Number]createNumber(String)", "[Object]createObject(String)", "[URL]createURL(String)", "[T]createValue(String,Class<T>)", "[Object]createValue(String,Object)", "[T]createValueUnchecked(String,Class<T>)", "[TypeHandler]getDefault()", "[FileInputStream]openFile(String)", "[Map<Class<?>, Converter<?, ? extends Throwable>>]putDefaultMap(Map<Class<?>, Converter<?, ? extends Throwable>>)", "[]TypeHandler()", "[]TypeHandler(Map<Class<?>, Converter<?, ? extends Throwable>>)", "[Converter<T, ?>]getConverter(Class<T>)"], "method_uris": ["src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[Class<?>]createClass(String)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[Date]createDate(String)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[Map<Class<?>, Converter<?, ? extends Throwable>>]createDefaultMap()", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[File]createFile(String)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[File[]]createFiles(String)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[Number]createNumber(String)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[Object]createObject(String)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[URL]createURL(String)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[T]createValue(String,Class<T>)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[Object]createValue(String,Object)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[T]createValueUnchecked(String,Class<T>)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[TypeHandler]getDefault()", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[FileInputStream]openFile(String)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[Map<Class<?>, Converter<?, ? extends Throwable>>]putDefaultMap(Map<Class<?>, Converter<?, ? extends Throwable>>)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[]TypeHandler()", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[]TypeHandler(Map<Class<?>, Converter<?, ? extends Throwable>>)", "src/main/java/org/apache/commons/cli/TypeHandler.java.TypeHandler.[Converter<T, ?>]getConverter(Class<T>)"], "overrides": null, "attributes": [], "class_docstring": "\nTypeHandler will handle the pluggable conversion and verification of Option types. It handles the mapping of classes to bot converters and verifiers. It\nprovides the default conversion and verification methods when converters and verifiers are not explicitly set.\n<p>\nIf Options are serialized and deserialized their converters and verifiers will revert to the defaults defined in this class. To correctly de-serialize\nOptions with custom converters and/or verifiers, using the default serialization methods, this class should be properly configured with the custom converters\nand verifiers for the specific class.\n</p>\n", "original_string": "public class TypeHandler {\n\n    /**\n     * The default TypeHandler.\n     */\n    private static final TypeHandler DEFAULT = new TypeHandler();\n\n    /** Value of hex conversion of strings */\n    private static final int HEX_RADIX = 16;\n\n    /**\n     * Returns the class whose name is {@code className}.\n     *\n     * @param className the class name\n     * @return The class if it is found\n     * @throws ParseException if the class could not be found\n     */\n    public static Class<?> createClass(final String className) throws ParseException {\n        return createValue(className, Class.class);\n    }\n\n    /**\n     * Returns the date represented by {@code string}.\n     * <p>\n     * This method is not yet implemented and always throws an {@link UnsupportedOperationException}.\n     * </p>\n     *\n     * @param string the date string\n     * @return The date if {@code string} is a valid date string, otherwise return null.\n     */\n    public static Date createDate(final String string) {\n        return createValueUnchecked(string, Date.class);\n    }\n\n    /**\n     * Creates a default converter map.\n     *\n     * @return a default converter map.\n     * @since 1.7.0\n     */\n    public static Map<Class<?>, Converter<?, ? extends Throwable>> createDefaultMap() {\n        return putDefaultMap(new HashMap<>());\n    }\n\n    /**\n     * Returns the File represented by {@code string}.\n     *\n     * @param string the File location\n     * @return The file represented by {@code string}.\n     */\n    public static File createFile(final String string) {\n        return createValueUnchecked(string, File.class);\n    }\n\n    /**\n     * Creates the File[] represented by {@code string}.\n     *\n     * <p>\n     * This method is not yet implemented and always throws an {@link UnsupportedOperationException}.\n     * </p>\n     *\n     * @param string the paths to the files\n     * @return The File[] represented by {@code string}.\n     * @throws UnsupportedOperationException always\n     * @deprecated with no replacement\n     */\n    @Deprecated // since 1.7.0\n    public static File[] createFiles(final String string) {\n        // to implement/port:\n        // return FileW.findFiles(string);\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }\n\n    /**\n     * Creates a number from a String. If a '.' is present, it creates a Double, otherwise a Long.\n     *\n     * @param string the value\n     * @return the number represented by {@code string}\n     * @throws ParseException if {@code string} is not a number\n     */\n    @Deprecated // since 1.7.0\n    public static Number createNumber(final String string) throws ParseException {\n        return createValue(string, Number.class);\n    }\n\n    /**\n     * Creates an Object from the class name and empty constructor.\n     *\n     * @param className the argument value\n     * @return the initialized object\n     * @throws ParseException if the class could not be found or the object could not be created\n     * @deprecated use {@link #createValue(String, Class)}\n     */\n    @Deprecated // since 1.7.0\n    public static Object createObject(final String className) throws ParseException {\n        return createValue(className, Object.class);\n    }\n\n    /**\n     * Creates the URL represented by {@code string}.\n     *\n     * @param string the URL string\n     * @return The URL in {@code string} is well-formed\n     * @throws ParseException if the URL in {@code string} is not well-formed\n     */\n    public static URL createURL(final String string) throws ParseException {\n        return createValue(string, URL.class);\n    }\n\n    /**\n     * Creates the @code Object} of type {@code clazz} with the value of {@code string}.\n     *\n     * @param string the command line value\n     * @param clazz  the class representing the type of argument\n     * @param <T>    type of argument\n     * @return The instance of {@code clazz} initialized with the value of {@code string}.\n     * @throws ParseException if the value creation for the given class threw an exception.\n     */\n    public static <T> T createValue(final String string, final Class<T> clazz) throws ParseException {\n        try {\n            return getDefault().getConverter(clazz).apply(string);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }\n\n    /**\n     * Creates the {@code Object} of type {@code obj} with the value of {@code string}.\n     *\n     * @param string the command line value\n     * @param obj    the type of argument\n     * @return The instance of {@code obj} initialized with the value of {@code string}.\n     * @throws ParseException if the value creation for the given object type failed\n     * @deprecated use {@link #createValue(String, Class)}\n     */\n    @Deprecated // since 1.7.0\n    public static Object createValue(final String string, final Object obj) throws ParseException {\n        return createValue(string, (Class<?>) obj);\n    }\n\n    /**\n     * Delegates to {@link #createValue(String, Class)} throwing IllegalArgumentException instead of ParseException.\n     *\n     * @param string the command line value\n     * @param clazz  the class representing the type of argument\n     * @param <T>    type of argument\n     * @return The instance of {@code clazz} initialized with the value of {@code string}.\n     * @throws IllegalArgumentException if the value creation for the given class threw an exception.\n     */\n    private static <T> T createValueUnchecked(final String string, final Class<T> clazz) {\n        try {\n            return createValue(string, clazz);\n        } catch (final ParseException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    /**\n     * Gets the default TypeHandler.\n     *\n     * @return the default TypeHandler.\n     * @since 1.7.0\n     */\n    public static TypeHandler getDefault() {\n        return DEFAULT;\n    }\n\n    /**\n     * Returns the opened FileInputStream represented by {@code string}.\n     *\n     * @param string the file location\n     * @return The file input stream represented by {@code string}.\n     * @throws ParseException if the file is not exist or not readable\n     * @deprecated use {@link #createValue(String, Class)}\n     */\n    @Deprecated // since 1.7.0\n    public static FileInputStream openFile(final String string) throws ParseException {\n        return createValue(string, FileInputStream.class);\n    }\n\n    private static Map<Class<?>, Converter<?, ? extends Throwable>> putDefaultMap(final Map<Class<?>, Converter<?, ? extends Throwable>> map) {\n        map.put(Object.class, Converter.OBJECT);\n        map.put(Class.class, Converter.CLASS);\n        map.put(Date.class, Converter.DATE);\n        map.put(File.class, Converter.FILE);\n        map.put(Path.class, Converter.PATH);\n        map.put(Number.class, Converter.NUMBER);\n        map.put(URL.class, Converter.URL);\n        map.put(FileInputStream.class, FileInputStream::new);\n        map.put(Long.class, Long::parseLong);\n        map.put(Integer.class, Integer::parseInt);\n        map.put(Short.class, Short::parseShort);\n        map.put(Byte.class, Byte::parseByte);\n        map.put(Character.class, s -> s.startsWith(\"\\\\u\") ? Character.toChars(Integer.parseInt(s.substring(2), HEX_RADIX))[0] : s.charAt(0));\n        map.put(Double.class, Double::parseDouble);\n        map.put(Float.class, Float::parseFloat);\n        map.put(BigInteger.class, BigInteger::new);\n        map.put(BigDecimal.class, BigDecimal::new);\n        return map;\n    }\n\n    /**\n     * Map of Class to Converter.\n     * <p>\n     * For each entry, that Class' type must match the Converter's first type.\n     * </p>\n     */\n    private final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap;\n\n    /**\n     * Constructs a default initialized instance.\n     */\n    public TypeHandler() {\n        this(createDefaultMap());\n    }\n\n    /**\n     * Constructs a default initialized instance.\n     * <p>\n     * For each entry, that Class' type must match the Converter's first type.\n     * </p>\n     *\n     * @param converterMap The converter map, not null.\n     * @since 1.7.0\n     */\n    public TypeHandler(final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap) {\n        this.converterMap = Objects.requireNonNull(converterMap, \"converterMap\");\n    }\n\n    /**\n     * Gets the registered converter for the the Class, or {@link Converter#DEFAULT} if absent.\n     *\n     * @param <T>   The Class parameter type.\n     * @param clazz The Class to get the Converter for.\n     * @return the registered converter if any, {@link Converter#DEFAULT} otherwise.\n     * @since 1.7.0\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public <T> Converter<T, ?> getConverter(final Class<T> clazz) {\n        return (Converter<T, ?>) converterMap.getOrDefault(clazz, Converter.DEFAULT);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final TypeHandler DEFAULT = new TypeHandler();", "docstring": "\nThe default TypeHandler.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TypeHandler", "name": "DEFAULT = new TypeHandler()", "syntax_pass": true}, {"attribute_expression": "private static final int HEX_RADIX = 16;", "docstring": " Value of hex conversion of strings", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "HEX_RADIX = 16", "syntax_pass": true}, {"attribute_expression": "private final Map<Class<?>, Converter<?, ? extends Throwable>> converterMap;", "docstring": "\nMap of Class to Converter.\n<p>\nFor each entry, that Class' type must match the Converter's first type.\n</p>\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Class<?>, Converter<?, ? extends Throwable>>", "name": "converterMap", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/Options.java.Options", "name": "Options", "file_path": "src/main/java/org/apache/commons/cli/Options.java", "superclasses": "", "methods": ["[Options]addOption(Option)", "[Options]addOption(String,boolean,String)", "[Options]addOption(String,String)", "[Options]addOption(String,String,boolean,String)", "[Options]addOptionGroup(OptionGroup)", "[Options]addOptions(Options)", "[Options]addRequiredOption(String,String,boolean,String)", "[List<String>]getMatchingOptions(String)", "[Option]getOption(String)", "[OptionGroup]getOptionGroup(Option)", "[Collection<OptionGroup>]getOptionGroups()", "[Collection<Option>]getOptions()", "[List<?>]getRequiredOptions()", "[boolean]hasLongOption(String)", "[boolean]hasOption(String)", "[boolean]hasShortOption(String)", "[List<Option>]helpOptions()", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/cli/Options.java.Options.[Options]addOption(Option)", "src/main/java/org/apache/commons/cli/Options.java.Options.[Options]addOption(String,boolean,String)", "src/main/java/org/apache/commons/cli/Options.java.Options.[Options]addOption(String,String)", "src/main/java/org/apache/commons/cli/Options.java.Options.[Options]addOption(String,String,boolean,String)", "src/main/java/org/apache/commons/cli/Options.java.Options.[Options]addOptionGroup(OptionGroup)", "src/main/java/org/apache/commons/cli/Options.java.Options.[Options]addOptions(Options)", "src/main/java/org/apache/commons/cli/Options.java.Options.[Options]addRequiredOption(String,String,boolean,String)", "src/main/java/org/apache/commons/cli/Options.java.Options.[List<String>]getMatchingOptions(String)", "src/main/java/org/apache/commons/cli/Options.java.Options.[Option]getOption(String)", "src/main/java/org/apache/commons/cli/Options.java.Options.[OptionGroup]getOptionGroup(Option)", "src/main/java/org/apache/commons/cli/Options.java.Options.[Collection<OptionGroup>]getOptionGroups()", "src/main/java/org/apache/commons/cli/Options.java.Options.[Collection<Option>]getOptions()", "src/main/java/org/apache/commons/cli/Options.java.Options.[List<?>]getRequiredOptions()", "src/main/java/org/apache/commons/cli/Options.java.Options.[boolean]hasLongOption(String)", "src/main/java/org/apache/commons/cli/Options.java.Options.[boolean]hasOption(String)", "src/main/java/org/apache/commons/cli/Options.java.Options.[boolean]hasShortOption(String)", "src/main/java/org/apache/commons/cli/Options.java.Options.[List<Option>]helpOptions()", "src/main/java/org/apache/commons/cli/Options.java.Options.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nMain entry-point into the library.\n<p>\nOptions represents a collection of {@link Option} objects, which describe the possible options for a command-line.\n</p>\n<p>\nIt may flexibly parse long and short options, with or without values. Additionally, it may parse only a portion of a\ncommandline, allowing for flexible multi-stage parsing.\n</p>\n\n@see org.apache.commons.cli.CommandLine\n", "original_string": "public class Options implements Serializable {\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /** A map of the options with the character key */\n    private final Map<String, Option> shortOpts = new LinkedHashMap<>();\n\n    /** A map of the options with the long key */\n    private final Map<String, Option> longOpts = new LinkedHashMap<>();\n\n    /** A map of the required options */\n    // N.B. This can contain either a String (addOption) or an OptionGroup (addOptionGroup)\n    // TODO this seems wrong\n    private final List<Object> requiredOpts = new ArrayList<>();\n\n    /** A map of the option groups */\n    private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<>();\n\n    /**\n     * Adds an option instance\n     *\n     * @param opt the option that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOption(final Option opt) {\n        final String key = opt.getKey();\n        // add it to the long option list\n        if (opt.hasLongOpt()) {\n            longOpts.put(opt.getLongOpt(), opt);\n        }\n        // if the option is required add it to the required list\n        if (opt.isRequired()) {\n            if (requiredOpts.contains(key)) {\n                requiredOpts.remove(requiredOpts.indexOf(key));\n            }\n            requiredOpts.add(key);\n        }\n        shortOpts.put(key, opt);\n        return this;\n    }\n\n    /**\n     * Adds an option that only contains a short-name.\n     * <p>\n     * It may be specified as requiring an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(final String opt, final boolean hasArg, final String description) {\n        addOption(opt, null, hasArg, description);\n        return this;\n    }\n\n    /**\n     * Adds an option that only contains a short name.\n     * <p>\n     * The option does not take an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.3\n     */\n    public Options addOption(final String opt, final String description) {\n        addOption(opt, null, false, description);\n        return this;\n    }\n\n    /**\n     * Adds an option that contains a short-name and a long-name.\n     * <p>\n     * It may be specified as requiring an argument.\n     * </p>\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     */\n    public Options addOption(final String opt, final String longOpt, final boolean hasArg, final String description) {\n        addOption(new Option(opt, longOpt, hasArg, description));\n        return this;\n    }\n\n    /**\n     * Adds the specified option group.\n     *\n     * @param group the OptionGroup that is to be added\n     * @return the resulting Options instance\n     */\n    public Options addOptionGroup(final OptionGroup group) {\n        if (group.isRequired()) {\n            requiredOpts.add(group);\n        }\n        for (final Option option : group.getOptions()) {\n            // an Option cannot be required if it is in an\n            // OptionGroup, either the group is required or\n            // nothing is required\n            option.setRequired(false);\n            addOption(option);\n            optionGroups.put(option.getKey(), group);\n        }\n        return this;\n    }\n\n    /**\n     * Adds options to this option.  If any Option in {@code options} already exists\n     * in this Options an IllegalArgumentException is thrown\n     *\n     * @param options the options to add.\n     * @return The resulting Options instance.\n     * @since 1.7.0\n     */\n    public Options addOptions(final Options options) {\n        for (final Option opt : options.getOptions()) {\n            if (hasOption(opt.getKey())) {\n                throw new IllegalArgumentException(\"Duplicate key: \" + opt.getKey());\n            }\n            addOption(opt);\n        }\n        options.getOptionGroups().forEach(this::addOptionGroup);\n        return this;\n    }\n\n    /**\n     * Adds an option that contains a short-name and a long-name.\n     * <p>\n     * The added option is set as required. It may be specified as requiring an argument. This method is a shortcut for:\n     * </p>\n     * <pre>\n     * <code>\n     * Options option = new Option(opt, longOpt, hasArg, description);\n     * option.setRequired(true);\n     * options.add(option);\n     * </code>\n     * </pre>\n     *\n     * @param opt Short single-character name of the option.\n     * @param longOpt Long multi-character name of the option.\n     * @param hasArg flag signalling if an argument is required after this option\n     * @param description Self-documenting description\n     * @return the resulting Options instance\n     * @since 1.4\n     */\n    public Options addRequiredOption(final String opt, final String longOpt, final boolean hasArg, final String description) {\n        final Option option = new Option(opt, longOpt, hasArg, description);\n        option.setRequired(true);\n        addOption(option);\n        return this;\n    }\n\n    /**\n     * Gets the options with a long name starting with the name specified.\n     *\n     * @param opt the partial name of the option\n     * @return the options matching the partial name specified, or an empty list if none matches\n     * @since 1.3\n     */\n    public List<String> getMatchingOptions(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final List<String> matchingOpts = new ArrayList<>();\n        // for a perfect match return the single option only\n        if (longOpts.containsKey(clean)) {\n            return Collections.singletonList(clean);\n        }\n        for (final String longOpt : longOpts.keySet()) {\n            if (longOpt.startsWith(clean)) {\n                matchingOpts.add(longOpt);\n            }\n        }\n        return matchingOpts;\n    }\n\n    /**\n     * Gets the {@link Option} matching the long or short name specified.\n     * <p>\n     * The leading hyphens in the name are ignored (up to 2).\n     * </p>\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return the option represented by opt\n     */\n    public Option getOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        final Option option = shortOpts.get(clean);\n        return option != null ? option : longOpts.get(clean);\n    }\n\n    /**\n     * Gets the OptionGroup the {@code opt} belongs to.\n     *\n     * @param opt the option whose OptionGroup is being queried.\n     * @return the OptionGroup if {@code opt} is part of an OptionGroup, otherwise return null\n     */\n    public OptionGroup getOptionGroup(final Option opt) {\n        return optionGroups.get(opt.getKey());\n    }\n\n    /**\n     * Gets the OptionGroups that are members of this Options instance.\n     *\n     * @return a Collection of OptionGroup instances.\n     */\n    Collection<OptionGroup> getOptionGroups() {\n        /* The optionGroups map will have duplicates in the values() results.  We\n         * use the HashSet to filter out duplicates and return a collection of\n         * OpitonGroup.  The decision to return a Collection rather than a set\n         * was probably to keep symmetry with the getOptions() method.\n         */\n        return new HashSet<>(optionGroups.values());\n    }\n\n    /**\n     * Gets a read-only list of options in this set\n     *\n     * @return read-only Collection of {@link Option} objects in this descriptor\n     */\n    public Collection<Option> getOptions() {\n        return Collections.unmodifiableCollection(helpOptions());\n    }\n\n    /**\n     * Gets the required options.\n     *\n     * @return read-only List of required options\n     */\n    public List<?> getRequiredOptions() {\n        return Collections.unmodifiableList(requiredOpts);\n    }\n\n    /**\n     * Tests whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasLongOption(final String opt) {\n        return longOpts.containsKey(Util.stripLeadingHyphens(opt));\n    }\n\n    /**\n     * Tests whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short or long name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     */\n    public boolean hasOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean) || longOpts.containsKey(clean);\n    }\n\n    /**\n     * Tests whether the named {@link Option} is a member of this {@link Options}.\n     *\n     * @param opt short name of the {@link Option}\n     * @return true if the named {@link Option} is a member of this {@link Options}\n     * @since 1.3\n     */\n    public boolean hasShortOption(final String opt) {\n        final String clean = Util.stripLeadingHyphens(opt);\n        return shortOpts.containsKey(clean);\n    }\n\n    /**\n     * Returns the Options for use by the HelpFormatter.\n     *\n     * @return the List of Options\n     */\n    List<Option> helpOptions() {\n        return new ArrayList<>(shortOpts.values());\n    }\n\n    /**\n     * Dump state, suitable for debugging.\n     *\n     * @return Stringified form of this object\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(\"[ Options: [ short \");\n        buf.append(shortOpts.toString());\n        buf.append(\" ] [ long \");\n        buf.append(longOpts);\n        buf.append(\" ]\");\n        return buf.toString();\n    }\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Option> shortOpts = new LinkedHashMap<>();", "docstring": " A map of the options with the character key", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Option>", "name": "shortOpts = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Option> longOpts = new LinkedHashMap<>();", "docstring": " A map of the options with the long key", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Option>", "name": "longOpts = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final List<Object> requiredOpts = new ArrayList<>();", "docstring": " TODO this seems wrong", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Object>", "name": "requiredOpts = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, OptionGroup> optionGroups = new LinkedHashMap<>();", "docstring": " A map of the option groups", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, OptionGroup>", "name": "optionGroups = new LinkedHashMap<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java.PatternOptionBuilder", "name": "PatternOptionBuilder", "file_path": "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java", "superclasses": "", "methods": ["[Object]getValueClass(char)", "[Class<?>]getValueType(char)", "[boolean]isValueCode(char)", "[Options]parsePattern(String)", "[T]unsupported()"], "method_uris": ["src/main/java/org/apache/commons/cli/PatternOptionBuilder.java.PatternOptionBuilder.[Object]getValueClass(char)", "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java.PatternOptionBuilder.[Class<?>]getValueType(char)", "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java.PatternOptionBuilder.[boolean]isValueCode(char)", "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java.PatternOptionBuilder.[Options]parsePattern(String)", "src/main/java/org/apache/commons/cli/PatternOptionBuilder.java.PatternOptionBuilder.[T]unsupported()"], "overrides": null, "attributes": [], "class_docstring": "\nAllows Options to be created from a single String. The pattern contains various single character flags and via an\noptional punctuation character, their expected type.\n\n<table border=\"1\">\n<caption>Overview of PatternOptionBuilder patterns</caption>\n<tr>\n<td>a</td>\n<td>-a flag</td>\n</tr>\n<tr>\n<td>b@</td>\n<td>-b [class name]</td>\n</tr>\n<tr>\n<td>c&gt;</td>\n<td>-c [file name]</td>\n</tr>\n<tr>\n<td>d+</td>\n<td>-d [class name] (creates object via empty constructor)</td>\n</tr>\n<tr>\n<td>e%</td>\n<td>-e [number] (creates Double/Long instance depending on existing of a '.')</td>\n</tr>\n<tr>\n<td>f/</td>\n<td>-f [URL]</td>\n</tr>\n<tr>\n<td>g:</td>\n<td>-g [string]</td>\n</tr>\n</table>\n\n<p>\nFor example, the following allows command line flags of '-v -p string-value -f /dir/file'. The exclamation mark\nprecede a mandatory option.\n</p>\n\n<pre>\nOptions options = PatternOptionBuilder.parsePattern(\"vp:!f/\");\n</pre>\n\n<p>\nTODO These need to break out to OptionType and also to be pluggable.\n</p>\n", "original_string": "public class PatternOptionBuilder {\n\n    /** String class */\n    public static final Class<String> STRING_VALUE = String.class;\n\n    /** Object class */\n    public static final Class<Object> OBJECT_VALUE = Object.class;\n\n    /** Number class */\n    public static final Class<Number> NUMBER_VALUE = Number.class;\n\n    /** Date class */\n    public static final Class<Date> DATE_VALUE = Date.class;\n\n    /** Class class */\n    public static final Class<?> CLASS_VALUE = Class.class;\n\n    /// can we do this one??\n    // is meant to check that the file exists, else it errors.\n    // ie) it's for reading not writing.\n\n    /** FileInputStream class */\n    public static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;\n\n    /** File class */\n    public static final Class<File> FILE_VALUE = File.class;\n\n    /** File array class */\n    public static final Class<File[]> FILES_VALUE = File[].class;\n\n    /** URL class */\n    public static final Class<URL> URL_VALUE = URL.class;\n\n    /** The converter to use for Unimplemented data types */\n    private static final Converter<?, UnsupportedOperationException> UNSUPPORTED = s -> {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    };\n\n    /**\n     * Retrieve the class that {@code ch} represents.\n     *\n     * @param ch the specified character\n     * @return The class that {@code ch} represents\n     * @deprecated use {@link #getValueType(char)}\n     */\n    @Deprecated // since=\"1.7.0\"\n    public static Object getValueClass(final char ch) {\n        return getValueType(ch);\n    }\n\n    /**\n     * Retrieve the class that {@code ch} represents.\n     *\n     * @param ch the specified character\n     * @return The class that {@code ch} represents\n     * @since 1.7.0\n     */\n    public static Class<?> getValueType(final char ch) {\n        switch (ch) {\n        case '@':\n            return OBJECT_VALUE;\n        case ':':\n            return STRING_VALUE;\n        case '%':\n            return NUMBER_VALUE;\n        case '+':\n            return CLASS_VALUE;\n        case '#':\n            return DATE_VALUE;\n        case '<':\n            return EXISTING_FILE_VALUE;\n        case '>':\n            return FILE_VALUE;\n        case '*':\n            return FILES_VALUE;\n        case '/':\n            return URL_VALUE;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns whether {@code ch} is a value code, i.e. whether it represents a class in a pattern.\n     *\n     * @param ch the specified character\n     * @return true if {@code ch} is a value code, otherwise false.\n     */\n    public static boolean isValueCode(final char ch) {\n        return ch == '@' || ch == ':' || ch == '%' || ch == '+' || ch == '#' || ch == '<' || ch == '>' || ch == '*' || ch == '/' || ch == '!';\n    }\n\n    /**\n     * Returns the {@link Options} instance represented by {@code pattern}.\n     *\n     * @param pattern the pattern string\n     * @return The {@link Options} instance\n     */\n    public static Options parsePattern(final String pattern) {\n        char opt = Char.SP;\n        boolean required = false;\n        Class<?> type = null;\n        Converter<?, ?> converter = Converter.DEFAULT;\n\n        final Options options = new Options();\n\n        for (int i = 0; i < pattern.length(); i++) {\n            final char ch = pattern.charAt(i);\n\n            // a value code comes after an option and specifies\n            // details about it\n            if (!isValueCode(ch)) {\n                if (opt != Char.SP) {\n                    // @formatter:off\n                    final Option option = Option.builder(String.valueOf(opt))\n                            .hasArg(type != null)\n                            .required(required)\n                            .type(type)\n                            .converter(converter)\n                            .build();\n                    // @formatter:on\n                    // we have a previous one to deal with\n                    options.addOption(option);\n                    required = false;\n                    type = null;\n                    converter = Converter.DEFAULT;\n                }\n\n                opt = ch;\n            } else if (ch == '!') {\n                required = true;\n            } else {\n                type = getValueType(ch);\n                final Map<Class<?>, Converter<?, ? extends Throwable>> map = TypeHandler.createDefaultMap();\n                // Backward compatibility (probably).\n                map.put(FILES_VALUE, unsupported());\n                converter = new TypeHandler(map).getConverter(getValueType(ch));\n            }\n        }\n\n        if (opt != Char.SP) {\n            final Option option = Option.builder(String.valueOf(opt)).hasArg(type != null).required(required).type(type).build();\n\n            // we have a final one to deal with\n            options.addOption(option);\n        }\n\n        return options;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <T> T unsupported() {\n        return (T) UNSUPPORTED;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Class<String> STRING_VALUE = String.class;", "docstring": " String class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<String>", "name": "STRING_VALUE = String.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<Object> OBJECT_VALUE = Object.class;", "docstring": " Object class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<Object>", "name": "OBJECT_VALUE = Object.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<Number> NUMBER_VALUE = Number.class;", "docstring": " Number class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<Number>", "name": "NUMBER_VALUE = Number.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<Date> DATE_VALUE = Date.class;", "docstring": " Date class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<Date>", "name": "DATE_VALUE = Date.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<?> CLASS_VALUE = Class.class;", "docstring": " Class class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<?>", "name": "CLASS_VALUE = Class.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;", "docstring": " FileInputStream class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<FileInputStream>", "name": "EXISTING_FILE_VALUE = FileInputStream.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<File> FILE_VALUE = File.class;", "docstring": " File class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<File>", "name": "FILE_VALUE = File.class", "syntax_pass": true}, {"attribute_expression": "public static final Class<File[]> FILES_VALUE = File[].class;", "docstring": " File array class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<File[]>", "name": "FILES_VALUE = File[].class", "syntax_pass": true}, {"attribute_expression": "public static final Class<URL> URL_VALUE = URL.class;", "docstring": " URL class", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Class<URL>", "name": "URL_VALUE = URL.class", "syntax_pass": true}, {"attribute_expression": "private static final Converter<?, UnsupportedOperationException> UNSUPPORTED = s -> {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    };", "docstring": " The converter to use for Unimplemented data types", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Converter<?, UnsupportedOperationException>", "name": "UNSUPPORTED = s -> {\n        throw new UnsupportedOperationException(\"Not yet implemented\");\n    }", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/Char.java.Char", "name": "Char", "file_path": "src/main/java/org/apache/commons/cli/Char.java", "superclasses": "", "methods": ["[]Char()"], "method_uris": ["src/main/java/org/apache/commons/cli/Char.java.Char.[]Char()"], "overrides": null, "attributes": [], "class_docstring": "\nPackage-private character constants.\n", "original_string": "final class Char {\n\n    /** Apostrophe */\n    static final char APOS = '\\'';\n\n    /** Carriage return. */\n    static final char CR = '\\r';\n\n    /** Equal sign. */\n    static final char EQUAL = '=';\n\n    /** Line feed. */\n    static final char LF = '\\n';\n\n    /** Space. */\n    static final char SP = ' ';\n\n    /** Tab. */\n    static final char TAB = '\\t';\n\n    private Char() {\n        // empty\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final char APOS = '\\'';", "docstring": " Apostrophe", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "APOS = '\\''", "syntax_pass": true}, {"attribute_expression": "static final char CR = '\\r';", "docstring": " Carriage return.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "CR = '\\r'", "syntax_pass": true}, {"attribute_expression": "static final char EQUAL = '=';", "docstring": " Equal sign.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "EQUAL = '='", "syntax_pass": true}, {"attribute_expression": "static final char LF = '\\n';", "docstring": " Line feed.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "LF = '\\n'", "syntax_pass": true}, {"attribute_expression": "static final char SP = ' ';", "docstring": " Space.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "SP = ' '", "syntax_pass": true}, {"attribute_expression": "static final char TAB = '\\t';", "docstring": " Tab.", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "TAB = '\\t'", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine", "name": "CommandLine", "file_path": "src/main/java/org/apache/commons/cli/CommandLine.java", "superclasses": "", "methods": ["[Builder]builder()", "[]CommandLine()", "[]CommandLine(List<String>,List<Option>,Consumer<Option>)", "[void]addArg(String)", "[void]addOption(Option)", "[T]get(Supplier<T>)", "[List<String>]getArgList()", "[String[]]getArgs()", "[Object]getOptionObject(char)", "[Object]getOptionObject(String)", "[Properties]getOptionProperties(Option)", "[Properties]getOptionProperties(String)", "[Option[]]getOptions()", "[String]getOptionValue(char)", "[String]getOptionValue(char,String)", "[String]getOptionValue(char,Supplier<String>)", "[String]getOptionValue(Option)", "[String]getOptionValue(Option,String)", "[String]getOptionValue(Option,Supplier<String>)", "[String]getOptionValue(OptionGroup)", "[String]getOptionValue(OptionGroup,String)", "[String]getOptionValue(OptionGroup,Supplier<String>)", "[String]getOptionValue(String)", "[String]getOptionValue(String,String)", "[String]getOptionValue(String,Supplier<String>)", "[String[]]getOptionValues(char)", "[String[]]getOptionValues(Option)", "[String[]]getOptionValues(OptionGroup)", "[String[]]getOptionValues(String)", "[T]getParsedOptionValue(char)", "[T]getParsedOptionValue(char,Supplier<T>)", "[T]getParsedOptionValue(char,T)", "[T]getParsedOptionValue(Option)", "[T]getParsedOptionValue(Option,Supplier<T>)", "[T]getParsedOptionValue(Option,T)", "[T]getParsedOptionValue(OptionGroup)", "[T]getParsedOptionValue(OptionGroup,Supplier<T>)", "[T]getParsedOptionValue(OptionGroup,T)", "[T]getParsedOptionValue(String)", "[T]getParsedOptionValue(String,Supplier<T>)", "[T]getParsedOptionValue(String,T)", "[void]handleDeprecated(Option)", "[boolean]hasOption(char)", "[boolean]hasOption(Option)", "[boolean]hasOption(OptionGroup)", "[boolean]hasOption(String)", "[Iterator<Option>]iterator()", "[void]processPropertiesFromValues(Properties,List<String>)", "[Option]resolveOption(String)"], "method_uris": ["src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[Builder]builder()", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[]CommandLine()", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[]CommandLine(List<String>,List<Option>,Consumer<Option>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[void]addArg(String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[void]addOption(Option)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]get(Supplier<T>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[List<String>]getArgList()", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String[]]getArgs()", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[Object]getOptionObject(char)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[Object]getOptionObject(String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[Properties]getOptionProperties(Option)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[Properties]getOptionProperties(String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[Option[]]getOptions()", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(char)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(char,String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(char,Supplier<String>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(Option)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(Option,String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(Option,Supplier<String>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(OptionGroup)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(OptionGroup,String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(OptionGroup,Supplier<String>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(String,String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String]getOptionValue(String,Supplier<String>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String[]]getOptionValues(char)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String[]]getOptionValues(Option)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String[]]getOptionValues(OptionGroup)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[String[]]getOptionValues(String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(char)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(char,Supplier<T>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(char,T)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(Option)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(Option,Supplier<T>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(Option,T)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(OptionGroup)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(OptionGroup,Supplier<T>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(OptionGroup,T)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(String,Supplier<T>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[T]getParsedOptionValue(String,T)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[void]handleDeprecated(Option)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[boolean]hasOption(char)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[boolean]hasOption(Option)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[boolean]hasOption(OptionGroup)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[boolean]hasOption(String)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[Iterator<Option>]iterator()", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[void]processPropertiesFromValues(Properties,List<String>)", "src/main/java/org/apache/commons/cli/CommandLine.java.CommandLine.[Option]resolveOption(String)"], "overrides": null, "attributes": [{"original_string": "    public static final class Builder {\n\n        /**\n         * Prints an Option to {@link System#out}.\n         */\n        static final Consumer<Option> DEPRECATED_HANDLER = o -> System.out.println(o.toDeprecatedString());\n\n        /** The unrecognized options/arguments */\n        private final List<String> args = new LinkedList<>();\n\n        /** The processed options */\n        private final List<Option> options = new ArrayList<>();\n\n        /**\n         * Deprecated Option handler.\n         */\n        private Consumer<Option> deprecatedHandler = DEPRECATED_HANDLER;\n\n        /**\n         * Adds left-over unrecognized option/argument.\n         *\n         * @param arg the unrecognized option/argument.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addArg(final String arg) {\n            if (arg != null) {\n                args.add(arg);\n            }\n            return this;\n        }\n\n        /**\n         * Adds an option to the command line. The values of the option are stored.\n         *\n         * @param opt the processed option.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addOption(final Option opt) {\n            if (opt != null) {\n                options.add(opt);\n            }\n            return this;\n        }\n\n        /**\n         * Creates the new instance.\n         *\n         * @return the new instance.\n         */\n        public CommandLine build() {\n            return new CommandLine(args, options, deprecatedHandler);\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n    }", "definition": "    public static final class Builder", "class_docstring": "\nA nested builder class to create {@code CommandLine} instance using descriptive methods.\n\n@since 1.4\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "static final Consumer<Option> DEPRECATED_HANDLER = o -> System.out.println(o.toDeprecatedString());", "docstring": "\nPrints an Option to {@link System#out}.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Consumer<Option>", "name": "DEPRECATED_HANDLER = o -> System.out.println(o.toDeprecatedString())", "syntax_pass": true}, {"attribute_expression": "private final List<String> args = new LinkedList<>();", "docstring": " The unrecognized options/arguments", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "args = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<Option> options = new ArrayList<>();", "docstring": " The processed options", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Option>", "name": "options = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private Consumer<Option> deprecatedHandler = DEPRECATED_HANDLER;", "docstring": "\nDeprecated Option handler.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Consumer<Option>", "name": "deprecatedHandler = DEPRECATED_HANDLER", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Builder addArg(final String arg) {\n            if (arg != null) {\n                args.add(arg);\n            }\n            return this;\n        }", "docstring": "\nAdds left-over unrecognized option/argument.\n\n@param arg the unrecognized option/argument.\n\n@return this Builder instance for method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "addArg", "params": [{"name": "arg", "type": "String"}], "body": "                                                {\n            if (arg != null) {\n                args.add(arg);\n            }\n            return this;\n        }", "signature": "public Builder addArg(final String arg)"}, {"syntax_pass": true, "original_string": "        public Builder addOption(final Option opt) {\n            if (opt != null) {\n                options.add(opt);\n            }\n            return this;\n        }", "docstring": "\nAdds an option to the command line. The values of the option are stored.\n\n@param opt the processed option.\n\n@return this Builder instance for method chaining.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "addOption", "params": [{"name": "opt", "type": "Option"}], "body": "                                                   {\n            if (opt != null) {\n                options.add(opt);\n            }\n            return this;\n        }", "signature": "public Builder addOption(final Option opt)"}, {"syntax_pass": true, "original_string": "        public CommandLine build() {\n            return new CommandLine(args, options, deprecatedHandler);\n        }", "docstring": "\nCreates the new instance.\n\n@return the new instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CommandLine", "classes": []}, "name": "build", "params": [], "body": "                                   {\n            return new CommandLine(args, options, deprecatedHandler);\n        }", "signature": "public CommandLine build()"}, {"syntax_pass": true, "original_string": "        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }", "docstring": "\nSets the deprecated option handler.\n\n@param deprecatedHandler the deprecated option handler.\n@return {@code this} instance.\n@since 1.7.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setDeprecatedHandler", "params": [{"name": "deprecatedHandler", "type": "Consumer<Option>"}], "body": "                                                                                      {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }", "signature": "public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler)"}]}], "class_docstring": "\nRepresents list of arguments parsed against a {@link Options} descriptor.\n<p>\nIt allows querying of a boolean {@link #hasOption(String opt)}, in addition to retrieving the\n{@link #getOptionValue(String opt)} for options requiring arguments.\n</p>\n<p>\nAdditionally, any left-over or unrecognized arguments, are available for further processing.\n</p>\n", "original_string": "public class CommandLine implements Serializable {\n\n    /**\n     * A nested builder class to create {@code CommandLine} instance using descriptive methods.\n     *\n     * @since 1.4\n     */\n    public static final class Builder {\n\n        /**\n         * Prints an Option to {@link System#out}.\n         */\n        static final Consumer<Option> DEPRECATED_HANDLER = o -> System.out.println(o.toDeprecatedString());\n\n        /** The unrecognized options/arguments */\n        private final List<String> args = new LinkedList<>();\n\n        /** The processed options */\n        private final List<Option> options = new ArrayList<>();\n\n        /**\n         * Deprecated Option handler.\n         */\n        private Consumer<Option> deprecatedHandler = DEPRECATED_HANDLER;\n\n        /**\n         * Adds left-over unrecognized option/argument.\n         *\n         * @param arg the unrecognized option/argument.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addArg(final String arg) {\n            if (arg != null) {\n                args.add(arg);\n            }\n            return this;\n        }\n\n        /**\n         * Adds an option to the command line. The values of the option are stored.\n         *\n         * @param opt the processed option.\n         *\n         * @return this Builder instance for method chaining.\n         */\n        public Builder addOption(final Option opt) {\n            if (opt != null) {\n                options.add(opt);\n            }\n            return this;\n        }\n\n        /**\n         * Creates the new instance.\n         *\n         * @return the new instance.\n         */\n        public CommandLine build() {\n            return new CommandLine(args, options, deprecatedHandler);\n        }\n\n        /**\n         * Sets the deprecated option handler.\n         *\n         * @param deprecatedHandler the deprecated option handler.\n         * @return {@code this} instance.\n         * @since 1.7.0\n         */\n        public Builder setDeprecatedHandler(final Consumer<Option> deprecatedHandler) {\n            this.deprecatedHandler = deprecatedHandler;\n            return this;\n        }\n    }\n\n    /** The serial version UID. */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Creates a new builder.\n     *\n     * @return a new builder.\n     * @since 1.7.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    /** The unrecognized options/arguments */\n    private final List<String> args;\n\n    /** The processed options */\n    private final List<Option> options;\n\n    /**\n     * The deprecated option handler.\n     * <p>\n     * If you want to serialize this field, use a serialization proxy.\n     * </p>\n     */\n    private final transient Consumer<Option> deprecatedHandler;\n\n    /**\n     * Creates a command line.\n     */\n    protected CommandLine() {\n        this(new LinkedList<>(), new ArrayList<>(), Builder.DEPRECATED_HANDLER);\n    }\n\n    /**\n     * Creates a command line.\n     */\n    private CommandLine(final List<String> args, final List<Option> options, final Consumer<Option> deprecatedHandler) {\n        this.args = Objects.requireNonNull(args, \"args\");\n        this.options = Objects.requireNonNull(options, \"options\");\n        this.deprecatedHandler = deprecatedHandler;\n    }\n\n    /**\n     * Adds left-over unrecognized option/argument.\n     *\n     * @param arg the unrecognized option/argument.\n     */\n    protected void addArg(final String arg) {\n        if (arg != null) {\n            args.add(arg);\n        }\n    }\n\n    /**\n     * Adds an option to the command line. The values of the option are stored.\n     *\n     * @param opt the processed option.\n     */\n    protected void addOption(final Option opt) {\n        if (opt != null) {\n            options.add(opt);\n        }\n    }\n\n    private <T> T get(final Supplier<T> supplier) {\n        return supplier == null ? null : supplier.get();\n    }\n\n    /**\n     * Gets any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as a {@code List}.\n     */\n    public List<String> getArgList() {\n        return args;\n    }\n\n    /**\n     * Gets any left-over non-recognized options and arguments\n     *\n     * @return remaining items passed in but not parsed as an array.\n     */\n    public String[] getArgs() {\n        return args.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the {@code Object} type of this {@code Option}.\n     *\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(char)\n     * @param opt the name of the option.\n     * @return the type of opt.\n     */\n    @Deprecated\n    public Object getOptionObject(final char opt) {\n        return getOptionObject(String.valueOf(opt));\n    }\n\n    /**\n     * Gets the {@code Object} type of this {@code Option}.\n     *\n     * @param opt the name of the option.\n     * @return the type of this {@code Option}.\n     * @deprecated due to System.err message. Instead use getParsedOptionValue(String)\n     */\n    @Deprecated\n    public Object getOptionObject(final String opt) {\n        try {\n            return getParsedOptionValue(opt);\n        } catch (final ParseException pe) {\n            System.err.println(\"Exception found converting \" + opt + \" to desired type: \" + pe.getMessage());\n            return null;\n        }\n    }\n\n    /**\n     * Gets the map of values associated to the option. This is convenient for options specifying Java properties like\n     * <code>-Dparam1=value1\n     * -Dparam2=value2</code>. All odd numbered values are property keys\n     * and even numbered values are property values.  If there are an odd number of values\n     * the last value is assumed to be a boolean flag and the value is \"true\".\n     *\n     * @param option name of the option.\n     * @return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n     * @since 1.5.0\n     */\n    public Properties getOptionProperties(final Option option) {\n        final Properties props = new Properties();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                processPropertiesFromValues(props, processedOption.getValuesList());\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Gets the map of values associated to the option. This is convenient for options specifying Java properties like\n     * <code>-Dparam1=value1\n     * -Dparam2=value2</code>. The first argument of the option is the key, and the 2nd argument is the value. If the option\n     * has only one argument ({@code -Dfoo}) it is considered as a boolean flag and the value is {@code \"true\"}.\n     *\n     * @param opt name of the option.\n     * @return The Properties mapped by the option, never {@code null} even if the option doesn't exists.\n     * @since 1.2\n     */\n    public Properties getOptionProperties(final String opt) {\n        final Properties props = new Properties();\n        for (final Option option : options) {\n            if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt())) {\n                processPropertiesFromValues(props, option.getValuesList());\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Gets an array of the processed {@link Option}s.\n     *\n     * @return an array of the processed {@link Option}s.\n     */\n    public Option[] getOptions() {\n        return options.toArray(Option.EMPTY_ARRAY);\n    }\n\n    /**\n     * Gets the first argument, if any, of this option.\n     *\n     * @param opt the character name of the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String getOptionValue(final char opt) {\n        return getOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Gets the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     */\n    public String getOptionValue(final char opt, final String defaultValue) {\n        return getOptionValue(String.valueOf(opt), () -> defaultValue);\n    }\n\n    /**\n     * Gets the argument, if any, of an option.\n     *\n     * @param opt character name of the option\n     * @param defaultValue is a supplier for the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.7.0\n     */\n    public String getOptionValue(final char opt, final Supplier<String> defaultValue) {\n        return getOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of this option.\n     *\n     * @param option the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     * @since 1.5.0\n     */\n    public String getOptionValue(final Option option) {\n        final String[] values = getOptionValues(option);\n        return values == null ? null : values[0];\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param option the option.\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.5.0\n     */\n    public String getOptionValue(final Option option, final String defaultValue) {\n        return getOptionValue(option, () -> defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param option the option.\n     * @param defaultValue is a supplier for the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.7.0\n     */\n    public String getOptionValue(final Option option, final Supplier<String> defaultValue) {\n        final String answer = getOptionValue(option);\n        return answer != null ? answer : get(defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of this option group.\n     *\n     * @param optionGroup the option group.\n     * @return Value of the argument if option group is selected, and has an argument, otherwise null.\n     * @since 1.9.0\n     */\n    public String getOptionValue(final OptionGroup optionGroup) {\n        final String[] values = getOptionValues(optionGroup);\n        return values == null ? null : values[0];\n    }\n\n    /**\n     * Gets the first argument, if any, of an option group.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue is the default value to be returned if the option group is not selected.\n     * @return Value of the argument if option group is selected, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.9.0\n     */\n    public String getOptionValue(final OptionGroup optionGroup, final String defaultValue) {\n        return getOptionValue(optionGroup, () -> defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of an option group.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue is a supplier for the default value to be returned if the option group is not selected.\n     * @return Value of the argument if option group is selected, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.9.0\n     */\n    public String getOptionValue(final OptionGroup optionGroup, final Supplier<String> defaultValue) {\n        final String answer = getOptionValue(optionGroup);\n        return answer != null ? answer : get(defaultValue);\n    }\n\n\n    /**\n     * Gets the first argument, if any, of this option.\n     *\n     * @param opt the name of the option.\n     * @return Value of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String getOptionValue(final String opt) {\n        return getOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param opt name of the option.\n     * @param defaultValue is the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     */\n    public String getOptionValue(final String opt, final String defaultValue) {\n        return getOptionValue(resolveOption(opt), () -> defaultValue);\n    }\n\n    /**\n     * Gets the first argument, if any, of an option.\n     *\n     * @param opt name of the option.\n     * @param defaultValue is a supplier for the default value to be returned if the option is not specified.\n     * @return Value of the argument if option is set, and has an argument, otherwise {@code defaultValue}.\n     * @since 1.7.0\n     */\n    public String getOptionValue(final String opt, final Supplier<String> defaultValue) {\n        return getOptionValue(resolveOption(opt), defaultValue);\n    }\n\n\n    /**\n     * Gets the array of values, if any, of an option.\n     *\n     * @param opt character name of the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String[] getOptionValues(final char opt) {\n        return getOptionValues(String.valueOf(opt));\n    }\n\n    /**\n     * Gets the array of values, if any, of an option.\n     *\n     * @param option the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     * @since 1.5.0\n     */\n    public String[] getOptionValues(final Option option) {\n        if (option == null) {\n            return null;\n        }\n        final List<String> values = new ArrayList<>();\n        for (final Option processedOption : options) {\n            if (processedOption.equals(option)) {\n                if (option.isDeprecated()) {\n                    handleDeprecated(option);\n                }\n                values.addAll(processedOption.getValuesList());\n            }\n        }\n        return values.isEmpty() ? null : values.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Gets the array of values, if any, of an option group.\n     *\n     * @param optionGroup the option group.\n     * @return Values of the argument if option group is selected, and has an argument, otherwise null.\n     * @since 1.9.0\n     */\n    public String[] getOptionValues(final OptionGroup optionGroup) {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return null;\n        }\n        return getOptionValues(optionGroup.getSelected());\n    }\n\n    /**\n     * Gets the array of values, if any, of an option.\n     *\n     * @param opt string name of the option.\n     * @return Values of the argument if option is set, and has an argument, otherwise null.\n     */\n    public String[] getOptionValues(final String opt) {\n        return getOptionValues(resolveOption(opt));\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5.0\n     */\n    public <T> T getParsedOptionValue(final char opt) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt));\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final char opt, final Supplier<T> defaultValue) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final char opt, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(String.valueOf(opt), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the option.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.5.0\n     */\n    public <T> T getParsedOptionValue(final Option option) throws ParseException {\n        return getParsedOptionValue(option, () -> null);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getParsedOptionValue(final Option option, final Supplier<T> defaultValue) throws ParseException {\n        if (option == null) {\n            return get(defaultValue);\n        }\n        final String res = getOptionValue(option);\n        try {\n            if (res == null) {\n                return get(defaultValue);\n            }\n            return (T) option.getConverter().apply(res);\n        } catch (final Throwable e) {\n            throw ParseException.wrap(e);\n        }\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param option the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final Option option, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(option, () -> defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code OptionGroup} converted to a particular type.\n     *\n     * @param optionGroup the option group.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the selected option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.9.0\n     */\n    public <T> T getParsedOptionValue(final OptionGroup optionGroup) throws ParseException {\n        return getParsedOptionValue(optionGroup, () -> null);\n    }\n\n    /**\n     * Gets a version of this {@code OptionGroup} converted to a particular type.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the selected option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.9.0\n     */\n    public <T> T getParsedOptionValue(final OptionGroup optionGroup, final Supplier<T> defaultValue) throws ParseException {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return get(defaultValue);\n        }\n        return getParsedOptionValue(optionGroup.getSelected(), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code OptionGroup} converted to a particular type.\n     *\n     * @param optionGroup the option group.\n     * @param defaultValue the default value to return if an option is not selected.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.9.0\n     */\n    public <T> T getParsedOptionValue(final OptionGroup optionGroup, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(optionGroup, () -> defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.2\n     */\n    public <T> T getParsedOptionValue(final String opt) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt));\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final String opt, final Supplier<T> defaultValue) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }\n\n    /**\n     * Gets a version of this {@code Option} converted to a particular type.\n     *\n     * @param opt the name of the option.\n     * @param defaultValue the default value to return if opt is not set.\n     * @param <T> The return type for the method.\n     * @return the value parsed into a particular object.\n     * @throws ParseException if there are problems turning the option value into the desired type\n     * @see PatternOptionBuilder\n     * @since 1.7.0\n     */\n    public <T> T getParsedOptionValue(final String opt, final T defaultValue) throws ParseException {\n        return getParsedOptionValue(resolveOption(opt), defaultValue);\n    }\n\n    /**\n     * Handles deprecated options.\n     *\n     * @param option a deprecated option.\n     */\n    private void handleDeprecated(final Option option) {\n        if (deprecatedHandler != null) {\n            deprecatedHandler.accept(option);\n        }\n    }\n\n    /**\n     * jkeyes - commented out until it is implemented properly\n     * <p>\n     * Dump state, suitable for debugging.\n     * </p>\n     *\n     * @return Stringified form of this object.\n     */\n\n    /*\n     * public String toString() { StringBuilder buf = new StringBuilder();\n     *\n     * buf.append(\"[ CommandLine: [ options: \"); buf.append(options.toString()); buf.append(\" ] [ args: \");\n     * buf.append(args.toString()); buf.append(\" ] ]\");\n     *\n     * return buf.toString(); }\n     */\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt character name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final char opt) {\n        return hasOption(String.valueOf(opt));\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt the option to check.\n     * @return true if set, false if not.\n     * @since 1.5.0\n     */\n    public boolean hasOption(final Option opt) {\n        final boolean result = options.contains(opt);\n        if (result && opt.isDeprecated()) {\n            handleDeprecated(opt);\n        }\n        return result;\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param optionGroup the option group to check.\n     * @return true if set, false if not.\n     * @since 1.9.0\n     */\n    public boolean hasOption(final OptionGroup optionGroup) {\n        if (optionGroup == null || !optionGroup.isSelected()) {\n            return false;\n        }\n        return hasOption(optionGroup.getSelected());\n    }\n\n    /**\n     * Tests to see if an option has been set.\n     *\n     * @param opt Short name of the option.\n     * @return true if set, false if not.\n     */\n    public boolean hasOption(final String opt) {\n        return hasOption(resolveOption(opt));\n    }\n\n    /**\n     * Returns an iterator over the Option members of CommandLine.\n     *\n     * @return an {@code Iterator} over the processed {@link Option} members of this {@link CommandLine}.\n     */\n    public Iterator<Option> iterator() {\n        return options.iterator();\n    }\n\n    /**\n     * Parses a list of values as properties.  All odd numbered values are property keys\n     * and even numbered values are property values.  If there are an odd number of values\n     * the last value is assumed to be a boolean with a value of \"true\".\n     * @param props the properties to update.\n     * @param values the list of values to parse.\n     */\n    private void processPropertiesFromValues(final Properties props, final List<String> values) {\n        for (int i = 0; i < values.size(); i += 2) {\n            if (i + 1 < values.size()) {\n                props.put(values.get(i), values.get(i + 1));\n            } else {\n                props.put(values.get(i), \"true\");\n            }\n        }\n    }\n\n    /**\n     * Retrieves the option object given the long or short option as a String\n     *\n     * @param opt short or long name of the option, may be null.\n     * @return Canonicalized option.\n     */\n    private Option resolveOption(final String opt) {\n        final String actual = Util.stripLeadingHyphens(opt);\n        if (actual != null) {\n            for (final Option option : options) {\n                if (actual.equals(option.getOpt()) || actual.equals(option.getLongOpt())) {\n                    return option;\n                }\n            }\n        }\n        return null;\n    }\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final List<String> args;", "docstring": " The unrecognized options/arguments", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "args", "syntax_pass": true}, {"attribute_expression": "private final List<Option> options;", "docstring": " The processed options", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Option>", "name": "options", "syntax_pass": true}, {"attribute_expression": "private final transient Consumer<Option> deprecatedHandler;", "docstring": "\nThe deprecated option handler.\n<p>\nIf you want to serialize this field, use a serialization proxy.\n</p>\n", "modifiers": "private final transient", "marker_annotations": [], "non_marker_annotations": ["private", "final", "transient"], "comments": [], "type": "Consumer<Option>", "name": "deprecatedHandler", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/DeprecatedAttributes.java.DeprecatedAttributes", "name": "DeprecatedAttributes", "file_path": "src/main/java/org/apache/commons/cli/DeprecatedAttributes.java", "superclasses": "", "methods": ["[Builder]builder()", "[]DeprecatedAttributes(String,String,boolean)", "[String]getDescription()", "[String]getSince()", "[boolean]isForRemoval()", "[String]toEmpty(String)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/cli/DeprecatedAttributes.java.DeprecatedAttributes.[Builder]builder()", "src/main/java/org/apache/commons/cli/DeprecatedAttributes.java.DeprecatedAttributes.[]DeprecatedAttributes(String,String,boolean)", "src/main/java/org/apache/commons/cli/DeprecatedAttributes.java.DeprecatedAttributes.[String]getDescription()", "src/main/java/org/apache/commons/cli/DeprecatedAttributes.java.DeprecatedAttributes.[String]getSince()", "src/main/java/org/apache/commons/cli/DeprecatedAttributes.java.DeprecatedAttributes.[boolean]isForRemoval()", "src/main/java/org/apache/commons/cli/DeprecatedAttributes.java.DeprecatedAttributes.[String]toEmpty(String)", "src/main/java/org/apache/commons/cli/DeprecatedAttributes.java.DeprecatedAttributes.[String]toString()"], "overrides": null, "attributes": [{"original_string": "    public static class Builder implements Supplier<DeprecatedAttributes> {\n\n        /** The description. */\n        private String description;\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        private boolean forRemoval;\n\n        /**\n         * The version in which the option became deprecated.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.since</a>\n         */\n        private String since;\n\n        @Override\n        public DeprecatedAttributes get() {\n            return new DeprecatedAttributes(description, since, forRemoval);\n        }\n\n        /**\n         * Sets the description.\n         *\n         * @param description the description.\n         * @return {@code this} instance.\n         */\n        public Builder setDescription(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @param forRemoval whether this is subject to removal in a future version.\n         * @return {@code this} instance.\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        public Builder setForRemoval(final boolean forRemoval) {\n            this.forRemoval = forRemoval;\n            return this;\n        }\n\n        /**\n         * Sets the version in which the option became deprecated.\n         *\n         * @param since the version in which the option became deprecated.\n         * @return {@code this} instance.\n         */\n        public Builder setSince(final String since) {\n            this.since = since;\n            return this;\n        }\n    }", "definition": "    public static class Builder implements Supplier<DeprecatedAttributes>", "class_docstring": "\nBuilds {@link DeprecatedAttributes}.\n", "name": "Builder", "super_interfaces": ["Supplier<DeprecatedAttributes>"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String description;", "docstring": " The description.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private boolean forRemoval;", "docstring": "\nWhether this option is subject to removal in a future version.\n\n@see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "forRemoval", "syntax_pass": true}, {"attribute_expression": "private String since;", "docstring": "\nThe version in which the option became deprecated.\n\n@see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.since</a>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "since", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public DeprecatedAttributes get() {\n            return new DeprecatedAttributes(description, since, forRemoval);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DeprecatedAttributes", "classes": []}, "name": "get", "params": [], "body": "                                          {\n            return new DeprecatedAttributes(description, since, forRemoval);\n        }", "signature": "@Override\n        public DeprecatedAttributes get()"}, {"syntax_pass": true, "original_string": "        public Builder setDescription(final String description) {\n            this.description = description;\n            return this;\n        }", "docstring": "\nSets the description.\n\n@param description the description.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setDescription", "params": [{"name": "description", "type": "String"}], "body": "                                                                {\n            this.description = description;\n            return this;\n        }", "signature": "public Builder setDescription(final String description)"}, {"syntax_pass": true, "original_string": "        public Builder setForRemoval(final boolean forRemoval) {\n            this.forRemoval = forRemoval;\n            return this;\n        }", "docstring": "\nWhether this option is subject to removal in a future version.\n\n@param forRemoval whether this is subject to removal in a future version.\n@return {@code this} instance.\n@see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setForRemoval", "params": [{"name": "forRemoval", "type": "boolean"}], "body": "                                                               {\n            this.forRemoval = forRemoval;\n            return this;\n        }", "signature": "public Builder setForRemoval(final boolean forRemoval)"}, {"syntax_pass": true, "original_string": "        public Builder setSince(final String since) {\n            this.since = since;\n            return this;\n        }", "docstring": "\nSets the version in which the option became deprecated.\n\n@param since the version in which the option became deprecated.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setSince", "params": [{"name": "since", "type": "String"}], "body": "                                                    {\n            this.since = since;\n            return this;\n        }", "signature": "public Builder setSince(final String since)"}]}], "class_docstring": "\nDeprecated attributes.\n<p>\nNote: This class isn't called \"Deprecated\" to avoid clashing with \"java.lang.Deprecated\".\n</p>\n<p>\nIf you want to serialize this class, use a serialization proxy.\n</p>\n\n@since 1.7.0\n@see Deprecated\n", "original_string": "public final class DeprecatedAttributes {\n\n    /**\n     * Builds {@link DeprecatedAttributes}.\n     */\n    public static class Builder implements Supplier<DeprecatedAttributes> {\n\n        /** The description. */\n        private String description;\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        private boolean forRemoval;\n\n        /**\n         * The version in which the option became deprecated.\n         *\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.since</a>\n         */\n        private String since;\n\n        @Override\n        public DeprecatedAttributes get() {\n            return new DeprecatedAttributes(description, since, forRemoval);\n        }\n\n        /**\n         * Sets the description.\n         *\n         * @param description the description.\n         * @return {@code this} instance.\n         */\n        public Builder setDescription(final String description) {\n            this.description = description;\n            return this;\n        }\n\n        /**\n         * Whether this option is subject to removal in a future version.\n         *\n         * @param forRemoval whether this is subject to removal in a future version.\n         * @return {@code this} instance.\n         * @see <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Deprecated.html#forRemoval()\">Deprecated.forRemoval</a>\n         */\n        public Builder setForRemoval(final boolean forRemoval) {\n            this.forRemoval = forRemoval;\n            return this;\n        }\n\n        /**\n         * Sets the version in which the option became deprecated.\n         *\n         * @param since the version in which the option became deprecated.\n         * @return {@code this} instance.\n         */\n        public Builder setSince(final String since) {\n            this.since = since;\n            return this;\n        }\n    }\n\n    /**\n     * The default value for a DeprecatedAttributes.\n     */\n    static final DeprecatedAttributes DEFAULT = new DeprecatedAttributes(\"\", \"\", false);\n\n    /**\n     * The empty string.\n     */\n    private static final String EMPTY_STRING = \"\";\n\n    /**\n     * Creates a new builder.\n     *\n     * @return a new builder.\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    /** The description. */\n    private final String description;\n\n    /** Whether this option will be removed. */\n    private final boolean forRemoval;\n\n    /** The version label for removal. */\n    private final String since;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param description The description.\n     * @param since       The version label for removal.\n     * @param forRemoval  Whether this option will be removed.\n     */\n    private DeprecatedAttributes(final String description, final String since, final boolean forRemoval) {\n        this.description = toEmpty(description);\n        this.since = toEmpty(since);\n        this.forRemoval = forRemoval;\n    }\n\n    /**\n     * Gets the descriptions.\n     *\n     * @return the descriptions.\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Gets version in which the option became deprecated.\n     *\n     * @return the version in which the option became deprecated.\n     */\n    public String getSince() {\n        return since;\n    }\n\n    /**\n     * Tests whether this option is subject to removal in a future version.\n     *\n     * @return whether this option is subject to removal in a future version.\n     */\n    public boolean isForRemoval() {\n        return forRemoval;\n    }\n\n    private String toEmpty(final String since) {\n        return since != null ? since : EMPTY_STRING;\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder(\"Deprecated\");\n        if (forRemoval) {\n            builder.append(\" for removal\");\n        }\n        if (!since.isEmpty()) {\n            builder.append(\" since \");\n            builder.append(since);\n        }\n        if (!description.isEmpty()) {\n            builder.append(\": \");\n            builder.append(description);\n        }\n        return builder.toString();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final DeprecatedAttributes DEFAULT = new DeprecatedAttributes(\"\", \"\", false);", "docstring": "\nThe default value for a DeprecatedAttributes.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "DeprecatedAttributes", "name": "DEFAULT = new DeprecatedAttributes(\"\", \"\", false)", "syntax_pass": true}, {"attribute_expression": "private static final String EMPTY_STRING = \"\";", "docstring": "\nThe empty string.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "EMPTY_STRING = \"\"", "syntax_pass": true}, {"attribute_expression": "private final String description;", "docstring": " The description.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private final boolean forRemoval;", "docstring": " Whether this option will be removed.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "forRemoval", "syntax_pass": true}, {"attribute_expression": "private final String since;", "docstring": " The version label for removal.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "since", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder", "name": "OptionBuilder", "file_path": "src/main/java/org/apache/commons/cli/OptionBuilder.java", "superclasses": "", "methods": ["[Option]create()", "[Option]create(char)", "[Option]create(String)", "[OptionBuilder]hasArg()", "[OptionBuilder]hasArg(boolean)", "[OptionBuilder]hasArgs()", "[OptionBuilder]hasArgs(int)", "[OptionBuilder]hasOptionalArg()", "[OptionBuilder]hasOptionalArgs()", "[OptionBuilder]hasOptionalArgs(int)", "[OptionBuilder]isRequired()", "[OptionBuilder]isRequired(boolean)", "[void]reset()", "[OptionBuilder]withArgName(String)", "[OptionBuilder]withDescription(String)", "[OptionBuilder]withLongOpt(String)", "[OptionBuilder]withType(Class<?>)", "[OptionBuilder]withType(Object)", "[OptionBuilder]withValueSeparator()", "[OptionBuilder]withValueSeparator(char)", "[]OptionBuilder()"], "method_uris": ["src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[Option]create()", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[Option]create(char)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[Option]create(String)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]hasArg()", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]hasArg(boolean)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]hasArgs()", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]hasArgs(int)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]hasOptionalArg()", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]hasOptionalArgs()", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]hasOptionalArgs(int)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]isRequired()", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]isRequired(boolean)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[void]reset()", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]withArgName(String)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]withDescription(String)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]withLongOpt(String)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]withType(Class<?>)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]withType(Object)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]withValueSeparator()", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[OptionBuilder]withValueSeparator(char)", "src/main/java/org/apache/commons/cli/OptionBuilder.java.OptionBuilder.[]OptionBuilder()"], "overrides": null, "attributes": [], "class_docstring": "\nOptionBuilder allows the user to create Options using descriptive methods.\n<p>\nDetails on the Builder pattern can be found at\n<a href=\"https://c2.com/cgi-bin/wiki?BuilderPattern\">https://c2.com/cgi-bin/wiki?BuilderPattern</a>.\n<p>\nThis class is NOT thread safe. See <a href=\"https://issues.apache.org/jira/browse/CLI-209\">CLI-209</a>\n\n@since 1.0\n@deprecated since 1.3, use {@link Option#builder(String)} instead\n", "original_string": "@Deprecated\npublic final class OptionBuilder {\n\n    /** Long option */\n    private static String longOption;\n\n    /** Option description */\n    private static String description;\n\n    /** Argument name */\n    private static String argName;\n\n    /** Is required? */\n    private static boolean required;\n\n    /** The number of arguments */\n    private static int argCount = Option.UNINITIALIZED;\n\n    /** Option type */\n    private static Class<?> type;\n\n    /** Option can have an optional argument value */\n    private static boolean optionalArg;\n\n    /** Value separator for argument value */\n    private static char valueSeparator;\n\n    /** Option builder instance */\n    private static final OptionBuilder INSTANCE = new OptionBuilder();\n\n    static {\n        // ensure the consistency of the initial values\n        reset();\n    }\n\n    /**\n     * Creates an Option using the current settings\n     *\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code longOpt} has not been set.\n     */\n    public static Option create() throws IllegalArgumentException {\n        if (longOption == null) {\n            reset();\n            throw new IllegalArgumentException(\"must specify longopt\");\n        }\n\n        return create(null);\n    }\n\n    /**\n     * Creates an Option using the current settings and with the specified Option {@code char}.\n     *\n     * @param opt the character representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n     */\n    public static Option create(final char opt) throws IllegalArgumentException {\n        return create(String.valueOf(opt));\n    }\n\n    /**\n     * Creates an Option using the current settings and with the specified Option {@code char}.\n     *\n     * @param opt the {@code String} representation of the Option\n     * @return the Option instance\n     * @throws IllegalArgumentException if {@code opt} is not a valid character. See Option.\n     */\n    public static Option create(final String opt) throws IllegalArgumentException {\n        Option option;\n        try {\n            // create the option\n            option = new Option(opt, description);\n\n            // set the option properties\n            option.setLongOpt(longOption);\n            option.setRequired(required);\n            option.setOptionalArg(optionalArg);\n            option.setArgs(argCount);\n            option.setType(type);\n            option.setConverter(TypeHandler.getDefault().getConverter(type));\n            option.setValueSeparator(valueSeparator);\n            option.setArgName(argName);\n        } finally {\n            // reset the OptionBuilder properties\n            reset();\n        }\n\n        // return the Option instance\n        return option;\n    }\n\n    /**\n     * The next Option created will require an argument value.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg() {\n        argCount = 1;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will require an argument value if {@code hasArg} is true.\n     *\n     * @param hasArg if true then the Option has an argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArg(final boolean hasArg) {\n        argCount = hasArg ? 1 : Option.UNINITIALIZED;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have unlimited argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs() {\n        argCount = Option.UNLIMITED_VALUES;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created can have {@code num} argument values.\n     *\n     * @param num the number of args that the option can have\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasArgs(final int num) {\n        argCount = num;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an optional argument.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArg() {\n        argCount = 1;\n        optionalArg = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have an unlimited number of optional arguments.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs() {\n        argCount = Option.UNLIMITED_VALUES;\n        optionalArg = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option can have the specified number of optional arguments.\n     *\n     * @param numArgs   the maximum number of optional arguments the next Option created can have.\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder hasOptionalArgs(final int numArgs) {\n        argCount = numArgs;\n        optionalArg = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired() {\n        required = true;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will be required if {@code required} is true.\n     *\n     * @param newRequired if true then the Option is required\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder isRequired(final boolean newRequired) {\n        required = newRequired;\n        return INSTANCE;\n    }\n\n    /**\n     * Resets the member variables to their default values.\n     */\n    private static void reset() {\n        description = null;\n        argName = null;\n        longOption = null;\n        type = String.class;\n        required = false;\n        argCount = Option.UNINITIALIZED;\n        optionalArg = false;\n        valueSeparator = (char) 0;\n    }\n\n    /**\n     * The next Option created will have the specified argument value name.\n     *\n     * @param name the name for the argument value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withArgName(final String name) {\n        argName = name;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the specified description\n     *\n     * @param newDescription a description of the Option's purpose\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withDescription(final String newDescription) {\n        description = newDescription;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have the following long option value.\n     *\n     * @param newLongopt the long option value\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withLongOpt(final String newLongopt) {\n        longOption = newLongopt;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance of {@code type}.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @since 1.3\n     */\n    public static OptionBuilder withType(final Class<?> newType) {\n        type = newType;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created will have a value that will be an instance of {@code type}.\n     * <p>\n     * <b>Note:</b> this method is kept for binary compatibility and the input type is supposed to be a {@link Class}\n     * object.\n     *\n     * @param newType the type of the Options argument value\n     * @return the OptionBuilder instance\n     * @deprecated since 1.3, use {@link #withType(Class)} instead\n     */\n    @Deprecated\n    public static OptionBuilder withType(final Object newType) {\n        return withType((Class<?>) newType);\n    }\n\n    /**\n     * The next Option created uses '{@code =}' as a means to separate argument values.\n     *\n     * <b>Example:</b>\n     *\n     * <pre>\n     * Option opt = withValueSeparator().create('D');\n     *\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0);\n     * String propertyValue = opt.getValue(1);\n     * </pre>\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator() {\n        valueSeparator = Char.EQUAL;\n        return INSTANCE;\n    }\n\n    /**\n     * The next Option created uses {@code sep} as a means to separate argument values.\n     * <p>\n     * <b>Example:</b>\n     *\n     * <pre>\n     * Option opt = OptionBuilder.withValueSeparator('=').create('D');\n     *\n     * String args = \"-Dkey=value\";\n     * CommandLine line = parser.parse(args);\n     * String propertyName = opt.getValue(0); // will be \"key\"\n     * String propertyValue = opt.getValue(1); // will be \"value\"\n     * </pre>\n     *\n     * @param sep The value separator to be used for the argument values.\n     *\n     * @return the OptionBuilder instance\n     */\n    public static OptionBuilder withValueSeparator(final char sep) {\n        valueSeparator = sep;\n        return INSTANCE;\n    }\n\n    /**\n     * private constructor to prevent instances being created\n     */\n    private OptionBuilder() {\n        // hide the constructor\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static String longOption;", "docstring": " Long option", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "longOption", "syntax_pass": true}, {"attribute_expression": "private static String description;", "docstring": " Option description", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "description", "syntax_pass": true}, {"attribute_expression": "private static String argName;", "docstring": " Argument name", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "argName", "syntax_pass": true}, {"attribute_expression": "private static boolean required;", "docstring": " Is required?", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "boolean", "name": "required", "syntax_pass": true}, {"attribute_expression": "private static int argCount = Option.UNINITIALIZED;", "docstring": " The number of arguments", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "int", "name": "argCount = Option.UNINITIALIZED", "syntax_pass": true}, {"attribute_expression": "private static Class<?> type;", "docstring": " Option type", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Class<?>", "name": "type", "syntax_pass": true}, {"attribute_expression": "private static boolean optionalArg;", "docstring": " Option can have an optional argument value", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "boolean", "name": "optionalArg", "syntax_pass": true}, {"attribute_expression": "private static char valueSeparator;", "docstring": " Value separator for argument value", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "char", "name": "valueSeparator", "syntax_pass": true}, {"attribute_expression": "private static final OptionBuilder INSTANCE = new OptionBuilder();", "docstring": " Option builder instance", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "OptionBuilder", "name": "INSTANCE = new OptionBuilder()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter", "name": "HelpFormatter", "file_path": "src/main/java/org/apache/commons/cli/HelpFormatter.java", "superclasses": "", "methods": ["[Builder]builder()", "[PrintWriter]createDefaultPrintWriter()", "[String]getDescription(Option)", "[]HelpFormatter()", "[]HelpFormatter(Function<Option, String>,PrintWriter,boolean)", "[void]appendOption(StringBuilder,Option,boolean)", "[void]appendOptionGroup(StringBuilder,OptionGroup)", "[A]appendOptions(A,int,Options,int,int)", "[A]appendWrappedText(A,int,int,String)", "[String]createPadding(int)", "[int]determineMaxSinceLength(Options)", "[int]findWrapPos(String,int,int)", "[String]getArgName()", "[int]getDescPadding()", "[int]getLeftPadding()", "[String]getLongOptPrefix()", "[String]getLongOptSeparator()", "[String]getNewLine()", "[Comparator<Option>]getOptionComparator()", "[String]getOptPrefix()", "[String]getSyntaxPrefix()", "[int]getWidth()", "[void]printHelp(int,String,String,Options,String)", "[void]printHelp(int,String,String,Options,String,boolean)", "[void]printHelp(PrintWriter,int,String,String,Options,int,int,String)", "[void]printHelp(PrintWriter,int,String,String,Options,int,int,String,boolean)", "[void]printHelp(String,Options)", "[void]printHelp(String,Options,boolean)", "[void]printHelp(String,String,Options,String)", "[void]printHelp(String,String,Options,String,boolean)", "[void]printOptions(PrintWriter,int,Options,int,int)", "[void]printUsage(PrintWriter,int,String)", "[void]printUsage(PrintWriter,int,String,Options)", "[void]printWrapped(PrintWriter,int,int,String)", "[void]printWrapped(PrintWriter,int,String)", "[StringBuffer]renderOptions(StringBuffer,int,Options,int,int)", "[StringBuffer]renderWrappedText(StringBuffer,int,int,String)", "[A]renderWrappedTextBlock(A,int,int,String)", "[String]rtrim(String)", "[void]setArgName(String)", "[void]setDescPadding(int)", "[void]setLeftPadding(int)", "[void]setLongOptPrefix(String)", "[void]setLongOptSeparator(String)", "[void]setNewLine(String)", "[void]setOptionComparator(Comparator<Option>)", "[void]setOptPrefix(String)", "[void]setSyntaxPrefix(String)", "[void]setWidth(int)"], "method_uris": ["src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[Builder]builder()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[PrintWriter]createDefaultPrintWriter()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[String]getDescription(Option)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[]HelpFormatter()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[]HelpFormatter(Function<Option, String>,PrintWriter,boolean)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]appendOption(StringBuilder,Option,boolean)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]appendOptionGroup(StringBuilder,OptionGroup)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[A]appendOptions(A,int,Options,int,int)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[A]appendWrappedText(A,int,int,String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[String]createPadding(int)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[int]determineMaxSinceLength(Options)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[int]findWrapPos(String,int,int)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[String]getArgName()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[int]getDescPadding()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[int]getLeftPadding()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[String]getLongOptPrefix()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[String]getLongOptSeparator()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[String]getNewLine()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[Comparator<Option>]getOptionComparator()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[String]getOptPrefix()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[String]getSyntaxPrefix()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[int]getWidth()", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printHelp(int,String,String,Options,String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printHelp(int,String,String,Options,String,boolean)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printHelp(PrintWriter,int,String,String,Options,int,int,String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printHelp(PrintWriter,int,String,String,Options,int,int,String,boolean)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printHelp(String,Options)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printHelp(String,Options,boolean)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printHelp(String,String,Options,String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printHelp(String,String,Options,String,boolean)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printOptions(PrintWriter,int,Options,int,int)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printUsage(PrintWriter,int,String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printUsage(PrintWriter,int,String,Options)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printWrapped(PrintWriter,int,int,String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]printWrapped(PrintWriter,int,String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[StringBuffer]renderOptions(StringBuffer,int,Options,int,int)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[StringBuffer]renderWrappedText(StringBuffer,int,int,String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[A]renderWrappedTextBlock(A,int,int,String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[String]rtrim(String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setArgName(String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setDescPadding(int)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setLeftPadding(int)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setLongOptPrefix(String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setLongOptSeparator(String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setNewLine(String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setOptionComparator(Comparator<Option>)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setOptPrefix(String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setSyntaxPrefix(String)", "src/main/java/org/apache/commons/cli/HelpFormatter.java.HelpFormatter.[void]setWidth(int)"], "overrides": null, "attributes": [{"original_string": "    public static class Builder implements Supplier<HelpFormatter> {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n\n        /**\n         * A function to convert a description (not null) and a deprecated Option (not null) to help description\n         */\n        private static final Function<Option, String> DEFAULT_DEPRECATED_FORMAT = o -> \"[Deprecated] \" + getDescription(o);\n\n        /**\n         * Formatter for deprecated options.\n         */\n        private Function<Option, String> deprecatedFormatFunction = DEFAULT_DEPRECATED_FORMAT;\n\n        /**\n         * The output PrintWriter, defaults to wrapping {@link System#out}.\n         */\n        private PrintWriter printStream = createDefaultPrintWriter();\n\n        /** The flag to determine if the since values should be dispalyed */\n        private boolean showSince;\n\n        @Override\n        public HelpFormatter get() {\n            return new HelpFormatter(deprecatedFormatFunction, printStream, showSince);\n        }\n\n        /**\n         * Sets the output PrintWriter, defaults to wrapping {@link System#out}.\n         *\n         * @param printWriter the output PrintWriter, not null.\n         * @return {@code this} instance.\n         */\n        public Builder setPrintWriter(final PrintWriter printWriter) {\n            this.printStream = Objects.requireNonNull(printWriter, \"printWriter\");\n            return this;\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param useDefaultFormat if {@code true} use the default format, otherwise clear the formatter.\n         * @return {@code this} instance.\n         */\n        public Builder setShowDeprecated(final boolean useDefaultFormat) {\n            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param deprecatedFormatFunction Specify the format for the deprecated options.\n         * @return {@code this} instance.\n         * @since 1.8.0\n         */\n        public Builder setShowDeprecated(final Function<Option, String> deprecatedFormatFunction) {\n            this.deprecatedFormatFunction = deprecatedFormatFunction;\n            return this;\n        }\n\n        /**\n         * Sets whether to show the date the option was first added.\n         * @param showSince if @{code true} the date the options was first added will be shown.\n         * @return this builder.\n         * @since 1.9.0\n         */\n        public Builder setShowSince(final boolean showSince) {\n            this.showSince = showSince;\n            return this;\n        }\n    }", "definition": "    public static class Builder implements Supplier<HelpFormatter>", "class_docstring": "\nBuilds {@link HelpFormatter}.\n\n@since 1.7.0\n", "name": "Builder", "super_interfaces": ["Supplier<HelpFormatter>"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final Function<Option, String> DEFAULT_DEPRECATED_FORMAT = o -> \"[Deprecated] \" + getDescription(o);", "docstring": "\nA function to convert a description (not null) and a deprecated Option (not null) to help description\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Function<Option, String>", "name": "DEFAULT_DEPRECATED_FORMAT = o -> \"[Deprecated] \" + getDescription(o)", "syntax_pass": true}, {"attribute_expression": "private Function<Option, String> deprecatedFormatFunction = DEFAULT_DEPRECATED_FORMAT;", "docstring": "\nFormatter for deprecated options.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Function<Option, String>", "name": "deprecatedFormatFunction = DEFAULT_DEPRECATED_FORMAT", "syntax_pass": true}, {"attribute_expression": "private PrintWriter printStream = createDefaultPrintWriter();", "docstring": "\nThe output PrintWriter, defaults to wrapping {@link System#out}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PrintWriter", "name": "printStream = createDefaultPrintWriter()", "syntax_pass": true}, {"attribute_expression": "private boolean showSince;", "docstring": " The flag to determine if the since values should be dispalyed", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "showSince", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public HelpFormatter get() {\n            return new HelpFormatter(deprecatedFormatFunction, printStream, showSince);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "HelpFormatter", "classes": []}, "name": "get", "params": [], "body": "                                   {\n            return new HelpFormatter(deprecatedFormatFunction, printStream, showSince);\n        }", "signature": "@Override\n        public HelpFormatter get()"}, {"syntax_pass": true, "original_string": "        public Builder setPrintWriter(final PrintWriter printWriter) {\n            this.printStream = Objects.requireNonNull(printWriter, \"printWriter\");\n            return this;\n        }", "docstring": "\nSets the output PrintWriter, defaults to wrapping {@link System#out}.\n\n@param printWriter the output PrintWriter, not null.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setPrintWriter", "params": [{"name": "printWriter", "type": "PrintWriter"}], "body": "                                                                     {\n            this.printStream = Objects.requireNonNull(printWriter, \"printWriter\");\n            return this;\n        }", "signature": "public Builder setPrintWriter(final PrintWriter printWriter)"}, {"syntax_pass": true, "original_string": "        public Builder setShowDeprecated(final boolean useDefaultFormat) {\n            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);\n        }", "docstring": "\nSets whether to show deprecated options.\n\n@param useDefaultFormat if {@code true} use the default format, otherwise clear the formatter.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setShowDeprecated", "params": [{"name": "useDefaultFormat", "type": "boolean"}], "body": "                                                                         {\n            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);\n        }", "signature": "public Builder setShowDeprecated(final boolean useDefaultFormat)"}, {"syntax_pass": true, "original_string": "        public Builder setShowDeprecated(final Function<Option, String> deprecatedFormatFunction) {\n            this.deprecatedFormatFunction = deprecatedFormatFunction;\n            return this;\n        }", "docstring": "\nSets whether to show deprecated options.\n\n@param deprecatedFormatFunction Specify the format for the deprecated options.\n@return {@code this} instance.\n@since 1.8.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setShowDeprecated", "params": [{"name": "deprecatedFormatFunction", "type": "Function<Option, String>"}], "body": "                                                                                                  {\n            this.deprecatedFormatFunction = deprecatedFormatFunction;\n            return this;\n        }", "signature": "public Builder setShowDeprecated(final Function<Option, String> deprecatedFormatFunction)"}, {"syntax_pass": true, "original_string": "        public Builder setShowSince(final boolean showSince) {\n            this.showSince = showSince;\n            return this;\n        }", "docstring": "\nSets whether to show the date the option was first added.\n@param showSince if @{code true} the date the options was first added will be shown.\n@return this builder.\n@since 1.9.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "setShowSince", "params": [{"name": "showSince", "type": "boolean"}], "body": "                                                             {\n            this.showSince = showSince;\n            return this;\n        }", "signature": "public Builder setShowSince(final boolean showSince)"}]}, {"original_string": "    private static final class OptionComparator implements Comparator<Option>, Serializable {\n\n        /** The serial version UID. */\n        private static final long serialVersionUID = 5305467873966684014L;\n\n        /**\n         * Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param opt1 The first Option to be compared.\n         * @param opt2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than\n         *         the second.\n         */\n        @Override\n        public int compare(final Option opt1, final Option opt2) {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }", "definition": "    private static final class OptionComparator implements Comparator<Option>, Serializable", "class_docstring": "\nThis class implements the {@code Comparator} interface for comparing Options.\n", "name": "OptionComparator", "super_interfaces": ["Comparator<Option>", "Serializable"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5305467873966684014L;", "docstring": " The serial version UID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5305467873966684014L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public int compare(final Option opt1, final Option opt2) {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }", "docstring": "\nCompares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument\nis less than, equal to, or greater than the second.\n\n@param opt1 The first Option to be compared.\n@param opt2 The second Option to be compared.\n@return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than\n        the second.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "opt1", "type": "Option"}, {"name": "opt2", "type": "Option"}], "body": "                                                                 {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }", "signature": "@Override\n        public int compare(final Option opt1, final Option opt2)"}]}], "class_docstring": "\nA formatter of help messages for command line options.\n<p>\nExample:\n</p>\n<pre>\nOptions options = new Options();\noptions.addOption(OptionBuilder.withLongOpt(\"file\").withDescription(\"The file to be processed\").hasArg().withArgName(\"FILE\").isRequired().create('f'));\noptions.addOption(OptionBuilder.withLongOpt(\"version\").withDescription(\"Print the version of the application\").create('v'));\noptions.addOption(OptionBuilder.withLongOpt(\"help\").create('h'));\n\nString header = \"Do something useful with an input file\\n\\n\";\nString footer = \"\\nPlease report issues at https://example.com/issues\";\n\nHelpFormatter formatter = new HelpFormatter();\nformatter.printHelp(\"myapp\", header, options, footer, true);\n</pre>\n<p>\nThis produces the following output:\n</p>\n<pre>\nusage: myapp -f &lt;FILE&gt; [-h] [-v]\nDo something useful with an input file\n\n -f,--file &lt;FILE&gt;   The file to be processed\n -h,--help\n -v,--version       Print the version of the application\n\nPlease report issues at https://example.com/issues\n</pre>\n", "original_string": "public class HelpFormatter {\n\n    /**\n     * Builds {@link HelpFormatter}.\n     *\n     * @since 1.7.0\n     */\n    public static class Builder implements Supplier<HelpFormatter> {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n\n        /**\n         * A function to convert a description (not null) and a deprecated Option (not null) to help description\n         */\n        private static final Function<Option, String> DEFAULT_DEPRECATED_FORMAT = o -> \"[Deprecated] \" + getDescription(o);\n\n        /**\n         * Formatter for deprecated options.\n         */\n        private Function<Option, String> deprecatedFormatFunction = DEFAULT_DEPRECATED_FORMAT;\n\n        /**\n         * The output PrintWriter, defaults to wrapping {@link System#out}.\n         */\n        private PrintWriter printStream = createDefaultPrintWriter();\n\n        /** The flag to determine if the since values should be dispalyed */\n        private boolean showSince;\n\n        @Override\n        public HelpFormatter get() {\n            return new HelpFormatter(deprecatedFormatFunction, printStream, showSince);\n        }\n\n        /**\n         * Sets the output PrintWriter, defaults to wrapping {@link System#out}.\n         *\n         * @param printWriter the output PrintWriter, not null.\n         * @return {@code this} instance.\n         */\n        public Builder setPrintWriter(final PrintWriter printWriter) {\n            this.printStream = Objects.requireNonNull(printWriter, \"printWriter\");\n            return this;\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param useDefaultFormat if {@code true} use the default format, otherwise clear the formatter.\n         * @return {@code this} instance.\n         */\n        public Builder setShowDeprecated(final boolean useDefaultFormat) {\n            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);\n        }\n\n        /**\n         * Sets whether to show deprecated options.\n         *\n         * @param deprecatedFormatFunction Specify the format for the deprecated options.\n         * @return {@code this} instance.\n         * @since 1.8.0\n         */\n        public Builder setShowDeprecated(final Function<Option, String> deprecatedFormatFunction) {\n            this.deprecatedFormatFunction = deprecatedFormatFunction;\n            return this;\n        }\n\n        /**\n         * Sets whether to show the date the option was first added.\n         * @param showSince if @{code true} the date the options was first added will be shown.\n         * @return this builder.\n         * @since 1.9.0\n         */\n        public Builder setShowSince(final boolean showSince) {\n            this.showSince = showSince;\n            return this;\n        }\n    }\n\n    /**\n     * This class implements the {@code Comparator} interface for comparing Options.\n     */\n    private static final class OptionComparator implements Comparator<Option>, Serializable {\n\n        /** The serial version UID. */\n        private static final long serialVersionUID = 5305467873966684014L;\n\n        /**\n         * Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument\n         * is less than, equal to, or greater than the second.\n         *\n         * @param opt1 The first Option to be compared.\n         * @param opt2 The second Option to be compared.\n         * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than\n         *         the second.\n         */\n        @Override\n        public int compare(final Option opt1, final Option opt2) {\n            return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n        }\n    }\n    /** \"Options\" text for options header */\n    private static final String HEADER_OPTIONS = \"Options\";\n\n    /** \"Since\" text for options header */\n    private static final String HEADER_SINCE = \"Since\";\n\n    /** \"Description\" test for options header */\n    private static final String HEADER_DESCRIPTION = \"Description\";\n\n    /** Default number of characters per line */\n    public static final int DEFAULT_WIDTH = 74;\n\n    /** Default padding to the left of each line */\n    public static final int DEFAULT_LEFT_PAD = 1;\n\n    /** Number of space characters to be prefixed to each description line */\n    public static final int DEFAULT_DESC_PAD = 3;\n\n    /** The string to display at the beginning of the usage statement */\n    public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";\n\n    /** Default prefix for shortOpts */\n    public static final String DEFAULT_OPT_PREFIX = \"-\";\n\n    /** Default prefix for long Option */\n    public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";\n\n    /**\n     * Default separator displayed between a long Option and its value\n     *\n     * @since 1.3\n     */\n    public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";\n\n    /** Default name for an argument */\n    public static final String DEFAULT_ARG_NAME = \"arg\";\n\n    /**\n     * Creates a new builder.\n     *\n     * @return a new builder.\n     * @since 1.7.0\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    private static PrintWriter createDefaultPrintWriter() {\n        return new PrintWriter(System.out);\n    }\n\n    /**\n     * Gets the option description or an empty string if the description is {@code null}.\n     * @param option The option to get the description from.\n     * @return the option description or an empty string if the description is {@code null}.\n     * @since 1.8.0\n     */\n    public static String getDescription(final Option option) {\n        final String desc = option.getDescription();\n        return desc == null ? \"\" : desc;\n    }\n\n    /**\n     * Number of characters per line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setWidth methods instead.\n     */\n    @Deprecated\n    public int defaultWidth = DEFAULT_WIDTH;\n\n    /**\n     * Amount of padding to the left of each line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setLeftPadding methods instead.\n     */\n    @Deprecated\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;\n\n    /**\n     * The number of characters of padding to be prefixed to each description line\n     *\n     * @deprecated Scope will be made private for next major version - use get/setDescPadding methods instead.\n     */\n    @Deprecated\n    public int defaultDescPad = DEFAULT_DESC_PAD;\n\n    /**\n     * The string to display at the beginning of the usage statement\n     *\n     * @deprecated Scope will be made private for next major version - use get/setSyntaxPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;\n\n    /**\n     * The new line string\n     *\n     * @deprecated Scope will be made private for next major version - use get/setNewLine methods instead.\n     */\n    @Deprecated\n    public String defaultNewLine = System.lineSeparator();\n\n    /**\n     * The shortOpt prefix\n     *\n     * @deprecated Scope will be made private for next major version - use get/setOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;\n\n    /**\n     * The long Opt prefix\n     *\n     * @deprecated Scope will be made private for next major version - use get/setLongOptPrefix methods instead.\n     */\n    @Deprecated\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;\n\n    /**\n     * The name of the argument\n     *\n     * @deprecated Scope will be made private for next major version - use get/setArgName methods instead.\n     */\n    @Deprecated\n    public String defaultArgName = DEFAULT_ARG_NAME;\n\n    /**\n     * Comparator used to sort the options when they output in help text\n     *\n     * Defaults to case-insensitive alphabetical sorting by option key\n     */\n    protected Comparator<Option> optionComparator = new OptionComparator();\n\n    /**\n     * Function to format the description for a deprecated option.\n     */\n    private final Function<Option, String> deprecatedFormatFunction;\n\n    /**\n     * Where to print help.\n     */\n    private final PrintWriter printWriter;\n\n    /** Flag to determine if since field should be displayed */\n    private final boolean showSince;\n\n    /**\n     * The separator displayed between the long option and its value.\n     */\n    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;\n\n    /**\n     * Constructs a new instance.\n     */\n    public HelpFormatter() {\n        this(null, createDefaultPrintWriter(), false);\n    }\n\n    /**\n     * Constructs a new instance.\n     * @param printWriter TODO\n     */\n    private HelpFormatter(final Function<Option, String> deprecatedFormatFunction, final PrintWriter printWriter, final boolean showSince) {\n        // TODO All other instance HelpFormatter instance variables.\n        // Make HelpFormatter immutable for 2.0\n        this.deprecatedFormatFunction = deprecatedFormatFunction;\n        this.printWriter = printWriter;\n        this.showSince = showSince;\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.\n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private void appendOption(final StringBuilder buff, final Option option, final boolean required) {\n        if (!required) {\n            buff.append(\"[\");\n        }\n        if (option.getOpt() != null) {\n            buff.append(\"-\").append(option.getOpt());\n        } else {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n        // if the Option has a value and a non blank argname\n        if (option.hasArg() && (option.getArgName() == null || !option.getArgName().isEmpty())) {\n            buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n            buff.append(\"<\").append(option.getArgName() != null ? option.getArgName() : getArgName()).append(\">\");\n        }\n        // if the Option is not a required option\n        if (!required) {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an OptionGroup to a StringBuffer. The clause is wrapped in square brackets if the group\n     * is required. The display of the options is handled by appendOption\n     *\n     * @param buff the StringBuilder to append to\n     * @param group the group to append\n     * @see #appendOption(StringBuilder,Option,boolean)\n     */\n    private void appendOptionGroup(final StringBuilder buff, final OptionGroup group) {\n        if (!group.isRequired()) {\n            buff.append(\"[\");\n        }\n        final List<Option> optList = new ArrayList<>(group.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // for each option in the OptionGroup\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // whether the option is required or not is handled at group level\n            appendOption(buff, it.next(), true);\n\n            if (it.hasNext()) {\n                buff.append(\" | \");\n            }\n        }\n        if (!group.isRequired()) {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Renders the specified Options and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @return the StringBuffer with the rendered Options contents.\n     * @throws IOException if an I/O error occurs.\n     */\n    <A extends Appendable> A appendOptions(final A sb, final int width, final Options options, final int leftPad, final int descPad) throws IOException {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n        // first create list containing only <lpad>-a,--aaa where\n        // -a is opt and --aaa is long opt; in parallel look for\n        // the longest opt string this list will be then used to\n        // sort options ascending\n        int max = 0;\n        final int maxSince = showSince ? determineMaxSinceLength(options) + leftPad : 0;\n        final List<StringBuilder> prefixList = new ArrayList<>();\n        final List<Option> optList = options.helpOptions();\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        for (final Option option : optList) {\n            final StringBuilder optBuf = new StringBuilder();\n            if (option.getOpt() == null) {\n                optBuf.append(lpad).append(\"   \").append(getLongOptPrefix()).append(option.getLongOpt());\n            } else {\n                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());\n                if (option.hasLongOpt()) {\n                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());\n                }\n            }\n            if (option.hasArg()) {\n                final String argName = option.getArgName();\n                if (argName != null && argName.isEmpty()) {\n                    // if the option has a blank argname\n                    optBuf.append(' ');\n                } else {\n                    optBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\n                    optBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = Math.max(optBuf.length() + maxSince, max);\n        }\n        final int nextLineTabStop = max + descPad;\n        if (showSince) {\n            final StringBuilder optHeader = new StringBuilder(HEADER_OPTIONS).append(createPadding(max - maxSince - HEADER_OPTIONS.length() + leftPad))\n                    .append(HEADER_SINCE);\n            optHeader.append(createPadding(max - optHeader.length())).append(lpad).append(HEADER_DESCRIPTION);\n            appendWrappedText(sb, width, nextLineTabStop, optHeader.toString());\n            sb.append(getNewLine());\n        }\n\n        int x = 0;\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            final Option option = it.next();\n            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());\n            if (optBuf.length() < max) {\n                optBuf.append(createPadding(max - maxSince - optBuf.length()));\n                if (showSince) {\n                    optBuf.append(lpad).append(option.getSince() == null ? \"-\" : option.getSince());\n                }\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n            optBuf.append(dpad);\n\n            if (deprecatedFormatFunction != null && option.isDeprecated()) {\n                optBuf.append(deprecatedFormatFunction.apply(option).trim());\n            } else if (option.getDescription() != null) {\n                optBuf.append(option.getDescription());\n            }\n            appendWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n            if (it.hasNext()) {\n                sb.append(getNewLine());\n            }\n        }\n        return sb;\n    }\n\n    /**\n     * Renders the specified text and return the rendered Options in a StringBuffer.\n     *\n     * @param <A> The Appendable implementation.\n     * @param appendable The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     * @return the StringBuffer with the rendered Options contents.\n     * @throws IOException if an I/O error occurs.\n     */\n    <A extends Appendable> A appendWrappedText(final A appendable, final int width, final int nextLineTabStop, final String text) throws IOException {\n        String render = text;\n        int nextLineTabStopPos = nextLineTabStop;\n        int pos = findWrapPos(render, width, 0);\n        if (pos == -1) {\n            appendable.append(rtrim(render));\n            return appendable;\n        }\n        appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        if (nextLineTabStopPos >= width) {\n            // stops infinite loop happening\n            nextLineTabStopPos = 1;\n        }\n        // all following lines must be padded with nextLineTabStop space characters\n        final String padding = createPadding(nextLineTabStopPos);\n        while (true) {\n            render = padding + render.substring(pos).trim();\n            pos = findWrapPos(render, width, 0);\n            if (pos == -1) {\n                appendable.append(render);\n                return appendable;\n            }\n            if (render.length() > width && pos == nextLineTabStopPos - 1) {\n                pos = width;\n            }\n            appendable.append(rtrim(render.substring(0, pos))).append(getNewLine());\n        }\n    }\n\n    /**\n     * Creates a String of padding of length {@code len}.\n     *\n     * @param len The length of the String of padding to create.\n     *\n     * @return The String of padding\n     */\n    protected String createPadding(final int len) {\n        final char[] padding = new char[len];\n        Arrays.fill(padding, ' ');\n        return new String(padding);\n    }\n\n    private int determineMaxSinceLength(final Options options) {\n        final int minLen = HEADER_SINCE.length();\n        final int len = options.getOptions().stream().map(o -> o.getSince() == null ? minLen : o.getSince().length()).max(Integer::compareTo).orElse(minLen);\n        return len < minLen ? minLen : len;\n    }\n\n    /**\n     * Finds the next text wrap position after {@code startPos} for the text in {@code text} with the column width\n     * {@code width}. The wrap point is the last position before startPos+width having a whitespace character (space,\n     * \\n, \\r). If there is no whitespace character before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace character\n     * @return position on which the text must be wrapped or -1 if the wrap position is at the end of the text\n     */\n    protected int findWrapPos(final String text, final int width, final int startPos) {\n        // the line ends before the max wrap pos or a new line char found\n        int pos = text.indexOf(Char.LF, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        pos = text.indexOf(Char.TAB, startPos);\n        if (pos != -1 && pos <= width) {\n            return pos + 1;\n        }\n        if (startPos + width >= text.length()) {\n            return -1;\n        }\n        // look for the last whitespace character before startPos+width\n        for (pos = startPos + width; pos >= startPos; --pos) {\n            final char c = text.charAt(pos);\n            if (c == Char.SP || c == Char.LF || c == Char.CR) {\n                break;\n            }\n        }\n        // if we found it - just return\n        if (pos > startPos) {\n            return pos;\n        }\n        // if we didn't find one, simply chop at startPos+width\n        pos = startPos + width;\n        return pos == text.length() ? -1 : pos;\n    }\n\n    /**\n     * Gets the 'argName'.\n     *\n     * @return the 'argName'\n     */\n    public String getArgName() {\n        return defaultArgName;\n    }\n\n    /**\n     * Gets the 'descPadding'.\n     *\n     * @return the 'descPadding'\n     */\n    public int getDescPadding() {\n        return defaultDescPad;\n    }\n\n    /**\n     * Gets the 'leftPadding'.\n     *\n     * @return the 'leftPadding'\n     */\n    public int getLeftPadding() {\n        return defaultLeftPad;\n    }\n\n    /**\n     * Gets the 'longOptPrefix'.\n     *\n     * @return the 'longOptPrefix'\n     */\n    public String getLongOptPrefix() {\n        return defaultLongOptPrefix;\n    }\n\n    /**\n     * Gets the separator displayed between a long option and its value.\n     *\n     * @return the separator\n     * @since 1.3\n     */\n    public String getLongOptSeparator() {\n        return longOptSeparator;\n    }\n\n    /**\n     * Gets the 'newLine'.\n     *\n     * @return the 'newLine'\n     */\n    public String getNewLine() {\n        return defaultNewLine;\n    }\n\n    /**\n     * Comparator used to sort the options when they output in help text. Defaults to case-insensitive alphabetical sorting\n     * by option key.\n     *\n     * @return the {@link Comparator} currently in use to sort the options\n     * @since 1.2\n     */\n    public Comparator<Option> getOptionComparator() {\n        return optionComparator;\n    }\n\n    /**\n     * Gets the 'optPrefix'.\n     *\n     * @return the 'optPrefix'\n     */\n    public String getOptPrefix() {\n        return defaultOptPrefix;\n    }\n\n    /**\n     * Gets the 'syntaxPrefix'.\n     *\n     * @return the 'syntaxPrefix'\n     */\n    public String getSyntaxPrefix() {\n        return defaultSyntaxPrefix;\n    }\n\n    /**\n     * Gets the 'width'.\n     *\n     * @return the 'width'\n     */\n    public int getWidth() {\n        return defaultWidth;\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to  {@link System#out}  by default.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(width, cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer,\n        final boolean autoUsage) {\n        final PrintWriter pw = new PrintWriter(printWriter);\n        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);\n        pw.flush();\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @param footer the banner to display at the end of the help\n     *\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer) {\n        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax.\n     *\n     * @param pw the writer to which the help will be written\n     * @param width the number of characters to be displayed on each line\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     * @throws IllegalStateException if there is no room to print a line\n     */\n    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,\n        final int descPad, final String footer, final boolean autoUsage) {\n        if (Util.isEmpty(cmdLineSyntax)) {\n            throw new IllegalArgumentException(\"cmdLineSyntax not provided\");\n        }\n        if (autoUsage) {\n            printUsage(pw, width, cmdLineSyntax, options);\n        } else {\n            printUsage(pw, width, cmdLineSyntax);\n        }\n        if (header != null && !header.isEmpty()) {\n            printWrapped(pw, width, header);\n        }\n        printOptions(pw, width, options, leftPad, descPad);\n        if (footer != null && !footer.isEmpty()) {\n            printWrapped(pw, width, footer);\n        }\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param options the Options instance\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer) {\n        printHelp(cmdLineSyntax, header, options, footer, false);\n    }\n\n    /**\n     * Prints the help for {@code options} with the specified command line syntax. This method prints help information\n     * to {@link System#out} by default.\n     *\n     * @param cmdLineSyntax the syntax for this application\n     * @param header the banner to display at the beginning of the help\n     * @param options the Options instance\n     * @param footer the banner to display at the end of the help\n     * @param autoUsage whether to print an automatically generated usage statement\n     */\n    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {\n        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);\n    }\n\n    /**\n     * Prints the help for the specified Options to the specified writer, using the specified width, left padding and\n     * description padding.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     */\n    public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad) {\n        try {\n            pw.println(appendOptions(new StringBuilder(), width, options, leftPad, descPad));\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Prints the cmdLineSyntax to the specified writer, using the specified width.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax) {\n        final int argPos = cmdLineSyntax.indexOf(' ') + 1;\n        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);\n    }\n\n    /**\n     * Prints the usage statement for the specified application.\n     *\n     * @param pw The PrintWriter to print the usage statement\n     * @param width The number of characters to display per line\n     * @param app The application name\n     * @param options The command line Options\n     */\n    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options) {\n        // initialize the string buffer\n        final StringBuilder buff = new StringBuilder(getSyntaxPrefix()).append(app).append(Char.SP);\n        // create a list for processed option groups\n        final Collection<OptionGroup> processedGroups = new ArrayList<>();\n        final List<Option> optList = new ArrayList<>(options.getOptions());\n        if (getOptionComparator() != null) {\n            Collections.sort(optList, getOptionComparator());\n        }\n        // iterate over the options\n        for (final Iterator<Option> it = optList.iterator(); it.hasNext();) {\n            // get the next Option\n            final Option option = it.next();\n            // check if the option is part of an OptionGroup\n            final OptionGroup group = options.getOptionGroup(option);\n            // if the option is part of a group\n            if (group != null) {\n                // and if the group has not already been processed\n                if (!processedGroups.contains(group)) {\n                    // add the group to the processed list\n                    processedGroups.add(group);\n                    // add the usage clause\n                    appendOptionGroup(buff, group);\n                }\n                // otherwise the option was displayed in the group\n                // previously so ignore it.\n            }\n            // if the Option is not part of an OptionGroup\n            else {\n                appendOption(buff, option, option.isRequired());\n            }\n            if (it.hasNext()) {\n                buff.append(Char.SP);\n            }\n        }\n\n        // call printWrapped\n        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n    }\n\n    /**\n     * Prints the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text) {\n        pw.println(renderWrappedTextBlock(new StringBuilder(text.length()), width, nextLineTabStop, text));\n    }\n\n    /**\n     * Prints the specified text to the specified PrintWriter.\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters to display per line\n     * @param text The text to be written to the PrintWriter\n     */\n    public void printWrapped(final PrintWriter pw, final int width, final String text) {\n        printWrapped(pw, width, 0, text);\n    }\n\n    /**\n     * Renders the specified Options and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered Options into.\n     * @param width The number of characters to display per line\n     * @param options The command line Options\n     * @param leftPad the number of characters of padding to be prefixed to each line\n     * @param descPad the number of characters of padding to be prefixed to each description line\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {\n        try {\n            return appendOptions(sb, width, options, leftPad, descPad);\n        } catch (final IOException e) {\n            // Cannot happen\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Renders the specified text and return the rendered Options in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, final int nextLineTabStop, final String text) {\n        try {\n            return appendWrappedText(sb, width, nextLineTabStop, text);\n        } catch (final IOException e) {\n            // Cannot happen.\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Renders the specified text width a maximum width. This method differs from renderWrappedText by not removing leading\n     * spaces after a new line.\n     *\n     * @param appendable The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     */\n    private <A extends Appendable> A renderWrappedTextBlock(final A appendable, final int width, final int nextLineTabStop, final String text) {\n        try {\n            final BufferedReader in = new BufferedReader(new StringReader(text));\n            String line;\n            boolean firstLine = true;\n            while ((line = in.readLine()) != null) {\n                if (!firstLine) {\n                    appendable.append(getNewLine());\n                } else {\n                    firstLine = false;\n                }\n                appendWrappedText(appendable, width, nextLineTabStop, line);\n            }\n        } catch (final IOException e) { // NOPMD\n            // cannot happen\n        }\n        return appendable;\n    }\n\n    /**\n     * Removes the trailing whitespace from the specified String.\n     *\n     * @param s The String to remove the trailing padding from.\n     * @return The String of without the trailing padding\n     */\n    protected String rtrim(final String s) {\n        if (Util.isEmpty(s)) {\n            return s;\n        }\n        int pos = s.length();\n        while (pos > 0 && Character.isWhitespace(s.charAt(pos - 1))) {\n            --pos;\n        }\n        return s.substring(0, pos);\n    }\n\n    /**\n     * Sets the 'argName'.\n     *\n     * @param name the new value of 'argName'\n     */\n    public void setArgName(final String name) {\n        this.defaultArgName = name;\n    }\n\n    /**\n     * Sets the 'descPadding'.\n     *\n     * @param padding the new value of 'descPadding'\n     */\n    public void setDescPadding(final int padding) {\n        this.defaultDescPad = padding;\n    }\n\n    /**\n     * Sets the 'leftPadding'.\n     *\n     * @param padding the new value of 'leftPadding'\n     */\n    public void setLeftPadding(final int padding) {\n        this.defaultLeftPad = padding;\n    }\n\n    /**\n     * Sets the 'longOptPrefix'.\n     *\n     * @param prefix the new value of 'longOptPrefix'\n     */\n    public void setLongOptPrefix(final String prefix) {\n        this.defaultLongOptPrefix = prefix;\n    }\n\n    /**\n     * Sets the separator displayed between a long option and its value. Ensure that the separator specified is supported by\n     * the parser used, typically ' ' or '='.\n     *\n     * @param longOptSeparator the separator, typically ' ' or '='.\n     * @since 1.3\n     */\n    public void setLongOptSeparator(final String longOptSeparator) {\n        this.longOptSeparator = longOptSeparator;\n    }\n\n    /**\n     * Sets the 'newLine'.\n     *\n     * @param newline the new value of 'newLine'\n     */\n    public void setNewLine(final String newline) {\n        this.defaultNewLine = newline;\n    }\n\n    /**\n     * Sets the comparator used to sort the options when they output in help text. Passing in a null comparator will keep the\n     * options in the order they were declared.\n     *\n     * @param comparator the {@link Comparator} to use for sorting the options\n     * @since 1.2\n     */\n    public void setOptionComparator(final Comparator<Option> comparator) {\n        this.optionComparator = comparator;\n    }\n\n    /**\n     * Sets the 'optPrefix'.\n     *\n     * @param prefix the new value of 'optPrefix'\n     */\n    public void setOptPrefix(final String prefix) {\n        this.defaultOptPrefix = prefix;\n    }\n\n    /**\n     * Sets the 'syntaxPrefix'.\n     *\n     * @param prefix the new value of 'syntaxPrefix'\n     */\n    public void setSyntaxPrefix(final String prefix) {\n        this.defaultSyntaxPrefix = prefix;\n    }\n\n    /**\n     * Sets the 'width'.\n     *\n     * @param width the new value of 'width'\n     */\n    public void setWidth(final int width) {\n        this.defaultWidth = width;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String HEADER_OPTIONS = \"Options\";", "docstring": " \"Options\" text for options header", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "HEADER_OPTIONS = \"Options\"", "syntax_pass": true}, {"attribute_expression": "private static final String HEADER_SINCE = \"Since\";", "docstring": " \"Since\" text for options header", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "HEADER_SINCE = \"Since\"", "syntax_pass": true}, {"attribute_expression": "private static final String HEADER_DESCRIPTION = \"Description\";", "docstring": " \"Description\" test for options header", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "HEADER_DESCRIPTION = \"Description\"", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_WIDTH = 74;", "docstring": " Default number of characters per line", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_WIDTH = 74", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_LEFT_PAD = 1;", "docstring": " Default padding to the left of each line", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_LEFT_PAD = 1", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_DESC_PAD = 3;", "docstring": " Number of space characters to be prefixed to each description line", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_DESC_PAD = 3", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_SYNTAX_PREFIX = \"usage: \";", "docstring": " The string to display at the beginning of the usage statement", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_SYNTAX_PREFIX = \"usage: \"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_OPT_PREFIX = \"-\";", "docstring": " Default prefix for shortOpts", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_OPT_PREFIX = \"-\"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_LONG_OPT_PREFIX = \"--\";", "docstring": " Default prefix for long Option", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_LONG_OPT_PREFIX = \"--\"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_LONG_OPT_SEPARATOR = \" \";", "docstring": "\nDefault separator displayed between a long Option and its value\n\n@since 1.3\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_LONG_OPT_SEPARATOR = \" \"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_ARG_NAME = \"arg\";", "docstring": " Default name for an argument", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_ARG_NAME = \"arg\"", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public int defaultWidth = DEFAULT_WIDTH;", "docstring": "\nNumber of characters per line\n\n@deprecated Scope will be made private for next major version - use get/setWidth methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "defaultWidth = DEFAULT_WIDTH", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public int defaultLeftPad = DEFAULT_LEFT_PAD;", "docstring": "\nAmount of padding to the left of each line\n\n@deprecated Scope will be made private for next major version - use get/setLeftPadding methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "defaultLeftPad = DEFAULT_LEFT_PAD", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public int defaultDescPad = DEFAULT_DESC_PAD;", "docstring": "\nThe number of characters of padding to be prefixed to each description line\n\n@deprecated Scope will be made private for next major version - use get/setDescPadding methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "defaultDescPad = DEFAULT_DESC_PAD", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;", "docstring": "\nThe string to display at the beginning of the usage statement\n\n@deprecated Scope will be made private for next major version - use get/setSyntaxPrefix methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultNewLine = System.lineSeparator();", "docstring": "\nThe new line string\n\n@deprecated Scope will be made private for next major version - use get/setNewLine methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultNewLine = System.lineSeparator()", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;", "docstring": "\nThe shortOpt prefix\n\n@deprecated Scope will be made private for next major version - use get/setOptPrefix methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultOptPrefix = DEFAULT_OPT_PREFIX", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;", "docstring": "\nThe long Opt prefix\n\n@deprecated Scope will be made private for next major version - use get/setLongOptPrefix methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    public String defaultArgName = DEFAULT_ARG_NAME;", "docstring": "\nThe name of the argument\n\n@deprecated Scope will be made private for next major version - use get/setArgName methods instead.\n", "modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "type": "String", "name": "defaultArgName = DEFAULT_ARG_NAME", "syntax_pass": true}, {"attribute_expression": "protected Comparator<Option> optionComparator = new OptionComparator();", "docstring": "\nComparator used to sort the options when they output in help text\n\nDefaults to case-insensitive alphabetical sorting by option key\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Comparator<Option>", "name": "optionComparator = new OptionComparator()", "syntax_pass": true}, {"attribute_expression": "private final Function<Option, String> deprecatedFormatFunction;", "docstring": "\nFunction to format the description for a deprecated option.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Function<Option, String>", "name": "deprecatedFormatFunction", "syntax_pass": true}, {"attribute_expression": "private final PrintWriter printWriter;", "docstring": "\nWhere to print help.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PrintWriter", "name": "printWriter", "syntax_pass": true}, {"attribute_expression": "private final boolean showSince;", "docstring": " Flag to determine if since field should be displayed", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "showSince", "syntax_pass": true}, {"attribute_expression": "private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;", "docstring": "\nThe separator displayed between the long option and its value.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/AmbiguousOptionException.java.AmbiguousOptionException", "name": "AmbiguousOptionException", "file_path": "src/main/java/org/apache/commons/cli/AmbiguousOptionException.java", "superclasses": "UnrecognizedOptionException", "methods": ["[String]createMessage(String,Collection<String>)", "[]AmbiguousOptionException(String,Collection<String>)", "[Collection<String>]getMatchingOptions()"], "method_uris": ["src/main/java/org/apache/commons/cli/AmbiguousOptionException.java.AmbiguousOptionException.[String]createMessage(String,Collection<String>)", "src/main/java/org/apache/commons/cli/AmbiguousOptionException.java.AmbiguousOptionException.[]AmbiguousOptionException(String,Collection<String>)", "src/main/java/org/apache/commons/cli/AmbiguousOptionException.java.AmbiguousOptionException.[Collection<String>]getMatchingOptions()"], "overrides": null, "attributes": [], "class_docstring": "\nException thrown when an option can't be identified from a partial name.\n\n@since 1.3\n", "original_string": "public class AmbiguousOptionException extends UnrecognizedOptionException {\n    /**\n     * This exception {@code serialVersionUID}.\n     */\n    private static final long serialVersionUID = 5829816121277947229L;\n\n    /**\n     * Build the exception message from the specified list of options.\n     *\n     * @param option\n     * @param matchingOptions\n     * @return\n     */\n    private static String createMessage(final String option, final Collection<String> matchingOptions) {\n        final StringBuilder buf = new StringBuilder(\"Ambiguous option: '\");\n        buf.append(option);\n        buf.append(\"'  (could be: \");\n\n        final Iterator<String> it = matchingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(Char.APOS);\n            buf.append(it.next());\n            buf.append(Char.APOS);\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n        buf.append(\")\");\n\n        return buf.toString();\n    }\n\n    /** The list of options matching the partial name specified */\n    private final Collection<String> matchingOptions;\n\n    /**\n     * Constructs a new AmbiguousOptionException.\n     *\n     * @param option the partial option name\n     * @param matchingOptions the options matching the name\n     */\n    public AmbiguousOptionException(final String option, final Collection<String> matchingOptions) {\n        super(createMessage(option, matchingOptions), option);\n        this.matchingOptions = matchingOptions;\n    }\n\n    /**\n     * Gets the options matching the partial name.\n     *\n     * @return a collection of options matching the name\n     */\n    public Collection<String> getMatchingOptions() {\n        return matchingOptions;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5829816121277947229L;", "docstring": "\nThis exception {@code serialVersionUID}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5829816121277947229L", "syntax_pass": true}, {"attribute_expression": "private final Collection<String> matchingOptions;", "docstring": " The list of options matching the partial name specified", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<String>", "name": "matchingOptions", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/PosixParser.java.PosixParser", "name": "PosixParser", "file_path": "src/main/java/org/apache/commons/cli/PosixParser.java", "superclasses": "Parser", "methods": ["[void]burstToken(String,boolean)", "[String[]]flatten(Options,String[],boolean)", "[void]gobble(Iterator<String>)", "[void]init()", "[void]processNonOptionToken(String,boolean)", "[void]processOptionToken(String,boolean)"], "method_uris": ["src/main/java/org/apache/commons/cli/PosixParser.java.PosixParser.[void]burstToken(String,boolean)", "src/main/java/org/apache/commons/cli/PosixParser.java.PosixParser.[String[]]flatten(Options,String[],boolean)", "src/main/java/org/apache/commons/cli/PosixParser.java.PosixParser.[void]gobble(Iterator<String>)", "src/main/java/org/apache/commons/cli/PosixParser.java.PosixParser.[void]init()", "src/main/java/org/apache/commons/cli/PosixParser.java.PosixParser.[void]processNonOptionToken(String,boolean)", "src/main/java/org/apache/commons/cli/PosixParser.java.PosixParser.[void]processOptionToken(String,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nThe class PosixParser provides an implementation of the {@link Parser#flatten(Options,String[],boolean) flatten}\nmethod.\n\n@deprecated since 1.3, use the {@link DefaultParser} instead\n", "original_string": "@Deprecated\npublic class PosixParser extends Parser {\n    /** Holder for flattened tokens */\n    private final List<String> tokens = new ArrayList<>();\n\n    /** Specifies if bursting should continue */\n    private boolean eatTheRest;\n\n    /** Holder for the current option */\n    private Option currentOption;\n\n    /** The command line Options */\n    private Options options;\n\n    /**\n     * Breaks {@code token} into its constituent parts using the following algorithm.\n     *\n     * <ul>\n     * <li>ignore the first character (\"<b>-</b>\")</li>\n     * <li>for each remaining character check if an {@link Option} exists with that id.</li>\n     * <li>if an {@link Option} does exist then add that character prepended with \"<b>-</b>\" to the list of processed\n     * tokens.</li>\n     * <li>if the {@link Option} can have an argument value and there are remaining characters in the token then add the\n     * remaining characters as a token to the list of processed tokens.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS</b> set then add the\n     * special token \"<b>--</b>\" followed by the remaining characters and also the remaining tokens directly to the\n     * processed tokens list.</li>\n     * <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> {@code stopAtNonOption} <b>IS NOT</b> set then add\n     * that character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing at the first non-Option encountered.\n     */\n    protected void burstToken(final String token, final boolean stopAtNonOption) {\n        for (int i = 1; i < token.length(); i++) {\n            final String ch = String.valueOf(token.charAt(i));\n\n            if (!options.hasOption(ch)) {\n                if (stopAtNonOption) {\n                    processNonOptionToken(token.substring(i), true);\n                } else {\n                    tokens.add(token);\n                }\n                break;\n            }\n            tokens.add(\"-\" + ch);\n            currentOption = options.getOption(ch);\n\n            if (currentOption.hasArg() && token.length() != i + 1) {\n                tokens.add(token.substring(i + 1));\n\n                break;\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * An implementation of {@link Parser}'s abstract {@link Parser#flatten(Options,String[],boolean) flatten} method.\n     * </p>\n     *\n     * <p>\n     * The following are the rules used by this flatten method.\n     * </p>\n     * <ol>\n     * <li>if {@code stopAtNonOption} is <b>true</b> then do not burst anymore of {@code arguments} entries, just\n     * add each successive entry without further processing. Otherwise, ignore {@code stopAtNonOption}.</li>\n     * <li>if the current {@code arguments} entry is \"<b>--</b>\" just add the entry to the list of processed\n     * tokens</li>\n     * <li>if the current {@code arguments} entry is \"<b>-</b>\" just add the entry to the list of processed tokens</li>\n     * <li>if the current {@code arguments} entry is two characters in length and the first character is \"<b>-</b>\"\n     * then check if this is a valid {@link Option} id. If it is a valid id, then add the entry to the list of processed\n     * tokens and set the current {@link Option} member. If it is not a valid id and {@code stopAtNonOption} is true,\n     * then the remaining entries are copied to the list of processed tokens. Otherwise, the current entry is ignored.</li>\n     * <li>if the current {@code arguments} entry is more than two characters in length and the first character is\n     * \"<b>-</b>\" then we need to burst the entry to determine its constituents. For more information on the bursting\n     * algorithm see {@link PosixParser#burstToken(String, boolean) burstToken}.</li>\n     * <li>if the current {@code arguments} entry is not handled by any of the previous rules, then the entry is added\n     * to the list of processed tokens.</li>\n     * </ol>\n     *\n     * @param options The command line {@link Options}\n     * @param arguments The command line arguments to be parsed\n     * @param stopAtNonOption Specifies whether to stop flattening when an non option is found.\n     * @return The flattened {@code arguments} String array.\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        init();\n        this.options = options;\n        // an iterator for the command line tokens\n        final Iterator<String> iter = Arrays.asList(arguments).iterator();\n        // process each command line token\n        while (iter.hasNext()) {\n            // get the next command line token\n            final String token = iter.next();\n            if (token != null) {\n                // single or double hyphen\n                if (\"-\".equals(token) || \"--\".equals(token)) {\n                    tokens.add(token);\n                } else if (token.startsWith(\"--\")) {\n                    // handle long option --foo or --foo=bar\n                    final int pos = DefaultParser.indexOfEqual(token);\n                    final String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\n                    final List<String> matchingOpts = options.getMatchingOptions(opt);\n\n                    if (matchingOpts.isEmpty()) {\n                        processNonOptionToken(token, stopAtNonOption);\n                    } else if (matchingOpts.size() > 1) {\n                        throw new AmbiguousOptionException(opt, matchingOpts);\n                    } else {\n                        currentOption = options.getOption(matchingOpts.get(0));\n\n                        tokens.add(\"--\" + currentOption.getLongOpt());\n                        if (pos != -1) {\n                            tokens.add(token.substring(pos + 1));\n                        }\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    if (token.length() == 2 || options.hasOption(token)) {\n                        processOptionToken(token, stopAtNonOption);\n                    } else if (!options.getMatchingOptions(token).isEmpty()) {\n                        final List<String> matchingOpts = options.getMatchingOptions(token);\n                        if (matchingOpts.size() > 1) {\n                            throw new AmbiguousOptionException(token, matchingOpts);\n                        }\n                        final Option opt = options.getOption(matchingOpts.get(0));\n                        processOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n                    }\n                    // requires bursting\n                    else {\n                        burstToken(token, stopAtNonOption);\n                    }\n                } else {\n                    processNonOptionToken(token, stopAtNonOption);\n                }\n            }\n            gobble(iter);\n        }\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Adds the remaining tokens to the processed tokens list.\n     *\n     * @param iter An iterator over the remaining tokens\n     */\n    private void gobble(final Iterator<String> iter) {\n        if (eatTheRest) {\n            while (iter.hasNext()) {\n                tokens.add(iter.next());\n            }\n        }\n    }\n\n    /**\n     * Resets the members to their original state i.e. remove all of {@code tokens} entries and set\n     * {@code eatTheRest} to false.\n     */\n    private void init() {\n        eatTheRest = false;\n        tokens.clear();\n    }\n\n    /**\n     * Add the special token \"<b>--</b>\" and the current {@code value} to the processed tokens list. Then add all the\n     * remaining {@code argument} values to the processed tokens list.\n     *\n     * @param value The current token\n     */\n    private void processNonOptionToken(final String value, final boolean stopAtNonOption) {\n        if (stopAtNonOption && (currentOption == null || !currentOption.hasArg())) {\n            eatTheRest = true;\n            tokens.add(\"--\");\n        }\n\n        tokens.add(value);\n    }\n\n    /**\n     * <p>\n     * If an {@link Option} exists for {@code token} then add the token to the processed list.\n     * </p>\n     *\n     * <p>\n     * If an {@link Option} does not exist and {@code stopAtNonOption} is set then add the remaining tokens to the\n     * processed tokens list directly.\n     * </p>\n     *\n     * @param token The current option token\n     * @param stopAtNonOption Specifies whether flattening should halt at the first non option.\n     */\n    private void processOptionToken(final String token, final boolean stopAtNonOption) {\n        if (stopAtNonOption && !options.hasOption(token)) {\n            eatTheRest = true;\n        }\n\n        if (options.hasOption(token)) {\n            currentOption = options.getOption(token);\n        }\n\n        tokens.add(token);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<String> tokens = new ArrayList<>();", "docstring": " Holder for flattened tokens", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "tokens = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private boolean eatTheRest;", "docstring": " Specifies if bursting should continue", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "eatTheRest", "syntax_pass": true}, {"attribute_expression": "private Option currentOption;", "docstring": " Holder for the current option", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Option", "name": "currentOption", "syntax_pass": true}, {"attribute_expression": "private Options options;", "docstring": " The command line Options", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/MissingOptionException.java.MissingOptionException", "name": "MissingOptionException", "file_path": "src/main/java/org/apache/commons/cli/MissingOptionException.java", "superclasses": "ParseException", "methods": ["[String]createMessage(List<?>)", "[]MissingOptionException(List)", "[]MissingOptionException(String)", "[List]getMissingOptions()"], "method_uris": ["src/main/java/org/apache/commons/cli/MissingOptionException.java.MissingOptionException.[String]createMessage(List<?>)", "src/main/java/org/apache/commons/cli/MissingOptionException.java.MissingOptionException.[]MissingOptionException(List)", "src/main/java/org/apache/commons/cli/MissingOptionException.java.MissingOptionException.[]MissingOptionException(String)", "src/main/java/org/apache/commons/cli/MissingOptionException.java.MissingOptionException.[List]getMissingOptions()"], "overrides": null, "attributes": [], "class_docstring": "\nThrown when a required option has not been provided.\n", "original_string": "public class MissingOptionException extends ParseException {\n    /** This exception {@code serialVersionUID}. */\n    private static final long serialVersionUID = 8161889051578563249L;\n\n    /**\n     * Build the exception message from the specified list of options.\n     *\n     * @param missingOptions the list of missing options and groups\n     */\n    private static String createMessage(final List<?> missingOptions) {\n        final StringBuilder buf = new StringBuilder(\"Missing required option\");\n        buf.append(missingOptions.size() == 1 ? \"\" : \"s\");\n        buf.append(\": \");\n\n        final Iterator<?> it = missingOptions.iterator();\n        while (it.hasNext()) {\n            buf.append(it.next());\n            if (it.hasNext()) {\n                buf.append(\", \");\n            }\n        }\n\n        return buf.toString();\n    }\n\n    /** The list of missing options and groups */\n    private List missingOptions;\n\n    /**\n     * Constructs a new {@code MissingSelectedException} with the specified list of missing options.\n     *\n     * @param missingOptions the list of missing options and groups\n     * @since 1.2\n     */\n    public MissingOptionException(final List missingOptions) {\n        this(createMessage(missingOptions));\n        this.missingOptions = missingOptions;\n    }\n\n    /**\n     * Constructs a new {@code MissingSelectedException} with the specified detail message.\n     *\n     * @param message the detail message\n     */\n    public MissingOptionException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Gets the list of options or option groups missing in the command line parsed.\n     *\n     * @return the missing options, consisting of String instances for simple options, and OptionGroup instances for\n     *         required option groups.\n     * @since 1.2\n     */\n    public List getMissingOptions() {\n        return missingOptions;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 8161889051578563249L;", "docstring": " This exception {@code serialVersionUID}.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 8161889051578563249L", "syntax_pass": true}, {"attribute_expression": "private List missingOptions;", "docstring": " The list of missing options and groups", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List", "name": "missingOptions", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/GnuParser.java.GnuParser", "name": "GnuParser", "file_path": "src/main/java/org/apache/commons/cli/GnuParser.java", "superclasses": "Parser", "methods": ["[String[]]flatten(Options,String[],boolean)"], "method_uris": ["src/main/java/org/apache/commons/cli/GnuParser.java.GnuParser.[String[]]flatten(Options,String[],boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nThe class GnuParser provides an implementation of the {@link Parser#flatten(Options, String[], boolean) flatten}\nmethod.\n\n@deprecated since 1.3, use the {@link DefaultParser} instead\n", "original_string": "@Deprecated\npublic class GnuParser extends Parser {\n    /**\n     * This flatten method does so using the following rules:\n     * <ol>\n     * <li>If an {@link Option} exists for the first character of the {@code arguments} entry <b>AND</b> an\n     * {@link Option} does not exist for the whole {@code argument} then add the first character as an option to the\n     * processed tokens list e.g. \"-D\" and add the rest of the entry to the also.</li>\n     * <li>Otherwise just add the token to the processed tokens list.</li>\n     * </ol>\n     *\n     * @param options The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     */\n    @Override\n    protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) {\n        final List<String> tokens = new ArrayList<>();\n        boolean eatTheRest = false;\n        for (int i = 0; i < arguments.length; i++) {\n            final String arg = arguments[i];\n            if (arg != null) {\n                if (\"--\".equals(arg)) {\n                    eatTheRest = true;\n                    tokens.add(\"--\");\n                } else if (\"-\".equals(arg)) {\n                    tokens.add(\"-\");\n                } else if (arg.startsWith(\"-\")) {\n                    final String opt = Util.stripLeadingHyphens(arg);\n                    if (options.hasOption(opt)) {\n                        tokens.add(arg);\n                    } else {\n                        final int equalPos = DefaultParser.indexOfEqual(opt);\n                        if (equalPos != -1 && options.hasOption(opt.substring(0, equalPos))) {\n                            // the format is --foo=value or -foo=value\n                            tokens.add(arg.substring(0, arg.indexOf(Char.EQUAL))); // --foo\n                            tokens.add(arg.substring(arg.indexOf(Char.EQUAL) + 1)); // value\n                        } else if (options.hasOption(arg.substring(0, 2))) {\n                            // the format is a special properties option (-Dproperty=value)\n                            tokens.add(arg.substring(0, 2)); // -D\n                            tokens.add(arg.substring(2)); // property=value\n                        } else {\n                            eatTheRest = stopAtNonOption;\n                            tokens.add(arg);\n                        }\n                    }\n                } else {\n                    tokens.add(arg);\n                }\n\n                if (eatTheRest) {\n                    for (i++; i < arguments.length; i++) { // NOPMD\n                        tokens.add(arguments[i]);\n                    }\n                }\n            }\n        }\n\n        return tokens.toArray(Util.EMPTY_STRING_ARRAY);\n    }\n}", "super_interfaces": [], "fields": []}]